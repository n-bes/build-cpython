{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-use-of-uninitialized-value", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-use-of-uninitialized-value"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "457", "helpUri": "https://cwe.mitre.org/data/definitions/457.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.13.0b4/"}}, "artifacts": [{"location": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "contents": {"text": "// Cyclic garbage collector implementation for free-threaded build.\n#include \"Python.h\"\n#include \"pycore_brc.h\"           // struct _brc_thread_state\n#include \"pycore_ceval.h\"         // _Py_set_eval_breaker_bit()\n#include \"pycore_context.h\"\n#include \"pycore_dict.h\"          // _PyDict_MaybeUntrack()\n#include \"pycore_initconfig.h\"\n#include \"pycore_interp.h\"        // PyInterpreterState.gc\n#include \"pycore_object.h\"\n#include \"pycore_object_alloc.h\"  // _PyObject_MallocWithType()\n#include \"pycore_object_stack.h\"\n#include \"pycore_pyerrors.h\"\n#include \"pycore_pystate.h\"       // _PyThreadState_GET()\n#include \"pycore_tstate.h\"        // _PyThreadStateImpl\n#include \"pycore_weakref.h\"       // _PyWeakref_ClearRef()\n#include \"pydtrace.h\"\n\n#ifdef Py_GIL_DISABLED\n\ntypedef struct _gc_runtime_state GCState;\n\n#ifdef Py_DEBUG\n#  define GC_DEBUG\n#endif\n\n// Each thread buffers the count of allocated objects in a thread-local\n// variable up to +/- this amount to reduce the overhead of updating\n// the global count.\n#define LOCAL_ALLOC_COUNT_THRESHOLD 512\n\n// Automatically choose the generation that needs collecting.\n#define GENERATION_AUTO (-1)\n\n// A linked list of objects using the `ob_tid` field as the next pointer.\n// The linked list pointers are distinct from any real thread ids, because the\n// thread ids returned by _Py_ThreadId() are also pointers to distinct objects.\n// No thread will confuse its own id with a linked list pointer.\nstruct worklist {\n    uintptr_t head;\n};\n\nstruct worklist_iter {\n    uintptr_t *ptr;   // pointer to current object\n    uintptr_t *next;  // next value of ptr\n};\n\nstruct visitor_args {\n    size_t offset;  // offset of PyObject from start of block\n};\n\n// Per-collection state\nstruct collection_state {\n    struct visitor_args base;\n    PyInterpreterState *interp;\n    GCState *gcstate;\n    Py_ssize_t collected;\n    Py_ssize_t uncollectable;\n    Py_ssize_t long_lived_total;\n    struct worklist unreachable;\n    struct worklist legacy_finalizers;\n    struct worklist wrcb_to_call;\n    struct worklist objs_to_decref;\n};\n\n// iterate over a worklist\n#define WORKSTACK_FOR_EACH(stack, op) \\\n    for ((op) = (PyObject *)(stack)->head; (op) != NULL; (op) = (PyObject *)(op)->ob_tid)\n\n// iterate over a worklist with support for removing the current object\n#define WORKSTACK_FOR_EACH_ITER(stack, iter, op) \\\n    for (worklist_iter_init((iter), &(stack)->head), (op) = (PyObject *)(*(iter)->ptr); \\\n         (op) != NULL; \\\n         worklist_iter_init((iter), (iter)->next), (op) = (PyObject *)(*(iter)->ptr))\n\nstatic void\nworklist_push(struct worklist *worklist, PyObject *op)\n{\n    assert(op->ob_tid == 0);\n    op->ob_tid = worklist->head;\n    worklist->head = (uintptr_t)op;\n}\n\nstatic PyObject *\nworklist_pop(struct worklist *worklist)\n{\n    PyObject *op = (PyObject *)worklist->head;\n    if (op != NULL) {\n        worklist->head = op->ob_tid;\n        _Py_atomic_store_uintptr_relaxed(&op->ob_tid, 0);\n    }\n    return op;\n}\n\nstatic void\nworklist_iter_init(struct worklist_iter *iter, uintptr_t *next)\n{\n    iter->ptr = next;\n    PyObject *op = (PyObject *)*(iter->ptr);\n    if (op) {\n        iter->next = &op->ob_tid;\n    }\n}\n\nstatic void\nworklist_remove(struct worklist_iter *iter)\n{\n    PyObject *op = (PyObject *)*(iter->ptr);\n    *(iter->ptr) = op->ob_tid;\n    op->ob_tid = 0;\n    iter->next = iter->ptr;\n}\n\nstatic inline int\ngc_is_unreachable(PyObject *op)\n{\n    return (op->ob_gc_bits & _PyGC_BITS_UNREACHABLE) != 0;\n}\n\nstatic void\ngc_set_unreachable(PyObject *op)\n{\n    op->ob_gc_bits |= _PyGC_BITS_UNREACHABLE;\n}\n\nstatic void\ngc_clear_unreachable(PyObject *op)\n{\n    op->ob_gc_bits &= ~_PyGC_BITS_UNREACHABLE;\n}\n\n// Initialize the `ob_tid` field to zero if the object is not already\n// initialized as unreachable.\nstatic void\ngc_maybe_init_refs(PyObject *op)\n{\n    if (!gc_is_unreachable(op)) {\n        gc_set_unreachable(op);\n        op->ob_tid = 0;\n    }\n}\n\nstatic inline Py_ssize_t\ngc_get_refs(PyObject *op)\n{\n    return (Py_ssize_t)op->ob_tid;\n}\n\nstatic inline void\ngc_add_refs(PyObject *op, Py_ssize_t refs)\n{\n    assert(_PyObject_GC_IS_TRACKED(op));\n    op->ob_tid += refs;\n}\n\nstatic inline void\ngc_decref(PyObject *op)\n{\n    op->ob_tid -= 1;\n}\n\nstatic void\ndisable_deferred_refcounting(PyObject *op)\n{\n    if (_PyObject_HasDeferredRefcount(op)) {\n        op->ob_gc_bits &= ~_PyGC_BITS_DEFERRED;\n        op->ob_ref_shared -= (1 << _Py_REF_SHARED_SHIFT);\n    }\n}\n\nstatic Py_ssize_t\nmerge_refcount(PyObject *op, Py_ssize_t extra)\n{\n    assert(_PyInterpreterState_GET()->stoptheworld.world_stopped);\n\n    Py_ssize_t refcount = Py_REFCNT(op);\n    refcount += extra;\n\n#ifdef Py_REF_DEBUG\n    _Py_AddRefTotal(_PyThreadState_GET(), extra);\n#endif\n\n    // No atomics necessary; all other threads in this interpreter are paused.\n    op->ob_tid = 0;\n    op->ob_ref_local = 0;\n    op->ob_ref_shared = _Py_REF_SHARED(refcount, _Py_REF_MERGED);\n    return refcount;\n}\n\nstatic void\ngc_restore_tid(PyObject *op)\n{\n    assert(_PyInterpreterState_GET()->stoptheworld.world_stopped);\n    mi_segment_t *segment = _mi_ptr_segment(op);\n    if (_Py_REF_IS_MERGED(op->ob_ref_shared)) {\n        op->ob_tid = 0;\n    }\n    else {\n        // NOTE: may change ob_tid if the object was re-initialized by\n        // a different thread or its segment was abandoned and reclaimed.\n        // The segment thread id might be zero, in which case we should\n        // ensure the refcounts are now merged.\n        op->ob_tid = segment->thread_id;\n        if (op->ob_tid == 0) {\n            merge_refcount(op, 0);\n        }\n    }\n}\n\nstatic void\ngc_restore_refs(PyObject *op)\n{\n    if (gc_is_unreachable(op)) {\n        gc_restore_tid(op);\n        gc_clear_unreachable(op);\n    }\n}\n\n// Given a mimalloc memory block return the PyObject stored in it or NULL if\n// the block is not allocated or the object is not tracked or is immortal.\nstatic PyObject *\nop_from_block(void *block, void *arg, bool include_frozen)\n{\n    struct visitor_args *a = arg;\n    if (block == NULL) {\n        return NULL;\n    }\n    PyObject *op = (PyObject *)((char*)block + a->offset);\n    assert(PyObject_IS_GC(op));\n    if (!_PyObject_GC_IS_TRACKED(op)) {\n        return NULL;\n    }\n    if (!include_frozen && (op->ob_gc_bits & _PyGC_BITS_FROZEN) != 0) {\n        return NULL;\n    }\n    return op;\n}\n\nstatic int\ngc_visit_heaps_lock_held(PyInterpreterState *interp, mi_block_visit_fun *visitor,\n                         struct visitor_args *arg)\n{\n    // Offset of PyObject header from start of memory block.\n    Py_ssize_t offset_base = 0;\n    if (_PyMem_DebugEnabled()) {\n        // The debug allocator adds two words at the beginning of each block.\n        offset_base += 2 * sizeof(size_t);\n    }\n\n    // Objects with Py_TPFLAGS_PREHEADER have two extra fields\n    Py_ssize_t offset_pre = offset_base + 2 * sizeof(PyObject*);\n\n    // visit each thread's heaps for GC objects\n    for (PyThreadState *p = interp->threads.head; p != NULL; p = p->next) {\n        struct _mimalloc_thread_state *m = &((_PyThreadStateImpl *)p)->mimalloc;\n        if (!_Py_atomic_load_int(&m->initialized)) {\n            // The thread may not have called tstate_mimalloc_bind() yet.\n            continue;\n        }\n\n        arg->offset = offset_base;\n        if (!mi_heap_visit_blocks(&m->heaps[_Py_MIMALLOC_HEAP_GC], true,\n                                  visitor, arg)) {\n            return -1;\n        }\n        arg->offset = offset_pre;\n        if (!mi_heap_visit_blocks(&m->heaps[_Py_MIMALLOC_HEAP_GC_PRE], true,\n                                  visitor, arg)) {\n            return -1;\n        }\n    }\n\n    // visit blocks in the per-interpreter abandoned pool (from dead threads)\n    mi_abandoned_pool_t *pool = &interp->mimalloc.abandoned_pool;\n    arg->offset = offset_base;\n    if (!_mi_abandoned_pool_visit_blocks(pool, _Py_MIMALLOC_HEAP_GC, true,\n                                         visitor, arg)) {\n        return -1;\n    }\n    arg->offset = offset_pre;\n    if (!_mi_abandoned_pool_visit_blocks(pool, _Py_MIMALLOC_HEAP_GC_PRE, true,\n                                         visitor, arg)) {\n        return -1;\n    }\n    return 0;\n}\n\n// Visits all GC objects in the interpreter's heaps.\n// NOTE: It is not safe to allocate or free any mimalloc managed memory while\n// this function is running.\nstatic int\ngc_visit_heaps(PyInterpreterState *interp, mi_block_visit_fun *visitor,\n               struct visitor_args *arg)\n{\n    // Other threads in the interpreter must be paused so that we can safely\n    // traverse their heaps.\n    assert(interp->stoptheworld.world_stopped);\n\n    int err;\n    HEAD_LOCK(&_PyRuntime);\n    err = gc_visit_heaps_lock_held(interp, visitor, arg);\n    HEAD_UNLOCK(&_PyRuntime);\n    return err;\n}\n\nstatic void\nmerge_queued_objects(_PyThreadStateImpl *tstate, struct collection_state *state)\n{\n    struct _brc_thread_state *brc = &tstate->brc;\n    _PyObjectStack_Merge(&brc->local_objects_to_merge, &brc->objects_to_merge);\n\n    PyObject *op;\n    while ((op = _PyObjectStack_Pop(&brc->local_objects_to_merge)) != NULL) {\n        // Subtract one when merging because the queue had a reference.\n        Py_ssize_t refcount = merge_refcount(op, -1);\n\n        if (!_PyObject_GC_IS_TRACKED(op) && refcount == 0) {\n            // GC objects with zero refcount are handled subsequently by the\n            // GC as if they were cyclic trash, but we have to handle dead\n            // non-GC objects here. Add one to the refcount so that we can\n            // decref and deallocate the object once we start the world again.\n            op->ob_ref_shared += (1 << _Py_REF_SHARED_SHIFT);\n#ifdef Py_REF_DEBUG\n            _Py_IncRefTotal(_PyThreadState_GET());\n#endif\n            worklist_push(&state->objs_to_decref, op);\n        }\n    }\n}\n\nstatic void\nmerge_all_queued_objects(PyInterpreterState *interp, struct collection_state *state)\n{\n    HEAD_LOCK(&_PyRuntime);\n    for (PyThreadState *p = interp->threads.head; p != NULL; p = p->next) {\n        merge_queued_objects((_PyThreadStateImpl *)p, state);\n    }\n    HEAD_UNLOCK(&_PyRuntime);\n}\n\nstatic void\nprocess_delayed_frees(PyInterpreterState *interp)\n{\n    // In STW status, we can observe the latest write sequence by\n    // advancing the write sequence immediately.\n    _Py_qsbr_advance(&interp->qsbr);\n    _PyThreadStateImpl *current_tstate = (_PyThreadStateImpl *)_PyThreadState_GET();\n    _Py_qsbr_quiescent_state(current_tstate->qsbr);\n    HEAD_LOCK(&_PyRuntime);\n    PyThreadState *tstate = interp->threads.head;\n    while (tstate != NULL) {\n        _PyMem_ProcessDelayed(tstate);\n        tstate = (PyThreadState *)tstate->next;\n    }\n    HEAD_UNLOCK(&_PyRuntime);\n}\n\n// Subtract an incoming reference from the computed \"gc_refs\" refcount.\nstatic int\nvisit_decref(PyObject *op, void *arg)\n{\n    if (_PyObject_GC_IS_TRACKED(op) && !_Py_IsImmortal(op)) {\n        // If update_refs hasn't reached this object yet, mark it\n        // as (tentatively) unreachable and initialize ob_tid to zero.\n        gc_maybe_init_refs(op);\n        gc_decref(op);\n    }\n    return 0;\n}\n\n// Compute the number of external references to objects in the heap\n// by subtracting internal references from the refcount. The difference is\n// computed in the ob_tid field (we restore it later).\nstatic bool\nupdate_refs(const mi_heap_t *heap, const mi_heap_area_t *area,\n            void *block, size_t block_size, void *args)\n{\n    PyObject *op = op_from_block(block, args, false);\n    if (op == NULL) {\n        return true;\n    }\n\n    // Exclude immortal objects from garbage collection\n    if (_Py_IsImmortal(op)) {\n        op->ob_tid = 0;\n        _PyObject_GC_UNTRACK(op);\n        gc_clear_unreachable(op);\n        return true;\n    }\n\n    Py_ssize_t refcount = Py_REFCNT(op);\n    refcount -= _PyObject_HasDeferredRefcount(op);\n    _PyObject_ASSERT(op, refcount >= 0);\n\n    if (refcount > 0 && !_PyObject_HasDeferredRefcount(op)) {\n        // Untrack tuples and dicts as necessary in this pass, but not objects\n        // with zero refcount, which we will want to collect.\n        if (PyTuple_CheckExact(op)) {\n            _PyTuple_MaybeUntrack(op);\n            if (!_PyObject_GC_IS_TRACKED(op)) {\n                gc_restore_refs(op);\n                return true;\n            }\n        }\n        else if (PyDict_CheckExact(op)) {\n            _PyDict_MaybeUntrack(op);\n            if (!_PyObject_GC_IS_TRACKED(op)) {\n                gc_restore_refs(op);\n                return true;\n            }\n        }\n    }\n\n    // We repurpose ob_tid to compute \"gc_refs\", the number of external\n    // references to the object (i.e., from outside the GC heaps). This means\n    // that ob_tid is no longer a valid thread id until it is restored by\n    // scan_heap_visitor(). Until then, we cannot use the standard reference\n    // counting functions or allow other threads to run Python code.\n    gc_maybe_init_refs(op);\n\n    // Add the actual refcount to ob_tid.\n    gc_add_refs(op, refcount);\n\n    // Subtract internal references from ob_tid. Objects with ob_tid > 0\n    // are directly reachable from outside containers, and so can't be\n    // collected.\n    Py_TYPE(op)->tp_traverse(op, visit_decref, NULL);\n    return true;\n}\n\nstatic int\nvisit_clear_unreachable(PyObject *op, _PyObjectStack *stack)\n{\n    if (gc_is_unreachable(op)) {\n        _PyObject_ASSERT(op, _PyObject_GC_IS_TRACKED(op));\n        gc_clear_unreachable(op);\n        return _PyObjectStack_Push(stack, op);\n    }\n    return 0;\n}\n\n// Transitively clear the unreachable bit on all objects reachable from op.\nstatic int\nmark_reachable(PyObject *op)\n{\n    _PyObjectStack stack = { NULL };\n    do {\n        traverseproc traverse = Py_TYPE(op)->tp_traverse;\n        if (traverse(op, (visitproc)&visit_clear_unreachable, &stack) < 0) {\n            _PyObjectStack_Clear(&stack);\n            return -1;\n        }\n        op = _PyObjectStack_Pop(&stack);\n    } while (op != NULL);\n    return 0;\n}\n\n#ifdef GC_DEBUG\nstatic bool\nvalidate_refcounts(const mi_heap_t *heap, const mi_heap_area_t *area,\n                   void *block, size_t block_size, void *args)\n{\n    PyObject *op = op_from_block(block, args, false);\n    if (op == NULL) {\n        return true;\n    }\n\n    _PyObject_ASSERT_WITH_MSG(op, !gc_is_unreachable(op),\n                              \"object should not be marked as unreachable yet\");\n\n    if (_Py_REF_IS_MERGED(op->ob_ref_shared)) {\n        _PyObject_ASSERT_WITH_MSG(op, op->ob_tid == 0,\n                                  \"merged objects should have ob_tid == 0\");\n    }\n    else if (!_Py_IsImmortal(op)) {\n        _PyObject_ASSERT_WITH_MSG(op, op->ob_tid != 0,\n                                  \"unmerged objects should have ob_tid != 0\");\n    }\n\n    return true;\n}\n\nstatic bool\nvalidate_gc_objects(const mi_heap_t *heap, const mi_heap_area_t *area,\n                    void *block, size_t block_size, void *args)\n{\n    PyObject *op = op_from_block(block, args, false);\n    if (op == NULL) {\n        return true;\n    }\n\n    _PyObject_ASSERT(op, gc_is_unreachable(op));\n    _PyObject_ASSERT_WITH_MSG(op, gc_get_refs(op) >= 0,\n                                  \"refcount is too small\");\n    return true;\n}\n#endif\n\nstatic bool\nmark_heap_visitor(const mi_heap_t *heap, const mi_heap_area_t *area,\n                  void *block, size_t block_size, void *args)\n{\n    PyObject *op = op_from_block(block, args, false);\n    if (op == NULL) {\n        return true;\n    }\n\n    _PyObject_ASSERT_WITH_MSG(op, gc_get_refs(op) >= 0,\n                                  \"refcount is too small\");\n\n    if (gc_is_unreachable(op) && gc_get_refs(op) != 0) {\n        // Object is reachable but currently marked as unreachable.\n        // Mark it as reachable and traverse its pointers to find\n        // any other object that may be directly reachable from it.\n        gc_clear_unreachable(op);\n\n        // Transitively mark reachable objects by clearing the unreachable flag.\n        if (mark_reachable(op) < 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nstatic bool\nrestore_refs(const mi_heap_t *heap, const mi_heap_area_t *area,\n             void *block, size_t block_size, void *args)\n{\n    PyObject *op = op_from_block(block, args, false);\n    if (op == NULL) {\n        return true;\n    }\n    gc_restore_tid(op);\n    gc_clear_unreachable(op);\n    return true;\n}\n\n/* Return true if object has a pre-PEP 442 finalization method. */\nstatic int\nhas_legacy_finalizer(PyObject *op)\n{\n    return Py_TYPE(op)->tp_del != NULL;\n}\n\nstatic bool\nscan_heap_visitor(const mi_heap_t *heap, const mi_heap_area_t *area,\n                  void *block, size_t block_size, void *args)\n{\n    PyObject *op = op_from_block(block, args, false);\n    if (op == NULL) {\n        return true;\n    }\n\n    struct collection_state *state = (struct collection_state *)args;\n    if (gc_is_unreachable(op)) {\n        // Disable deferred refcounting for unreachable objects so that they\n        // are collected immediately after finalization.\n        disable_deferred_refcounting(op);\n\n        // Merge and add one to the refcount to prevent deallocation while we\n        // are holding on to it in a worklist.\n        merge_refcount(op, 1);\n\n        if (has_legacy_finalizer(op)) {\n            // would be unreachable, but has legacy finalizer\n            gc_clear_unreachable(op);\n            worklist_push(&state->legacy_finalizers, op);\n        }\n        else {\n            worklist_push(&state->unreachable, op);\n        }\n    }\n    else {\n        // object is reachable, restore `ob_tid`; we're done with these objects\n        gc_restore_tid(op);\n        state->long_lived_total++;\n    }\n\n    return true;\n}\n\nstatic int\nmove_legacy_finalizer_reachable(struct collection_state *state);\n\nstatic int\ndeduce_unreachable_heap(PyInterpreterState *interp,\n                        struct collection_state *state)\n{\n\n#ifdef GC_DEBUG\n    // Check that all objects are marked as unreachable and that the computed\n    // reference count difference (stored in `ob_tid`) is non-negative.\n    gc_visit_heaps(interp, &validate_refcounts, &state->base);\n#endif\n\n    // Identify objects that are directly reachable from outside the GC heap\n    // by computing the difference between the refcount and the number of\n    // incoming references.\n    gc_visit_heaps(interp, &update_refs, &state->base);\n\n#ifdef GC_DEBUG\n    // Check that all objects are marked as unreachable and that the computed\n    // reference count difference (stored in `ob_tid`) is non-negative.\n    gc_visit_heaps(interp, &validate_gc_objects, &state->base);\n#endif\n\n    // Transitively mark reachable objects by clearing the\n    // _PyGC_BITS_UNREACHABLE flag.\n    if (gc_visit_heaps(interp, &mark_heap_visitor, &state->base) < 0) {\n        // On out-of-memory, restore the refcounts and bail out.\n        gc_visit_heaps(interp, &restore_refs, &state->base);\n        return -1;\n    }\n\n    // Identify remaining unreachable objects and push them onto a stack.\n    // Restores ob_tid for reachable objects.\n    gc_visit_heaps(interp, &scan_heap_visitor, &state->base);\n\n    if (state->legacy_finalizers.head) {\n        // There may be objects reachable from legacy finalizers that are in\n        // the unreachable set. We need to mark them as reachable.\n        if (move_legacy_finalizer_reachable(state) < 0) {\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\nstatic int\nmove_legacy_finalizer_reachable(struct collection_state *state)\n{\n    // Clear the reachable bit on all objects transitively reachable\n    // from the objects with legacy finalizers.\n    PyObject *op;\n    WORKSTACK_FOR_EACH(&state->legacy_finalizers, op) {\n        if (mark_reachable(op) < 0) {\n            return -1;\n        }\n    }\n\n    // Move the reachable objects from the unreachable worklist to the legacy\n    // finalizer worklist.\n    struct worklist_iter iter;\n    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n        if (!gc_is_unreachable(op)) {\n            worklist_remove(&iter);\n            worklist_push(&state->legacy_finalizers, op);\n        }\n    }\n\n    return 0;\n}\n\n// Clear all weakrefs to unreachable objects. Weakrefs with callbacks are\n// enqueued in `wrcb_to_call`, but not invoked yet.\nstatic void\nclear_weakrefs(struct collection_state *state)\n{\n    PyObject *op;\n    WORKSTACK_FOR_EACH(&state->unreachable, op) {\n        if (PyWeakref_Check(op)) {\n            // Clear weakrefs that are themselves unreachable to ensure their\n            // callbacks will not be executed later from a `tp_clear()`\n            // inside delete_garbage(). That would be unsafe: it could\n            // resurrect a dead object or access a an already cleared object.\n            // See bpo-38006 for one example.\n            _PyWeakref_ClearRef((PyWeakReference *)op);\n        }\n\n        if (!_PyType_SUPPORTS_WEAKREFS(Py_TYPE(op))) {\n            continue;\n        }\n\n        // NOTE: This is never triggered for static types so we can avoid the\n        // (slightly) more costly _PyObject_GET_WEAKREFS_LISTPTR().\n        PyWeakReference **wrlist = _PyObject_GET_WEAKREFS_LISTPTR_FROM_OFFSET(op);\n\n        // `op` may have some weakrefs.  March over the list, clear\n        // all the weakrefs, and enqueue the weakrefs with callbacks\n        // that must be called into wrcb_to_call.\n        for (PyWeakReference *wr = *wrlist; wr != NULL; wr = *wrlist) {\n            // _PyWeakref_ClearRef clears the weakref but leaves\n            // the callback pointer intact.  Obscure: it also\n            // changes *wrlist.\n            _PyObject_ASSERT((PyObject *)wr, wr->wr_object == op);\n            _PyWeakref_ClearRef(wr);\n            _PyObject_ASSERT((PyObject *)wr, wr->wr_object == Py_None);\n\n            // We do not invoke callbacks for weakrefs that are themselves\n            // unreachable. This is partly for historical reasons: weakrefs\n            // predate safe object finalization, and a weakref that is itself\n            // unreachable may have a callback that resurrects other\n            // unreachable objects.\n            if (wr->wr_callback == NULL || gc_is_unreachable((PyObject *)wr)) {\n                continue;\n            }\n\n            // Create a new reference so that wr can't go away before we can\n            // process it again.\n            merge_refcount((PyObject *)wr, 1);\n\n            // Enqueue weakref to be called later.\n            worklist_push(&state->wrcb_to_call, (PyObject *)wr);\n        }\n    }\n}\n\nstatic void\ncall_weakref_callbacks(struct collection_state *state)\n{\n    // Invoke the callbacks we decided to honor.\n    PyObject *op;\n    while ((op = worklist_pop(&state->wrcb_to_call)) != NULL) {\n        _PyObject_ASSERT(op, PyWeakref_Check(op));\n\n        PyWeakReference *wr = (PyWeakReference *)op;\n        PyObject *callback = wr->wr_callback;\n        _PyObject_ASSERT(op, callback != NULL);\n\n        /* copy-paste of weakrefobject.c's handle_callback() */\n        PyObject *temp = PyObject_CallOneArg(callback, (PyObject *)wr);\n        if (temp == NULL) {\n            PyErr_WriteUnraisable(callback);\n        }\n        else {\n            Py_DECREF(temp);\n        }\n\n        Py_DECREF(op);  // drop worklist reference\n    }\n}\n\n\nstatic GCState *\nget_gc_state(void)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    return &interp->gc;\n}\n\n\nvoid\n_PyGC_InitState(GCState *gcstate)\n{\n    // TODO: move to pycore_runtime_init.h once the incremental GC lands.\n    gcstate->young.threshold = 2000;\n}\n\n\nPyStatus\n_PyGC_Init(PyInterpreterState *interp)\n{\n    GCState *gcstate = &interp->gc;\n\n    // gh-117783: immortalize objects that would use deferred refcounting\n    // once the first non-main thread is created (but not in subinterpreters).\n    gcstate->immortalize = _Py_IsMainInterpreter(interp) ? 0 : -1;\n\n    gcstate->garbage = PyList_New(0);\n    if (gcstate->garbage == NULL) {\n        return _PyStatus_NO_MEMORY();\n    }\n\n    gcstate->callbacks = PyList_New(0);\n    if (gcstate->callbacks == NULL) {\n        return _PyStatus_NO_MEMORY();\n    }\n\n    return _PyStatus_OK();\n}\n\nstatic void\ndebug_cycle(const char *msg, PyObject *op)\n{\n    PySys_FormatStderr(\"gc: %s <%s %p>\\n\",\n                       msg, Py_TYPE(op)->tp_name, op);\n}\n\n/* Run first-time finalizers (if any) on all the objects in collectable.\n * Note that this may remove some (or even all) of the objects from the\n * list, due to refcounts falling to 0.\n */\nstatic void\nfinalize_garbage(struct collection_state *state)\n{\n    // NOTE: the unreachable worklist holds a strong reference to the object\n    // to prevent it from being deallocated while we are holding on to it.\n    PyObject *op;\n    WORKSTACK_FOR_EACH(&state->unreachable, op) {\n        if (!_PyGC_FINALIZED(op)) {\n            destructor finalize = Py_TYPE(op)->tp_finalize;\n            if (finalize != NULL) {\n                _PyGC_SET_FINALIZED(op);\n                finalize(op);\n                assert(!_PyErr_Occurred(_PyThreadState_GET()));\n            }\n        }\n    }\n}\n\n// Break reference cycles by clearing the containers involved.\nstatic void\ndelete_garbage(struct collection_state *state)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    GCState *gcstate = state->gcstate;\n\n    assert(!_PyErr_Occurred(tstate));\n\n    PyObject *op;\n    while ((op = worklist_pop(&state->objs_to_decref)) != NULL) {\n        Py_DECREF(op);\n    }\n\n    while ((op = worklist_pop(&state->unreachable)) != NULL) {\n        _PyObject_ASSERT(op, gc_is_unreachable(op));\n\n        // Clear the unreachable flag.\n        gc_clear_unreachable(op);\n\n        if (!_PyObject_GC_IS_TRACKED(op)) {\n            // Object might have been untracked by some other tp_clear() call.\n            Py_DECREF(op);  // drop the reference from the worklist\n            continue;\n        }\n\n        state->collected++;\n\n        if (gcstate->debug & _PyGC_DEBUG_SAVEALL) {\n            assert(gcstate->garbage != NULL);\n            if (PyList_Append(gcstate->garbage, op) < 0) {\n                _PyErr_Clear(tstate);\n            }\n        }\n        else {\n            inquiry clear = Py_TYPE(op)->tp_clear;\n            if (clear != NULL) {\n                (void) clear(op);\n                if (_PyErr_Occurred(tstate)) {\n                    PyErr_FormatUnraisable(\"Exception ignored in tp_clear of %s\",\n                                           Py_TYPE(op)->tp_name);\n                }\n            }\n        }\n\n        Py_DECREF(op);  // drop the reference from the worklist\n    }\n}\n\nstatic void\nhandle_legacy_finalizers(struct collection_state *state)\n{\n    GCState *gcstate = state->gcstate;\n    assert(gcstate->garbage != NULL);\n\n    PyObject *op;\n    while ((op = worklist_pop(&state->legacy_finalizers)) != NULL) {\n        state->uncollectable++;\n\n        if (gcstate->debug & _PyGC_DEBUG_UNCOLLECTABLE) {\n            debug_cycle(\"uncollectable\", op);\n        }\n\n        if ((gcstate->debug & _PyGC_DEBUG_SAVEALL) || has_legacy_finalizer(op)) {\n            if (PyList_Append(gcstate->garbage, op) < 0) {\n                PyErr_Clear();\n            }\n        }\n        Py_DECREF(op);  // drop worklist reference\n    }\n}\n\n// Show stats for objects in each generations\nstatic void\nshow_stats_each_generations(GCState *gcstate)\n{\n    // TODO\n}\n\n// Traversal callback for handle_resurrected_objects.\nstatic int\nvisit_decref_unreachable(PyObject *op, void *data)\n{\n    if (gc_is_unreachable(op) && _PyObject_GC_IS_TRACKED(op)) {\n        op->ob_ref_local -= 1;\n    }\n    return 0;\n}\n\n// Handle objects that may have resurrected after a call to 'finalize_garbage'.\nstatic int\nhandle_resurrected_objects(struct collection_state *state)\n{\n    // First, find externally reachable objects by computing the reference\n    // count difference in ob_ref_local. We can't use ob_tid here because\n    // that's already used to store the unreachable worklist.\n    PyObject *op;\n    struct worklist_iter iter;\n    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n        assert(gc_is_unreachable(op));\n        assert(_Py_REF_IS_MERGED(op->ob_ref_shared));\n\n        if (!_PyObject_GC_IS_TRACKED(op)) {\n            // Object was untracked by a finalizer. Schedule it for a Py_DECREF\n            // after we finish with the stop-the-world pause.\n            gc_clear_unreachable(op);\n            worklist_remove(&iter);\n            worklist_push(&state->objs_to_decref, op);\n            continue;\n        }\n\n        Py_ssize_t refcount = (op->ob_ref_shared >> _Py_REF_SHARED_SHIFT);\n        if (refcount > INT32_MAX) {\n            // The refcount is too big to fit in `ob_ref_local`. Mark the\n            // object as immortal and bail out.\n            gc_clear_unreachable(op);\n            worklist_remove(&iter);\n            _Py_SetImmortal(op);\n            continue;\n        }\n\n        op->ob_ref_local += (uint32_t)refcount;\n\n        // Subtract one to account for the reference from the worklist.\n        op->ob_ref_local -= 1;\n\n        traverseproc traverse = Py_TYPE(op)->tp_traverse;\n        (void) traverse(op,\n            (visitproc)visit_decref_unreachable,\n            NULL);\n    }\n\n    // Find resurrected objects\n    bool any_resurrected = false;\n    WORKSTACK_FOR_EACH(&state->unreachable, op) {\n        int32_t gc_refs = (int32_t)op->ob_ref_local;\n        op->ob_ref_local = 0;  // restore ob_ref_local\n\n        _PyObject_ASSERT(op, gc_refs >= 0);\n\n        if (gc_is_unreachable(op) && gc_refs > 0) {\n            // Clear the unreachable flag on any transitively reachable objects\n            // from this one.\n            any_resurrected = true;\n            gc_clear_unreachable(op);\n            if (mark_reachable(op) < 0) {\n                return -1;\n            }\n        }\n    }\n\n    if (any_resurrected) {\n        // Remove resurrected objects from the unreachable list.\n        WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n            if (!gc_is_unreachable(op)) {\n                _PyObject_ASSERT(op, Py_REFCNT(op) > 1);\n                worklist_remove(&iter);\n                merge_refcount(op, -1);  // remove worklist reference\n            }\n        }\n    }\n\n#ifdef GC_DEBUG\n    WORKSTACK_FOR_EACH(&state->unreachable, op) {\n        _PyObject_ASSERT(op, gc_is_unreachable(op));\n        _PyObject_ASSERT(op, _PyObject_GC_IS_TRACKED(op));\n        _PyObject_ASSERT(op, op->ob_ref_local == 0);\n        _PyObject_ASSERT(op, _Py_REF_IS_MERGED(op->ob_ref_shared));\n    }\n#endif\n\n    return 0;\n}\n\n\n/* Invoke progress callbacks to notify clients that garbage collection\n * is starting or stopping\n */\nstatic void\ninvoke_gc_callback(PyThreadState *tstate, const char *phase,\n                   int generation, Py_ssize_t collected,\n                   Py_ssize_t uncollectable)\n{\n    assert(!_PyErr_Occurred(tstate));\n\n    /* we may get called very early */\n    GCState *gcstate = &tstate->interp->gc;\n    if (gcstate->callbacks == NULL) {\n        return;\n    }\n\n    /* The local variable cannot be rebound, check it for sanity */\n    assert(PyList_CheckExact(gcstate->callbacks));\n    PyObject *info = NULL;\n    if (PyList_GET_SIZE(gcstate->callbacks) != 0) {\n        info = Py_BuildValue(\"{sisnsn}\",\n            \"generation\", generation,\n            \"collected\", collected,\n            \"uncollectable\", uncollectable);\n        if (info == NULL) {\n            PyErr_FormatUnraisable(\"Exception ignored on invoking gc callbacks\");\n            return;\n        }\n    }\n\n    PyObject *phase_obj = PyUnicode_FromString(phase);\n    if (phase_obj == NULL) {\n        Py_XDECREF(info);\n        PyErr_FormatUnraisable(\"Exception ignored on invoking gc callbacks\");\n        return;\n    }\n\n    PyObject *stack[] = {phase_obj, info};\n    for (Py_ssize_t i=0; i<PyList_GET_SIZE(gcstate->callbacks); i++) {\n        PyObject *r, *cb = PyList_GET_ITEM(gcstate->callbacks, i);\n        Py_INCREF(cb); /* make sure cb doesn't go away */\n        r = PyObject_Vectorcall(cb, stack, 2, NULL);\n        if (r == NULL) {\n            PyErr_WriteUnraisable(cb);\n        }\n        else {\n            Py_DECREF(r);\n        }\n        Py_DECREF(cb);\n    }\n    Py_DECREF(phase_obj);\n    Py_XDECREF(info);\n    assert(!_PyErr_Occurred(tstate));\n}\n\nstatic void\ncleanup_worklist(struct worklist *worklist)\n{\n    PyObject *op;\n    while ((op = worklist_pop(worklist)) != NULL) {\n        gc_clear_unreachable(op);\n        Py_DECREF(op);\n    }\n}\n\nstatic bool\ngc_should_collect(GCState *gcstate)\n{\n    int count = _Py_atomic_load_int_relaxed(&gcstate->young.count);\n    int threshold = gcstate->young.threshold;\n    if (count <= threshold || threshold == 0 || !gcstate->enabled) {\n        return false;\n    }\n    // Avoid quadratic behavior by scaling threshold to the number of live\n    // objects. A few tests rely on immediate scheduling of the GC so we ignore\n    // the scaled threshold if generations[1].threshold is set to zero.\n    return (count > gcstate->long_lived_total / 4 ||\n            gcstate->old[0].threshold == 0);\n}\n\nstatic void\nrecord_allocation(PyThreadState *tstate)\n{\n    struct _gc_thread_state *gc = &((_PyThreadStateImpl *)tstate)->gc;\n\n    // We buffer the allocation count to avoid the overhead of atomic\n    // operations for every allocation.\n    gc->alloc_count++;\n    if (gc->alloc_count >= LOCAL_ALLOC_COUNT_THRESHOLD) {\n        // TODO: Use Py_ssize_t for the generation count.\n        GCState *gcstate = &tstate->interp->gc;\n        _Py_atomic_add_int(&gcstate->young.count, (int)gc->alloc_count);\n        gc->alloc_count = 0;\n\n        if (gc_should_collect(gcstate) &&\n            !_Py_atomic_load_int_relaxed(&gcstate->collecting))\n        {\n            _Py_ScheduleGC(tstate);\n        }\n    }\n}\n\nstatic void\nrecord_deallocation(PyThreadState *tstate)\n{\n    struct _gc_thread_state *gc = &((_PyThreadStateImpl *)tstate)->gc;\n\n    gc->alloc_count--;\n    if (gc->alloc_count <= -LOCAL_ALLOC_COUNT_THRESHOLD) {\n        GCState *gcstate = &tstate->interp->gc;\n        _Py_atomic_add_int(&gcstate->young.count, (int)gc->alloc_count);\n        gc->alloc_count = 0;\n    }\n}\n\nstatic void\ngc_collect_internal(PyInterpreterState *interp, struct collection_state *state, int generation)\n{\n    _PyEval_StopTheWorld(interp);\n\n    // update collection and allocation counters\n    if (generation+1 < NUM_GENERATIONS) {\n        state->gcstate->old[generation].count += 1;\n    }\n\n    state->gcstate->young.count = 0;\n    for (int i = 1; i <= generation; ++i) {\n        state->gcstate->old[i-1].count = 0;\n    }\n\n    // merge refcounts for all queued objects\n    merge_all_queued_objects(interp, state);\n    process_delayed_frees(interp);\n\n    // Find unreachable objects\n    int err = deduce_unreachable_heap(interp, state);\n    if (err < 0) {\n        _PyEval_StartTheWorld(interp);\n        PyErr_NoMemory();\n        return;\n    }\n\n    // Print debugging information.\n    if (interp->gc.debug & _PyGC_DEBUG_COLLECTABLE) {\n        PyObject *op;\n        WORKSTACK_FOR_EACH(&state->unreachable, op) {\n            debug_cycle(\"collectable\", op);\n        }\n    }\n\n    // Record the number of live GC objects\n    interp->gc.long_lived_total = state->long_lived_total;\n\n    // Clear weakrefs and enqueue callbacks (but do not call them).\n    clear_weakrefs(state);\n    _PyEval_StartTheWorld(interp);\n\n    // Deallocate any object from the refcount merge step\n    cleanup_worklist(&state->objs_to_decref);\n\n    // Call weakref callbacks and finalizers after unpausing other threads to\n    // avoid potential deadlocks.\n    call_weakref_callbacks(state);\n    finalize_garbage(state);\n\n    // Handle any objects that may have resurrected after the finalization.\n    _PyEval_StopTheWorld(interp);\n    err = handle_resurrected_objects(state);\n    // Clear free lists in all threads\n    _PyGC_ClearAllFreeLists(interp);\n    _PyEval_StartTheWorld(interp);\n\n    if (err < 0) {\n        cleanup_worklist(&state->unreachable);\n        cleanup_worklist(&state->legacy_finalizers);\n        cleanup_worklist(&state->wrcb_to_call);\n        cleanup_worklist(&state->objs_to_decref);\n        PyErr_NoMemory();\n        return;\n    }\n\n    // Call tp_clear on objects in the unreachable set. This will cause\n    // the reference cycles to be broken. It may also cause some objects\n    // to be freed.\n    delete_garbage(state);\n\n    // Append objects with legacy finalizers to the \"gc.garbage\" list.\n    handle_legacy_finalizers(state);\n}\n\n/* This is the main function.  Read this to understand how the\n * collection process works. */\nstatic Py_ssize_t\ngc_collect_main(PyThreadState *tstate, int generation, _PyGC_Reason reason)\n{\n    Py_ssize_t m = 0; /* # objects collected */\n    Py_ssize_t n = 0; /* # unreachable objects that couldn't be collected */\n    PyTime_t t1 = 0;   /* initialize to prevent a compiler warning */\n    GCState *gcstate = &tstate->interp->gc;\n\n    // gc_collect_main() must not be called before _PyGC_Init\n    // or after _PyGC_Fini()\n    assert(gcstate->garbage != NULL);\n    assert(!_PyErr_Occurred(tstate));\n\n    int expected = 0;\n    if (!_Py_atomic_compare_exchange_int(&gcstate->collecting, &expected, 1)) {\n        // Don't start a garbage collection if one is already in progress.\n        return 0;\n    }\n\n    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n        // Don't collect if the threshold is not exceeded.\n        _Py_atomic_store_int(&gcstate->collecting, 0);\n        return 0;\n    }\n\n    assert(generation >= 0 && generation < NUM_GENERATIONS);\n\n#ifdef Py_STATS\n    if (_Py_stats) {\n        _Py_stats->object_stats.object_visits = 0;\n    }\n#endif\n    GC_STAT_ADD(generation, collections, 1);\n\n    if (reason != _Py_GC_REASON_SHUTDOWN) {\n        invoke_gc_callback(tstate, \"start\", generation, 0, 0);\n    }\n\n    if (gcstate->debug & _PyGC_DEBUG_STATS) {\n        PySys_WriteStderr(\"gc: collecting generation %d...\\n\", generation);\n        show_stats_each_generations(gcstate);\n        // ignore error: don't interrupt the GC if reading the clock fails\n        (void)PyTime_PerfCounterRaw(&t1);\n    }\n\n    if (PyDTrace_GC_START_ENABLED()) {\n        PyDTrace_GC_START(generation);\n    }\n\n    PyInterpreterState *interp = tstate->interp;\n\n    struct collection_state state = {\n        .interp = interp,\n        .gcstate = gcstate,\n    };\n\n    gc_collect_internal(interp, &state, generation);\n\n    m = state.collected;\n    n = state.uncollectable;\n\n    if (gcstate->debug & _PyGC_DEBUG_STATS) {\n        PyTime_t t2;\n        (void)PyTime_PerfCounterRaw(&t2);\n        double d = PyTime_AsSecondsDouble(t2 - t1);\n        PySys_WriteStderr(\n            \"gc: done, %zd unreachable, %zd uncollectable, %.4fs elapsed\\n\",\n            n+m, n, d);\n    }\n\n    // Clear the current thread's free-list again.\n    _PyThreadStateImpl *tstate_impl = (_PyThreadStateImpl *)tstate;\n    _PyObject_ClearFreeLists(&tstate_impl->freelists, 0);\n\n    if (_PyErr_Occurred(tstate)) {\n        if (reason == _Py_GC_REASON_SHUTDOWN) {\n            _PyErr_Clear(tstate);\n        }\n        else {\n            PyErr_FormatUnraisable(\"Exception ignored in garbage collection\");\n        }\n    }\n\n    /* Update stats */\n    struct gc_generation_stats *stats = &gcstate->generation_stats[generation];\n    stats->collections++;\n    stats->collected += m;\n    stats->uncollectable += n;\n\n    GC_STAT_ADD(generation, objects_collected, m);\n#ifdef Py_STATS\n    if (_Py_stats) {\n        GC_STAT_ADD(generation, object_visits,\n            _Py_stats->object_stats.object_visits);\n        _Py_stats->object_stats.object_visits = 0;\n    }\n#endif\n\n    if (PyDTrace_GC_DONE_ENABLED()) {\n        PyDTrace_GC_DONE(n + m);\n    }\n\n    if (reason != _Py_GC_REASON_SHUTDOWN) {\n        invoke_gc_callback(tstate, \"stop\", generation, m, n);\n    }\n\n    assert(!_PyErr_Occurred(tstate));\n    _Py_atomic_store_int(&gcstate->collecting, 0);\n    return n + m;\n}\n\nstruct get_referrers_args {\n    struct visitor_args base;\n    PyObject *objs;\n    struct worklist results;\n};\n\nstatic int\nreferrersvisit(PyObject* obj, void *arg)\n{\n    PyObject *objs = arg;\n    Py_ssize_t i;\n    for (i = 0; i < PyTuple_GET_SIZE(objs); i++) {\n        if (PyTuple_GET_ITEM(objs, i) == obj) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nstatic bool\nvisit_get_referrers(const mi_heap_t *heap, const mi_heap_area_t *area,\n                    void *block, size_t block_size, void *args)\n{\n    PyObject *op = op_from_block(block, args, true);\n    if (op == NULL) {\n        return true;\n    }\n\n    struct get_referrers_args *arg = (struct get_referrers_args *)args;\n    if (Py_TYPE(op)->tp_traverse(op, referrersvisit, arg->objs)) {\n        op->ob_tid = 0;  // we will restore the refcount later\n        worklist_push(&arg->results, op);\n    }\n\n    return true;\n}\n\nPyObject *\n_PyGC_GetReferrers(PyInterpreterState *interp, PyObject *objs)\n{\n    PyObject *result = PyList_New(0);\n    if (!result) {\n        return NULL;\n    }\n\n    _PyEval_StopTheWorld(interp);\n\n    // Append all objects to a worklist. This abuses ob_tid. We will restore\n    // it later. NOTE: We can't append to the PyListObject during\n    // gc_visit_heaps() because PyList_Append() may reclaim an abandoned\n    // mimalloc segments while we are traversing them.\n    struct get_referrers_args args = { .objs = objs };\n    gc_visit_heaps(interp, &visit_get_referrers, &args.base);\n\n    bool error = false;\n    PyObject *op;\n    while ((op = worklist_pop(&args.results)) != NULL) {\n        gc_restore_tid(op);\n        if (op != objs && PyList_Append(result, op) < 0) {\n            error = true;\n            break;\n        }\n    }\n\n    // In case of error, clear the remaining worklist\n    while ((op = worklist_pop(&args.results)) != NULL) {\n        gc_restore_tid(op);\n    }\n\n    _PyEval_StartTheWorld(interp);\n\n    if (error) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    return result;\n}\n\nstruct get_objects_args {\n    struct visitor_args base;\n    struct worklist objects;\n};\n\nstatic bool\nvisit_get_objects(const mi_heap_t *heap, const mi_heap_area_t *area,\n                  void *block, size_t block_size, void *args)\n{\n    PyObject *op = op_from_block(block, args, true);\n    if (op == NULL) {\n        return true;\n    }\n\n    struct get_objects_args *arg = (struct get_objects_args *)args;\n    op->ob_tid = 0;  // we will restore the refcount later\n    worklist_push(&arg->objects, op);\n\n    return true;\n}\n\nPyObject *\n_PyGC_GetObjects(PyInterpreterState *interp, int generation)\n{\n    PyObject *result = PyList_New(0);\n    if (!result) {\n        return NULL;\n    }\n\n    _PyEval_StopTheWorld(interp);\n\n    // Append all objects to a worklist. This abuses ob_tid. We will restore\n    // it later. NOTE: We can't append to the list during gc_visit_heaps()\n    // because PyList_Append() may reclaim an abandoned mimalloc segment\n    // while we are traversing it.\n    struct get_objects_args args = { 0 };\n    gc_visit_heaps(interp, &visit_get_objects, &args.base);\n\n    bool error = false;\n    PyObject *op;\n    while ((op = worklist_pop(&args.objects)) != NULL) {\n        gc_restore_tid(op);\n        if (op != result && PyList_Append(result, op) < 0) {\n            error = true;\n            break;\n        }\n    }\n\n    // In case of error, clear the remaining worklist\n    while ((op = worklist_pop(&args.objects)) != NULL) {\n        gc_restore_tid(op);\n    }\n\n    _PyEval_StartTheWorld(interp);\n\n    if (error) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    return result;\n}\n\nstatic bool\nvisit_freeze(const mi_heap_t *heap, const mi_heap_area_t *area,\n             void *block, size_t block_size, void *args)\n{\n    PyObject *op = op_from_block(block, args, true);\n    if (op != NULL) {\n        op->ob_gc_bits |= _PyGC_BITS_FROZEN;\n    }\n    return true;\n}\n\nvoid\n_PyGC_Freeze(PyInterpreterState *interp)\n{\n    struct visitor_args args;\n    _PyEval_StopTheWorld(interp);\n    gc_visit_heaps(interp, &visit_freeze, &args);\n    _PyEval_StartTheWorld(interp);\n}\n\nstatic bool\nvisit_unfreeze(const mi_heap_t *heap, const mi_heap_area_t *area,\n               void *block, size_t block_size, void *args)\n{\n    PyObject *op = op_from_block(block, args, true);\n    if (op != NULL) {\n        op->ob_gc_bits &= ~_PyGC_BITS_FROZEN;\n    }\n    return true;\n}\n\nvoid\n_PyGC_Unfreeze(PyInterpreterState *interp)\n{\n    struct visitor_args args;\n    _PyEval_StopTheWorld(interp);\n    gc_visit_heaps(interp, &visit_unfreeze, &args);\n    _PyEval_StartTheWorld(interp);\n}\n\nstruct count_frozen_args {\n    struct visitor_args base;\n    Py_ssize_t count;\n};\n\nstatic bool\nvisit_count_frozen(const mi_heap_t *heap, const mi_heap_area_t *area,\n                   void *block, size_t block_size, void *args)\n{\n    PyObject *op = op_from_block(block, args, true);\n    if (op != NULL && (op->ob_gc_bits & _PyGC_BITS_FROZEN) != 0) {\n        struct count_frozen_args *arg = (struct count_frozen_args *)args;\n        arg->count++;\n    }\n    return true;\n}\n\nPy_ssize_t\n_PyGC_GetFreezeCount(PyInterpreterState *interp)\n{\n    struct count_frozen_args args = { .count = 0 };\n    _PyEval_StopTheWorld(interp);\n    gc_visit_heaps(interp, &visit_count_frozen, &args.base);\n    _PyEval_StartTheWorld(interp);\n    return args.count;\n}\n\n/* C API for controlling the state of the garbage collector */\nint\nPyGC_Enable(void)\n{\n    GCState *gcstate = get_gc_state();\n    int old_state = gcstate->enabled;\n    gcstate->enabled = 1;\n    return old_state;\n}\n\nint\nPyGC_Disable(void)\n{\n    GCState *gcstate = get_gc_state();\n    int old_state = gcstate->enabled;\n    gcstate->enabled = 0;\n    return old_state;\n}\n\nint\nPyGC_IsEnabled(void)\n{\n    GCState *gcstate = get_gc_state();\n    return gcstate->enabled;\n}\n\n/* Public API to invoke gc.collect() from C */\nPy_ssize_t\nPyGC_Collect(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    GCState *gcstate = &tstate->interp->gc;\n\n    if (!gcstate->enabled) {\n        return 0;\n    }\n\n    Py_ssize_t n;\n    PyObject *exc = _PyErr_GetRaisedException(tstate);\n    n = gc_collect_main(tstate, NUM_GENERATIONS - 1, _Py_GC_REASON_MANUAL);\n    _PyErr_SetRaisedException(tstate, exc);\n\n    return n;\n}\n\nPy_ssize_t\n_PyGC_Collect(PyThreadState *tstate, int generation, _PyGC_Reason reason)\n{\n    return gc_collect_main(tstate, generation, reason);\n}\n\nvoid\n_PyGC_CollectNoFail(PyThreadState *tstate)\n{\n    /* Ideally, this function is only called on interpreter shutdown,\n       and therefore not recursively.  Unfortunately, when there are daemon\n       threads, a daemon thread can start a cyclic garbage collection\n       during interpreter shutdown (and then never finish it).\n       See http://bugs.python.org/issue8713#msg195178 for an example.\n       */\n    gc_collect_main(tstate, NUM_GENERATIONS - 1, _Py_GC_REASON_SHUTDOWN);\n}\n\nvoid\n_PyGC_DumpShutdownStats(PyInterpreterState *interp)\n{\n    GCState *gcstate = &interp->gc;\n    if (!(gcstate->debug & _PyGC_DEBUG_SAVEALL)\n        && gcstate->garbage != NULL && PyList_GET_SIZE(gcstate->garbage) > 0) {\n        const char *message;\n        if (gcstate->debug & _PyGC_DEBUG_UNCOLLECTABLE) {\n            message = \"gc: %zd uncollectable objects at shutdown\";\n        }\n        else {\n            message = \"gc: %zd uncollectable objects at shutdown; \" \\\n                \"use gc.set_debug(gc.DEBUG_UNCOLLECTABLE) to list them\";\n        }\n        /* PyErr_WarnFormat does too many things and we are at shutdown,\n           the warnings module's dependencies (e.g. linecache) may be gone\n           already. */\n        if (PyErr_WarnExplicitFormat(PyExc_ResourceWarning, \"gc\", 0,\n                                     \"gc\", NULL, message,\n                                     PyList_GET_SIZE(gcstate->garbage)))\n        {\n            PyErr_WriteUnraisable(NULL);\n        }\n        if (gcstate->debug & _PyGC_DEBUG_UNCOLLECTABLE) {\n            PyObject *repr = NULL, *bytes = NULL;\n            repr = PyObject_Repr(gcstate->garbage);\n            if (!repr || !(bytes = PyUnicode_EncodeFSDefault(repr))) {\n                PyErr_WriteUnraisable(gcstate->garbage);\n            }\n            else {\n                PySys_WriteStderr(\n                    \"      %s\\n\",\n                    PyBytes_AS_STRING(bytes)\n                    );\n            }\n            Py_XDECREF(repr);\n            Py_XDECREF(bytes);\n        }\n    }\n}\n\n\nvoid\n_PyGC_Fini(PyInterpreterState *interp)\n{\n    GCState *gcstate = &interp->gc;\n    Py_CLEAR(gcstate->garbage);\n    Py_CLEAR(gcstate->callbacks);\n\n    /* We expect that none of this interpreters objects are shared\n       with other interpreters.\n       See https://github.com/python/cpython/issues/90228. */\n}\n\n/* for debugging */\n\n#ifdef Py_DEBUG\nstatic int\nvisit_validate(PyObject *op, void *parent_raw)\n{\n    PyObject *parent = _PyObject_CAST(parent_raw);\n    if (_PyObject_IsFreed(op)) {\n        _PyObject_ASSERT_FAILED_MSG(parent,\n                                    \"PyObject_GC_Track() object is not valid\");\n    }\n    return 0;\n}\n#endif\n\n\n/* extension modules might be compiled with GC support so these\n   functions must always be available */\n\nvoid\nPyObject_GC_Track(void *op_raw)\n{\n    PyObject *op = _PyObject_CAST(op_raw);\n    if (_PyObject_GC_IS_TRACKED(op)) {\n        _PyObject_ASSERT_FAILED_MSG(op,\n                                    \"object already tracked \"\n                                    \"by the garbage collector\");\n    }\n    _PyObject_GC_TRACK(op);\n\n#ifdef Py_DEBUG\n    /* Check that the object is valid: validate objects traversed\n       by tp_traverse() */\n    traverseproc traverse = Py_TYPE(op)->tp_traverse;\n    (void)traverse(op, visit_validate, op);\n#endif\n}\n\nvoid\nPyObject_GC_UnTrack(void *op_raw)\n{\n    PyObject *op = _PyObject_CAST(op_raw);\n    /* Obscure:  the Py_TRASHCAN mechanism requires that we be able to\n     * call PyObject_GC_UnTrack twice on an object.\n     */\n    if (_PyObject_GC_IS_TRACKED(op)) {\n        _PyObject_GC_UNTRACK(op);\n    }\n}\n\nint\nPyObject_IS_GC(PyObject *obj)\n{\n    return _PyObject_IS_GC(obj);\n}\n\nvoid\n_Py_ScheduleGC(PyThreadState *tstate)\n{\n    if (!_Py_eval_breaker_bit_is_set(tstate, _PY_GC_SCHEDULED_BIT))\n    {\n        _Py_set_eval_breaker_bit(tstate, _PY_GC_SCHEDULED_BIT);\n    }\n}\n\nvoid\n_PyObject_GC_Link(PyObject *op)\n{\n    record_allocation(_PyThreadState_GET());\n}\n\nvoid\n_Py_RunGC(PyThreadState *tstate)\n{\n    GCState *gcstate = get_gc_state();\n    if (!gcstate->enabled) {\n        return;\n    }\n    gc_collect_main(tstate, 0, _Py_GC_REASON_HEAP);\n}\n\nstatic PyObject *\ngc_alloc(PyTypeObject *tp, size_t basicsize, size_t presize)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (basicsize > PY_SSIZE_T_MAX - presize) {\n        return _PyErr_NoMemory(tstate);\n    }\n    size_t size = presize + basicsize;\n    char *mem = _PyObject_MallocWithType(tp, size);\n    if (mem == NULL) {\n        return _PyErr_NoMemory(tstate);\n    }\n    if (presize) {\n        ((PyObject **)mem)[0] = NULL;\n        ((PyObject **)mem)[1] = NULL;\n    }\n    PyObject *op = (PyObject *)(mem + presize);\n    record_allocation(tstate);\n    return op;\n}\n\nPyObject *\n_PyObject_GC_New(PyTypeObject *tp)\n{\n    size_t presize = _PyType_PreHeaderSize(tp);\n    size_t size = _PyObject_SIZE(tp);\n    if (_PyType_HasFeature(tp, Py_TPFLAGS_INLINE_VALUES)) {\n        size += _PyInlineValuesSize(tp);\n    }\n    PyObject *op = gc_alloc(tp, size, presize);\n    if (op == NULL) {\n        return NULL;\n    }\n    _PyObject_Init(op, tp);\n    return op;\n}\n\nPyVarObject *\n_PyObject_GC_NewVar(PyTypeObject *tp, Py_ssize_t nitems)\n{\n    PyVarObject *op;\n\n    if (nitems < 0) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n    size_t presize = _PyType_PreHeaderSize(tp);\n    size_t size = _PyObject_VAR_SIZE(tp, nitems);\n    op = (PyVarObject *)gc_alloc(tp, size, presize);\n    if (op == NULL) {\n        return NULL;\n    }\n    _PyObject_InitVar(op, tp, nitems);\n    return op;\n}\n\nPyObject *\nPyUnstable_Object_GC_NewWithExtraData(PyTypeObject *tp, size_t extra_size)\n{\n    size_t presize = _PyType_PreHeaderSize(tp);\n    PyObject *op = gc_alloc(tp, _PyObject_SIZE(tp) + extra_size, presize);\n    if (op == NULL) {\n        return NULL;\n    }\n    memset(op, 0, _PyObject_SIZE(tp) + extra_size);\n    _PyObject_Init(op, tp);\n    return op;\n}\n\nPyVarObject *\n_PyObject_GC_Resize(PyVarObject *op, Py_ssize_t nitems)\n{\n    const size_t basicsize = _PyObject_VAR_SIZE(Py_TYPE(op), nitems);\n    const size_t presize = _PyType_PreHeaderSize(((PyObject *)op)->ob_type);\n    _PyObject_ASSERT((PyObject *)op, !_PyObject_GC_IS_TRACKED(op));\n    if (basicsize > (size_t)PY_SSIZE_T_MAX - presize) {\n        return (PyVarObject *)PyErr_NoMemory();\n    }\n    char *mem = (char *)op - presize;\n    mem = (char *)_PyObject_ReallocWithType(Py_TYPE(op), mem,  presize + basicsize);\n    if (mem == NULL) {\n        return (PyVarObject *)PyErr_NoMemory();\n    }\n    op = (PyVarObject *) (mem + presize);\n    Py_SET_SIZE(op, nitems);\n    return op;\n}\n\nvoid\nPyObject_GC_Del(void *op)\n{\n    size_t presize = _PyType_PreHeaderSize(((PyObject *)op)->ob_type);\n    if (_PyObject_GC_IS_TRACKED(op)) {\n        _PyObject_GC_UNTRACK(op);\n#ifdef Py_DEBUG\n        PyObject *exc = PyErr_GetRaisedException();\n        if (PyErr_WarnExplicitFormat(PyExc_ResourceWarning, \"gc\", 0,\n                                     \"gc\", NULL, \"Object of type %s is not untracked before destruction\",\n                                     ((PyObject*)op)->ob_type->tp_name)) {\n            PyErr_WriteUnraisable(NULL);\n        }\n        PyErr_SetRaisedException(exc);\n#endif\n    }\n\n    record_deallocation(_PyThreadState_GET());\n    PyObject *self = (PyObject *)op;\n    if (_PyObject_GC_IS_SHARED_INLINE(self)) {\n        _PyObject_FreeDelayed(((char *)op)-presize);\n    }\n    else {\n        PyObject_Free(((char *)op)-presize);\n    }\n}\n\nint\nPyObject_GC_IsTracked(PyObject* obj)\n{\n    return _PyObject_GC_IS_TRACKED(obj);\n}\n\nint\nPyObject_GC_IsFinalized(PyObject *obj)\n{\n    return _PyGC_FINALIZED(obj);\n}\n\nstruct custom_visitor_args {\n    struct visitor_args base;\n    gcvisitobjects_t callback;\n    void *arg;\n};\n\nstatic bool\ncustom_visitor_wrapper(const mi_heap_t *heap, const mi_heap_area_t *area,\n                       void *block, size_t block_size, void *args)\n{\n    PyObject *op = op_from_block(block, args, false);\n    if (op == NULL) {\n        return true;\n    }\n\n    struct custom_visitor_args *wrapper = (struct custom_visitor_args *)args;\n    if (!wrapper->callback(op, wrapper->arg)) {\n        return false;\n    }\n\n    return true;\n}\n\n// gh-117783: Immortalize objects that use deferred reference counting to\n// temporarily work around scaling bottlenecks.\nstatic bool\nimmortalize_visitor(const mi_heap_t *heap, const mi_heap_area_t *area,\n                    void *block, size_t block_size, void *args)\n{\n    PyObject *op = op_from_block(block, args, false);\n    if (op != NULL && _PyObject_HasDeferredRefcount(op)) {\n        _Py_SetImmortal(op);\n        op->ob_gc_bits &= ~_PyGC_BITS_DEFERRED;\n    }\n    return true;\n}\n\nvoid\n_PyGC_ImmortalizeDeferredObjects(PyInterpreterState *interp)\n{\n    struct visitor_args args;\n    _PyEval_StopTheWorld(interp);\n    if (interp->gc.immortalize == 0) {\n        gc_visit_heaps(interp, &immortalize_visitor, &args);\n        interp->gc.immortalize = 1;\n    }\n    _PyEval_StartTheWorld(interp);\n}\n\nvoid\nPyUnstable_GC_VisitObjects(gcvisitobjects_t callback, void *arg)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    struct custom_visitor_args wrapper = {\n        .callback = callback,\n        .arg = arg,\n    };\n\n    _PyEval_StopTheWorld(interp);\n    gc_visit_heaps(interp, &custom_visitor_wrapper, &wrapper.base);\n    _PyEval_StartTheWorld(interp);\n}\n\n/* Clear all free lists\n * All free lists are cleared during the collection of the highest generation.\n * Allocated items in the free list may keep a pymalloc arena occupied.\n * Clearing the free lists may give back memory to the OS earlier.\n * Free-threading version: Since freelists are managed per thread,\n * GC should clear all freelists by traversing all threads.\n */\nvoid\n_PyGC_ClearAllFreeLists(PyInterpreterState *interp)\n{\n    HEAD_LOCK(&_PyRuntime);\n    _PyThreadStateImpl *tstate = (_PyThreadStateImpl *)interp->threads.head;\n    while (tstate != NULL) {\n        _PyObject_ClearFreeLists(&tstate->freelists, 0);\n        tstate = (_PyThreadStateImpl *)tstate->base.next;\n    }\n    HEAD_UNLOCK(&_PyRuntime);\n}\n\n#endif  // Py_GIL_DISABLED\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value 'iter.next'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 98, "startColumn": 32, "endColumn": 44}, "contextRegion": {"startLine": 98, "snippet": {"text": "    PyObject *op = (PyObject *)*(iter->ptr);\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1535, "startColumn": 1, "endColumn": 14}, "contextRegion": {"startLine": 1535, "snippet": {"text": "_PyGC_Collect(PyThreadState *tstate, int generation, _PyGC_Reason reason)\n"}}}, "logicalLocations": [{"name": "_PyGC_Collect", "fullyQualifiedName": "_PyGC_Collect", "decoratedName": "_PyGC_Collect", "kind": "function"}], "message": {"text": "entry to '_PyGC_Collect'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1537, "startColumn": 12, "endColumn": 55}, "contextRegion": {"startLine": 1537, "snippet": {"text": "    return gc_collect_main(tstate, generation, reason);\n"}}}, "logicalLocations": [{"name": "_PyGC_Collect", "fullyQualifiedName": "_PyGC_Collect", "decoratedName": "_PyGC_Collect", "kind": "function"}], "message": {"text": "calling 'gc_collect_main' from '_PyGC_Collect'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1170, "startColumn": 1, "endColumn": 16}, "contextRegion": {"startLine": 1170, "snippet": {"text": "gc_collect_main(PyThreadState *tstate, int generation, _PyGC_Reason reason)\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "entry to 'gc_collect_main'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1183, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1183, "snippet": {"text": "    if (!_Py_atomic_compare_exchange_int(&gcstate->collecting, &expected, 1)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1225, "startColumn": 5, "endColumn": 52}, "contextRegion": {"startLine": 1225, "snippet": {"text": "    gc_collect_internal(interp, &state, generation);\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "calling 'gc_collect_internal' from 'gc_collect_main'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1093, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 1093, "snippet": {"text": "gc_collect_internal(PyInterpreterState *interp, struct collection_state *state, int generation)\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "entry to 'gc_collect_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1112, "startColumn": 15, "endColumn": 53}, "contextRegion": {"startLine": 1112, "snippet": {"text": "    int err = deduce_unreachable_heap(interp, state);\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "calling 'deduce_unreachable_heap' from 'gc_collect_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 1, "endColumn": 24}, "contextRegion": {"startLine": 586, "snippet": {"text": "deduce_unreachable_heap(PyInterpreterState *interp,\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "entry to 'deduce_unreachable_heap'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 609, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 609, "snippet": {"text": "    if (gc_visit_heaps(interp, &mark_heap_visitor, &state->base) < 0) {\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 617, "startColumn": 5, "endColumn": 19}, "contextRegion": {"startLine": 617, "snippet": {"text": "    gc_visit_heaps(interp, &scan_heap_visitor, &state->base);\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 619, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 619, "snippet": {"text": "    if (state->legacy_finalizers.head) {\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 622, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 622, "snippet": {"text": "        if (move_legacy_finalizer_reachable(state) < 0) {\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 622, "startColumn": 13, "endColumn": 51}, "contextRegion": {"startLine": 622, "snippet": {"text": "        if (move_legacy_finalizer_reachable(state) < 0) {\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "calling 'move_legacy_finalizer_reachable' from 'deduce_unreachable_heap'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 631, "startColumn": 1, "endColumn": 32}, "contextRegion": {"startLine": 631, "snippet": {"text": "move_legacy_finalizer_reachable(struct collection_state *state)\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "entry to 'move_legacy_finalizer_reachable'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 644, "startColumn": 26, "endColumn": 30}, "contextRegion": {"startLine": 644, "snippet": {"text": "    struct worklist_iter iter;\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 644, "startColumn": 26, "endColumn": 30}, "contextRegion": {"startLine": 644, "snippet": {"text": "    struct worklist_iter iter;\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "capacity: 8 bytes"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 645, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 645, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "inlined call to 'worklist_iter_init' from 'move_legacy_finalizer_reachable'"}}, "kinds": ["call", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 99, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 99, "snippet": {"text": "    if (op) {\n"}}}, "logicalLocations": [{"name": "worklist_iter_init", "fullyQualifiedName": "worklist_iter_init", "decoratedName": "worklist_iter_init", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 6}, {"location": {"logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 645, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 645, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "following 'true' branch (when 'op' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 646, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 646, "snippet": {"text": "        if (!gc_is_unreachable(op)) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 646, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 646, "snippet": {"text": "        if (!gc_is_unreachable(op)) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 645, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 645, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 645, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 645, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "inlined call to 'worklist_iter_init' from 'move_legacy_finalizer_reachable'"}}, "kinds": ["call", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 98, "startColumn": 32, "endColumn": 44}, "contextRegion": {"startLine": 98, "snippet": {"text": "    PyObject *op = (PyObject *)*(iter->ptr);\n"}}}, "logicalLocations": [{"name": "worklist_iter_init", "fullyQualifiedName": "worklist_iter_init", "decoratedName": "worklist_iter_init", "kind": "function"}], "message": {"text": "use of uninitialized value 'iter.next' here"}}, "kinds": ["danger"], "nestingLevel": 6}]}]}]}, {"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value 'iter.next'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 98, "startColumn": 32, "endColumn": 44}, "contextRegion": {"startLine": 98, "snippet": {"text": "    PyObject *op = (PyObject *)*(iter->ptr);\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1541, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 1541, "snippet": {"text": "_PyGC_CollectNoFail(PyThreadState *tstate)\n"}}}, "logicalLocations": [{"name": "_PyGC_CollectNoFail", "fullyQualifiedName": "_PyGC_CollectNoFail", "decoratedName": "_PyGC_CollectNoFail", "kind": "function"}], "message": {"text": "entry to '_PyGC_CollectNoFail'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1549, "startColumn": 5, "endColumn": 73}, "contextRegion": {"startLine": 1549, "snippet": {"text": "    gc_collect_main(tstate, NUM_GENERATIONS - 1, _Py_GC_REASON_SHUTDOWN);\n"}}}, "logicalLocations": [{"name": "_PyGC_CollectNoFail", "fullyQualifiedName": "_PyGC_CollectNoFail", "decoratedName": "_PyGC_CollectNoFail", "kind": "function"}], "message": {"text": "calling 'gc_collect_main' from '_PyGC_CollectNoFail'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1170, "startColumn": 1, "endColumn": 16}, "contextRegion": {"startLine": 1170, "snippet": {"text": "gc_collect_main(PyThreadState *tstate, int generation, _PyGC_Reason reason)\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "entry to 'gc_collect_main'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1183, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1183, "snippet": {"text": "    if (!_Py_atomic_compare_exchange_int(&gcstate->collecting, &expected, 1)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'false' branch (when 'reason != 0')..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1194, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1194, "snippet": {"text": "    assert(generation >= 0 && generation < NUM_GENERATIONS);\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1203, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1203, "snippet": {"text": "    if (reason != _Py_GC_REASON_SHUTDOWN) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'false' branch (when 'reason == 1')..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1207, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 1207, "snippet": {"text": "    if (gcstate->debug & _PyGC_DEBUG_STATS) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1225, "startColumn": 5, "endColumn": 52}, "contextRegion": {"startLine": 1225, "snippet": {"text": "    gc_collect_internal(interp, &state, generation);\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "calling 'gc_collect_internal' from 'gc_collect_main'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1093, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 1093, "snippet": {"text": "gc_collect_internal(PyInterpreterState *interp, struct collection_state *state, int generation)\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "entry to 'gc_collect_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1098, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1098, "snippet": {"text": "    if (generation+1 < NUM_GENERATIONS) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1102, "startColumn": 5, "endColumn": 10}, "contextRegion": {"startLine": 1102, "snippet": {"text": "    state->gcstate->young.count = 0;\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1103, "startColumn": 21, "endColumn": 36}, "contextRegion": {"startLine": 1103, "snippet": {"text": "    for (int i = 1; i <= generation; ++i) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i <= generation')..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1104, "startColumn": 9, "endColumn": 14}, "contextRegion": {"startLine": 1104, "snippet": {"text": "        state->gcstate->old[i-1].count = 0;\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1112, "startColumn": 15, "endColumn": 53}, "contextRegion": {"startLine": 1112, "snippet": {"text": "    int err = deduce_unreachable_heap(interp, state);\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "calling 'deduce_unreachable_heap' from 'gc_collect_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 1, "endColumn": 24}, "contextRegion": {"startLine": 586, "snippet": {"text": "deduce_unreachable_heap(PyInterpreterState *interp,\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "entry to 'deduce_unreachable_heap'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 609, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 609, "snippet": {"text": "    if (gc_visit_heaps(interp, &mark_heap_visitor, &state->base) < 0) {\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 617, "startColumn": 5, "endColumn": 19}, "contextRegion": {"startLine": 617, "snippet": {"text": "    gc_visit_heaps(interp, &scan_heap_visitor, &state->base);\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 619, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 619, "snippet": {"text": "    if (state->legacy_finalizers.head) {\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 622, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 622, "snippet": {"text": "        if (move_legacy_finalizer_reachable(state) < 0) {\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 622, "startColumn": 13, "endColumn": 51}, "contextRegion": {"startLine": 622, "snippet": {"text": "        if (move_legacy_finalizer_reachable(state) < 0) {\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "calling 'move_legacy_finalizer_reachable' from 'deduce_unreachable_heap'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 631, "startColumn": 1, "endColumn": 32}, "contextRegion": {"startLine": 631, "snippet": {"text": "move_legacy_finalizer_reachable(struct collection_state *state)\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "entry to 'move_legacy_finalizer_reachable'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 644, "startColumn": 26, "endColumn": 30}, "contextRegion": {"startLine": 644, "snippet": {"text": "    struct worklist_iter iter;\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 644, "startColumn": 26, "endColumn": 30}, "contextRegion": {"startLine": 644, "snippet": {"text": "    struct worklist_iter iter;\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "capacity: 8 bytes"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 645, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 645, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "inlined call to 'worklist_iter_init' from 'move_legacy_finalizer_reachable'"}}, "kinds": ["call", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 99, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 99, "snippet": {"text": "    if (op) {\n"}}}, "logicalLocations": [{"name": "worklist_iter_init", "fullyQualifiedName": "worklist_iter_init", "decoratedName": "worklist_iter_init", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 6}, {"location": {"logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 645, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 645, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "following 'true' branch (when 'op' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 646, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 646, "snippet": {"text": "        if (!gc_is_unreachable(op)) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 646, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 646, "snippet": {"text": "        if (!gc_is_unreachable(op)) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 645, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 645, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 645, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 645, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "inlined call to 'worklist_iter_init' from 'move_legacy_finalizer_reachable'"}}, "kinds": ["call", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 98, "startColumn": 32, "endColumn": 44}, "contextRegion": {"startLine": 98, "snippet": {"text": "    PyObject *op = (PyObject *)*(iter->ptr);\n"}}}, "logicalLocations": [{"name": "worklist_iter_init", "fullyQualifiedName": "worklist_iter_init", "decoratedName": "worklist_iter_init", "kind": "function"}], "message": {"text": "use of uninitialized value 'iter.next' here"}}, "kinds": ["danger"], "nestingLevel": 6}]}]}]}, {"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value 'iter.next'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 98, "startColumn": 32, "endColumn": 44}, "contextRegion": {"startLine": 98, "snippet": {"text": "    PyObject *op = (PyObject *)*(iter->ptr);\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1678, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 1678, "snippet": {"text": "_Py_RunGC(PyThreadState *tstate)\n"}}}, "logicalLocations": [{"name": "_Py_RunGC", "fullyQualifiedName": "_Py_RunGC", "decoratedName": "_Py_RunGC", "kind": "function"}], "message": {"text": "entry to '_Py_RunGC'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1681, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1681, "snippet": {"text": "    if (!gcstate->enabled) {\n"}}}, "logicalLocations": [{"name": "_Py_RunGC", "fullyQualifiedName": "_Py_RunGC", "decoratedName": "_Py_RunGC", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1684, "startColumn": 5, "endColumn": 20}, "contextRegion": {"startLine": 1684, "snippet": {"text": "    gc_collect_main(tstate, 0, _Py_GC_REASON_HEAP);\n"}}}, "logicalLocations": [{"name": "_Py_RunGC", "fullyQualifiedName": "_Py_RunGC", "decoratedName": "_Py_RunGC", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1684, "startColumn": 5, "endColumn": 51}, "contextRegion": {"startLine": 1684, "snippet": {"text": "    gc_collect_main(tstate, 0, _Py_GC_REASON_HEAP);\n"}}}, "logicalLocations": [{"name": "_Py_RunGC", "fullyQualifiedName": "_Py_RunGC", "decoratedName": "_Py_RunGC", "kind": "function"}], "message": {"text": "calling 'gc_collect_main' from '_Py_RunGC'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1170, "startColumn": 1, "endColumn": 16}, "contextRegion": {"startLine": 1170, "snippet": {"text": "gc_collect_main(PyThreadState *tstate, int generation, _PyGC_Reason reason)\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "entry to 'gc_collect_main'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1183, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1183, "snippet": {"text": "    if (!_Py_atomic_compare_exchange_int(&gcstate->collecting, &expected, 1)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'true' branch (when 'reason == 0')..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 42, "endColumn": 68}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 42, "endColumn": 68}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "calling 'gc_should_collect' from 'gc_collect_main'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1043, "startColumn": 1, "endColumn": 18}, "contextRegion": {"startLine": 1043, "snippet": {"text": "gc_should_collect(GCState *gcstate)\n"}}}, "logicalLocations": [{"name": "gc_should_collect", "fullyQualifiedName": "gc_should_collect", "decoratedName": "gc_should_collect", "kind": "function"}], "message": {"text": "entry to 'gc_should_collect'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1047, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1047, "snippet": {"text": "    if (count <= threshold || threshold == 0 || !gcstate->enabled) {\n"}}}, "logicalLocations": [{"name": "gc_should_collect", "fullyQualifiedName": "gc_should_collect", "decoratedName": "gc_should_collect", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1053, "startColumn": 5, "endColumn": 11}, "contextRegion": {"startLine": 1053, "snippet": {"text": "    return (count > gcstate->long_lived_total / 4 ||\n"}}}, "logicalLocations": [{"name": "gc_should_collect", "fullyQualifiedName": "gc_should_collect", "decoratedName": "gc_should_collect", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 42, "endColumn": 68}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "returning to 'gc_collect_main' from 'gc_should_collect'"}}, "kinds": ["return", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 9, "endColumn": 68}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1194, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1194, "snippet": {"text": "    assert(generation >= 0 && generation < NUM_GENERATIONS);\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1203, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1203, "snippet": {"text": "    if (reason != _Py_GC_REASON_SHUTDOWN) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'true' branch (when 'reason != 1')..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1204, "startColumn": 9, "endColumn": 27}, "contextRegion": {"startLine": 1204, "snippet": {"text": "        invoke_gc_callback(tstate, \"start\", generation, 0, 0);\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1225, "startColumn": 5, "endColumn": 52}, "contextRegion": {"startLine": 1225, "snippet": {"text": "    gc_collect_internal(interp, &state, generation);\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "calling 'gc_collect_internal' from 'gc_collect_main'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1093, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 1093, "snippet": {"text": "gc_collect_internal(PyInterpreterState *interp, struct collection_state *state, int generation)\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "entry to 'gc_collect_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1098, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1098, "snippet": {"text": "    if (generation+1 < NUM_GENERATIONS) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1099, "startColumn": 9, "endColumn": 14}, "contextRegion": {"startLine": 1099, "snippet": {"text": "        state->gcstate->old[generation].count += 1;\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1103, "startColumn": 21, "endColumn": 36}, "contextRegion": {"startLine": 1103, "snippet": {"text": "    for (int i = 1; i <= generation; ++i) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "following 'false' branch (when 'i > generation')..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1108, "startColumn": 5, "endColumn": 29}, "contextRegion": {"startLine": 1108, "snippet": {"text": "    merge_all_queued_objects(interp, state);\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1112, "startColumn": 15, "endColumn": 53}, "contextRegion": {"startLine": 1112, "snippet": {"text": "    int err = deduce_unreachable_heap(interp, state);\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "calling 'deduce_unreachable_heap' from 'gc_collect_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 1, "endColumn": 24}, "contextRegion": {"startLine": 586, "snippet": {"text": "deduce_unreachable_heap(PyInterpreterState *interp,\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "entry to 'deduce_unreachable_heap'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 609, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 609, "snippet": {"text": "    if (gc_visit_heaps(interp, &mark_heap_visitor, &state->base) < 0) {\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 617, "startColumn": 5, "endColumn": 19}, "contextRegion": {"startLine": 617, "snippet": {"text": "    gc_visit_heaps(interp, &scan_heap_visitor, &state->base);\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 619, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 619, "snippet": {"text": "    if (state->legacy_finalizers.head) {\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 622, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 622, "snippet": {"text": "        if (move_legacy_finalizer_reachable(state) < 0) {\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 622, "startColumn": 13, "endColumn": 51}, "contextRegion": {"startLine": 622, "snippet": {"text": "        if (move_legacy_finalizer_reachable(state) < 0) {\n"}}}, "logicalLocations": [{"name": "deduce_unreachable_heap", "fullyQualifiedName": "deduce_unreachable_heap", "decoratedName": "deduce_unreachable_heap", "kind": "function"}], "message": {"text": "calling 'move_legacy_finalizer_reachable' from 'deduce_unreachable_heap'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 631, "startColumn": 1, "endColumn": 32}, "contextRegion": {"startLine": 631, "snippet": {"text": "move_legacy_finalizer_reachable(struct collection_state *state)\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "entry to 'move_legacy_finalizer_reachable'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 644, "startColumn": 26, "endColumn": 30}, "contextRegion": {"startLine": 644, "snippet": {"text": "    struct worklist_iter iter;\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 644, "startColumn": 26, "endColumn": 30}, "contextRegion": {"startLine": 644, "snippet": {"text": "    struct worklist_iter iter;\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "capacity: 8 bytes"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 645, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 645, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "inlined call to 'worklist_iter_init' from 'move_legacy_finalizer_reachable'"}}, "kinds": ["call", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 99, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 99, "snippet": {"text": "    if (op) {\n"}}}, "logicalLocations": [{"name": "worklist_iter_init", "fullyQualifiedName": "worklist_iter_init", "decoratedName": "worklist_iter_init", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 6}, {"location": {"logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 645, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 645, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "following 'true' branch (when 'op' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 646, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 646, "snippet": {"text": "        if (!gc_is_unreachable(op)) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 646, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 646, "snippet": {"text": "        if (!gc_is_unreachable(op)) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 645, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 645, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 645, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 645, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "move_legacy_finalizer_reachable", "fullyQualifiedName": "move_legacy_finalizer_reachable", "decoratedName": "move_legacy_finalizer_reachable", "kind": "function"}], "message": {"text": "inlined call to 'worklist_iter_init' from 'move_legacy_finalizer_reachable'"}}, "kinds": ["call", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 98, "startColumn": 32, "endColumn": 44}, "contextRegion": {"startLine": 98, "snippet": {"text": "    PyObject *op = (PyObject *)*(iter->ptr);\n"}}}, "logicalLocations": [{"name": "worklist_iter_init", "fullyQualifiedName": "worklist_iter_init", "decoratedName": "worklist_iter_init", "kind": "function"}], "message": {"text": "use of uninitialized value 'iter.next' here"}}, "kinds": ["danger"], "nestingLevel": 6}]}]}]}, {"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value 'iter.next'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 98, "startColumn": 32, "endColumn": 44}, "contextRegion": {"startLine": 98, "snippet": {"text": "    PyObject *op = (PyObject *)*(iter->ptr);\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1535, "startColumn": 1, "endColumn": 14}, "contextRegion": {"startLine": 1535, "snippet": {"text": "_PyGC_Collect(PyThreadState *tstate, int generation, _PyGC_Reason reason)\n"}}}, "logicalLocations": [{"name": "_PyGC_Collect", "fullyQualifiedName": "_PyGC_Collect", "decoratedName": "_PyGC_Collect", "kind": "function"}], "message": {"text": "entry to '_PyGC_Collect'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1537, "startColumn": 12, "endColumn": 55}, "contextRegion": {"startLine": 1537, "snippet": {"text": "    return gc_collect_main(tstate, generation, reason);\n"}}}, "logicalLocations": [{"name": "_PyGC_Collect", "fullyQualifiedName": "_PyGC_Collect", "decoratedName": "_PyGC_Collect", "kind": "function"}], "message": {"text": "calling 'gc_collect_main' from '_PyGC_Collect'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1170, "startColumn": 1, "endColumn": 16}, "contextRegion": {"startLine": 1170, "snippet": {"text": "gc_collect_main(PyThreadState *tstate, int generation, _PyGC_Reason reason)\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "entry to 'gc_collect_main'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1183, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1183, "snippet": {"text": "    if (!_Py_atomic_compare_exchange_int(&gcstate->collecting, &expected, 1)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1225, "startColumn": 5, "endColumn": 52}, "contextRegion": {"startLine": 1225, "snippet": {"text": "    gc_collect_internal(interp, &state, generation);\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "calling 'gc_collect_internal' from 'gc_collect_main'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1093, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 1093, "snippet": {"text": "gc_collect_internal(PyInterpreterState *interp, struct collection_state *state, int generation)\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "entry to 'gc_collect_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1113, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1113, "snippet": {"text": "    if (err < 0) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "following 'false' branch (when 'err >= 0')..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1120, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 1120, "snippet": {"text": "    if (interp->gc.debug & _PyGC_DEBUG_COLLECTABLE) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1144, "startColumn": 11, "endColumn": 44}, "contextRegion": {"startLine": 1144, "snippet": {"text": "    err = handle_resurrected_objects(state);\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "calling 'handle_resurrected_objects' from 'gc_collect_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 893, "startColumn": 1, "endColumn": 27}, "contextRegion": {"startLine": 893, "snippet": {"text": "handle_resurrected_objects(struct collection_state *state)\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "entry to 'handle_resurrected_objects'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 899, "startColumn": 26, "endColumn": 30}, "contextRegion": {"startLine": 899, "snippet": {"text": "    struct worklist_iter iter;\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 899, "startColumn": 26, "endColumn": 30}, "contextRegion": {"startLine": 899, "snippet": {"text": "    struct worklist_iter iter;\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "capacity: 8 bytes"}}, "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 900, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 900, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "inlined call to 'worklist_iter_init' from 'handle_resurrected_objects'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 99, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 99, "snippet": {"text": "    if (op) {\n"}}}, "logicalLocations": [{"name": "worklist_iter_init", "fullyQualifiedName": "worklist_iter_init", "decoratedName": "worklist_iter_init", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 900, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 900, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "following 'true' branch (when 'op' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 901, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 901, "snippet": {"text": "        assert(gc_is_unreachable(op));\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 904, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 904, "snippet": {"text": "        if (!_PyObject_GC_IS_TRACKED(op)) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 913, "startColumn": 9, "endColumn": 19}, "contextRegion": {"startLine": 913, "snippet": {"text": "        Py_ssize_t refcount = (op->ob_ref_shared >> _Py_REF_SHARED_SHIFT);\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 914, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 914, "snippet": {"text": "        if (refcount > INT32_MAX) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "following 'false' branch (when 'refcount <= 2147483647')..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 923, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 923, "snippet": {"text": "        op->ob_ref_local += (uint32_t)refcount;\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 900, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 900, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "inlined call to 'worklist_iter_init' from 'handle_resurrected_objects'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 98, "startColumn": 32, "endColumn": 44}, "contextRegion": {"startLine": 98, "snippet": {"text": "    PyObject *op = (PyObject *)*(iter->ptr);\n"}}}, "logicalLocations": [{"name": "worklist_iter_init", "fullyQualifiedName": "worklist_iter_init", "decoratedName": "worklist_iter_init", "kind": "function"}], "message": {"text": "use of uninitialized value 'iter.next' here"}}, "kinds": ["danger"], "nestingLevel": 5}]}]}]}, {"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value 'iter.next'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 98, "startColumn": 32, "endColumn": 44}, "contextRegion": {"startLine": 98, "snippet": {"text": "    PyObject *op = (PyObject *)*(iter->ptr);\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1541, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 1541, "snippet": {"text": "_PyGC_CollectNoFail(PyThreadState *tstate)\n"}}}, "logicalLocations": [{"name": "_PyGC_CollectNoFail", "fullyQualifiedName": "_PyGC_CollectNoFail", "decoratedName": "_PyGC_CollectNoFail", "kind": "function"}], "message": {"text": "entry to '_PyGC_CollectNoFail'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1549, "startColumn": 5, "endColumn": 73}, "contextRegion": {"startLine": 1549, "snippet": {"text": "    gc_collect_main(tstate, NUM_GENERATIONS - 1, _Py_GC_REASON_SHUTDOWN);\n"}}}, "logicalLocations": [{"name": "_PyGC_CollectNoFail", "fullyQualifiedName": "_PyGC_CollectNoFail", "decoratedName": "_PyGC_CollectNoFail", "kind": "function"}], "message": {"text": "calling 'gc_collect_main' from '_PyGC_CollectNoFail'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1170, "startColumn": 1, "endColumn": 16}, "contextRegion": {"startLine": 1170, "snippet": {"text": "gc_collect_main(PyThreadState *tstate, int generation, _PyGC_Reason reason)\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "entry to 'gc_collect_main'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1183, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1183, "snippet": {"text": "    if (!_Py_atomic_compare_exchange_int(&gcstate->collecting, &expected, 1)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'false' branch (when 'reason != 0')..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1194, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1194, "snippet": {"text": "    assert(generation >= 0 && generation < NUM_GENERATIONS);\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1203, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1203, "snippet": {"text": "    if (reason != _Py_GC_REASON_SHUTDOWN) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'false' branch (when 'reason == 1')..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1207, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 1207, "snippet": {"text": "    if (gcstate->debug & _PyGC_DEBUG_STATS) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1225, "startColumn": 5, "endColumn": 52}, "contextRegion": {"startLine": 1225, "snippet": {"text": "    gc_collect_internal(interp, &state, generation);\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "calling 'gc_collect_internal' from 'gc_collect_main'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1093, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 1093, "snippet": {"text": "gc_collect_internal(PyInterpreterState *interp, struct collection_state *state, int generation)\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "entry to 'gc_collect_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1098, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1098, "snippet": {"text": "    if (generation+1 < NUM_GENERATIONS) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1102, "startColumn": 5, "endColumn": 10}, "contextRegion": {"startLine": 1102, "snippet": {"text": "    state->gcstate->young.count = 0;\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1103, "startColumn": 21, "endColumn": 36}, "contextRegion": {"startLine": 1103, "snippet": {"text": "    for (int i = 1; i <= generation; ++i) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i <= generation')..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1104, "startColumn": 9, "endColumn": 14}, "contextRegion": {"startLine": 1104, "snippet": {"text": "        state->gcstate->old[i-1].count = 0;\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1113, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1113, "snippet": {"text": "    if (err < 0) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "following 'false' branch (when 'err >= 0')..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1120, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 1120, "snippet": {"text": "    if (interp->gc.debug & _PyGC_DEBUG_COLLECTABLE) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1144, "startColumn": 11, "endColumn": 44}, "contextRegion": {"startLine": 1144, "snippet": {"text": "    err = handle_resurrected_objects(state);\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "calling 'handle_resurrected_objects' from 'gc_collect_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 893, "startColumn": 1, "endColumn": 27}, "contextRegion": {"startLine": 893, "snippet": {"text": "handle_resurrected_objects(struct collection_state *state)\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "entry to 'handle_resurrected_objects'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 899, "startColumn": 26, "endColumn": 30}, "contextRegion": {"startLine": 899, "snippet": {"text": "    struct worklist_iter iter;\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 899, "startColumn": 26, "endColumn": 30}, "contextRegion": {"startLine": 899, "snippet": {"text": "    struct worklist_iter iter;\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "capacity: 8 bytes"}}, "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 900, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 900, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "inlined call to 'worklist_iter_init' from 'handle_resurrected_objects'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 99, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 99, "snippet": {"text": "    if (op) {\n"}}}, "logicalLocations": [{"name": "worklist_iter_init", "fullyQualifiedName": "worklist_iter_init", "decoratedName": "worklist_iter_init", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 900, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 900, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "following 'true' branch (when 'op' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 901, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 901, "snippet": {"text": "        assert(gc_is_unreachable(op));\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 904, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 904, "snippet": {"text": "        if (!_PyObject_GC_IS_TRACKED(op)) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 913, "startColumn": 9, "endColumn": 19}, "contextRegion": {"startLine": 913, "snippet": {"text": "        Py_ssize_t refcount = (op->ob_ref_shared >> _Py_REF_SHARED_SHIFT);\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 914, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 914, "snippet": {"text": "        if (refcount > INT32_MAX) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "following 'false' branch (when 'refcount <= 2147483647')..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 923, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 923, "snippet": {"text": "        op->ob_ref_local += (uint32_t)refcount;\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 900, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 900, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "inlined call to 'worklist_iter_init' from 'handle_resurrected_objects'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 98, "startColumn": 32, "endColumn": 44}, "contextRegion": {"startLine": 98, "snippet": {"text": "    PyObject *op = (PyObject *)*(iter->ptr);\n"}}}, "logicalLocations": [{"name": "worklist_iter_init", "fullyQualifiedName": "worklist_iter_init", "decoratedName": "worklist_iter_init", "kind": "function"}], "message": {"text": "use of uninitialized value 'iter.next' here"}}, "kinds": ["danger"], "nestingLevel": 5}]}]}]}, {"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value 'iter.next'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 98, "startColumn": 32, "endColumn": 44}, "contextRegion": {"startLine": 98, "snippet": {"text": "    PyObject *op = (PyObject *)*(iter->ptr);\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1678, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 1678, "snippet": {"text": "_Py_RunGC(PyThreadState *tstate)\n"}}}, "logicalLocations": [{"name": "_Py_RunGC", "fullyQualifiedName": "_Py_RunGC", "decoratedName": "_Py_RunGC", "kind": "function"}], "message": {"text": "entry to '_Py_RunGC'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1681, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1681, "snippet": {"text": "    if (!gcstate->enabled) {\n"}}}, "logicalLocations": [{"name": "_Py_RunGC", "fullyQualifiedName": "_Py_RunGC", "decoratedName": "_Py_RunGC", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1684, "startColumn": 5, "endColumn": 20}, "contextRegion": {"startLine": 1684, "snippet": {"text": "    gc_collect_main(tstate, 0, _Py_GC_REASON_HEAP);\n"}}}, "logicalLocations": [{"name": "_Py_RunGC", "fullyQualifiedName": "_Py_RunGC", "decoratedName": "_Py_RunGC", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1684, "startColumn": 5, "endColumn": 51}, "contextRegion": {"startLine": 1684, "snippet": {"text": "    gc_collect_main(tstate, 0, _Py_GC_REASON_HEAP);\n"}}}, "logicalLocations": [{"name": "_Py_RunGC", "fullyQualifiedName": "_Py_RunGC", "decoratedName": "_Py_RunGC", "kind": "function"}], "message": {"text": "calling 'gc_collect_main' from '_Py_RunGC'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1170, "startColumn": 1, "endColumn": 16}, "contextRegion": {"startLine": 1170, "snippet": {"text": "gc_collect_main(PyThreadState *tstate, int generation, _PyGC_Reason reason)\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "entry to 'gc_collect_main'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1183, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1183, "snippet": {"text": "    if (!_Py_atomic_compare_exchange_int(&gcstate->collecting, &expected, 1)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'true' branch (when 'reason == 0')..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 42, "endColumn": 68}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 42, "endColumn": 68}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "calling 'gc_should_collect' from 'gc_collect_main'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1043, "startColumn": 1, "endColumn": 18}, "contextRegion": {"startLine": 1043, "snippet": {"text": "gc_should_collect(GCState *gcstate)\n"}}}, "logicalLocations": [{"name": "gc_should_collect", "fullyQualifiedName": "gc_should_collect", "decoratedName": "gc_should_collect", "kind": "function"}], "message": {"text": "entry to 'gc_should_collect'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1047, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1047, "snippet": {"text": "    if (count <= threshold || threshold == 0 || !gcstate->enabled) {\n"}}}, "logicalLocations": [{"name": "gc_should_collect", "fullyQualifiedName": "gc_should_collect", "decoratedName": "gc_should_collect", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1053, "startColumn": 5, "endColumn": 11}, "contextRegion": {"startLine": 1053, "snippet": {"text": "    return (count > gcstate->long_lived_total / 4 ||\n"}}}, "logicalLocations": [{"name": "gc_should_collect", "fullyQualifiedName": "gc_should_collect", "decoratedName": "gc_should_collect", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 42, "endColumn": 68}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "returning to 'gc_collect_main' from 'gc_should_collect'"}}, "kinds": ["return", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1188, "startColumn": 9, "endColumn": 68}, "contextRegion": {"startLine": 1188, "snippet": {"text": "    if (reason == _Py_GC_REASON_HEAP && !gc_should_collect(gcstate)) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1194, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1194, "snippet": {"text": "    assert(generation >= 0 && generation < NUM_GENERATIONS);\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1203, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1203, "snippet": {"text": "    if (reason != _Py_GC_REASON_SHUTDOWN) {\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "following 'true' branch (when 'reason != 1')..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1204, "startColumn": 9, "endColumn": 27}, "contextRegion": {"startLine": 1204, "snippet": {"text": "        invoke_gc_callback(tstate, \"start\", generation, 0, 0);\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1225, "startColumn": 5, "endColumn": 52}, "contextRegion": {"startLine": 1225, "snippet": {"text": "    gc_collect_internal(interp, &state, generation);\n"}}}, "logicalLocations": [{"name": "gc_collect_main", "fullyQualifiedName": "gc_collect_main", "decoratedName": "gc_collect_main", "kind": "function"}], "message": {"text": "calling 'gc_collect_internal' from 'gc_collect_main'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1093, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 1093, "snippet": {"text": "gc_collect_internal(PyInterpreterState *interp, struct collection_state *state, int generation)\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "entry to 'gc_collect_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1098, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1098, "snippet": {"text": "    if (generation+1 < NUM_GENERATIONS) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1099, "startColumn": 9, "endColumn": 14}, "contextRegion": {"startLine": 1099, "snippet": {"text": "        state->gcstate->old[generation].count += 1;\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1103, "startColumn": 21, "endColumn": 36}, "contextRegion": {"startLine": 1103, "snippet": {"text": "    for (int i = 1; i <= generation; ++i) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "following 'false' branch (when 'i > generation')..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1108, "startColumn": 5, "endColumn": 29}, "contextRegion": {"startLine": 1108, "snippet": {"text": "    merge_all_queued_objects(interp, state);\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1113, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1113, "snippet": {"text": "    if (err < 0) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "following 'false' branch (when 'err >= 0')..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1120, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 1120, "snippet": {"text": "    if (interp->gc.debug & _PyGC_DEBUG_COLLECTABLE) {\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 1144, "startColumn": 11, "endColumn": 44}, "contextRegion": {"startLine": 1144, "snippet": {"text": "    err = handle_resurrected_objects(state);\n"}}}, "logicalLocations": [{"name": "gc_collect_internal", "fullyQualifiedName": "gc_collect_internal", "decoratedName": "gc_collect_internal", "kind": "function"}], "message": {"text": "calling 'handle_resurrected_objects' from 'gc_collect_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 893, "startColumn": 1, "endColumn": 27}, "contextRegion": {"startLine": 893, "snippet": {"text": "handle_resurrected_objects(struct collection_state *state)\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "entry to 'handle_resurrected_objects'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 899, "startColumn": 26, "endColumn": 30}, "contextRegion": {"startLine": 899, "snippet": {"text": "    struct worklist_iter iter;\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 899, "startColumn": 26, "endColumn": 30}, "contextRegion": {"startLine": 899, "snippet": {"text": "    struct worklist_iter iter;\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "capacity: 8 bytes"}}, "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 900, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 900, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "inlined call to 'worklist_iter_init' from 'handle_resurrected_objects'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 99, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 99, "snippet": {"text": "    if (op) {\n"}}}, "logicalLocations": [{"name": "worklist_iter_init", "fullyQualifiedName": "worklist_iter_init", "decoratedName": "worklist_iter_init", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 900, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 900, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "following 'true' branch (when 'op' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 901, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 901, "snippet": {"text": "        assert(gc_is_unreachable(op));\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 904, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 904, "snippet": {"text": "        if (!_PyObject_GC_IS_TRACKED(op)) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 913, "startColumn": 9, "endColumn": 19}, "contextRegion": {"startLine": 913, "snippet": {"text": "        Py_ssize_t refcount = (op->ob_ref_shared >> _Py_REF_SHARED_SHIFT);\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 914, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 914, "snippet": {"text": "        if (refcount > INT32_MAX) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "following 'false' branch (when 'refcount <= 2147483647')..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 923, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 923, "snippet": {"text": "        op->ob_ref_local += (uint32_t)refcount;\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 900, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 900, "snippet": {"text": "    WORKSTACK_FOR_EACH_ITER(&state->unreachable, &iter, op) {\n"}}}, "logicalLocations": [{"name": "handle_resurrected_objects", "fullyQualifiedName": "handle_resurrected_objects", "decoratedName": "handle_resurrected_objects", "kind": "function"}], "message": {"text": "inlined call to 'worklist_iter_init' from 'handle_resurrected_objects'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/gc_free_threading.c", "uriBaseId": "PWD"}, "region": {"startLine": 98, "startColumn": 32, "endColumn": 44}, "contextRegion": {"startLine": 98, "snippet": {"text": "    PyObject *op = (PyObject *)*(iter->ptr);\n"}}}, "logicalLocations": [{"name": "worklist_iter_init", "fullyQualifiedName": "worklist_iter_init", "decoratedName": "worklist_iter_init", "kind": "function"}], "message": {"text": "use of uninitialized value 'iter.next' here"}}, "kinds": ["danger"], "nestingLevel": 5}]}]}]}]}]}
