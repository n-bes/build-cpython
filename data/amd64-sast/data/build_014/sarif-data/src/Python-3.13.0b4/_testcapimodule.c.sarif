{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-allocation-size", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-allocation-size"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "131", "helpUri": "https://cwe.mitre.org/data/definitions/131.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.13.0b4/"}}, "artifacts": [{"location": {"uri": "./Modules/_testcapi/util.h", "uriBaseId": "PWD"}, "contents": {"text": "#define NULLABLE(x) do {                    \\\n        if (x == Py_None) {                 \\\n            x = NULL;                       \\\n        }                                   \\\n    } while (0);\n\n#define RETURN_INT(value) do {              \\\n        int _ret = (value);                 \\\n        if (_ret == -1) {                   \\\n            assert(PyErr_Occurred());       \\\n            return NULL;                    \\\n        }                                   \\\n        assert(!PyErr_Occurred());          \\\n        return PyLong_FromLong(_ret);       \\\n    } while (0)\n\n#define RETURN_SIZE(value) do {             \\\n        Py_ssize_t _ret = (value);          \\\n        if (_ret == -1) {                   \\\n            assert(PyErr_Occurred());       \\\n            return NULL;                    \\\n        }                                   \\\n        assert(!PyErr_Occurred());          \\\n        return PyLong_FromSsize_t(_ret);    \\\n    } while (0)\n\n/* Marker to check that pointer value was set. */\nstatic const char uninitialized[] = \"uninitialized\";\n#define UNINITIALIZED_PTR ((void *)uninitialized)\n/* Marker to check that Py_ssize_t value was set. */\n#define UNINITIALIZED_SIZE ((Py_ssize_t)236892191)\n/* Marker to check that integer value was set. */\n#define UNINITIALIZED_INT (63256717)\n"}, "sourceLanguage": "c"}, {"location": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "contents": {"text": "/*\n * C Extension module to test Python interpreter C APIs.\n *\n * The 'test_*' functions exported by this module are run as part of the\n * standard Python regression test, via Lib/test/test_capi.py.\n */\n\n// Include parts.h first since it takes care of NDEBUG and Py_BUILD_CORE macros\n// and including Python.h.\n//\n// Several parts of this module are broken out into files in _testcapi/.\n// Include definitions from there.\n#include \"_testcapi/parts.h\"\n\n#include \"frameobject.h\"          // PyFrame_New()\n#include \"marshal.h\"              // PyMarshal_WriteLongToFile()\n\n#include <float.h>                // FLT_MAX\n#include <signal.h>\n#include <stddef.h>               // offsetof()\n\n#ifdef HAVE_SYS_WAIT_H\n#  include <sys/wait.h>           // W_STOPCODE\n#endif\n\n#ifdef bool\n#  error \"The public headers should not include <stdbool.h>, see gh-48924\"\n#endif\n\n#include \"_testcapi/util.h\"\n\n\n// Forward declarations\nstatic struct PyModuleDef _testcapimodule;\n\n// Module state\ntypedef struct {\n    PyObject *error; // _testcapi.error object\n} testcapistate_t;\n\nstatic testcapistate_t*\nget_testcapi_state(PyObject *module)\n{\n    void *state = PyModule_GetState(module);\n    assert(state != NULL);\n    return (testcapistate_t *)state;\n}\n\nstatic PyObject *\nget_testerror(PyObject *self) {\n    testcapistate_t *state = get_testcapi_state(self);\n    return state->error;\n}\n\n/* Raise _testcapi.error with test_name + \": \" + msg, and return NULL. */\n\nstatic PyObject *\nraiseTestError(PyObject *self, const char* test_name, const char* msg)\n{\n    PyErr_Format(get_testerror(self), \"%s: %s\", test_name, msg);\n    return NULL;\n}\n\n/* Test #defines from pyconfig.h (particularly the SIZEOF_* defines).\n\n   The ones derived from autoconf on the UNIX-like OSes can be relied\n   upon (in the absence of sloppy cross-compiling), but the Windows\n   platforms have these hardcoded.  Better safe than sorry.\n*/\nstatic PyObject*\nsizeof_error(PyObject *self, const char* fatname, const char* typname,\n    int expected, int got)\n{\n    PyErr_Format(get_testerror(self),\n        \"%s #define == %d but sizeof(%s) == %d\",\n        fatname, expected, typname, got);\n    return (PyObject*)NULL;\n}\n\nstatic PyObject*\ntest_config(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n#define CHECK_SIZEOF(FATNAME, TYPE) \\\n            if (FATNAME != sizeof(TYPE)) \\\n                return sizeof_error(self, #FATNAME, #TYPE, FATNAME, sizeof(TYPE))\n\n    CHECK_SIZEOF(SIZEOF_SHORT, short);\n    CHECK_SIZEOF(SIZEOF_INT, int);\n    CHECK_SIZEOF(SIZEOF_LONG, long);\n    CHECK_SIZEOF(SIZEOF_VOID_P, void*);\n    CHECK_SIZEOF(SIZEOF_TIME_T, time_t);\n    CHECK_SIZEOF(SIZEOF_LONG_LONG, long long);\n\n#undef CHECK_SIZEOF\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject*\ntest_sizeof_c_types(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n#if defined(__GNUC__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5)))\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wtype-limits\"\n#endif\n#define CHECK_SIZEOF(TYPE, EXPECTED)         \\\n    if (EXPECTED != sizeof(TYPE))  {         \\\n        PyErr_Format(get_testerror(self),    \\\n            \"sizeof(%s) = %u instead of %u\", \\\n            #TYPE, sizeof(TYPE), EXPECTED);  \\\n        return (PyObject*)NULL;              \\\n    }\n#define IS_SIGNED(TYPE) (((TYPE)-1) < (TYPE)0)\n#define CHECK_SIGNNESS(TYPE, SIGNED)            \\\n    if (IS_SIGNED(TYPE) != SIGNED) {            \\\n        PyErr_Format(get_testerror(self),       \\\n            \"%s signness is %i, instead of %i\", \\\n            #TYPE, IS_SIGNED(TYPE), SIGNED);    \\\n        return (PyObject*)NULL;                 \\\n    }\n\n    /* integer types */\n    CHECK_SIZEOF(Py_UCS1, 1);\n    CHECK_SIZEOF(Py_UCS2, 2);\n    CHECK_SIZEOF(Py_UCS4, 4);\n    CHECK_SIGNNESS(Py_UCS1, 0);\n    CHECK_SIGNNESS(Py_UCS2, 0);\n    CHECK_SIGNNESS(Py_UCS4, 0);\n    CHECK_SIZEOF(int32_t, 4);\n    CHECK_SIGNNESS(int32_t, 1);\n    CHECK_SIZEOF(uint32_t, 4);\n    CHECK_SIGNNESS(uint32_t, 0);\n    CHECK_SIZEOF(int64_t, 8);\n    CHECK_SIGNNESS(int64_t, 1);\n    CHECK_SIZEOF(uint64_t, 8);\n    CHECK_SIGNNESS(uint64_t, 0);\n\n    /* pointer/size types */\n    CHECK_SIZEOF(size_t, sizeof(void *));\n    CHECK_SIGNNESS(size_t, 0);\n    CHECK_SIZEOF(Py_ssize_t, sizeof(void *));\n    CHECK_SIGNNESS(Py_ssize_t, 1);\n\n    CHECK_SIZEOF(uintptr_t, sizeof(void *));\n    CHECK_SIGNNESS(uintptr_t, 0);\n    CHECK_SIZEOF(intptr_t, sizeof(void *));\n    CHECK_SIGNNESS(intptr_t, 1);\n\n    Py_RETURN_NONE;\n\n#undef IS_SIGNED\n#undef CHECK_SIGNESS\n#undef CHECK_SIZEOF\n#if defined(__GNUC__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5)))\n#pragma GCC diagnostic pop\n#endif\n}\n\nstatic PyObject*\ntest_list_api(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    PyObject* list;\n    int i;\n\n    /* SF bug 132008:  PyList_Reverse segfaults */\n#define NLIST 30\n    list = PyList_New(NLIST);\n    if (list == (PyObject*)NULL)\n        return (PyObject*)NULL;\n    /* list = range(NLIST) */\n    for (i = 0; i < NLIST; ++i) {\n        PyObject* anint = PyLong_FromLong(i);\n        if (anint == (PyObject*)NULL) {\n            Py_DECREF(list);\n            return (PyObject*)NULL;\n        }\n        PyList_SET_ITEM(list, i, anint);\n    }\n    /* list.reverse(), via PyList_Reverse() */\n    i = PyList_Reverse(list);   /* should not blow up! */\n    if (i != 0) {\n        Py_DECREF(list);\n        return (PyObject*)NULL;\n    }\n    /* Check that list == range(29, -1, -1) now */\n    for (i = 0; i < NLIST; ++i) {\n        PyObject* anint = PyList_GET_ITEM(list, i);\n        if (PyLong_AS_LONG(anint) != NLIST-1-i) {\n            PyErr_SetString(get_testerror(self),\n                            \"test_list_api: reverse screwed up\");\n            Py_DECREF(list);\n            return (PyObject*)NULL;\n        }\n    }\n    Py_DECREF(list);\n#undef NLIST\n\n    Py_RETURN_NONE;\n}\n\nstatic int\ntest_dict_inner(PyObject *self, int count)\n{\n    Py_ssize_t pos = 0, iterations = 0;\n    int i;\n    PyObject *dict = PyDict_New();\n    PyObject *v, *k;\n\n    if (dict == NULL)\n        return -1;\n\n    for (i = 0; i < count; i++) {\n        v = PyLong_FromLong(i);\n        if (v == NULL) {\n            goto error;\n        }\n        if (PyDict_SetItem(dict, v, v) < 0) {\n            Py_DECREF(v);\n            goto error;\n        }\n        Py_DECREF(v);\n    }\n\n    k = v = UNINITIALIZED_PTR;\n    while (PyDict_Next(dict, &pos, &k, &v)) {\n        PyObject *o;\n        iterations++;\n\n        assert(k != UNINITIALIZED_PTR);\n        assert(v != UNINITIALIZED_PTR);\n        i = PyLong_AS_LONG(v) + 1;\n        o = PyLong_FromLong(i);\n        if (o == NULL) {\n            goto error;\n        }\n        if (PyDict_SetItem(dict, k, o) < 0) {\n            Py_DECREF(o);\n            goto error;\n        }\n        Py_DECREF(o);\n        k = v = UNINITIALIZED_PTR;\n    }\n    assert(k == UNINITIALIZED_PTR);\n    assert(v == UNINITIALIZED_PTR);\n\n    Py_DECREF(dict);\n\n    if (iterations != count) {\n        PyErr_SetString(\n            get_testerror(self),\n            \"test_dict_iteration: dict iteration went wrong \");\n        return -1;\n    } else {\n        return 0;\n    }\nerror:\n    Py_DECREF(dict);\n    return -1;\n}\n\n\n\nstatic PyObject*\ntest_dict_iteration(PyObject* self, PyObject *Py_UNUSED(ignored))\n{\n    int i;\n\n    for (i = 0; i < 200; i++) {\n        if (test_dict_inner(self, i) < 0) {\n            return NULL;\n        }\n    }\n\n    Py_RETURN_NONE;\n}\n\n/* Issue #4701: Check that PyObject_Hash implicitly calls\n *   PyType_Ready if it hasn't already been called\n */\nstatic PyTypeObject _HashInheritanceTester_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"hashinheritancetester\",            /* Name of this type */\n    sizeof(PyObject),           /* Basic object size */\n    0,                          /* Item size for varobject */\n    (destructor)PyObject_Del, /* tp_dealloc */\n    0,                          /* tp_vectorcall_offset */\n    0,                          /* tp_getattr */\n    0,                          /* tp_setattr */\n    0,                          /* tp_as_async */\n    0,                          /* tp_repr */\n    0,                          /* tp_as_number */\n    0,                          /* tp_as_sequence */\n    0,                          /* tp_as_mapping */\n    0,                          /* tp_hash */\n    0,                          /* tp_call */\n    0,                          /* tp_str */\n    PyObject_GenericGetAttr,  /* tp_getattro */\n    0,                          /* tp_setattro */\n    0,                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,         /* tp_flags */\n    0,                          /* tp_doc */\n    0,                          /* tp_traverse */\n    0,                          /* tp_clear */\n    0,                          /* tp_richcompare */\n    0,                          /* tp_weaklistoffset */\n    0,                          /* tp_iter */\n    0,                          /* tp_iternext */\n    0,                          /* tp_methods */\n    0,                          /* tp_members */\n    0,                          /* tp_getset */\n    0,                          /* tp_base */\n    0,                          /* tp_dict */\n    0,                          /* tp_descr_get */\n    0,                          /* tp_descr_set */\n    0,                          /* tp_dictoffset */\n    0,                          /* tp_init */\n    0,                          /* tp_alloc */\n    PyType_GenericNew,                  /* tp_new */\n};\n\nstatic PyObject*\npycompilestring(PyObject* self, PyObject *obj) {\n    if (PyBytes_CheckExact(obj) == 0) {\n        PyErr_SetString(PyExc_ValueError, \"Argument must be a bytes object\");\n        return NULL;\n    }\n    const char *the_string = PyBytes_AsString(obj);\n    if (the_string == NULL) {\n        return NULL;\n    }\n    return Py_CompileString(the_string, \"<string>\", Py_file_input);\n}\n\nstatic PyObject*\ntest_lazy_hash_inheritance(PyObject* self, PyObject *Py_UNUSED(ignored))\n{\n    PyTypeObject *type;\n    PyObject *obj;\n    Py_hash_t hash;\n\n    type = &_HashInheritanceTester_Type;\n\n    if (type->tp_dict != NULL)\n        /* The type has already been initialized. This probably means\n           -R is being used. */\n        Py_RETURN_NONE;\n\n\n    obj = PyObject_New(PyObject, type);\n    if (obj == NULL) {\n        PyErr_Clear();\n        PyErr_SetString(\n            get_testerror(self),\n            \"test_lazy_hash_inheritance: failed to create object\");\n        return NULL;\n    }\n\n    if (type->tp_dict != NULL) {\n        PyErr_SetString(\n            get_testerror(self),\n            \"test_lazy_hash_inheritance: type initialised too soon\");\n        Py_DECREF(obj);\n        return NULL;\n    }\n\n    hash = PyObject_Hash(obj);\n    if ((hash == -1) && PyErr_Occurred()) {\n        PyErr_Clear();\n        PyErr_SetString(\n            get_testerror(self),\n            \"test_lazy_hash_inheritance: could not hash object\");\n        Py_DECREF(obj);\n        return NULL;\n    }\n\n    if (type->tp_dict == NULL) {\n        PyErr_SetString(\n            get_testerror(self),\n            \"test_lazy_hash_inheritance: type not initialised by hash()\");\n        Py_DECREF(obj);\n        return NULL;\n    }\n\n    if (type->tp_hash != PyType_Type.tp_hash) {\n        PyErr_SetString(\n            get_testerror(self),\n            \"test_lazy_hash_inheritance: unexpected hash function\");\n        Py_DECREF(obj);\n        return NULL;\n    }\n\n    Py_DECREF(obj);\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nreturn_none(void *unused)\n{\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nraise_error(void *unused)\n{\n    PyErr_SetNone(PyExc_ValueError);\n    return NULL;\n}\n\nstatic PyObject *\npy_buildvalue(PyObject *self, PyObject *args)\n{\n    const char *fmt;\n    PyObject *objs[10] = {NULL};\n    if (!PyArg_ParseTuple(args, \"s|OOOOOOOOOO\", &fmt,\n            &objs[0], &objs[1], &objs[2], &objs[3], &objs[4],\n            &objs[5], &objs[6], &objs[7], &objs[8], &objs[9]))\n    {\n        return NULL;\n    }\n    for(int i = 0; i < 10; i++) {\n        NULLABLE(objs[i]);\n    }\n    return Py_BuildValue(fmt,\n            objs[0], objs[1], objs[2], objs[3], objs[4],\n            objs[5], objs[6], objs[7], objs[8], objs[9]);\n}\n\nstatic PyObject *\npy_buildvalue_ints(PyObject *self, PyObject *args)\n{\n    const char *fmt;\n    unsigned int values[10] = {0};\n    if (!PyArg_ParseTuple(args, \"s|IIIIIIIIII\", &fmt,\n            &values[0], &values[1], &values[2], &values[3], &values[4],\n            &values[5], &values[6], &values[7], &values[8], &values[9]))\n    {\n        return NULL;\n    }\n    return Py_BuildValue(fmt,\n            values[0], values[1], values[2], values[3], values[4],\n            values[5], values[6], values[7], values[8], values[9]);\n}\n\nstatic int\ntest_buildvalue_N_error(PyObject *self, const char *fmt)\n{\n    PyObject *arg, *res;\n\n    arg = PyList_New(0);\n    if (arg == NULL) {\n        return -1;\n    }\n\n    Py_INCREF(arg);\n    res = Py_BuildValue(fmt, return_none, NULL, arg);\n    if (res == NULL) {\n        return -1;\n    }\n    Py_DECREF(res);\n    if (Py_REFCNT(arg) != 1) {\n        PyErr_Format(get_testerror(self), \"test_buildvalue_N: \"\n                     \"arg was not decrefed in successful \"\n                     \"Py_BuildValue(\\\"%s\\\")\", fmt);\n        return -1;\n    }\n\n    Py_INCREF(arg);\n    res = Py_BuildValue(fmt, raise_error, NULL, arg);\n    if (res != NULL || !PyErr_Occurred()) {\n        PyErr_Format(get_testerror(self), \"test_buildvalue_N: \"\n                     \"Py_BuildValue(\\\"%s\\\") didn't complain\", fmt);\n        return -1;\n    }\n    PyErr_Clear();\n    if (Py_REFCNT(arg) != 1) {\n        PyErr_Format(get_testerror(self), \"test_buildvalue_N: \"\n                     \"arg was not decrefed in failed \"\n                     \"Py_BuildValue(\\\"%s\\\")\", fmt);\n        return -1;\n    }\n    Py_DECREF(arg);\n    return 0;\n}\n\nstatic PyObject *\ntest_buildvalue_N(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *arg, *res;\n\n    arg = PyList_New(0);\n    if (arg == NULL) {\n        return NULL;\n    }\n    Py_INCREF(arg);\n    res = Py_BuildValue(\"N\", arg);\n    if (res == NULL) {\n        return NULL;\n    }\n    if (res != arg) {\n        return raiseTestError(self, \"test_buildvalue_N\",\n                              \"Py_BuildValue(\\\"N\\\") returned wrong result\");\n    }\n    if (Py_REFCNT(arg) != 2) {\n        return raiseTestError(self, \"test_buildvalue_N\",\n                              \"arg was not decrefed in Py_BuildValue(\\\"N\\\")\");\n    }\n    Py_DECREF(res);\n    Py_DECREF(arg);\n\n    if (test_buildvalue_N_error(self, \"O&N\") < 0)\n        return NULL;\n    if (test_buildvalue_N_error(self, \"(O&N)\") < 0)\n        return NULL;\n    if (test_buildvalue_N_error(self, \"[O&N]\") < 0)\n        return NULL;\n    if (test_buildvalue_N_error(self, \"{O&N}\") < 0)\n        return NULL;\n    if (test_buildvalue_N_error(self, \"{()O&(())N}\") < 0)\n        return NULL;\n\n    Py_RETURN_NONE;\n}\n\n\nstatic PyObject *\ntest_get_statictype_slots(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    newfunc tp_new = PyType_GetSlot(&PyLong_Type, Py_tp_new);\n    if (PyLong_Type.tp_new != tp_new) {\n        PyErr_SetString(PyExc_AssertionError, \"mismatch: tp_new of long\");\n        return NULL;\n    }\n\n    reprfunc tp_repr = PyType_GetSlot(&PyLong_Type, Py_tp_repr);\n    if (PyLong_Type.tp_repr != tp_repr) {\n        PyErr_SetString(PyExc_AssertionError, \"mismatch: tp_repr of long\");\n        return NULL;\n    }\n\n    ternaryfunc tp_call = PyType_GetSlot(&PyLong_Type, Py_tp_call);\n    if (tp_call != NULL) {\n        PyErr_SetString(PyExc_AssertionError, \"mismatch: tp_call of long\");\n        return NULL;\n    }\n\n    binaryfunc nb_add = PyType_GetSlot(&PyLong_Type, Py_nb_add);\n    if (PyLong_Type.tp_as_number->nb_add != nb_add) {\n        PyErr_SetString(PyExc_AssertionError, \"mismatch: nb_add of long\");\n        return NULL;\n    }\n\n    lenfunc mp_length = PyType_GetSlot(&PyLong_Type, Py_mp_length);\n    if (mp_length != NULL) {\n        PyErr_SetString(PyExc_AssertionError, \"mismatch: mp_length of long\");\n        return NULL;\n    }\n\n    void *over_value = PyType_GetSlot(&PyLong_Type, Py_bf_releasebuffer + 1);\n    if (over_value != NULL) {\n        PyErr_SetString(PyExc_AssertionError, \"mismatch: max+1 of long\");\n        return NULL;\n    }\n\n    tp_new = PyType_GetSlot(&PyLong_Type, 0);\n    if (tp_new != NULL) {\n        PyErr_SetString(PyExc_AssertionError, \"mismatch: slot 0 of long\");\n        return NULL;\n    }\n    if (PyErr_ExceptionMatches(PyExc_SystemError)) {\n        // This is the right exception\n        PyErr_Clear();\n    }\n    else {\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\n\nstatic PyType_Slot HeapTypeNameType_slots[] = {\n    {0},\n};\n\nstatic PyType_Spec HeapTypeNameType_Spec = {\n    .name = \"_testcapi.HeapTypeNameType\",\n    .basicsize = sizeof(PyObject),\n    .flags = Py_TPFLAGS_DEFAULT,\n    .slots = HeapTypeNameType_slots,\n};\n\nstatic PyObject *\nget_heaptype_for_name(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    return PyType_FromSpec(&HeapTypeNameType_Spec);\n}\n\n\nstatic PyObject *\nget_type_name(PyObject *self, PyObject *type)\n{\n    assert(PyType_Check(type));\n    return PyType_GetName((PyTypeObject *)type);\n}\n\n\nstatic PyObject *\nget_type_qualname(PyObject *self, PyObject *type)\n{\n    assert(PyType_Check(type));\n    return PyType_GetQualName((PyTypeObject *)type);\n}\n\n\nstatic PyObject *\nget_type_fullyqualname(PyObject *self, PyObject *type)\n{\n    assert(PyType_Check(type));\n    return PyType_GetFullyQualifiedName((PyTypeObject *)type);\n}\n\n\nstatic PyObject *\nget_type_module_name(PyObject *self, PyObject *type)\n{\n    assert(PyType_Check(type));\n    return PyType_GetModuleName((PyTypeObject *)type);\n}\n\n\nstatic PyObject *\ntest_get_type_dict(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    /* Test for PyType_GetDict */\n\n    // Assert ints have a `to_bytes` method\n    PyObject *long_dict = PyType_GetDict(&PyLong_Type);\n    assert(long_dict);\n    assert(PyDict_GetItemString(long_dict, \"to_bytes\")); // borrowed ref\n    Py_DECREF(long_dict);\n\n    // Make a new type, add an attribute to it and assert it's there\n    PyObject *HeapTypeNameType = PyType_FromSpec(&HeapTypeNameType_Spec);\n    assert(HeapTypeNameType);\n    assert(PyObject_SetAttrString(\n        HeapTypeNameType, \"new_attr\", Py_NewRef(Py_None)) >= 0);\n    PyObject *type_dict = PyType_GetDict((PyTypeObject*)HeapTypeNameType);\n    assert(type_dict);\n    assert(PyDict_GetItemString(type_dict, \"new_attr\")); // borrowed ref\n    Py_DECREF(HeapTypeNameType);\n    Py_DECREF(type_dict);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\npyobject_repr_from_null(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    return PyObject_Repr(NULL);\n}\n\nstatic PyObject *\npyobject_str_from_null(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    return PyObject_Str(NULL);\n}\n\nstatic PyObject *\npyobject_bytes_from_null(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    return PyObject_Bytes(NULL);\n}\n\nstatic PyObject *\nset_errno(PyObject *self, PyObject *args)\n{\n    int new_errno;\n\n    if (!PyArg_ParseTuple(args, \"i:set_errno\", &new_errno))\n        return NULL;\n\n    errno = new_errno;\n    Py_RETURN_NONE;\n}\n\n/* test_thread_state spawns a thread of its own, and that thread releases\n * `thread_done` when it's finished.  The driver code has to know when the\n * thread finishes, because the thread uses a PyObject (the callable) that\n * may go away when the driver finishes.  The former lack of this explicit\n * synchronization caused rare segfaults, so rare that they were seen only\n * on a Mac buildbot (although they were possible on any box).\n */\nstatic PyThread_type_lock thread_done = NULL;\n\nstatic int\n_make_call(void *callable)\n{\n    PyObject *rc;\n    int success;\n    PyGILState_STATE s = PyGILState_Ensure();\n    rc = PyObject_CallNoArgs((PyObject *)callable);\n    success = (rc != NULL);\n    Py_XDECREF(rc);\n    PyGILState_Release(s);\n    return success;\n}\n\n/* Same thing, but releases `thread_done` when it returns.  This variant\n * should be called only from threads spawned by test_thread_state().\n */\nstatic void\n_make_call_from_thread(void *callable)\n{\n    _make_call(callable);\n    PyThread_release_lock(thread_done);\n}\n\nstatic PyObject *\ntest_thread_state(PyObject *self, PyObject *args)\n{\n    PyObject *fn;\n    int success = 1;\n\n    if (!PyArg_ParseTuple(args, \"O:test_thread_state\", &fn))\n        return NULL;\n\n    if (!PyCallable_Check(fn)) {\n        PyErr_Format(PyExc_TypeError, \"'%s' object is not callable\",\n            Py_TYPE(fn)->tp_name);\n        return NULL;\n    }\n\n    thread_done = PyThread_allocate_lock();\n    if (thread_done == NULL)\n        return PyErr_NoMemory();\n    PyThread_acquire_lock(thread_done, 1);\n\n    /* Start a new thread with our callback. */\n    PyThread_start_new_thread(_make_call_from_thread, fn);\n    /* Make the callback with the thread lock held by this thread */\n    success &= _make_call(fn);\n    /* Do it all again, but this time with the thread-lock released */\n    Py_BEGIN_ALLOW_THREADS\n    success &= _make_call(fn);\n    PyThread_acquire_lock(thread_done, 1);  /* wait for thread to finish */\n    Py_END_ALLOW_THREADS\n\n    /* And once more with and without a thread\n       XXX - should use a lock and work out exactly what we are trying\n       to test <wink>\n    */\n    Py_BEGIN_ALLOW_THREADS\n    PyThread_start_new_thread(_make_call_from_thread, fn);\n    success &= _make_call(fn);\n    PyThread_acquire_lock(thread_done, 1);  /* wait for thread to finish */\n    Py_END_ALLOW_THREADS\n\n    /* Release lock we acquired above.  This is required on HP-UX. */\n    PyThread_release_lock(thread_done);\n\n    PyThread_free_lock(thread_done);\n    if (!success)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\ngilstate_ensure_release(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    PyGILState_STATE state = PyGILState_Ensure();\n    PyGILState_Release(state);\n    Py_RETURN_NONE;\n}\n\n#ifndef MS_WINDOWS\nstatic PyThread_type_lock wait_done = NULL;\n\nstatic void wait_for_lock(void *unused) {\n    PyThread_acquire_lock(wait_done, 1);\n    PyThread_release_lock(wait_done);\n    PyThread_free_lock(wait_done);\n    wait_done = NULL;\n}\n\n// These can be used to test things that care about the existence of another\n// thread that the threading module doesn't know about.\n\nstatic PyObject *\nspawn_pthread_waiter(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    if (wait_done) {\n        PyErr_SetString(PyExc_RuntimeError, \"thread already running\");\n        return NULL;\n    }\n    wait_done = PyThread_allocate_lock();\n    if (wait_done == NULL)\n        return PyErr_NoMemory();\n    PyThread_acquire_lock(wait_done, 1);\n    PyThread_start_new_thread(wait_for_lock, NULL);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nend_spawned_pthread(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    if (!wait_done) {\n        PyErr_SetString(PyExc_RuntimeError, \"call _spawn_pthread_waiter 1st\");\n        return NULL;\n    }\n    PyThread_release_lock(wait_done);\n    Py_RETURN_NONE;\n}\n#endif  // not MS_WINDOWS\n\n/* test Py_AddPendingCalls using threads */\nstatic int _pending_callback(void *arg)\n{\n    /* we assume the argument is callable object to which we own a reference */\n    PyObject *callable = (PyObject *)arg;\n    PyObject *r = PyObject_CallNoArgs(callable);\n    Py_DECREF(callable);\n    Py_XDECREF(r);\n    return r != NULL ? 0 : -1;\n}\n\n/* The following requests n callbacks to _pending_callback.  It can be\n * run from any python thread.\n */\nstatic PyObject *\npending_threadfunc(PyObject *self, PyObject *arg, PyObject *kwargs)\n{\n    static char *kwlist[] = {\"callback\", \"num\",\n                             \"blocking\", \"ensure_added\", NULL};\n    PyObject *callable;\n    unsigned int num = 1;\n    int blocking = 0;\n    int ensure_added = 0;\n    if (!PyArg_ParseTupleAndKeywords(arg, kwargs,\n                                     \"O|I$pp:_pending_threadfunc\", kwlist,\n                                     &callable, &num, &blocking, &ensure_added))\n    {\n        return NULL;\n    }\n\n    /* create the reference for the callbackwhile we hold the lock */\n    for (unsigned int i = 0; i < num; i++) {\n        Py_INCREF(callable);\n    }\n\n    PyThreadState *save_tstate = NULL;\n    if (!blocking) {\n        save_tstate = PyEval_SaveThread();\n    }\n\n    unsigned int num_added = 0;\n    for (; num_added < num; num_added++) {\n        if (ensure_added) {\n            int r;\n            do {\n                r = Py_AddPendingCall(&_pending_callback, callable);\n            } while (r < 0);\n        }\n        else {\n            if (Py_AddPendingCall(&_pending_callback, callable) < 0) {\n                break;\n            }\n        }\n    }\n\n    if (!blocking) {\n        PyEval_RestoreThread(save_tstate);\n    }\n\n    for (unsigned int i = num_added; i < num; i++) {\n        Py_DECREF(callable); /* unsuccessful add, destroy the extra reference */\n    }\n    /* The callable is decref'ed above in each added _pending_callback(). */\n    return PyLong_FromUnsignedLong((unsigned long)num_added);\n}\n\n/* Test PyOS_string_to_double. */\nstatic PyObject *\ntest_string_to_double(PyObject *self, PyObject *Py_UNUSED(ignored)) {\n    double result;\n    const char *msg;\n\n#define CHECK_STRING(STR, expected)                             \\\n    result = PyOS_string_to_double(STR, NULL, NULL);            \\\n    if (result == -1.0 && PyErr_Occurred())                     \\\n        return NULL;                                            \\\n    if (result != (double)expected) {                           \\\n        msg = \"conversion of \" STR \" to float failed\";          \\\n        goto fail;                                              \\\n    }\n\n#define CHECK_INVALID(STR)                                              \\\n    result = PyOS_string_to_double(STR, NULL, NULL);                    \\\n    if (result == -1.0 && PyErr_Occurred()) {                           \\\n        if (PyErr_ExceptionMatches(PyExc_ValueError))                   \\\n            PyErr_Clear();                                              \\\n        else                                                            \\\n            return NULL;                                                \\\n    }                                                                   \\\n    else {                                                              \\\n        msg = \"conversion of \" STR \" didn't raise ValueError\";          \\\n        goto fail;                                                      \\\n    }\n\n    CHECK_STRING(\"0.1\", 0.1);\n    CHECK_STRING(\"1.234\", 1.234);\n    CHECK_STRING(\"-1.35\", -1.35);\n    CHECK_STRING(\".1e01\", 1.0);\n    CHECK_STRING(\"2.e-2\", 0.02);\n\n    CHECK_INVALID(\" 0.1\");\n    CHECK_INVALID(\"\\t\\n-3\");\n    CHECK_INVALID(\".123 \");\n    CHECK_INVALID(\"3\\n\");\n    CHECK_INVALID(\"123abc\");\n\n    Py_RETURN_NONE;\n  fail:\n    return raiseTestError(self, \"test_string_to_double\", msg);\n#undef CHECK_STRING\n#undef CHECK_INVALID\n}\n\n\n/* Coverage testing of capsule objects. */\n\nstatic const char *capsule_name = \"capsule name\";\nstatic       char *capsule_pointer = \"capsule pointer\";\nstatic       char *capsule_context = \"capsule context\";\nstatic const char *capsule_error = NULL;\nstatic int\ncapsule_destructor_call_count = 0;\n\nstatic void\ncapsule_destructor(PyObject *o) {\n    capsule_destructor_call_count++;\n    if (PyCapsule_GetContext(o) != capsule_context) {\n        capsule_error = \"context did not match in destructor!\";\n    } else if (PyCapsule_GetDestructor(o) != capsule_destructor) {\n        capsule_error = \"destructor did not match in destructor!  (woah!)\";\n    } else if (PyCapsule_GetName(o) != capsule_name) {\n        capsule_error = \"name did not match in destructor!\";\n    } else if (PyCapsule_GetPointer(o, capsule_name) != capsule_pointer) {\n        capsule_error = \"pointer did not match in destructor!\";\n    }\n}\n\ntypedef struct {\n    char *name;\n    char *module;\n    char *attribute;\n} known_capsule;\n\nstatic PyObject *\ntest_capsule(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *object;\n    const char *error = NULL;\n    void *pointer;\n    void *pointer2;\n    known_capsule known_capsules[] = {\n        #define KNOWN_CAPSULE(module, name)             { module \".\" name, module, name }\n        KNOWN_CAPSULE(\"_socket\", \"CAPI\"),\n        KNOWN_CAPSULE(\"_curses\", \"_C_API\"),\n        KNOWN_CAPSULE(\"datetime\", \"datetime_CAPI\"),\n        { NULL, NULL },\n    };\n    known_capsule *known = &known_capsules[0];\n\n#define FAIL(x) { error = (x); goto exit; }\n\n#define CHECK_DESTRUCTOR \\\n    if (capsule_error) { \\\n        FAIL(capsule_error); \\\n    } \\\n    else if (!capsule_destructor_call_count) {          \\\n        FAIL(\"destructor not called!\"); \\\n    } \\\n    capsule_destructor_call_count = 0; \\\n\n    object = PyCapsule_New(capsule_pointer, capsule_name, capsule_destructor);\n    PyCapsule_SetContext(object, capsule_context);\n    capsule_destructor(object);\n    CHECK_DESTRUCTOR;\n    Py_DECREF(object);\n    CHECK_DESTRUCTOR;\n\n    object = PyCapsule_New(known, \"ignored\", NULL);\n    PyCapsule_SetPointer(object, capsule_pointer);\n    PyCapsule_SetName(object, capsule_name);\n    PyCapsule_SetDestructor(object, capsule_destructor);\n    PyCapsule_SetContext(object, capsule_context);\n    capsule_destructor(object);\n    CHECK_DESTRUCTOR;\n    /* intentionally access using the wrong name */\n    pointer2 = PyCapsule_GetPointer(object, \"the wrong name\");\n    if (!PyErr_Occurred()) {\n        FAIL(\"PyCapsule_GetPointer should have failed but did not!\");\n    }\n    PyErr_Clear();\n    if (pointer2) {\n        if (pointer2 == capsule_pointer) {\n            FAIL(\"PyCapsule_GetPointer should not have\"\n                     \" returned the internal pointer!\");\n        } else {\n            FAIL(\"PyCapsule_GetPointer should have \"\n                     \"returned NULL pointer but did not!\");\n        }\n    }\n    PyCapsule_SetDestructor(object, NULL);\n    Py_DECREF(object);\n    if (capsule_destructor_call_count) {\n        FAIL(\"destructor called when it should not have been!\");\n    }\n\n    for (known = &known_capsules[0]; known->module != NULL; known++) {\n        /* yeah, ordinarily I wouldn't do this either,\n           but it's fine for this test harness.\n        */\n        static char buffer[256];\n#undef FAIL\n#define FAIL(x) \\\n        { \\\n        sprintf(buffer, \"%s module: \\\"%s\\\" attribute: \\\"%s\\\"\", \\\n            x, known->module, known->attribute); \\\n        error = buffer; \\\n        goto exit; \\\n        } \\\n\n        PyObject *module = PyImport_ImportModule(known->module);\n        if (module) {\n            pointer = PyCapsule_Import(known->name, 0);\n            if (!pointer) {\n                Py_DECREF(module);\n                FAIL(\"PyCapsule_GetPointer returned NULL unexpectedly!\");\n            }\n            object = PyObject_GetAttrString(module, known->attribute);\n            if (!object) {\n                Py_DECREF(module);\n                return NULL;\n            }\n            pointer2 = PyCapsule_GetPointer(object,\n                                    \"weebles wobble but they don't fall down\");\n            if (!PyErr_Occurred()) {\n                Py_DECREF(object);\n                Py_DECREF(module);\n                FAIL(\"PyCapsule_GetPointer should have failed but did not!\");\n            }\n            PyErr_Clear();\n            if (pointer2) {\n                Py_DECREF(module);\n                Py_DECREF(object);\n                if (pointer2 == pointer) {\n                    FAIL(\"PyCapsule_GetPointer should not have\"\n                             \" returned its internal pointer!\");\n                } else {\n                    FAIL(\"PyCapsule_GetPointer should have\"\n                             \" returned NULL pointer but did not!\");\n                }\n            }\n            Py_DECREF(object);\n            Py_DECREF(module);\n        }\n        else\n            PyErr_Clear();\n    }\n\n  exit:\n    if (error) {\n        return raiseTestError(self, \"test_capsule\", error);\n    }\n    Py_RETURN_NONE;\n#undef FAIL\n}\n\n#ifdef HAVE_GETTIMEOFDAY\n/* Profiling of integer performance */\nstatic void print_delta(int test, struct timeval *s, struct timeval *e)\n{\n    e->tv_sec -= s->tv_sec;\n    e->tv_usec -= s->tv_usec;\n    if (e->tv_usec < 0) {\n        e->tv_sec -=1;\n        e->tv_usec += 1000000;\n    }\n    printf(\"Test %d: %d.%06ds\\n\", test, (int)e->tv_sec, (int)e->tv_usec);\n}\n\nstatic PyObject *\nprofile_int(PyObject *self, PyObject* args)\n{\n    int i, k;\n    struct timeval start, stop;\n    PyObject *single, **multiple, *op1, *result;\n\n    /* Test 1: Allocate and immediately deallocate\n       many small integers */\n    gettimeofday(&start, NULL);\n    for(k=0; k < 20000; k++)\n        for(i=0; i < 1000; i++) {\n            single = PyLong_FromLong(i);\n            Py_DECREF(single);\n        }\n    gettimeofday(&stop, NULL);\n    print_delta(1, &start, &stop);\n\n    /* Test 2: Allocate and immediately deallocate\n       many large integers */\n    gettimeofday(&start, NULL);\n    for(k=0; k < 20000; k++)\n        for(i=0; i < 1000; i++) {\n            single = PyLong_FromLong(i+1000000);\n            Py_DECREF(single);\n        }\n    gettimeofday(&stop, NULL);\n    print_delta(2, &start, &stop);\n\n    /* Test 3: Allocate a few integers, then release\n       them all simultaneously. */\n    multiple = malloc(sizeof(PyObject*) * 1000);\n    if (multiple == NULL)\n        return PyErr_NoMemory();\n    gettimeofday(&start, NULL);\n    for(k=0; k < 20000; k++) {\n        for(i=0; i < 1000; i++) {\n            multiple[i] = PyLong_FromLong(i+1000000);\n        }\n        for(i=0; i < 1000; i++) {\n            Py_DECREF(multiple[i]);\n        }\n    }\n    gettimeofday(&stop, NULL);\n    print_delta(3, &start, &stop);\n    free(multiple);\n\n    /* Test 4: Allocate many integers, then release\n       them all simultaneously. */\n    multiple = malloc(sizeof(PyObject*) * 1000000);\n    if (multiple == NULL)\n        return PyErr_NoMemory();\n    gettimeofday(&start, NULL);\n    for(k=0; k < 20; k++) {\n        for(i=0; i < 1000000; i++) {\n            multiple[i] = PyLong_FromLong(i+1000000);\n        }\n        for(i=0; i < 1000000; i++) {\n            Py_DECREF(multiple[i]);\n        }\n    }\n    gettimeofday(&stop, NULL);\n    print_delta(4, &start, &stop);\n    free(multiple);\n\n    /* Test 5: Allocate many integers < 32000 */\n    multiple = malloc(sizeof(PyObject*) * 1000000);\n    if (multiple == NULL)\n        return PyErr_NoMemory();\n    gettimeofday(&start, NULL);\n    for(k=0; k < 10; k++) {\n        for(i=0; i < 1000000; i++) {\n            multiple[i] = PyLong_FromLong(i+1000);\n        }\n        for(i=0; i < 1000000; i++) {\n            Py_DECREF(multiple[i]);\n        }\n    }\n    gettimeofday(&stop, NULL);\n    print_delta(5, &start, &stop);\n    free(multiple);\n\n    /* Test 6: Perform small int addition */\n    op1 = PyLong_FromLong(1);\n    gettimeofday(&start, NULL);\n    for(i=0; i < 10000000; i++) {\n        result = PyNumber_Add(op1, op1);\n        Py_DECREF(result);\n    }\n    gettimeofday(&stop, NULL);\n    Py_DECREF(op1);\n    print_delta(6, &start, &stop);\n\n    /* Test 7: Perform medium int addition */\n    op1 = PyLong_FromLong(1000);\n    if (op1 == NULL)\n        return NULL;\n    gettimeofday(&start, NULL);\n    for(i=0; i < 10000000; i++) {\n        result = PyNumber_Add(op1, op1);\n        Py_XDECREF(result);\n    }\n    gettimeofday(&stop, NULL);\n    Py_DECREF(op1);\n    print_delta(7, &start, &stop);\n\n    Py_RETURN_NONE;\n}\n#endif\n\n/* Issue 6012 */\nstatic PyObject *str1, *str2;\nstatic int\nfailing_converter(PyObject *obj, void *arg)\n{\n    /* Clone str1, then let the conversion fail. */\n    assert(str1);\n    str2 = Py_NewRef(str1);\n    return 0;\n}\nstatic PyObject*\nargparsing(PyObject *o, PyObject *args)\n{\n    PyObject *res;\n    str1 = str2 = NULL;\n    if (!PyArg_ParseTuple(args, \"O&O&\",\n                          PyUnicode_FSConverter, &str1,\n                          failing_converter, &str2)) {\n        if (!str2)\n            /* argument converter not called? */\n            return NULL;\n        /* Should be 1 */\n        res = PyLong_FromSsize_t(Py_REFCNT(str2));\n        Py_DECREF(str2);\n        PyErr_Clear();\n        return res;\n    }\n    Py_RETURN_NONE;\n}\n\n/* To test that the result of PyCode_NewEmpty has the right members. */\nstatic PyObject *\ncode_newempty(PyObject *self, PyObject *args)\n{\n    const char *filename;\n    const char *funcname;\n    int firstlineno;\n\n    if (!PyArg_ParseTuple(args, \"ssi:code_newempty\",\n                          &filename, &funcname, &firstlineno))\n        return NULL;\n\n    return (PyObject *)PyCode_NewEmpty(filename, funcname, firstlineno);\n}\n\nstatic PyObject *\nmake_memoryview_from_NULL_pointer(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    Py_buffer info;\n    if (PyBuffer_FillInfo(&info, NULL, NULL, 1, 1, PyBUF_FULL_RO) < 0)\n        return NULL;\n    return PyMemoryView_FromBuffer(&info);\n}\n\nstatic PyObject *\nbuffer_fill_info(PyObject *self, PyObject *args)\n{\n    Py_buffer info;\n    const char *data;\n    Py_ssize_t size;\n    int readonly;\n    int flags;\n\n    if (!PyArg_ParseTuple(args, \"s#ii:buffer_fill_info\",\n                          &data, &size, &readonly, &flags)) {\n        return NULL;\n    }\n\n    if (PyBuffer_FillInfo(&info, NULL, (void *)data, size, readonly, flags) < 0) {\n        return NULL;\n    }\n    return PyMemoryView_FromBuffer(&info);\n}\n\nstatic PyObject *\ntest_from_contiguous(PyObject* self, PyObject *Py_UNUSED(ignored))\n{\n    int data[9] = {-1,-1,-1,-1,-1,-1,-1,-1,-1};\n    int init[5] = {0, 1, 2, 3, 4};\n    Py_ssize_t itemsize = sizeof(int);\n    Py_ssize_t shape = 5;\n    Py_ssize_t strides = 2 * itemsize;\n    Py_buffer view = {\n        data,\n        NULL,\n        5 * itemsize,\n        itemsize,\n        1,\n        1,\n        NULL,\n        &shape,\n        &strides,\n        NULL,\n        NULL\n    };\n    int *ptr;\n    int i;\n\n    PyBuffer_FromContiguous(&view, init, view.len, 'C');\n    ptr = view.buf;\n    for (i = 0; i < 5; i++) {\n        if (ptr[2*i] != i) {\n            PyErr_SetString(get_testerror(self),\n                \"test_from_contiguous: incorrect result\");\n            return NULL;\n        }\n    }\n\n    view.buf = &data[8];\n    view.strides[0] = -2 * itemsize;\n\n    PyBuffer_FromContiguous(&view, init, view.len, 'C');\n    ptr = view.buf;\n    for (i = 0; i < 5; i++) {\n        if (*(ptr-2*i) != i) {\n            PyErr_SetString(get_testerror(self),\n                \"test_from_contiguous: incorrect result\");\n            return NULL;\n        }\n    }\n\n    Py_RETURN_NONE;\n}\n\n#if (defined(__linux__) || defined(__FreeBSD__)) && defined(__GNUC__)\n\nstatic PyObject *\ntest_pep3118_obsolete_write_locks(PyObject* self, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *b;\n    char *dummy[1];\n    int ret, match;\n\n    /* PyBuffer_FillInfo() */\n    ret = PyBuffer_FillInfo(NULL, NULL, dummy, 1, 0, PyBUF_SIMPLE);\n    match = PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_BufferError);\n    PyErr_Clear();\n    if (ret != -1 || match == 0)\n        goto error;\n\n    PyObject *mod_io = PyImport_ImportModule(\"_io\");\n    if (mod_io == NULL) {\n        return NULL;\n    }\n\n    /* bytesiobuf_getbuffer() */\n    PyTypeObject *type = (PyTypeObject *)PyObject_GetAttrString(\n            mod_io, \"_BytesIOBuffer\");\n    Py_DECREF(mod_io);\n    if (type == NULL) {\n        return NULL;\n    }\n    b = type->tp_alloc(type, 0);\n    Py_DECREF(type);\n    if (b == NULL) {\n        return NULL;\n    }\n\n    ret = PyObject_GetBuffer(b, NULL, PyBUF_SIMPLE);\n    Py_DECREF(b);\n    match = PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_BufferError);\n    PyErr_Clear();\n    if (ret != -1 || match == 0)\n        goto error;\n\n    Py_RETURN_NONE;\n\nerror:\n    PyErr_SetString(get_testerror(self),\n        \"test_pep3118_obsolete_write_locks: failure\");\n    return NULL;\n}\n#endif\n\n/* This tests functions that historically supported write locks.  It is\n   wrong to call getbuffer() with view==NULL and a compliant getbufferproc\n   is entitled to segfault in that case. */\nstatic PyObject *\ngetbuffer_with_null_view(PyObject* self, PyObject *obj)\n{\n    if (PyObject_GetBuffer(obj, NULL, PyBUF_SIMPLE) < 0)\n        return NULL;\n\n    Py_RETURN_NONE;\n}\n\n/* PyBuffer_SizeFromFormat() */\nstatic PyObject *\ntest_PyBuffer_SizeFromFormat(PyObject *self, PyObject *args)\n{\n    const char *format;\n\n    if (!PyArg_ParseTuple(args, \"s:test_PyBuffer_SizeFromFormat\",\n                          &format)) {\n        return NULL;\n    }\n\n    RETURN_SIZE(PyBuffer_SizeFromFormat(format));\n}\n\n/* Test that the fatal error from not having a current thread doesn't\n   cause an infinite loop.  Run via Lib/test/test_capi.py */\nstatic PyObject *\ncrash_no_current_thread(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    Py_BEGIN_ALLOW_THREADS\n    /* Using PyThreadState_Get() directly allows the test to pass in\n       !pydebug mode. However, the test only actually tests anything\n       in pydebug mode, since that's where the infinite loop was in\n       the first place. */\n    PyThreadState_Get();\n    Py_END_ALLOW_THREADS\n    return NULL;\n}\n\n/* Test that the GILState thread and the \"current\" thread match. */\nstatic PyObject *\ntest_current_tstate_matches(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    PyThreadState *orig_tstate = PyThreadState_Get();\n\n    if (orig_tstate != PyGILState_GetThisThreadState()) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"current thread state doesn't match GILState\");\n        return NULL;\n    }\n\n    const char *err = NULL;\n    PyThreadState_Swap(NULL);\n    PyThreadState *substate = Py_NewInterpreter();\n\n    if (substate != PyThreadState_Get()) {\n        err = \"subinterpreter thread state not current\";\n        goto finally;\n    }\n    if (substate != PyGILState_GetThisThreadState()) {\n        err = \"subinterpreter thread state doesn't match GILState\";\n        goto finally;\n    }\n\nfinally:\n    Py_EndInterpreter(substate);\n    PyThreadState_Swap(orig_tstate);\n\n    if (err != NULL) {\n        PyErr_SetString(PyExc_RuntimeError, err);\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\n/* To run some code in a sub-interpreter. */\nstatic PyObject *\nrun_in_subinterp(PyObject *self, PyObject *args)\n{\n    const char *code;\n    int r;\n    PyThreadState *substate, *mainstate;\n    /* only initialise 'cflags.cf_flags' to test backwards compatibility */\n    PyCompilerFlags cflags = {0};\n\n    if (!PyArg_ParseTuple(args, \"s:run_in_subinterp\",\n                          &code))\n        return NULL;\n\n    mainstate = PyThreadState_Get();\n\n    PyThreadState_Swap(NULL);\n\n    substate = Py_NewInterpreter();\n    if (substate == NULL) {\n        /* Since no new thread state was created, there is no exception to\n           propagate; raise a fresh one after swapping in the old thread\n           state. */\n        PyThreadState_Swap(mainstate);\n        PyErr_SetString(PyExc_RuntimeError, \"sub-interpreter creation failed\");\n        return NULL;\n    }\n    r = PyRun_SimpleStringFlags(code, &cflags);\n    Py_EndInterpreter(substate);\n\n    PyThreadState_Swap(mainstate);\n\n    return PyLong_FromLong(r);\n}\n\nstatic PyMethodDef ml;\n\nstatic PyObject *\ncreate_cfunction(PyObject *self, PyObject *args)\n{\n    return PyCFunction_NewEx(&ml, self, NULL);\n}\n\nstatic PyMethodDef ml = {\n    \"create_cfunction\",\n    create_cfunction,\n    METH_NOARGS,\n    NULL\n};\n\nstatic PyObject *\n_test_incref(PyObject *ob)\n{\n    return Py_NewRef(ob);\n}\n\nstatic PyObject *\ntest_xincref_doesnt_leak(PyObject *ob, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *obj = PyLong_FromLong(0);\n    Py_XINCREF(_test_incref(obj));\n    Py_DECREF(obj);\n    Py_DECREF(obj);\n    Py_DECREF(obj);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\ntest_incref_doesnt_leak(PyObject *ob, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *obj = PyLong_FromLong(0);\n    Py_INCREF(_test_incref(obj));\n    Py_DECREF(obj);\n    Py_DECREF(obj);\n    Py_DECREF(obj);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\ntest_xdecref_doesnt_leak(PyObject *ob, PyObject *Py_UNUSED(ignored))\n{\n    Py_XDECREF(PyLong_FromLong(0));\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\ntest_decref_doesnt_leak(PyObject *ob, PyObject *Py_UNUSED(ignored))\n{\n    Py_DECREF(PyLong_FromLong(0));\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\ntest_structseq_newtype_doesnt_leak(PyObject *Py_UNUSED(self),\n                              PyObject *Py_UNUSED(args))\n{\n    PyStructSequence_Desc descr;\n    PyStructSequence_Field descr_fields[3];\n\n    descr_fields[0] = (PyStructSequence_Field){\"foo\", \"foo value\"};\n    descr_fields[1] = (PyStructSequence_Field){NULL, \"some hidden value\"};\n    descr_fields[2] = (PyStructSequence_Field){0, NULL};\n\n    descr.name = \"_testcapi.test_descr\";\n    descr.doc = \"This is used to test for memory leaks in NewType\";\n    descr.fields = descr_fields;\n    descr.n_in_sequence = 1;\n\n    PyTypeObject* structseq_type = PyStructSequence_NewType(&descr);\n    if (structseq_type == NULL) {\n        return NULL;\n    }\n    assert(PyType_Check(structseq_type));\n    assert(PyType_FastSubclass(structseq_type, Py_TPFLAGS_TUPLE_SUBCLASS));\n    Py_DECREF(structseq_type);\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\ntest_structseq_newtype_null_descr_doc(PyObject *Py_UNUSED(self),\n                              PyObject *Py_UNUSED(args))\n{\n    PyStructSequence_Field descr_fields[1] = {\n        (PyStructSequence_Field){NULL, NULL}\n    };\n    // Test specifically for NULL .doc field.\n    PyStructSequence_Desc descr = {\"_testcapi.test_descr\", NULL, &descr_fields[0], 0};\n\n    PyTypeObject* structseq_type = PyStructSequence_NewType(&descr);\n    assert(structseq_type != NULL);\n    assert(PyType_Check(structseq_type));\n    assert(PyType_FastSubclass(structseq_type, Py_TPFLAGS_TUPLE_SUBCLASS));\n    Py_DECREF(structseq_type);\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\ntest_incref_decref_API(PyObject *ob, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *obj = PyLong_FromLong(0);\n    Py_IncRef(obj);\n    Py_DecRef(obj);\n    Py_DecRef(obj);\n    Py_RETURN_NONE;\n}\n\ntypedef struct {\n    PyThread_type_lock start_event;\n    PyThread_type_lock exit_event;\n    PyObject *callback;\n} test_c_thread_t;\n\nstatic void\ntemporary_c_thread(void *data)\n{\n    test_c_thread_t *test_c_thread = data;\n    PyGILState_STATE state;\n    PyObject *res;\n\n    PyThread_release_lock(test_c_thread->start_event);\n\n    /* Allocate a Python thread state for this thread */\n    state = PyGILState_Ensure();\n\n    res = PyObject_CallNoArgs(test_c_thread->callback);\n    Py_CLEAR(test_c_thread->callback);\n\n    if (res == NULL) {\n        PyErr_Print();\n    }\n    else {\n        Py_DECREF(res);\n    }\n\n    /* Destroy the Python thread state for this thread */\n    PyGILState_Release(state);\n\n    PyThread_release_lock(test_c_thread->exit_event);\n}\n\nstatic test_c_thread_t test_c_thread;\n\nstatic PyObject *\ncall_in_temporary_c_thread(PyObject *self, PyObject *args)\n{\n    PyObject *res = NULL;\n    PyObject *callback = NULL;\n    long thread;\n    int wait = 1;\n    if (!PyArg_ParseTuple(args, \"O|i\", &callback, &wait))\n    {\n        return NULL;\n    }\n\n    test_c_thread.start_event = PyThread_allocate_lock();\n    test_c_thread.exit_event = PyThread_allocate_lock();\n    test_c_thread.callback = NULL;\n    if (!test_c_thread.start_event || !test_c_thread.exit_event) {\n        PyErr_SetString(PyExc_RuntimeError, \"could not allocate lock\");\n        goto exit;\n    }\n\n    test_c_thread.callback = Py_NewRef(callback);\n\n    PyThread_acquire_lock(test_c_thread.start_event, 1);\n    PyThread_acquire_lock(test_c_thread.exit_event, 1);\n\n    thread = PyThread_start_new_thread(temporary_c_thread, &test_c_thread);\n    if (thread == -1) {\n        PyErr_SetString(PyExc_RuntimeError, \"unable to start the thread\");\n        PyThread_release_lock(test_c_thread.start_event);\n        PyThread_release_lock(test_c_thread.exit_event);\n        goto exit;\n    }\n\n    PyThread_acquire_lock(test_c_thread.start_event, 1);\n    PyThread_release_lock(test_c_thread.start_event);\n\n    if (!wait) {\n        Py_RETURN_NONE;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n        PyThread_acquire_lock(test_c_thread.exit_event, 1);\n        PyThread_release_lock(test_c_thread.exit_event);\n    Py_END_ALLOW_THREADS\n\n    res = Py_NewRef(Py_None);\n\nexit:\n    Py_CLEAR(test_c_thread.callback);\n    if (test_c_thread.start_event) {\n        PyThread_free_lock(test_c_thread.start_event);\n        test_c_thread.start_event = NULL;\n    }\n    if (test_c_thread.exit_event) {\n        PyThread_free_lock(test_c_thread.exit_event);\n        test_c_thread.exit_event = NULL;\n    }\n    return res;\n}\n\nstatic PyObject *\njoin_temporary_c_thread(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    Py_BEGIN_ALLOW_THREADS\n        PyThread_acquire_lock(test_c_thread.exit_event, 1);\n        PyThread_release_lock(test_c_thread.exit_event);\n    Py_END_ALLOW_THREADS\n    Py_CLEAR(test_c_thread.callback);\n    PyThread_free_lock(test_c_thread.start_event);\n    test_c_thread.start_event = NULL;\n    PyThread_free_lock(test_c_thread.exit_event);\n    test_c_thread.exit_event = NULL;\n    Py_RETURN_NONE;\n}\n\n/* marshal */\n\nstatic PyObject*\npymarshal_write_long_to_file(PyObject* self, PyObject *args)\n{\n    long value;\n    PyObject *filename;\n    int version;\n    FILE *fp;\n\n    if (!PyArg_ParseTuple(args, \"lOi:pymarshal_write_long_to_file\",\n                          &value, &filename, &version))\n        return NULL;\n\n    fp = _Py_fopen_obj(filename, \"wb\");\n    if (fp == NULL) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        return NULL;\n    }\n\n    PyMarshal_WriteLongToFile(value, fp, version);\n    assert(!PyErr_Occurred());\n\n    fclose(fp);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject*\npymarshal_write_object_to_file(PyObject* self, PyObject *args)\n{\n    PyObject *obj;\n    PyObject *filename;\n    int version;\n    FILE *fp;\n\n    if (!PyArg_ParseTuple(args, \"OOi:pymarshal_write_object_to_file\",\n                          &obj, &filename, &version))\n        return NULL;\n\n    fp = _Py_fopen_obj(filename, \"wb\");\n    if (fp == NULL) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        return NULL;\n    }\n\n    PyMarshal_WriteObjectToFile(obj, fp, version);\n    assert(!PyErr_Occurred());\n\n    fclose(fp);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject*\npymarshal_read_short_from_file(PyObject* self, PyObject *args)\n{\n    int value;\n    long pos;\n    PyObject *filename;\n    FILE *fp;\n\n    if (!PyArg_ParseTuple(args, \"O:pymarshal_read_short_from_file\", &filename))\n        return NULL;\n\n    fp = _Py_fopen_obj(filename, \"rb\");\n    if (fp == NULL) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        return NULL;\n    }\n\n    value = PyMarshal_ReadShortFromFile(fp);\n    pos = ftell(fp);\n\n    fclose(fp);\n    if (PyErr_Occurred())\n        return NULL;\n    return Py_BuildValue(\"il\", value, pos);\n}\n\nstatic PyObject*\npymarshal_read_long_from_file(PyObject* self, PyObject *args)\n{\n    long value, pos;\n    PyObject *filename;\n    FILE *fp;\n\n    if (!PyArg_ParseTuple(args, \"O:pymarshal_read_long_from_file\", &filename))\n        return NULL;\n\n    fp = _Py_fopen_obj(filename, \"rb\");\n    if (fp == NULL) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        return NULL;\n    }\n\n    value = PyMarshal_ReadLongFromFile(fp);\n    pos = ftell(fp);\n\n    fclose(fp);\n    if (PyErr_Occurred())\n        return NULL;\n    return Py_BuildValue(\"ll\", value, pos);\n}\n\nstatic PyObject*\npymarshal_read_last_object_from_file(PyObject* self, PyObject *args)\n{\n    PyObject *filename;\n    if (!PyArg_ParseTuple(args, \"O:pymarshal_read_last_object_from_file\", &filename))\n        return NULL;\n\n    FILE *fp = _Py_fopen_obj(filename, \"rb\");\n    if (fp == NULL) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        return NULL;\n    }\n\n    PyObject *obj = PyMarshal_ReadLastObjectFromFile(fp);\n    long pos = ftell(fp);\n\n    fclose(fp);\n    if (obj == NULL) {\n        return NULL;\n    }\n    return Py_BuildValue(\"Nl\", obj, pos);\n}\n\nstatic PyObject*\npymarshal_read_object_from_file(PyObject* self, PyObject *args)\n{\n    PyObject *filename;\n    if (!PyArg_ParseTuple(args, \"O:pymarshal_read_object_from_file\", &filename))\n        return NULL;\n\n    FILE *fp = _Py_fopen_obj(filename, \"rb\");\n    if (fp == NULL) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        return NULL;\n    }\n\n    PyObject *obj = PyMarshal_ReadObjectFromFile(fp);\n    long pos = ftell(fp);\n\n    fclose(fp);\n    if (obj == NULL) {\n        return NULL;\n    }\n    return Py_BuildValue(\"Nl\", obj, pos);\n}\n\nstatic PyObject*\nreturn_null_without_error(PyObject *self, PyObject *args)\n{\n    /* invalid call: return NULL without setting an error,\n     * _Py_CheckFunctionResult() must detect such bug at runtime. */\n    PyErr_Clear();\n    return NULL;\n}\n\nstatic PyObject*\nreturn_result_with_error(PyObject *self, PyObject *args)\n{\n    /* invalid call: return a result with an error set,\n     * _Py_CheckFunctionResult() must detect such bug at runtime. */\n    PyErr_SetNone(PyExc_ValueError);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\ngetitem_with_error(PyObject *self, PyObject *args)\n{\n    PyObject *map, *key;\n    if (!PyArg_ParseTuple(args, \"OO\", &map, &key)) {\n        return NULL;\n    }\n\n    PyErr_SetString(PyExc_ValueError, \"bug\");\n    return PyObject_GetItem(map, key);\n}\n\nstatic PyObject *\ndict_get_version(PyObject *self, PyObject *args)\n{\n    PyDictObject *dict;\n    uint64_t version;\n\n    if (!PyArg_ParseTuple(args, \"O!\", &PyDict_Type, &dict))\n        return NULL;\n\n    _Py_COMP_DIAG_PUSH\n    _Py_COMP_DIAG_IGNORE_DEPR_DECLS\n    version = dict->ma_version_tag;\n    _Py_COMP_DIAG_POP\n\n    static_assert(sizeof(unsigned long long) >= sizeof(version),\n                  \"version is larger than unsigned long long\");\n    return PyLong_FromUnsignedLongLong((unsigned long long)version);\n}\n\n\nstatic PyObject *\nraise_SIGINT_then_send_None(PyObject *self, PyObject *args)\n{\n    PyGenObject *gen;\n\n    if (!PyArg_ParseTuple(args, \"O!\", &PyGen_Type, &gen))\n        return NULL;\n\n    /* This is used in a test to check what happens if a signal arrives just\n       as we're in the process of entering a yield from chain (see\n       bpo-30039).\n\n       Needs to be done in C, because:\n       - we don't have a Python wrapper for raise()\n       - we need to make sure that the Python-level signal handler doesn't run\n         *before* we enter the generator frame, which is impossible in Python\n         because we check for signals before every bytecode operation.\n     */\n    raise(SIGINT);\n    return PyObject_CallMethod((PyObject *)gen, \"send\", \"O\", Py_None);\n}\n\n\nstatic PyObject*\nstack_pointer(PyObject *self, PyObject *args)\n{\n    int v = 5;\n    return PyLong_FromVoidPtr(&v);\n}\n\n\n#ifdef W_STOPCODE\nstatic PyObject*\npy_w_stopcode(PyObject *self, PyObject *args)\n{\n    int sig, status;\n    if (!PyArg_ParseTuple(args, \"i\", &sig)) {\n        return NULL;\n    }\n    status = W_STOPCODE(sig);\n    return PyLong_FromLong(status);\n}\n#endif\n\n\nstatic PyObject *\ntest_pythread_tss_key_state(PyObject *self, PyObject *args)\n{\n    Py_tss_t tss_key = Py_tss_NEEDS_INIT;\n    if (PyThread_tss_is_created(&tss_key)) {\n        return raiseTestError(self, \"test_pythread_tss_key_state\",\n                              \"TSS key not in an uninitialized state at \"\n                              \"creation time\");\n    }\n    if (PyThread_tss_create(&tss_key) != 0) {\n        PyErr_SetString(PyExc_RuntimeError, \"PyThread_tss_create failed\");\n        return NULL;\n    }\n    if (!PyThread_tss_is_created(&tss_key)) {\n        return raiseTestError(self, \"test_pythread_tss_key_state\",\n                              \"PyThread_tss_create succeeded, \"\n                              \"but with TSS key in an uninitialized state\");\n    }\n    if (PyThread_tss_create(&tss_key) != 0) {\n        return raiseTestError(self, \"test_pythread_tss_key_state\",\n                              \"PyThread_tss_create unsuccessful with \"\n                              \"an already initialized key\");\n    }\n#define CHECK_TSS_API(expr) \\\n        (void)(expr); \\\n        if (!PyThread_tss_is_created(&tss_key)) { \\\n            return raiseTestError(self, \"test_pythread_tss_key_state\", \\\n                                  \"TSS key initialization state was not \" \\\n                                  \"preserved after calling \" #expr); }\n    CHECK_TSS_API(PyThread_tss_set(&tss_key, NULL));\n    CHECK_TSS_API(PyThread_tss_get(&tss_key));\n#undef CHECK_TSS_API\n    PyThread_tss_delete(&tss_key);\n    if (PyThread_tss_is_created(&tss_key)) {\n        return raiseTestError(self, \"test_pythread_tss_key_state\",\n                              \"PyThread_tss_delete called, but did not \"\n                              \"set the key state to uninitialized\");\n    }\n\n    Py_tss_t *ptr_key = PyThread_tss_alloc();\n    if (ptr_key == NULL) {\n        PyErr_SetString(PyExc_RuntimeError, \"PyThread_tss_alloc failed\");\n        return NULL;\n    }\n    if (PyThread_tss_is_created(ptr_key)) {\n        return raiseTestError(self, \"test_pythread_tss_key_state\",\n                              \"TSS key not in an uninitialized state at \"\n                              \"allocation time\");\n    }\n    PyThread_tss_free(ptr_key);\n    ptr_key = NULL;\n    Py_RETURN_NONE;\n}\n\n\n/* def bad_get(self, obj, cls):\n       cls()\n       return repr(self)\n*/\nstatic PyObject*\nbad_get(PyObject *module, PyObject *args)\n{\n    PyObject *self, *obj, *cls;\n    if (!PyArg_ParseTuple(args, \"OOO\", &self, &obj, &cls)) {\n        return NULL;\n    }\n\n    PyObject *res = PyObject_CallNoArgs(cls);\n    if (res == NULL) {\n        return NULL;\n    }\n    Py_DECREF(res);\n\n    return PyObject_Repr(self);\n}\n\n\n#ifdef Py_REF_DEBUG\nstatic PyObject *\nnegative_refcount(PyObject *self, PyObject *Py_UNUSED(args))\n{\n    PyObject *obj = PyUnicode_FromString(\"negative_refcount\");\n    if (obj == NULL) {\n        return NULL;\n    }\n    assert(Py_REFCNT(obj) == 1);\n\n    Py_SET_REFCNT(obj,  0);\n    /* Py_DECREF() must call _Py_NegativeRefcount() and abort Python */\n    Py_DECREF(obj);\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\ndecref_freed_object(PyObject *self, PyObject *Py_UNUSED(args))\n{\n    PyObject *obj = PyUnicode_FromString(\"decref_freed_object\");\n    if (obj == NULL) {\n        return NULL;\n    }\n    assert(Py_REFCNT(obj) == 1);\n\n    // Deallocate the memory\n    Py_DECREF(obj);\n    // obj is a now a dangling pointer\n\n    // gh-109496: If Python is built in debug mode, Py_DECREF() must call\n    // _Py_NegativeRefcount() and abort Python.\n    Py_DECREF(obj);\n\n    Py_RETURN_NONE;\n}\n#endif\n\n\n/* Functions for testing C calling conventions (METH_*) are named meth_*,\n * e.g. \"meth_varargs\" for METH_VARARGS.\n *\n * They all return a tuple of their C-level arguments, with None instead\n * of NULL and Python tuples instead of C arrays.\n */\n\n\nstatic PyObject*\n_null_to_none(PyObject* obj)\n{\n    if (obj == NULL) {\n        Py_RETURN_NONE;\n    }\n    return Py_NewRef(obj);\n}\n\nstatic PyObject*\nmeth_varargs(PyObject* self, PyObject* args)\n{\n    return Py_BuildValue(\"NO\", _null_to_none(self), args);\n}\n\nstatic PyObject*\nmeth_varargs_keywords(PyObject* self, PyObject* args, PyObject* kwargs)\n{\n    return Py_BuildValue(\"NON\", _null_to_none(self), args, _null_to_none(kwargs));\n}\n\nstatic PyObject*\nmeth_o(PyObject* self, PyObject* obj)\n{\n    return Py_BuildValue(\"NO\", _null_to_none(self), obj);\n}\n\nstatic PyObject*\nmeth_noargs(PyObject* self, PyObject* ignored)\n{\n    return _null_to_none(self);\n}\n\nstatic PyObject*\n_fastcall_to_tuple(PyObject* const* args, Py_ssize_t nargs)\n{\n    PyObject *tuple = PyTuple_New(nargs);\n    if (tuple == NULL) {\n        return NULL;\n    }\n    for (Py_ssize_t i=0; i < nargs; i++) {\n        Py_INCREF(args[i]);\n        PyTuple_SET_ITEM(tuple, i, args[i]);\n    }\n    return tuple;\n}\n\nstatic PyObject*\nmeth_fastcall(PyObject* self, PyObject* const* args, Py_ssize_t nargs)\n{\n    return Py_BuildValue(\n        \"NN\", _null_to_none(self), _fastcall_to_tuple(args, nargs)\n    );\n}\n\nstatic PyObject*\nmeth_fastcall_keywords(PyObject* self, PyObject* const* args,\n                       Py_ssize_t nargs, PyObject* kwargs)\n{\n    PyObject *pyargs = _fastcall_to_tuple(args, nargs);\n    if (pyargs == NULL) {\n        return NULL;\n    }\n    assert(args != NULL || nargs == 0);\n    PyObject* const* args_offset = args == NULL ? NULL : args + nargs;\n    PyObject *pykwargs = PyObject_Vectorcall((PyObject*)&PyDict_Type,\n                                              args_offset, 0, kwargs);\n    return Py_BuildValue(\"NNN\", _null_to_none(self), pyargs, pykwargs);\n}\n\nstatic PyObject*\ntest_pycfunction_call(PyObject *module, PyObject *args)\n{\n    // Function removed in the Python 3.13 API but was kept in the stable ABI.\n    extern PyObject* PyCFunction_Call(PyObject *callable, PyObject *args, PyObject *kwargs);\n\n    PyObject *func, *pos_args, *kwargs = NULL;\n    if (!PyArg_ParseTuple(args, \"OO!|O!\", &func, &PyTuple_Type, &pos_args, &PyDict_Type, &kwargs)) {\n        return NULL;\n    }\n    return PyCFunction_Call(func, pos_args, kwargs);\n}\n\nstatic PyObject*\npynumber_tobase(PyObject *module, PyObject *args)\n{\n    PyObject *obj;\n    int base;\n    if (!PyArg_ParseTuple(args, \"Oi:pynumber_tobase\",\n                          &obj, &base)) {\n        return NULL;\n    }\n    return PyNumber_ToBase(obj, base);\n}\n\nstatic PyObject*\ntest_set_type_size(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *obj = PyList_New(0);\n    if (obj == NULL) {\n        return NULL;\n    }\n\n    // Ensure that following tests don't modify the object,\n    // to ensure that Py_DECREF() will not crash.\n    assert(Py_TYPE(obj) == &PyList_Type);\n    assert(Py_SIZE(obj) == 0);\n\n    // bpo-39573: Test Py_SET_TYPE() and Py_SET_SIZE() functions.\n    Py_SET_TYPE(obj, &PyList_Type);\n    Py_SET_SIZE(obj, 0);\n\n    Py_DECREF(obj);\n    Py_RETURN_NONE;\n}\n\n\n// Test Py_CLEAR() macro\nstatic PyObject*\ntest_py_clear(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    // simple case with a variable\n    PyObject *obj = PyList_New(0);\n    if (obj == NULL) {\n        return NULL;\n    }\n    Py_CLEAR(obj);\n    assert(obj == NULL);\n\n    // gh-98724: complex case, Py_CLEAR() argument has a side effect\n    PyObject* array[1];\n    array[0] = PyList_New(0);\n    if (array[0] == NULL) {\n        return NULL;\n    }\n\n    PyObject **p = array;\n    Py_CLEAR(*p++);\n    assert(array[0] == NULL);\n    assert(p == array + 1);\n\n    Py_RETURN_NONE;\n}\n\n\n// Test Py_SETREF() and Py_XSETREF() macros, similar to test_py_clear()\nstatic PyObject*\ntest_py_setref(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    // Py_SETREF() simple case with a variable\n    PyObject *obj = PyList_New(0);\n    if (obj == NULL) {\n        return NULL;\n    }\n    Py_SETREF(obj, NULL);\n    assert(obj == NULL);\n\n    // Py_XSETREF() simple case with a variable\n    PyObject *obj2 = PyList_New(0);\n    if (obj2 == NULL) {\n        return NULL;\n    }\n    Py_XSETREF(obj2, NULL);\n    assert(obj2 == NULL);\n    // test Py_XSETREF() when the argument is NULL\n    Py_XSETREF(obj2, NULL);\n    assert(obj2 == NULL);\n\n    // gh-98724: complex case, Py_SETREF() argument has a side effect\n    PyObject* array[1];\n    array[0] = PyList_New(0);\n    if (array[0] == NULL) {\n        return NULL;\n    }\n\n    PyObject **p = array;\n    Py_SETREF(*p++, NULL);\n    assert(array[0] == NULL);\n    assert(p == array + 1);\n\n    // gh-98724: complex case, Py_XSETREF() argument has a side effect\n    PyObject* array2[1];\n    array2[0] = PyList_New(0);\n    if (array2[0] == NULL) {\n        return NULL;\n    }\n\n    PyObject **p2 = array2;\n    Py_XSETREF(*p2++, NULL);\n    assert(array2[0] == NULL);\n    assert(p2 == array2 + 1);\n\n    // test Py_XSETREF() when the argument is NULL\n    p2 = array2;\n    Py_XSETREF(*p2++, NULL);\n    assert(array2[0] == NULL);\n    assert(p2 == array2 + 1);\n\n    Py_RETURN_NONE;\n}\n\n\n#define TEST_REFCOUNT() \\\n    do { \\\n        PyObject *obj = PyList_New(0); \\\n        if (obj == NULL) { \\\n            return NULL; \\\n        } \\\n        assert(Py_REFCNT(obj) == 1); \\\n        \\\n        /* test Py_NewRef() */ \\\n        PyObject *ref = Py_NewRef(obj); \\\n        assert(ref == obj); \\\n        assert(Py_REFCNT(obj) == 2); \\\n        Py_DECREF(ref); \\\n        \\\n        /* test Py_XNewRef() */ \\\n        PyObject *xref = Py_XNewRef(obj); \\\n        assert(xref == obj); \\\n        assert(Py_REFCNT(obj) == 2); \\\n        Py_DECREF(xref); \\\n        \\\n        assert(Py_XNewRef(NULL) == NULL); \\\n        \\\n        Py_DECREF(obj); \\\n        Py_RETURN_NONE; \\\n    } while (0) \\\n\n\n// Test Py_NewRef() and Py_XNewRef() macros\nstatic PyObject*\ntest_refcount_macros(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    TEST_REFCOUNT();\n}\n\n#undef Py_NewRef\n#undef Py_XNewRef\n\n// Test Py_NewRef() and Py_XNewRef() functions, after undefining macros.\nstatic PyObject*\ntest_refcount_funcs(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    TEST_REFCOUNT();\n}\n\n\n// Test Py_Is() function\n#define TEST_PY_IS() \\\n    do { \\\n        PyObject *o_none = Py_None; \\\n        PyObject *o_true = Py_True; \\\n        PyObject *o_false = Py_False; \\\n        PyObject *obj = PyList_New(0); \\\n        if (obj == NULL) { \\\n            return NULL; \\\n        } \\\n        \\\n        /* test Py_Is() */ \\\n        assert(Py_Is(obj, obj)); \\\n        assert(!Py_Is(obj, o_none)); \\\n        \\\n        /* test Py_None */ \\\n        assert(Py_Is(o_none, o_none)); \\\n        assert(!Py_Is(obj, o_none)); \\\n        \\\n        /* test Py_True */ \\\n        assert(Py_Is(o_true, o_true)); \\\n        assert(!Py_Is(o_false, o_true)); \\\n        assert(!Py_Is(obj, o_true)); \\\n        \\\n        /* test Py_False */ \\\n        assert(Py_Is(o_false, o_false)); \\\n        assert(!Py_Is(o_true, o_false)); \\\n        assert(!Py_Is(obj, o_false)); \\\n        \\\n        Py_DECREF(obj); \\\n        Py_RETURN_NONE; \\\n    } while (0)\n\n// Test Py_Is() macro\nstatic PyObject*\ntest_py_is_macros(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    TEST_PY_IS();\n}\n\n#undef Py_Is\n\n// Test Py_Is() function, after undefining its macro.\nstatic PyObject*\ntest_py_is_funcs(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    TEST_PY_IS();\n}\n\n\n// type->tp_version_tag\nstatic PyObject *\ntype_get_version(PyObject *self, PyObject *type)\n{\n    if (!PyType_Check(type)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a type\");\n        return NULL;\n    }\n    PyObject *res = PyLong_FromUnsignedLong(\n        ((PyTypeObject *)type)->tp_version_tag);\n    if (res == NULL) {\n        assert(PyErr_Occurred());\n        return NULL;\n    }\n    return res;\n}\n\nstatic PyObject *\ntype_modified(PyObject *self, PyObject *type)\n{\n    if (!PyType_Check(type)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a type\");\n        return NULL;\n    }\n    PyType_Modified((PyTypeObject *)type);\n    Py_RETURN_NONE;\n}\n\n// Circumvents standard version assignment machinery - use with caution and only on\n// short-lived heap types\nstatic PyObject *\ntype_assign_specific_version_unsafe(PyObject *self, PyObject *args)\n{\n    PyTypeObject *type;\n    unsigned int version;\n    if (!PyArg_ParseTuple(args, \"Oi:type_assign_specific_version_unsafe\", &type, &version)) {\n        return NULL;\n    }\n    assert(!PyType_HasFeature(type, Py_TPFLAGS_IMMUTABLETYPE));\n    type->tp_version_tag = version;\n    type->tp_versions_used++;\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\ntype_assign_version(PyObject *self, PyObject *type)\n{\n    if (!PyType_Check(type)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a type\");\n        return NULL;\n    }\n    int res = PyUnstable_Type_AssignVersionTag((PyTypeObject *)type);\n    return PyLong_FromLong(res);\n}\n\n\nstatic PyObject *\ntype_get_tp_bases(PyObject *self, PyObject *type)\n{\n    PyObject *bases = ((PyTypeObject *)type)->tp_bases;\n    if (bases == NULL) {\n        Py_RETURN_NONE;\n    }\n    return Py_NewRef(bases);\n}\n\nstatic PyObject *\ntype_get_tp_mro(PyObject *self, PyObject *type)\n{\n    PyObject *mro = ((PyTypeObject *)type)->tp_mro;\n    if (mro == NULL) {\n        Py_RETURN_NONE;\n    }\n    return Py_NewRef(mro);\n}\n\n\n/* We only use 2 in test_capi/test_misc.py. */\n#define NUM_BASIC_STATIC_TYPES 2\nstatic PyTypeObject BasicStaticTypes[NUM_BASIC_STATIC_TYPES] = {\n#define INIT_BASIC_STATIC_TYPE \\\n    { \\\n        PyVarObject_HEAD_INIT(NULL, 0) \\\n        .tp_name = \"BasicStaticType\", \\\n        .tp_basicsize = sizeof(PyObject), \\\n    }\n    INIT_BASIC_STATIC_TYPE,\n    INIT_BASIC_STATIC_TYPE,\n#undef INIT_BASIC_STATIC_TYPE\n};\nstatic int num_basic_static_types_used = 0;\n\nstatic PyObject *\nget_basic_static_type(PyObject *self, PyObject *args)\n{\n    PyObject *base = NULL;\n    if (!PyArg_ParseTuple(args, \"|O\", &base)) {\n        return NULL;\n    }\n    assert(base == NULL || PyType_Check(base));\n\n    if(num_basic_static_types_used >= NUM_BASIC_STATIC_TYPES) {\n        PyErr_SetString(PyExc_RuntimeError, \"no more available basic static types\");\n        return NULL;\n    }\n    PyTypeObject *cls = &BasicStaticTypes[num_basic_static_types_used++];\n\n    if (base != NULL) {\n        cls->tp_bases = PyTuple_Pack(1, base);\n        if (cls->tp_bases == NULL) {\n            return NULL;\n        }\n        cls->tp_base = (PyTypeObject *)Py_NewRef(base);\n    }\n    if (PyType_Ready(cls) < 0) {\n        Py_DECREF(cls->tp_bases);\n        Py_DECREF(cls->tp_base);\n        return NULL;\n    }\n    return (PyObject *)cls;\n}\n\n\n// Test PyThreadState C API\nstatic PyObject *\ntest_tstate_capi(PyObject *self, PyObject *Py_UNUSED(args))\n{\n    // PyThreadState_Get()\n    PyThreadState *tstate = PyThreadState_Get();\n    assert(tstate != NULL);\n\n    // PyThreadState_GET()\n    PyThreadState *tstate2 = PyThreadState_Get();\n    assert(tstate2 == tstate);\n\n    // PyThreadState_GetUnchecked()\n    PyThreadState *tstate3 = PyThreadState_GetUnchecked();\n    assert(tstate3 == tstate);\n\n    // PyThreadState_EnterTracing(), PyThreadState_LeaveTracing()\n    PyThreadState_EnterTracing(tstate);\n    PyThreadState_LeaveTracing(tstate);\n\n    // PyThreadState_GetDict(): no tstate argument\n    PyObject *dict = PyThreadState_GetDict();\n    // PyThreadState_GetDict() API can return NULL if PyDict_New() fails,\n    // but it should not occur in practice.\n    assert(dict != NULL);\n    assert(PyDict_Check(dict));\n    // dict is a borrowed reference\n\n    // PyThreadState_GetInterpreter()\n    PyInterpreterState *interp = PyThreadState_GetInterpreter(tstate);\n    assert(interp != NULL);\n\n    // PyThreadState_GetFrame()\n    PyFrameObject*frame = PyThreadState_GetFrame(tstate);\n    assert(frame != NULL);\n    assert(PyFrame_Check(frame));\n    Py_DECREF(frame);\n\n    // PyThreadState_GetID()\n    uint64_t id = PyThreadState_GetID(tstate);\n    assert(id >= 1);\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nframe_getlocals(PyObject *self, PyObject *frame)\n{\n    if (!PyFrame_Check(frame)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a frame\");\n        return NULL;\n    }\n    return PyFrame_GetLocals((PyFrameObject *)frame);\n}\n\nstatic PyObject *\nframe_getglobals(PyObject *self, PyObject *frame)\n{\n    if (!PyFrame_Check(frame)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a frame\");\n        return NULL;\n    }\n    return PyFrame_GetGlobals((PyFrameObject *)frame);\n}\n\nstatic PyObject *\nframe_getgenerator(PyObject *self, PyObject *frame)\n{\n    if (!PyFrame_Check(frame)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a frame\");\n        return NULL;\n    }\n    return PyFrame_GetGenerator((PyFrameObject *)frame);\n}\n\nstatic PyObject *\nframe_getbuiltins(PyObject *self, PyObject *frame)\n{\n    if (!PyFrame_Check(frame)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a frame\");\n        return NULL;\n    }\n    return PyFrame_GetBuiltins((PyFrameObject *)frame);\n}\n\nstatic PyObject *\nframe_getlasti(PyObject *self, PyObject *frame)\n{\n    if (!PyFrame_Check(frame)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a frame\");\n        return NULL;\n    }\n    int lasti = PyFrame_GetLasti((PyFrameObject *)frame);\n    if (lasti < 0) {\n        assert(lasti == -1);\n        Py_RETURN_NONE;\n    }\n    return PyLong_FromLong(lasti);\n}\n\nstatic PyObject *\nframe_new(PyObject *self, PyObject *args)\n{\n    PyObject *code, *globals, *locals;\n    if (!PyArg_ParseTuple(args, \"OOO\", &code, &globals, &locals)) {\n        return NULL;\n    }\n    if (!PyCode_Check(code)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a code object\");\n        return NULL;\n    }\n    PyThreadState *tstate = PyThreadState_Get();\n\n    return (PyObject *)PyFrame_New(tstate, (PyCodeObject *)code, globals, locals);\n}\n\nstatic PyObject *\ntest_frame_getvar(PyObject *self, PyObject *args)\n{\n    PyObject *frame, *name;\n    if (!PyArg_ParseTuple(args, \"OO\", &frame, &name)) {\n        return NULL;\n    }\n    if (!PyFrame_Check(frame)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a frame\");\n        return NULL;\n    }\n\n    return PyFrame_GetVar((PyFrameObject *)frame, name);\n}\n\nstatic PyObject *\ntest_frame_getvarstring(PyObject *self, PyObject *args)\n{\n    PyObject *frame;\n    const char *name;\n    if (!PyArg_ParseTuple(args, \"Oy\", &frame, &name)) {\n        return NULL;\n    }\n    if (!PyFrame_Check(frame)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a frame\");\n        return NULL;\n    }\n\n    return PyFrame_GetVarString((PyFrameObject *)frame, name);\n}\n\n\nstatic PyObject *\neval_get_func_name(PyObject *self, PyObject *func)\n{\n    return PyUnicode_FromString(PyEval_GetFuncName(func));\n}\n\nstatic PyObject *\neval_get_func_desc(PyObject *self, PyObject *func)\n{\n    return PyUnicode_FromString(PyEval_GetFuncDesc(func));\n}\n\nstatic PyObject *\ngen_get_code(PyObject *self, PyObject *gen)\n{\n    if (!PyGen_Check(gen)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a generator object\");\n        return NULL;\n    }\n    return (PyObject *)PyGen_GetCode((PyGenObject *)gen);\n}\n\nstatic PyObject *\neval_eval_code_ex(PyObject *mod, PyObject *pos_args)\n{\n    PyObject *result = NULL;\n    PyObject *code;\n    PyObject *globals;\n    PyObject *locals = NULL;\n    PyObject *args = NULL;\n    PyObject *kwargs = NULL;\n    PyObject *defaults = NULL;\n    PyObject *kw_defaults = NULL;\n    PyObject *closure = NULL;\n\n    PyObject **c_kwargs = NULL;\n\n    if (!PyArg_ParseTuple(pos_args,\n                          \"OO|OO!O!O!OO:eval_code_ex\",\n                          &code,\n                          &globals,\n                          &locals,\n                          &PyTuple_Type, &args,\n                          &PyDict_Type, &kwargs,\n                          &PyTuple_Type, &defaults,\n                          &kw_defaults,\n                          &closure))\n    {\n        goto exit;\n    }\n\n    NULLABLE(code);\n    NULLABLE(globals);\n    NULLABLE(locals);\n    NULLABLE(kw_defaults);\n    NULLABLE(closure);\n\n    PyObject **c_args = NULL;\n    Py_ssize_t c_args_len = 0;\n    if (args) {\n        c_args = &PyTuple_GET_ITEM(args, 0);\n        c_args_len = PyTuple_Size(args);\n    }\n\n    Py_ssize_t c_kwargs_len = 0;\n    if (kwargs) {\n        c_kwargs_len = PyDict_Size(kwargs);\n        if (c_kwargs_len > 0) {\n            c_kwargs = PyMem_NEW(PyObject*, 2 * c_kwargs_len);\n            if (!c_kwargs) {\n                PyErr_NoMemory();\n                goto exit;\n            }\n\n            Py_ssize_t i = 0;\n            Py_ssize_t pos = 0;\n            while (PyDict_Next(kwargs, &pos, &c_kwargs[i], &c_kwargs[i + 1])) {\n                i += 2;\n            }\n            c_kwargs_len = i / 2;\n            /* XXX This is broken if the caller deletes dict items! */\n        }\n    }\n\n    PyObject **c_defaults = NULL;\n    Py_ssize_t c_defaults_len = 0;\n    if (defaults) {\n        c_defaults = &PyTuple_GET_ITEM(defaults, 0);\n        c_defaults_len = PyTuple_Size(defaults);\n    }\n\n    result = PyEval_EvalCodeEx(\n        code,\n        globals,\n        locals,\n        c_args,\n        (int)c_args_len,\n        c_kwargs,\n        (int)c_kwargs_len,\n        c_defaults,\n        (int)c_defaults_len,\n        kw_defaults,\n        closure\n    );\n\nexit:\n    if (c_kwargs) {\n        PyMem_DEL(c_kwargs);\n    }\n\n    return result;\n}\n\nstatic PyObject *\nget_feature_macros(PyObject *self, PyObject *Py_UNUSED(args))\n{\n    PyObject *result = PyDict_New();\n    if (!result) {\n        return NULL;\n    }\n    int res;\n#include \"_testcapi_feature_macros.inc\"\n    return result;\n}\n\nstatic PyObject *\ntest_code_api(PyObject *self, PyObject *Py_UNUSED(args))\n{\n    PyCodeObject *co = PyCode_NewEmpty(\"_testcapi\", \"dummy\", 1);\n    if (co == NULL) {\n        return NULL;\n    }\n    /* co_code */\n    {\n        PyObject *co_code = PyCode_GetCode(co);\n        if (co_code == NULL) {\n            goto fail;\n        }\n        assert(PyBytes_CheckExact(co_code));\n        if (PyObject_Length(co_code) == 0) {\n            PyErr_SetString(PyExc_ValueError, \"empty co_code\");\n            Py_DECREF(co_code);\n            goto fail;\n        }\n        Py_DECREF(co_code);\n    }\n    /* co_varnames */\n    {\n        PyObject *co_varnames = PyCode_GetVarnames(co);\n        if (co_varnames == NULL) {\n            goto fail;\n        }\n        if (!PyTuple_CheckExact(co_varnames)) {\n            PyErr_SetString(PyExc_TypeError, \"co_varnames not tuple\");\n            Py_DECREF(co_varnames);\n            goto fail;\n        }\n        if (PyTuple_GET_SIZE(co_varnames) != 0) {\n            PyErr_SetString(PyExc_ValueError, \"non-empty co_varnames\");\n            Py_DECREF(co_varnames);\n            goto fail;\n        }\n        Py_DECREF(co_varnames);\n    }\n    /* co_cellvars */\n    {\n        PyObject *co_cellvars = PyCode_GetCellvars(co);\n        if (co_cellvars == NULL) {\n            goto fail;\n        }\n        if (!PyTuple_CheckExact(co_cellvars)) {\n            PyErr_SetString(PyExc_TypeError, \"co_cellvars not tuple\");\n            Py_DECREF(co_cellvars);\n            goto fail;\n        }\n        if (PyTuple_GET_SIZE(co_cellvars) != 0) {\n            PyErr_SetString(PyExc_ValueError, \"non-empty co_cellvars\");\n            Py_DECREF(co_cellvars);\n            goto fail;\n        }\n        Py_DECREF(co_cellvars);\n    }\n    /* co_freevars */\n    {\n        PyObject *co_freevars = PyCode_GetFreevars(co);\n        if (co_freevars == NULL) {\n            goto fail;\n        }\n        if (!PyTuple_CheckExact(co_freevars)) {\n            PyErr_SetString(PyExc_TypeError, \"co_freevars not tuple\");\n            Py_DECREF(co_freevars);\n            goto fail;\n        }\n        if (PyTuple_GET_SIZE(co_freevars) != 0) {\n            PyErr_SetString(PyExc_ValueError, \"non-empty co_freevars\");\n            Py_DECREF(co_freevars);\n            goto fail;\n        }\n        Py_DECREF(co_freevars);\n    }\n    Py_DECREF(co);\n    Py_RETURN_NONE;\nfail:\n    Py_DECREF(co);\n    return NULL;\n}\n\nstatic int\nrecord_func(PyObject *obj, PyFrameObject *f, int what, PyObject *arg)\n{\n    assert(PyList_Check(obj));\n    PyObject *what_obj = NULL;\n    PyObject *line_obj = NULL;\n    PyObject *tuple = NULL;\n    int res = -1;\n    what_obj = PyLong_FromLong(what);\n    if (what_obj == NULL) {\n        goto error;\n    }\n    int line = PyFrame_GetLineNumber(f);\n    line_obj = PyLong_FromLong(line);\n    if (line_obj == NULL) {\n        goto error;\n    }\n    tuple = PyTuple_Pack(3, what_obj, line_obj, arg);\n    if (tuple == NULL) {\n        goto error;\n    }\n    PyTuple_SET_ITEM(tuple, 0, what_obj);\n    if (PyList_Append(obj, tuple)) {\n        goto error;\n    }\n    res = 0;\nerror:\n    Py_XDECREF(what_obj);\n    Py_XDECREF(line_obj);\n    Py_XDECREF(tuple);\n    return res;\n}\n\nstatic PyObject *\nsettrace_to_record(PyObject *self, PyObject *list)\n{\n\n   if (!PyList_Check(list)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a list\");\n        return NULL;\n    }\n    PyEval_SetTrace(record_func, list);\n    Py_RETURN_NONE;\n}\n\nstatic int\nerror_func(PyObject *obj, PyFrameObject *f, int what, PyObject *arg)\n{\n    assert(PyList_Check(obj));\n    /* Only raise if list is empty, otherwise append None\n     * This ensures that we only raise once */\n    if (PyList_GET_SIZE(obj)) {\n        return 0;\n    }\n    if (PyList_Append(obj, Py_None)) {\n       return -1;\n    }\n    PyErr_SetString(PyExc_Exception, \"an exception\");\n    return -1;\n}\n\nstatic PyObject *\nsettrace_to_error(PyObject *self, PyObject *list)\n{\n    if (!PyList_Check(list)) {\n        PyErr_SetString(PyExc_TypeError, \"argument must be a list\");\n        return NULL;\n    }\n    PyEval_SetTrace(error_func, list);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nclear_managed_dict(PyObject *self, PyObject *obj)\n{\n    PyObject_ClearManagedDict(obj);\n    Py_RETURN_NONE;\n}\n\n\nstatic PyObject *\ntest_macros(PyObject *self, PyObject *Py_UNUSED(args))\n{\n    struct MyStruct {\n        int x;\n    };\n    wchar_t array[3];\n\n    // static_assert(), Py_BUILD_ASSERT()\n    static_assert(1 == 1, \"bug\");\n    Py_BUILD_ASSERT(1 == 1);\n\n\n    // Py_MIN(), Py_MAX(), Py_ABS()\n    assert(Py_MIN(5, 11) == 5);\n    assert(Py_MAX(5, 11) == 11);\n    assert(Py_ABS(-5) == 5);\n\n    // Py_STRINGIFY()\n    assert(strcmp(Py_STRINGIFY(123), \"123\") == 0);\n\n    // Py_MEMBER_SIZE(), Py_ARRAY_LENGTH()\n    assert(Py_MEMBER_SIZE(struct MyStruct, x) == sizeof(int));\n    assert(Py_ARRAY_LENGTH(array) == 3);\n\n    // Py_CHARMASK()\n    int c = 0xab00 | 7;\n    assert(Py_CHARMASK(c) == 7);\n\n    // _Py_IS_TYPE_SIGNED()\n    assert(_Py_IS_TYPE_SIGNED(int));\n    assert(!_Py_IS_TYPE_SIGNED(unsigned int));\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nfunction_get_code(PyObject *self, PyObject *func)\n{\n    PyObject *code = PyFunction_GetCode(func);\n    if (code != NULL) {\n        return Py_NewRef(code);\n    } else {\n        return NULL;\n    }\n}\n\nstatic PyObject *\nfunction_get_globals(PyObject *self, PyObject *func)\n{\n    PyObject *globals = PyFunction_GetGlobals(func);\n    if (globals != NULL) {\n        return Py_NewRef(globals);\n    } else {\n        return NULL;\n    }\n}\n\nstatic PyObject *\nfunction_get_module(PyObject *self, PyObject *func)\n{\n    PyObject *module = PyFunction_GetModule(func);\n    if (module != NULL) {\n        return Py_NewRef(module);\n    } else {\n        return NULL;\n    }\n}\n\nstatic PyObject *\nfunction_get_defaults(PyObject *self, PyObject *func)\n{\n    PyObject *defaults = PyFunction_GetDefaults(func);\n    if (defaults != NULL) {\n        return Py_NewRef(defaults);\n    } else if (PyErr_Occurred()) {\n        return NULL;\n    } else {\n        Py_RETURN_NONE;  // This can happen when `defaults` are set to `None`\n    }\n}\n\nstatic PyObject *\nfunction_set_defaults(PyObject *self, PyObject *args)\n{\n    PyObject *func = NULL, *defaults = NULL;\n    if (!PyArg_ParseTuple(args, \"OO\", &func, &defaults)) {\n        return NULL;\n    }\n    int result = PyFunction_SetDefaults(func, defaults);\n    if (result == -1)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nfunction_get_kw_defaults(PyObject *self, PyObject *func)\n{\n    PyObject *defaults = PyFunction_GetKwDefaults(func);\n    if (defaults != NULL) {\n        return Py_NewRef(defaults);\n    } else if (PyErr_Occurred()) {\n        return NULL;\n    } else {\n        Py_RETURN_NONE;  // This can happen when `kwdefaults` are set to `None`\n    }\n}\n\nstatic PyObject *\nfunction_set_kw_defaults(PyObject *self, PyObject *args)\n{\n    PyObject *func = NULL, *defaults = NULL;\n    if (!PyArg_ParseTuple(args, \"OO\", &func, &defaults)) {\n        return NULL;\n    }\n    int result = PyFunction_SetKwDefaults(func, defaults);\n    if (result == -1)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nfunction_get_closure(PyObject *self, PyObject *func)\n{\n    PyObject *closure = PyFunction_GetClosure(func);\n    if (closure != NULL) {\n        return Py_NewRef(closure);\n    } else if (PyErr_Occurred()) {\n        return NULL;\n    } else {\n        Py_RETURN_NONE;  // This can happen when `closure` is set to `None`\n    }\n}\n\nstatic PyObject *\nfunction_set_closure(PyObject *self, PyObject *args)\n{\n    PyObject *func = NULL, *closure = NULL;\n    if (!PyArg_ParseTuple(args, \"OO\", &func, &closure)) {\n        return NULL;\n    }\n    int result = PyFunction_SetClosure(func, closure);\n    if (result == -1) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\ncheck_pyimport_addmodule(PyObject *self, PyObject *args)\n{\n    const char *name;\n    if (!PyArg_ParseTuple(args, \"s\", &name)) {\n        return NULL;\n    }\n\n    // test PyImport_AddModuleRef()\n    PyObject *module = PyImport_AddModuleRef(name);\n    if (module == NULL) {\n        return NULL;\n    }\n    assert(PyModule_Check(module));\n    // module is a strong reference\n\n    // test PyImport_AddModule()\n    PyObject *module2 = PyImport_AddModule(name);\n    if (module2 == NULL) {\n        goto error;\n    }\n    assert(PyModule_Check(module2));\n    assert(module2 == module);\n    // module2 is a borrowed ref\n\n    // test PyImport_AddModuleObject()\n    PyObject *name_obj = PyUnicode_FromString(name);\n    if (name_obj == NULL) {\n        goto error;\n    }\n    PyObject *module3 = PyImport_AddModuleObject(name_obj);\n    Py_DECREF(name_obj);\n    if (module3 == NULL) {\n        goto error;\n    }\n    assert(PyModule_Check(module3));\n    assert(module3 == module);\n    // module3 is a borrowed ref\n\n    return module;\n\nerror:\n    Py_DECREF(module);\n    return NULL;\n}\n\n\nstatic PyObject *\ntest_weakref_capi(PyObject *Py_UNUSED(module), PyObject *Py_UNUSED(args))\n{\n    // Ignore PyWeakref_GetObject() deprecation, we test it on purpose\n    _Py_COMP_DIAG_PUSH\n    _Py_COMP_DIAG_IGNORE_DEPR_DECLS\n\n    // Create a new heap type, create an instance of this type, and delete the\n    // type. This object supports weak references.\n    PyObject *new_type = PyObject_CallFunction((PyObject*)&PyType_Type,\n                                               \"s(){}\", \"TypeName\");\n    if (new_type == NULL) {\n        return NULL;\n    }\n    PyObject *obj = PyObject_CallNoArgs(new_type);\n    Py_DECREF(new_type);\n    if (obj == NULL) {\n        return NULL;\n    }\n    Py_ssize_t refcnt = Py_REFCNT(obj);\n\n    // test PyWeakref_NewRef(), reference is alive\n    PyObject *weakref = PyWeakref_NewRef(obj, NULL);\n    if (weakref == NULL) {\n        Py_DECREF(obj);\n        return NULL;\n    }\n\n    // test PyWeakref_Check(), valid weakref object\n    assert(PyWeakref_Check(weakref));\n    assert(PyWeakref_CheckRefExact(weakref));\n    assert(PyWeakref_CheckRefExact(weakref));\n    assert(Py_REFCNT(obj) == refcnt);\n\n    // test PyWeakref_GetRef(), reference is alive\n    PyObject *ref = UNINITIALIZED_PTR;\n    assert(PyWeakref_GetRef(weakref, &ref) == 1);\n    assert(ref == obj);\n    assert(Py_REFCNT(obj) == (refcnt + 1));\n    Py_DECREF(ref);\n\n    // test PyWeakref_GetObject(), reference is alive\n    ref = PyWeakref_GetObject(weakref);  // borrowed ref\n    assert(ref == obj);\n\n    // test PyWeakref_GET_OBJECT(), reference is alive\n    ref = PyWeakref_GET_OBJECT(weakref);  // borrowed ref\n    assert(ref == obj);\n\n    // delete the referenced object: clear the weakref\n    assert(Py_REFCNT(obj) == 1);\n    Py_DECREF(obj);\n\n    // test PyWeakref_GET_OBJECT(), reference is dead\n    assert(PyWeakref_GET_OBJECT(weakref) == Py_None);\n\n    // test PyWeakref_GetRef(), reference is dead\n    ref = UNINITIALIZED_PTR;\n    assert(PyWeakref_GetRef(weakref, &ref) == 0);\n    assert(ref == NULL);\n\n    // test PyWeakref_Check(), not a weakref object\n    PyObject *invalid_weakref = Py_None;\n    assert(!PyWeakref_Check(invalid_weakref));\n    assert(!PyWeakref_CheckRefExact(invalid_weakref));\n    assert(!PyWeakref_CheckRefExact(invalid_weakref));\n\n    // test PyWeakref_GetRef(), invalid type\n    assert(!PyErr_Occurred());\n    ref = UNINITIALIZED_PTR;\n    assert(PyWeakref_GetRef(invalid_weakref, &ref) == -1);\n    assert(PyErr_ExceptionMatches(PyExc_TypeError));\n    PyErr_Clear();\n    assert(ref == NULL);\n\n    // test PyWeakref_GetObject(), invalid type\n    assert(PyWeakref_GetObject(invalid_weakref) == NULL);\n    assert(PyErr_ExceptionMatches(PyExc_SystemError));\n    PyErr_Clear();\n\n    // test PyWeakref_GetRef(NULL)\n    ref = UNINITIALIZED_PTR;\n    assert(PyWeakref_GetRef(NULL, &ref) == -1);\n    assert(PyErr_ExceptionMatches(PyExc_SystemError));\n    assert(ref == NULL);\n    PyErr_Clear();\n\n    // test PyWeakref_GetObject(NULL)\n    assert(PyWeakref_GetObject(NULL) == NULL);\n    assert(PyErr_ExceptionMatches(PyExc_SystemError));\n    PyErr_Clear();\n\n    Py_DECREF(weakref);\n\n    Py_RETURN_NONE;\n\n    _Py_COMP_DIAG_POP\n}\n\nstruct simpletracer_data {\n    int create_count;\n    int destroy_count;\n    void* addresses[10];\n};\n\nstatic int _simpletracer(PyObject *obj, PyRefTracerEvent event, void* data) {\n    struct simpletracer_data* the_data = (struct simpletracer_data*)data;\n    assert(the_data->create_count + the_data->destroy_count < (int)Py_ARRAY_LENGTH(the_data->addresses));\n    the_data->addresses[the_data->create_count + the_data->destroy_count] = obj;\n    if (event == PyRefTracer_CREATE) {\n        the_data->create_count++;\n    } else {\n        the_data->destroy_count++;\n    }\n    return 0;\n}\n\nstatic PyObject *\ntest_reftracer(PyObject *ob, PyObject *Py_UNUSED(ignored))\n{\n    // Save the current tracer and data to restore it later\n    void* current_data;\n    PyRefTracer current_tracer = PyRefTracer_GetTracer(&current_data);\n\n    struct simpletracer_data tracer_data = {0};\n    void* the_data = &tracer_data;\n    // Install a simple tracer function\n    if (PyRefTracer_SetTracer(_simpletracer, the_data) != 0) {\n        goto failed;\n    }\n\n    // Check that the tracer was correctly installed\n    void* data;\n    if (PyRefTracer_GetTracer(&data) != _simpletracer || data != the_data) {\n        PyErr_SetString(PyExc_AssertionError, \"The reftracer not correctly installed\");\n        (void)PyRefTracer_SetTracer(NULL, NULL);\n        goto failed;\n    }\n\n    // Create a bunch of objects\n    PyObject* obj = PyList_New(0);\n    if (obj == NULL) {\n        goto failed;\n    }\n    PyObject* obj2 = PyDict_New();\n    if (obj2 == NULL) {\n        Py_DECREF(obj);\n        goto failed;\n    }\n\n    // Kill all objects\n    Py_DECREF(obj);\n    Py_DECREF(obj2);\n\n    // Remove the tracer\n    (void)PyRefTracer_SetTracer(NULL, NULL);\n\n    // Check that the tracer was removed\n    if (PyRefTracer_GetTracer(&data) != NULL || data != NULL) {\n        PyErr_SetString(PyExc_ValueError, \"The reftracer was not correctly removed\");\n        goto failed;\n    }\n\n    if (tracer_data.create_count != 2 ||\n        tracer_data.addresses[0] != obj ||\n        tracer_data.addresses[1] != obj2) {\n        PyErr_SetString(PyExc_ValueError, \"The object creation was not correctly traced\");\n        goto failed;\n    }\n\n    if (tracer_data.destroy_count != 2 ||\n        tracer_data.addresses[2] != obj ||\n        tracer_data.addresses[3] != obj2) {\n        PyErr_SetString(PyExc_ValueError, \"The object destruction was not correctly traced\");\n        goto failed;\n    }\n    PyRefTracer_SetTracer(current_tracer, current_data);\n    Py_RETURN_NONE;\nfailed:\n    PyRefTracer_SetTracer(current_tracer, current_data);\n    return NULL;\n}\n\nstatic PyObject *\nfunction_set_warning(PyObject *Py_UNUSED(module), PyObject *Py_UNUSED(args))\n{\n    if (PyErr_WarnEx(PyExc_RuntimeWarning, \"Testing PyErr_WarnEx\", 2)) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\ntest_critical_sections(PyObject *module, PyObject *Py_UNUSED(args))\n{\n    Py_BEGIN_CRITICAL_SECTION(module);\n    Py_END_CRITICAL_SECTION();\n\n    Py_BEGIN_CRITICAL_SECTION2(module, module);\n    Py_END_CRITICAL_SECTION2();\n\n    Py_RETURN_NONE;\n}\n\nstatic PyMethodDef TestMethods[] = {\n    {\"set_errno\",               set_errno,                       METH_VARARGS},\n    {\"test_config\",             test_config,                     METH_NOARGS},\n    {\"test_sizeof_c_types\",     test_sizeof_c_types,             METH_NOARGS},\n    {\"test_list_api\",           test_list_api,                   METH_NOARGS},\n    {\"test_dict_iteration\",     test_dict_iteration,             METH_NOARGS},\n    {\"test_lazy_hash_inheritance\",      test_lazy_hash_inheritance,METH_NOARGS},\n    {\"test_xincref_doesnt_leak\",test_xincref_doesnt_leak,        METH_NOARGS},\n    {\"test_incref_doesnt_leak\", test_incref_doesnt_leak,         METH_NOARGS},\n    {\"test_xdecref_doesnt_leak\",test_xdecref_doesnt_leak,        METH_NOARGS},\n    {\"test_decref_doesnt_leak\", test_decref_doesnt_leak,         METH_NOARGS},\n    {\"test_structseq_newtype_doesnt_leak\",\n        test_structseq_newtype_doesnt_leak, METH_NOARGS},\n    {\"test_structseq_newtype_null_descr_doc\",\n        test_structseq_newtype_null_descr_doc, METH_NOARGS},\n    {\"test_incref_decref_API\",  test_incref_decref_API,          METH_NOARGS},\n    {\"pyobject_repr_from_null\", pyobject_repr_from_null, METH_NOARGS},\n    {\"pyobject_str_from_null\",  pyobject_str_from_null, METH_NOARGS},\n    {\"pyobject_bytes_from_null\", pyobject_bytes_from_null, METH_NOARGS},\n    {\"test_string_to_double\",   test_string_to_double,           METH_NOARGS},\n    {\"test_capsule\", (PyCFunction)test_capsule, METH_NOARGS},\n    {\"test_from_contiguous\", (PyCFunction)test_from_contiguous, METH_NOARGS},\n#if (defined(__linux__) || defined(__FreeBSD__)) && defined(__GNUC__)\n    {\"test_pep3118_obsolete_write_locks\", (PyCFunction)test_pep3118_obsolete_write_locks, METH_NOARGS},\n#endif\n    {\"getbuffer_with_null_view\", getbuffer_with_null_view,       METH_O},\n    {\"PyBuffer_SizeFromFormat\",  test_PyBuffer_SizeFromFormat,   METH_VARARGS},\n    {\"py_buildvalue\",            py_buildvalue,                  METH_VARARGS},\n    {\"py_buildvalue_ints\",       py_buildvalue_ints,             METH_VARARGS},\n    {\"test_buildvalue_N\",        test_buildvalue_N,              METH_NOARGS},\n    {\"test_get_statictype_slots\", test_get_statictype_slots,     METH_NOARGS},\n    {\"get_heaptype_for_name\",     get_heaptype_for_name,         METH_NOARGS},\n    {\"get_type_name\",            get_type_name,                  METH_O},\n    {\"get_type_qualname\",        get_type_qualname,              METH_O},\n    {\"get_type_fullyqualname\",   get_type_fullyqualname,         METH_O},\n    {\"get_type_module_name\",     get_type_module_name,           METH_O},\n    {\"test_get_type_dict\",        test_get_type_dict,            METH_NOARGS},\n    {\"test_reftracer\",          test_reftracer,                  METH_NOARGS},\n    {\"_test_thread_state\",      test_thread_state,               METH_VARARGS},\n    {\"gilstate_ensure_release\", gilstate_ensure_release,         METH_NOARGS},\n#ifndef MS_WINDOWS\n    {\"_spawn_pthread_waiter\",   spawn_pthread_waiter,            METH_NOARGS},\n    {\"_end_spawned_pthread\",    end_spawned_pthread,             METH_NOARGS},\n#endif\n    {\"_pending_threadfunc\",     _PyCFunction_CAST(pending_threadfunc),\n     METH_VARARGS|METH_KEYWORDS},\n#ifdef HAVE_GETTIMEOFDAY\n    {\"profile_int\",             profile_int,                     METH_NOARGS},\n#endif\n    {\"argparsing\",              argparsing,                      METH_VARARGS},\n    {\"code_newempty\",           code_newempty,                   METH_VARARGS},\n    {\"eval_code_ex\",            eval_eval_code_ex,               METH_VARARGS},\n    {\"make_memoryview_from_NULL_pointer\", make_memoryview_from_NULL_pointer,\n     METH_NOARGS},\n    {\"buffer_fill_info\",        buffer_fill_info,                METH_VARARGS},\n    {\"crash_no_current_thread\", crash_no_current_thread,         METH_NOARGS},\n    {\"test_current_tstate_matches\", test_current_tstate_matches, METH_NOARGS},\n    {\"run_in_subinterp\",        run_in_subinterp,                METH_VARARGS},\n    {\"create_cfunction\",        create_cfunction,                METH_NOARGS},\n    {\"call_in_temporary_c_thread\", call_in_temporary_c_thread, METH_VARARGS,\n     PyDoc_STR(\"set_error_class(error_class) -> None\")},\n    {\"join_temporary_c_thread\", join_temporary_c_thread, METH_NOARGS},\n    {\"pymarshal_write_long_to_file\",\n        pymarshal_write_long_to_file, METH_VARARGS},\n    {\"pymarshal_write_object_to_file\",\n        pymarshal_write_object_to_file, METH_VARARGS},\n    {\"pymarshal_read_short_from_file\",\n        pymarshal_read_short_from_file, METH_VARARGS},\n    {\"pymarshal_read_long_from_file\",\n        pymarshal_read_long_from_file, METH_VARARGS},\n    {\"pymarshal_read_last_object_from_file\",\n        pymarshal_read_last_object_from_file, METH_VARARGS},\n    {\"pymarshal_read_object_from_file\",\n        pymarshal_read_object_from_file, METH_VARARGS},\n    {\"return_null_without_error\", return_null_without_error, METH_NOARGS},\n    {\"return_result_with_error\", return_result_with_error, METH_NOARGS},\n    {\"getitem_with_error\", getitem_with_error, METH_VARARGS},\n    {\"Py_CompileString\",     pycompilestring, METH_O},\n    {\"dict_get_version\", dict_get_version, METH_VARARGS},\n    {\"raise_SIGINT_then_send_None\", raise_SIGINT_then_send_None, METH_VARARGS},\n    {\"stack_pointer\", stack_pointer, METH_NOARGS},\n#ifdef W_STOPCODE\n    {\"W_STOPCODE\", py_w_stopcode, METH_VARARGS},\n#endif\n    {\"test_pythread_tss_key_state\", test_pythread_tss_key_state, METH_VARARGS},\n    {\"bad_get\", bad_get, METH_VARARGS},\n#ifdef Py_REF_DEBUG\n    {\"negative_refcount\", negative_refcount, METH_NOARGS},\n    {\"decref_freed_object\", decref_freed_object, METH_NOARGS},\n#endif\n    {\"meth_varargs\", meth_varargs, METH_VARARGS},\n    {\"meth_varargs_keywords\", _PyCFunction_CAST(meth_varargs_keywords), METH_VARARGS|METH_KEYWORDS},\n    {\"meth_o\", meth_o, METH_O},\n    {\"meth_noargs\", meth_noargs, METH_NOARGS},\n    {\"meth_fastcall\", _PyCFunction_CAST(meth_fastcall), METH_FASTCALL},\n    {\"meth_fastcall_keywords\", _PyCFunction_CAST(meth_fastcall_keywords), METH_FASTCALL|METH_KEYWORDS},\n    {\"pycfunction_call\", test_pycfunction_call, METH_VARARGS},\n    {\"pynumber_tobase\", pynumber_tobase, METH_VARARGS},\n    {\"test_set_type_size\", test_set_type_size, METH_NOARGS},\n    {\"test_py_clear\", test_py_clear, METH_NOARGS},\n    {\"test_py_setref\", test_py_setref, METH_NOARGS},\n    {\"test_refcount_macros\", test_refcount_macros, METH_NOARGS},\n    {\"test_refcount_funcs\", test_refcount_funcs, METH_NOARGS},\n    {\"test_py_is_macros\", test_py_is_macros, METH_NOARGS},\n    {\"test_py_is_funcs\", test_py_is_funcs, METH_NOARGS},\n    {\"type_get_version\", type_get_version, METH_O, PyDoc_STR(\"type->tp_version_tag\")},\n    {\"type_modified\", type_modified, METH_O, PyDoc_STR(\"PyType_Modified\")},\n    {\"type_assign_specific_version_unsafe\", type_assign_specific_version_unsafe, METH_VARARGS,\n     PyDoc_STR(\"forcefully assign type->tp_version_tag\")},\n    {\"type_assign_version\", type_assign_version, METH_O, PyDoc_STR(\"PyUnstable_Type_AssignVersionTag\")},\n    {\"type_get_tp_bases\", type_get_tp_bases, METH_O},\n    {\"type_get_tp_mro\", type_get_tp_mro, METH_O},\n    {\"get_basic_static_type\", get_basic_static_type, METH_VARARGS, NULL},\n    {\"test_tstate_capi\", test_tstate_capi, METH_NOARGS, NULL},\n    {\"frame_getlocals\", frame_getlocals, METH_O, NULL},\n    {\"frame_getglobals\", frame_getglobals, METH_O, NULL},\n    {\"frame_getgenerator\", frame_getgenerator, METH_O, NULL},\n    {\"frame_getbuiltins\", frame_getbuiltins, METH_O, NULL},\n    {\"frame_getlasti\", frame_getlasti, METH_O, NULL},\n    {\"frame_new\", frame_new, METH_VARARGS, NULL},\n    {\"frame_getvar\", test_frame_getvar, METH_VARARGS, NULL},\n    {\"frame_getvarstring\", test_frame_getvarstring, METH_VARARGS, NULL},\n    {\"eval_get_func_name\", eval_get_func_name, METH_O, NULL},\n    {\"eval_get_func_desc\", eval_get_func_desc, METH_O, NULL},\n    {\"gen_get_code\", gen_get_code, METH_O, NULL},\n    {\"get_feature_macros\", get_feature_macros, METH_NOARGS, NULL},\n    {\"test_code_api\", test_code_api, METH_NOARGS, NULL},\n    {\"settrace_to_error\", settrace_to_error, METH_O, NULL},\n    {\"settrace_to_record\", settrace_to_record, METH_O, NULL},\n    {\"test_macros\", test_macros, METH_NOARGS, NULL},\n    {\"clear_managed_dict\", clear_managed_dict, METH_O, NULL},\n    {\"function_get_code\", function_get_code, METH_O, NULL},\n    {\"function_get_globals\", function_get_globals, METH_O, NULL},\n    {\"function_get_module\", function_get_module, METH_O, NULL},\n    {\"function_get_defaults\", function_get_defaults, METH_O, NULL},\n    {\"function_set_defaults\", function_set_defaults, METH_VARARGS, NULL},\n    {\"function_get_kw_defaults\", function_get_kw_defaults, METH_O, NULL},\n    {\"function_set_kw_defaults\", function_set_kw_defaults, METH_VARARGS, NULL},\n    {\"function_get_closure\", function_get_closure, METH_O, NULL},\n    {\"function_set_closure\", function_set_closure, METH_VARARGS, NULL},\n    {\"check_pyimport_addmodule\", check_pyimport_addmodule, METH_VARARGS},\n    {\"test_weakref_capi\", test_weakref_capi, METH_NOARGS},\n    {\"function_set_warning\", function_set_warning, METH_NOARGS},\n    {\"test_critical_sections\", test_critical_sections, METH_NOARGS},\n    {NULL, NULL} /* sentinel */\n};\n\n\ntypedef struct {\n    PyObject_HEAD\n} matmulObject;\n\nstatic PyObject *\nmatmulType_matmul(PyObject *self, PyObject *other)\n{\n    return Py_BuildValue(\"(sOO)\", \"matmul\", self, other);\n}\n\nstatic PyObject *\nmatmulType_imatmul(PyObject *self, PyObject *other)\n{\n    return Py_BuildValue(\"(sOO)\", \"imatmul\", self, other);\n}\n\nstatic void\nmatmulType_dealloc(PyObject *self)\n{\n    Py_TYPE(self)->tp_free(self);\n}\n\nstatic PyNumberMethods matmulType_as_number = {\n    0,                          /* nb_add */\n    0,                          /* nb_subtract */\n    0,                          /* nb_multiply */\n    0,                          /* nb_remainde r*/\n    0,                          /* nb_divmod */\n    0,                          /* nb_power */\n    0,                          /* nb_negative */\n    0,                          /* tp_positive */\n    0,                          /* tp_absolute */\n    0,                          /* tp_bool */\n    0,                          /* nb_invert */\n    0,                          /* nb_lshift */\n    0,                          /* nb_rshift */\n    0,                          /* nb_and */\n    0,                          /* nb_xor */\n    0,                          /* nb_or */\n    0,                          /* nb_int */\n    0,                          /* nb_reserved */\n    0,                          /* nb_float */\n    0,                          /* nb_inplace_add */\n    0,                          /* nb_inplace_subtract */\n    0,                          /* nb_inplace_multiply */\n    0,                          /* nb_inplace_remainder */\n    0,                          /* nb_inplace_power */\n    0,                          /* nb_inplace_lshift */\n    0,                          /* nb_inplace_rshift */\n    0,                          /* nb_inplace_and */\n    0,                          /* nb_inplace_xor */\n    0,                          /* nb_inplace_or */\n    0,                          /* nb_floor_divide */\n    0,                          /* nb_true_divide */\n    0,                          /* nb_inplace_floor_divide */\n    0,                          /* nb_inplace_true_divide */\n    0,                          /* nb_index */\n    matmulType_matmul,        /* nb_matrix_multiply */\n    matmulType_imatmul        /* nb_matrix_inplace_multiply */\n};\n\nstatic PyTypeObject matmulType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"matmulType\",\n    sizeof(matmulObject),               /* tp_basicsize */\n    0,                                  /* tp_itemsize */\n    matmulType_dealloc,                 /* destructor tp_dealloc */\n    0,                                  /* tp_vectorcall_offset */\n    0,                                  /* tp_getattr */\n    0,                                  /* tp_setattr */\n    0,                                  /* tp_as_async */\n    0,                                  /* tp_repr */\n    &matmulType_as_number,              /* tp_as_number */\n    0,                                  /* tp_as_sequence */\n    0,                                  /* tp_as_mapping */\n    0,                                  /* tp_hash */\n    0,                                  /* tp_call */\n    0,                                  /* tp_str */\n    PyObject_GenericGetAttr,            /* tp_getattro */\n    PyObject_GenericSetAttr,            /* tp_setattro */\n    0,                                  /* tp_as_buffer */\n    0,                                  /* tp_flags */\n    \"C level type with matrix operations defined\",\n    0,                                  /* traverseproc tp_traverse */\n    0,                                  /* tp_clear */\n    0,                                  /* tp_richcompare */\n    0,                                  /* tp_weaklistoffset */\n    0,                                  /* tp_iter */\n    0,                                  /* tp_iternext */\n    0,                                  /* tp_methods */\n    0,                                  /* tp_members */\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    PyType_GenericNew,                  /* tp_new */\n    PyObject_Del,                       /* tp_free */\n};\n\ntypedef struct {\n    PyObject_HEAD\n} ipowObject;\n\nstatic PyObject *\nipowType_ipow(PyObject *self, PyObject *other, PyObject *mod)\n{\n    return PyTuple_Pack(2, other, mod);\n}\n\nstatic PyNumberMethods ipowType_as_number = {\n    .nb_inplace_power = ipowType_ipow\n};\n\nstatic PyTypeObject ipowType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    .tp_name = \"ipowType\",\n    .tp_basicsize = sizeof(ipowObject),\n    .tp_as_number = &ipowType_as_number,\n    .tp_new = PyType_GenericNew\n};\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *ao_iterator;\n} awaitObject;\n\n\nstatic PyObject *\nawaitObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyObject *v;\n    awaitObject *ao;\n\n    if (!PyArg_UnpackTuple(args, \"awaitObject\", 1, 1, &v))\n        return NULL;\n\n    ao = (awaitObject *)type->tp_alloc(type, 0);\n    if (ao == NULL) {\n        return NULL;\n    }\n\n    ao->ao_iterator = Py_NewRef(v);\n\n    return (PyObject *)ao;\n}\n\n\nstatic void\nawaitObject_dealloc(awaitObject *ao)\n{\n    Py_CLEAR(ao->ao_iterator);\n    Py_TYPE(ao)->tp_free(ao);\n}\n\n\nstatic PyObject *\nawaitObject_await(awaitObject *ao)\n{\n    return Py_NewRef(ao->ao_iterator);\n}\n\nstatic PyAsyncMethods awaitType_as_async = {\n    (unaryfunc)awaitObject_await,           /* am_await */\n    0,                                      /* am_aiter */\n    0,                                      /* am_anext */\n    0,                                      /* am_send  */\n};\n\n\nstatic PyTypeObject awaitType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"awaitType\",\n    sizeof(awaitObject),                /* tp_basicsize */\n    0,                                  /* tp_itemsize */\n    (destructor)awaitObject_dealloc,    /* destructor tp_dealloc */\n    0,                                  /* tp_vectorcall_offset */\n    0,                                  /* tp_getattr */\n    0,                                  /* tp_setattr */\n    &awaitType_as_async,                /* tp_as_async */\n    0,                                  /* tp_repr */\n    0,                                  /* tp_as_number */\n    0,                                  /* tp_as_sequence */\n    0,                                  /* tp_as_mapping */\n    0,                                  /* tp_hash */\n    0,                                  /* tp_call */\n    0,                                  /* tp_str */\n    PyObject_GenericGetAttr,            /* tp_getattro */\n    PyObject_GenericSetAttr,            /* tp_setattro */\n    0,                                  /* tp_as_buffer */\n    0,                                  /* tp_flags */\n    \"C level type with tp_as_async\",\n    0,                                  /* traverseproc tp_traverse */\n    0,                                  /* tp_clear */\n    0,                                  /* tp_richcompare */\n    0,                                  /* tp_weaklistoffset */\n    0,                                  /* tp_iter */\n    0,                                  /* tp_iternext */\n    0,                                  /* tp_methods */\n    0,                                  /* tp_members */\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    awaitObject_new,                    /* tp_new */\n    PyObject_Del,                       /* tp_free */\n};\n\n\n/* Test bpo-35983: create a subclass of \"list\" which checks that instances\n * are not deallocated twice */\n\ntypedef struct {\n    PyListObject list;\n    int deallocated;\n} MyListObject;\n\nstatic PyObject *\nMyList_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyObject* op = PyList_Type.tp_new(type, args, kwds);\n    ((MyListObject*)op)->deallocated = 0;\n    return op;\n}\n\nvoid\nMyList_dealloc(MyListObject* op)\n{\n    if (op->deallocated) {\n        /* We cannot raise exceptions here but we still want the testsuite\n         * to fail when we hit this */\n        Py_FatalError(\"MyList instance deallocated twice\");\n    }\n    op->deallocated = 1;\n    PyList_Type.tp_dealloc((PyObject *)op);\n}\n\nstatic PyTypeObject MyList_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"MyList\",\n    sizeof(MyListObject),\n    0,\n    (destructor)MyList_dealloc,                 /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,  /* &PyList_Type */                      /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    MyList_new,                                 /* tp_new */\n};\n\n/* Test PEP 560 */\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *item;\n} PyGenericAliasObject;\n\nstatic void\ngeneric_alias_dealloc(PyGenericAliasObject *self)\n{\n    Py_CLEAR(self->item);\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\nstatic PyObject *\ngeneric_alias_mro_entries(PyGenericAliasObject *self, PyObject *bases)\n{\n    return PyTuple_Pack(1, self->item);\n}\n\nstatic PyMethodDef generic_alias_methods[] = {\n    {\"__mro_entries__\", _PyCFunction_CAST(generic_alias_mro_entries), METH_O, NULL},\n    {NULL}  /* sentinel */\n};\n\nstatic PyTypeObject GenericAlias_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"GenericAlias\",\n    sizeof(PyGenericAliasObject),\n    0,\n    .tp_dealloc = (destructor)generic_alias_dealloc,\n    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n    .tp_methods = generic_alias_methods,\n};\n\nstatic PyObject *\ngeneric_alias_new(PyObject *item)\n{\n    PyGenericAliasObject *o = PyObject_New(PyGenericAliasObject, &GenericAlias_Type);\n    if (o == NULL) {\n        return NULL;\n    }\n    o->item = Py_NewRef(item);\n    return (PyObject*) o;\n}\n\ntypedef struct {\n    PyObject_HEAD\n} PyGenericObject;\n\nstatic PyObject *\ngeneric_class_getitem(PyObject *type, PyObject *item)\n{\n    return generic_alias_new(item);\n}\n\nstatic PyMethodDef generic_methods[] = {\n    {\"__class_getitem__\", generic_class_getitem, METH_O|METH_CLASS, NULL},\n    {NULL}  /* sentinel */\n};\n\nstatic PyTypeObject Generic_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"Generic\",\n    sizeof(PyGenericObject),\n    0,\n    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n    .tp_methods = generic_methods,\n};\n\nstatic PyMethodDef meth_instance_methods[] = {\n    {\"meth_varargs\", meth_varargs, METH_VARARGS},\n    {\"meth_varargs_keywords\", _PyCFunction_CAST(meth_varargs_keywords), METH_VARARGS|METH_KEYWORDS},\n    {\"meth_o\", meth_o, METH_O},\n    {\"meth_noargs\", meth_noargs, METH_NOARGS},\n    {\"meth_fastcall\", _PyCFunction_CAST(meth_fastcall), METH_FASTCALL},\n    {\"meth_fastcall_keywords\", _PyCFunction_CAST(meth_fastcall_keywords), METH_FASTCALL|METH_KEYWORDS},\n    {NULL, NULL} /* sentinel */\n};\n\n\nstatic PyTypeObject MethInstance_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"MethInstance\",\n    sizeof(PyObject),\n    .tp_new = PyType_GenericNew,\n    .tp_flags = Py_TPFLAGS_DEFAULT,\n    .tp_methods = meth_instance_methods,\n    .tp_doc = (char*)PyDoc_STR(\n        \"Class with normal (instance) methods to test calling conventions\"),\n};\n\nstatic PyMethodDef meth_class_methods[] = {\n    {\"meth_varargs\", meth_varargs, METH_VARARGS|METH_CLASS},\n    {\"meth_varargs_keywords\", _PyCFunction_CAST(meth_varargs_keywords), METH_VARARGS|METH_KEYWORDS|METH_CLASS},\n    {\"meth_o\", meth_o, METH_O|METH_CLASS},\n    {\"meth_noargs\", meth_noargs, METH_NOARGS|METH_CLASS},\n    {\"meth_fastcall\", _PyCFunction_CAST(meth_fastcall), METH_FASTCALL|METH_CLASS},\n    {\"meth_fastcall_keywords\", _PyCFunction_CAST(meth_fastcall_keywords), METH_FASTCALL|METH_KEYWORDS|METH_CLASS},\n    {NULL, NULL} /* sentinel */\n};\n\n\nstatic PyTypeObject MethClass_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"MethClass\",\n    sizeof(PyObject),\n    .tp_new = PyType_GenericNew,\n    .tp_flags = Py_TPFLAGS_DEFAULT,\n    .tp_methods = meth_class_methods,\n    .tp_doc = PyDoc_STR(\n        \"Class with class methods to test calling conventions\"),\n};\n\nstatic PyMethodDef meth_static_methods[] = {\n    {\"meth_varargs\", meth_varargs, METH_VARARGS|METH_STATIC},\n    {\"meth_varargs_keywords\", _PyCFunction_CAST(meth_varargs_keywords), METH_VARARGS|METH_KEYWORDS|METH_STATIC},\n    {\"meth_o\", meth_o, METH_O|METH_STATIC},\n    {\"meth_noargs\", meth_noargs, METH_NOARGS|METH_STATIC},\n    {\"meth_fastcall\", _PyCFunction_CAST(meth_fastcall), METH_FASTCALL|METH_STATIC},\n    {\"meth_fastcall_keywords\", _PyCFunction_CAST(meth_fastcall_keywords), METH_FASTCALL|METH_KEYWORDS|METH_STATIC},\n    {NULL, NULL} /* sentinel */\n};\n\n\nstatic PyTypeObject MethStatic_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"MethStatic\",\n    sizeof(PyObject),\n    .tp_new = PyType_GenericNew,\n    .tp_flags = Py_TPFLAGS_DEFAULT,\n    .tp_methods = meth_static_methods,\n    .tp_doc = PyDoc_STR(\n        \"Class with static methods to test calling conventions\"),\n};\n\n/* ContainerNoGC -- a simple container without GC methods */\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *value;\n} ContainerNoGCobject;\n\nstatic PyObject *\nContainerNoGC_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)\n{\n    PyObject *value;\n    char *names[] = {\"value\", NULL};\n    if (!PyArg_ParseTupleAndKeywords(args, kwargs, \"O\", names, &value)) {\n        return NULL;\n    }\n    PyObject *self = type->tp_alloc(type, 0);\n    if (self == NULL) {\n        return NULL;\n    }\n    Py_INCREF(value);\n    ((ContainerNoGCobject *)self)->value = value;\n    return self;\n}\n\nstatic void\nContainerNoGC_dealloc(ContainerNoGCobject *self)\n{\n    Py_DECREF(self->value);\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\nstatic PyMemberDef ContainerNoGC_members[] = {\n    {\"value\", _Py_T_OBJECT, offsetof(ContainerNoGCobject, value), Py_READONLY,\n     PyDoc_STR(\"a container value for test purposes\")},\n    {0}\n};\n\nstatic PyTypeObject ContainerNoGC_type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_testcapi.ContainerNoGC\",\n    sizeof(ContainerNoGCobject),\n    .tp_dealloc = (destructor)ContainerNoGC_dealloc,\n    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n    .tp_members = ContainerNoGC_members,\n    .tp_new = ContainerNoGC_new,\n};\n\n\nstatic struct PyModuleDef _testcapimodule = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = \"_testcapi\",\n    .m_size = sizeof(testcapistate_t),\n    .m_methods = TestMethods,\n};\n\n/* Per PEP 489, this module will not be converted to multi-phase initialization\n */\n\nPyMODINIT_FUNC\nPyInit__testcapi(void)\n{\n    PyObject *m;\n\n    m = PyModule_Create(&_testcapimodule);\n    if (m == NULL)\n        return NULL;\n#ifdef Py_GIL_DISABLED\n    PyUnstable_Module_SetGIL(m, Py_MOD_GIL_NOT_USED);\n#endif\n\n    Py_SET_TYPE(&_HashInheritanceTester_Type, &PyType_Type);\n    if (PyType_Ready(&_HashInheritanceTester_Type) < 0) {\n        return NULL;\n    }\n    if (PyType_Ready(&matmulType) < 0)\n        return NULL;\n    Py_INCREF(&matmulType);\n    PyModule_AddObject(m, \"matmulType\", (PyObject *)&matmulType);\n    if (PyType_Ready(&ipowType) < 0) {\n        return NULL;\n    }\n    Py_INCREF(&ipowType);\n    PyModule_AddObject(m, \"ipowType\", (PyObject *)&ipowType);\n\n    if (PyType_Ready(&awaitType) < 0)\n        return NULL;\n    Py_INCREF(&awaitType);\n    PyModule_AddObject(m, \"awaitType\", (PyObject *)&awaitType);\n\n    MyList_Type.tp_base = &PyList_Type;\n    if (PyType_Ready(&MyList_Type) < 0)\n        return NULL;\n    Py_INCREF(&MyList_Type);\n    PyModule_AddObject(m, \"MyList\", (PyObject *)&MyList_Type);\n\n    if (PyType_Ready(&GenericAlias_Type) < 0)\n        return NULL;\n    Py_INCREF(&GenericAlias_Type);\n    PyModule_AddObject(m, \"GenericAlias\", (PyObject *)&GenericAlias_Type);\n\n    if (PyType_Ready(&Generic_Type) < 0)\n        return NULL;\n    Py_INCREF(&Generic_Type);\n    PyModule_AddObject(m, \"Generic\", (PyObject *)&Generic_Type);\n\n    if (PyType_Ready(&MethInstance_Type) < 0)\n        return NULL;\n    Py_INCREF(&MethInstance_Type);\n    PyModule_AddObject(m, \"MethInstance\", (PyObject *)&MethInstance_Type);\n\n    if (PyType_Ready(&MethClass_Type) < 0)\n        return NULL;\n    Py_INCREF(&MethClass_Type);\n    PyModule_AddObject(m, \"MethClass\", (PyObject *)&MethClass_Type);\n\n    if (PyType_Ready(&MethStatic_Type) < 0)\n        return NULL;\n    Py_INCREF(&MethStatic_Type);\n    PyModule_AddObject(m, \"MethStatic\", (PyObject *)&MethStatic_Type);\n\n    PyModule_AddObject(m, \"CHAR_MAX\", PyLong_FromLong(CHAR_MAX));\n    PyModule_AddObject(m, \"CHAR_MIN\", PyLong_FromLong(CHAR_MIN));\n    PyModule_AddObject(m, \"UCHAR_MAX\", PyLong_FromLong(UCHAR_MAX));\n    PyModule_AddObject(m, \"SHRT_MAX\", PyLong_FromLong(SHRT_MAX));\n    PyModule_AddObject(m, \"SHRT_MIN\", PyLong_FromLong(SHRT_MIN));\n    PyModule_AddObject(m, \"USHRT_MAX\", PyLong_FromLong(USHRT_MAX));\n    PyModule_AddObject(m, \"INT_MAX\",  PyLong_FromLong(INT_MAX));\n    PyModule_AddObject(m, \"INT_MIN\",  PyLong_FromLong(INT_MIN));\n    PyModule_AddObject(m, \"UINT_MAX\",  PyLong_FromUnsignedLong(UINT_MAX));\n    PyModule_AddObject(m, \"LONG_MAX\", PyLong_FromLong(LONG_MAX));\n    PyModule_AddObject(m, \"LONG_MIN\", PyLong_FromLong(LONG_MIN));\n    PyModule_AddObject(m, \"ULONG_MAX\", PyLong_FromUnsignedLong(ULONG_MAX));\n    PyModule_AddObject(m, \"FLT_MAX\", PyFloat_FromDouble(FLT_MAX));\n    PyModule_AddObject(m, \"FLT_MIN\", PyFloat_FromDouble(FLT_MIN));\n    PyModule_AddObject(m, \"DBL_MAX\", PyFloat_FromDouble(DBL_MAX));\n    PyModule_AddObject(m, \"DBL_MIN\", PyFloat_FromDouble(DBL_MIN));\n    PyModule_AddObject(m, \"LLONG_MAX\", PyLong_FromLongLong(LLONG_MAX));\n    PyModule_AddObject(m, \"LLONG_MIN\", PyLong_FromLongLong(LLONG_MIN));\n    PyModule_AddObject(m, \"ULLONG_MAX\", PyLong_FromUnsignedLongLong(ULLONG_MAX));\n    PyModule_AddObject(m, \"PY_SSIZE_T_MAX\", PyLong_FromSsize_t(PY_SSIZE_T_MAX));\n    PyModule_AddObject(m, \"PY_SSIZE_T_MIN\", PyLong_FromSsize_t(PY_SSIZE_T_MIN));\n    PyModule_AddObject(m, \"SIZE_MAX\", PyLong_FromSize_t(SIZE_MAX));\n    PyModule_AddObject(m, \"SIZEOF_WCHAR_T\", PyLong_FromSsize_t(sizeof(wchar_t)));\n    PyModule_AddObject(m, \"SIZEOF_VOID_P\", PyLong_FromSsize_t(sizeof(void*)));\n    PyModule_AddObject(m, \"SIZEOF_TIME_T\", PyLong_FromSsize_t(sizeof(time_t)));\n    PyModule_AddObject(m, \"SIZEOF_PID_T\", PyLong_FromSsize_t(sizeof(pid_t)));\n    PyModule_AddObject(m, \"Py_Version\", PyLong_FromUnsignedLong(Py_Version));\n    Py_INCREF(&PyInstanceMethod_Type);\n    PyModule_AddObject(m, \"instancemethod\", (PyObject *)&PyInstanceMethod_Type);\n\n    PyModule_AddIntConstant(m, \"the_number_three\", 3);\n    PyModule_AddIntMacro(m, Py_C_RECURSION_LIMIT);\n\n    if (PyModule_AddIntMacro(m, Py_single_input)) {\n        return NULL;\n    }\n    if (PyModule_AddIntMacro(m, Py_file_input)) {\n        return NULL;\n    }\n    if (PyModule_AddIntMacro(m, Py_eval_input)) {\n        return NULL;\n    }\n\n    testcapistate_t *state = get_testcapi_state(m);\n    state->error = PyErr_NewException(\"_testcapi.error\", NULL, NULL);\n    PyModule_AddObject(m, \"error\", state->error);\n\n    if (PyType_Ready(&ContainerNoGC_type) < 0) {\n        return NULL;\n    }\n    Py_INCREF(&ContainerNoGC_type);\n    if (PyModule_AddObject(m, \"ContainerNoGC\",\n                           (PyObject *) &ContainerNoGC_type) < 0)\n        return NULL;\n\n    /* Include tests from the _testcapi/ directory */\n    if (_PyTestCapi_Init_Vectorcall(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Heaptype(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Abstract(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Bytes(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Unicode(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_GetArgs(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_DateTime(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Docstring(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Mem(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Watchers(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Long(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Float(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Complex(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Numbers(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Dict(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Set(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_List(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Tuple(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Structmember(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Exceptions(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Code(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Buffer(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_File(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Codec(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Immortal(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_GC(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_PyAtomic(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Run(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Hash(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Time(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Monitoring(m) < 0) {\n        return NULL;\n    }\n    if (_PyTestCapi_Init_Object(m) < 0) {\n        return NULL;\n    }\n\n    PyState_AddModule(m, &_testcapimodule);\n    return m;\n}\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-allocation-size", "taxa": [{"id": "131", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "allocated buffer size is not a multiple of the pointee's size"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 224, "startColumn": 5, "endColumn": 14}, "contextRegion": {"startLine": 224, "snippet": {"text": "    k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapi/util.h", "uriBaseId": "PWD"}, "region": {"startLine": 28, "startColumn": 19, "endColumn": 32}, "contextRegion": {"startLine": 28, "snippet": {"text": "static const char uninitialized[] = \"uninitialized\";\n"}}}, "message": {"text": "allocated here"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 209, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 209, "snippet": {"text": "    if (dict == NULL)\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'dict' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 224, "startColumn": 5, "endColumn": 14}, "contextRegion": {"startLine": 224, "snippet": {"text": "    k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "assigned to 'PyObject *' {aka 'struct _object *'} here; 'sizeof (PyObject {aka struct _object})' is '32'"}}, "kinds": ["danger"], "nestingLevel": 1}]}]}]}, {"ruleId": "-Wanalyzer-allocation-size", "taxa": [{"id": "131", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "allocated buffer size is not a multiple of the pointee's size"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 224, "startColumn": 5, "endColumn": 14}, "contextRegion": {"startLine": 224, "snippet": {"text": "    k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapi/util.h", "uriBaseId": "PWD"}, "region": {"startLine": 28, "startColumn": 19, "endColumn": 32}, "contextRegion": {"startLine": 28, "snippet": {"text": "static const char uninitialized[] = \"uninitialized\";\n"}}}, "message": {"text": "allocated here"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 264, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 264, "snippet": {"text": "test_dict_iteration(PyObject* self, PyObject *Py_UNUSED(ignored))\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "entry to 'test_dict_iteration'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 268, "startColumn": 17, "endColumn": 24}, "contextRegion": {"startLine": 268, "snippet": {"text": "    for (i = 0; i < 200; i++) {\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i != 200')..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 269, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 269, "snippet": {"text": "        if (test_dict_inner(self, i) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 269, "startColumn": 13, "endColumn": 37}, "contextRegion": {"startLine": 269, "snippet": {"text": "        if (test_dict_inner(self, i) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "calling 'test_dict_inner' from 'test_dict_iteration'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 202, "startColumn": 1, "endColumn": 16}, "contextRegion": {"startLine": 202, "snippet": {"text": "test_dict_inner(PyObject *self, int count)\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "entry to 'test_dict_inner'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 209, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 209, "snippet": {"text": "    if (dict == NULL)\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'dict' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 212, "startColumn": 17, "endColumn": 26}, "contextRegion": {"startLine": 212, "snippet": {"text": "    for (i = 0; i < count; i++) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'i >= count')..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 224, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 224, "snippet": {"text": "    k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 224, "startColumn": 5, "endColumn": 14}, "contextRegion": {"startLine": 224, "snippet": {"text": "    k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "assigned to 'PyObject *' {aka 'struct _object *'} here; 'sizeof (PyObject {aka struct _object})' is '32'"}}, "kinds": ["danger"], "nestingLevel": 2}]}]}]}, {"ruleId": "-Wanalyzer-allocation-size", "taxa": [{"id": "131", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "allocated buffer size is not a multiple of the pointee's size"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 224, "startColumn": 9, "endColumn": 14}, "contextRegion": {"startLine": 224, "snippet": {"text": "    k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapi/util.h", "uriBaseId": "PWD"}, "region": {"startLine": 28, "startColumn": 19, "endColumn": 32}, "contextRegion": {"startLine": 28, "snippet": {"text": "static const char uninitialized[] = \"uninitialized\";\n"}}}, "message": {"text": "allocated here"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 209, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 209, "snippet": {"text": "    if (dict == NULL)\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'dict' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 224, "startColumn": 9, "endColumn": 14}, "contextRegion": {"startLine": 224, "snippet": {"text": "    k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "assigned to 'PyObject *' {aka 'struct _object *'} here; 'sizeof (PyObject {aka struct _object})' is '32'"}}, "kinds": ["danger"], "nestingLevel": 1}]}]}]}, {"ruleId": "-Wanalyzer-allocation-size", "taxa": [{"id": "131", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "allocated buffer size is not a multiple of the pointee's size"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 224, "startColumn": 9, "endColumn": 14}, "contextRegion": {"startLine": 224, "snippet": {"text": "    k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapi/util.h", "uriBaseId": "PWD"}, "region": {"startLine": 28, "startColumn": 19, "endColumn": 32}, "contextRegion": {"startLine": 28, "snippet": {"text": "static const char uninitialized[] = \"uninitialized\";\n"}}}, "message": {"text": "allocated here"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 264, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 264, "snippet": {"text": "test_dict_iteration(PyObject* self, PyObject *Py_UNUSED(ignored))\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "entry to 'test_dict_iteration'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 268, "startColumn": 17, "endColumn": 24}, "contextRegion": {"startLine": 268, "snippet": {"text": "    for (i = 0; i < 200; i++) {\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i != 200')..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 269, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 269, "snippet": {"text": "        if (test_dict_inner(self, i) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 269, "startColumn": 13, "endColumn": 37}, "contextRegion": {"startLine": 269, "snippet": {"text": "        if (test_dict_inner(self, i) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "calling 'test_dict_inner' from 'test_dict_iteration'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 202, "startColumn": 1, "endColumn": 16}, "contextRegion": {"startLine": 202, "snippet": {"text": "test_dict_inner(PyObject *self, int count)\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "entry to 'test_dict_inner'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 209, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 209, "snippet": {"text": "    if (dict == NULL)\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'dict' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 212, "startColumn": 17, "endColumn": 26}, "contextRegion": {"startLine": 212, "snippet": {"text": "    for (i = 0; i < count; i++) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'i >= count')..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 224, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 224, "snippet": {"text": "    k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 224, "startColumn": 9, "endColumn": 14}, "contextRegion": {"startLine": 224, "snippet": {"text": "    k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "assigned to 'PyObject *' {aka 'struct _object *'} here; 'sizeof (PyObject {aka struct _object})' is '32'"}}, "kinds": ["danger"], "nestingLevel": 2}]}]}]}, {"ruleId": "-Wanalyzer-allocation-size", "taxa": [{"id": "131", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "allocated buffer size is not a multiple of the pointee's size"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 241, "startColumn": 9, "endColumn": 18}, "contextRegion": {"startLine": 241, "snippet": {"text": "        k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapi/util.h", "uriBaseId": "PWD"}, "region": {"startLine": 28, "startColumn": 19, "endColumn": 32}, "contextRegion": {"startLine": 28, "snippet": {"text": "static const char uninitialized[] = \"uninitialized\";\n"}}}, "message": {"text": "allocated here"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 209, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 209, "snippet": {"text": "    if (dict == NULL)\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'dict' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 225, "startColumn": 12, "endColumn": 23}, "contextRegion": {"startLine": 225, "snippet": {"text": "    while (PyDict_Next(dict, &pos, &k, &v)) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 226, "startColumn": 9, "endColumn": 17}, "contextRegion": {"startLine": 226, "snippet": {"text": "        PyObject *o;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 229, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 229, "snippet": {"text": "        assert(k != UNINITIALIZED_PTR);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 230, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 230, "snippet": {"text": "        assert(v != UNINITIALIZED_PTR);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 230, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 230, "snippet": {"text": "        assert(v != UNINITIALIZED_PTR);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 231, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 231, "snippet": {"text": "        i = PyLong_AS_LONG(v) + 1;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 233, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 233, "snippet": {"text": "        if (o == NULL) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'o' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 236, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 236, "snippet": {"text": "        if (PyDict_SetItem(dict, k, o) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 236, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 236, "snippet": {"text": "        if (PyDict_SetItem(dict, k, o) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 240, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 240, "snippet": {"text": "        Py_DECREF(o);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 241, "startColumn": 9, "endColumn": 18}, "contextRegion": {"startLine": 241, "snippet": {"text": "        k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "assigned to 'PyObject *' {aka 'struct _object *'} here; 'sizeof (PyObject {aka struct _object})' is '32'"}}, "kinds": ["danger"], "nestingLevel": 1}]}]}]}, {"ruleId": "-Wanalyzer-allocation-size", "taxa": [{"id": "131", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "allocated buffer size is not a multiple of the pointee's size"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 241, "startColumn": 9, "endColumn": 18}, "contextRegion": {"startLine": 241, "snippet": {"text": "        k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapi/util.h", "uriBaseId": "PWD"}, "region": {"startLine": 28, "startColumn": 19, "endColumn": 32}, "contextRegion": {"startLine": 28, "snippet": {"text": "static const char uninitialized[] = \"uninitialized\";\n"}}}, "message": {"text": "allocated here"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 264, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 264, "snippet": {"text": "test_dict_iteration(PyObject* self, PyObject *Py_UNUSED(ignored))\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "entry to 'test_dict_iteration'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 268, "startColumn": 17, "endColumn": 24}, "contextRegion": {"startLine": 268, "snippet": {"text": "    for (i = 0; i < 200; i++) {\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i != 200')..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 269, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 269, "snippet": {"text": "        if (test_dict_inner(self, i) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 269, "startColumn": 13, "endColumn": 37}, "contextRegion": {"startLine": 269, "snippet": {"text": "        if (test_dict_inner(self, i) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "calling 'test_dict_inner' from 'test_dict_iteration'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 202, "startColumn": 1, "endColumn": 16}, "contextRegion": {"startLine": 202, "snippet": {"text": "test_dict_inner(PyObject *self, int count)\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "entry to 'test_dict_inner'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 209, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 209, "snippet": {"text": "    if (dict == NULL)\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'dict' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 212, "startColumn": 17, "endColumn": 26}, "contextRegion": {"startLine": 212, "snippet": {"text": "    for (i = 0; i < count; i++) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'i >= count')..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 224, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 224, "snippet": {"text": "    k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 225, "startColumn": 12, "endColumn": 23}, "contextRegion": {"startLine": 225, "snippet": {"text": "    while (PyDict_Next(dict, &pos, &k, &v)) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 226, "startColumn": 9, "endColumn": 17}, "contextRegion": {"startLine": 226, "snippet": {"text": "        PyObject *o;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 229, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 229, "snippet": {"text": "        assert(k != UNINITIALIZED_PTR);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 230, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 230, "snippet": {"text": "        assert(v != UNINITIALIZED_PTR);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 230, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 230, "snippet": {"text": "        assert(v != UNINITIALIZED_PTR);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 231, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 231, "snippet": {"text": "        i = PyLong_AS_LONG(v) + 1;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 233, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 233, "snippet": {"text": "        if (o == NULL) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'o' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 236, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 236, "snippet": {"text": "        if (PyDict_SetItem(dict, k, o) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 236, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 236, "snippet": {"text": "        if (PyDict_SetItem(dict, k, o) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 240, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 240, "snippet": {"text": "        Py_DECREF(o);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 241, "startColumn": 9, "endColumn": 18}, "contextRegion": {"startLine": 241, "snippet": {"text": "        k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "assigned to 'PyObject *' {aka 'struct _object *'} here; 'sizeof (PyObject {aka struct _object})' is '32'"}}, "kinds": ["danger"], "nestingLevel": 2}]}]}]}, {"ruleId": "-Wanalyzer-allocation-size", "taxa": [{"id": "131", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "allocated buffer size is not a multiple of the pointee's size"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 241, "startColumn": 13, "endColumn": 18}, "contextRegion": {"startLine": 241, "snippet": {"text": "        k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapi/util.h", "uriBaseId": "PWD"}, "region": {"startLine": 28, "startColumn": 19, "endColumn": 32}, "contextRegion": {"startLine": 28, "snippet": {"text": "static const char uninitialized[] = \"uninitialized\";\n"}}}, "message": {"text": "allocated here"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 209, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 209, "snippet": {"text": "    if (dict == NULL)\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'dict' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 225, "startColumn": 12, "endColumn": 23}, "contextRegion": {"startLine": 225, "snippet": {"text": "    while (PyDict_Next(dict, &pos, &k, &v)) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 226, "startColumn": 9, "endColumn": 17}, "contextRegion": {"startLine": 226, "snippet": {"text": "        PyObject *o;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 229, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 229, "snippet": {"text": "        assert(k != UNINITIALIZED_PTR);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 230, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 230, "snippet": {"text": "        assert(v != UNINITIALIZED_PTR);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 230, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 230, "snippet": {"text": "        assert(v != UNINITIALIZED_PTR);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 231, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 231, "snippet": {"text": "        i = PyLong_AS_LONG(v) + 1;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 233, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 233, "snippet": {"text": "        if (o == NULL) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'o' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 236, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 236, "snippet": {"text": "        if (PyDict_SetItem(dict, k, o) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 236, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 236, "snippet": {"text": "        if (PyDict_SetItem(dict, k, o) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 240, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 240, "snippet": {"text": "        Py_DECREF(o);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 241, "startColumn": 13, "endColumn": 18}, "contextRegion": {"startLine": 241, "snippet": {"text": "        k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "assigned to 'PyObject *' {aka 'struct _object *'} here; 'sizeof (PyObject {aka struct _object})' is '32'"}}, "kinds": ["danger"], "nestingLevel": 1}]}]}]}, {"ruleId": "-Wanalyzer-allocation-size", "taxa": [{"id": "131", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "allocated buffer size is not a multiple of the pointee's size"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 241, "startColumn": 13, "endColumn": 18}, "contextRegion": {"startLine": 241, "snippet": {"text": "        k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapi/util.h", "uriBaseId": "PWD"}, "region": {"startLine": 28, "startColumn": 19, "endColumn": 32}, "contextRegion": {"startLine": 28, "snippet": {"text": "static const char uninitialized[] = \"uninitialized\";\n"}}}, "message": {"text": "allocated here"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 264, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 264, "snippet": {"text": "test_dict_iteration(PyObject* self, PyObject *Py_UNUSED(ignored))\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "entry to 'test_dict_iteration'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 268, "startColumn": 17, "endColumn": 24}, "contextRegion": {"startLine": 268, "snippet": {"text": "    for (i = 0; i < 200; i++) {\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i != 200')..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 269, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 269, "snippet": {"text": "        if (test_dict_inner(self, i) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 269, "startColumn": 13, "endColumn": 37}, "contextRegion": {"startLine": 269, "snippet": {"text": "        if (test_dict_inner(self, i) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_iteration", "fullyQualifiedName": "test_dict_iteration", "decoratedName": "test_dict_iteration", "kind": "function"}], "message": {"text": "calling 'test_dict_inner' from 'test_dict_iteration'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 202, "startColumn": 1, "endColumn": 16}, "contextRegion": {"startLine": 202, "snippet": {"text": "test_dict_inner(PyObject *self, int count)\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "entry to 'test_dict_inner'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 209, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 209, "snippet": {"text": "    if (dict == NULL)\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'dict' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 212, "startColumn": 17, "endColumn": 26}, "contextRegion": {"startLine": 212, "snippet": {"text": "    for (i = 0; i < count; i++) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'i >= count')..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 224, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 224, "snippet": {"text": "    k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 225, "startColumn": 12, "endColumn": 23}, "contextRegion": {"startLine": 225, "snippet": {"text": "    while (PyDict_Next(dict, &pos, &k, &v)) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 226, "startColumn": 9, "endColumn": 17}, "contextRegion": {"startLine": 226, "snippet": {"text": "        PyObject *o;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 229, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 229, "snippet": {"text": "        assert(k != UNINITIALIZED_PTR);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 230, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 230, "snippet": {"text": "        assert(v != UNINITIALIZED_PTR);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 230, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 230, "snippet": {"text": "        assert(v != UNINITIALIZED_PTR);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 231, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 231, "snippet": {"text": "        i = PyLong_AS_LONG(v) + 1;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 233, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 233, "snippet": {"text": "        if (o == NULL) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch (when 'o' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 236, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 236, "snippet": {"text": "        if (PyDict_SetItem(dict, k, o) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 236, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 236, "snippet": {"text": "        if (PyDict_SetItem(dict, k, o) < 0) {\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 240, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 240, "snippet": {"text": "        Py_DECREF(o);\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 241, "startColumn": 13, "endColumn": 18}, "contextRegion": {"startLine": 241, "snippet": {"text": "        k = v = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_dict_inner", "fullyQualifiedName": "test_dict_inner", "decoratedName": "test_dict_inner", "kind": "function"}], "message": {"text": "assigned to 'PyObject *' {aka 'struct _object *'} here; 'sizeof (PyObject {aka struct _object})' is '32'"}}, "kinds": ["danger"], "nestingLevel": 2}]}]}]}, {"ruleId": "-Wanalyzer-allocation-size", "taxa": [{"id": "131", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "allocated buffer size is not a multiple of the pointee's size"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3166, "startColumn": 15, "endColumn": 18}, "contextRegion": {"startLine": 3166, "snippet": {"text": "    PyObject *ref = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_weakref_capi", "fullyQualifiedName": "test_weakref_capi", "decoratedName": "test_weakref_capi", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapi/util.h", "uriBaseId": "PWD"}, "region": {"startLine": 28, "startColumn": 19, "endColumn": 32}, "contextRegion": {"startLine": 28, "snippet": {"text": "static const char uninitialized[] = \"uninitialized\";\n"}}}, "message": {"text": "allocated here"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3142, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3142, "snippet": {"text": "    if (new_type == NULL) {\n"}}}, "logicalLocations": [{"name": "test_weakref_capi", "fullyQualifiedName": "test_weakref_capi", "decoratedName": "test_weakref_capi", "kind": "function"}], "message": {"text": "following 'false' branch (when 'new_type' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3145, "startColumn": 5, "endColumn": 13}, "contextRegion": {"startLine": 3145, "snippet": {"text": "    PyObject *obj = PyObject_CallNoArgs(new_type);\n"}}}, "logicalLocations": [{"name": "test_weakref_capi", "fullyQualifiedName": "test_weakref_capi", "decoratedName": "test_weakref_capi", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3147, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3147, "snippet": {"text": "    if (obj == NULL) {\n"}}}, "logicalLocations": [{"name": "test_weakref_capi", "fullyQualifiedName": "test_weakref_capi", "decoratedName": "test_weakref_capi", "kind": "function"}], "message": {"text": "following 'false' branch (when 'obj' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3150, "startColumn": 5, "endColumn": 15}, "contextRegion": {"startLine": 3150, "snippet": {"text": "    Py_ssize_t refcnt = Py_REFCNT(obj);\n"}}}, "logicalLocations": [{"name": "test_weakref_capi", "fullyQualifiedName": "test_weakref_capi", "decoratedName": "test_weakref_capi", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3154, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3154, "snippet": {"text": "    if (weakref == NULL) {\n"}}}, "logicalLocations": [{"name": "test_weakref_capi", "fullyQualifiedName": "test_weakref_capi", "decoratedName": "test_weakref_capi", "kind": "function"}], "message": {"text": "following 'false' branch (when 'weakref' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3160, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 3160, "snippet": {"text": "    assert(PyWeakref_Check(weakref));\n"}}}, "logicalLocations": [{"name": "test_weakref_capi", "fullyQualifiedName": "test_weakref_capi", "decoratedName": "test_weakref_capi", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3161, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 3161, "snippet": {"text": "    assert(PyWeakref_CheckRefExact(weakref));\n"}}}, "logicalLocations": [{"name": "test_weakref_capi", "fullyQualifiedName": "test_weakref_capi", "decoratedName": "test_weakref_capi", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3162, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 3162, "snippet": {"text": "    assert(PyWeakref_CheckRefExact(weakref));\n"}}}, "logicalLocations": [{"name": "test_weakref_capi", "fullyQualifiedName": "test_weakref_capi", "decoratedName": "test_weakref_capi", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3163, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 3163, "snippet": {"text": "    assert(Py_REFCNT(obj) == refcnt);\n"}}}, "logicalLocations": [{"name": "test_weakref_capi", "fullyQualifiedName": "test_weakref_capi", "decoratedName": "test_weakref_capi", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3166, "startColumn": 5, "endColumn": 13}, "contextRegion": {"startLine": 3166, "snippet": {"text": "    PyObject *ref = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_weakref_capi", "fullyQualifiedName": "test_weakref_capi", "decoratedName": "test_weakref_capi", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapimodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3166, "startColumn": 15, "endColumn": 18}, "contextRegion": {"startLine": 3166, "snippet": {"text": "    PyObject *ref = UNINITIALIZED_PTR;\n"}}}, "logicalLocations": [{"name": "test_weakref_capi", "fullyQualifiedName": "test_weakref_capi", "decoratedName": "test_weakref_capi", "kind": "function"}], "message": {"text": "assigned to 'PyObject *' {aka 'struct _object *'} here; 'sizeof (PyObject {aka struct _object})' is '32'"}}, "kinds": ["danger"], "nestingLevel": 1}]}]}]}]}]}
