{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-null-dereference", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-dereference"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "476", "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.13.0b4/"}}, "artifacts": [{"location": {"uri": "./Modules/_collectionsmodule.c", "uriBaseId": "PWD"}, "contents": {"text": "#include \"Python.h\"\n#include \"pycore_call.h\"          // _PyObject_CallNoArgs()\n#include \"pycore_dict.h\"          // _PyDict_GetItem_KnownHash()\n#include \"pycore_long.h\"          // _PyLong_GetZero()\n#include \"pycore_moduleobject.h\"  // _PyModule_GetState()\n#include \"pycore_pyatomic_ft_wrappers.h\"\n#include \"pycore_typeobject.h\"    // _PyType_GetModuleState()\n\n#include <stddef.h>\n\ntypedef struct {\n    PyTypeObject *deque_type;\n    PyTypeObject *defdict_type;\n    PyTypeObject *dequeiter_type;\n    PyTypeObject *dequereviter_type;\n    PyTypeObject *tuplegetter_type;\n} collections_state;\n\nstatic inline collections_state *\nget_module_state(PyObject *mod)\n{\n    void *state = _PyModule_GetState(mod);\n    assert(state != NULL);\n    return (collections_state *)state;\n}\n\nstatic inline collections_state *\nget_module_state_by_cls(PyTypeObject *cls)\n{\n    void *state = _PyType_GetModuleState(cls);\n    assert(state != NULL);\n    return (collections_state *)state;\n}\n\nstatic struct PyModuleDef _collectionsmodule;\n\nstatic inline collections_state *\nfind_module_state_by_def(PyTypeObject *type)\n{\n    PyObject *mod = PyType_GetModuleByDef(type, &_collectionsmodule);\n    assert(mod != NULL);\n    return get_module_state(mod);\n}\n\n/*[clinic input]\nmodule _collections\nclass _tuplegetter \"_tuplegetterobject *\" \"clinic_state()->tuplegetter_type\"\nclass _collections.deque \"dequeobject *\" \"clinic_state()->deque_type\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=a033cc2a8476b3f1]*/\n\ntypedef struct dequeobject dequeobject;\n\n/* We can safely assume type to be the defining class,\n * since tuplegetter is not a base type */\n#define clinic_state() (get_module_state_by_cls(type))\n#include \"clinic/_collectionsmodule.c.h\"\n#undef clinic_state\n\n/*[python input]\nclass dequeobject_converter(self_converter):\n    type = \"dequeobject *\"\n[python start generated code]*/\n/*[python end generated code: output=da39a3ee5e6b4b0d input=b6ae4a3ff852be2f]*/\n\n/* collections module implementation of a deque() datatype\n   Written and maintained by Raymond D. Hettinger <python@rcn.com>\n*/\n\n/* The block length may be set to any number over 1.  Larger numbers\n * reduce the number of calls to the memory allocator, give faster\n * indexing and rotation, and reduce the link to data overhead ratio.\n * Making the block length a power of two speeds-up the modulo\n * and division calculations in deque_item() and deque_ass_item().\n */\n\n#define BLOCKLEN 64\n#define CENTER ((BLOCKLEN - 1) / 2)\n#define MAXFREEBLOCKS 16\n\n/* Data for deque objects is stored in a doubly-linked list of fixed\n * length blocks.  This assures that appends or pops never move any\n * other data elements besides the one being appended or popped.\n *\n * Another advantage is that it completely avoids use of realloc(),\n * resulting in more predictable performance.\n *\n * Textbook implementations of doubly-linked lists store one datum\n * per link, but that gives them a 200% memory overhead (a prev and\n * next link for each datum) and it costs one malloc() call per data\n * element.  By using fixed-length blocks, the link to data ratio is\n * significantly improved and there are proportionally fewer calls\n * to malloc() and free().  The data blocks of consecutive pointers\n * also improve cache locality.\n *\n * The list of blocks is never empty, so d.leftblock and d.rightblock\n * are never equal to NULL.  The list is not circular.\n *\n * A deque d's first element is at d.leftblock[leftindex]\n * and its last element is at d.rightblock[rightindex].\n *\n * Unlike Python slice indices, these indices are inclusive on both\n * ends.  This makes the algorithms for left and right operations\n * more symmetrical and it simplifies the design.\n *\n * The indices, d.leftindex and d.rightindex are always in the range:\n *     0 <= index < BLOCKLEN\n *\n * And their exact relationship is:\n *     (d.leftindex + d.len - 1) % BLOCKLEN == d.rightindex\n *\n * Whenever d.leftblock == d.rightblock, then:\n *     d.leftindex + d.len - 1 == d.rightindex\n *\n * However, when d.leftblock != d.rightblock, the d.leftindex and\n * d.rightindex become indices into distinct blocks and either may\n * be larger than the other.\n *\n * Empty deques have:\n *     d.len == 0\n *     d.leftblock == d.rightblock\n *     d.leftindex == CENTER + 1\n *     d.rightindex == CENTER\n *\n * Checking for d.len == 0 is the intended way to see whether d is empty.\n */\n\ntypedef struct BLOCK {\n    struct BLOCK *leftlink;\n    PyObject *data[BLOCKLEN];\n    struct BLOCK *rightlink;\n} block;\n\nstruct dequeobject {\n    PyObject_VAR_HEAD\n    block *leftblock;\n    block *rightblock;\n    Py_ssize_t leftindex;       /* 0 <= leftindex < BLOCKLEN */\n    Py_ssize_t rightindex;      /* 0 <= rightindex < BLOCKLEN */\n    size_t state;               /* incremented whenever the indices move */\n    Py_ssize_t maxlen;          /* maxlen is -1 for unbounded deques */\n    Py_ssize_t numfreeblocks;\n    block *freeblocks[MAXFREEBLOCKS];\n    PyObject *weakreflist;\n};\n\n/* For debug builds, add error checking to track the endpoints\n * in the chain of links.  The goal is to make sure that link\n * assignments only take place at endpoints so that links already\n * in use do not get overwritten.\n *\n * CHECK_END should happen before each assignment to a block's link field.\n * MARK_END should happen whenever a link field becomes a new endpoint.\n * This happens when new blocks are added or whenever an existing\n * block is freed leaving another existing block as the new endpoint.\n */\n\n#ifndef NDEBUG\n#define MARK_END(link)  link = NULL;\n#define CHECK_END(link) assert(link == NULL);\n#define CHECK_NOT_END(link) assert(link != NULL);\n#else\n#define MARK_END(link)\n#define CHECK_END(link)\n#define CHECK_NOT_END(link)\n#endif\n\n/* A simple freelisting scheme is used to minimize calls to the memory\n   allocator.  It accommodates common use cases where new blocks are being\n   added at about the same rate as old blocks are being freed.\n */\n\nstatic inline block *\nnewblock(dequeobject *deque) {\n    block *b;\n    if (deque->numfreeblocks) {\n        deque->numfreeblocks--;\n        return deque->freeblocks[deque->numfreeblocks];\n    }\n    b = PyMem_Malloc(sizeof(block));\n    if (b != NULL) {\n        return b;\n    }\n    PyErr_NoMemory();\n    return NULL;\n}\n\nstatic inline void\nfreeblock(dequeobject *deque, block *b)\n{\n    if (deque->numfreeblocks < MAXFREEBLOCKS) {\n        deque->freeblocks[deque->numfreeblocks] = b;\n        deque->numfreeblocks++;\n    } else {\n        PyMem_Free(b);\n    }\n}\n\nstatic PyObject *\ndeque_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    dequeobject *deque;\n    block *b;\n\n    /* create dequeobject structure */\n    deque = (dequeobject *)type->tp_alloc(type, 0);\n    if (deque == NULL)\n        return NULL;\n\n    b = newblock(deque);\n    if (b == NULL) {\n        Py_DECREF(deque);\n        return NULL;\n    }\n    MARK_END(b->leftlink);\n    MARK_END(b->rightlink);\n\n    assert(BLOCKLEN >= 2);\n    Py_SET_SIZE(deque, 0);\n    deque->leftblock = b;\n    deque->rightblock = b;\n    deque->leftindex = CENTER + 1;\n    deque->rightindex = CENTER;\n    deque->state = 0;\n    deque->maxlen = -1;\n    deque->numfreeblocks = 0;\n    deque->weakreflist = NULL;\n\n    return (PyObject *)deque;\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.pop as deque_pop\n\n    deque: dequeobject\n\nRemove and return the rightmost element.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_pop_impl(dequeobject *deque)\n/*[clinic end generated code: output=2e5f7890c4251f07 input=55c5b6a8ad51d72f]*/\n{\n    PyObject *item;\n    block *prevblock;\n\n    if (Py_SIZE(deque) == 0) {\n        PyErr_SetString(PyExc_IndexError, \"pop from an empty deque\");\n        return NULL;\n    }\n    item = deque->rightblock->data[deque->rightindex];\n    deque->rightindex--;\n    Py_SET_SIZE(deque, Py_SIZE(deque) - 1);\n    deque->state++;\n\n    if (deque->rightindex < 0) {\n        if (Py_SIZE(deque)) {\n            prevblock = deque->rightblock->leftlink;\n            assert(deque->leftblock != deque->rightblock);\n            freeblock(deque, deque->rightblock);\n            CHECK_NOT_END(prevblock);\n            MARK_END(prevblock->rightlink);\n            deque->rightblock = prevblock;\n            deque->rightindex = BLOCKLEN - 1;\n        } else {\n            assert(deque->leftblock == deque->rightblock);\n            assert(deque->leftindex == deque->rightindex+1);\n            /* re-center instead of freeing a block */\n            deque->leftindex = CENTER + 1;\n            deque->rightindex = CENTER;\n        }\n    }\n    return item;\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.popleft as deque_popleft\n\n     deque: dequeobject\n\nRemove and return the leftmost element.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_popleft_impl(dequeobject *deque)\n/*[clinic end generated code: output=62b154897097ff68 input=1571ce88fe3053de]*/\n{\n    PyObject *item;\n    block *prevblock;\n\n    if (Py_SIZE(deque) == 0) {\n        PyErr_SetString(PyExc_IndexError, \"pop from an empty deque\");\n        return NULL;\n    }\n    assert(deque->leftblock != NULL);\n    item = deque->leftblock->data[deque->leftindex];\n    deque->leftindex++;\n    Py_SET_SIZE(deque, Py_SIZE(deque) - 1);\n    deque->state++;\n\n    if (deque->leftindex == BLOCKLEN) {\n        if (Py_SIZE(deque)) {\n            assert(deque->leftblock != deque->rightblock);\n            prevblock = deque->leftblock->rightlink;\n            freeblock(deque, deque->leftblock);\n            CHECK_NOT_END(prevblock);\n            MARK_END(prevblock->leftlink);\n            deque->leftblock = prevblock;\n            deque->leftindex = 0;\n        } else {\n            assert(deque->leftblock == deque->rightblock);\n            assert(deque->leftindex == deque->rightindex+1);\n            /* re-center instead of freeing a block */\n            deque->leftindex = CENTER + 1;\n            deque->rightindex = CENTER;\n        }\n    }\n    return item;\n}\n\n/* The deque's size limit is d.maxlen.  The limit can be zero or positive.\n * If there is no limit, then d.maxlen == -1.\n *\n * After an item is added to a deque, we check to see if the size has\n * grown past the limit. If it has, we get the size back down to the limit\n * by popping an item off of the opposite end.  The methods that can\n * trigger this are append(), appendleft(), extend(), and extendleft().\n *\n * The macro to check whether a deque needs to be trimmed uses a single\n * unsigned test that returns true whenever 0 <= maxlen < Py_SIZE(deque).\n */\n\n#define NEEDS_TRIM(deque, maxlen) ((size_t)(maxlen) < (size_t)(Py_SIZE(deque)))\n\nstatic inline int\ndeque_append_lock_held(dequeobject *deque, PyObject *item, Py_ssize_t maxlen)\n{\n    if (deque->rightindex == BLOCKLEN - 1) {\n        block *b = newblock(deque);\n        if (b == NULL)\n            return -1;\n        b->leftlink = deque->rightblock;\n        CHECK_END(deque->rightblock->rightlink);\n        deque->rightblock->rightlink = b;\n        deque->rightblock = b;\n        MARK_END(b->rightlink);\n        deque->rightindex = -1;\n    }\n    Py_SET_SIZE(deque, Py_SIZE(deque) + 1);\n    deque->rightindex++;\n    deque->rightblock->data[deque->rightindex] = item;\n    if (NEEDS_TRIM(deque, maxlen)) {\n        PyObject *olditem = deque_popleft_impl(deque);\n        Py_DECREF(olditem);\n    } else {\n        deque->state++;\n    }\n    return 0;\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.append as deque_append\n\n    deque: dequeobject\n    item: object\n    /\n\nAdd an element to the right side of the deque.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_append_impl(dequeobject *deque, PyObject *item)\n/*[clinic end generated code: output=9c7bcb8b599c6362 input=b0eeeb09b9f5cf18]*/\n{\n    if (deque_append_lock_held(deque, Py_NewRef(item), deque->maxlen) < 0)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\nstatic inline int\ndeque_appendleft_lock_held(dequeobject *deque, PyObject *item,\n                           Py_ssize_t maxlen)\n{\n    if (deque->leftindex == 0) {\n        block *b = newblock(deque);\n        if (b == NULL)\n            return -1;\n        b->rightlink = deque->leftblock;\n        CHECK_END(deque->leftblock->leftlink);\n        deque->leftblock->leftlink = b;\n        deque->leftblock = b;\n        MARK_END(b->leftlink);\n        deque->leftindex = BLOCKLEN;\n    }\n    Py_SET_SIZE(deque, Py_SIZE(deque) + 1);\n    deque->leftindex--;\n    deque->leftblock->data[deque->leftindex] = item;\n    if (NEEDS_TRIM(deque, maxlen)) {\n        PyObject *olditem = deque_pop_impl(deque);\n        Py_DECREF(olditem);\n    } else {\n        deque->state++;\n    }\n    return 0;\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.appendleft as deque_appendleft\n\n    deque: dequeobject\n    item: object\n    /\n\nAdd an element to the left side of the deque.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_appendleft_impl(dequeobject *deque, PyObject *item)\n/*[clinic end generated code: output=9a192edbcd0f20db input=236c2fbceaf08e14]*/\n{\n    if (deque_appendleft_lock_held(deque, Py_NewRef(item), deque->maxlen) < 0)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\nstatic PyObject*\nfinalize_iterator(PyObject *it)\n{\n    if (PyErr_Occurred()) {\n        if (PyErr_ExceptionMatches(PyExc_StopIteration))\n            PyErr_Clear();\n        else {\n            Py_DECREF(it);\n            return NULL;\n        }\n    }\n    Py_DECREF(it);\n    Py_RETURN_NONE;\n}\n\n/* Run an iterator to exhaustion.  Shortcut for\n   the extend/extendleft methods when maxlen == 0. */\nstatic PyObject*\nconsume_iterator(PyObject *it)\n{\n    PyObject *(*iternext)(PyObject *);\n    PyObject *item;\n\n    iternext = *Py_TYPE(it)->tp_iternext;\n    while ((item = iternext(it)) != NULL) {\n        Py_DECREF(item);\n    }\n    return finalize_iterator(it);\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.extend as deque_extend\n\n    deque: dequeobject\n    iterable: object\n    /\n\nExtend the right side of the deque with elements from the iterable.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_extend_impl(dequeobject *deque, PyObject *iterable)\n/*[clinic end generated code: output=8b5ffa57ce82d980 input=85861954127c81da]*/\n{\n    PyObject *it, *item;\n    PyObject *(*iternext)(PyObject *);\n    Py_ssize_t maxlen = deque->maxlen;\n\n    /* Handle case where id(deque) == id(iterable) */\n    if ((PyObject *)deque == iterable) {\n        PyObject *result;\n        PyObject *s = PySequence_List(iterable);\n        if (s == NULL)\n            return NULL;\n        result = deque_extend(deque, s);\n        Py_DECREF(s);\n        return result;\n    }\n\n    it = PyObject_GetIter(iterable);\n    if (it == NULL)\n        return NULL;\n\n    if (maxlen == 0)\n        return consume_iterator(it);\n\n    /* Space saving heuristic.  Start filling from the left */\n    if (Py_SIZE(deque) == 0) {\n        assert(deque->leftblock == deque->rightblock);\n        assert(deque->leftindex == deque->rightindex+1);\n        deque->leftindex = 1;\n        deque->rightindex = 0;\n    }\n\n    iternext = *Py_TYPE(it)->tp_iternext;\n    while ((item = iternext(it)) != NULL) {\n        if (deque_append_lock_held(deque, item, maxlen) == -1) {\n            Py_DECREF(item);\n            Py_DECREF(it);\n            return NULL;\n        }\n    }\n    return finalize_iterator(it);\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.extendleft as deque_extendleft\n\n    deque: dequeobject\n    iterable: object\n    /\n\nExtend the left side of the deque with elements from the iterable.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_extendleft_impl(dequeobject *deque, PyObject *iterable)\n/*[clinic end generated code: output=ba44191aa8e35a26 input=640dabd086115689]*/\n{\n    PyObject *it, *item;\n    PyObject *(*iternext)(PyObject *);\n    Py_ssize_t maxlen = deque->maxlen;\n\n    /* Handle case where id(deque) == id(iterable) */\n    if ((PyObject *)deque == iterable) {\n        PyObject *result;\n        PyObject *s = PySequence_List(iterable);\n        if (s == NULL)\n            return NULL;\n        result = deque_extendleft_impl(deque, s);\n        Py_DECREF(s);\n        return result;\n    }\n\n    it = PyObject_GetIter(iterable);\n    if (it == NULL)\n        return NULL;\n\n    if (maxlen == 0)\n        return consume_iterator(it);\n\n    /* Space saving heuristic.  Start filling from the right */\n    if (Py_SIZE(deque) == 0) {\n        assert(deque->leftblock == deque->rightblock);\n        assert(deque->leftindex == deque->rightindex+1);\n        deque->leftindex = BLOCKLEN - 1;\n        deque->rightindex = BLOCKLEN - 2;\n    }\n\n    iternext = *Py_TYPE(it)->tp_iternext;\n    while ((item = iternext(it)) != NULL) {\n        if (deque_appendleft_lock_held(deque, item, maxlen) == -1) {\n            Py_DECREF(item);\n            Py_DECREF(it);\n            return NULL;\n        }\n    }\n    return finalize_iterator(it);\n}\n\nstatic PyObject *\ndeque_inplace_concat(dequeobject *deque, PyObject *other)\n{\n    PyObject *result;\n\n    // deque_extend is thread-safe\n    result = deque_extend(deque, other);\n    if (result == NULL)\n        return result;\n    Py_INCREF(deque);\n    Py_DECREF(result);\n    return (PyObject *)deque;\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.copy as deque_copy\n\n    deque: dequeobject\n\nReturn a shallow copy of a deque.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_copy_impl(dequeobject *deque)\n/*[clinic end generated code: output=6409b3d1ad2898b5 input=51d2ed1a23bab5e2]*/\n{\n    PyObject *result;\n    dequeobject *old_deque = (dequeobject *)deque;\n    collections_state *state = find_module_state_by_def(Py_TYPE(deque));\n    if (Py_IS_TYPE(deque, state->deque_type)) {\n        dequeobject *new_deque;\n        PyObject *rv;\n\n        new_deque = (dequeobject *)deque_new(state->deque_type,\n                                             (PyObject *)NULL, (PyObject *)NULL);\n        if (new_deque == NULL)\n            return NULL;\n        new_deque->maxlen = old_deque->maxlen;\n        /* Fast path for the deque_repeat() common case where len(deque) == 1\n         *\n         * It's safe to not acquire the per-object lock for new_deque; it's\n         * invisible to other threads.\n         */\n        if (Py_SIZE(deque) == 1) {\n            PyObject *item = old_deque->leftblock->data[old_deque->leftindex];\n            rv = deque_append_impl(new_deque, item);\n        } else {\n            rv = deque_extend_impl(new_deque, (PyObject *)deque);\n        }\n        if (rv != NULL) {\n            Py_DECREF(rv);\n            return (PyObject *)new_deque;\n        }\n        Py_DECREF(new_deque);\n        return NULL;\n    }\n    if (old_deque->maxlen < 0)\n        result = PyObject_CallOneArg((PyObject *)(Py_TYPE(deque)),\n                                     (PyObject *)deque);\n    else\n        result = PyObject_CallFunction((PyObject *)(Py_TYPE(deque)), \"Oi\",\n                                       deque, old_deque->maxlen, NULL);\n    if (result != NULL && !PyObject_TypeCheck(result, state->deque_type)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"%.200s() must return a deque, not %.200s\",\n                     Py_TYPE(deque)->tp_name, Py_TYPE(result)->tp_name);\n        Py_DECREF(result);\n        return NULL;\n    }\n    return result;\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.__copy__ as deque___copy__ = _collections.deque.copy\n\nReturn a shallow copy of a deque.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque___copy___impl(dequeobject *deque)\n/*[clinic end generated code: output=7c5821504342bf23 input=f5464036f9686a55]*/\n{\n    return deque_copy_impl(deque);\n}\n\nstatic PyObject *\ndeque_concat_lock_held(dequeobject *deque, PyObject *other)\n{\n    PyObject *new_deque, *result;\n    int rv;\n\n    collections_state *state = find_module_state_by_def(Py_TYPE(deque));\n    rv = PyObject_IsInstance(other, (PyObject *)state->deque_type);\n    if (rv <= 0) {\n        if (rv == 0) {\n            PyErr_Format(PyExc_TypeError,\n                         \"can only concatenate deque (not \\\"%.200s\\\") to deque\",\n                         Py_TYPE(other)->tp_name);\n        }\n        return NULL;\n    }\n\n    new_deque = deque_copy_impl(deque);\n    if (new_deque == NULL)\n        return NULL;\n\n    // It's safe to not acquire the per-object lock for new_deque; it's\n    // invisible to other threads.\n    result = deque_extend_impl((dequeobject *)new_deque, other);\n    if (result == NULL) {\n        Py_DECREF(new_deque);\n        return NULL;\n    }\n    Py_DECREF(result);\n    return new_deque;\n}\n\nstatic PyObject *\ndeque_concat(dequeobject *deque, PyObject *other)\n{\n    PyObject *result;\n    Py_BEGIN_CRITICAL_SECTION(deque);\n    result = deque_concat_lock_held(deque, other);\n    Py_END_CRITICAL_SECTION();\n    return result;\n}\n\nstatic int\ndeque_clear(dequeobject *deque)\n{\n    block *b;\n    block *prevblock;\n    block *leftblock;\n    Py_ssize_t leftindex;\n    Py_ssize_t n, m;\n    PyObject *item;\n    PyObject **itemptr, **limit;\n\n    if (Py_SIZE(deque) == 0)\n        return 0;\n\n    /* During the process of clearing a deque, decrefs can cause the\n       deque to mutate.  To avoid fatal confusion, we have to make the\n       deque empty before clearing the blocks and never refer to\n       anything via deque->ref while clearing.  (This is the same\n       technique used for clearing lists, sets, and dicts.)\n\n       Making the deque empty requires allocating a new empty block.  In\n       the unlikely event that memory is full, we fall back to an\n       alternate method that doesn't require a new block.  Repeating\n       pops in a while-loop is slower, possibly re-entrant (and a clever\n       adversary could cause it to never terminate).\n    */\n\n    b = newblock(deque);\n    if (b == NULL) {\n        PyErr_Clear();\n        goto alternate_method;\n    }\n\n    /* Remember the old size, leftblock, and leftindex */\n    n = Py_SIZE(deque);\n    leftblock = deque->leftblock;\n    leftindex = deque->leftindex;\n\n    /* Set the deque to be empty using the newly allocated block */\n    MARK_END(b->leftlink);\n    MARK_END(b->rightlink);\n    Py_SET_SIZE(deque, 0);\n    deque->leftblock = b;\n    deque->rightblock = b;\n    deque->leftindex = CENTER + 1;\n    deque->rightindex = CENTER;\n    deque->state++;\n\n    /* Now the old size, leftblock, and leftindex are disconnected from\n       the empty deque and we can use them to decref the pointers.\n    */\n    m = (BLOCKLEN - leftindex > n) ? n : BLOCKLEN - leftindex;\n    itemptr = &leftblock->data[leftindex];\n    limit = itemptr + m;\n    n -= m;\n    while (1) {\n        if (itemptr == limit) {\n            if (n == 0)\n                break;\n            CHECK_NOT_END(leftblock->rightlink);\n            prevblock = leftblock;\n            leftblock = leftblock->rightlink;\n            m = (n > BLOCKLEN) ? BLOCKLEN : n;\n            itemptr = leftblock->data;\n            limit = itemptr + m;\n            n -= m;\n            freeblock(deque, prevblock);\n        }\n        item = *(itemptr++);\n        Py_DECREF(item);\n    }\n    CHECK_END(leftblock->rightlink);\n    freeblock(deque, leftblock);\n    return 0;\n\n  alternate_method:\n    while (Py_SIZE(deque)) {\n        item = deque_pop_impl(deque);\n        assert (item != NULL);\n        Py_DECREF(item);\n    }\n    return 0;\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.clear as deque_clearmethod\n\n    deque: dequeobject\n\nRemove all elements from the deque.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_clearmethod_impl(dequeobject *deque)\n/*[clinic end generated code: output=79b2513e097615c1 input=3a22e9605d20c5e9]*/\n{\n    deque_clear(deque);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\ndeque_inplace_repeat_lock_held(dequeobject *deque, Py_ssize_t n)\n{\n    Py_ssize_t i, m, size;\n    PyObject *seq;\n    PyObject *rv;\n\n    size = Py_SIZE(deque);\n    if (size == 0 || n == 1) {\n        return Py_NewRef(deque);\n    }\n\n    if (n <= 0) {\n        deque_clear(deque);\n        return Py_NewRef(deque);\n    }\n\n    if (size == 1) {\n        /* common case, repeating a single element */\n        PyObject *item = deque->leftblock->data[deque->leftindex];\n\n        if (deque->maxlen >= 0 && n > deque->maxlen)\n            n = deque->maxlen;\n\n        deque->state++;\n        for (i = 0 ; i < n-1 ; ) {\n            if (deque->rightindex == BLOCKLEN - 1) {\n                block *b = newblock(deque);\n                if (b == NULL) {\n                    Py_SET_SIZE(deque, Py_SIZE(deque) + i);\n                    return NULL;\n                }\n                b->leftlink = deque->rightblock;\n                CHECK_END(deque->rightblock->rightlink);\n                deque->rightblock->rightlink = b;\n                deque->rightblock = b;\n                MARK_END(b->rightlink);\n                deque->rightindex = -1;\n            }\n            m = n - 1 - i;\n            if (m > BLOCKLEN - 1 - deque->rightindex)\n                m = BLOCKLEN - 1 - deque->rightindex;\n            i += m;\n            while (m--) {\n                deque->rightindex++;\n                deque->rightblock->data[deque->rightindex] = Py_NewRef(item);\n            }\n        }\n        Py_SET_SIZE(deque, Py_SIZE(deque) + i);\n        return Py_NewRef(deque);\n    }\n\n    if ((size_t)size > PY_SSIZE_T_MAX / (size_t)n) {\n        return PyErr_NoMemory();\n    }\n\n    seq = PySequence_List((PyObject *)deque);\n    if (seq == NULL)\n        return seq;\n\n    /* Reduce the number of repetitions when maxlen would be exceeded */\n    if (deque->maxlen >= 0 && n * size > deque->maxlen)\n        n = (deque->maxlen + size - 1) / size;\n\n    for (i = 0 ; i < n-1 ; i++) {\n        rv = deque_extend_impl(deque, seq);\n        if (rv == NULL) {\n            Py_DECREF(seq);\n            return NULL;\n        }\n        Py_DECREF(rv);\n    }\n    Py_INCREF(deque);\n    Py_DECREF(seq);\n    return (PyObject *)deque;\n}\n\nstatic PyObject *\ndeque_inplace_repeat(dequeobject *deque, Py_ssize_t n)\n{\n    PyObject *result;\n    Py_BEGIN_CRITICAL_SECTION(deque);\n    result = deque_inplace_repeat_lock_held(deque, n);\n    Py_END_CRITICAL_SECTION();\n    return result;\n}\n\nstatic PyObject *\ndeque_repeat(dequeobject *deque, Py_ssize_t n)\n{\n    dequeobject *new_deque;\n    PyObject *rv;\n\n    Py_BEGIN_CRITICAL_SECTION(deque);\n    new_deque = (dequeobject *)deque_copy_impl(deque);\n    Py_END_CRITICAL_SECTION();\n    if (new_deque == NULL)\n        return NULL;\n    // It's safe to not acquire the per-object lock for new_deque; it's\n    // invisible to other threads.\n    rv = deque_inplace_repeat_lock_held(new_deque, n);\n    Py_DECREF(new_deque);\n    return rv;\n}\n\n/* The rotate() method is part of the public API and is used internally\nas a primitive for other methods.\n\nRotation by 1 or -1 is a common case, so any optimizations for high\nvolume rotations should take care not to penalize the common case.\n\nConceptually, a rotate by one is equivalent to a pop on one side and an\nappend on the other.  However, a pop/append pair is unnecessarily slow\nbecause it requires an incref/decref pair for an object located randomly\nin memory.  It is better to just move the object pointer from one block\nto the next without changing the reference count.\n\nWhen moving batches of pointers, it is tempting to use memcpy() but that\nproved to be slower than a simple loop for a variety of reasons.\nMemcpy() cannot know in advance that we're copying pointers instead of\nbytes, that the source and destination are pointer aligned and\nnon-overlapping, that moving just one pointer is a common case, that we\nnever need to move more than BLOCKLEN pointers, and that at least one\npointer is always moved.\n\nFor high volume rotations, newblock() and freeblock() are never called\nmore than once.  Previously emptied blocks are immediately reused as a\ndestination block.  If a block is left-over at the end, it is freed.\n*/\n\nstatic int\n_deque_rotate(dequeobject *deque, Py_ssize_t n)\n{\n    block *b = NULL;\n    block *leftblock = deque->leftblock;\n    block *rightblock = deque->rightblock;\n    Py_ssize_t leftindex = deque->leftindex;\n    Py_ssize_t rightindex = deque->rightindex;\n    Py_ssize_t len=Py_SIZE(deque), halflen=len>>1;\n    int rv = -1;\n\n    if (len <= 1)\n        return 0;\n    if (n > halflen || n < -halflen) {\n        n %= len;\n        if (n > halflen)\n            n -= len;\n        else if (n < -halflen)\n            n += len;\n    }\n    assert(len > 1);\n    assert(-halflen <= n && n <= halflen);\n\n    deque->state++;\n    while (n > 0) {\n        if (leftindex == 0) {\n            if (b == NULL) {\n                b = newblock(deque);\n                if (b == NULL)\n                    goto done;\n            }\n            b->rightlink = leftblock;\n            CHECK_END(leftblock->leftlink);\n            leftblock->leftlink = b;\n            leftblock = b;\n            MARK_END(b->leftlink);\n            leftindex = BLOCKLEN;\n            b = NULL;\n        }\n        assert(leftindex > 0);\n        {\n            PyObject **src, **dest;\n            Py_ssize_t m = n;\n\n            if (m > rightindex + 1)\n                m = rightindex + 1;\n            if (m > leftindex)\n                m = leftindex;\n            assert (m > 0 && m <= len);\n            rightindex -= m;\n            leftindex -= m;\n            src = &rightblock->data[rightindex + 1];\n            dest = &leftblock->data[leftindex];\n            n -= m;\n            do {\n                *(dest++) = *(src++);\n            } while (--m);\n        }\n        if (rightindex < 0) {\n            assert(leftblock != rightblock);\n            assert(b == NULL);\n            b = rightblock;\n            CHECK_NOT_END(rightblock->leftlink);\n            rightblock = rightblock->leftlink;\n            MARK_END(rightblock->rightlink);\n            rightindex = BLOCKLEN - 1;\n        }\n    }\n    while (n < 0) {\n        if (rightindex == BLOCKLEN - 1) {\n            if (b == NULL) {\n                b = newblock(deque);\n                if (b == NULL)\n                    goto done;\n            }\n            b->leftlink = rightblock;\n            CHECK_END(rightblock->rightlink);\n            rightblock->rightlink = b;\n            rightblock = b;\n            MARK_END(b->rightlink);\n            rightindex = -1;\n            b = NULL;\n        }\n        assert (rightindex < BLOCKLEN - 1);\n        {\n            PyObject **src, **dest;\n            Py_ssize_t m = -n;\n\n            if (m > BLOCKLEN - leftindex)\n                m = BLOCKLEN - leftindex;\n            if (m > BLOCKLEN - 1 - rightindex)\n                m = BLOCKLEN - 1 - rightindex;\n            assert (m > 0 && m <= len);\n            src = &leftblock->data[leftindex];\n            dest = &rightblock->data[rightindex + 1];\n            leftindex += m;\n            rightindex += m;\n            n += m;\n            do {\n                *(dest++) = *(src++);\n            } while (--m);\n        }\n        if (leftindex == BLOCKLEN) {\n            assert(leftblock != rightblock);\n            assert(b == NULL);\n            b = leftblock;\n            CHECK_NOT_END(leftblock->rightlink);\n            leftblock = leftblock->rightlink;\n            MARK_END(leftblock->leftlink);\n            leftindex = 0;\n        }\n    }\n    rv = 0;\ndone:\n    if (b != NULL)\n        freeblock(deque, b);\n    deque->leftblock = leftblock;\n    deque->rightblock = rightblock;\n    deque->leftindex = leftindex;\n    deque->rightindex = rightindex;\n\n    return rv;\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.rotate as deque_rotate\n\n    deque: dequeobject\n    n: Py_ssize_t = 1\n    /\n\nRotate the deque n steps to the right.  If n is negative, rotates left.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_rotate_impl(dequeobject *deque, Py_ssize_t n)\n/*[clinic end generated code: output=96c2402a371eb15d input=5bf834296246e002]*/\n{\n    if (!_deque_rotate(deque, n))\n        Py_RETURN_NONE;\n    return NULL;\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.reverse as deque_reverse\n\n    deque: dequeobject\n\nReverse *IN PLACE*.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_reverse_impl(dequeobject *deque)\n/*[clinic end generated code: output=bdeebc2cf8c1f064 input=26f4167fd623027f]*/\n{\n    block *leftblock = deque->leftblock;\n    block *rightblock = deque->rightblock;\n    Py_ssize_t leftindex = deque->leftindex;\n    Py_ssize_t rightindex = deque->rightindex;\n    Py_ssize_t n = Py_SIZE(deque) >> 1;\n    PyObject *tmp;\n\n    while (--n >= 0) {\n        /* Validate that pointers haven't met in the middle */\n        assert(leftblock != rightblock || leftindex < rightindex);\n        CHECK_NOT_END(leftblock);\n        CHECK_NOT_END(rightblock);\n\n        /* Swap */\n        tmp = leftblock->data[leftindex];\n        leftblock->data[leftindex] = rightblock->data[rightindex];\n        rightblock->data[rightindex] = tmp;\n\n        /* Advance left block/index pair */\n        leftindex++;\n        if (leftindex == BLOCKLEN) {\n            leftblock = leftblock->rightlink;\n            leftindex = 0;\n        }\n\n        /* Step backwards with the right block/index pair */\n        rightindex--;\n        if (rightindex < 0) {\n            rightblock = rightblock->leftlink;\n            rightindex = BLOCKLEN - 1;\n        }\n    }\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.count as deque_count\n\n    deque: dequeobject\n    value as v: object\n    /\n\nReturn number of occurrences of value.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_count_impl(dequeobject *deque, PyObject *v)\n/*[clinic end generated code: output=2ca26c49b6ab0400 input=4ef67ef2b34dc1fc]*/\n{\n    block *b = deque->leftblock;\n    Py_ssize_t index = deque->leftindex;\n    Py_ssize_t n = Py_SIZE(deque);\n    Py_ssize_t count = 0;\n    size_t start_state = deque->state;\n    PyObject *item;\n    int cmp;\n\n    while (--n >= 0) {\n        CHECK_NOT_END(b);\n        item = Py_NewRef(b->data[index]);\n        cmp = PyObject_RichCompareBool(item, v, Py_EQ);\n        Py_DECREF(item);\n        if (cmp < 0)\n            return NULL;\n        count += cmp;\n\n        if (start_state != deque->state) {\n            PyErr_SetString(PyExc_RuntimeError,\n                            \"deque mutated during iteration\");\n            return NULL;\n        }\n\n        /* Advance left block/index pair */\n        index++;\n        if (index == BLOCKLEN) {\n            b = b->rightlink;\n            index = 0;\n        }\n    }\n    return PyLong_FromSsize_t(count);\n}\n\nstatic int\ndeque_contains_lock_held(dequeobject *deque, PyObject *v)\n{\n    block *b = deque->leftblock;\n    Py_ssize_t index = deque->leftindex;\n    Py_ssize_t n = Py_SIZE(deque);\n    size_t start_state = deque->state;\n    PyObject *item;\n    int cmp;\n\n    while (--n >= 0) {\n        CHECK_NOT_END(b);\n        item = Py_NewRef(b->data[index]);\n        cmp = PyObject_RichCompareBool(item, v, Py_EQ);\n        Py_DECREF(item);\n        if (cmp) {\n            return cmp;\n        }\n        if (start_state != deque->state) {\n            PyErr_SetString(PyExc_RuntimeError,\n                            \"deque mutated during iteration\");\n            return -1;\n        }\n        index++;\n        if (index == BLOCKLEN) {\n            b = b->rightlink;\n            index = 0;\n        }\n    }\n    return 0;\n}\n\nstatic int\ndeque_contains(dequeobject *deque, PyObject *v)\n{\n    int result;\n    Py_BEGIN_CRITICAL_SECTION(deque);\n    result = deque_contains_lock_held(deque, v);\n    Py_END_CRITICAL_SECTION();\n    return result;\n}\n\nstatic Py_ssize_t\ndeque_len(dequeobject *deque)\n{\n    return FT_ATOMIC_LOAD_SSIZE(((PyVarObject *)deque)->ob_size);\n}\n\n/*[clinic input]\n@critical_section\n@text_signature \"($self, value, [start, [stop]])\"\n_collections.deque.index as deque_index\n\n    deque: dequeobject\n    value as v: object\n    start: object(converter='_PyEval_SliceIndexNotNone', type='Py_ssize_t', c_default='0') = NULL\n    stop: object(converter='_PyEval_SliceIndexNotNone', type='Py_ssize_t', c_default='Py_SIZE(deque)') = NULL\n    /\n\nReturn first index of value.\n\nRaises ValueError if the value is not present.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_index_impl(dequeobject *deque, PyObject *v, Py_ssize_t start,\n                 Py_ssize_t stop)\n/*[clinic end generated code: output=df45132753175ef9 input=90f48833a91e1743]*/\n{\n    Py_ssize_t i, n;\n    PyObject *item;\n    block *b = deque->leftblock;\n    Py_ssize_t index = deque->leftindex;\n    size_t start_state = deque->state;\n    int cmp;\n\n    if (start < 0) {\n        start += Py_SIZE(deque);\n        if (start < 0)\n            start = 0;\n    }\n    if (stop < 0) {\n        stop += Py_SIZE(deque);\n        if (stop < 0)\n            stop = 0;\n    }\n    if (stop > Py_SIZE(deque))\n        stop = Py_SIZE(deque);\n    if (start > stop)\n        start = stop;\n    assert(0 <= start && start <= stop && stop <= Py_SIZE(deque));\n\n    for (i=0 ; i < start - BLOCKLEN ; i += BLOCKLEN) {\n        b = b->rightlink;\n    }\n    for ( ; i < start ; i++) {\n        index++;\n        if (index == BLOCKLEN) {\n            b = b->rightlink;\n            index = 0;\n        }\n    }\n\n    n = stop - i;\n    while (--n >= 0) {\n        CHECK_NOT_END(b);\n        item = Py_NewRef(b->data[index]);\n        cmp = PyObject_RichCompareBool(item, v, Py_EQ);\n        Py_DECREF(item);\n        if (cmp > 0)\n            return PyLong_FromSsize_t(stop - n - 1);\n        if (cmp < 0)\n            return NULL;\n        if (start_state != deque->state) {\n            PyErr_SetString(PyExc_RuntimeError,\n                            \"deque mutated during iteration\");\n            return NULL;\n        }\n        index++;\n        if (index == BLOCKLEN) {\n            b = b->rightlink;\n            index = 0;\n        }\n    }\n    PyErr_Format(PyExc_ValueError, \"%R is not in deque\", v);\n    return NULL;\n}\n\n/* insert(), remove(), and delitem() are implemented in terms of\n   rotate() for simplicity and reasonable performance near the end\n   points.  If for some reason these methods become popular, it is not\n   hard to re-implement this using direct data movement (similar to\n   the code used in list slice assignments) and achieve a performance\n   boost (by moving each pointer only once instead of twice).\n*/\n\n/*[clinic input]\n@critical_section\n_collections.deque.insert as deque_insert\n\n    deque: dequeobject\n    index: Py_ssize_t\n    value: object\n    /\n\nInsert value before index.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_insert_impl(dequeobject *deque, Py_ssize_t index, PyObject *value)\n/*[clinic end generated code: output=ef4d2c15d5532b80 input=dbee706586cc9cde]*/\n{\n    Py_ssize_t n = Py_SIZE(deque);\n    PyObject *rv;\n\n    if (deque->maxlen == Py_SIZE(deque)) {\n        PyErr_SetString(PyExc_IndexError, \"deque already at its maximum size\");\n        return NULL;\n    }\n    if (index >= n)\n        return deque_append_impl(deque, value);\n    if (index <= -n || index == 0)\n        return deque_appendleft_impl(deque, value);\n    if (_deque_rotate(deque, -index))\n        return NULL;\n    if (index < 0)\n        rv = deque_append_impl(deque, value);\n    else\n        rv = deque_appendleft_impl(deque, value);\n    if (rv == NULL)\n        return NULL;\n    Py_DECREF(rv);\n    if (_deque_rotate(deque, index))\n        return NULL;\n    Py_RETURN_NONE;\n}\n\nstatic int\nvalid_index(Py_ssize_t i, Py_ssize_t limit)\n{\n    /* The cast to size_t lets us use just a single comparison\n       to check whether i is in the range: 0 <= i < limit */\n    return (size_t) i < (size_t) limit;\n}\n\nstatic PyObject *\ndeque_item_lock_held(dequeobject *deque, Py_ssize_t i)\n{\n    block *b;\n    PyObject *item;\n    Py_ssize_t n, index=i;\n\n    if (!valid_index(i, Py_SIZE(deque))) {\n        PyErr_SetString(PyExc_IndexError, \"deque index out of range\");\n        return NULL;\n    }\n\n    if (i == 0) {\n        i = deque->leftindex;\n        b = deque->leftblock;\n    } else if (i == Py_SIZE(deque) - 1) {\n        i = deque->rightindex;\n        b = deque->rightblock;\n    } else {\n        i += deque->leftindex;\n        n = (Py_ssize_t)((size_t) i / BLOCKLEN);\n        i = (Py_ssize_t)((size_t) i % BLOCKLEN);\n        if (index < (Py_SIZE(deque) >> 1)) {\n            b = deque->leftblock;\n            while (--n >= 0)\n                b = b->rightlink;\n        } else {\n            n = (Py_ssize_t)(\n                    ((size_t)(deque->leftindex + Py_SIZE(deque) - 1))\n                    / BLOCKLEN - n);\n            b = deque->rightblock;\n            while (--n >= 0)\n                b = b->leftlink;\n        }\n    }\n    item = b->data[i];\n    return Py_NewRef(item);\n}\n\nstatic PyObject *\ndeque_item(dequeobject *deque, Py_ssize_t i)\n{\n    PyObject *result;\n    Py_BEGIN_CRITICAL_SECTION(deque);\n    result = deque_item_lock_held(deque, i);\n    Py_END_CRITICAL_SECTION();\n    return result;\n}\n\nstatic int\ndeque_del_item(dequeobject *deque, Py_ssize_t i)\n{\n    PyObject *item;\n    int rv;\n\n    assert (i >= 0 && i < Py_SIZE(deque));\n    if (_deque_rotate(deque, -i))\n        return -1;\n    item = deque_popleft_impl(deque);\n    rv = _deque_rotate(deque, i);\n    assert (item != NULL);\n    Py_DECREF(item);\n    return rv;\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.remove as deque_remove\n\n    deque: dequeobject\n    value: object\n    /\n\nRemove first occurrence of value.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque_remove_impl(dequeobject *deque, PyObject *value)\n/*[clinic end generated code: output=54cff28b8ef78c5b input=60eb3f8aa4de532a]*/\n{\n    PyObject *item;\n    block *b = deque->leftblock;\n    Py_ssize_t i, n = Py_SIZE(deque), index = deque->leftindex;\n    size_t start_state = deque->state;\n    int cmp, rv;\n\n    for (i = 0 ; i < n; i++) {\n        item = Py_NewRef(b->data[index]);\n        cmp = PyObject_RichCompareBool(item, value, Py_EQ);\n        Py_DECREF(item);\n        if (cmp < 0) {\n            return NULL;\n        }\n        if (start_state != deque->state) {\n            PyErr_SetString(PyExc_IndexError,\n                            \"deque mutated during iteration\");\n            return NULL;\n        }\n        if (cmp > 0) {\n            break;\n        }\n        index++;\n        if (index == BLOCKLEN) {\n            b = b->rightlink;\n            index = 0;\n        }\n    }\n    if (i == n) {\n        PyErr_Format(PyExc_ValueError, \"%R is not in deque\", value);\n        return NULL;\n    }\n    rv = deque_del_item(deque, i);\n    if (rv == -1) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nstatic int\ndeque_ass_item_lock_held(dequeobject *deque, Py_ssize_t i, PyObject *v)\n{\n    block *b;\n    Py_ssize_t n, len=Py_SIZE(deque), halflen=(len+1)>>1, index=i;\n\n    if (!valid_index(i, len)) {\n        PyErr_SetString(PyExc_IndexError, \"deque index out of range\");\n        return -1;\n    }\n    if (v == NULL)\n        return deque_del_item(deque, i);\n\n    i += deque->leftindex;\n    n = (Py_ssize_t)((size_t) i / BLOCKLEN);\n    i = (Py_ssize_t)((size_t) i % BLOCKLEN);\n    if (index <= halflen) {\n        b = deque->leftblock;\n        while (--n >= 0)\n            b = b->rightlink;\n    } else {\n        n = (Py_ssize_t)(\n                ((size_t)(deque->leftindex + Py_SIZE(deque) - 1))\n                / BLOCKLEN - n);\n        b = deque->rightblock;\n        while (--n >= 0)\n            b = b->leftlink;\n    }\n    Py_SETREF(b->data[i], Py_NewRef(v));\n    return 0;\n}\n\nstatic int\ndeque_ass_item(dequeobject *deque, Py_ssize_t i, PyObject *v)\n{\n    int result;\n    Py_BEGIN_CRITICAL_SECTION(deque);\n    result = deque_ass_item_lock_held(deque, i, v);\n    Py_END_CRITICAL_SECTION();\n    return result;\n}\n\nstatic void\ndeque_dealloc(dequeobject *deque)\n{\n    PyTypeObject *tp = Py_TYPE(deque);\n    Py_ssize_t i;\n\n    PyObject_GC_UnTrack(deque);\n    if (deque->weakreflist != NULL)\n        PyObject_ClearWeakRefs((PyObject *) deque);\n    if (deque->leftblock != NULL) {\n        deque_clear(deque);\n        assert(deque->leftblock != NULL);\n        freeblock(deque, deque->leftblock);\n    }\n    deque->leftblock = NULL;\n    deque->rightblock = NULL;\n    for (i=0 ; i < deque->numfreeblocks ; i++) {\n        PyMem_Free(deque->freeblocks[i]);\n    }\n    tp->tp_free(deque);\n    Py_DECREF(tp);\n}\n\nstatic int\ndeque_traverse(dequeobject *deque, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(deque));\n\n    block *b;\n    PyObject *item;\n    Py_ssize_t index;\n    Py_ssize_t indexlo = deque->leftindex;\n    Py_ssize_t indexhigh;\n\n    for (b = deque->leftblock; b != deque->rightblock; b = b->rightlink) {\n        for (index = indexlo; index < BLOCKLEN ; index++) {\n            item = b->data[index];\n            Py_VISIT(item);\n        }\n        indexlo = 0;\n    }\n    indexhigh = deque->rightindex;\n    for (index = indexlo; index <= indexhigh; index++) {\n        item = b->data[index];\n        Py_VISIT(item);\n    }\n    return 0;\n}\n\n/*[clinic input]\n_collections.deque.__reduce__ as deque___reduce__\n\n    deque: dequeobject\n\nReturn state information for pickling.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque___reduce___impl(dequeobject *deque)\n/*[clinic end generated code: output=cb85d9e0b7d2c5ad input=991a933a5bc7a526]*/\n{\n    PyObject *state, *it;\n\n    state = _PyObject_GetState((PyObject *)deque);\n    if (state == NULL) {\n        return NULL;\n    }\n\n    it = PyObject_GetIter((PyObject *)deque);\n    if (it == NULL) {\n        Py_DECREF(state);\n        return NULL;\n    }\n\n    // It's safe to access deque->maxlen here without holding the per object\n    // lock for deque; deque->maxlen is only assigned during construction.\n    if (deque->maxlen < 0) {\n        return Py_BuildValue(\"O()NN\", Py_TYPE(deque), state, it);\n    }\n    else {\n        return Py_BuildValue(\"O(()n)NN\", Py_TYPE(deque), deque->maxlen, state, it);\n    }\n}\n\nPyDoc_STRVAR(reduce_doc, \"Return state information for pickling.\");\n\nstatic PyObject *\ndeque_repr(PyObject *deque)\n{\n    PyObject *aslist, *result;\n    int i;\n\n    i = Py_ReprEnter(deque);\n    if (i != 0) {\n        if (i < 0)\n            return NULL;\n        return PyUnicode_FromString(\"[...]\");\n    }\n\n    aslist = PySequence_List(deque);\n    if (aslist == NULL) {\n        Py_ReprLeave(deque);\n        return NULL;\n    }\n    if (((dequeobject *)deque)->maxlen >= 0)\n        result = PyUnicode_FromFormat(\"%s(%R, maxlen=%zd)\",\n                                      _PyType_Name(Py_TYPE(deque)), aslist,\n                                      ((dequeobject *)deque)->maxlen);\n    else\n        result = PyUnicode_FromFormat(\"%s(%R)\",\n                                      _PyType_Name(Py_TYPE(deque)), aslist);\n    Py_ReprLeave(deque);\n    Py_DECREF(aslist);\n    return result;\n}\n\nstatic PyObject *\ndeque_richcompare(PyObject *v, PyObject *w, int op)\n{\n    PyObject *it1=NULL, *it2=NULL, *x, *y;\n    Py_ssize_t vs, ws;\n    int b, cmp=-1;\n\n    collections_state *state = find_module_state_by_def(Py_TYPE(v));\n    if (!PyObject_TypeCheck(v, state->deque_type) ||\n        !PyObject_TypeCheck(w, state->deque_type)) {\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n\n    /* Shortcuts */\n    vs = Py_SIZE((dequeobject *)v);\n    ws = Py_SIZE((dequeobject *)w);\n    if (op == Py_EQ) {\n        if (v == w)\n            Py_RETURN_TRUE;\n        if (vs != ws)\n            Py_RETURN_FALSE;\n    }\n    if (op == Py_NE) {\n        if (v == w)\n            Py_RETURN_FALSE;\n        if (vs != ws)\n            Py_RETURN_TRUE;\n    }\n\n    /* Search for the first index where items are different */\n    it1 = PyObject_GetIter(v);\n    if (it1 == NULL)\n        goto done;\n    it2 = PyObject_GetIter(w);\n    if (it2 == NULL)\n        goto done;\n    for (;;) {\n        x = PyIter_Next(it1);\n        if (x == NULL && PyErr_Occurred())\n            goto done;\n        y = PyIter_Next(it2);\n        if (x == NULL || y == NULL)\n            break;\n        b = PyObject_RichCompareBool(x, y, Py_EQ);\n        if (b == 0) {\n            cmp = PyObject_RichCompareBool(x, y, op);\n            Py_DECREF(x);\n            Py_DECREF(y);\n            goto done;\n        }\n        Py_DECREF(x);\n        Py_DECREF(y);\n        if (b < 0)\n            goto done;\n    }\n    /* We reached the end of one deque or both */\n    Py_XDECREF(x);\n    Py_XDECREF(y);\n    if (PyErr_Occurred())\n        goto done;\n    switch (op) {\n    case Py_LT: cmp = y != NULL; break;  /* if w was longer */\n    case Py_LE: cmp = x == NULL; break;  /* if v was not longer */\n    case Py_EQ: cmp = x == y;    break;  /* if we reached the end of both */\n    case Py_NE: cmp = x != y;    break;  /* if one deque continues */\n    case Py_GT: cmp = x != NULL; break;  /* if v was longer */\n    case Py_GE: cmp = y == NULL; break;  /* if w was not longer */\n    }\n\ndone:\n    Py_XDECREF(it1);\n    Py_XDECREF(it2);\n    if (cmp == 1)\n        Py_RETURN_TRUE;\n    if (cmp == 0)\n        Py_RETURN_FALSE;\n    return NULL;\n}\n\n/*[clinic input]\n@critical_section\n@text_signature \"([iterable[, maxlen]])\"\n_collections.deque.__init__ as deque_init\n\n    deque: dequeobject\n    iterable: object = NULL\n    maxlen as maxlenobj: object = NULL\n\nA list-like sequence optimized for data accesses near its endpoints.\n[clinic start generated code]*/\n\nstatic int\ndeque_init_impl(dequeobject *deque, PyObject *iterable, PyObject *maxlenobj)\n/*[clinic end generated code: output=7084a39d71218dcd input=2b9e37af1fd73143]*/\n{\n    Py_ssize_t maxlen = -1;\n    if (maxlenobj != NULL && maxlenobj != Py_None) {\n        maxlen = PyLong_AsSsize_t(maxlenobj);\n        if (maxlen == -1 && PyErr_Occurred())\n            return -1;\n        if (maxlen < 0) {\n            PyErr_SetString(PyExc_ValueError, \"maxlen must be non-negative\");\n            return -1;\n        }\n    }\n    deque->maxlen = maxlen;\n    if (Py_SIZE(deque) > 0)\n        deque_clear(deque);\n    if (iterable != NULL) {\n        PyObject *rv = deque_extend_impl(deque, iterable);\n        if (rv == NULL)\n            return -1;\n        Py_DECREF(rv);\n    }\n    return 0;\n}\n\n/*[clinic input]\n@critical_section\n_collections.deque.__sizeof__ as deque___sizeof__\n\n    deque: dequeobject\n\nReturn the size of the deque in memory, in bytes.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque___sizeof___impl(dequeobject *deque)\n/*[clinic end generated code: output=4d36e9fb4f30bbaf input=762312f2d4813535]*/\n{\n    size_t res = _PyObject_SIZE(Py_TYPE(deque));\n    size_t blocks;\n    blocks = (size_t)(deque->leftindex + Py_SIZE(deque) + BLOCKLEN - 1) / BLOCKLEN;\n    assert(((size_t)deque->leftindex + (size_t)Py_SIZE(deque) - 1) ==\n           ((blocks - 1) * BLOCKLEN + (size_t)deque->rightindex));\n    res += blocks * sizeof(block);\n    return PyLong_FromSize_t(res);\n}\n\nstatic PyObject *\ndeque_get_maxlen(dequeobject *deque, void *Py_UNUSED(ignored))\n{\n    if (deque->maxlen < 0)\n        Py_RETURN_NONE;\n    return PyLong_FromSsize_t(deque->maxlen);\n}\n\nstatic PyObject *deque_reviter(dequeobject *deque);\n\n/*[clinic input]\n_collections.deque.__reversed__ as deque___reversed__\n\n    deque: dequeobject\n\nReturn a reverse iterator over the deque.\n[clinic start generated code]*/\n\nstatic PyObject *\ndeque___reversed___impl(dequeobject *deque)\n/*[clinic end generated code: output=3e7e7e715883cf2e input=3d494c25a6fe5c7e]*/\n{\n    return deque_reviter(deque);\n}\n\n/* deque object ********************************************************/\n\nstatic PyGetSetDef deque_getset[] = {\n    {\"maxlen\", (getter)deque_get_maxlen, (setter)NULL,\n     \"maximum size of a deque or None if unbounded\"},\n    {0}\n};\n\nstatic PyObject *deque_iter(dequeobject *deque);\n\nstatic PyMethodDef deque_methods[] = {\n    DEQUE_APPEND_METHODDEF\n    DEQUE_APPENDLEFT_METHODDEF\n    DEQUE_CLEARMETHOD_METHODDEF\n    DEQUE___COPY___METHODDEF\n    DEQUE_COPY_METHODDEF\n    DEQUE_COUNT_METHODDEF\n    DEQUE_EXTEND_METHODDEF\n    DEQUE_EXTENDLEFT_METHODDEF\n    DEQUE_INDEX_METHODDEF\n    DEQUE_INSERT_METHODDEF\n    DEQUE_POP_METHODDEF\n    DEQUE_POPLEFT_METHODDEF\n    DEQUE___REDUCE___METHODDEF\n    DEQUE_REMOVE_METHODDEF\n    DEQUE___REVERSED___METHODDEF\n    DEQUE_REVERSE_METHODDEF\n    DEQUE_ROTATE_METHODDEF\n    DEQUE___SIZEOF___METHODDEF\n    {\"__class_getitem__\",       Py_GenericAlias,\n        METH_O|METH_CLASS,       PyDoc_STR(\"See PEP 585\")},\n    {NULL,              NULL}   /* sentinel */\n};\n\nstatic PyMemberDef deque_members[] = {\n    {\"__weaklistoffset__\", Py_T_PYSSIZET, offsetof(dequeobject, weakreflist), Py_READONLY},\n    {NULL},\n};\n\nstatic PyType_Slot deque_slots[] = {\n    {Py_tp_dealloc, deque_dealloc},\n    {Py_tp_repr, deque_repr},\n    {Py_tp_hash, PyObject_HashNotImplemented},\n    {Py_tp_getattro, PyObject_GenericGetAttr},\n    {Py_tp_doc, (void *)deque_init__doc__},\n    {Py_tp_traverse, deque_traverse},\n    {Py_tp_clear, deque_clear},\n    {Py_tp_richcompare, deque_richcompare},\n    {Py_tp_iter, deque_iter},\n    {Py_tp_getset, deque_getset},\n    {Py_tp_init, deque_init},\n    {Py_tp_alloc, PyType_GenericAlloc},\n    {Py_tp_new, deque_new},\n    {Py_tp_free, PyObject_GC_Del},\n    {Py_tp_methods, deque_methods},\n    {Py_tp_members, deque_members},\n\n    // Sequence protocol\n    {Py_sq_length, deque_len},\n    {Py_sq_concat, deque_concat},\n    {Py_sq_repeat, deque_repeat},\n    {Py_sq_item, deque_item},\n    {Py_sq_ass_item, deque_ass_item},\n    {Py_sq_contains, deque_contains},\n    {Py_sq_inplace_concat, deque_inplace_concat},\n    {Py_sq_inplace_repeat, deque_inplace_repeat},\n    {0, NULL},\n};\n\nstatic PyType_Spec deque_spec = {\n    .name = \"collections.deque\",\n    .basicsize = sizeof(dequeobject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n              Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SEQUENCE |\n              Py_TPFLAGS_IMMUTABLETYPE),\n    .slots = deque_slots,\n};\n\n/*********************** Deque Iterator **************************/\n\ntypedef struct {\n    PyObject_HEAD\n    block *b;\n    Py_ssize_t index;\n    dequeobject *deque;\n    size_t state;          /* state when the iterator is created */\n    Py_ssize_t counter;    /* number of items remaining for iteration */\n} dequeiterobject;\n\nstatic PyObject *\ndeque_iter(dequeobject *deque)\n{\n    dequeiterobject *it;\n\n    collections_state *state = find_module_state_by_def(Py_TYPE(deque));\n    it = PyObject_GC_New(dequeiterobject, state->dequeiter_type);\n    if (it == NULL)\n        return NULL;\n    Py_BEGIN_CRITICAL_SECTION(deque);\n    it->b = deque->leftblock;\n    it->index = deque->leftindex;\n    it->deque = (dequeobject*)Py_NewRef(deque);\n    it->state = deque->state;\n    it->counter = Py_SIZE(deque);\n    Py_END_CRITICAL_SECTION();\n    PyObject_GC_Track(it);\n    return (PyObject *)it;\n}\n\nstatic int\ndequeiter_traverse(dequeiterobject *dio, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(dio));\n    Py_VISIT(dio->deque);\n    return 0;\n}\n\nstatic int\ndequeiter_clear(dequeiterobject *dio)\n{\n    Py_CLEAR(dio->deque);\n    return 0;\n}\n\nstatic void\ndequeiter_dealloc(dequeiterobject *dio)\n{\n    /* bpo-31095: UnTrack is needed before calling any callbacks */\n    PyTypeObject *tp = Py_TYPE(dio);\n    PyObject_GC_UnTrack(dio);\n    (void)dequeiter_clear(dio);\n    PyObject_GC_Del(dio);\n    Py_DECREF(tp);\n}\n\nstatic PyObject *\ndequeiter_next_lock_held(dequeiterobject *it, dequeobject *deque)\n{\n    PyObject *item;\n\n    if (it->deque->state != it->state) {\n        it->counter = 0;\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"deque mutated during iteration\");\n        return NULL;\n    }\n    if (it->counter == 0)\n        return NULL;\n    assert (!(it->b == it->deque->rightblock &&\n              it->index > it->deque->rightindex));\n\n    item = it->b->data[it->index];\n    it->index++;\n    it->counter--;\n    if (it->index == BLOCKLEN && it->counter > 0) {\n        CHECK_NOT_END(it->b->rightlink);\n        it->b = it->b->rightlink;\n        it->index = 0;\n    }\n    return Py_NewRef(item);\n}\n\nstatic PyObject *\ndequeiter_next(dequeiterobject *it)\n{\n    PyObject *result;\n    // It's safe to access it->deque without holding the per-object lock for it\n    // here; it->deque is only assigned during construction of it.\n    dequeobject *deque = it->deque;\n    Py_BEGIN_CRITICAL_SECTION2(it, deque);\n    result = dequeiter_next_lock_held(it, deque);\n    Py_END_CRITICAL_SECTION2();\n\n    return result;\n}\n\nstatic PyObject *\ndequeiter_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    Py_ssize_t i, index=0;\n    PyObject *deque;\n    dequeiterobject *it;\n    collections_state *state = get_module_state_by_cls(type);\n    if (!PyArg_ParseTuple(args, \"O!|n\", state->deque_type, &deque, &index))\n        return NULL;\n    assert(type == state->dequeiter_type);\n\n    it = (dequeiterobject*)deque_iter((dequeobject *)deque);\n    if (!it)\n        return NULL;\n    /* consume items from the queue */\n    for(i=0; i<index; i++) {\n        PyObject *item = dequeiter_next(it);\n        if (item) {\n            Py_DECREF(item);\n        } else {\n            /*\n             * It's safe to read directly from it without acquiring the\n             * per-object lock; the iterator isn't visible to any other threads\n             * yet.\n             */\n            if (it->counter) {\n                Py_DECREF(it);\n                return NULL;\n            } else\n                break;\n        }\n    }\n    return (PyObject*)it;\n}\n\nstatic PyObject *\ndequeiter_len(dequeiterobject *it, PyObject *Py_UNUSED(ignored))\n{\n    Py_ssize_t len = FT_ATOMIC_LOAD_SSIZE(it->counter);\n    return PyLong_FromSsize_t(len);\n}\n\nPyDoc_STRVAR(length_hint_doc, \"Private method returning an estimate of len(list(it)).\");\n\nstatic PyObject *\ndequeiter_reduce(dequeiterobject *it, PyObject *Py_UNUSED(ignored))\n{\n    PyTypeObject *ty = Py_TYPE(it);\n    // It's safe to access it->deque without holding the per-object lock for it\n    // here; it->deque is only assigned during construction of it.\n    dequeobject *deque = it->deque;\n    Py_ssize_t size, counter;\n    Py_BEGIN_CRITICAL_SECTION2(it, deque);\n    size = Py_SIZE(deque);\n    counter = it->counter;\n    Py_END_CRITICAL_SECTION2();\n    return Py_BuildValue(\"O(On)\", ty, deque, size - counter);\n}\n\nstatic PyMethodDef dequeiter_methods[] = {\n    {\"__length_hint__\", (PyCFunction)dequeiter_len, METH_NOARGS, length_hint_doc},\n    {\"__reduce__\", (PyCFunction)dequeiter_reduce, METH_NOARGS, reduce_doc},\n    {NULL,              NULL}           /* sentinel */\n};\n\nstatic PyType_Slot dequeiter_slots[] = {\n    {Py_tp_dealloc, dequeiter_dealloc},\n    {Py_tp_getattro, PyObject_GenericGetAttr},\n    {Py_tp_traverse, dequeiter_traverse},\n    {Py_tp_clear, dequeiter_clear},\n    {Py_tp_iter, PyObject_SelfIter},\n    {Py_tp_iternext, dequeiter_next},\n    {Py_tp_methods, dequeiter_methods},\n    {Py_tp_new, dequeiter_new},\n    {0, NULL},\n};\n\nstatic PyType_Spec dequeiter_spec = {\n    .name = \"collections._deque_iterator\",\n    .basicsize = sizeof(dequeiterobject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n              Py_TPFLAGS_IMMUTABLETYPE),\n    .slots = dequeiter_slots,\n};\n\n/*********************** Deque Reverse Iterator **************************/\n\nstatic PyObject *\ndeque_reviter(dequeobject *deque)\n{\n    dequeiterobject *it;\n    collections_state *state = find_module_state_by_def(Py_TYPE(deque));\n\n    it = PyObject_GC_New(dequeiterobject, state->dequereviter_type);\n    if (it == NULL)\n        return NULL;\n    Py_BEGIN_CRITICAL_SECTION(deque);\n    it->b = deque->rightblock;\n    it->index = deque->rightindex;\n    it->deque = (dequeobject*)Py_NewRef(deque);\n    it->state = deque->state;\n    it->counter = Py_SIZE(deque);\n    Py_END_CRITICAL_SECTION();\n    PyObject_GC_Track(it);\n    return (PyObject *)it;\n}\n\nstatic PyObject *\ndequereviter_next_lock_held(dequeiterobject *it, dequeobject *deque)\n{\n    PyObject *item;\n    if (it->counter == 0)\n        return NULL;\n\n    if (it->deque->state != it->state) {\n        it->counter = 0;\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"deque mutated during iteration\");\n        return NULL;\n    }\n    assert (!(it->b == it->deque->leftblock &&\n              it->index < it->deque->leftindex));\n\n    item = it->b->data[it->index];\n    it->index--;\n    it->counter--;\n    if (it->index < 0 && it->counter > 0) {\n        CHECK_NOT_END(it->b->leftlink);\n        it->b = it->b->leftlink;\n        it->index = BLOCKLEN - 1;\n    }\n    return Py_NewRef(item);\n}\n\nstatic PyObject *\ndequereviter_next(dequeiterobject *it)\n{\n    PyObject *item;\n    // It's safe to access it->deque without holding the per-object lock for it\n    // here; it->deque is only assigned during construction of it.\n    dequeobject *deque = it->deque;\n    Py_BEGIN_CRITICAL_SECTION2(it, deque);\n    item = dequereviter_next_lock_held(it, deque);\n    Py_END_CRITICAL_SECTION2();\n    return item;\n}\n\nstatic PyObject *\ndequereviter_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    Py_ssize_t i, index=0;\n    PyObject *deque;\n    dequeiterobject *it;\n    collections_state *state = get_module_state_by_cls(type);\n    if (!PyArg_ParseTuple(args, \"O!|n\", state->deque_type, &deque, &index))\n        return NULL;\n    assert(type == state->dequereviter_type);\n\n    it = (dequeiterobject *)deque_reviter((dequeobject *)deque);\n    if (!it)\n        return NULL;\n    /* consume items from the queue */\n    for(i=0; i<index; i++) {\n        PyObject *item = dequereviter_next(it);\n        if (item) {\n            Py_DECREF(item);\n        } else {\n            /*\n             * It's safe to read directly from it without acquiring the\n             * per-object lock; the iterator isn't visible to any other threads\n             * yet.\n             */\n            if (it->counter) {\n                Py_DECREF(it);\n                return NULL;\n            } else\n                break;\n        }\n    }\n    return (PyObject*)it;\n}\n\nstatic PyType_Slot dequereviter_slots[] = {\n    {Py_tp_dealloc, dequeiter_dealloc},\n    {Py_tp_getattro, PyObject_GenericGetAttr},\n    {Py_tp_traverse, dequeiter_traverse},\n    {Py_tp_clear, dequeiter_clear},\n    {Py_tp_iter, PyObject_SelfIter},\n    {Py_tp_iternext, dequereviter_next},\n    {Py_tp_methods, dequeiter_methods},\n    {Py_tp_new, dequereviter_new},\n    {0, NULL},\n};\n\nstatic PyType_Spec dequereviter_spec = {\n    .name = \"collections._deque_reverse_iterator\",\n    .basicsize = sizeof(dequeiterobject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n              Py_TPFLAGS_IMMUTABLETYPE),\n    .slots = dequereviter_slots,\n};\n\n/* defaultdict type *********************************************************/\n\ntypedef struct {\n    PyDictObject dict;\n    PyObject *default_factory;\n} defdictobject;\n\nPyDoc_STRVAR(defdict_missing_doc,\n\"__missing__(key) # Called by __getitem__ for missing key; pseudo-code:\\n\\\n  if self.default_factory is None: raise KeyError((key,))\\n\\\n  self[key] = value = self.default_factory()\\n\\\n  return value\\n\\\n\");\n\nstatic PyObject *\ndefdict_missing(defdictobject *dd, PyObject *key)\n{\n    PyObject *factory = dd->default_factory;\n    PyObject *value;\n    if (factory == NULL || factory == Py_None) {\n        /* XXX Call dict.__missing__(key) */\n        PyObject *tup;\n        tup = PyTuple_Pack(1, key);\n        if (!tup) return NULL;\n        PyErr_SetObject(PyExc_KeyError, tup);\n        Py_DECREF(tup);\n        return NULL;\n    }\n    value = _PyObject_CallNoArgs(factory);\n    if (value == NULL)\n        return value;\n    if (PyObject_SetItem((PyObject *)dd, key, value) < 0) {\n        Py_DECREF(value);\n        return NULL;\n    }\n    return value;\n}\n\nstatic inline PyObject*\nnew_defdict(defdictobject *dd, PyObject *arg)\n{\n    return PyObject_CallFunctionObjArgs((PyObject*)Py_TYPE(dd),\n        dd->default_factory ? dd->default_factory : Py_None, arg, NULL);\n}\n\nPyDoc_STRVAR(defdict_copy_doc, \"D.copy() -> a shallow copy of D.\");\n\nstatic PyObject *\ndefdict_copy(defdictobject *dd, PyObject *Py_UNUSED(ignored))\n{\n    /* This calls the object's class.  That only works for subclasses\n       whose class constructor has the same signature.  Subclasses that\n       define a different constructor signature must override copy().\n    */\n    return new_defdict(dd, (PyObject*)dd);\n}\n\nstatic PyObject *\ndefdict_reduce(defdictobject *dd, PyObject *Py_UNUSED(ignored))\n{\n    /* __reduce__ must return a 5-tuple as follows:\n\n       - factory function\n       - tuple of args for the factory function\n       - additional state (here None)\n       - sequence iterator (here None)\n       - dictionary iterator (yielding successive (key, value) pairs\n\n       This API is used by pickle.py and copy.py.\n\n       For this to be useful with pickle.py, the default_factory\n       must be picklable; e.g., None, a built-in, or a global\n       function in a module or package.\n\n       Both shallow and deep copying are supported, but for deep\n       copying, the default_factory must be deep-copyable; e.g. None,\n       or a built-in (functions are not copyable at this time).\n\n       This only works for subclasses as long as their constructor\n       signature is compatible; the first argument must be the\n       optional default_factory, defaulting to None.\n    */\n    PyObject *args;\n    PyObject *items;\n    PyObject *iter;\n    PyObject *result;\n\n    if (dd->default_factory == NULL || dd->default_factory == Py_None)\n        args = PyTuple_New(0);\n    else\n        args = PyTuple_Pack(1, dd->default_factory);\n    if (args == NULL)\n        return NULL;\n    items = PyObject_CallMethodNoArgs((PyObject *)dd, &_Py_ID(items));\n    if (items == NULL) {\n        Py_DECREF(args);\n        return NULL;\n    }\n    iter = PyObject_GetIter(items);\n    if (iter == NULL) {\n        Py_DECREF(items);\n        Py_DECREF(args);\n        return NULL;\n    }\n    result = PyTuple_Pack(5, Py_TYPE(dd), args,\n                          Py_None, Py_None, iter);\n    Py_DECREF(iter);\n    Py_DECREF(items);\n    Py_DECREF(args);\n    return result;\n}\n\nstatic PyMethodDef defdict_methods[] = {\n    {\"__missing__\", (PyCFunction)defdict_missing, METH_O,\n     defdict_missing_doc},\n    {\"copy\", (PyCFunction)defdict_copy, METH_NOARGS,\n     defdict_copy_doc},\n    {\"__copy__\", (PyCFunction)defdict_copy, METH_NOARGS,\n     defdict_copy_doc},\n    {\"__reduce__\", (PyCFunction)defdict_reduce, METH_NOARGS,\n     reduce_doc},\n    {\"__class_getitem__\", Py_GenericAlias, METH_O|METH_CLASS,\n     PyDoc_STR(\"See PEP 585\")},\n    {NULL}\n};\n\nstatic PyMemberDef defdict_members[] = {\n    {\"default_factory\", _Py_T_OBJECT,\n     offsetof(defdictobject, default_factory), 0,\n     PyDoc_STR(\"Factory for default value called by __missing__().\")},\n    {NULL}\n};\n\nstatic void\ndefdict_dealloc(defdictobject *dd)\n{\n    /* bpo-31095: UnTrack is needed before calling any callbacks */\n    PyTypeObject *tp = Py_TYPE(dd);\n    PyObject_GC_UnTrack(dd);\n    Py_CLEAR(dd->default_factory);\n    PyDict_Type.tp_dealloc((PyObject *)dd);\n    Py_DECREF(tp);\n}\n\nstatic PyObject *\ndefdict_repr(defdictobject *dd)\n{\n    PyObject *baserepr;\n    PyObject *defrepr;\n    PyObject *result;\n    baserepr = PyDict_Type.tp_repr((PyObject *)dd);\n    if (baserepr == NULL)\n        return NULL;\n    if (dd->default_factory == NULL)\n        defrepr = PyUnicode_FromString(\"None\");\n    else\n    {\n        int status = Py_ReprEnter(dd->default_factory);\n        if (status != 0) {\n            if (status < 0) {\n                Py_DECREF(baserepr);\n                return NULL;\n            }\n            defrepr = PyUnicode_FromString(\"...\");\n        }\n        else\n            defrepr = PyObject_Repr(dd->default_factory);\n        Py_ReprLeave(dd->default_factory);\n    }\n    if (defrepr == NULL) {\n        Py_DECREF(baserepr);\n        return NULL;\n    }\n    result = PyUnicode_FromFormat(\"%s(%U, %U)\",\n                                  _PyType_Name(Py_TYPE(dd)),\n                                  defrepr, baserepr);\n    Py_DECREF(defrepr);\n    Py_DECREF(baserepr);\n    return result;\n}\n\nstatic PyObject*\ndefdict_or(PyObject* left, PyObject* right)\n{\n    PyObject *self, *other;\n\n    // Find module state\n    PyTypeObject *tp = Py_TYPE(left);\n    PyObject *mod = PyType_GetModuleByDef(tp, &_collectionsmodule);\n    if (mod == NULL) {\n        PyErr_Clear();\n        tp = Py_TYPE(right);\n        mod = PyType_GetModuleByDef(tp, &_collectionsmodule);\n    }\n    assert(mod != NULL);\n    collections_state *state = get_module_state(mod);\n\n    if (PyObject_TypeCheck(left, state->defdict_type)) {\n        self = left;\n        other = right;\n    }\n    else {\n        assert(PyObject_TypeCheck(right, state->defdict_type));\n        self = right;\n        other = left;\n    }\n    if (!PyDict_Check(other)) {\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n    // Like copy(), this calls the object's class.\n    // Override __or__/__ror__ for subclasses with different constructors.\n    PyObject *new = new_defdict((defdictobject*)self, left);\n    if (!new) {\n        return NULL;\n    }\n    if (PyDict_Update(new, right)) {\n        Py_DECREF(new);\n        return NULL;\n    }\n    return new;\n}\n\nstatic int\ndefdict_traverse(PyObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(self));\n    Py_VISIT(((defdictobject *)self)->default_factory);\n    return PyDict_Type.tp_traverse(self, visit, arg);\n}\n\nstatic int\ndefdict_tp_clear(defdictobject *dd)\n{\n    Py_CLEAR(dd->default_factory);\n    return PyDict_Type.tp_clear((PyObject *)dd);\n}\n\nstatic int\ndefdict_init(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    defdictobject *dd = (defdictobject *)self;\n    PyObject *olddefault = dd->default_factory;\n    PyObject *newdefault = NULL;\n    PyObject *newargs;\n    int result;\n    if (args == NULL || !PyTuple_Check(args))\n        newargs = PyTuple_New(0);\n    else {\n        Py_ssize_t n = PyTuple_GET_SIZE(args);\n        if (n > 0) {\n            newdefault = PyTuple_GET_ITEM(args, 0);\n            if (!PyCallable_Check(newdefault) && newdefault != Py_None) {\n                PyErr_SetString(PyExc_TypeError,\n                    \"first argument must be callable or None\");\n                return -1;\n            }\n        }\n        newargs = PySequence_GetSlice(args, 1, n);\n    }\n    if (newargs == NULL)\n        return -1;\n    dd->default_factory = Py_XNewRef(newdefault);\n    result = PyDict_Type.tp_init(self, newargs, kwds);\n    Py_DECREF(newargs);\n    Py_XDECREF(olddefault);\n    return result;\n}\n\nPyDoc_STRVAR(defdict_doc,\n\"defaultdict(default_factory=None, /, [...]) --> dict with default factory\\n\\\n\\n\\\nThe default factory is called without arguments to produce\\n\\\na new value when a key is not present, in __getitem__ only.\\n\\\nA defaultdict compares equal to a dict with the same items.\\n\\\nAll remaining arguments are treated the same as if they were\\n\\\npassed to the dict constructor, including keyword arguments.\\n\\\n\");\n\n/* See comment in xxsubtype.c */\n#define DEFERRED_ADDRESS(ADDR) 0\n\nstatic PyType_Slot defdict_slots[] = {\n    {Py_tp_dealloc, defdict_dealloc},\n    {Py_tp_repr, defdict_repr},\n    {Py_nb_or, defdict_or},\n    {Py_tp_getattro, PyObject_GenericGetAttr},\n    {Py_tp_doc, (void *)defdict_doc},\n    {Py_tp_traverse, defdict_traverse},\n    {Py_tp_clear, defdict_tp_clear},\n    {Py_tp_methods, defdict_methods},\n    {Py_tp_members, defdict_members},\n    {Py_tp_init, defdict_init},\n    {Py_tp_alloc, PyType_GenericAlloc},\n    {Py_tp_free, PyObject_GC_Del},\n    {0, NULL},\n};\n\nstatic PyType_Spec defdict_spec = {\n    .name = \"collections.defaultdict\",\n    .basicsize = sizeof(defdictobject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC |\n              Py_TPFLAGS_IMMUTABLETYPE),\n    .slots = defdict_slots,\n};\n\n/* helper function for Counter  *********************************************/\n\n/*[clinic input]\n_collections._count_elements\n\n    mapping: object\n    iterable: object\n    /\n\nCount elements in the iterable, updating the mapping\n[clinic start generated code]*/\n\nstatic PyObject *\n_collections__count_elements_impl(PyObject *module, PyObject *mapping,\n                                  PyObject *iterable)\n/*[clinic end generated code: output=7e0c1789636b3d8f input=e79fad04534a0b45]*/\n{\n    PyObject *it, *oldval;\n    PyObject *newval = NULL;\n    PyObject *key = NULL;\n    PyObject *bound_get = NULL;\n    PyObject *mapping_get;\n    PyObject *dict_get;\n    PyObject *mapping_setitem;\n    PyObject *dict_setitem;\n    PyObject *one = _PyLong_GetOne();  // borrowed reference\n\n    it = PyObject_GetIter(iterable);\n    if (it == NULL)\n        return NULL;\n\n    /* Only take the fast path when get() and __setitem__()\n     * have not been overridden.\n     */\n    mapping_get = _PyType_LookupRef(Py_TYPE(mapping), &_Py_ID(get));\n    dict_get = _PyType_Lookup(&PyDict_Type, &_Py_ID(get));\n    mapping_setitem = _PyType_LookupRef(Py_TYPE(mapping), &_Py_ID(__setitem__));\n    dict_setitem = _PyType_Lookup(&PyDict_Type, &_Py_ID(__setitem__));\n\n    if (mapping_get != NULL && mapping_get == dict_get &&\n        mapping_setitem != NULL && mapping_setitem == dict_setitem &&\n        PyDict_Check(mapping))\n    {\n        while (1) {\n            /* Fast path advantages:\n                   1. Eliminate double hashing\n                      (by re-using the same hash for both the get and set)\n                   2. Avoid argument overhead of PyObject_CallFunctionObjArgs\n                      (argument tuple creation and parsing)\n                   3. Avoid indirection through a bound method object\n                      (creates another argument tuple)\n                   4. Avoid initial increment from zero\n                      (reuse an existing one-object instead)\n            */\n            Py_hash_t hash;\n\n            key = PyIter_Next(it);\n            if (key == NULL)\n                break;\n\n            hash = _PyObject_HashFast(key);\n            if (hash == -1) {\n                goto done;\n            }\n\n            oldval = _PyDict_GetItem_KnownHash(mapping, key, hash);\n            if (oldval == NULL) {\n                if (PyErr_Occurred())\n                    goto done;\n                if (_PyDict_SetItem_KnownHash(mapping, key, one, hash) < 0)\n                    goto done;\n            } else {\n                newval = PyNumber_Add(oldval, one);\n                if (newval == NULL)\n                    goto done;\n                if (_PyDict_SetItem_KnownHash(mapping, key, newval, hash) < 0)\n                    goto done;\n                Py_CLEAR(newval);\n            }\n            Py_DECREF(key);\n        }\n    }\n    else {\n        bound_get = PyObject_GetAttr(mapping, &_Py_ID(get));\n        if (bound_get == NULL)\n            goto done;\n\n        PyObject *zero = _PyLong_GetZero();  // borrowed reference\n        while (1) {\n            key = PyIter_Next(it);\n            if (key == NULL)\n                break;\n            oldval = PyObject_CallFunctionObjArgs(bound_get, key, zero, NULL);\n            if (oldval == NULL)\n                break;\n            newval = PyNumber_Add(oldval, one);\n            Py_DECREF(oldval);\n            if (newval == NULL)\n                break;\n            if (PyObject_SetItem(mapping, key, newval) < 0)\n                break;\n            Py_CLEAR(newval);\n            Py_DECREF(key);\n        }\n    }\n\ndone:\n    Py_XDECREF(mapping_get);\n    Py_XDECREF(mapping_setitem);\n    Py_DECREF(it);\n    Py_XDECREF(key);\n    Py_XDECREF(newval);\n    Py_XDECREF(bound_get);\n    if (PyErr_Occurred())\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n/* Helper function for namedtuple() ************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    Py_ssize_t index;\n    PyObject* doc;\n} _tuplegetterobject;\n\n/*[clinic input]\n@classmethod\n_tuplegetter.__new__ as tuplegetter_new\n\n    index: Py_ssize_t\n    doc: object\n    /\n[clinic start generated code]*/\n\nstatic PyObject *\ntuplegetter_new_impl(PyTypeObject *type, Py_ssize_t index, PyObject *doc)\n/*[clinic end generated code: output=014be444ad80263f input=87c576a5bdbc0bbb]*/\n{\n    _tuplegetterobject* self;\n    self = (_tuplegetterobject *)type->tp_alloc(type, 0);\n    if (self == NULL) {\n        return NULL;\n    }\n    self->index = index;\n    self->doc = Py_NewRef(doc);\n    return (PyObject *)self;\n}\n\nstatic PyObject *\ntuplegetter_descr_get(PyObject *self, PyObject *obj, PyObject *type)\n{\n    Py_ssize_t index = ((_tuplegetterobject*)self)->index;\n    PyObject *result;\n\n    if (obj == NULL) {\n        return Py_NewRef(self);\n    }\n    if (!PyTuple_Check(obj)) {\n        if (obj == Py_None) {\n            return Py_NewRef(self);\n        }\n        PyErr_Format(PyExc_TypeError,\n                     \"descriptor for index '%zd' for tuple subclasses \"\n                     \"doesn't apply to '%s' object\",\n                     index,\n                     Py_TYPE(obj)->tp_name);\n        return NULL;\n    }\n\n    if (!valid_index(index, PyTuple_GET_SIZE(obj))) {\n        PyErr_SetString(PyExc_IndexError, \"tuple index out of range\");\n        return NULL;\n    }\n\n    result = PyTuple_GET_ITEM(obj, index);\n    return Py_NewRef(result);\n}\n\nstatic int\ntuplegetter_descr_set(PyObject *self, PyObject *obj, PyObject *value)\n{\n    if (value == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"can't delete attribute\");\n    } else {\n        PyErr_SetString(PyExc_AttributeError, \"can't set attribute\");\n    }\n    return -1;\n}\n\nstatic int\ntuplegetter_traverse(PyObject *self, visitproc visit, void *arg)\n{\n    _tuplegetterobject *tuplegetter = (_tuplegetterobject *)self;\n    Py_VISIT(Py_TYPE(tuplegetter));\n    Py_VISIT(tuplegetter->doc);\n    return 0;\n}\n\nstatic int\ntuplegetter_clear(PyObject *self)\n{\n    _tuplegetterobject *tuplegetter = (_tuplegetterobject *)self;\n    Py_CLEAR(tuplegetter->doc);\n    return 0;\n}\n\nstatic void\ntuplegetter_dealloc(_tuplegetterobject *self)\n{\n    PyTypeObject *tp = Py_TYPE(self);\n    PyObject_GC_UnTrack(self);\n    tuplegetter_clear((PyObject*)self);\n    tp->tp_free((PyObject*)self);\n    Py_DECREF(tp);\n}\n\nstatic PyObject*\ntuplegetter_reduce(_tuplegetterobject *self, PyObject *Py_UNUSED(ignored))\n{\n    return Py_BuildValue(\"(O(nO))\", (PyObject*) Py_TYPE(self), self->index, self->doc);\n}\n\nstatic PyObject*\ntuplegetter_repr(_tuplegetterobject *self)\n{\n    return PyUnicode_FromFormat(\"%s(%zd, %R)\",\n                                _PyType_Name(Py_TYPE(self)),\n                                self->index, self->doc);\n}\n\n\nstatic PyMemberDef tuplegetter_members[] = {\n    {\"__doc__\",  _Py_T_OBJECT, offsetof(_tuplegetterobject, doc), 0},\n    {0}\n};\n\nstatic PyMethodDef tuplegetter_methods[] = {\n    {\"__reduce__\", (PyCFunction)tuplegetter_reduce, METH_NOARGS, NULL},\n    {NULL},\n};\n\nstatic PyType_Slot tuplegetter_slots[] = {\n    {Py_tp_dealloc, tuplegetter_dealloc},\n    {Py_tp_repr, tuplegetter_repr},\n    {Py_tp_traverse, tuplegetter_traverse},\n    {Py_tp_clear, tuplegetter_clear},\n    {Py_tp_methods, tuplegetter_methods},\n    {Py_tp_members, tuplegetter_members},\n    {Py_tp_descr_get, tuplegetter_descr_get},\n    {Py_tp_descr_set, tuplegetter_descr_set},\n    {Py_tp_new, tuplegetter_new},\n    {0, NULL},\n};\n\nstatic PyType_Spec tuplegetter_spec = {\n    .name = \"collections._tuplegetter\",\n    .basicsize = sizeof(_tuplegetterobject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n              Py_TPFLAGS_IMMUTABLETYPE),\n    .slots = tuplegetter_slots,\n};\n\n\n/* module level code ********************************************************/\n\nstatic int\ncollections_traverse(PyObject *mod, visitproc visit, void *arg)\n{\n    collections_state *state = get_module_state(mod);\n    Py_VISIT(state->deque_type);\n    Py_VISIT(state->defdict_type);\n    Py_VISIT(state->dequeiter_type);\n    Py_VISIT(state->dequereviter_type);\n    Py_VISIT(state->tuplegetter_type);\n    return 0;\n}\n\nstatic int\ncollections_clear(PyObject *mod)\n{\n    collections_state *state = get_module_state(mod);\n    Py_CLEAR(state->deque_type);\n    Py_CLEAR(state->defdict_type);\n    Py_CLEAR(state->dequeiter_type);\n    Py_CLEAR(state->dequereviter_type);\n    Py_CLEAR(state->tuplegetter_type);\n    return 0;\n}\n\nstatic void\ncollections_free(void *module)\n{\n    collections_clear((PyObject *)module);\n}\n\nPyDoc_STRVAR(collections_doc,\n\"High performance data structures.\\n\\\n- deque:        ordered collection accessible from endpoints only\\n\\\n- defaultdict:  dict subclass with a default value factory\\n\\\n\");\n\nstatic struct PyMethodDef collections_methods[] = {\n    _COLLECTIONS__COUNT_ELEMENTS_METHODDEF\n    {NULL,       NULL}          /* sentinel */\n};\n\n#define ADD_TYPE(MOD, SPEC, TYPE, BASE) do {                        \\\n    TYPE = (PyTypeObject *)PyType_FromMetaclass(NULL, MOD, SPEC,    \\\n                                                (PyObject *)BASE);  \\\n    if (TYPE == NULL) {                                             \\\n        return -1;                                                  \\\n    }                                                               \\\n    if (PyModule_AddType(MOD, TYPE) < 0) {                          \\\n        return -1;                                                  \\\n    }                                                               \\\n} while (0)\n\nstatic int\ncollections_exec(PyObject *module) {\n    collections_state *state = get_module_state(module);\n    ADD_TYPE(module, &deque_spec, state->deque_type, NULL);\n    ADD_TYPE(module, &defdict_spec, state->defdict_type, &PyDict_Type);\n    ADD_TYPE(module, &dequeiter_spec, state->dequeiter_type, NULL);\n    ADD_TYPE(module, &dequereviter_spec, state->dequereviter_type, NULL);\n    ADD_TYPE(module, &tuplegetter_spec, state->tuplegetter_type, NULL);\n\n    if (PyModule_AddType(module, &PyODict_Type) < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n\n#undef ADD_TYPE\n\nstatic struct PyModuleDef_Slot collections_slots[] = {\n    {Py_mod_exec, collections_exec},\n    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},\n    {Py_mod_gil, Py_MOD_GIL_NOT_USED},\n    {0, NULL}\n};\n\nstatic struct PyModuleDef _collectionsmodule = {\n    .m_base = PyModuleDef_HEAD_INIT,\n    .m_name = \"_collections\",\n    .m_doc = collections_doc,\n    .m_size = sizeof(collections_state),\n    .m_methods = collections_methods,\n    .m_slots = collections_slots,\n    .m_traverse = collections_traverse,\n    .m_clear = collections_clear,\n    .m_free = collections_free,\n};\n\nPyMODINIT_FUNC\nPyInit__collections(void)\n{\n    return PyModuleDef_Init(&_collectionsmodule);\n}\n"}, "sourceLanguage": "c"}, {"location": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "contents": {"text": "#ifndef Py_OBJECT_H\n#define Py_OBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Object and type object interface */\n\n/*\nObjects are structures allocated on the heap.  Special rules apply to\nthe use of objects to ensure they are properly garbage-collected.\nObjects are never allocated statically or on the stack; they must be\naccessed through special macros and functions only.  (Type objects are\nexceptions to the first rule; the standard types are represented by\nstatically initialized type objects, although work on type/class unification\nfor Python 2.2 made it possible to have heap-allocated type objects too).\n\nAn object has a 'reference count' that is increased or decreased when a\npointer to the object is copied or deleted; when the reference count\nreaches zero there are no references to the object left and it can be\nremoved from the heap.\n\nAn object has a 'type' that determines what it represents and what kind\nof data it contains.  An object's type is fixed when it is created.\nTypes themselves are represented as objects; an object contains a\npointer to the corresponding type object.  The type itself has a type\npointer pointing to the object representing the type 'type', which\ncontains a pointer to itself!.\n\nObjects do not float around in memory; once allocated an object keeps\nthe same size and address.  Objects that must hold variable-size data\ncan contain pointers to variable-size parts of the object.  Not all\nobjects of the same type have the same size; but the size cannot change\nafter allocation.  (These restrictions are made so a reference to an\nobject can be simply a pointer -- moving an object would require\nupdating all the pointers, and changing an object's size would require\nmoving it if there was another object right next to it.)\n\nObjects are always accessed through pointers of the type 'PyObject *'.\nThe type 'PyObject' is a structure that only contains the reference count\nand the type pointer.  The actual memory allocated for an object\ncontains other data that can only be accessed after casting the pointer\nto a pointer to a longer structure type.  This longer type must start\nwith the reference count and type fields; the macro PyObject_HEAD should be\nused for this (to accommodate for future changes).  The implementation\nof a particular object type can cast the object pointer to the proper\ntype and back.\n\nA standard interface exists for objects that contain an array of items\nwhose size is determined when the object is allocated.\n*/\n\n/* Py_DEBUG implies Py_REF_DEBUG. */\n#if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)\n#  define Py_REF_DEBUG\n#endif\n\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   PyObject ob_base;\n\n/*\nImmortalization:\n\nThe following indicates the immortalization strategy depending on the amount\nof available bits in the reference count field. All strategies are backwards\ncompatible but the specific reference count value or immortalization check\nmight change depending on the specializations for the underlying system.\n\nProper deallocation of immortal instances requires distinguishing between\nstatically allocated immortal instances vs those promoted by the runtime to be\nimmortal. The latter should be the only instances that require\ncleanup during runtime finalization.\n*/\n\n#if SIZEOF_VOID_P > 4\n/*\nIn 64+ bit systems, an object will be marked as immortal by setting all of the\nlower 32 bits of the reference count field, which is equal to: 0xFFFFFFFF\n\nUsing the lower 32 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases will use saturated arithmetic, taking advantage of\nhaving all the lower 32 bits set, which will avoid the reference count to go\nbeyond the refcount limit. Immortality checks for reference count decreases will\nbe done by checking the bit sign flag in the lower 32 bits.\n*/\n#define _Py_IMMORTAL_REFCNT _Py_CAST(Py_ssize_t, UINT_MAX)\n\n#else\n/*\nIn 32 bit systems, an object will be marked as immortal by setting all of the\nlower 30 bits of the reference count field, which is equal to: 0x3FFFFFFF\n\nUsing the lower 30 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases and decreases will first go through an immortality\ncheck by comparing the reference count field to the immortality reference count.\n*/\n#define _Py_IMMORTAL_REFCNT _Py_CAST(Py_ssize_t, UINT_MAX >> 2)\n#endif\n\n// Py_GIL_DISABLED builds indicate immortal objects using `ob_ref_local`, which is\n// always 32-bits.\n#ifdef Py_GIL_DISABLED\n#define _Py_IMMORTAL_REFCNT_LOCAL UINT32_MAX\n#endif\n\n// Kept for backward compatibility. It was needed by Py_TRACE_REFS build.\n#define _PyObject_EXTRA_INIT\n\n/* Make all uses of PyObject_HEAD_INIT immortal.\n *\n * Statically allocated objects might be shared between\n * interpreters, so must be marked as immortal.\n */\n#if defined(Py_GIL_DISABLED)\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        0,                          \\\n        0,                          \\\n        { 0 },                      \\\n        0,                          \\\n        _Py_IMMORTAL_REFCNT_LOCAL,  \\\n        0,                          \\\n        (type),                     \\\n    },\n#else\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        { _Py_IMMORTAL_REFCNT },    \\\n        (type)                      \\\n    },\n#endif\n\n#define PyVarObject_HEAD_INIT(type, size) \\\n    {                                     \\\n        PyObject_HEAD_INIT(type)          \\\n        (size)                            \\\n    },\n\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD      PyVarObject ob_base;\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\n#ifndef Py_GIL_DISABLED\nstruct _object {\n#if (defined(__GNUC__) || defined(__clang__)) \\\n        && !(defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L)\n    // On C99 and older, anonymous union is a GCC and clang extension\n    __extension__\n#endif\n#ifdef _MSC_VER\n    // Ignore MSC warning C4201: \"nonstandard extension used:\n    // nameless struct/union\"\n    __pragma(warning(push))\n    __pragma(warning(disable: 4201))\n#endif\n    union {\n       Py_ssize_t ob_refcnt;\n#if SIZEOF_VOID_P > 4\n       PY_UINT32_T ob_refcnt_split[2];\n#endif\n    };\n#ifdef _MSC_VER\n    __pragma(warning(pop))\n#endif\n\n    PyTypeObject *ob_type;\n};\n#else\n// Objects that are not owned by any thread use a thread id (tid) of zero.\n// This includes both immortal objects and objects whose reference count\n// fields have been merged.\n#define _Py_UNOWNED_TID             0\n\n// The shared reference count uses the two least-significant bits to store\n// flags. The remaining bits are used to store the reference count.\n#define _Py_REF_SHARED_SHIFT        2\n#define _Py_REF_SHARED_FLAG_MASK    0x3\n\n// The shared flags are initialized to zero.\n#define _Py_REF_SHARED_INIT         0x0\n#define _Py_REF_MAYBE_WEAKREF       0x1\n#define _Py_REF_QUEUED              0x2\n#define _Py_REF_MERGED              0x3\n\n// Create a shared field from a refcnt and desired flags\n#define _Py_REF_SHARED(refcnt, flags) (((refcnt) << _Py_REF_SHARED_SHIFT) + (flags))\n\nstruct _object {\n    // ob_tid stores the thread id (or zero). It is also used by the GC and the\n    // trashcan mechanism as a linked list pointer and by the GC to store the\n    // computed \"gc_refs\" refcount.\n    uintptr_t ob_tid;\n    uint16_t _padding;\n    PyMutex ob_mutex;           // per-object lock\n    uint8_t ob_gc_bits;         // gc-related state\n    uint32_t ob_ref_local;      // local reference count\n    Py_ssize_t ob_ref_shared;   // shared (atomic) reference count\n    PyTypeObject *ob_type;\n};\n#endif\n\n/* Cast argument to PyObject* type. */\n#define _PyObject_CAST(op) _Py_CAST(PyObject*, (op))\n\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n/* Cast argument to PyVarObject* type. */\n#define _PyVarObject_CAST(op) _Py_CAST(PyVarObject*, (op))\n\n\n// Test if the 'x' object is the 'y' object, the same as \"x is y\" in Python.\nPyAPI_FUNC(int) Py_Is(PyObject *x, PyObject *y);\n#define Py_Is(x, y) ((x) == (y))\n\n#if defined(Py_GIL_DISABLED) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(uintptr_t) _Py_GetThreadLocal_Addr(void);\n\nstatic inline uintptr_t\n_Py_ThreadId(void)\n{\n    uintptr_t tid;\n#if defined(_MSC_VER) && defined(_M_X64)\n    tid = __readgsqword(48);\n#elif defined(_MSC_VER) && defined(_M_IX86)\n    tid = __readfsdword(24);\n#elif defined(_MSC_VER) && defined(_M_ARM64)\n    tid = __getReg(18);\n#elif defined(__i386__)\n    __asm__(\"movl %%gs:0, %0\" : \"=r\" (tid));  // 32-bit always uses GS\n#elif defined(__MACH__) && defined(__x86_64__)\n    __asm__(\"movq %%gs:0, %0\" : \"=r\" (tid));  // x86_64 macOSX uses GS\n#elif defined(__x86_64__)\n   __asm__(\"movq %%fs:0, %0\" : \"=r\" (tid));  // x86_64 Linux, BSD uses FS\n#elif defined(__arm__)\n    __asm__ (\"mrc p15, 0, %0, c13, c0, 3\\nbic %0, %0, #3\" : \"=r\" (tid));\n#elif defined(__aarch64__) && defined(__APPLE__)\n    __asm__ (\"mrs %0, tpidrro_el0\" : \"=r\" (tid));\n#elif defined(__aarch64__)\n    __asm__ (\"mrs %0, tpidr_el0\" : \"=r\" (tid));\n#elif defined(__powerpc64__)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // r13 is reserved for use as system thread ID by the Power 64-bit ABI.\n    register uintptr_t tp __asm__ (\"r13\");\n    __asm__(\"\" : \"=r\" (tp));\n    tid = tp;\n    #endif\n#elif defined(__powerpc__)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // r2 is reserved for use as system thread ID by the Power 32-bit ABI.\n    register uintptr_t tp __asm__ (\"r2\");\n    __asm__ (\"\" : \"=r\" (tp));\n    tid = tp;\n    #endif\n#elif defined(__s390__) && defined(__GNUC__)\n    // Both GCC and Clang have supported __builtin_thread_pointer\n    // for s390 from long time ago.\n    tid = (uintptr_t)__builtin_thread_pointer();\n#elif defined(__riscv)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // tp is Thread Pointer provided by the RISC-V ABI.\n    __asm__ (\"mv %0, tp\" : \"=r\" (tid));\n    #endif\n#else\n    // Fallback to a portable implementation if we do not have a faster\n    // platform-specific implementation.\n    tid = _Py_GetThreadLocal_Addr();\n#endif\n  return tid;\n}\n\nstatic inline Py_ALWAYS_INLINE int\n_Py_IsOwnedByCurrentThread(PyObject *ob)\n{\n#ifdef _Py_THREAD_SANITIZER\n    return _Py_atomic_load_uintptr_relaxed(&ob->ob_tid) == _Py_ThreadId();\n#else\n    return ob->ob_tid == _Py_ThreadId();\n#endif\n}\n#endif\n\nstatic inline Py_ssize_t Py_REFCNT(PyObject *ob) {\n#if !defined(Py_GIL_DISABLED)\n    return ob->ob_refcnt;\n#else\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&ob->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return _Py_IMMORTAL_REFCNT;\n    }\n    Py_ssize_t shared = _Py_atomic_load_ssize_relaxed(&ob->ob_ref_shared);\n    return _Py_STATIC_CAST(Py_ssize_t, local) +\n           Py_ARITHMETIC_RIGHT_SHIFT(Py_ssize_t, shared, _Py_REF_SHARED_SHIFT);\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_REFCNT(ob) Py_REFCNT(_PyObject_CAST(ob))\n#endif\n\n\n// bpo-39573: The Py_SET_TYPE() function must be used to set an object type.\nstatic inline PyTypeObject* Py_TYPE(PyObject *ob) {\n    return ob->ob_type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_TYPE(ob) Py_TYPE(_PyObject_CAST(ob))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyLong_Type;\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n\n// bpo-39573: The Py_SET_SIZE() function must be used to set an object size.\nstatic inline Py_ssize_t Py_SIZE(PyObject *ob) {\n    assert(ob->ob_type != &PyLong_Type);\n    assert(ob->ob_type != &PyBool_Type);\n    return  _PyVarObject_CAST(ob)->ob_size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SIZE(ob) Py_SIZE(_PyObject_CAST(ob))\n#endif\n\nstatic inline Py_ALWAYS_INLINE int _Py_IsImmortal(PyObject *op)\n{\n#if defined(Py_GIL_DISABLED)\n    return (_Py_atomic_load_uint32_relaxed(&op->ob_ref_local) ==\n            _Py_IMMORTAL_REFCNT_LOCAL);\n#elif SIZEOF_VOID_P > 4\n    return (_Py_CAST(PY_INT32_T, op->ob_refcnt) < 0);\n#else\n    return (op->ob_refcnt == _Py_IMMORTAL_REFCNT);\n#endif\n}\n#define _Py_IsImmortal(op) _Py_IsImmortal(_PyObject_CAST(op))\n\nstatic inline int Py_IS_TYPE(PyObject *ob, PyTypeObject *type) {\n    return Py_TYPE(ob) == type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_IS_TYPE(ob, type) Py_IS_TYPE(_PyObject_CAST(ob), (type))\n#endif\n\n\n// Py_SET_REFCNT() implementation for stable ABI\nPyAPI_FUNC(void) _Py_SetRefcnt(PyObject *ob, Py_ssize_t refcnt);\n\nstatic inline void Py_SET_REFCNT(PyObject *ob, Py_ssize_t refcnt) {\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030d0000\n    // Stable ABI implements Py_SET_REFCNT() as a function call\n    // on limited C API version 3.13 and newer.\n    _Py_SetRefcnt(ob, refcnt);\n#else\n    // This immortal check is for code that is unaware of immortal objects.\n    // The runtime tracks these objects and we should avoid as much\n    // as possible having extensions inadvertently change the refcnt\n    // of an immortalized object.\n    if (_Py_IsImmortal(ob)) {\n        return;\n    }\n\n#ifndef Py_GIL_DISABLED\n    ob->ob_refcnt = refcnt;\n#else\n    if (_Py_IsOwnedByCurrentThread(ob)) {\n        if ((size_t)refcnt > (size_t)UINT32_MAX) {\n            // On overflow, make the object immortal\n            ob->ob_tid = _Py_UNOWNED_TID;\n            ob->ob_ref_local = _Py_IMMORTAL_REFCNT_LOCAL;\n            ob->ob_ref_shared = 0;\n        }\n        else {\n            // Set local refcount to desired refcount and shared refcount\n            // to zero, but preserve the shared refcount flags.\n            ob->ob_ref_local = _Py_STATIC_CAST(uint32_t, refcnt);\n            ob->ob_ref_shared &= _Py_REF_SHARED_FLAG_MASK;\n        }\n    }\n    else {\n        // Set local refcount to zero and shared refcount to desired refcount.\n        // Mark the object as merged.\n        ob->ob_tid = _Py_UNOWNED_TID;\n        ob->ob_ref_local = 0;\n        ob->ob_ref_shared = _Py_REF_SHARED(refcnt, _Py_REF_MERGED);\n    }\n#endif  // Py_GIL_DISABLED\n#endif  // Py_LIMITED_API+0 < 0x030d0000\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_REFCNT(ob, refcnt) Py_SET_REFCNT(_PyObject_CAST(ob), (refcnt))\n#endif\n\n\nstatic inline void Py_SET_TYPE(PyObject *ob, PyTypeObject *type) {\n    ob->ob_type = type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_TYPE(ob, type) Py_SET_TYPE(_PyObject_CAST(ob), type)\n#endif\n\nstatic inline void Py_SET_SIZE(PyVarObject *ob, Py_ssize_t size) {\n    assert(ob->ob_base.ob_type != &PyLong_Type);\n    assert(ob->ob_base.ob_type != &PyBool_Type);\n#ifdef Py_GIL_DISABLED\n    _Py_atomic_store_ssize_relaxed(&ob->ob_size, size);\n#else\n    ob->ob_size = size;\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_SIZE(ob, size) Py_SET_SIZE(_PyVarObject_CAST(ob), (size))\n#endif\n\n\n/*\nType objects contain a string containing the type name (to help somewhat\nin debugging), the allocation parameters (see PyObject_New() and\nPyObject_NewVar()),\nand methods for accessing objects of the type.  Methods are optional, a\nnil pointer meaning that particular kind of access is not available for\nthis type.  The Py_DECREF() macro uses the tp_dealloc method without\nchecking for a nil pointer; it should always be implemented except if\nthe implementation can guarantee that the reference count will never\nreach zero (e.g., for statically allocated type objects).\n\nNB: the methods for certain type groups are now contained in separate\nmethod blocks.\n*/\n\ntypedef PyObject * (*unaryfunc)(PyObject *);\ntypedef PyObject * (*binaryfunc)(PyObject *, PyObject *);\ntypedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);\ntypedef int (*inquiry)(PyObject *);\ntypedef Py_ssize_t (*lenfunc)(PyObject *);\ntypedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);\ntypedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);\ntypedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);\ntypedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);\ntypedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);\n\ntypedef int (*objobjproc)(PyObject *, PyObject *);\ntypedef int (*visitproc)(PyObject *, void *);\ntypedef int (*traverseproc)(PyObject *, visitproc, void *);\n\n\ntypedef void (*freefunc)(void *);\ntypedef void (*destructor)(PyObject *);\ntypedef PyObject *(*getattrfunc)(PyObject *, char *);\ntypedef PyObject *(*getattrofunc)(PyObject *, PyObject *);\ntypedef int (*setattrfunc)(PyObject *, char *, PyObject *);\ntypedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*reprfunc)(PyObject *);\ntypedef Py_hash_t (*hashfunc)(PyObject *);\ntypedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);\ntypedef PyObject *(*getiterfunc) (PyObject *);\ntypedef PyObject *(*iternextfunc) (PyObject *);\ntypedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*initproc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*newfunc)(PyTypeObject *, PyObject *, PyObject *);\ntypedef PyObject *(*allocfunc)(PyTypeObject *, Py_ssize_t);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030c0000 // 3.12\ntypedef PyObject *(*vectorcallfunc)(PyObject *callable, PyObject *const *args,\n                                    size_t nargsf, PyObject *kwnames);\n#endif\n\ntypedef struct{\n    int slot;    /* slot id, see below */\n    void *pfunc; /* function pointer */\n} PyType_Slot;\n\ntypedef struct{\n    const char* name;\n    int basicsize;\n    int itemsize;\n    unsigned int flags;\n    PyType_Slot *slots; /* terminated by slot==0. */\n} PyType_Spec;\n\nPyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000\nPyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);\nPyAPI_FUNC(PyObject *) PyType_GetModule(PyTypeObject *);\nPyAPI_FUNC(void *) PyType_GetModuleState(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000\nPyAPI_FUNC(PyObject *) PyType_GetName(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GetQualName(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030D0000\nPyAPI_FUNC(PyObject *) PyType_GetFullyQualifiedName(PyTypeObject *type);\nPyAPI_FUNC(PyObject *) PyType_GetModuleName(PyTypeObject *type);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\nPyAPI_FUNC(PyObject *) PyType_FromMetaclass(PyTypeObject*, PyObject*, PyType_Spec*, PyObject*);\nPyAPI_FUNC(void *) PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls);\nPyAPI_FUNC(Py_ssize_t) PyType_GetTypeDataSize(PyTypeObject *cls);\n#endif\n\n/* Generic type check */\nPyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);\n\nstatic inline int PyObject_TypeCheck(PyObject *ob, PyTypeObject *type) {\n    return Py_IS_TYPE(ob, type) || PyType_IsSubtype(Py_TYPE(ob), type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyObject_TypeCheck(ob, type) PyObject_TypeCheck(_PyObject_CAST(ob), (type))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */\nPyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */\nPyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */\n\nPyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);\n\nPyAPI_FUNC(int) PyType_Ready(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,\n                                               PyObject *, PyObject *);\nPyAPI_FUNC(unsigned int) PyType_ClearCache(void);\nPyAPI_FUNC(void) PyType_Modified(PyTypeObject *);\n\n/* Generic operations on objects */\nPyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);\nPyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);\nPyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);\nPyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);\nPyAPI_FUNC(int) PyObject_DelAttrString(PyObject *v, const char *name);\nPyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(int) PyObject_GetOptionalAttr(PyObject *, PyObject *, PyObject **);\nPyAPI_FUNC(int) PyObject_GetOptionalAttrString(PyObject *, const char *, PyObject **);\n#endif\nPyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_DelAttr(PyObject *v, PyObject *name);\nPyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(int) PyObject_HasAttrWithError(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttrStringWithError(PyObject *, const char *);\n#endif\nPyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);\n#endif\nPyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);\nPyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);\nPyAPI_FUNC(int) PyObject_IsTrue(PyObject *);\nPyAPI_FUNC(int) PyObject_Not(PyObject *);\nPyAPI_FUNC(int) PyCallable_Check(PyObject *);\nPyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);\n\n/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a\n   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),\n   returning the names of the current locals.  In this case, if there are\n   no current locals, NULL is returned, and PyErr_Occurred() is false.\n*/\nPyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);\n\n/* Helpers for printing recursive container types */\nPyAPI_FUNC(int) Py_ReprEnter(PyObject *);\nPyAPI_FUNC(void) Py_ReprLeave(PyObject *);\n\n/* Flag bits for printing: */\n#define Py_PRINT_RAW    1       /* No string quotes etc. */\n\n/*\nType flags (tp_flags)\n\nThese flags are used to change expected features and behavior for a\nparticular type.\n\nArbitration of the flag bit positions will need to be coordinated among\nall extension writers who publicly release their extensions (this will\nbe fewer than you might expect!).\n\nMost flags were removed as of Python 3.0 to make room for new flags.  (Some\nflags are not for backwards compatibility but to indicate the presence of an\noptional feature; these flags remain of course.)\n\nType definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.\n\nCode can use PyType_HasFeature(type_ob, flag_value) to test whether the\ngiven type object has a specified feature.\n*/\n\n#ifndef Py_LIMITED_API\n\n/* Track types initialized using _PyStaticType_InitBuiltin(). */\n#define _Py_TPFLAGS_STATIC_BUILTIN (1 << 1)\n\n/* The values array is placed inline directly after the rest of\n * the object. Implies Py_TPFLAGS_HAVE_GC.\n */\n#define Py_TPFLAGS_INLINE_VALUES (1 << 2)\n\n/* Placement of weakref pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_weaklistoffset.\n */\n#define Py_TPFLAGS_MANAGED_WEAKREF (1 << 3)\n\n/* Placement of dict (and values) pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_dictoffset. Implies Py_TPFLAGS_HAVE_GC.\n */\n#define Py_TPFLAGS_MANAGED_DICT (1 << 4)\n\n#define Py_TPFLAGS_PREHEADER (Py_TPFLAGS_MANAGED_WEAKREF | Py_TPFLAGS_MANAGED_DICT)\n\n/* Set if instances of the type object are treated as sequences for pattern matching */\n#define Py_TPFLAGS_SEQUENCE (1 << 5)\n/* Set if instances of the type object are treated as mappings for pattern matching */\n#define Py_TPFLAGS_MAPPING (1 << 6)\n#endif\n\n/* Disallow creating instances of the type: set tp_new to NULL and don't create\n * the \"__new__\" key in the type dictionary. */\n#define Py_TPFLAGS_DISALLOW_INSTANTIATION (1UL << 7)\n\n/* Set if the type object is immutable: type attributes cannot be set nor deleted */\n#define Py_TPFLAGS_IMMUTABLETYPE (1UL << 8)\n\n/* Set if the type object is dynamically allocated */\n#define Py_TPFLAGS_HEAPTYPE (1UL << 9)\n\n/* Set if the type allows subclassing */\n#define Py_TPFLAGS_BASETYPE (1UL << 10)\n\n/* Set if the type implements the vectorcall protocol (PEP 590) */\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\n#define Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)\n#ifndef Py_LIMITED_API\n// Backwards compatibility alias for API that was provisional in Python 3.8\n#define _Py_TPFLAGS_HAVE_VECTORCALL Py_TPFLAGS_HAVE_VECTORCALL\n#endif\n#endif\n\n/* Set if the type is 'ready' -- fully initialized */\n#define Py_TPFLAGS_READY (1UL << 12)\n\n/* Set while the type is being 'readied', to prevent recursive ready calls */\n#define Py_TPFLAGS_READYING (1UL << 13)\n\n/* Objects support garbage collection (see objimpl.h) */\n#define Py_TPFLAGS_HAVE_GC (1UL << 14)\n\n/* These two bits are preserved for Stackless Python, next after this is 17 */\n#ifdef STACKLESS\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)\n#else\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0\n#endif\n\n/* Objects behave like an unbound method */\n#define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)\n\n/* Unused. Legacy flag */\n#define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)\n\n/* Type is abstract and cannot be instantiated */\n#define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)\n\n// This undocumented flag gives certain built-ins their unique pattern-matching\n// behavior, which allows a single positional subpattern to match against the\n// subject itself (rather than a mapped attribute on it):\n#define _Py_TPFLAGS_MATCH_SELF (1UL << 22)\n\n/* Items (ob_size*tp_itemsize) are found at the end of an instance's memory */\n#define Py_TPFLAGS_ITEMS_AT_END (1UL << 23)\n\n/* These flags are used to determine if a type is a subclass. */\n#define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)\n#define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)\n#define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)\n#define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)\n#define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)\n#define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)\n#define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)\n#define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)\n\n#define Py_TPFLAGS_DEFAULT  ( \\\n                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \\\n                0)\n\n/* NOTE: Some of the following flags reuse lower bits (removed as part of the\n * Python 3.0 transition). */\n\n/* The following flags are kept for compatibility; in previous\n * versions they indicated presence of newer tp_* fields on the\n * type struct.\n * Starting with 3.8, binary compatibility of C extensions across\n * feature releases of Python is not supported anymore (except when\n * using the stable ABI, in which all classes are created dynamically,\n * using the interpreter's memory layout.)\n * Note that older extensions using the stable ABI set these flags,\n * so the bits must not be repurposed.\n */\n#define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)\n#define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)\n\n\n/*\nThe macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement\nreference counts.  Py_DECREF calls the object's deallocator function when\nthe refcount falls to 0; for\nobjects that don't contain references to other objects or heap memory\nthis can be the standard function free().  Both macros can be used\nwherever a void expression is allowed.  The argument must not be a\nNULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.\nThe macro _Py_NewReference(op) initialize reference counts to 1, and\nin special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional\nbookkeeping appropriate to the special build.\n\nWe assume that the reference count field can never overflow; this can\nbe proven when the size of the field is the same as the pointer size, so\nwe ignore the possibility.  Provided a C int is at least 32 bits (which\nis implicitly assumed in many parts of this code), that's enough for\nabout 2**31 references to an object.\n\nXXX The following became out of date in Python 2.2, but I'm not sure\nXXX what the full truth is now.  Certainly, heap-allocated type objects\nXXX can and should be deallocated.\nType objects should never be deallocated; the type pointer in an object\nis not considered to be a reference to the type object, to save\ncomplications in the deallocation function.  (This is actually a\ndecision that's up to the implementer of each new type so if you want,\nyou can count such references to the type object.)\n*/\n\n#if defined(Py_REF_DEBUG) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,\n                                      PyObject *op);\nPyAPI_FUNC(void) _Py_INCREF_IncRefTotal(void);\nPyAPI_FUNC(void) _Py_DECREF_DecRefTotal(void);\n#endif  // Py_REF_DEBUG && !Py_LIMITED_API\n\nPyAPI_FUNC(void) _Py_Dealloc(PyObject *);\n\n/*\nThese are provided as conveniences to Python runtime embedders, so that\nthey can have object code that is not dependent on Python compilation flags.\n*/\nPyAPI_FUNC(void) Py_IncRef(PyObject *);\nPyAPI_FUNC(void) Py_DecRef(PyObject *);\n\n// Similar to Py_IncRef() and Py_DecRef() but the argument must be non-NULL.\n// Private functions used by Py_INCREF() and Py_DECREF().\nPyAPI_FUNC(void) _Py_IncRef(PyObject *);\nPyAPI_FUNC(void) _Py_DecRef(PyObject *);\n\nstatic inline Py_ALWAYS_INLINE void Py_INCREF(PyObject *op)\n{\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n    // Stable ABI implements Py_INCREF() as a function call on limited C API\n    // version 3.12 and newer, and on Python built in debug mode. _Py_IncRef()\n    // was added to Python 3.10.0a7, use Py_IncRef() on older Python versions.\n    // Py_IncRef() accepts NULL whereas _Py_IncRef() doesn't.\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_IncRef(op);\n#  else\n    Py_IncRef(op);\n#  endif\n#else\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n#if defined(Py_GIL_DISABLED)\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    uint32_t new_local = local + 1;\n    if (new_local == 0) {\n        // local is equal to _Py_IMMORTAL_REFCNT: do nothing\n        return;\n    }\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, new_local);\n    }\n    else {\n        _Py_atomic_add_ssize(&op->ob_ref_shared, (1 << _Py_REF_SHARED_SHIFT));\n    }\n#elif SIZEOF_VOID_P > 4\n    // Portable saturated add, branching on the carry flag and set low bits\n    PY_UINT32_T cur_refcnt = op->ob_refcnt_split[PY_BIG_ENDIAN];\n    PY_UINT32_T new_refcnt = cur_refcnt + 1;\n    if (new_refcnt == 0) {\n        // cur_refcnt is equal to _Py_IMMORTAL_REFCNT: the object is immortal,\n        // do nothing\n        return;\n    }\n    op->ob_refcnt_split[PY_BIG_ENDIAN] = new_refcnt;\n#else\n    // Explicitly check immortality against the immortal value\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    op->ob_refcnt++;\n#endif\n    _Py_INCREF_STAT_INC();\n#ifdef Py_REF_DEBUG\n    _Py_INCREF_IncRefTotal();\n#endif\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_INCREF(op) Py_INCREF(_PyObject_CAST(op))\n#endif\n\n\n#if !defined(Py_LIMITED_API) && defined(Py_GIL_DISABLED)\n// Implements Py_DECREF on objects not owned by the current thread.\nPyAPI_FUNC(void) _Py_DecRefShared(PyObject *);\nPyAPI_FUNC(void) _Py_DecRefSharedDebug(PyObject *, const char *, int);\n\n// Called from Py_DECREF by the owning thread when the local refcount reaches\n// zero. The call will deallocate the object if the shared refcount is also\n// zero. Otherwise, the thread gives up ownership and merges the reference\n// count fields.\nPyAPI_FUNC(void) _Py_MergeZeroLocalRefcount(PyObject *);\n#endif\n\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n// Stable ABI implements Py_DECREF() as a function call on limited C API\n// version 3.12 and newer, and on Python built in debug mode. _Py_DecRef() was\n// added to Python 3.10.0a7, use Py_DecRef() on older Python versions.\n// Py_DecRef() accepts NULL whereas _Py_IncRef() doesn't.\nstatic inline void Py_DECREF(PyObject *op) {\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_DecRef(op);\n#  else\n    Py_DecRef(op);\n#  endif\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_GIL_DISABLED) && defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        if (local == 0) {\n            _Py_NegativeRefcount(filename, lineno, op);\n        }\n        local--;\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, local);\n        if (local == 0) {\n            _Py_MergeZeroLocalRefcount(op);\n        }\n    }\n    else {\n        _Py_DecRefSharedDebug(op, filename, lineno);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#elif defined(Py_GIL_DISABLED)\nstatic inline void Py_DECREF(PyObject *op)\n{\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        local--;\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, local);\n        if (local == 0) {\n            _Py_MergeZeroLocalRefcount(op);\n        }\n    }\n    else {\n        _Py_DecRefShared(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    if (op->ob_refcnt <= 0) {\n        _Py_NegativeRefcount(filename, lineno, op);\n    }\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#else\nstatic inline Py_ALWAYS_INLINE void Py_DECREF(PyObject *op)\n{\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n#endif\n\n\n/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear\n * and tp_dealloc implementations.\n *\n * Note that \"the obvious\" code can be deadly:\n *\n *     Py_XDECREF(op);\n *     op = NULL;\n *\n * Typically, `op` is something like self->containee, and `self` is done\n * using its `containee` member.  In the code sequence above, suppose\n * `containee` is non-NULL with a refcount of 1.  Its refcount falls to\n * 0 on the first line, which can trigger an arbitrary amount of code,\n * possibly including finalizers (like __del__ methods or weakref callbacks)\n * coded in Python, which in turn can release the GIL and allow other threads\n * to run, etc.  Such code may even invoke methods of `self` again, or cause\n * cyclic gc to trigger, but-- oops! --self->containee still points to the\n * object being torn down, and it may be in an insane state while being torn\n * down.  This has in fact been a rich historic source of miserable (rare &\n * hard-to-diagnose) segfaulting (and other) bugs.\n *\n * The safe way is:\n *\n *      Py_CLEAR(op);\n *\n * That arranges to set `op` to NULL _before_ decref'ing, so that any code\n * triggered as a side-effect of `op` getting torn down no longer believes\n * `op` points to a valid object.\n *\n * There are cases where it's safe to use the naive code, but they're brittle.\n * For example, if `op` points to a Python integer, you know that destroying\n * one of those can't cause problems -- but in part that relies on that\n * Python integers aren't currently weakly referencable.  Best practice is\n * to use Py_CLEAR() even if you can't think of a reason for why you need to.\n *\n * gh-98724: Use a temporary variable to only evaluate the macro argument once,\n * to avoid the duplication of side effects if the argument has side effects.\n *\n * gh-99701: If the PyObject* type is used with casting arguments to PyObject*,\n * the code can be miscompiled with strict aliasing because of type punning.\n * With strict aliasing, a compiler considers that two pointers of different\n * types cannot read or write the same memory which enables optimization\n * opportunities.\n *\n * If available, use _Py_TYPEOF() to use the 'op' type for temporary variables,\n * and so avoid type punning. Otherwise, use memcpy() which causes type erasure\n * and so prevents the compiler to reuse an old cached 'op' value after\n * Py_CLEAR().\n */\n#ifdef _Py_TYPEOF\n#define Py_CLEAR(op) \\\n    do { \\\n        _Py_TYPEOF(op)* _tmp_op_ptr = &(op); \\\n        _Py_TYPEOF(op) _tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            *_tmp_op_ptr = _Py_NULL; \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#else\n#define Py_CLEAR(op) \\\n    do { \\\n        PyObject **_tmp_op_ptr = _Py_CAST(PyObject**, &(op)); \\\n        PyObject *_tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            PyObject *_null_ptr = _Py_NULL; \\\n            memcpy(_tmp_op_ptr, &_null_ptr, sizeof(PyObject*)); \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#endif\n\n\n/* Function to use in case the object pointer can be NULL: */\nstatic inline void Py_XINCREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_INCREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XINCREF(op) Py_XINCREF(_PyObject_CAST(op))\n#endif\n\nstatic inline void Py_XDECREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_DECREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XDECREF(op) Py_XDECREF(_PyObject_CAST(op))\n#endif\n\n// Create a new strong reference to an object:\n// increment the reference count of the object and return the object.\nPyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);\n\n// Similar to Py_NewRef(), but the object can be NULL.\nPyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);\n\nstatic inline PyObject* _Py_NewRef(PyObject *obj)\n{\n    Py_INCREF(obj);\n    return obj;\n}\n\nstatic inline PyObject* _Py_XNewRef(PyObject *obj)\n{\n    Py_XINCREF(obj);\n    return obj;\n}\n\n// Py_NewRef() and Py_XNewRef() are exported as functions for the stable ABI.\n// Names overridden with macros by static inline functions for best\n// performances.\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_NewRef(obj) _Py_NewRef(_PyObject_CAST(obj))\n#  define Py_XNewRef(obj) _Py_XNewRef(_PyObject_CAST(obj))\n#else\n#  define Py_NewRef(obj) _Py_NewRef(obj)\n#  define Py_XNewRef(obj) _Py_XNewRef(obj)\n#endif\n\n\n#define Py_CONSTANT_NONE 0\n#define Py_CONSTANT_FALSE 1\n#define Py_CONSTANT_TRUE 2\n#define Py_CONSTANT_ELLIPSIS 3\n#define Py_CONSTANT_NOT_IMPLEMENTED 4\n#define Py_CONSTANT_ZERO 5\n#define Py_CONSTANT_ONE 6\n#define Py_CONSTANT_EMPTY_STR 7\n#define Py_CONSTANT_EMPTY_BYTES 8\n#define Py_CONSTANT_EMPTY_TUPLE 9\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(PyObject*) Py_GetConstant(unsigned int constant_id);\nPyAPI_FUNC(PyObject*) Py_GetConstantBorrowed(unsigned int constant_id);\n#endif\n\n\n/*\n_Py_NoneStruct is an object of undefined type which can be used in contexts\nwhere NULL (nil) is not suitable (since NULL often means 'error').\n*/\nPyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000\n#  define Py_None Py_GetConstantBorrowed(Py_CONSTANT_NONE)\n#else\n#  define Py_None (&_Py_NoneStruct)\n#endif\n\n// Test if an object is the None singleton, the same as \"x is None\" in Python.\nPyAPI_FUNC(int) Py_IsNone(PyObject *x);\n#define Py_IsNone(x) Py_Is((x), Py_None)\n\n/* Macro for returning Py_None from a function */\n#define Py_RETURN_NONE return Py_None\n\n/*\nPy_NotImplemented is a singleton used to signal that an operation is\nnot implemented for a given type combination.\n*/\nPyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */\n\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000\n#  define Py_NotImplemented Py_GetConstantBorrowed(Py_CONSTANT_NOT_IMPLEMENTED)\n#else\n#  define Py_NotImplemented (&_Py_NotImplementedStruct)\n#endif\n\n/* Macro for returning Py_NotImplemented from a function */\n#define Py_RETURN_NOTIMPLEMENTED return Py_NotImplemented\n\n/* Rich comparison opcodes */\n#define Py_LT 0\n#define Py_LE 1\n#define Py_EQ 2\n#define Py_NE 3\n#define Py_GT 4\n#define Py_GE 5\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000\n/* Result of calling PyIter_Send */\ntypedef enum {\n    PYGEN_RETURN = 0,\n    PYGEN_ERROR = -1,\n    PYGEN_NEXT = 1,\n} PySendResult;\n#endif\n\n/*\n * Macro for implementing rich comparisons\n *\n * Needs to be a macro because any C-comparable type can be used.\n */\n#define Py_RETURN_RICHCOMPARE(val1, val2, op)                               \\\n    do {                                                                    \\\n        switch (op) {                                                       \\\n        case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        default:                                                            \\\n            Py_UNREACHABLE();                                               \\\n        }                                                                   \\\n    } while (0)\n\n\n/*\nMore conventions\n================\n\nArgument Checking\n-----------------\n\nFunctions that take objects as arguments normally don't check for nil\narguments, but they do check the type of the argument, and return an\nerror if the function doesn't apply to the type.\n\nFailure Modes\n-------------\n\nFunctions may fail for a variety of reasons, including running out of\nmemory.  This is communicated to the caller in two ways: an error string\nis set (see errors.h), and the function result differs: functions that\nnormally return a pointer return NULL for failure, functions returning\nan integer return -1 (which could be a legal return value too!), and\nother functions return 0 for success and -1 for failure.\nCallers should always check for errors before using the result.  If\nan error was set, the caller must either explicitly clear it, or pass\nthe error on to its caller.\n\nReference Counts\n----------------\n\nIt takes a while to get used to the proper usage of reference counts.\n\nFunctions that create an object set the reference count to 1; such new\nobjects must be stored somewhere or destroyed again with Py_DECREF().\nSome functions that 'store' objects, such as PyTuple_SetItem() and\nPyList_SetItem(),\ndon't increment the reference count of the object, since the most\nfrequent use is to store a fresh object.  Functions that 'retrieve'\nobjects, such as PyTuple_GetItem() and PyDict_GetItemString(), also\ndon't increment\nthe reference count, since most frequently the object is only looked at\nquickly.  Thus, to retrieve an object and store it again, the caller\nmust call Py_INCREF() explicitly.\n\nNOTE: functions that 'consume' a reference count, like\nPyList_SetItem(), consume the reference even if the object wasn't\nsuccessfully stored, to simplify error handling.\n\nIt seems attractive to make other functions that take an object as\nargument consume a reference count; however, this may quickly get\nconfusing (even the current practice is already confusing).  Consider\nit carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at\ntimes.\n*/\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_OBJECT_H\n#  include \"cpython/object.h\"\n#  undef Py_CPYTHON_OBJECT_H\n#endif\n\n\nstatic inline int\nPyType_HasFeature(PyTypeObject *type, unsigned long feature)\n{\n    unsigned long flags;\n#ifdef Py_LIMITED_API\n    // PyTypeObject is opaque in the limited C API\n    flags = PyType_GetFlags(type);\n#else\n#   ifdef Py_GIL_DISABLED\n        flags = _Py_atomic_load_ulong_relaxed(&type->tp_flags);\n#   else\n        flags = type->tp_flags;\n#   endif\n#endif\n    return ((flags & feature) != 0);\n}\n\n#define PyType_FastSubclass(type, flag) PyType_HasFeature((type), (flag))\n\nstatic inline int PyType_Check(PyObject *op) {\n    return PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_Check(op) PyType_Check(_PyObject_CAST(op))\n#endif\n\n#define _PyType_CAST(op) \\\n    (assert(PyType_Check(op)), _Py_CAST(PyTypeObject*, (op)))\n\nstatic inline int PyType_CheckExact(PyObject *op) {\n    return Py_IS_TYPE(op, &PyType_Type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_CheckExact(op) PyType_CheckExact(_PyObject_CAST(op))\n#endif\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(PyObject *) PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif   // !Py_OBJECT_H\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-null-dereference", "taxa": [{"id": "476", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "dereference of NULL 'op'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 305, "startColumn": 12, "endColumn": 22}, "contextRegion": {"startLine": 305, "snippet": {"text": "    return ob->ob_tid == _Py_ThreadId();\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_collectionsmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1407, "startColumn": 1, "endColumn": 15}, "contextRegion": {"startLine": 1407, "snippet": {"text": "deque_del_item(dequeobject *deque, Py_ssize_t i)\n"}}}, "logicalLocations": [{"name": "deque_del_item", "fullyQualifiedName": "deque_del_item", "decoratedName": "deque_del_item", "kind": "function"}], "message": {"text": "entry to 'deque_del_item'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_collectionsmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1413, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1413, "snippet": {"text": "    if (_deque_rotate(deque, -i))\n"}}}, "logicalLocations": [{"name": "deque_del_item", "fullyQualifiedName": "deque_del_item", "decoratedName": "deque_del_item", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_collectionsmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1415, "startColumn": 5, "endColumn": 9}, "contextRegion": {"startLine": 1415, "snippet": {"text": "    item = deque_popleft_impl(deque);\n"}}}, "logicalLocations": [{"name": "deque_del_item", "fullyQualifiedName": "deque_del_item", "decoratedName": "deque_del_item", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_collectionsmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1415, "startColumn": 12, "endColumn": 37}, "contextRegion": {"startLine": 1415, "snippet": {"text": "    item = deque_popleft_impl(deque);\n"}}}, "logicalLocations": [{"name": "deque_del_item", "fullyQualifiedName": "deque_del_item", "decoratedName": "deque_del_item", "kind": "function"}], "message": {"text": "calling 'deque_popleft_impl' from 'deque_del_item'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_collectionsmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 287, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 287, "snippet": {"text": "deque_popleft_impl(dequeobject *deque)\n"}}}, "logicalLocations": [{"name": "deque_popleft_impl", "fullyQualifiedName": "deque_popleft_impl", "decoratedName": "deque_popleft_impl", "kind": "function"}], "message": {"text": "entry to 'deque_popleft_impl'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_collectionsmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 293, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 293, "snippet": {"text": "    if (Py_SIZE(deque) == 0) {\n"}}}, "logicalLocations": [{"name": "deque_popleft_impl", "fullyQualifiedName": "deque_popleft_impl", "decoratedName": "deque_popleft_impl", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"logicalLocations": [{"name": "deque_popleft_impl", "fullyQualifiedName": "deque_popleft_impl", "decoratedName": "deque_popleft_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_collectionsmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1415, "startColumn": 12, "endColumn": 37}, "contextRegion": {"startLine": 1415, "snippet": {"text": "    item = deque_popleft_impl(deque);\n"}}}, "logicalLocations": [{"name": "deque_del_item", "fullyQualifiedName": "deque_del_item", "decoratedName": "deque_del_item", "kind": "function"}], "message": {"text": "return of NULL to 'deque_del_item' from 'deque_popleft_impl'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_collectionsmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1418, "snippet": {"text": "    Py_DECREF(item);\n"}}}, "logicalLocations": [{"name": "deque_del_item", "fullyQualifiedName": "deque_del_item", "decoratedName": "deque_del_item", "kind": "function"}], "message": {"text": "calling 'Py_DECREF' from 'deque_del_item'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 896, "startColumn": 20, "endColumn": 29}, "contextRegion": {"startLine": 896, "snippet": {"text": "static inline void Py_DECREF(PyObject *op)\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "entry to 'Py_DECREF'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 899, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 899, "snippet": {"text": "    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 902, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 902, "snippet": {"text": "    _Py_DECREF_STAT_INC();\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 903, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 903, "snippet": {"text": "    if (_Py_IsOwnedByCurrentThread(op)) {\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "inlined call to '_Py_IsOwnedByCurrentThread' from 'Py_DECREF'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 305, "startColumn": 12, "endColumn": 22}, "contextRegion": {"startLine": 305, "snippet": {"text": "    return ob->ob_tid == _Py_ThreadId();\n"}}}, "logicalLocations": [{"name": "_Py_IsOwnedByCurrentThread", "fullyQualifiedName": "_Py_IsOwnedByCurrentThread", "decoratedName": "_Py_IsOwnedByCurrentThread", "kind": "function"}], "message": {"text": "dereference of NULL 'op'"}}, "kinds": ["danger"], "nestingLevel": 3}]}]}]}]}]}
