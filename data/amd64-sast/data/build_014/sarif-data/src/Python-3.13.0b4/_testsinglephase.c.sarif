{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-null-dereference", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-dereference"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "476", "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.13.0b4/"}}, "artifacts": [{"location": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "contents": {"text": "\n/* Testing module for single-phase initialization of extension modules\n\nThis file contains 8 distinct modules, meaning each as its own name\nand its own init function (PyInit_...).  The default import system will\nonly find the one matching the filename: _testsinglephase.  To load the\nothers you must do so manually.  For example:\n\n```python\nname = '_testsinglephase_base_wrapper'\nfilename = _testsinglephase.__file__\nloader = importlib.machinery.ExtensionFileLoader(name, filename)\nspec = importlib.util.spec_from_file_location(name, filename, loader=loader)\nmod = importlib._bootstrap._load(spec)\n```\n\nHere are the 8 modules:\n\n* _testsinglephase\n   * def: _testsinglephase_basic,\n      * m_name: \"_testsinglephase\"\n      * m_size: -1\n   * state\n      * process-global\n         * <int> initialized_count  (default to -1; will never be 0)\n         * <module_state> module  (see module state below)\n      * module state: no\n      * initial __dict__: see common initial __dict__ below\n   * init function\n      1. create module\n      2. clear <global>.module\n      3. initialize <global>.module: see module state below\n      4. initialize module: set initial __dict__\n      5. increment <global>.initialized_count\n   * functions\n      * (3 common, see below)\n      * initialized_count() - return <global>.module.initialized_count\n   * import system\n      * caches\n         * global extensions cache: yes\n         * def.m_base.m_copy: yes\n         * def.m_base.m_init: no\n         * per-interpreter cache: yes  (all single-phase init modules)\n      * load in main interpreter\n         * initial  (not already in global cache)\n            1. get init function from shared object file\n            2. run init function\n            3. copy __dict__ into def.m_base.m_copy\n            4. set entry in global cache\n            5. set entry in per-interpreter cache\n            6. set entry in sys.modules\n         * reload  (already in sys.modules)\n            1. get def from global cache\n            2. get module from sys.modules\n            3. update module with contents of def.m_base.m_copy\n         * already loaded in other interpreter  (already in global cache)\n            * same as reload, but create new module and update *it*\n         * not in any sys.modules, still in global cache\n            * same as already loaded\n      * load in legacy (non-isolated) interpreter\n         * same as main interpreter\n      * unload: never  (all single-phase init modules)\n* _testsinglephase_basic_wrapper\n   * identical to _testsinglephase except module name\n* _testsinglephase_basic_copy\n   * def: static local variable in init function\n      * m_name: \"_testsinglephase_basic_copy\"\n      * m_size: -1\n   * state: same as _testsinglephase\n   * init function: same as _testsinglephase\n   * functions: same as _testsinglephase\n   * import system: same as _testsinglephase\n* _testsinglephase_with_reinit\n   * def: _testsinglephase_with_reinit,\n      * m_name: \"_testsinglephase_with_reinit\"\n      * m_size: 0\n   * state\n      * process-global state: no\n      * module state: no\n      * initial __dict__: see common initial __dict__ below\n   * init function\n      1. create module\n      2. initialize temporary module state (local var): see module state below\n      3. initialize module: set initial __dict__\n   * functions: see common functions below\n   * import system\n      * caches\n         * global extensions cache: only if loaded in main interpreter\n         * def.m_base.m_copy: no\n         * def.m_base.m_init: only if loaded in the main interpreter\n         * per-interpreter cache: yes  (all single-phase init modules)\n      * load in main interpreter\n         * initial  (not already in global cache)\n            * (same as _testsinglephase except step 3)\n            1. get init function from shared object file\n            2. run init function\n            3. set def.m_base.m_init to the init function\n            4. set entry in global cache\n            5. set entry in per-interpreter cache\n            6. set entry in sys.modules\n         * reload  (already in sys.modules)\n            1. get def from global cache\n            2. call def->m_base.m_init to get a new module object\n            3. replace the existing module in sys.modules\n         * already loaded in other interpreter  (already in global cache)\n            * same as reload (since will only be in cache for main interp)\n         * not in any sys.modules, still in global cache\n            * same as already loaded\n      * load in legacy (non-isolated) interpreter\n         * initial  (not already in global cache)\n            * (same as main interpreter except skip steps 3 & 4 there)\n            1. get init function from shared object file\n            2. run init function\n            ...\n            5. set entry in per-interpreter cache\n            6. set entry in sys.modules\n         * reload  (already in sys.modules)\n            * same as initial  (load from scratch)\n         * already loaded in other interpreter  (already in global cache)\n            * same as initial  (load from scratch)\n         * not in any sys.modules, still in global cache\n            * same as initial  (load from scratch)\n      * unload: never  (all single-phase init modules)\n* _testsinglephase_with_state\n   * def: _testsinglephase_with_state,\n      * m_name: \"_testsinglephase_with_state\"\n      * m_size: sizeof(module_state)\n   * state\n      * process-global: no\n      * module state: see module state below\n      * initial __dict__: see common initial __dict__ below\n   * init function\n      1. create module\n      3. initialize module state: see module state below\n      4. initialize module: set initial __dict__\n      5. increment <global>.initialized_count\n   * functions: see common functions below\n   * import system: same as _testsinglephase_basic_copy\n* _testsinglephase_check_cache_first\n   * def: _testsinglepahse_check_cache_first\n      * m_name: \"_testsinglephase_check_cache_first\"\n      * m_size: -1\n   * state: none\n   * init function:\n      * tries PyState_FindModule() first\n      * otherwise creates empty module\n   * functions: none\n   * import system: same as _testsinglephase\n* _testsinglephase_with_reinit_check_cache_first\n   * def: _testsinglepahse_with_reinit_check_cache_first\n      * m_name: \"_testsinglephase_with_reinit_check_cache_first\"\n      * m_size: 0\n   * state: none\n   * init function: same as _testsinglephase_check_cache_first\n   * functions: none\n   * import system: same as _testsinglephase_with_reinit\n* _testsinglephase_with_state_check_cache_first\n   * def: _testsinglepahse_with_state_check_cache_first\n      * m_name: \"_testsinglephase_with_state_check_cache_first\"\n      * m_size: 42\n   * state: none\n   * init function: same as _testsinglephase_check_cache_first\n   * functions: none\n   * import system: same as _testsinglephase_with_state\n\nModule state:\n\n* fields\n   * <PyTime_t> initialized - when the module was first initialized\n   * <PyObject> *error\n   * <PyObject> *int_const\n   * <PyObject> *str_const\n* initialization\n   1. set state.initialized to the current time\n   2. set state.error to a new exception class\n   3. set state->int_const to int(1969)\n   4. set state->str_const to \"something different\"\n\nCommon initial __dict__:\n\n* error: state.error\n* int_const: state.int_const\n* str_const: state.str_const\n* _module_initialized: state.initialized\n\nCommon functions:\n\n* look_up_self() - return the module from the per-interpreter \"by-index\" cache\n* sum() - return a + b\n* state_initialized() - return state->initialized (or None if m_size == 0)\n\nSee Python/import.c, especially the long comments, for more about\nsingle-phase init modules.\n*/\n\n#ifndef Py_BUILD_CORE_BUILTIN\n#  define Py_BUILD_CORE_MODULE 1\n#endif\n\n//#include <time.h>\n#include \"Python.h\"\n#include \"pycore_namespace.h\"     // _PyNamespace_New()\n\n\ntypedef struct {\n    PyTime_t initialized;\n    PyObject *error;\n    PyObject *int_const;\n    PyObject *str_const;\n} module_state;\n\n\n/* Process-global state is only used by _testsinglephase\n   since it's the only one that does not support re-init. */\nstatic struct {\n    int initialized_count;\n    module_state module;\n} global_state = {\n\n#define NOT_INITIALIZED -1\n    .initialized_count = NOT_INITIALIZED,\n};\n\nstatic void clear_state(module_state *state);\n\nstatic void\nclear_global_state(void)\n{\n    clear_state(&global_state.module);\n    global_state.initialized_count = NOT_INITIALIZED;\n}\n\n\nstatic inline module_state *\nget_module_state(PyObject *module)\n{\n    PyModuleDef *def = PyModule_GetDef(module);\n    if (def->m_size == -1) {\n        return &global_state.module;\n    }\n    else if (def->m_size == 0) {\n        return NULL;\n    }\n    else {\n        module_state *state = (module_state*)PyModule_GetState(module);\n        assert(state != NULL);\n        return state;\n    }\n}\n\nstatic void\nclear_state(module_state *state)\n{\n    state->initialized = 0;\n    Py_CLEAR(state->error);\n    Py_CLEAR(state->int_const);\n    Py_CLEAR(state->str_const);\n}\n\nstatic int\n_set_initialized(PyTime_t *initialized)\n{\n    /* We go strictly monotonic to ensure each time is unique. */\n    PyTime_t prev;\n    if (PyTime_Monotonic(&prev) != 0) {\n        return -1;\n    }\n    /* We do a busy sleep since the interval should be super short. */\n    PyTime_t t;\n    do {\n        if (PyTime_Monotonic(&t) != 0) {\n            return -1;\n        }\n    } while (t == prev);\n\n    *initialized = t;\n    return 0;\n}\n\nstatic int\ninit_state(module_state *state)\n{\n    assert(state->initialized == 0 &&\n           state->error == NULL &&\n           state->int_const == NULL &&\n           state->str_const == NULL);\n\n    if (_set_initialized(&state->initialized) != 0) {\n        goto error;\n    }\n    assert(state->initialized > 0);\n\n    /* Add an exception type */\n    state->error = PyErr_NewException(\"_testsinglephase.error\", NULL, NULL);\n    if (state->error == NULL) {\n        goto error;\n    }\n\n    state->int_const = PyLong_FromLong(1969);\n    if (state->int_const == NULL) {\n        goto error;\n    }\n\n    state->str_const = PyUnicode_FromString(\"something different\");\n    if (state->str_const == NULL) {\n        goto error;\n    }\n\n    return 0;\n\nerror:\n    clear_state(state);\n    return -1;\n}\n\n\nstatic int\ninit_module(PyObject *module, module_state *state)\n{\n    if (PyModule_AddObjectRef(module, \"error\", state->error) != 0) {\n        return -1;\n    }\n    if (PyModule_AddObjectRef(module, \"int_const\", state->int_const) != 0) {\n        return -1;\n    }\n    if (PyModule_AddObjectRef(module, \"str_const\", state->str_const) != 0) {\n        return -1;\n    }\n\n    double d = PyTime_AsSecondsDouble(state->initialized);\n    if (PyModule_Add(module, \"_module_initialized\", PyFloat_FromDouble(d)) < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n\n\nPyDoc_STRVAR(common_state_initialized_doc,\n\"state_initialized()\\n\\\n\\n\\\nReturn the seconds-since-epoch when the module state was initialized.\");\n\nstatic PyObject *\ncommon_state_initialized(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    module_state *state = get_module_state(self);\n    if (state == NULL) {\n        Py_RETURN_NONE;\n    }\n    double d = PyTime_AsSecondsDouble(state->initialized);\n    return PyFloat_FromDouble(d);\n}\n\n#define STATE_INITIALIZED_METHODDEF \\\n    {\"state_initialized\", common_state_initialized, METH_NOARGS, \\\n     common_state_initialized_doc}\n\n\nPyDoc_STRVAR(common_look_up_self_doc,\n\"look_up_self()\\n\\\n\\n\\\nReturn the module associated with this module's def.m_base.m_index.\");\n\nstatic PyObject *\ncommon_look_up_self(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    PyModuleDef *def = PyModule_GetDef(self);\n    if (def == NULL) {\n        return NULL;\n    }\n    return Py_NewRef(\n            PyState_FindModule(def));\n}\n\n#define LOOK_UP_SELF_METHODDEF \\\n    {\"look_up_self\", common_look_up_self, METH_NOARGS, common_look_up_self_doc}\n\n\n/* Function of two integers returning integer */\n\nPyDoc_STRVAR(common_sum_doc,\n\"sum(i,j)\\n\\\n\\n\\\nReturn the sum of i and j.\");\n\nstatic PyObject *\ncommon_sum(PyObject *self, PyObject *args)\n{\n    long i, j;\n    long res;\n    if (!PyArg_ParseTuple(args, \"ll:sum\", &i, &j))\n        return NULL;\n    res = i + j;\n    return PyLong_FromLong(res);\n}\n\n#define SUM_METHODDEF \\\n    {\"sum\", common_sum, METH_VARARGS, common_sum_doc}\n\n\nPyDoc_STRVAR(basic_initialized_count_doc,\n\"initialized_count()\\n\\\n\\n\\\nReturn how many times the module has been initialized.\");\n\nstatic PyObject *\nbasic_initialized_count(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    assert(PyModule_GetDef(self)->m_size == -1);\n    return PyLong_FromLong(global_state.initialized_count);\n}\n\n#define INITIALIZED_COUNT_METHODDEF \\\n    {\"initialized_count\", basic_initialized_count, METH_NOARGS, \\\n     basic_initialized_count_doc}\n\n\nPyDoc_STRVAR(basic__clear_globals_doc,\n\"_clear_globals()\\n\\\n\\n\\\nFree all global state and set it to uninitialized.\");\n\nstatic PyObject *\nbasic__clear_globals(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    assert(PyModule_GetDef(self)->m_size == -1);\n    clear_global_state();\n    Py_RETURN_NONE;\n}\n\n#define _CLEAR_GLOBALS_METHODDEF \\\n    {\"_clear_globals\", basic__clear_globals, METH_NOARGS, \\\n     basic__clear_globals_doc}\n\n\nPyDoc_STRVAR(basic__clear_module_state_doc, \"_clear_module_state()\\n\\\n\\n\\\nFree the module state and set it to uninitialized.\");\n\nstatic PyObject *\nbasic__clear_module_state(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    module_state *state = get_module_state(self);\n    if (state != NULL) {\n        clear_state(state);\n    }\n    Py_RETURN_NONE;\n}\n\n#define _CLEAR_MODULE_STATE_METHODDEF \\\n    {\"_clear_module_state\", basic__clear_module_state, METH_NOARGS, \\\n     basic__clear_module_state_doc}\n\n\n/*********************************************/\n/* the _testsinglephase module (and aliases) */\n/*********************************************/\n\n/* This ia more typical of legacy extensions in the wild:\n   - single-phase init\n   - no module state\n   - does not support repeated initialization\n    (so m_copy is used)\n   - the module def is cached in _PyRuntime.extensions\n     (by name/filename)\n\n   Also note that, because the module has single-phase init,\n   it is cached in interp->module_by_index (using mod->md_def->m_base.m_index).\n */\n\nstatic PyMethodDef TestMethods_Basic[] = {\n    LOOK_UP_SELF_METHODDEF,\n    SUM_METHODDEF,\n    STATE_INITIALIZED_METHODDEF,\n    INITIALIZED_COUNT_METHODDEF,\n    _CLEAR_GLOBALS_METHODDEF,\n    {NULL, NULL}           /* sentinel */\n};\n\nstatic struct PyModuleDef _testsinglephase_basic = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = \"_testsinglephase\",\n    .m_doc = PyDoc_STR(\"Test module _testsinglephase\"),\n    .m_size = -1,  // no module state\n    .m_methods = TestMethods_Basic,\n};\n\nstatic PyObject *\ninit__testsinglephase_basic(PyModuleDef *def)\n{\n    if (global_state.initialized_count == -1) {\n        global_state.initialized_count = 0;\n    }\n\n    PyObject *module = PyModule_Create(def);\n    if (module == NULL) {\n        return NULL;\n    }\n#ifdef Py_GIL_DISABLED\n    PyUnstable_Module_SetGIL(module, Py_MOD_GIL_NOT_USED);\n#endif\n\n    module_state *state = &global_state.module;\n    // It may have been set by a previous run or under a different name.\n    clear_state(state);\n    if (init_state(state) < 0) {\n        Py_CLEAR(module);\n        return NULL;\n    }\n\n    if (init_module(module, state) < 0) {\n        Py_CLEAR(module);\n        goto finally;\n    }\n\n    global_state.initialized_count++;\n\nfinally:\n    return module;\n}\n\nPyMODINIT_FUNC\nPyInit__testsinglephase(void)\n{\n    return init__testsinglephase_basic(&_testsinglephase_basic);\n}\n\n\nPyMODINIT_FUNC\nPyInit__testsinglephase_basic_wrapper(void)\n{\n    return PyInit__testsinglephase();\n}\n\n\nPyMODINIT_FUNC\nPyInit__testsinglephase_basic_copy(void)\n{\n    static struct PyModuleDef def = {\n        PyModuleDef_HEAD_INIT,\n        .m_name = \"_testsinglephase_basic_copy\",\n        .m_doc = PyDoc_STR(\"Test module _testsinglephase_basic_copy\"),\n        .m_size = -1,  // no module state\n        .m_methods = TestMethods_Basic,\n    };\n    return init__testsinglephase_basic(&def);\n}\n\n\n/*******************************************/\n/* the _testsinglephase_with_reinit module */\n/*******************************************/\n\n/* This ia less typical of legacy extensions in the wild:\n   - single-phase init  (same as _testsinglephase above)\n   - no module state\n   - supports repeated initialization\n     (so m_copy is not used)\n   - the module def is not cached in _PyRuntime.extensions\n\n   At this point most modules would reach for multi-phase init (PEP 489).\n   However, module state has been around a while (PEP 3121),\n   and most extensions predate multi-phase init.\n\n   (This module is basically the same as _testsinglephase,\n    but supports repeated initialization.)\n */\n\nstatic PyMethodDef TestMethods_Reinit[] = {\n    LOOK_UP_SELF_METHODDEF,\n    SUM_METHODDEF,\n    STATE_INITIALIZED_METHODDEF,\n    {NULL, NULL}           /* sentinel */\n};\n\nstatic struct PyModuleDef _testsinglephase_with_reinit = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = \"_testsinglephase_with_reinit\",\n    .m_doc = PyDoc_STR(\"Test module _testsinglephase_with_reinit\"),\n    .m_size = 0,\n    .m_methods = TestMethods_Reinit,\n};\n\nPyMODINIT_FUNC\nPyInit__testsinglephase_with_reinit(void)\n{\n    /* We purposefully do not try PyState_FindModule() first here\n       since we want to check the behavior of re-loading the module. */\n    PyObject *module = PyModule_Create(&_testsinglephase_with_reinit);\n    if (module == NULL) {\n        return NULL;\n    }\n#ifdef Py_GIL_DISABLED\n    PyUnstable_Module_SetGIL(module, Py_MOD_GIL_NOT_USED);\n#endif\n\n    assert(get_module_state(module) == NULL);\n\n    module_state state = {0};\n    if (init_state(&state) < 0) {\n        Py_CLEAR(module);\n        return NULL;\n    }\n\n    if (init_module(module, &state) < 0) {\n        Py_CLEAR(module);\n        goto finally;\n    }\n\nfinally:\n    /* We only needed the module state for setting the module attrs. */\n    clear_state(&state);\n    return module;\n}\n\n\n/******************************************/\n/* the _testsinglephase_with_state module */\n/******************************************/\n\n/* This is less typical of legacy extensions in the wild:\n   - single-phase init  (same as _testsinglephase above)\n   - has some module state\n   - supports repeated initialization\n     (so m_copy is not used)\n   - the module def is not cached in _PyRuntime.extensions\n\n   At this point most modules would reach for multi-phase init (PEP 489).\n   However, module state has been around a while (PEP 3121),\n   and most extensions predate multi-phase init.\n */\n\nstatic PyMethodDef TestMethods_WithState[] = {\n    LOOK_UP_SELF_METHODDEF,\n    SUM_METHODDEF,\n    STATE_INITIALIZED_METHODDEF,\n    _CLEAR_MODULE_STATE_METHODDEF,\n    {NULL, NULL}           /* sentinel */\n};\n\nstatic struct PyModuleDef _testsinglephase_with_state = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = \"_testsinglephase_with_state\",\n    .m_doc = PyDoc_STR(\"Test module _testsinglephase_with_state\"),\n    .m_size = sizeof(module_state),\n    .m_methods = TestMethods_WithState,\n};\n\nPyMODINIT_FUNC\nPyInit__testsinglephase_with_state(void)\n{\n    /* We purposefully do not try PyState_FindModule() first here\n       since we want to check the behavior of re-loading the module. */\n    PyObject *module = PyModule_Create(&_testsinglephase_with_state);\n    if (module == NULL) {\n        return NULL;\n    }\n#ifdef Py_GIL_DISABLED\n    PyUnstable_Module_SetGIL(module, Py_MOD_GIL_NOT_USED);\n#endif\n\n    module_state *state = get_module_state(module);\n    assert(state != NULL);\n    if (init_state(state) < 0) {\n        Py_CLEAR(module);\n        return NULL;\n    }\n\n    if (init_module(module, state) < 0) {\n        clear_state(state);\n        Py_CLEAR(module);\n        goto finally;\n    }\n\nfinally:\n    return module;\n}\n\n\n/****************************************************/\n/* the _testsinglephase_*_check_cache_first modules */\n/****************************************************/\n\n/* Each of these modules should only be freshly loaded.  That means\n   clearing the caches and each module def's m_base after each load. */\n\nstatic struct PyModuleDef _testsinglephase_check_cache_first = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = \"_testsinglephase_check_cache_first\",\n    .m_doc = PyDoc_STR(\"Test module _testsinglephase_check_cache_first\"),\n    .m_size = -1,  // no module state\n};\n\nPyMODINIT_FUNC\nPyInit__testsinglephase_check_cache_first(void)\n{\n    assert(_testsinglephase_check_cache_first.m_base.m_index == 0);\n    PyObject *mod = PyState_FindModule(&_testsinglephase_check_cache_first);\n    if (mod != NULL) {\n        return Py_NewRef(mod);\n    }\n    return PyModule_Create(&_testsinglephase_check_cache_first);\n}\n\n\nstatic struct PyModuleDef _testsinglephase_with_reinit_check_cache_first = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = \"_testsinglephase_with_reinit_check_cache_first\",\n    .m_doc = PyDoc_STR(\"Test module _testsinglephase_with_reinit_check_cache_first\"),\n    .m_size = 0,  // no module state\n};\n\nPyMODINIT_FUNC\nPyInit__testsinglephase_with_reinit_check_cache_first(void)\n{\n    assert(_testsinglephase_with_reinit_check_cache_first.m_base.m_index == 0);\n    PyObject *mod = PyState_FindModule(&_testsinglephase_with_reinit_check_cache_first);\n    if (mod != NULL) {\n        return Py_NewRef(mod);\n    }\n    return PyModule_Create(&_testsinglephase_with_reinit_check_cache_first);\n}\n\n\nstatic struct PyModuleDef _testsinglephase_with_state_check_cache_first = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = \"_testsinglephase_with_state_check_cache_first\",\n    .m_doc = PyDoc_STR(\"Test module _testsinglephase_with_state_check_cache_first\"),\n    .m_size = 42,  // not used\n};\n\nPyMODINIT_FUNC\nPyInit__testsinglephase_with_state_check_cache_first(void)\n{\n    assert(_testsinglephase_with_state_check_cache_first.m_base.m_index == 0);\n    PyObject *mod = PyState_FindModule(&_testsinglephase_with_state_check_cache_first);\n    if (mod != NULL) {\n        return Py_NewRef(mod);\n    }\n    return PyModule_Create(&_testsinglephase_with_state_check_cache_first);\n}\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-null-dereference", "taxa": [{"id": "476", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "dereference of NULL 'state'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 254, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 254, "snippet": {"text": "    state->initialized = 0;\n"}}}, "logicalLocations": [{"name": "clear_state", "fullyQualifiedName": "clear_state", "decoratedName": "clear_state", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 651, "startColumn": 1, "endColumn": 35}, "contextRegion": {"startLine": 651, "snippet": {"text": "PyInit__testsinglephase_with_state(void)\n"}}}, "logicalLocations": [{"name": "PyInit__testsinglephase_with_state", "fullyQualifiedName": "PyInit__testsinglephase_with_state", "decoratedName": "PyInit__testsinglephase_with_state", "kind": "function"}], "message": {"text": "entry to 'PyInit__testsinglephase_with_state'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 656, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 656, "snippet": {"text": "    if (module == NULL) {\n"}}}, "logicalLocations": [{"name": "PyInit__testsinglephase_with_state", "fullyQualifiedName": "PyInit__testsinglephase_with_state", "decoratedName": "PyInit__testsinglephase_with_state", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 660, "startColumn": 5, "endColumn": 29}, "contextRegion": {"startLine": 660, "snippet": {"text": "    PyUnstable_Module_SetGIL(module, Py_MOD_GIL_NOT_USED);\n"}}}, "logicalLocations": [{"name": "PyInit__testsinglephase_with_state", "fullyQualifiedName": "PyInit__testsinglephase_with_state", "decoratedName": "PyInit__testsinglephase_with_state", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 663, "startColumn": 27, "endColumn": 51}, "contextRegion": {"startLine": 663, "snippet": {"text": "    module_state *state = get_module_state(module);\n"}}}, "logicalLocations": [{"name": "PyInit__testsinglephase_with_state", "fullyQualifiedName": "PyInit__testsinglephase_with_state", "decoratedName": "PyInit__testsinglephase_with_state", "kind": "function"}], "message": {"text": "calling 'get_module_state' from 'PyInit__testsinglephase_with_state'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 235, "startColumn": 1, "endColumn": 17}, "contextRegion": {"startLine": 235, "snippet": {"text": "get_module_state(PyObject *module)\n"}}}, "logicalLocations": [{"name": "get_module_state", "fullyQualifiedName": "get_module_state", "decoratedName": "get_module_state", "kind": "function"}], "message": {"text": "entry to 'get_module_state'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 238, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 238, "snippet": {"text": "    if (def->m_size == -1) {\n"}}}, "logicalLocations": [{"name": "get_module_state", "fullyQualifiedName": "get_module_state", "decoratedName": "get_module_state", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 241, "startColumn": 10, "endColumn": 12}, "contextRegion": {"startLine": 241, "snippet": {"text": "    else if (def->m_size == 0) {\n"}}}, "logicalLocations": [{"name": "get_module_state", "fullyQualifiedName": "get_module_state", "decoratedName": "get_module_state", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 241, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 241, "snippet": {"text": "    else if (def->m_size == 0) {\n"}}}, "logicalLocations": [{"name": "get_module_state", "fullyQualifiedName": "get_module_state", "decoratedName": "get_module_state", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"logicalLocations": [{"name": "get_module_state", "fullyQualifiedName": "get_module_state", "decoratedName": "get_module_state", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 663, "startColumn": 27, "endColumn": 51}, "contextRegion": {"startLine": 663, "snippet": {"text": "    module_state *state = get_module_state(module);\n"}}}, "logicalLocations": [{"name": "PyInit__testsinglephase_with_state", "fullyQualifiedName": "PyInit__testsinglephase_with_state", "decoratedName": "PyInit__testsinglephase_with_state", "kind": "function"}], "message": {"text": "return of NULL to 'PyInit__testsinglephase_with_state' from 'get_module_state'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 665, "startColumn": 9, "endColumn": 26}, "contextRegion": {"startLine": 665, "snippet": {"text": "    if (init_state(state) < 0) {\n"}}}, "logicalLocations": [{"name": "PyInit__testsinglephase_with_state", "fullyQualifiedName": "PyInit__testsinglephase_with_state", "decoratedName": "PyInit__testsinglephase_with_state", "kind": "function"}], "message": {"text": "calling 'init_state' from 'PyInit__testsinglephase_with_state'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 281, "startColumn": 1, "endColumn": 11}, "contextRegion": {"startLine": 281, "snippet": {"text": "init_state(module_state *state)\n"}}}, "logicalLocations": [{"name": "init_state", "fullyQualifiedName": "init_state", "decoratedName": "init_state", "kind": "function"}], "message": {"text": "entry to 'init_state'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 288, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 288, "snippet": {"text": "    if (_set_initialized(&state->initialized) != 0) {\n"}}}, "logicalLocations": [{"name": "init_state", "fullyQualifiedName": "init_state", "decoratedName": "init_state", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 289, "startColumn": 9, "endColumn": 13}, "contextRegion": {"startLine": 289, "snippet": {"text": "        goto error;\n"}}}, "logicalLocations": [{"name": "init_state", "fullyQualifiedName": "init_state", "decoratedName": "init_state", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 312, "startColumn": 5, "endColumn": 23}, "contextRegion": {"startLine": 312, "snippet": {"text": "    clear_state(state);\n"}}}, "logicalLocations": [{"name": "init_state", "fullyQualifiedName": "init_state", "decoratedName": "init_state", "kind": "function"}], "message": {"text": "calling 'clear_state' from 'init_state'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 252, "startColumn": 1, "endColumn": 12}, "contextRegion": {"startLine": 252, "snippet": {"text": "clear_state(module_state *state)\n"}}}, "logicalLocations": [{"name": "clear_state", "fullyQualifiedName": "clear_state", "decoratedName": "clear_state", "kind": "function"}], "message": {"text": "entry to 'clear_state'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 254, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 254, "snippet": {"text": "    state->initialized = 0;\n"}}}, "logicalLocations": [{"name": "clear_state", "fullyQualifiedName": "clear_state", "decoratedName": "clear_state", "kind": "function"}], "message": {"text": "dereference of NULL 'state'"}}, "kinds": ["danger"], "nestingLevel": 3}]}]}]}, {"ruleId": "-Wanalyzer-null-dereference", "taxa": [{"id": "476", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "dereference of NULL 'state'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 294, "startColumn": 5, "endColumn": 76}, "contextRegion": {"startLine": 294, "snippet": {"text": "    state->error = PyErr_NewException(\"_testsinglephase.error\", NULL, NULL);\n"}}}, "logicalLocations": [{"name": "init_state", "fullyQualifiedName": "init_state", "decoratedName": "init_state", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 651, "startColumn": 1, "endColumn": 35}, "contextRegion": {"startLine": 651, "snippet": {"text": "PyInit__testsinglephase_with_state(void)\n"}}}, "logicalLocations": [{"name": "PyInit__testsinglephase_with_state", "fullyQualifiedName": "PyInit__testsinglephase_with_state", "decoratedName": "PyInit__testsinglephase_with_state", "kind": "function"}], "message": {"text": "entry to 'PyInit__testsinglephase_with_state'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 656, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 656, "snippet": {"text": "    if (module == NULL) {\n"}}}, "logicalLocations": [{"name": "PyInit__testsinglephase_with_state", "fullyQualifiedName": "PyInit__testsinglephase_with_state", "decoratedName": "PyInit__testsinglephase_with_state", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 660, "startColumn": 5, "endColumn": 29}, "contextRegion": {"startLine": 660, "snippet": {"text": "    PyUnstable_Module_SetGIL(module, Py_MOD_GIL_NOT_USED);\n"}}}, "logicalLocations": [{"name": "PyInit__testsinglephase_with_state", "fullyQualifiedName": "PyInit__testsinglephase_with_state", "decoratedName": "PyInit__testsinglephase_with_state", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 663, "startColumn": 27, "endColumn": 51}, "contextRegion": {"startLine": 663, "snippet": {"text": "    module_state *state = get_module_state(module);\n"}}}, "logicalLocations": [{"name": "PyInit__testsinglephase_with_state", "fullyQualifiedName": "PyInit__testsinglephase_with_state", "decoratedName": "PyInit__testsinglephase_with_state", "kind": "function"}], "message": {"text": "calling 'get_module_state' from 'PyInit__testsinglephase_with_state'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 235, "startColumn": 1, "endColumn": 17}, "contextRegion": {"startLine": 235, "snippet": {"text": "get_module_state(PyObject *module)\n"}}}, "logicalLocations": [{"name": "get_module_state", "fullyQualifiedName": "get_module_state", "decoratedName": "get_module_state", "kind": "function"}], "message": {"text": "entry to 'get_module_state'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 238, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 238, "snippet": {"text": "    if (def->m_size == -1) {\n"}}}, "logicalLocations": [{"name": "get_module_state", "fullyQualifiedName": "get_module_state", "decoratedName": "get_module_state", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 241, "startColumn": 10, "endColumn": 12}, "contextRegion": {"startLine": 241, "snippet": {"text": "    else if (def->m_size == 0) {\n"}}}, "logicalLocations": [{"name": "get_module_state", "fullyQualifiedName": "get_module_state", "decoratedName": "get_module_state", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 241, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 241, "snippet": {"text": "    else if (def->m_size == 0) {\n"}}}, "logicalLocations": [{"name": "get_module_state", "fullyQualifiedName": "get_module_state", "decoratedName": "get_module_state", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"logicalLocations": [{"name": "get_module_state", "fullyQualifiedName": "get_module_state", "decoratedName": "get_module_state", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 663, "startColumn": 27, "endColumn": 51}, "contextRegion": {"startLine": 663, "snippet": {"text": "    module_state *state = get_module_state(module);\n"}}}, "logicalLocations": [{"name": "PyInit__testsinglephase_with_state", "fullyQualifiedName": "PyInit__testsinglephase_with_state", "decoratedName": "PyInit__testsinglephase_with_state", "kind": "function"}], "message": {"text": "return of NULL to 'PyInit__testsinglephase_with_state' from 'get_module_state'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 665, "startColumn": 9, "endColumn": 26}, "contextRegion": {"startLine": 665, "snippet": {"text": "    if (init_state(state) < 0) {\n"}}}, "logicalLocations": [{"name": "PyInit__testsinglephase_with_state", "fullyQualifiedName": "PyInit__testsinglephase_with_state", "decoratedName": "PyInit__testsinglephase_with_state", "kind": "function"}], "message": {"text": "calling 'init_state' from 'PyInit__testsinglephase_with_state'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 281, "startColumn": 1, "endColumn": 11}, "contextRegion": {"startLine": 281, "snippet": {"text": "init_state(module_state *state)\n"}}}, "logicalLocations": [{"name": "init_state", "fullyQualifiedName": "init_state", "decoratedName": "init_state", "kind": "function"}], "message": {"text": "entry to 'init_state'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 288, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 288, "snippet": {"text": "    if (_set_initialized(&state->initialized) != 0) {\n"}}}, "logicalLocations": [{"name": "init_state", "fullyQualifiedName": "init_state", "decoratedName": "init_state", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 291, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 291, "snippet": {"text": "    assert(state->initialized > 0);\n"}}}, "logicalLocations": [{"name": "init_state", "fullyQualifiedName": "init_state", "decoratedName": "init_state", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testsinglephase.c", "uriBaseId": "PWD"}, "region": {"startLine": 294, "startColumn": 5, "endColumn": 76}, "contextRegion": {"startLine": 294, "snippet": {"text": "    state->error = PyErr_NewException(\"_testsinglephase.error\", NULL, NULL);\n"}}}, "logicalLocations": [{"name": "init_state", "fullyQualifiedName": "init_state", "decoratedName": "init_state", "kind": "function"}], "message": {"text": "dereference of NULL 'state'"}}, "kinds": ["danger"], "nestingLevel": 2}]}]}]}]}]}
