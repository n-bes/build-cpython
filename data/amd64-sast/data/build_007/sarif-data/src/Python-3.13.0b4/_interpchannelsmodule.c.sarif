{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-null-dereference",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-dereference"}]}},
           "taxonomies": [{"name": "CWE",
                           "version": "4.7",
                           "organization": "MITRE",
                           "shortDescription": {"text": "The MITRE Common Weakness Enumeration"},
                           "taxa": [{"id": "476",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}],
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.13.0b4/"}},
           "artifacts": [{"location": {"uri": "./Modules/_interpchannelsmodule.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/* interpreters module */\n/* low-level access to interpreter primitives */\n\n#ifndef Py_BUILD_CORE_BUILTIN\n#  define Py_BUILD_CORE_MODULE 1\n#endif\n\n#include \"Python.h\"\n#include \"pycore_crossinterp.h\"   // struct _xid\n#include \"pycore_interp.h\"        // _PyInterpreterState_LookUpID()\n#include \"pycore_pystate.h\"       // _PyInterpreterState_GetIDObject()\n\n#ifdef MS_WINDOWS\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>        // SwitchToThread()\n#elif defined(HAVE_SCHED_H)\n#include <sched.h>          // sched_yield()\n#endif\n\n#define REGISTERS_HEAP_TYPES\n#define HAS_UNBOUND_ITEMS\n#include \"_interpreters_common.h\"\n#undef HAS_UNBOUND_ITEMS\n#undef REGISTERS_HEAP_TYPES\n\n\n/*\nThis module has the following process-global state:\n\n_globals (static struct globals):\n    module_count (int)\n    channels (struct _channels):\n        numopen (int64_t)\n        next_id; (int64_t)\n        mutex (PyThread_type_lock)\n        head (linked list of struct _channelref *):\n            cid (int64_t)\n            objcount (Py_ssize_t)\n            next (struct _channelref *):\n                ...\n            chan (struct _channel *):\n                open (int)\n                mutex (PyThread_type_lock)\n                closing (struct _channel_closing *):\n                    ref (struct _channelref *):\n                        ...\n                ends (struct _channelends *):\n                    numsendopen (int64_t)\n                    numrecvopen (int64_t)\n                    send (struct _channelend *):\n                        interpid (int64_t)\n                        open (int)\n                        next (struct _channelend *)\n                    recv (struct _channelend *):\n                        ...\n                queue (struct _channelqueue *):\n                    count (int64_t)\n                    first (struct _channelitem *):\n                        next (struct _channelitem *):\n                            ...\n                        data (_PyCrossInterpreterData *):\n                            data (void *)\n                            obj (PyObject *)\n                            interpid (int64_t)\n                            new_object (xid_newobjectfunc)\n                            free (xid_freefunc)\n                    last (struct _channelitem *):\n                        ...\n\nThe above state includes the following allocations by the module:\n\n* 1 top-level mutex (to protect the rest of the state)\n* for each channel:\n   * 1 struct _channelref\n   * 1 struct _channel\n   * 0-1 struct _channel_closing\n   * 1 struct _channelends\n   * 2 struct _channelend\n   * 1 struct _channelqueue\n* for each item in each channel:\n   * 1 struct _channelitem\n   * 1 _PyCrossInterpreterData\n\nThe only objects in that global state are the references held by each\nchannel's queue, which are safely managed via the _PyCrossInterpreterData_*()\nAPI..  The module does not create any objects that are shared globally.\n*/\n\n#define MODULE_NAME _interpchannels\n#define MODULE_NAME_STR Py_STRINGIFY(MODULE_NAME)\n#define MODINIT_FUNC_NAME RESOLVE_MODINIT_FUNC_NAME(MODULE_NAME)\n\n\n#define GLOBAL_MALLOC(TYPE) \\\n    PyMem_RawMalloc(sizeof(TYPE))\n#define GLOBAL_FREE(VAR) \\\n    PyMem_RawFree(VAR)\n\n\n#define XID_IGNORE_EXC 1\n#define XID_FREE 2\n\nstatic int\n_release_xid_data(_PyCrossInterpreterData *data, int flags)\n{\n    int ignoreexc = flags & XID_IGNORE_EXC;\n    PyObject *exc;\n    if (ignoreexc) {\n        exc = PyErr_GetRaisedException();\n    }\n    int res;\n    if (flags & XID_FREE) {\n        res = _PyCrossInterpreterData_ReleaseAndRawFree(data);\n    }\n    else {\n        res = _PyCrossInterpreterData_Release(data);\n    }\n    if (res < 0) {\n        /* The owning interpreter is already destroyed. */\n        if (ignoreexc) {\n            // XXX Emit a warning?\n            PyErr_Clear();\n        }\n    }\n    if (flags & XID_FREE) {\n        /* Either way, we free the data. */\n    }\n    if (ignoreexc) {\n        PyErr_SetRaisedException(exc);\n    }\n    return res;\n}\n\n\nstatic PyInterpreterState *\n_get_current_interp(void)\n{\n    // PyInterpreterState_Get() aborts if lookup fails, so don't need\n    // to check the result for NULL.\n    return PyInterpreterState_Get();\n}\n\nstatic PyObject *\n_get_current_module(void)\n{\n    PyObject *name = PyUnicode_FromString(MODULE_NAME_STR);\n    if (name == NULL) {\n        return NULL;\n    }\n    PyObject *mod = PyImport_GetModule(name);\n    Py_DECREF(name);\n    if (mod == NULL) {\n        return NULL;\n    }\n    assert(mod != Py_None);\n    return mod;\n}\n\nstatic PyObject *\nget_module_from_owned_type(PyTypeObject *cls)\n{\n    assert(cls != NULL);\n    return _get_current_module();\n    // XXX Use the more efficient API now that we use heap types:\n    //return PyType_GetModule(cls);\n}\n\nstatic struct PyModuleDef moduledef;\n\nstatic PyObject *\nget_module_from_type(PyTypeObject *cls)\n{\n    assert(cls != NULL);\n    return _get_current_module();\n    // XXX Use the more efficient API now that we use heap types:\n    //return PyType_GetModuleByDef(cls, &moduledef);\n}\n\nstatic PyObject *\nadd_new_exception(PyObject *mod, const char *name, PyObject *base)\n{\n    assert(!PyObject_HasAttrStringWithError(mod, name));\n    PyObject *exctype = PyErr_NewException(name, base, NULL);\n    if (exctype == NULL) {\n        return NULL;\n    }\n    int res = PyModule_AddType(mod, (PyTypeObject *)exctype);\n    if (res < 0) {\n        Py_DECREF(exctype);\n        return NULL;\n    }\n    return exctype;\n}\n\n#define ADD_NEW_EXCEPTION(MOD, NAME, BASE) \\\n    add_new_exception(MOD, MODULE_NAME_STR \".\" Py_STRINGIFY(NAME), BASE)\n\nstatic int\nwait_for_lock(PyThread_type_lock mutex, PY_TIMEOUT_T timeout)\n{\n    PyLockStatus res = PyThread_acquire_lock_timed_with_retries(mutex, timeout);\n    if (res == PY_LOCK_INTR) {\n        /* KeyboardInterrupt, etc. */\n        assert(PyErr_Occurred());\n        return -1;\n    }\n    else if (res == PY_LOCK_FAILURE) {\n        assert(!PyErr_Occurred());\n        assert(timeout > 0);\n        PyErr_SetString(PyExc_TimeoutError, \"timed out\");\n        return -1;\n    }\n    assert(res == PY_LOCK_ACQUIRED);\n    PyThread_release_lock(mutex);\n    return 0;\n}\n\n\n/* module state *************************************************************/\n\ntypedef struct {\n    /* Added at runtime by interpreters module. */\n    PyTypeObject *send_channel_type;\n    PyTypeObject *recv_channel_type;\n\n    /* heap types */\n    PyTypeObject *ChannelInfoType;\n    PyTypeObject *ChannelIDType;\n\n    /* exceptions */\n    PyObject *ChannelError;\n    PyObject *ChannelNotFoundError;\n    PyObject *ChannelClosedError;\n    PyObject *ChannelEmptyError;\n    PyObject *ChannelNotEmptyError;\n} module_state;\n\nstatic inline module_state *\nget_module_state(PyObject *mod)\n{\n    assert(mod != NULL);\n    module_state *state = PyModule_GetState(mod);\n    assert(state != NULL);\n    return state;\n}\n\nstatic module_state *\n_get_current_module_state(void)\n{\n    PyObject *mod = _get_current_module();\n    if (mod == NULL) {\n        // XXX import it?\n        PyErr_SetString(PyExc_RuntimeError,\n                        MODULE_NAME_STR \" module not imported yet\");\n        return NULL;\n    }\n    module_state *state = get_module_state(mod);\n    Py_DECREF(mod);\n    return state;\n}\n\nstatic int\ntraverse_module_state(module_state *state, visitproc visit, void *arg)\n{\n    /* external types */\n    Py_VISIT(state->send_channel_type);\n    Py_VISIT(state->recv_channel_type);\n\n    /* heap types */\n    Py_VISIT(state->ChannelInfoType);\n    Py_VISIT(state->ChannelIDType);\n\n    /* exceptions */\n    Py_VISIT(state->ChannelError);\n    Py_VISIT(state->ChannelNotFoundError);\n    Py_VISIT(state->ChannelClosedError);\n    Py_VISIT(state->ChannelEmptyError);\n    Py_VISIT(state->ChannelNotEmptyError);\n\n    return 0;\n}\n\nstatic void\nclear_xid_types(module_state *state)\n{\n    /* external types */\n    if (state->send_channel_type != NULL) {\n        (void)clear_xid_class(state->send_channel_type);\n        Py_CLEAR(state->send_channel_type);\n    }\n    if (state->recv_channel_type != NULL) {\n        (void)clear_xid_class(state->recv_channel_type);\n        Py_CLEAR(state->recv_channel_type);\n    }\n\n    /* heap types */\n    if (state->ChannelIDType != NULL) {\n        (void)clear_xid_class(state->ChannelIDType);\n        Py_CLEAR(state->ChannelIDType);\n    }\n}\n\nstatic int\nclear_module_state(module_state *state)\n{\n    clear_xid_types(state);\n\n    /* heap types */\n    Py_CLEAR(state->ChannelInfoType);\n\n    /* exceptions */\n    Py_CLEAR(state->ChannelError);\n    Py_CLEAR(state->ChannelNotFoundError);\n    Py_CLEAR(state->ChannelClosedError);\n    Py_CLEAR(state->ChannelEmptyError);\n    Py_CLEAR(state->ChannelNotEmptyError);\n\n    return 0;\n}\n\n\n/* channel-specific code ****************************************************/\n\n#define CHANNEL_SEND 1\n#define CHANNEL_BOTH 0\n#define CHANNEL_RECV -1\n\n\n/* channel errors */\n\n#define ERR_CHANNEL_NOT_FOUND -2\n#define ERR_CHANNEL_CLOSED -3\n#define ERR_CHANNEL_INTERP_CLOSED -4\n#define ERR_CHANNEL_EMPTY -5\n#define ERR_CHANNEL_NOT_EMPTY -6\n#define ERR_CHANNEL_MUTEX_INIT -7\n#define ERR_CHANNELS_MUTEX_INIT -8\n#define ERR_NO_NEXT_CHANNEL_ID -9\n#define ERR_CHANNEL_CLOSED_WAITING -10\n\nstatic int\nexceptions_init(PyObject *mod)\n{\n    module_state *state = get_module_state(mod);\n    if (state == NULL) {\n        return -1;\n    }\n\n#define ADD(NAME, BASE) \\\n    do { \\\n        assert(state->NAME == NULL); \\\n        state->NAME = ADD_NEW_EXCEPTION(mod, NAME, BASE); \\\n        if (state->NAME == NULL) { \\\n            return -1; \\\n        } \\\n    } while (0)\n\n    // A channel-related operation failed.\n    ADD(ChannelError, PyExc_RuntimeError);\n    // An operation tried to use a channel that doesn't exist.\n    ADD(ChannelNotFoundError, state->ChannelError);\n    // An operation tried to use a closed channel.\n    ADD(ChannelClosedError, state->ChannelError);\n    // An operation tried to pop from an empty channel.\n    ADD(ChannelEmptyError, state->ChannelError);\n    // An operation tried to close a non-empty channel.\n    ADD(ChannelNotEmptyError, state->ChannelError);\n#undef ADD\n\n    return 0;\n}\n\nstatic int\nhandle_channel_error(int err, PyObject *mod, int64_t cid)\n{\n    if (err == 0) {\n        assert(!PyErr_Occurred());\n        return 0;\n    }\n    assert(err < 0);\n    module_state *state = get_module_state(mod);\n    assert(state != NULL);\n    if (err == ERR_CHANNEL_NOT_FOUND) {\n        PyErr_Format(state->ChannelNotFoundError,\n                     \"channel %\" PRId64 \" not found\", cid);\n    }\n    else if (err == ERR_CHANNEL_CLOSED) {\n        PyErr_Format(state->ChannelClosedError,\n                     \"channel %\" PRId64 \" is closed\", cid);\n    }\n    else if (err == ERR_CHANNEL_CLOSED_WAITING) {\n        PyErr_Format(state->ChannelClosedError,\n                     \"channel %\" PRId64 \" has closed\", cid);\n    }\n    else if (err == ERR_CHANNEL_INTERP_CLOSED) {\n        PyErr_Format(state->ChannelClosedError,\n                     \"channel %\" PRId64 \" is already closed\", cid);\n    }\n    else if (err == ERR_CHANNEL_EMPTY) {\n        PyErr_Format(state->ChannelEmptyError,\n                     \"channel %\" PRId64 \" is empty\", cid);\n    }\n    else if (err == ERR_CHANNEL_NOT_EMPTY) {\n        PyErr_Format(state->ChannelNotEmptyError,\n                     \"channel %\" PRId64 \" may not be closed \"\n                     \"if not empty (try force=True)\",\n                     cid);\n    }\n    else if (err == ERR_CHANNEL_MUTEX_INIT) {\n        PyErr_SetString(state->ChannelError,\n                        \"can't initialize mutex for new channel\");\n    }\n    else if (err == ERR_CHANNELS_MUTEX_INIT) {\n        PyErr_SetString(state->ChannelError,\n                        \"can't initialize mutex for channel management\");\n    }\n    else if (err == ERR_NO_NEXT_CHANNEL_ID) {\n        PyErr_SetString(state->ChannelError,\n                        \"failed to get a channel ID\");\n    }\n    else {\n        assert(PyErr_Occurred());\n    }\n    return 1;\n}\n\n\n/* the channel queue */\n\ntypedef uintptr_t _channelitem_id_t;\n\ntypedef struct wait_info {\n    PyThread_type_lock mutex;\n    enum {\n        WAITING_NO_STATUS = 0,\n        WAITING_ACQUIRED = 1,\n        WAITING_RELEASING = 2,\n        WAITING_RELEASED = 3,\n    } status;\n    int received;\n    _channelitem_id_t itemid;\n} _waiting_t;\n\nstatic int\n_waiting_init(_waiting_t *waiting)\n{\n    PyThread_type_lock mutex = PyThread_allocate_lock();\n    if (mutex == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n\n    *waiting = (_waiting_t){\n        .mutex = mutex,\n        .status = WAITING_NO_STATUS,\n    };\n    return 0;\n}\n\nstatic void\n_waiting_clear(_waiting_t *waiting)\n{\n    assert(waiting->status != WAITING_ACQUIRED\n           && waiting->status != WAITING_RELEASING);\n    if (waiting->mutex != NULL) {\n        PyThread_free_lock(waiting->mutex);\n        waiting->mutex = NULL;\n    }\n}\n\nstatic _channelitem_id_t\n_waiting_get_itemid(_waiting_t *waiting)\n{\n    return waiting->itemid;\n}\n\nstatic void\n_waiting_acquire(_waiting_t *waiting)\n{\n    assert(waiting->status == WAITING_NO_STATUS);\n    PyThread_acquire_lock(waiting->mutex, NOWAIT_LOCK);\n    waiting->status = WAITING_ACQUIRED;\n}\n\nstatic void\n_waiting_release(_waiting_t *waiting, int received)\n{\n    assert(waiting->mutex != NULL);\n    assert(waiting->status == WAITING_ACQUIRED);\n    assert(!waiting->received);\n\n    waiting->status = WAITING_RELEASING;\n    PyThread_release_lock(waiting->mutex);\n    if (waiting->received != received) {\n        assert(received == 1);\n        waiting->received = received;\n    }\n    waiting->status = WAITING_RELEASED;\n}\n\nstatic void\n_waiting_finish_releasing(_waiting_t *waiting)\n{\n    while (waiting->status == WAITING_RELEASING) {\n#ifdef MS_WINDOWS\n        SwitchToThread();\n#elif defined(HAVE_SCHED_H)\n        sched_yield();\n#endif\n    }\n}\n\nstruct _channelitem;\n\ntypedef struct _channelitem {\n    /* The interpreter that added the item to the queue.\n       The actual bound interpid is found in item->data.\n       This is necessary because item->data might be NULL,\n       meaning the interpreter has been destroyed. */\n    int64_t interpid;\n    _PyCrossInterpreterData *data;\n    _waiting_t *waiting;\n    int unboundop;\n    struct _channelitem *next;\n} _channelitem;\n\nstatic inline _channelitem_id_t\n_channelitem_ID(_channelitem *item)\n{\n    return (_channelitem_id_t)item;\n}\n\nstatic void\n_channelitem_init(_channelitem *item,\n                  int64_t interpid, _PyCrossInterpreterData *data,\n                  _waiting_t *waiting, int unboundop)\n{\n    if (interpid < 0) {\n        interpid = _get_interpid(data);\n    }\n    else {\n        assert(data == NULL\n               || _PyCrossInterpreterData_INTERPID(data) < 0\n               || interpid == _PyCrossInterpreterData_INTERPID(data));\n    }\n    *item = (_channelitem){\n        .interpid = interpid,\n        .data = data,\n        .waiting = waiting,\n        .unboundop = unboundop,\n    };\n    if (waiting != NULL) {\n        waiting->itemid = _channelitem_ID(item);\n    }\n}\n\nstatic void\n_channelitem_clear_data(_channelitem *item, int removed)\n{\n    if (item->data != NULL) {\n        // It was allocated in channel_send().\n        (void)_release_xid_data(item->data, XID_IGNORE_EXC & XID_FREE);\n        item->data = NULL;\n    }\n\n    if (item->waiting != NULL && removed) {\n        if (item->waiting->status == WAITING_ACQUIRED) {\n            _waiting_release(item->waiting, 0);\n        }\n        item->waiting = NULL;\n    }\n}\n\nstatic void\n_channelitem_clear(_channelitem *item)\n{\n    item->next = NULL;\n    _channelitem_clear_data(item, 1);\n}\n\nstatic _channelitem *\n_channelitem_new(int64_t interpid, _PyCrossInterpreterData *data,\n                 _waiting_t *waiting, int unboundop)\n{\n    _channelitem *item = GLOBAL_MALLOC(_channelitem);\n    if (item == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    _channelitem_init(item, interpid, data, waiting, unboundop);\n    return item;\n}\n\nstatic void\n_channelitem_free(_channelitem *item)\n{\n    _channelitem_clear(item);\n    GLOBAL_FREE(item);\n}\n\nstatic void\n_channelitem_free_all(_channelitem *item)\n{\n    while (item != NULL) {\n        _channelitem *last = item;\n        item = item->next;\n        _channelitem_free(last);\n    }\n}\n\nstatic void\n_channelitem_popped(_channelitem *item,\n                    _PyCrossInterpreterData **p_data, _waiting_t **p_waiting,\n                    int *p_unboundop)\n{\n    assert(item->waiting == NULL || item->waiting->status == WAITING_ACQUIRED);\n    *p_data = item->data;\n    *p_waiting = item->waiting;\n    *p_unboundop = item->unboundop;\n    // We clear them here, so they won't be released in _channelitem_clear().\n    item->data = NULL;\n    item->waiting = NULL;\n    _channelitem_free(item);\n}\n\nstatic int\n_channelitem_clear_interpreter(_channelitem *item)\n{\n    assert(item->interpid >= 0);\n    if (item->data == NULL) {\n        // Its interpreter was already cleared (or it was never bound).\n        // For UNBOUND_REMOVE it should have been freed at that time.\n        assert(item->unboundop != UNBOUND_REMOVE);\n        return 0;\n    }\n    assert(_PyCrossInterpreterData_INTERPID(item->data) == item->interpid);\n\n    switch (item->unboundop) {\n    case UNBOUND_REMOVE:\n        // The caller must free/clear it.\n        return 1;\n    case UNBOUND_ERROR:\n    case UNBOUND_REPLACE:\n        // We won't need the cross-interpreter data later\n        // so we completely throw it away.\n        _channelitem_clear_data(item, 0);\n        return 0;\n    default:\n        Py_FatalError(\"not reachable\");\n        return -1;\n    }\n}\n\n\ntypedef struct _channelqueue {\n    int64_t count;\n    _channelitem *first;\n    _channelitem *last;\n} _channelqueue;\n\nstatic _channelqueue *\n_channelqueue_new(void)\n{\n    _channelqueue *queue = GLOBAL_MALLOC(_channelqueue);\n    if (queue == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    queue->count = 0;\n    queue->first = NULL;\n    queue->last = NULL;\n    return queue;\n}\n\nstatic void\n_channelqueue_clear(_channelqueue *queue)\n{\n    _channelitem_free_all(queue->first);\n    queue->count = 0;\n    queue->first = NULL;\n    queue->last = NULL;\n}\n\nstatic void\n_channelqueue_free(_channelqueue *queue)\n{\n    _channelqueue_clear(queue);\n    GLOBAL_FREE(queue);\n}\n\nstatic int\n_channelqueue_put(_channelqueue *queue,\n                  int64_t interpid, _PyCrossInterpreterData *data,\n                  _waiting_t *waiting, int unboundop)\n{\n    _channelitem *item = _channelitem_new(interpid, data, waiting, unboundop);\n    if (item == NULL) {\n        return -1;\n    }\n\n    queue->count += 1;\n    if (queue->first == NULL) {\n        queue->first = item;\n    }\n    else {\n        queue->last->next = item;\n    }\n    queue->last = item;\n\n    if (waiting != NULL) {\n        _waiting_acquire(waiting);\n    }\n\n    return 0;\n}\n\nstatic int\n_channelqueue_get(_channelqueue *queue,\n                  _PyCrossInterpreterData **p_data, _waiting_t **p_waiting,\n                  int *p_unboundop)\n{\n    _channelitem *item = queue->first;\n    if (item == NULL) {\n        return ERR_CHANNEL_EMPTY;\n    }\n    queue->first = item->next;\n    if (queue->last == item) {\n        queue->last = NULL;\n    }\n    queue->count -= 1;\n\n    _channelitem_popped(item, p_data, p_waiting, p_unboundop);\n    return 0;\n}\n\nstatic int\n_channelqueue_find(_channelqueue *queue, _channelitem_id_t itemid,\n                   _channelitem **p_item, _channelitem **p_prev)\n{\n    _channelitem *prev = NULL;\n    _channelitem *item = NULL;\n    if (queue->first != NULL) {\n        if (_channelitem_ID(queue->first) == itemid) {\n            item = queue->first;\n        }\n        else {\n            prev = queue->first;\n            while (prev->next != NULL) {\n                if (_channelitem_ID(prev->next) == itemid) {\n                    item = prev->next;\n                    break;\n                }\n                prev = prev->next;\n            }\n            if (item == NULL) {\n                prev = NULL;\n            }\n        }\n    }\n    if (p_item != NULL) {\n        *p_item = item;\n    }\n    if (p_prev != NULL) {\n        *p_prev = prev;\n    }\n    return (item != NULL);\n}\n\nstatic void\n_channelqueue_remove(_channelqueue *queue, _channelitem_id_t itemid,\n                     _PyCrossInterpreterData **p_data, _waiting_t **p_waiting)\n{\n    _channelitem *prev = NULL;\n    _channelitem *item = NULL;\n    int found = _channelqueue_find(queue, itemid, &item, &prev);\n    if (!found) {\n        return;\n    }\n\n    assert(item->waiting != NULL);\n    assert(!item->waiting->received);\n    if (prev == NULL) {\n        assert(queue->first == item);\n        queue->first = item->next;\n    }\n    else {\n        assert(queue->first != item);\n        assert(prev->next == item);\n        prev->next = item->next;\n    }\n    item->next = NULL;\n\n    if (queue->last == item) {\n        queue->last = prev;\n    }\n    queue->count -= 1;\n\n    int unboundop;\n    _channelitem_popped(item, p_data, p_waiting, &unboundop);\n}\n\nstatic void\n_channelqueue_clear_interpreter(_channelqueue *queue, int64_t interpid)\n{\n    _channelitem *prev = NULL;\n    _channelitem *next = queue->first;\n    while (next != NULL) {\n        _channelitem *item = next;\n        next = item->next;\n        int remove = (item->interpid == interpid)\n            ? _channelitem_clear_interpreter(item)\n            : 0;\n        if (remove) {\n            _channelitem_free(item);\n            if (prev == NULL) {\n                queue->first = next;\n            }\n            else {\n                prev->next = next;\n            }\n            queue->count -= 1;\n        }\n        else {\n            prev = item;\n        }\n    }\n}\n\n\n/* channel-interpreter associations */\n\nstruct _channelend;\n\ntypedef struct _channelend {\n    struct _channelend *next;\n    int64_t interpid;\n    int open;\n} _channelend;\n\nstatic _channelend *\n_channelend_new(int64_t interpid)\n{\n    _channelend *end = GLOBAL_MALLOC(_channelend);\n    if (end == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    end->next = NULL;\n    end->interpid = interpid;\n    end->open = 1;\n    return end;\n}\n\nstatic void\n_channelend_free(_channelend *end)\n{\n    GLOBAL_FREE(end);\n}\n\nstatic void\n_channelend_free_all(_channelend *end)\n{\n    while (end != NULL) {\n        _channelend *last = end;\n        end = end->next;\n        _channelend_free(last);\n    }\n}\n\nstatic _channelend *\n_channelend_find(_channelend *first, int64_t interpid, _channelend **pprev)\n{\n    _channelend *prev = NULL;\n    _channelend *end = first;\n    while (end != NULL) {\n        if (end->interpid == interpid) {\n            break;\n        }\n        prev = end;\n        end = end->next;\n    }\n    if (pprev != NULL) {\n        *pprev = prev;\n    }\n    return end;\n}\n\ntypedef struct _channelassociations {\n    // Note that the list entries are never removed for interpreter\n    // for which the channel is closed.  This should not be a problem in\n    // practice.  Also, a channel isn't automatically closed when an\n    // interpreter is destroyed.\n    int64_t numsendopen;\n    int64_t numrecvopen;\n    _channelend *send;\n    _channelend *recv;\n} _channelends;\n\nstatic _channelends *\n_channelends_new(void)\n{\n    _channelends *ends = GLOBAL_MALLOC(_channelends);\n    if (ends== NULL) {\n        return NULL;\n    }\n    ends->numsendopen = 0;\n    ends->numrecvopen = 0;\n    ends->send = NULL;\n    ends->recv = NULL;\n    return ends;\n}\n\nstatic void\n_channelends_clear(_channelends *ends)\n{\n    _channelend_free_all(ends->send);\n    ends->send = NULL;\n    ends->numsendopen = 0;\n\n    _channelend_free_all(ends->recv);\n    ends->recv = NULL;\n    ends->numrecvopen = 0;\n}\n\nstatic void\n_channelends_free(_channelends *ends)\n{\n    _channelends_clear(ends);\n    GLOBAL_FREE(ends);\n}\n\nstatic _channelend *\n_channelends_add(_channelends *ends, _channelend *prev, int64_t interpid,\n                 int send)\n{\n    _channelend *end = _channelend_new(interpid);\n    if (end == NULL) {\n        return NULL;\n    }\n\n    if (prev == NULL) {\n        if (send) {\n            ends->send = end;\n        }\n        else {\n            ends->recv = end;\n        }\n    }\n    else {\n        prev->next = end;\n    }\n    if (send) {\n        ends->numsendopen += 1;\n    }\n    else {\n        ends->numrecvopen += 1;\n    }\n    return end;\n}\n\nstatic int\n_channelends_associate(_channelends *ends, int64_t interpid, int send)\n{\n    _channelend *prev;\n    _channelend *end = _channelend_find(send ? ends->send : ends->recv,\n                                        interpid, &prev);\n    if (end != NULL) {\n        if (!end->open) {\n            return ERR_CHANNEL_CLOSED;\n        }\n        // already associated\n        return 0;\n    }\n    if (_channelends_add(ends, prev, interpid, send) == NULL) {\n        return -1;\n    }\n    return 0;\n}\n\nstatic int\n_channelends_is_open(_channelends *ends)\n{\n    if (ends->numsendopen != 0 || ends->numrecvopen != 0) {\n        // At least one interpreter is still associated with the channel\n        // (and hasn't been released).\n        return 1;\n    }\n    // XXX This is wrong if an end can ever be removed.\n    if (ends->send == NULL && ends->recv == NULL) {\n        // The channel has never had any interpreters associated with it.\n        return 1;\n    }\n    return 0;\n}\n\nstatic void\n_channelends_release_end(_channelends *ends, _channelend *end, int send)\n{\n    end->open = 0;\n    if (send) {\n        ends->numsendopen -= 1;\n    }\n    else {\n        ends->numrecvopen -= 1;\n    }\n}\n\nstatic int\n_channelends_release_interpreter(_channelends *ends, int64_t interpid, int which)\n{\n    _channelend *prev;\n    _channelend *end;\n    if (which >= 0) {  // send/both\n        end = _channelend_find(ends->send, interpid, &prev);\n        if (end == NULL) {\n            // never associated so add it\n            end = _channelends_add(ends, prev, interpid, 1);\n            if (end == NULL) {\n                return -1;\n            }\n        }\n        _channelends_release_end(ends, end, 1);\n    }\n    if (which <= 0) {  // recv/both\n        end = _channelend_find(ends->recv, interpid, &prev);\n        if (end == NULL) {\n            // never associated so add it\n            end = _channelends_add(ends, prev, interpid, 0);\n            if (end == NULL) {\n                return -1;\n            }\n        }\n        _channelends_release_end(ends, end, 0);\n    }\n    return 0;\n}\n\nstatic void\n_channelends_release_all(_channelends *ends, int which, int force)\n{\n    // XXX Handle the ends.\n    // XXX Handle force is True.\n\n    // Ensure all the \"send\"-associated interpreters are closed.\n    _channelend *end;\n    for (end = ends->send; end != NULL; end = end->next) {\n        _channelends_release_end(ends, end, 1);\n    }\n\n    // Ensure all the \"recv\"-associated interpreters are closed.\n    for (end = ends->recv; end != NULL; end = end->next) {\n        _channelends_release_end(ends, end, 0);\n    }\n}\n\nstatic void\n_channelends_clear_interpreter(_channelends *ends, int64_t interpid)\n{\n    // XXX Actually remove the entries?\n    _channelend *end;\n    end = _channelend_find(ends->send, interpid, NULL);\n    if (end != NULL) {\n        _channelends_release_end(ends, end, 1);\n    }\n    end = _channelend_find(ends->recv, interpid, NULL);\n    if (end != NULL) {\n        _channelends_release_end(ends, end, 0);\n    }\n}\n\n\n/* each channel's state */\n\nstruct _channel;\nstruct _channel_closing;\nstatic void _channel_clear_closing(struct _channel *);\nstatic void _channel_finish_closing(struct _channel *);\n\ntypedef struct _channel {\n    PyThread_type_lock mutex;\n    _channelqueue *queue;\n    _channelends *ends;\n    struct {\n        int unboundop;\n    } defaults;\n    int open;\n    struct _channel_closing *closing;\n} _channel_state;\n\nstatic _channel_state *\n_channel_new(PyThread_type_lock mutex, int unboundop)\n{\n    _channel_state *chan = GLOBAL_MALLOC(_channel_state);\n    if (chan == NULL) {\n        return NULL;\n    }\n    chan->mutex = mutex;\n    chan->queue = _channelqueue_new();\n    if (chan->queue == NULL) {\n        GLOBAL_FREE(chan);\n        return NULL;\n    }\n    chan->ends = _channelends_new();\n    if (chan->ends == NULL) {\n        _channelqueue_free(chan->queue);\n        GLOBAL_FREE(chan);\n        return NULL;\n    }\n    chan->defaults.unboundop = unboundop;\n    chan->open = 1;\n    chan->closing = NULL;\n    return chan;\n}\n\nstatic void\n_channel_free(_channel_state *chan)\n{\n    _channel_clear_closing(chan);\n    PyThread_acquire_lock(chan->mutex, WAIT_LOCK);\n    _channelqueue_free(chan->queue);\n    _channelends_free(chan->ends);\n    PyThread_release_lock(chan->mutex);\n\n    PyThread_free_lock(chan->mutex);\n    GLOBAL_FREE(chan);\n}\n\nstatic int\n_channel_add(_channel_state *chan, int64_t interpid,\n             _PyCrossInterpreterData *data, _waiting_t *waiting,\n             int unboundop)\n{\n    int res = -1;\n    PyThread_acquire_lock(chan->mutex, WAIT_LOCK);\n\n    if (!chan->open) {\n        res = ERR_CHANNEL_CLOSED;\n        goto done;\n    }\n    if (_channelends_associate(chan->ends, interpid, 1) != 0) {\n        res = ERR_CHANNEL_INTERP_CLOSED;\n        goto done;\n    }\n\n    if (_channelqueue_put(chan->queue, interpid, data, waiting, unboundop) != 0) {\n        goto done;\n    }\n    // Any errors past this point must cause a _waiting_release() call.\n\n    res = 0;\ndone:\n    PyThread_release_lock(chan->mutex);\n    return res;\n}\n\nstatic int\n_channel_next(_channel_state *chan, int64_t interpid,\n              _PyCrossInterpreterData **p_data, _waiting_t **p_waiting,\n              int *p_unboundop)\n{\n    int err = 0;\n    PyThread_acquire_lock(chan->mutex, WAIT_LOCK);\n\n    if (!chan->open) {\n        err = ERR_CHANNEL_CLOSED;\n        goto done;\n    }\n    if (_channelends_associate(chan->ends, interpid, 0) != 0) {\n        err = ERR_CHANNEL_INTERP_CLOSED;\n        goto done;\n    }\n\n    int empty = _channelqueue_get(chan->queue, p_data, p_waiting, p_unboundop);\n    assert(!PyErr_Occurred());\n    if (empty) {\n        assert(empty == ERR_CHANNEL_EMPTY);\n        if (chan->closing != NULL) {\n            chan->open = 0;\n        }\n        err = ERR_CHANNEL_EMPTY;\n        goto done;\n    }\n\ndone:\n    PyThread_release_lock(chan->mutex);\n    if (chan->queue->count == 0) {\n        _channel_finish_closing(chan);\n    }\n    return err;\n}\n\nstatic void\n_channel_remove(_channel_state *chan, _channelitem_id_t itemid)\n{\n    _PyCrossInterpreterData *data = NULL;\n    _waiting_t *waiting = NULL;\n\n    PyThread_acquire_lock(chan->mutex, WAIT_LOCK);\n    _channelqueue_remove(chan->queue, itemid, &data, &waiting);\n    PyThread_release_lock(chan->mutex);\n\n    (void)_release_xid_data(data, XID_IGNORE_EXC | XID_FREE);\n    if (waiting != NULL) {\n        _waiting_release(waiting, 0);\n    }\n\n    if (chan->queue->count == 0) {\n        _channel_finish_closing(chan);\n    }\n}\n\nstatic int\n_channel_release_interpreter(_channel_state *chan, int64_t interpid, int end)\n{\n    PyThread_acquire_lock(chan->mutex, WAIT_LOCK);\n\n    int res = -1;\n    if (!chan->open) {\n        res = ERR_CHANNEL_CLOSED;\n        goto done;\n    }\n\n    if (_channelends_release_interpreter(chan->ends, interpid, end) != 0) {\n        goto done;\n    }\n    chan->open = _channelends_is_open(chan->ends);\n    // XXX Clear the queue if not empty?\n    // XXX Activate the \"closing\" mechanism?\n\n    res = 0;\ndone:\n    PyThread_release_lock(chan->mutex);\n    return res;\n}\n\nstatic int\n_channel_release_all(_channel_state *chan, int end, int force)\n{\n    int res = -1;\n    PyThread_acquire_lock(chan->mutex, WAIT_LOCK);\n\n    if (!chan->open) {\n        res = ERR_CHANNEL_CLOSED;\n        goto done;\n    }\n\n    if (!force && chan->queue->count > 0) {\n        res = ERR_CHANNEL_NOT_EMPTY;\n        goto done;\n    }\n    // XXX Clear the queue?\n\n    chan->open = 0;\n\n    // We *could* also just leave these in place, since we've marked\n    // the channel as closed already.\n    _channelends_release_all(chan->ends, end, force);\n\n    res = 0;\ndone:\n    PyThread_release_lock(chan->mutex);\n    return res;\n}\n\nstatic void\n_channel_clear_interpreter(_channel_state *chan, int64_t interpid)\n{\n    PyThread_acquire_lock(chan->mutex, WAIT_LOCK);\n\n    _channelqueue_clear_interpreter(chan->queue, interpid);\n    _channelends_clear_interpreter(chan->ends, interpid);\n    chan->open = _channelends_is_open(chan->ends);\n\n    PyThread_release_lock(chan->mutex);\n}\n\n\n/* the set of channels */\n\nstruct _channelref;\n\ntypedef struct _channelref {\n    int64_t cid;\n    _channel_state *chan;\n    struct _channelref *next;\n    // The number of ChannelID objects referring to this channel.\n    Py_ssize_t objcount;\n} _channelref;\n\nstatic _channelref *\n_channelref_new(int64_t cid, _channel_state *chan)\n{\n    _channelref *ref = GLOBAL_MALLOC(_channelref);\n    if (ref == NULL) {\n        return NULL;\n    }\n    ref->cid = cid;\n    ref->chan = chan;\n    ref->next = NULL;\n    ref->objcount = 0;\n    return ref;\n}\n\n//static void\n//_channelref_clear(_channelref *ref)\n//{\n//    ref->cid = -1;\n//    ref->chan = NULL;\n//    ref->next = NULL;\n//    ref->objcount = 0;\n//}\n\nstatic void\n_channelref_free(_channelref *ref)\n{\n    if (ref->chan != NULL) {\n        _channel_clear_closing(ref->chan);\n    }\n    //_channelref_clear(ref);\n    GLOBAL_FREE(ref);\n}\n\nstatic _channelref *\n_channelref_find(_channelref *first, int64_t cid, _channelref **pprev)\n{\n    _channelref *prev = NULL;\n    _channelref *ref = first;\n    while (ref != NULL) {\n        if (ref->cid == cid) {\n            break;\n        }\n        prev = ref;\n        ref = ref->next;\n    }\n    if (pprev != NULL) {\n        *pprev = prev;\n    }\n    return ref;\n}\n\n\ntypedef struct _channels {\n    PyThread_type_lock mutex;\n    _channelref *head;\n    int64_t numopen;\n    int64_t next_id;\n} _channels;\n\nstatic void\n_channels_init(_channels *channels, PyThread_type_lock mutex)\n{\n    channels->mutex = mutex;\n    channels->head = NULL;\n    channels->numopen = 0;\n    channels->next_id = 0;\n}\n\nstatic void\n_channels_fini(_channels *channels)\n{\n    assert(channels->numopen == 0);\n    assert(channels->head == NULL);\n    if (channels->mutex != NULL) {\n        PyThread_free_lock(channels->mutex);\n        channels->mutex = NULL;\n    }\n}\n\nstatic int64_t\n_channels_next_id(_channels *channels)  // needs lock\n{\n    int64_t cid = channels->next_id;\n    if (cid < 0) {\n        /* overflow */\n        return -1;\n    }\n    channels->next_id += 1;\n    return cid;\n}\n\nstatic int\n_channels_lookup(_channels *channels, int64_t cid, PyThread_type_lock *pmutex,\n                 _channel_state **res)\n{\n    int err = -1;\n    _channel_state *chan = NULL;\n    PyThread_acquire_lock(channels->mutex, WAIT_LOCK);\n    if (pmutex != NULL) {\n        *pmutex = NULL;\n    }\n\n    _channelref *ref = _channelref_find(channels->head, cid, NULL);\n    if (ref == NULL) {\n        err = ERR_CHANNEL_NOT_FOUND;\n        goto done;\n    }\n    if (ref->chan == NULL || !ref->chan->open) {\n        err = ERR_CHANNEL_CLOSED;\n        goto done;\n    }\n\n    if (pmutex != NULL) {\n        // The mutex will be closed by the caller.\n        *pmutex = channels->mutex;\n    }\n\n    chan = ref->chan;\n    err = 0;\n\ndone:\n    if (pmutex == NULL || *pmutex == NULL) {\n        PyThread_release_lock(channels->mutex);\n    }\n    *res = chan;\n    return err;\n}\n\nstatic int64_t\n_channels_add(_channels *channels, _channel_state *chan)\n{\n    int64_t cid = -1;\n    PyThread_acquire_lock(channels->mutex, WAIT_LOCK);\n\n    // Create a new ref.\n    int64_t _cid = _channels_next_id(channels);\n    if (_cid < 0) {\n        cid = ERR_NO_NEXT_CHANNEL_ID;\n        goto done;\n    }\n    _channelref *ref = _channelref_new(_cid, chan);\n    if (ref == NULL) {\n        goto done;\n    }\n\n    // Add it to the list.\n    // We assume that the channel is a new one (not already in the list).\n    ref->next = channels->head;\n    channels->head = ref;\n    channels->numopen += 1;\n\n    cid = _cid;\ndone:\n    PyThread_release_lock(channels->mutex);\n    return cid;\n}\n\n/* forward */\nstatic int _channel_set_closing(_channelref *, PyThread_type_lock);\n\nstatic int\n_channels_close(_channels *channels, int64_t cid, _channel_state **pchan,\n                int end, int force)\n{\n    int res = -1;\n    PyThread_acquire_lock(channels->mutex, WAIT_LOCK);\n    if (pchan != NULL) {\n        *pchan = NULL;\n    }\n\n    _channelref *ref = _channelref_find(channels->head, cid, NULL);\n    if (ref == NULL) {\n        res = ERR_CHANNEL_NOT_FOUND;\n        goto done;\n    }\n\n    if (ref->chan == NULL) {\n        res = ERR_CHANNEL_CLOSED;\n        goto done;\n    }\n    else if (!force && end == CHANNEL_SEND && ref->chan->closing != NULL) {\n        res = ERR_CHANNEL_CLOSED;\n        goto done;\n    }\n    else {\n        int err = _channel_release_all(ref->chan, end, force);\n        if (err != 0) {\n            if (end == CHANNEL_SEND && err == ERR_CHANNEL_NOT_EMPTY) {\n                if (ref->chan->closing != NULL) {\n                    res = ERR_CHANNEL_CLOSED;\n                    goto done;\n                }\n                // Mark the channel as closing and return.  The channel\n                // will be cleaned up in _channel_next().\n                PyErr_Clear();\n                int err = _channel_set_closing(ref, channels->mutex);\n                if (err != 0) {\n                    res = err;\n                    goto done;\n                }\n                if (pchan != NULL) {\n                    *pchan = ref->chan;\n                }\n                res = 0;\n            }\n            else {\n                res = err;\n            }\n            goto done;\n        }\n        if (pchan != NULL) {\n            *pchan = ref->chan;\n        }\n        else  {\n            _channel_free(ref->chan);\n        }\n        ref->chan = NULL;\n    }\n\n    res = 0;\ndone:\n    PyThread_release_lock(channels->mutex);\n    return res;\n}\n\nstatic void\n_channels_remove_ref(_channels *channels, _channelref *ref, _channelref *prev,\n                     _channel_state **pchan)\n{\n    if (ref == channels->head) {\n        channels->head = ref->next;\n    }\n    else {\n        prev->next = ref->next;\n    }\n    channels->numopen -= 1;\n\n    if (pchan != NULL) {\n        *pchan = ref->chan;\n    }\n    _channelref_free(ref);\n}\n\nstatic int\n_channels_remove(_channels *channels, int64_t cid, _channel_state **pchan)\n{\n    int res = -1;\n    PyThread_acquire_lock(channels->mutex, WAIT_LOCK);\n\n    if (pchan != NULL) {\n        *pchan = NULL;\n    }\n\n    _channelref *prev = NULL;\n    _channelref *ref = _channelref_find(channels->head, cid, &prev);\n    if (ref == NULL) {\n        res = ERR_CHANNEL_NOT_FOUND;\n        goto done;\n    }\n\n    _channels_remove_ref(channels, ref, prev, pchan);\n\n    res = 0;\ndone:\n    PyThread_release_lock(channels->mutex);\n    return res;\n}\n\nstatic int\n_channels_add_id_object(_channels *channels, int64_t cid)\n{\n    int res = -1;\n    PyThread_acquire_lock(channels->mutex, WAIT_LOCK);\n\n    _channelref *ref = _channelref_find(channels->head, cid, NULL);\n    if (ref == NULL) {\n        res = ERR_CHANNEL_NOT_FOUND;\n        goto done;\n    }\n    ref->objcount += 1;\n\n    res = 0;\ndone:\n    PyThread_release_lock(channels->mutex);\n    return res;\n}\n\nstatic void\n_channels_release_cid_object(_channels *channels, int64_t cid)\n{\n    PyThread_acquire_lock(channels->mutex, WAIT_LOCK);\n\n    _channelref *prev = NULL;\n    _channelref *ref = _channelref_find(channels->head, cid, &prev);\n    if (ref == NULL) {\n        // Already destroyed.\n        goto done;\n    }\n    ref->objcount -= 1;\n\n    // Destroy if no longer used.\n    if (ref->objcount == 0) {\n        _channel_state *chan = NULL;\n        _channels_remove_ref(channels, ref, prev, &chan);\n        if (chan != NULL) {\n            _channel_free(chan);\n        }\n    }\n\ndone:\n    PyThread_release_lock(channels->mutex);\n}\n\nstruct channel_id_and_info {\n    int64_t id;\n    int unboundop;\n};\n\nstatic struct channel_id_and_info *\n_channels_list_all(_channels *channels, int64_t *count)\n{\n    struct channel_id_and_info *cids = NULL;\n    PyThread_acquire_lock(channels->mutex, WAIT_LOCK);\n    struct channel_id_and_info *ids =\n        PyMem_NEW(struct channel_id_and_info, (Py_ssize_t)(channels->numopen));\n    if (ids == NULL) {\n        goto done;\n    }\n    _channelref *ref = channels->head;\n    for (int64_t i=0; ref != NULL; ref = ref->next, i++) {\n        ids[i] = (struct channel_id_and_info){\n            .id = ref->cid,\n            .unboundop = ref->chan->defaults.unboundop,\n        };\n    }\n    *count = channels->numopen;\n\n    cids = ids;\ndone:\n    PyThread_release_lock(channels->mutex);\n    return cids;\n}\n\nstatic void\n_channels_clear_interpreter(_channels *channels, int64_t interpid)\n{\n    PyThread_acquire_lock(channels->mutex, WAIT_LOCK);\n\n    _channelref *ref = channels->head;\n    for (; ref != NULL; ref = ref->next) {\n        if (ref->chan != NULL) {\n            _channel_clear_interpreter(ref->chan, interpid);\n        }\n    }\n\n    PyThread_release_lock(channels->mutex);\n}\n\n\n/* support for closing non-empty channels */\n\nstruct _channel_closing {\n    _channelref *ref;\n};\n\nstatic int\n_channel_set_closing(_channelref *ref, PyThread_type_lock mutex) {\n    _channel_state *chan = ref->chan;\n    if (chan == NULL) {\n        // already closed\n        return 0;\n    }\n    int res = -1;\n    PyThread_acquire_lock(chan->mutex, WAIT_LOCK);\n    if (chan->closing != NULL) {\n        res = ERR_CHANNEL_CLOSED;\n        goto done;\n    }\n    chan->closing = GLOBAL_MALLOC(struct _channel_closing);\n    if (chan->closing == NULL) {\n        goto done;\n    }\n    chan->closing->ref = ref;\n\n    res = 0;\ndone:\n    PyThread_release_lock(chan->mutex);\n    return res;\n}\n\nstatic void\n_channel_clear_closing(_channel_state *chan) {\n    PyThread_acquire_lock(chan->mutex, WAIT_LOCK);\n    if (chan->closing != NULL) {\n        GLOBAL_FREE(chan->closing);\n        chan->closing = NULL;\n    }\n    PyThread_release_lock(chan->mutex);\n}\n\nstatic void\n_channel_finish_closing(_channel_state *chan) {\n    struct _channel_closing *closing = chan->closing;\n    if (closing == NULL) {\n        return;\n    }\n    _channelref *ref = closing->ref;\n    _channel_clear_closing(chan);\n    // Do the things that would have been done in _channels_close().\n    ref->chan = NULL;\n    _channel_free(chan);\n}\n\n\n/* \"high\"-level channel-related functions */\n\n// Create a new channel.\nstatic int64_t\nchannel_create(_channels *channels, int unboundop)\n{\n    PyThread_type_lock mutex = PyThread_allocate_lock();\n    if (mutex == NULL) {\n        return ERR_CHANNEL_MUTEX_INIT;\n    }\n    _channel_state *chan = _channel_new(mutex, unboundop);\n    if (chan == NULL) {\n        PyThread_free_lock(mutex);\n        return -1;\n    }\n    int64_t cid = _channels_add(channels, chan);\n    if (cid < 0) {\n        _channel_free(chan);\n    }\n    return cid;\n}\n\n// Completely destroy the channel.\nstatic int\nchannel_destroy(_channels *channels, int64_t cid)\n{\n    _channel_state *chan = NULL;\n    int err = _channels_remove(channels, cid, &chan);\n    if (err != 0) {\n        return err;\n    }\n    if (chan != NULL) {\n        _channel_free(chan);\n    }\n    return 0;\n}\n\n// Push an object onto the channel.\n// The current interpreter gets associated with the send end of the channel.\n// Optionally request to be notified when it is received.\nstatic int\nchannel_send(_channels *channels, int64_t cid, PyObject *obj,\n             _waiting_t *waiting, int unboundop)\n{\n    PyInterpreterState *interp = _get_current_interp();\n    if (interp == NULL) {\n        return -1;\n    }\n    int64_t interpid = PyInterpreterState_GetID(interp);\n\n    // Look up the channel.\n    PyThread_type_lock mutex = NULL;\n    _channel_state *chan = NULL;\n    int err = _channels_lookup(channels, cid, &mutex, &chan);\n    if (err != 0) {\n        return err;\n    }\n    assert(chan != NULL);\n    // Past this point we are responsible for releasing the mutex.\n\n    if (chan->closing != NULL) {\n        PyThread_release_lock(mutex);\n        return ERR_CHANNEL_CLOSED;\n    }\n\n    // Convert the object to cross-interpreter data.\n    _PyCrossInterpreterData *data = GLOBAL_MALLOC(_PyCrossInterpreterData);\n    if (data == NULL) {\n        PyThread_release_lock(mutex);\n        return -1;\n    }\n    if (_PyObject_GetCrossInterpreterData(obj, data) != 0) {\n        PyThread_release_lock(mutex);\n        GLOBAL_FREE(data);\n        return -1;\n    }\n\n    // Add the data to the channel.\n    int res = _channel_add(chan, interpid, data, waiting, unboundop);\n    PyThread_release_lock(mutex);\n    if (res != 0) {\n        // We may chain an exception here:\n        (void)_release_xid_data(data, 0);\n        GLOBAL_FREE(data);\n        return res;\n    }\n\n    return 0;\n}\n\n// Basically, un-send an object.\nstatic void\nchannel_clear_sent(_channels *channels, int64_t cid, _waiting_t *waiting)\n{\n    // Look up the channel.\n    PyThread_type_lock mutex = NULL;\n    _channel_state *chan = NULL;\n    int err = _channels_lookup(channels, cid, &mutex, &chan);\n    if (err != 0) {\n        // The channel was already closed, etc.\n        assert(waiting->status == WAITING_RELEASED);\n        return;  // Ignore the error.\n    }\n    assert(chan != NULL);\n    // Past this point we are responsible for releasing the mutex.\n\n    _channelitem_id_t itemid = _waiting_get_itemid(waiting);\n    _channel_remove(chan, itemid);\n\n    PyThread_release_lock(mutex);\n}\n\n// Like channel_send(), but strictly wait for the object to be received.\nstatic int\nchannel_send_wait(_channels *channels, int64_t cid, PyObject *obj,\n                  int unboundop, PY_TIMEOUT_T timeout)\n{\n    // We use a stack variable here, so we must ensure that &waiting\n    // is not held by any channel item at the point this function exits.\n    _waiting_t waiting;\n    if (_waiting_init(&waiting) < 0) {\n        assert(PyErr_Occurred());\n        return -1;\n    }\n\n    /* Queue up the object. */\n    int res = channel_send(channels, cid, obj, &waiting, unboundop);\n    if (res < 0) {\n        assert(waiting.status == WAITING_NO_STATUS);\n        goto finally;\n    }\n\n    /* Wait until the object is received. */\n    if (wait_for_lock(waiting.mutex, timeout) < 0) {\n        assert(PyErr_Occurred());\n        _waiting_finish_releasing(&waiting);\n        /* The send() call is failing now, so make sure the item\n           won't be received. */\n        channel_clear_sent(channels, cid, &waiting);\n        assert(waiting.status == WAITING_RELEASED);\n        if (!waiting.received) {\n            res = -1;\n            goto finally;\n        }\n        // XXX Emit a warning if not a TimeoutError?\n        PyErr_Clear();\n    }\n    else {\n        _waiting_finish_releasing(&waiting);\n        assert(waiting.status == WAITING_RELEASED);\n        if (!waiting.received) {\n            res = ERR_CHANNEL_CLOSED_WAITING;\n            goto finally;\n        }\n    }\n\n    /* success! */\n    res = 0;\n\nfinally:\n    _waiting_clear(&waiting);\n    return res;\n}\n\n// Pop the next object off the channel.  Fail if empty.\n// The current interpreter gets associated with the recv end of the channel.\n// XXX Support a \"wait\" mutex?\nstatic int\nchannel_recv(_channels *channels, int64_t cid, PyObject **res, int *p_unboundop)\n{\n    int err;\n    *res = NULL;\n\n    PyInterpreterState *interp = _get_current_interp();\n    if (interp == NULL) {\n        // XXX Is this always an error?\n        if (PyErr_Occurred()) {\n            return -1;\n        }\n        return 0;\n    }\n    int64_t interpid = PyInterpreterState_GetID(interp);\n\n    // Look up the channel.\n    PyThread_type_lock mutex = NULL;\n    _channel_state *chan = NULL;\n    err = _channels_lookup(channels, cid, &mutex, &chan);\n    if (err != 0) {\n        return err;\n    }\n    assert(chan != NULL);\n    // Past this point we are responsible for releasing the mutex.\n\n    // Pop off the next item from the channel.\n    _PyCrossInterpreterData *data = NULL;\n    _waiting_t *waiting = NULL;\n    err = _channel_next(chan, interpid, &data, &waiting, p_unboundop);\n    PyThread_release_lock(mutex);\n    if (err != 0) {\n        return err;\n    }\n    else if (data == NULL) {\n        // The item was unbound.\n        assert(!PyErr_Occurred());\n        *res = NULL;\n        return 0;\n    }\n\n    // Convert the data back to an object.\n    PyObject *obj = _PyCrossInterpreterData_NewObject(data);\n    if (obj == NULL) {\n        assert(PyErr_Occurred());\n        // It was allocated in channel_send(), so we free it.\n        (void)_release_xid_data(data, XID_IGNORE_EXC | XID_FREE);\n        if (waiting != NULL) {\n            _waiting_release(waiting, 0);\n        }\n        return -1;\n    }\n    // It was allocated in channel_send(), so we free it.\n    int release_res = _release_xid_data(data, XID_FREE);\n    if (release_res < 0) {\n        // The source interpreter has been destroyed already.\n        assert(PyErr_Occurred());\n        Py_DECREF(obj);\n        if (waiting != NULL) {\n            _waiting_release(waiting, 0);\n        }\n        return -1;\n    }\n\n    // Notify the sender.\n    if (waiting != NULL) {\n        _waiting_release(waiting, 1);\n    }\n\n    *res = obj;\n    return 0;\n}\n\n// Disallow send/recv for the current interpreter.\n// The channel is marked as closed if no other interpreters\n// are currently associated.\nstatic int\nchannel_release(_channels *channels, int64_t cid, int send, int recv)\n{\n    PyInterpreterState *interp = _get_current_interp();\n    if (interp == NULL) {\n        return -1;\n    }\n    int64_t interpid = PyInterpreterState_GetID(interp);\n\n    // Look up the channel.\n    PyThread_type_lock mutex = NULL;\n    _channel_state *chan = NULL;\n    int err = _channels_lookup(channels, cid, &mutex, &chan);\n    if (err != 0) {\n        return err;\n    }\n    // Past this point we are responsible for releasing the mutex.\n\n    // Close one or both of the two ends.\n    int res = _channel_release_interpreter(chan, interpid, send-recv);\n    PyThread_release_lock(mutex);\n    return res;\n}\n\n// Close the channel (for all interpreters).  Fail if it's already closed.\n// Close immediately if it's empty.  Otherwise, disallow sending and\n// finally close once empty.  Optionally, immediately clear and close it.\nstatic int\nchannel_close(_channels *channels, int64_t cid, int end, int force)\n{\n    return _channels_close(channels, cid, NULL, end, force);\n}\n\n// Return true if the identified interpreter is associated\n// with the given end of the channel.\nstatic int\nchannel_is_associated(_channels *channels, int64_t cid, int64_t interpid,\n                       int send)\n{\n    _channel_state *chan = NULL;\n    int err = _channels_lookup(channels, cid, NULL, &chan);\n    if (err != 0) {\n        return err;\n    }\n    else if (send && chan->closing != NULL) {\n        return ERR_CHANNEL_CLOSED;\n    }\n\n    _channelend *end = _channelend_find(send ? chan->ends->send : chan->ends->recv,\n                                        interpid, NULL);\n\n    return (end != NULL && end->open);\n}\n\nstatic int\n_channel_get_count(_channels *channels, int64_t cid, Py_ssize_t *p_count)\n{\n    PyThread_type_lock mutex = NULL;\n    _channel_state *chan = NULL;\n    int err = _channels_lookup(channels, cid, &mutex, &chan);\n    if (err != 0) {\n        return err;\n    }\n    assert(chan != NULL);\n    int64_t count = chan->queue->count;\n    PyThread_release_lock(mutex);\n\n    *p_count = (Py_ssize_t)count;\n    return 0;\n}\n\n\n/* channel info */\n\nstruct channel_info {\n    struct {\n        // 1: closed; -1: closing\n        int closed;\n        struct {\n            Py_ssize_t nsend_only;  // not released\n            Py_ssize_t nsend_only_released;\n            Py_ssize_t nrecv_only;  // not released\n            Py_ssize_t nrecv_only_released;\n            Py_ssize_t nboth;  // not released\n            Py_ssize_t nboth_released;\n            Py_ssize_t nboth_send_released;\n            Py_ssize_t nboth_recv_released;\n        } all;\n        struct {\n            // 1: associated; -1: released\n            int send;\n            int recv;\n        } cur;\n    } status;\n    Py_ssize_t count;\n};\n\nstatic int\n_channel_get_info(_channels *channels, int64_t cid, struct channel_info *info)\n{\n    int err = 0;\n    *info = (struct channel_info){0};\n\n    // Get the current interpreter.\n    PyInterpreterState *interp = _get_current_interp();\n    if (interp == NULL) {\n        return -1;\n    }\n    Py_ssize_t interpid = PyInterpreterState_GetID(interp);\n\n    // Hold the global lock until we're done.\n    PyThread_acquire_lock(channels->mutex, WAIT_LOCK);\n\n    // Find the channel.\n    _channelref *ref = _channelref_find(channels->head, cid, NULL);\n    if (ref == NULL) {\n        err = ERR_CHANNEL_NOT_FOUND;\n        goto finally;\n    }\n    _channel_state *chan = ref->chan;\n\n    // Check if open.\n    if (chan == NULL) {\n        info->status.closed = 1;\n        goto finally;\n    }\n    if (!chan->open) {\n        assert(chan->queue->count == 0);\n        info->status.closed = 1;\n        goto finally;\n    }\n    if (chan->closing != NULL) {\n        assert(chan->queue->count > 0);\n        info->status.closed = -1;\n    }\n    else {\n        info->status.closed = 0;\n    }\n\n    // Get the number of queued objects.\n    info->count = chan->queue->count;\n\n    // Get the ends statuses.\n    assert(info->status.cur.send == 0);\n    assert(info->status.cur.recv == 0);\n    _channelend *send = chan->ends->send;\n    while (send != NULL) {\n        if (send->interpid == interpid) {\n            info->status.cur.send = send->open ? 1 : -1;\n        }\n\n        if (send->open) {\n            info->status.all.nsend_only += 1;\n        }\n        else {\n            info->status.all.nsend_only_released += 1;\n        }\n        send = send->next;\n    }\n    _channelend *recv = chan->ends->recv;\n    while (recv != NULL) {\n        if (recv->interpid == interpid) {\n            info->status.cur.recv = recv->open ? 1 : -1;\n        }\n\n        // XXX This is O(n*n).  Why do we have 2 linked lists?\n        _channelend *send = chan->ends->send;\n        while (send != NULL) {\n            if (send->interpid == recv->interpid) {\n                break;\n            }\n            send = send->next;\n        }\n        if (send == NULL) {\n            if (recv->open) {\n                info->status.all.nrecv_only += 1;\n            }\n            else {\n                info->status.all.nrecv_only_released += 1;\n            }\n        }\n        else {\n            if (recv->open) {\n                if (send->open) {\n                    info->status.all.nboth += 1;\n                    info->status.all.nsend_only -= 1;\n                }\n                else {\n                    info->status.all.nboth_recv_released += 1;\n                    info->status.all.nsend_only_released -= 1;\n                }\n            }\n            else {\n                if (send->open) {\n                    info->status.all.nboth_send_released += 1;\n                    info->status.all.nsend_only -= 1;\n                }\n                else {\n                    info->status.all.nboth_released += 1;\n                    info->status.all.nsend_only_released -= 1;\n                }\n            }\n        }\n        recv = recv->next;\n    }\n\nfinally:\n    PyThread_release_lock(channels->mutex);\n    return err;\n}\n\nPyDoc_STRVAR(channel_info_doc,\n\"ChannelInfo\\n\\\n\\n\\\nA named tuple of a channel's state.\");\n\nstatic PyStructSequence_Field channel_info_fields[] = {\n    {\"open\", \"both ends are open\"},\n    {\"closing\", \"send is closed, recv is non-empty\"},\n    {\"closed\", \"both ends are closed\"},\n    {\"count\", \"queued objects\"},\n\n    {\"num_interp_send\", \"interpreters bound to the send end\"},\n    {\"num_interp_send_released\",\n     \"interpreters bound to the send end and released\"},\n\n    {\"num_interp_recv\", \"interpreters bound to the send end\"},\n    {\"num_interp_recv_released\",\n     \"interpreters bound to the send end and released\"},\n\n    {\"num_interp_both\", \"interpreters bound to both ends\"},\n    {\"num_interp_both_released\",\n     \"interpreters bound to both ends and released_from_both\"},\n    {\"num_interp_both_send_released\",\n     \"interpreters bound to both ends and released_from_the send end\"},\n    {\"num_interp_both_recv_released\",\n     \"interpreters bound to both ends and released_from_the recv end\"},\n\n    {\"send_associated\", \"current interpreter is bound to the send end\"},\n    {\"send_released\", \"current interpreter *was* bound to the send end\"},\n    {\"recv_associated\", \"current interpreter is bound to the recv end\"},\n    {\"recv_released\", \"current interpreter *was* bound to the recv end\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc channel_info_desc = {\n    .name = MODULE_NAME_STR \".ChannelInfo\",\n    .doc = channel_info_doc,\n    .fields = channel_info_fields,\n    .n_in_sequence = 8,\n};\n\nstatic PyObject *\nnew_channel_info(PyObject *mod, struct channel_info *info)\n{\n    module_state *state = get_module_state(mod);\n    if (state == NULL) {\n        return NULL;\n    }\n\n    assert(state->ChannelInfoType != NULL);\n    PyObject *self = PyStructSequence_New(state->ChannelInfoType);\n    if (self == NULL) {\n        return NULL;\n    }\n\n    int pos = 0;\n#define SET_BOOL(val) \\\n    PyStructSequence_SET_ITEM(self, pos++, \\\n                              Py_NewRef(val ? Py_True : Py_False))\n#define SET_COUNT(val) \\\n    do { \\\n        PyObject *obj = PyLong_FromLongLong(val); \\\n        if (obj == NULL) { \\\n            Py_CLEAR(self); \\\n            return NULL; \\\n        } \\\n        PyStructSequence_SET_ITEM(self, pos++, obj); \\\n    } while(0)\n    SET_BOOL(info->status.closed == 0);\n    SET_BOOL(info->status.closed == -1);\n    SET_BOOL(info->status.closed == 1);\n    SET_COUNT(info->count);\n    SET_COUNT(info->status.all.nsend_only);\n    SET_COUNT(info->status.all.nsend_only_released);\n    SET_COUNT(info->status.all.nrecv_only);\n    SET_COUNT(info->status.all.nrecv_only_released);\n    SET_COUNT(info->status.all.nboth);\n    SET_COUNT(info->status.all.nboth_released);\n    SET_COUNT(info->status.all.nboth_send_released);\n    SET_COUNT(info->status.all.nboth_recv_released);\n    SET_BOOL(info->status.cur.send == 1);\n    SET_BOOL(info->status.cur.send == -1);\n    SET_BOOL(info->status.cur.recv == 1);\n    SET_BOOL(info->status.cur.recv == -1);\n#undef SET_COUNT\n#undef SET_BOOL\n    assert(!PyErr_Occurred());\n    return self;\n}\n\n\n/* ChannelID class */\n\ntypedef struct channelid {\n    PyObject_HEAD\n    int64_t cid;\n    int end;\n    int resolve;\n    _channels *channels;\n} channelid;\n\nstruct channel_id_converter_data {\n    PyObject *module;\n    int64_t cid;\n    int end;\n};\n\nstatic int\nchannel_id_converter(PyObject *arg, void *ptr)\n{\n    int64_t cid;\n    int end = 0;\n    struct channel_id_converter_data *data = ptr;\n    module_state *state = get_module_state(data->module);\n    assert(state != NULL);\n    if (PyObject_TypeCheck(arg, state->ChannelIDType)) {\n        cid = ((channelid *)arg)->cid;\n        end = ((channelid *)arg)->end;\n    }\n    else if (PyIndex_Check(arg)) {\n        cid = PyLong_AsLongLong(arg);\n        if (cid == -1 && PyErr_Occurred()) {\n            return 0;\n        }\n        if (cid < 0) {\n            PyErr_Format(PyExc_ValueError,\n                        \"channel ID must be a non-negative int, got %R\", arg);\n            return 0;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"channel ID must be an int, got %.100s\",\n                     Py_TYPE(arg)->tp_name);\n        return 0;\n    }\n    data->cid = cid;\n    data->end = end;\n    return 1;\n}\n\nstatic int\nnewchannelid(PyTypeObject *cls, int64_t cid, int end, _channels *channels,\n             int force, int resolve, channelid **res)\n{\n    *res = NULL;\n\n    channelid *self = PyObject_New(channelid, cls);\n    if (self == NULL) {\n        return -1;\n    }\n    self->cid = cid;\n    self->end = end;\n    self->resolve = resolve;\n    self->channels = channels;\n\n    int err = _channels_add_id_object(channels, cid);\n    if (err != 0) {\n        if (force && err == ERR_CHANNEL_NOT_FOUND) {\n            assert(!PyErr_Occurred());\n        }\n        else {\n            Py_DECREF((PyObject *)self);\n            return err;\n        }\n    }\n\n    *res = self;\n    return 0;\n}\n\nstatic _channels * _global_channels(void);\n\nstatic PyObject *\n_channelid_new(PyObject *mod, PyTypeObject *cls,\n               PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"id\", \"send\", \"recv\", \"force\", \"_resolve\", NULL};\n    int64_t cid;\n    int end;\n    struct channel_id_converter_data cid_data = {\n        .module = mod,\n    };\n    int send = -1;\n    int recv = -1;\n    int force = 0;\n    int resolve = 0;\n    if (!PyArg_ParseTupleAndKeywords(args, kwds,\n                                     \"O&|$pppp:ChannelID.__new__\", kwlist,\n                                     channel_id_converter, &cid_data,\n                                     &send, &recv, &force, &resolve)) {\n        return NULL;\n    }\n    cid = cid_data.cid;\n    end = cid_data.end;\n\n    // Handle \"send\" and \"recv\".\n    if (send == 0 && recv == 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"'send' and 'recv' cannot both be False\");\n        return NULL;\n    }\n    else if (send == 1) {\n        if (recv == 0 || recv == -1) {\n            end = CHANNEL_SEND;\n        }\n        else {\n            assert(recv == 1);\n            end = 0;\n        }\n    }\n    else if (recv == 1) {\n        assert(send == 0 || send == -1);\n        end = CHANNEL_RECV;\n    }\n\n    PyObject *cidobj = NULL;\n    int err = newchannelid(cls, cid, end, _global_channels(),\n                           force, resolve,\n                           (channelid **)&cidobj);\n    if (handle_channel_error(err, mod, cid)) {\n        assert(cidobj == NULL);\n        return NULL;\n    }\n    assert(cidobj != NULL);\n    return cidobj;\n}\n\nstatic void\nchannelid_dealloc(PyObject *self)\n{\n    int64_t cid = ((channelid *)self)->cid;\n    _channels *channels = ((channelid *)self)->channels;\n\n    PyTypeObject *tp = Py_TYPE(self);\n    tp->tp_free(self);\n    /* \"Instances of heap-allocated types hold a reference to their type.\"\n     * See: https://docs.python.org/3.11/howto/isolating-extensions.html#garbage-collection-protocol\n     * See: https://docs.python.org/3.11/c-api/typeobj.html#c.PyTypeObject.tp_traverse\n    */\n    // XXX Why don't we implement Py_TPFLAGS_HAVE_GC, e.g. Py_tp_traverse,\n    // like we do for _abc._abc_data?\n    Py_DECREF(tp);\n\n    _channels_release_cid_object(channels, cid);\n}\n\nstatic PyObject *\nchannelid_repr(PyObject *self)\n{\n    PyTypeObject *type = Py_TYPE(self);\n    const char *name = _PyType_Name(type);\n\n    channelid *cidobj = (channelid *)self;\n    const char *fmt;\n    if (cidobj->end == CHANNEL_SEND) {\n        fmt = \"%s(%\" PRId64 \", send=True)\";\n    }\n    else if (cidobj->end == CHANNEL_RECV) {\n        fmt = \"%s(%\" PRId64 \", recv=True)\";\n    }\n    else {\n        fmt = \"%s(%\" PRId64 \")\";\n    }\n    return PyUnicode_FromFormat(fmt, name, cidobj->cid);\n}\n\nstatic PyObject *\nchannelid_str(PyObject *self)\n{\n    channelid *cidobj = (channelid *)self;\n    return PyUnicode_FromFormat(\"%\" PRId64 \"\", cidobj->cid);\n}\n\nstatic PyObject *\nchannelid_int(PyObject *self)\n{\n    channelid *cidobj = (channelid *)self;\n    return PyLong_FromLongLong(cidobj->cid);\n}\n\nstatic Py_hash_t\nchannelid_hash(PyObject *self)\n{\n    channelid *cidobj = (channelid *)self;\n    PyObject *pyid = PyLong_FromLongLong(cidobj->cid);\n    if (pyid == NULL) {\n        return -1;\n    }\n    Py_hash_t hash = PyObject_Hash(pyid);\n    Py_DECREF(pyid);\n    return hash;\n}\n\nstatic PyObject *\nchannelid_richcompare(PyObject *self, PyObject *other, int op)\n{\n    PyObject *res = NULL;\n    if (op != Py_EQ && op != Py_NE) {\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n\n    PyObject *mod = get_module_from_type(Py_TYPE(self));\n    if (mod == NULL) {\n        return NULL;\n    }\n    module_state *state = get_module_state(mod);\n    if (state == NULL) {\n        goto done;\n    }\n\n    if (!PyObject_TypeCheck(self, state->ChannelIDType)) {\n        res = Py_NewRef(Py_NotImplemented);\n        goto done;\n    }\n\n    channelid *cidobj = (channelid *)self;\n    int equal;\n    if (PyObject_TypeCheck(other, state->ChannelIDType)) {\n        channelid *othercidobj = (channelid *)other;\n        equal = (cidobj->end == othercidobj->end) && (cidobj->cid == othercidobj->cid);\n    }\n    else if (PyLong_Check(other)) {\n        /* Fast path */\n        int overflow;\n        long long othercid = PyLong_AsLongLongAndOverflow(other, &overflow);\n        if (othercid == -1 && PyErr_Occurred()) {\n            goto done;\n        }\n        equal = !overflow && (othercid >= 0) && (cidobj->cid == othercid);\n    }\n    else if (PyNumber_Check(other)) {\n        PyObject *pyid = PyLong_FromLongLong(cidobj->cid);\n        if (pyid == NULL) {\n            goto done;\n        }\n        res = PyObject_RichCompare(pyid, other, op);\n        Py_DECREF(pyid);\n        goto done;\n    }\n    else {\n        res = Py_NewRef(Py_NotImplemented);\n        goto done;\n    }\n\n    if ((op == Py_EQ && equal) || (op == Py_NE && !equal)) {\n        res = Py_NewRef(Py_True);\n    }\n    else {\n        res = Py_NewRef(Py_False);\n    }\n\ndone:\n    Py_DECREF(mod);\n    return res;\n}\n\nstatic PyTypeObject * _get_current_channelend_type(int end);\n\nstatic PyObject *\n_channelobj_from_cidobj(PyObject *cidobj, int end)\n{\n    PyObject *cls = (PyObject *)_get_current_channelend_type(end);\n    if (cls == NULL) {\n        return NULL;\n    }\n    PyObject *chan = PyObject_CallFunctionObjArgs(cls, cidobj, NULL);\n    Py_DECREF(cls);\n    if (chan == NULL) {\n        return NULL;\n    }\n    return chan;\n}\n\nstruct _channelid_xid {\n    int64_t cid;\n    int end;\n    int resolve;\n};\n\nstatic PyObject *\n_channelid_from_xid(_PyCrossInterpreterData *data)\n{\n    struct _channelid_xid *xid = \\\n                (struct _channelid_xid *)_PyCrossInterpreterData_DATA(data);\n\n    // It might not be imported yet, so we can't use _get_current_module().\n    PyObject *mod = PyImport_ImportModule(MODULE_NAME_STR);\n    if (mod == NULL) {\n        return NULL;\n    }\n    assert(mod != Py_None);\n    module_state *state = get_module_state(mod);\n    if (state == NULL) {\n        return NULL;\n    }\n\n    // Note that we do not preserve the \"resolve\" flag.\n    PyObject *cidobj = NULL;\n    int err = newchannelid(state->ChannelIDType, xid->cid, xid->end,\n                           _global_channels(), 0, 0,\n                           (channelid **)&cidobj);\n    if (err != 0) {\n        assert(cidobj == NULL);\n        (void)handle_channel_error(err, mod, xid->cid);\n        goto done;\n    }\n    assert(cidobj != NULL);\n    if (xid->end == 0) {\n        goto done;\n    }\n    if (!xid->resolve) {\n        goto done;\n    }\n\n    /* Try returning a high-level channel end but fall back to the ID. */\n    PyObject *chan = _channelobj_from_cidobj(cidobj, xid->end);\n    if (chan == NULL) {\n        PyErr_Clear();\n        goto done;\n    }\n    Py_DECREF(cidobj);\n    cidobj = chan;\n\ndone:\n    Py_DECREF(mod);\n    return cidobj;\n}\n\nstatic int\n_channelid_shared(PyThreadState *tstate, PyObject *obj,\n                  _PyCrossInterpreterData *data)\n{\n    if (_PyCrossInterpreterData_InitWithSize(\n            data, tstate->interp, sizeof(struct _channelid_xid), obj,\n            _channelid_from_xid\n            ) < 0)\n    {\n        return -1;\n    }\n    struct _channelid_xid *xid = \\\n                (struct _channelid_xid *)_PyCrossInterpreterData_DATA(data);\n    xid->cid = ((channelid *)obj)->cid;\n    xid->end = ((channelid *)obj)->end;\n    xid->resolve = ((channelid *)obj)->resolve;\n    return 0;\n}\n\nstatic PyObject *\nchannelid_end(PyObject *self, void *end)\n{\n    int force = 1;\n    channelid *cidobj = (channelid *)self;\n    if (end != NULL) {\n        PyObject *obj = NULL;\n        int err = newchannelid(Py_TYPE(self), cidobj->cid, *(int *)end,\n                               cidobj->channels, force, cidobj->resolve,\n                               (channelid **)&obj);\n        if (err != 0) {\n            assert(obj == NULL);\n            PyObject *mod = get_module_from_type(Py_TYPE(self));\n            if (mod == NULL) {\n                return NULL;\n            }\n            (void)handle_channel_error(err, mod, cidobj->cid);\n            Py_DECREF(mod);\n            return NULL;\n        }\n        assert(obj != NULL);\n        return obj;\n    }\n\n    if (cidobj->end == CHANNEL_SEND) {\n        return PyUnicode_InternFromString(\"send\");\n    }\n    if (cidobj->end == CHANNEL_RECV) {\n        return PyUnicode_InternFromString(\"recv\");\n    }\n    return PyUnicode_InternFromString(\"both\");\n}\n\nstatic int _channelid_end_send = CHANNEL_SEND;\nstatic int _channelid_end_recv = CHANNEL_RECV;\n\nstatic PyGetSetDef channelid_getsets[] = {\n    {\"end\", (getter)channelid_end, NULL,\n     PyDoc_STR(\"'send', 'recv', or 'both'\")},\n    {\"send\", (getter)channelid_end, NULL,\n     PyDoc_STR(\"the 'send' end of the channel\"), &_channelid_end_send},\n    {\"recv\", (getter)channelid_end, NULL,\n     PyDoc_STR(\"the 'recv' end of the channel\"), &_channelid_end_recv},\n    {NULL}\n};\n\nPyDoc_STRVAR(channelid_doc,\n\"A channel ID identifies a channel and may be used as an int.\");\n\nstatic PyType_Slot channelid_typeslots[] = {\n    {Py_tp_dealloc, (destructor)channelid_dealloc},\n    {Py_tp_doc, (void *)channelid_doc},\n    {Py_tp_repr, (reprfunc)channelid_repr},\n    {Py_tp_str, (reprfunc)channelid_str},\n    {Py_tp_hash, channelid_hash},\n    {Py_tp_richcompare, channelid_richcompare},\n    {Py_tp_getset, channelid_getsets},\n    // number slots\n    {Py_nb_int, (unaryfunc)channelid_int},\n    {Py_nb_index,  (unaryfunc)channelid_int},\n    {0, NULL},\n};\n\nstatic PyType_Spec channelid_typespec = {\n    .name = MODULE_NAME_STR \".ChannelID\",\n    .basicsize = sizeof(channelid),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n              Py_TPFLAGS_DISALLOW_INSTANTIATION | Py_TPFLAGS_IMMUTABLETYPE),\n    .slots = channelid_typeslots,\n};\n\nstatic PyTypeObject *\nadd_channelid_type(PyObject *mod)\n{\n    PyTypeObject *cls = (PyTypeObject *)PyType_FromModuleAndSpec(\n                mod, &channelid_typespec, NULL);\n    if (cls == NULL) {\n        return NULL;\n    }\n    if (PyModule_AddType(mod, cls) < 0) {\n        Py_DECREF(cls);\n        return NULL;\n    }\n    if (ensure_xid_class(cls, _channelid_shared) < 0) {\n        Py_DECREF(cls);\n        return NULL;\n    }\n    return cls;\n}\n\n\n/* SendChannel and RecvChannel classes */\n\n// XXX Use a new __xid__ protocol instead?\n\nstatic PyTypeObject *\n_get_current_channelend_type(int end)\n{\n    module_state *state = _get_current_module_state();\n    if (state == NULL) {\n        return NULL;\n    }\n    PyTypeObject *cls;\n    if (end == CHANNEL_SEND) {\n        cls = state->send_channel_type;\n    }\n    else {\n        assert(end == CHANNEL_RECV);\n        cls = state->recv_channel_type;\n    }\n    if (cls == NULL) {\n        // Force the module to be loaded, to register the type.\n        PyObject *highlevel = PyImport_ImportModule(\"interpreters.channels\");\n        if (highlevel == NULL) {\n            PyErr_Clear();\n            highlevel = PyImport_ImportModule(\"test.support.interpreters.channels\");\n            if (highlevel == NULL) {\n                return NULL;\n            }\n        }\n        Py_DECREF(highlevel);\n        if (end == CHANNEL_SEND) {\n            cls = state->send_channel_type;\n        }\n        else {\n            cls = state->recv_channel_type;\n        }\n        assert(cls != NULL);\n    }\n    return cls;\n}\n\nstatic PyObject *\n_channelend_from_xid(_PyCrossInterpreterData *data)\n{\n    channelid *cidobj = (channelid *)_channelid_from_xid(data);\n    if (cidobj == NULL) {\n        return NULL;\n    }\n    PyTypeObject *cls = _get_current_channelend_type(cidobj->end);\n    if (cls == NULL) {\n        Py_DECREF(cidobj);\n        return NULL;\n    }\n    PyObject *obj = PyObject_CallOneArg((PyObject *)cls, (PyObject *)cidobj);\n    Py_DECREF(cidobj);\n    return obj;\n}\n\nstatic int\n_channelend_shared(PyThreadState *tstate, PyObject *obj,\n                    _PyCrossInterpreterData *data)\n{\n    PyObject *cidobj = PyObject_GetAttrString(obj, \"_id\");\n    if (cidobj == NULL) {\n        return -1;\n    }\n    int res = _channelid_shared(tstate, cidobj, data);\n    Py_DECREF(cidobj);\n    if (res < 0) {\n        return -1;\n    }\n    _PyCrossInterpreterData_SET_NEW_OBJECT(data, _channelend_from_xid);\n    return 0;\n}\n\nstatic int\nset_channelend_types(PyObject *mod, PyTypeObject *send, PyTypeObject *recv)\n{\n    module_state *state = get_module_state(mod);\n    if (state == NULL) {\n        return -1;\n    }\n\n    // Clear the old values if the .py module was reloaded.\n    if (state->send_channel_type != NULL) {\n        (void)clear_xid_class(state->send_channel_type);\n        Py_CLEAR(state->send_channel_type);\n    }\n    if (state->recv_channel_type != NULL) {\n        (void)clear_xid_class(state->recv_channel_type);\n        Py_CLEAR(state->recv_channel_type);\n    }\n\n    // Add and register the types.\n    state->send_channel_type = (PyTypeObject *)Py_NewRef(send);\n    state->recv_channel_type = (PyTypeObject *)Py_NewRef(recv);\n    if (ensure_xid_class(send, _channelend_shared) < 0) {\n        Py_CLEAR(state->send_channel_type);\n        Py_CLEAR(state->recv_channel_type);\n        return -1;\n    }\n    if (ensure_xid_class(recv, _channelend_shared) < 0) {\n        (void)clear_xid_class(state->send_channel_type);\n        Py_CLEAR(state->send_channel_type);\n        Py_CLEAR(state->recv_channel_type);\n        return -1;\n    }\n\n    return 0;\n}\n\n\n/* module level code ********************************************************/\n\n/* globals is the process-global state for the module.  It holds all\n   the data that we need to share between interpreters, so it cannot\n   hold PyObject values. */\nstatic struct globals {\n    int module_count;\n    _channels channels;\n} _globals = {0};\n\nstatic int\n_globals_init(void)\n{\n    // XXX This isn't thread-safe.\n    _globals.module_count++;\n    if (_globals.module_count > 1) {\n        // Already initialized.\n        return 0;\n    }\n\n    assert(_globals.channels.mutex == NULL);\n    PyThread_type_lock mutex = PyThread_allocate_lock();\n    if (mutex == NULL) {\n        return ERR_CHANNELS_MUTEX_INIT;\n    }\n    _channels_init(&_globals.channels, mutex);\n    return 0;\n}\n\nstatic void\n_globals_fini(void)\n{\n    // XXX This isn't thread-safe.\n    _globals.module_count--;\n    if (_globals.module_count > 0) {\n        return;\n    }\n\n    _channels_fini(&_globals.channels);\n}\n\nstatic _channels *\n_global_channels(void) {\n    return &_globals.channels;\n}\n\n\nstatic void\nclear_interpreter(void *data)\n{\n    if (_globals.module_count == 0) {\n        return;\n    }\n    PyInterpreterState *interp = (PyInterpreterState *)data;\n    assert(interp == _get_current_interp());\n    int64_t interpid = PyInterpreterState_GetID(interp);\n    _channels_clear_interpreter(&_globals.channels, interpid);\n}\n\n\nstatic PyObject *\nchannelsmod_create(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"unboundop\", NULL};\n    int unboundop;\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"i:create\", kwlist,\n                                     &unboundop))\n    {\n        return NULL;\n    }\n    if (!check_unbound(unboundop)) {\n        PyErr_Format(PyExc_ValueError,\n                     \"unsupported unboundop %d\", unboundop);\n        return NULL;\n    }\n\n    int64_t cid = channel_create(&_globals.channels, unboundop);\n    if (cid < 0) {\n        (void)handle_channel_error(-1, self, cid);\n        return NULL;\n    }\n    module_state *state = get_module_state(self);\n    if (state == NULL) {\n        return NULL;\n    }\n    PyObject *cidobj = NULL;\n    int err = newchannelid(state->ChannelIDType, cid, 0,\n                           &_globals.channels, 0, 0,\n                           (channelid **)&cidobj);\n    if (handle_channel_error(err, self, cid)) {\n        assert(cidobj == NULL);\n        err = channel_destroy(&_globals.channels, cid);\n        if (handle_channel_error(err, self, cid)) {\n            // XXX issue a warning?\n        }\n        return NULL;\n    }\n    assert(cidobj != NULL);\n    assert(((channelid *)cidobj)->channels != NULL);\n    return cidobj;\n}\n\nPyDoc_STRVAR(channelsmod_create_doc,\n\"channel_create(unboundop) -> cid\\n\\\n\\n\\\nCreate a new cross-interpreter channel and return a unique generated ID.\");\n\nstatic PyObject *\nchannelsmod_destroy(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"cid\", NULL};\n    int64_t cid;\n    struct channel_id_converter_data cid_data = {\n        .module = self,\n    };\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O&:channel_destroy\", kwlist,\n                                     channel_id_converter, &cid_data)) {\n        return NULL;\n    }\n    cid = cid_data.cid;\n\n    int err = channel_destroy(&_globals.channels, cid);\n    if (handle_channel_error(err, self, cid)) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(channelsmod_destroy_doc,\n\"channel_destroy(cid)\\n\\\n\\n\\\nClose and finalize the channel.  Afterward attempts to use the channel\\n\\\nwill behave as though it never existed.\");\n\nstatic PyObject *\nchannelsmod_list_all(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    int64_t count = 0;\n    struct channel_id_and_info *cids =\n        _channels_list_all(&_globals.channels, &count);\n    if (cids == NULL) {\n        if (count == 0) {\n            return PyList_New(0);\n        }\n        return NULL;\n    }\n    PyObject *ids = PyList_New((Py_ssize_t)count);\n    if (ids == NULL) {\n        goto finally;\n    }\n    module_state *state = get_module_state(self);\n    if (state == NULL) {\n        Py_DECREF(ids);\n        ids = NULL;\n        goto finally;\n    }\n    struct channel_id_and_info *cur = cids;\n    for (int64_t i=0; i < count; cur++, i++) {\n        PyObject *cidobj = NULL;\n        int err = newchannelid(state->ChannelIDType, cur->id, 0,\n                               &_globals.channels, 0, 0,\n                               (channelid **)&cidobj);\n        if (handle_channel_error(err, self, cur->id)) {\n            assert(cidobj == NULL);\n            Py_SETREF(ids, NULL);\n            break;\n        }\n        assert(cidobj != NULL);\n\n        PyObject *item = Py_BuildValue(\"Oi\", cidobj, cur->unboundop);\n        Py_DECREF(cidobj);\n        if (item == NULL) {\n            Py_SETREF(ids, NULL);\n            break;\n        }\n        PyList_SET_ITEM(ids, (Py_ssize_t)i, item);\n    }\n\nfinally:\n    PyMem_Free(cids);\n    return ids;\n}\n\nPyDoc_STRVAR(channelsmod_list_all_doc,\n\"channel_list_all() -> [cid]\\n\\\n\\n\\\nReturn the list of all IDs for active channels.\");\n\nstatic PyObject *\nchannelsmod_list_interpreters(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"cid\", \"send\", NULL};\n    int64_t cid;            /* Channel ID */\n    struct channel_id_converter_data cid_data = {\n        .module = self,\n    };\n    int send = 0;           /* Send or receive end? */\n    int64_t interpid;\n    PyObject *ids, *interpid_obj;\n    PyInterpreterState *interp;\n\n    if (!PyArg_ParseTupleAndKeywords(\n            args, kwds, \"O&$p:channel_list_interpreters\",\n            kwlist, channel_id_converter, &cid_data, &send)) {\n        return NULL;\n    }\n    cid = cid_data.cid;\n\n    ids = PyList_New(0);\n    if (ids == NULL) {\n        goto except;\n    }\n\n    interp = PyInterpreterState_Head();\n    while (interp != NULL) {\n        interpid = PyInterpreterState_GetID(interp);\n        assert(interpid >= 0);\n        int res = channel_is_associated(&_globals.channels, cid, interpid, send);\n        if (res < 0) {\n            (void)handle_channel_error(res, self, cid);\n            goto except;\n        }\n        if (res) {\n            interpid_obj = _PyInterpreterState_GetIDObject(interp);\n            if (interpid_obj == NULL) {\n                goto except;\n            }\n            res = PyList_Insert(ids, 0, interpid_obj);\n            Py_DECREF(interpid_obj);\n            if (res < 0) {\n                goto except;\n            }\n        }\n        interp = PyInterpreterState_Next(interp);\n    }\n\n    goto finally;\n\nexcept:\n    Py_CLEAR(ids);\n\nfinally:\n    return ids;\n}\n\nPyDoc_STRVAR(channelsmod_list_interpreters_doc,\n\"channel_list_interpreters(cid, *, send) -> [id]\\n\\\n\\n\\\nReturn the list of all interpreter IDs associated with an end of the channel.\\n\\\n\\n\\\nThe 'send' argument should be a boolean indicating whether to use the send or\\n\\\nreceive end.\");\n\n\nstatic PyObject *\nchannelsmod_send(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"cid\", \"obj\", \"unboundop\", \"blocking\", \"timeout\",\n                             NULL};\n    struct channel_id_converter_data cid_data = {\n        .module = self,\n    };\n    PyObject *obj;\n    int unboundop = UNBOUND_REPLACE;\n    int blocking = 1;\n    PyObject *timeout_obj = NULL;\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O&O|i$pO:channel_send\", kwlist,\n                                     channel_id_converter, &cid_data, &obj,\n                                     &unboundop, &blocking, &timeout_obj))\n    {\n        return NULL;\n    }\n    if (!check_unbound(unboundop)) {\n        PyErr_Format(PyExc_ValueError,\n                     \"unsupported unboundop %d\", unboundop);\n        return NULL;\n    }\n\n    int64_t cid = cid_data.cid;\n    PY_TIMEOUT_T timeout;\n    if (PyThread_ParseTimeoutArg(timeout_obj, blocking, &timeout) < 0) {\n        return NULL;\n    }\n\n    /* Queue up the object. */\n    int err = 0;\n    if (blocking) {\n        err = channel_send_wait(&_globals.channels, cid, obj, unboundop, timeout);\n    }\n    else {\n        err = channel_send(&_globals.channels, cid, obj, NULL, unboundop);\n    }\n    if (handle_channel_error(err, self, cid)) {\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(channelsmod_send_doc,\n\"channel_send(cid, obj, *, blocking=True, timeout=None)\\n\\\n\\n\\\nAdd the object's data to the channel's queue.\\n\\\nBy default this waits for the object to be received.\");\n\nstatic PyObject *\nchannelsmod_send_buffer(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"cid\", \"obj\", \"unboundop\", \"blocking\", \"timeout\",\n                             NULL};\n    struct channel_id_converter_data cid_data = {\n        .module = self,\n    };\n    PyObject *obj;\n    int unboundop = UNBOUND_REPLACE;\n    int blocking = 1;\n    PyObject *timeout_obj = NULL;\n    if (!PyArg_ParseTupleAndKeywords(args, kwds,\n                                     \"O&O|i$pO:channel_send_buffer\", kwlist,\n                                     channel_id_converter, &cid_data, &obj,\n                                     &unboundop, &blocking, &timeout_obj)) {\n        return NULL;\n    }\n    if (!check_unbound(unboundop)) {\n        PyErr_Format(PyExc_ValueError,\n                     \"unsupported unboundop %d\", unboundop);\n        return NULL;\n    }\n\n    int64_t cid = cid_data.cid;\n    PY_TIMEOUT_T timeout;\n    if (PyThread_ParseTimeoutArg(timeout_obj, blocking, &timeout) < 0) {\n        return NULL;\n    }\n\n    PyObject *tempobj = PyMemoryView_FromObject(obj);\n    if (tempobj == NULL) {\n        return NULL;\n    }\n\n    /* Queue up the object. */\n    int err = 0;\n    if (blocking) {\n        err = channel_send_wait(\n                &_globals.channels, cid, tempobj, unboundop, timeout);\n    }\n    else {\n        err = channel_send(&_globals.channels, cid, tempobj, NULL, unboundop);\n    }\n    Py_DECREF(tempobj);\n    if (handle_channel_error(err, self, cid)) {\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(channelsmod_send_buffer_doc,\n\"channel_send_buffer(cid, obj, *, blocking=True, timeout=None)\\n\\\n\\n\\\nAdd the object's buffer to the channel's queue.\\n\\\nBy default this waits for the object to be received.\");\n\nstatic PyObject *\nchannelsmod_recv(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"cid\", \"default\", NULL};\n    int64_t cid;\n    struct channel_id_converter_data cid_data = {\n        .module = self,\n    };\n    PyObject *dflt = NULL;\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O&|O:channel_recv\", kwlist,\n                                     channel_id_converter, &cid_data, &dflt)) {\n        return NULL;\n    }\n    cid = cid_data.cid;\n\n    PyObject *obj = NULL;\n    int unboundop = 0;\n    int err = channel_recv(&_globals.channels, cid, &obj, &unboundop);\n    if (err == ERR_CHANNEL_EMPTY && dflt != NULL) {\n        // Use the default.\n        obj = Py_NewRef(dflt);\n        err = 0;\n    }\n    else if (handle_channel_error(err, self, cid)) {\n        return NULL;\n    }\n    else if (obj == NULL) {\n        // The item was unbound.\n        return Py_BuildValue(\"Oi\", Py_None, unboundop);\n    }\n\n    PyObject *res = Py_BuildValue(\"OO\", obj, Py_None);\n    Py_DECREF(obj);\n    return res;\n}\n\nPyDoc_STRVAR(channelsmod_recv_doc,\n\"channel_recv(cid, [default]) -> (obj, unboundop)\\n\\\n\\n\\\nReturn a new object from the data at the front of the channel's queue.\\n\\\n\\n\\\nIf there is nothing to receive then raise ChannelEmptyError, unless\\n\\\na default value is provided.  In that case return it.\");\n\nstatic PyObject *\nchannelsmod_close(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"cid\", \"send\", \"recv\", \"force\", NULL};\n    int64_t cid;\n    struct channel_id_converter_data cid_data = {\n        .module = self,\n    };\n    int send = 0;\n    int recv = 0;\n    int force = 0;\n    if (!PyArg_ParseTupleAndKeywords(args, kwds,\n                                     \"O&|$ppp:channel_close\", kwlist,\n                                     channel_id_converter, &cid_data,\n                                     &send, &recv, &force)) {\n        return NULL;\n    }\n    cid = cid_data.cid;\n\n    int err = channel_close(&_globals.channels, cid, send-recv, force);\n    if (handle_channel_error(err, self, cid)) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(channelsmod_close_doc,\n\"channel_close(cid, *, send=None, recv=None, force=False)\\n\\\n\\n\\\nClose the channel for all interpreters.\\n\\\n\\n\\\nIf the channel is empty then the keyword args are ignored and both\\n\\\nends are immediately closed.  Otherwise, if 'force' is True then\\n\\\nall queued items are released and both ends are immediately\\n\\\nclosed.\\n\\\n\\n\\\nIf the channel is not empty *and* 'force' is False then following\\n\\\nhappens:\\n\\\n\\n\\\n * recv is True (regardless of send):\\n\\\n   - raise ChannelNotEmptyError\\n\\\n * recv is None and send is None:\\n\\\n   - raise ChannelNotEmptyError\\n\\\n * send is True and recv is not True:\\n\\\n   - fully close the 'send' end\\n\\\n   - close the 'recv' end to interpreters not already receiving\\n\\\n   - fully close it once empty\\n\\\n\\n\\\nClosing an already closed channel results in a ChannelClosedError.\\n\\\n\\n\\\nOnce the channel's ID has no more ref counts in any interpreter\\n\\\nthe channel will be destroyed.\");\n\nstatic PyObject *\nchannelsmod_release(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    // Note that only the current interpreter is affected.\n    static char *kwlist[] = {\"cid\", \"send\", \"recv\", \"force\", NULL};\n    int64_t cid;\n    struct channel_id_converter_data cid_data = {\n        .module = self,\n    };\n    int send = 0;\n    int recv = 0;\n    int force = 0;\n    if (!PyArg_ParseTupleAndKeywords(args, kwds,\n                                     \"O&|$ppp:channel_release\", kwlist,\n                                     channel_id_converter, &cid_data,\n                                     &send, &recv, &force)) {\n        return NULL;\n    }\n    cid = cid_data.cid;\n    if (send == 0 && recv == 0) {\n        send = 1;\n        recv = 1;\n    }\n\n    // XXX Handle force is True.\n    // XXX Fix implicit release.\n\n    int err = channel_release(&_globals.channels, cid, send, recv);\n    if (handle_channel_error(err, self, cid)) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(channelsmod_release_doc,\n\"channel_release(cid, *, send=None, recv=None, force=True)\\n\\\n\\n\\\nClose the channel for the current interpreter.  'send' and 'recv'\\n\\\n(bool) may be used to indicate the ends to close.  By default both\\n\\\nends are closed.  Closing an already closed end is a noop.\");\n\nstatic PyObject *\nchannelsmod_get_count(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"cid\", NULL};\n    struct channel_id_converter_data cid_data = {\n        .module = self,\n    };\n    if (!PyArg_ParseTupleAndKeywords(args, kwds,\n                                     \"O&:get_count\", kwlist,\n                                     channel_id_converter, &cid_data)) {\n        return NULL;\n    }\n    int64_t cid = cid_data.cid;\n\n    Py_ssize_t count = -1;\n    int err = _channel_get_count(&_globals.channels, cid, &count);\n    if (handle_channel_error(err, self, cid)) {\n        return NULL;\n    }\n    assert(count >= 0);\n    return PyLong_FromSsize_t(count);\n}\n\nPyDoc_STRVAR(channelsmod_get_count_doc,\n\"get_count(cid)\\n\\\n\\n\\\nReturn the number of items in the channel.\");\n\nstatic PyObject *\nchannelsmod_get_info(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"cid\", NULL};\n    struct channel_id_converter_data cid_data = {\n        .module = self,\n    };\n    if (!PyArg_ParseTupleAndKeywords(args, kwds,\n                                     \"O&:_get_info\", kwlist,\n                                     channel_id_converter, &cid_data)) {\n        return NULL;\n    }\n    int64_t cid = cid_data.cid;\n\n    struct channel_info info;\n    int err = _channel_get_info(&_globals.channels, cid, &info);\n    if (handle_channel_error(err, self, cid)) {\n        return NULL;\n    }\n    return new_channel_info(self, &info);\n}\n\nPyDoc_STRVAR(channelsmod_get_info_doc,\n\"get_info(cid)\\n\\\n\\n\\\nReturn details about the channel.\");\n\nstatic PyObject *\nchannelsmod_get_channel_defaults(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"cid\", NULL};\n    struct channel_id_converter_data cid_data = {\n        .module = self,\n    };\n    if (!PyArg_ParseTupleAndKeywords(args, kwds,\n                                     \"O&:get_channel_defaults\", kwlist,\n                                     channel_id_converter, &cid_data)) {\n        return NULL;\n    }\n    int64_t cid = cid_data.cid;\n\n    PyThread_type_lock mutex = NULL;\n    _channel_state *channel = NULL;\n    int err = _channels_lookup(&_globals.channels, cid, &mutex, &channel);\n    if (handle_channel_error(err, self, cid)) {\n        return NULL;\n    }\n    int unboundop = channel->defaults.unboundop;\n    PyThread_release_lock(mutex);\n\n    PyObject *defaults = Py_BuildValue(\"i\", unboundop);\n    return defaults;\n}\n\nPyDoc_STRVAR(channelsmod_get_channel_defaults_doc,\n\"get_channel_defaults(cid)\\n\\\n\\n\\\nReturn the channel's default values, set when it was created.\");\n\nstatic PyObject *\nchannelsmod__channel_id(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    module_state *state = get_module_state(self);\n    if (state == NULL) {\n        return NULL;\n    }\n    PyTypeObject *cls = state->ChannelIDType;\n\n    PyObject *mod = get_module_from_owned_type(cls);\n    assert(mod == self);\n    Py_DECREF(mod);\n\n    return _channelid_new(self, cls, args, kwds);\n}\n\nstatic PyObject *\nchannelsmod__register_end_types(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"send\", \"recv\", NULL};\n    PyObject *send;\n    PyObject *recv;\n    if (!PyArg_ParseTupleAndKeywords(args, kwds,\n                                     \"OO:_register_end_types\", kwlist,\n                                     &send, &recv)) {\n        return NULL;\n    }\n    if (!PyType_Check(send)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a type for 'send'\");\n        return NULL;\n    }\n    if (!PyType_Check(recv)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a type for 'recv'\");\n        return NULL;\n    }\n    PyTypeObject *cls_send = (PyTypeObject *)send;\n    PyTypeObject *cls_recv = (PyTypeObject *)recv;\n\n    if (set_channelend_types(self, cls_send, cls_recv) < 0) {\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\nstatic PyMethodDef module_functions[] = {\n    {\"create\",                     _PyCFunction_CAST(channelsmod_create),\n     METH_VARARGS | METH_KEYWORDS, channelsmod_create_doc},\n    {\"destroy\",                    _PyCFunction_CAST(channelsmod_destroy),\n     METH_VARARGS | METH_KEYWORDS, channelsmod_destroy_doc},\n    {\"list_all\",                   channelsmod_list_all,\n     METH_NOARGS,                  channelsmod_list_all_doc},\n    {\"list_interpreters\",          _PyCFunction_CAST(channelsmod_list_interpreters),\n     METH_VARARGS | METH_KEYWORDS, channelsmod_list_interpreters_doc},\n    {\"send\",                       _PyCFunction_CAST(channelsmod_send),\n     METH_VARARGS | METH_KEYWORDS, channelsmod_send_doc},\n    {\"send_buffer\",                _PyCFunction_CAST(channelsmod_send_buffer),\n     METH_VARARGS | METH_KEYWORDS, channelsmod_send_buffer_doc},\n    {\"recv\",                       _PyCFunction_CAST(channelsmod_recv),\n     METH_VARARGS | METH_KEYWORDS, channelsmod_recv_doc},\n    {\"close\",                      _PyCFunction_CAST(channelsmod_close),\n     METH_VARARGS | METH_KEYWORDS, channelsmod_close_doc},\n    {\"release\",                    _PyCFunction_CAST(channelsmod_release),\n     METH_VARARGS | METH_KEYWORDS, channelsmod_release_doc},\n    {\"get_count\",                   _PyCFunction_CAST(channelsmod_get_count),\n     METH_VARARGS | METH_KEYWORDS, channelsmod_get_count_doc},\n    {\"get_info\",                   _PyCFunction_CAST(channelsmod_get_info),\n     METH_VARARGS | METH_KEYWORDS, channelsmod_get_info_doc},\n    {\"get_channel_defaults\",       _PyCFunction_CAST(channelsmod_get_channel_defaults),\n     METH_VARARGS | METH_KEYWORDS, channelsmod_get_channel_defaults_doc},\n    {\"_channel_id\",                _PyCFunction_CAST(channelsmod__channel_id),\n     METH_VARARGS | METH_KEYWORDS, NULL},\n    {\"_register_end_types\",        _PyCFunction_CAST(channelsmod__register_end_types),\n     METH_VARARGS | METH_KEYWORDS, NULL},\n\n    {NULL,                        NULL}           /* sentinel */\n};\n\n\n/* initialization function */\n\nPyDoc_STRVAR(module_doc,\n\"This module provides primitive operations to manage Python interpreters.\\n\\\nThe 'interpreters' module provides a more convenient interface.\");\n\nstatic int\nmodule_exec(PyObject *mod)\n{\n    if (_globals_init() != 0) {\n        return -1;\n    }\n\n    module_state *state = get_module_state(mod);\n    if (state == NULL) {\n        goto error;\n    }\n\n    /* Add exception types */\n    if (exceptions_init(mod) != 0) {\n        goto error;\n    }\n\n    /* Add other types */\n\n    // ChannelInfo\n    state->ChannelInfoType = PyStructSequence_NewType(&channel_info_desc);\n    if (state->ChannelInfoType == NULL) {\n        goto error;\n    }\n    if (PyModule_AddType(mod, state->ChannelInfoType) < 0) {\n        goto error;\n    }\n\n    // ChannelID\n    state->ChannelIDType = add_channelid_type(mod);\n    if (state->ChannelIDType == NULL) {\n        goto error;\n    }\n\n    /* Make sure chnnels drop objects owned by this interpreter. */\n    PyInterpreterState *interp = _get_current_interp();\n    PyUnstable_AtExit(interp, clear_interpreter, (void *)interp);\n\n    return 0;\n\nerror:\n    if (state != NULL) {\n        clear_xid_types(state);\n    }\n    _globals_fini();\n    return -1;\n}\n\nstatic struct PyModuleDef_Slot module_slots[] = {\n    {Py_mod_exec, module_exec},\n    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},\n    {Py_mod_gil, Py_MOD_GIL_NOT_USED},\n    {0, NULL},\n};\n\nstatic int\nmodule_traverse(PyObject *mod, visitproc visit, void *arg)\n{\n    module_state *state = get_module_state(mod);\n    assert(state != NULL);\n    traverse_module_state(state, visit, arg);\n    return 0;\n}\n\nstatic int\nmodule_clear(PyObject *mod)\n{\n    module_state *state = get_module_state(mod);\n    assert(state != NULL);\n\n    // Now we clear the module state.\n    clear_module_state(state);\n    return 0;\n}\n\nstatic void\nmodule_free(void *mod)\n{\n    module_state *state = get_module_state(mod);\n    assert(state != NULL);\n\n    // Now we clear the module state.\n    clear_module_state(state);\n\n    _globals_fini();\n}\n\nstatic struct PyModuleDef moduledef = {\n    .m_base = PyModuleDef_HEAD_INIT,\n    .m_name = MODULE_NAME_STR,\n    .m_doc = module_doc,\n    .m_size = sizeof(module_state),\n    .m_methods = module_functions,\n    .m_slots = module_slots,\n    .m_traverse = module_traverse,\n    .m_clear = module_clear,\n    .m_free = (freefunc)module_free,\n};\n\nPyMODINIT_FUNC\nMODINIT_FUNC_NAME(void)\n{\n    return PyModuleDef_Init(&moduledef);\n}\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/object.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_OBJECT_H\n#define Py_OBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Object and type object interface */\n\n/*\nObjects are structures allocated on the heap.  Special rules apply to\nthe use of objects to ensure they are properly garbage-collected.\nObjects are never allocated statically or on the stack; they must be\naccessed through special macros and functions only.  (Type objects are\nexceptions to the first rule; the standard types are represented by\nstatically initialized type objects, although work on type/class unification\nfor Python 2.2 made it possible to have heap-allocated type objects too).\n\nAn object has a 'reference count' that is increased or decreased when a\npointer to the object is copied or deleted; when the reference count\nreaches zero there are no references to the object left and it can be\nremoved from the heap.\n\nAn object has a 'type' that determines what it represents and what kind\nof data it contains.  An object's type is fixed when it is created.\nTypes themselves are represented as objects; an object contains a\npointer to the corresponding type object.  The type itself has a type\npointer pointing to the object representing the type 'type', which\ncontains a pointer to itself!.\n\nObjects do not float around in memory; once allocated an object keeps\nthe same size and address.  Objects that must hold variable-size data\ncan contain pointers to variable-size parts of the object.  Not all\nobjects of the same type have the same size; but the size cannot change\nafter allocation.  (These restrictions are made so a reference to an\nobject can be simply a pointer -- moving an object would require\nupdating all the pointers, and changing an object's size would require\nmoving it if there was another object right next to it.)\n\nObjects are always accessed through pointers of the type 'PyObject *'.\nThe type 'PyObject' is a structure that only contains the reference count\nand the type pointer.  The actual memory allocated for an object\ncontains other data that can only be accessed after casting the pointer\nto a pointer to a longer structure type.  This longer type must start\nwith the reference count and type fields; the macro PyObject_HEAD should be\nused for this (to accommodate for future changes).  The implementation\nof a particular object type can cast the object pointer to the proper\ntype and back.\n\nA standard interface exists for objects that contain an array of items\nwhose size is determined when the object is allocated.\n*/\n\n/* Py_DEBUG implies Py_REF_DEBUG. */\n#if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)\n#  define Py_REF_DEBUG\n#endif\n\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   PyObject ob_base;\n\n/*\nImmortalization:\n\nThe following indicates the immortalization strategy depending on the amount\nof available bits in the reference count field. All strategies are backwards\ncompatible but the specific reference count value or immortalization check\nmight change depending on the specializations for the underlying system.\n\nProper deallocation of immortal instances requires distinguishing between\nstatically allocated immortal instances vs those promoted by the runtime to be\nimmortal. The latter should be the only instances that require\ncleanup during runtime finalization.\n*/\n\n#if SIZEOF_VOID_P > 4\n/*\nIn 64+ bit systems, an object will be marked as immortal by setting all of the\nlower 32 bits of the reference count field, which is equal to: 0xFFFFFFFF\n\nUsing the lower 32 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases will use saturated arithmetic, taking advantage of\nhaving all the lower 32 bits set, which will avoid the reference count to go\nbeyond the refcount limit. Immortality checks for reference count decreases will\nbe done by checking the bit sign flag in the lower 32 bits.\n*/\n#define _Py_IMMORTAL_REFCNT _Py_CAST(Py_ssize_t, UINT_MAX)\n\n#else\n/*\nIn 32 bit systems, an object will be marked as immortal by setting all of the\nlower 30 bits of the reference count field, which is equal to: 0x3FFFFFFF\n\nUsing the lower 30 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases and decreases will first go through an immortality\ncheck by comparing the reference count field to the immortality reference count.\n*/\n#define _Py_IMMORTAL_REFCNT _Py_CAST(Py_ssize_t, UINT_MAX >> 2)\n#endif\n\n// Py_GIL_DISABLED builds indicate immortal objects using `ob_ref_local`, which is\n// always 32-bits.\n#ifdef Py_GIL_DISABLED\n#define _Py_IMMORTAL_REFCNT_LOCAL UINT32_MAX\n#endif\n\n// Kept for backward compatibility. It was needed by Py_TRACE_REFS build.\n#define _PyObject_EXTRA_INIT\n\n/* Make all uses of PyObject_HEAD_INIT immortal.\n *\n * Statically allocated objects might be shared between\n * interpreters, so must be marked as immortal.\n */\n#if defined(Py_GIL_DISABLED)\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        0,                          \\\n        0,                          \\\n        { 0 },                      \\\n        0,                          \\\n        _Py_IMMORTAL_REFCNT_LOCAL,  \\\n        0,                          \\\n        (type),                     \\\n    },\n#else\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        { _Py_IMMORTAL_REFCNT },    \\\n        (type)                      \\\n    },\n#endif\n\n#define PyVarObject_HEAD_INIT(type, size) \\\n    {                                     \\\n        PyObject_HEAD_INIT(type)          \\\n        (size)                            \\\n    },\n\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD      PyVarObject ob_base;\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\n#ifndef Py_GIL_DISABLED\nstruct _object {\n#if (defined(__GNUC__) || defined(__clang__)) \\\n        && !(defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L)\n    // On C99 and older, anonymous union is a GCC and clang extension\n    __extension__\n#endif\n#ifdef _MSC_VER\n    // Ignore MSC warning C4201: \"nonstandard extension used:\n    // nameless struct/union\"\n    __pragma(warning(push))\n    __pragma(warning(disable: 4201))\n#endif\n    union {\n       Py_ssize_t ob_refcnt;\n#if SIZEOF_VOID_P > 4\n       PY_UINT32_T ob_refcnt_split[2];\n#endif\n    };\n#ifdef _MSC_VER\n    __pragma(warning(pop))\n#endif\n\n    PyTypeObject *ob_type;\n};\n#else\n// Objects that are not owned by any thread use a thread id (tid) of zero.\n// This includes both immortal objects and objects whose reference count\n// fields have been merged.\n#define _Py_UNOWNED_TID             0\n\n// The shared reference count uses the two least-significant bits to store\n// flags. The remaining bits are used to store the reference count.\n#define _Py_REF_SHARED_SHIFT        2\n#define _Py_REF_SHARED_FLAG_MASK    0x3\n\n// The shared flags are initialized to zero.\n#define _Py_REF_SHARED_INIT         0x0\n#define _Py_REF_MAYBE_WEAKREF       0x1\n#define _Py_REF_QUEUED              0x2\n#define _Py_REF_MERGED              0x3\n\n// Create a shared field from a refcnt and desired flags\n#define _Py_REF_SHARED(refcnt, flags) (((refcnt) << _Py_REF_SHARED_SHIFT) + (flags))\n\nstruct _object {\n    // ob_tid stores the thread id (or zero). It is also used by the GC and the\n    // trashcan mechanism as a linked list pointer and by the GC to store the\n    // computed \"gc_refs\" refcount.\n    uintptr_t ob_tid;\n    uint16_t _padding;\n    PyMutex ob_mutex;           // per-object lock\n    uint8_t ob_gc_bits;         // gc-related state\n    uint32_t ob_ref_local;      // local reference count\n    Py_ssize_t ob_ref_shared;   // shared (atomic) reference count\n    PyTypeObject *ob_type;\n};\n#endif\n\n/* Cast argument to PyObject* type. */\n#define _PyObject_CAST(op) _Py_CAST(PyObject*, (op))\n\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n/* Cast argument to PyVarObject* type. */\n#define _PyVarObject_CAST(op) _Py_CAST(PyVarObject*, (op))\n\n\n// Test if the 'x' object is the 'y' object, the same as \"x is y\" in Python.\nPyAPI_FUNC(int) Py_Is(PyObject *x, PyObject *y);\n#define Py_Is(x, y) ((x) == (y))\n\n#if defined(Py_GIL_DISABLED) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(uintptr_t) _Py_GetThreadLocal_Addr(void);\n\nstatic inline uintptr_t\n_Py_ThreadId(void)\n{\n    uintptr_t tid;\n#if defined(_MSC_VER) && defined(_M_X64)\n    tid = __readgsqword(48);\n#elif defined(_MSC_VER) && defined(_M_IX86)\n    tid = __readfsdword(24);\n#elif defined(_MSC_VER) && defined(_M_ARM64)\n    tid = __getReg(18);\n#elif defined(__i386__)\n    __asm__(\"movl %%gs:0, %0\" : \"=r\" (tid));  // 32-bit always uses GS\n#elif defined(__MACH__) && defined(__x86_64__)\n    __asm__(\"movq %%gs:0, %0\" : \"=r\" (tid));  // x86_64 macOSX uses GS\n#elif defined(__x86_64__)\n   __asm__(\"movq %%fs:0, %0\" : \"=r\" (tid));  // x86_64 Linux, BSD uses FS\n#elif defined(__arm__)\n    __asm__ (\"mrc p15, 0, %0, c13, c0, 3\\nbic %0, %0, #3\" : \"=r\" (tid));\n#elif defined(__aarch64__) && defined(__APPLE__)\n    __asm__ (\"mrs %0, tpidrro_el0\" : \"=r\" (tid));\n#elif defined(__aarch64__)\n    __asm__ (\"mrs %0, tpidr_el0\" : \"=r\" (tid));\n#elif defined(__powerpc64__)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // r13 is reserved for use as system thread ID by the Power 64-bit ABI.\n    register uintptr_t tp __asm__ (\"r13\");\n    __asm__(\"\" : \"=r\" (tp));\n    tid = tp;\n    #endif\n#elif defined(__powerpc__)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // r2 is reserved for use as system thread ID by the Power 32-bit ABI.\n    register uintptr_t tp __asm__ (\"r2\");\n    __asm__ (\"\" : \"=r\" (tp));\n    tid = tp;\n    #endif\n#elif defined(__s390__) && defined(__GNUC__)\n    // Both GCC and Clang have supported __builtin_thread_pointer\n    // for s390 from long time ago.\n    tid = (uintptr_t)__builtin_thread_pointer();\n#elif defined(__riscv)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // tp is Thread Pointer provided by the RISC-V ABI.\n    __asm__ (\"mv %0, tp\" : \"=r\" (tid));\n    #endif\n#else\n    // Fallback to a portable implementation if we do not have a faster\n    // platform-specific implementation.\n    tid = _Py_GetThreadLocal_Addr();\n#endif\n  return tid;\n}\n\nstatic inline Py_ALWAYS_INLINE int\n_Py_IsOwnedByCurrentThread(PyObject *ob)\n{\n#ifdef _Py_THREAD_SANITIZER\n    return _Py_atomic_load_uintptr_relaxed(&ob->ob_tid) == _Py_ThreadId();\n#else\n    return ob->ob_tid == _Py_ThreadId();\n#endif\n}\n#endif\n\nstatic inline Py_ssize_t Py_REFCNT(PyObject *ob) {\n#if !defined(Py_GIL_DISABLED)\n    return ob->ob_refcnt;\n#else\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&ob->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return _Py_IMMORTAL_REFCNT;\n    }\n    Py_ssize_t shared = _Py_atomic_load_ssize_relaxed(&ob->ob_ref_shared);\n    return _Py_STATIC_CAST(Py_ssize_t, local) +\n           Py_ARITHMETIC_RIGHT_SHIFT(Py_ssize_t, shared, _Py_REF_SHARED_SHIFT);\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_REFCNT(ob) Py_REFCNT(_PyObject_CAST(ob))\n#endif\n\n\n// bpo-39573: The Py_SET_TYPE() function must be used to set an object type.\nstatic inline PyTypeObject* Py_TYPE(PyObject *ob) {\n    return ob->ob_type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_TYPE(ob) Py_TYPE(_PyObject_CAST(ob))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyLong_Type;\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n\n// bpo-39573: The Py_SET_SIZE() function must be used to set an object size.\nstatic inline Py_ssize_t Py_SIZE(PyObject *ob) {\n    assert(ob->ob_type != &PyLong_Type);\n    assert(ob->ob_type != &PyBool_Type);\n    return  _PyVarObject_CAST(ob)->ob_size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SIZE(ob) Py_SIZE(_PyObject_CAST(ob))\n#endif\n\nstatic inline Py_ALWAYS_INLINE int _Py_IsImmortal(PyObject *op)\n{\n#if defined(Py_GIL_DISABLED)\n    return (_Py_atomic_load_uint32_relaxed(&op->ob_ref_local) ==\n            _Py_IMMORTAL_REFCNT_LOCAL);\n#elif SIZEOF_VOID_P > 4\n    return (_Py_CAST(PY_INT32_T, op->ob_refcnt) < 0);\n#else\n    return (op->ob_refcnt == _Py_IMMORTAL_REFCNT);\n#endif\n}\n#define _Py_IsImmortal(op) _Py_IsImmortal(_PyObject_CAST(op))\n\nstatic inline int Py_IS_TYPE(PyObject *ob, PyTypeObject *type) {\n    return Py_TYPE(ob) == type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_IS_TYPE(ob, type) Py_IS_TYPE(_PyObject_CAST(ob), (type))\n#endif\n\n\n// Py_SET_REFCNT() implementation for stable ABI\nPyAPI_FUNC(void) _Py_SetRefcnt(PyObject *ob, Py_ssize_t refcnt);\n\nstatic inline void Py_SET_REFCNT(PyObject *ob, Py_ssize_t refcnt) {\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030d0000\n    // Stable ABI implements Py_SET_REFCNT() as a function call\n    // on limited C API version 3.13 and newer.\n    _Py_SetRefcnt(ob, refcnt);\n#else\n    // This immortal check is for code that is unaware of immortal objects.\n    // The runtime tracks these objects and we should avoid as much\n    // as possible having extensions inadvertently change the refcnt\n    // of an immortalized object.\n    if (_Py_IsImmortal(ob)) {\n        return;\n    }\n\n#ifndef Py_GIL_DISABLED\n    ob->ob_refcnt = refcnt;\n#else\n    if (_Py_IsOwnedByCurrentThread(ob)) {\n        if ((size_t)refcnt > (size_t)UINT32_MAX) {\n            // On overflow, make the object immortal\n            ob->ob_tid = _Py_UNOWNED_TID;\n            ob->ob_ref_local = _Py_IMMORTAL_REFCNT_LOCAL;\n            ob->ob_ref_shared = 0;\n        }\n        else {\n            // Set local refcount to desired refcount and shared refcount\n            // to zero, but preserve the shared refcount flags.\n            ob->ob_ref_local = _Py_STATIC_CAST(uint32_t, refcnt);\n            ob->ob_ref_shared &= _Py_REF_SHARED_FLAG_MASK;\n        }\n    }\n    else {\n        // Set local refcount to zero and shared refcount to desired refcount.\n        // Mark the object as merged.\n        ob->ob_tid = _Py_UNOWNED_TID;\n        ob->ob_ref_local = 0;\n        ob->ob_ref_shared = _Py_REF_SHARED(refcnt, _Py_REF_MERGED);\n    }\n#endif  // Py_GIL_DISABLED\n#endif  // Py_LIMITED_API+0 < 0x030d0000\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_REFCNT(ob, refcnt) Py_SET_REFCNT(_PyObject_CAST(ob), (refcnt))\n#endif\n\n\nstatic inline void Py_SET_TYPE(PyObject *ob, PyTypeObject *type) {\n    ob->ob_type = type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_TYPE(ob, type) Py_SET_TYPE(_PyObject_CAST(ob), type)\n#endif\n\nstatic inline void Py_SET_SIZE(PyVarObject *ob, Py_ssize_t size) {\n    assert(ob->ob_base.ob_type != &PyLong_Type);\n    assert(ob->ob_base.ob_type != &PyBool_Type);\n#ifdef Py_GIL_DISABLED\n    _Py_atomic_store_ssize_relaxed(&ob->ob_size, size);\n#else\n    ob->ob_size = size;\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_SIZE(ob, size) Py_SET_SIZE(_PyVarObject_CAST(ob), (size))\n#endif\n\n\n/*\nType objects contain a string containing the type name (to help somewhat\nin debugging), the allocation parameters (see PyObject_New() and\nPyObject_NewVar()),\nand methods for accessing objects of the type.  Methods are optional, a\nnil pointer meaning that particular kind of access is not available for\nthis type.  The Py_DECREF() macro uses the tp_dealloc method without\nchecking for a nil pointer; it should always be implemented except if\nthe implementation can guarantee that the reference count will never\nreach zero (e.g., for statically allocated type objects).\n\nNB: the methods for certain type groups are now contained in separate\nmethod blocks.\n*/\n\ntypedef PyObject * (*unaryfunc)(PyObject *);\ntypedef PyObject * (*binaryfunc)(PyObject *, PyObject *);\ntypedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);\ntypedef int (*inquiry)(PyObject *);\ntypedef Py_ssize_t (*lenfunc)(PyObject *);\ntypedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);\ntypedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);\ntypedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);\ntypedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);\ntypedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);\n\ntypedef int (*objobjproc)(PyObject *, PyObject *);\ntypedef int (*visitproc)(PyObject *, void *);\ntypedef int (*traverseproc)(PyObject *, visitproc, void *);\n\n\ntypedef void (*freefunc)(void *);\ntypedef void (*destructor)(PyObject *);\ntypedef PyObject *(*getattrfunc)(PyObject *, char *);\ntypedef PyObject *(*getattrofunc)(PyObject *, PyObject *);\ntypedef int (*setattrfunc)(PyObject *, char *, PyObject *);\ntypedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*reprfunc)(PyObject *);\ntypedef Py_hash_t (*hashfunc)(PyObject *);\ntypedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);\ntypedef PyObject *(*getiterfunc) (PyObject *);\ntypedef PyObject *(*iternextfunc) (PyObject *);\ntypedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*initproc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*newfunc)(PyTypeObject *, PyObject *, PyObject *);\ntypedef PyObject *(*allocfunc)(PyTypeObject *, Py_ssize_t);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030c0000 // 3.12\ntypedef PyObject *(*vectorcallfunc)(PyObject *callable, PyObject *const *args,\n                                    size_t nargsf, PyObject *kwnames);\n#endif\n\ntypedef struct{\n    int slot;    /* slot id, see below */\n    void *pfunc; /* function pointer */\n} PyType_Slot;\n\ntypedef struct{\n    const char* name;\n    int basicsize;\n    int itemsize;\n    unsigned int flags;\n    PyType_Slot *slots; /* terminated by slot==0. */\n} PyType_Spec;\n\nPyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000\nPyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);\nPyAPI_FUNC(PyObject *) PyType_GetModule(PyTypeObject *);\nPyAPI_FUNC(void *) PyType_GetModuleState(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000\nPyAPI_FUNC(PyObject *) PyType_GetName(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GetQualName(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030D0000\nPyAPI_FUNC(PyObject *) PyType_GetFullyQualifiedName(PyTypeObject *type);\nPyAPI_FUNC(PyObject *) PyType_GetModuleName(PyTypeObject *type);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\nPyAPI_FUNC(PyObject *) PyType_FromMetaclass(PyTypeObject*, PyObject*, PyType_Spec*, PyObject*);\nPyAPI_FUNC(void *) PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls);\nPyAPI_FUNC(Py_ssize_t) PyType_GetTypeDataSize(PyTypeObject *cls);\n#endif\n\n/* Generic type check */\nPyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);\n\nstatic inline int PyObject_TypeCheck(PyObject *ob, PyTypeObject *type) {\n    return Py_IS_TYPE(ob, type) || PyType_IsSubtype(Py_TYPE(ob), type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyObject_TypeCheck(ob, type) PyObject_TypeCheck(_PyObject_CAST(ob), (type))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */\nPyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */\nPyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */\n\nPyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);\n\nPyAPI_FUNC(int) PyType_Ready(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,\n                                               PyObject *, PyObject *);\nPyAPI_FUNC(unsigned int) PyType_ClearCache(void);\nPyAPI_FUNC(void) PyType_Modified(PyTypeObject *);\n\n/* Generic operations on objects */\nPyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);\nPyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);\nPyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);\nPyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);\nPyAPI_FUNC(int) PyObject_DelAttrString(PyObject *v, const char *name);\nPyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(int) PyObject_GetOptionalAttr(PyObject *, PyObject *, PyObject **);\nPyAPI_FUNC(int) PyObject_GetOptionalAttrString(PyObject *, const char *, PyObject **);\n#endif\nPyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_DelAttr(PyObject *v, PyObject *name);\nPyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(int) PyObject_HasAttrWithError(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttrStringWithError(PyObject *, const char *);\n#endif\nPyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);\n#endif\nPyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);\nPyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);\nPyAPI_FUNC(int) PyObject_IsTrue(PyObject *);\nPyAPI_FUNC(int) PyObject_Not(PyObject *);\nPyAPI_FUNC(int) PyCallable_Check(PyObject *);\nPyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);\n\n/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a\n   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),\n   returning the names of the current locals.  In this case, if there are\n   no current locals, NULL is returned, and PyErr_Occurred() is false.\n*/\nPyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);\n\n/* Helpers for printing recursive container types */\nPyAPI_FUNC(int) Py_ReprEnter(PyObject *);\nPyAPI_FUNC(void) Py_ReprLeave(PyObject *);\n\n/* Flag bits for printing: */\n#define Py_PRINT_RAW    1       /* No string quotes etc. */\n\n/*\nType flags (tp_flags)\n\nThese flags are used to change expected features and behavior for a\nparticular type.\n\nArbitration of the flag bit positions will need to be coordinated among\nall extension writers who publicly release their extensions (this will\nbe fewer than you might expect!).\n\nMost flags were removed as of Python 3.0 to make room for new flags.  (Some\nflags are not for backwards compatibility but to indicate the presence of an\noptional feature; these flags remain of course.)\n\nType definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.\n\nCode can use PyType_HasFeature(type_ob, flag_value) to test whether the\ngiven type object has a specified feature.\n*/\n\n#ifndef Py_LIMITED_API\n\n/* Track types initialized using _PyStaticType_InitBuiltin(). */\n#define _Py_TPFLAGS_STATIC_BUILTIN (1 << 1)\n\n/* The values array is placed inline directly after the rest of\n * the object. Implies Py_TPFLAGS_HAVE_GC.\n */\n#define Py_TPFLAGS_INLINE_VALUES (1 << 2)\n\n/* Placement of weakref pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_weaklistoffset.\n */\n#define Py_TPFLAGS_MANAGED_WEAKREF (1 << 3)\n\n/* Placement of dict (and values) pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_dictoffset. Implies Py_TPFLAGS_HAVE_GC.\n */\n#define Py_TPFLAGS_MANAGED_DICT (1 << 4)\n\n#define Py_TPFLAGS_PREHEADER (Py_TPFLAGS_MANAGED_WEAKREF | Py_TPFLAGS_MANAGED_DICT)\n\n/* Set if instances of the type object are treated as sequences for pattern matching */\n#define Py_TPFLAGS_SEQUENCE (1 << 5)\n/* Set if instances of the type object are treated as mappings for pattern matching */\n#define Py_TPFLAGS_MAPPING (1 << 6)\n#endif\n\n/* Disallow creating instances of the type: set tp_new to NULL and don't create\n * the \"__new__\" key in the type dictionary. */\n#define Py_TPFLAGS_DISALLOW_INSTANTIATION (1UL << 7)\n\n/* Set if the type object is immutable: type attributes cannot be set nor deleted */\n#define Py_TPFLAGS_IMMUTABLETYPE (1UL << 8)\n\n/* Set if the type object is dynamically allocated */\n#define Py_TPFLAGS_HEAPTYPE (1UL << 9)\n\n/* Set if the type allows subclassing */\n#define Py_TPFLAGS_BASETYPE (1UL << 10)\n\n/* Set if the type implements the vectorcall protocol (PEP 590) */\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\n#define Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)\n#ifndef Py_LIMITED_API\n// Backwards compatibility alias for API that was provisional in Python 3.8\n#define _Py_TPFLAGS_HAVE_VECTORCALL Py_TPFLAGS_HAVE_VECTORCALL\n#endif\n#endif\n\n/* Set if the type is 'ready' -- fully initialized */\n#define Py_TPFLAGS_READY (1UL << 12)\n\n/* Set while the type is being 'readied', to prevent recursive ready calls */\n#define Py_TPFLAGS_READYING (1UL << 13)\n\n/* Objects support garbage collection (see objimpl.h) */\n#define Py_TPFLAGS_HAVE_GC (1UL << 14)\n\n/* These two bits are preserved for Stackless Python, next after this is 17 */\n#ifdef STACKLESS\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)\n#else\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0\n#endif\n\n/* Objects behave like an unbound method */\n#define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)\n\n/* Unused. Legacy flag */\n#define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)\n\n/* Type is abstract and cannot be instantiated */\n#define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)\n\n// This undocumented flag gives certain built-ins their unique pattern-matching\n// behavior, which allows a single positional subpattern to match against the\n// subject itself (rather than a mapped attribute on it):\n#define _Py_TPFLAGS_MATCH_SELF (1UL << 22)\n\n/* Items (ob_size*tp_itemsize) are found at the end of an instance's memory */\n#define Py_TPFLAGS_ITEMS_AT_END (1UL << 23)\n\n/* These flags are used to determine if a type is a subclass. */\n#define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)\n#define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)\n#define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)\n#define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)\n#define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)\n#define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)\n#define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)\n#define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)\n\n#define Py_TPFLAGS_DEFAULT  ( \\\n                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \\\n                0)\n\n/* NOTE: Some of the following flags reuse lower bits (removed as part of the\n * Python 3.0 transition). */\n\n/* The following flags are kept for compatibility; in previous\n * versions they indicated presence of newer tp_* fields on the\n * type struct.\n * Starting with 3.8, binary compatibility of C extensions across\n * feature releases of Python is not supported anymore (except when\n * using the stable ABI, in which all classes are created dynamically,\n * using the interpreter's memory layout.)\n * Note that older extensions using the stable ABI set these flags,\n * so the bits must not be repurposed.\n */\n#define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)\n#define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)\n\n\n/*\nThe macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement\nreference counts.  Py_DECREF calls the object's deallocator function when\nthe refcount falls to 0; for\nobjects that don't contain references to other objects or heap memory\nthis can be the standard function free().  Both macros can be used\nwherever a void expression is allowed.  The argument must not be a\nNULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.\nThe macro _Py_NewReference(op) initialize reference counts to 1, and\nin special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional\nbookkeeping appropriate to the special build.\n\nWe assume that the reference count field can never overflow; this can\nbe proven when the size of the field is the same as the pointer size, so\nwe ignore the possibility.  Provided a C int is at least 32 bits (which\nis implicitly assumed in many parts of this code), that's enough for\nabout 2**31 references to an object.\n\nXXX The following became out of date in Python 2.2, but I'm not sure\nXXX what the full truth is now.  Certainly, heap-allocated type objects\nXXX can and should be deallocated.\nType objects should never be deallocated; the type pointer in an object\nis not considered to be a reference to the type object, to save\ncomplications in the deallocation function.  (This is actually a\ndecision that's up to the implementer of each new type so if you want,\nyou can count such references to the type object.)\n*/\n\n#if defined(Py_REF_DEBUG) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,\n                                      PyObject *op);\nPyAPI_FUNC(void) _Py_INCREF_IncRefTotal(void);\nPyAPI_FUNC(void) _Py_DECREF_DecRefTotal(void);\n#endif  // Py_REF_DEBUG && !Py_LIMITED_API\n\nPyAPI_FUNC(void) _Py_Dealloc(PyObject *);\n\n/*\nThese are provided as conveniences to Python runtime embedders, so that\nthey can have object code that is not dependent on Python compilation flags.\n*/\nPyAPI_FUNC(void) Py_IncRef(PyObject *);\nPyAPI_FUNC(void) Py_DecRef(PyObject *);\n\n// Similar to Py_IncRef() and Py_DecRef() but the argument must be non-NULL.\n// Private functions used by Py_INCREF() and Py_DECREF().\nPyAPI_FUNC(void) _Py_IncRef(PyObject *);\nPyAPI_FUNC(void) _Py_DecRef(PyObject *);\n\nstatic inline Py_ALWAYS_INLINE void Py_INCREF(PyObject *op)\n{\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n    // Stable ABI implements Py_INCREF() as a function call on limited C API\n    // version 3.12 and newer, and on Python built in debug mode. _Py_IncRef()\n    // was added to Python 3.10.0a7, use Py_IncRef() on older Python versions.\n    // Py_IncRef() accepts NULL whereas _Py_IncRef() doesn't.\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_IncRef(op);\n#  else\n    Py_IncRef(op);\n#  endif\n#else\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n#if defined(Py_GIL_DISABLED)\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    uint32_t new_local = local + 1;\n    if (new_local == 0) {\n        // local is equal to _Py_IMMORTAL_REFCNT: do nothing\n        return;\n    }\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, new_local);\n    }\n    else {\n        _Py_atomic_add_ssize(&op->ob_ref_shared, (1 << _Py_REF_SHARED_SHIFT));\n    }\n#elif SIZEOF_VOID_P > 4\n    // Portable saturated add, branching on the carry flag and set low bits\n    PY_UINT32_T cur_refcnt = op->ob_refcnt_split[PY_BIG_ENDIAN];\n    PY_UINT32_T new_refcnt = cur_refcnt + 1;\n    if (new_refcnt == 0) {\n        // cur_refcnt is equal to _Py_IMMORTAL_REFCNT: the object is immortal,\n        // do nothing\n        return;\n    }\n    op->ob_refcnt_split[PY_BIG_ENDIAN] = new_refcnt;\n#else\n    // Explicitly check immortality against the immortal value\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    op->ob_refcnt++;\n#endif\n    _Py_INCREF_STAT_INC();\n#ifdef Py_REF_DEBUG\n    _Py_INCREF_IncRefTotal();\n#endif\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_INCREF(op) Py_INCREF(_PyObject_CAST(op))\n#endif\n\n\n#if !defined(Py_LIMITED_API) && defined(Py_GIL_DISABLED)\n// Implements Py_DECREF on objects not owned by the current thread.\nPyAPI_FUNC(void) _Py_DecRefShared(PyObject *);\nPyAPI_FUNC(void) _Py_DecRefSharedDebug(PyObject *, const char *, int);\n\n// Called from Py_DECREF by the owning thread when the local refcount reaches\n// zero. The call will deallocate the object if the shared refcount is also\n// zero. Otherwise, the thread gives up ownership and merges the reference\n// count fields.\nPyAPI_FUNC(void) _Py_MergeZeroLocalRefcount(PyObject *);\n#endif\n\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n// Stable ABI implements Py_DECREF() as a function call on limited C API\n// version 3.12 and newer, and on Python built in debug mode. _Py_DecRef() was\n// added to Python 3.10.0a7, use Py_DecRef() on older Python versions.\n// Py_DecRef() accepts NULL whereas _Py_IncRef() doesn't.\nstatic inline void Py_DECREF(PyObject *op) {\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_DecRef(op);\n#  else\n    Py_DecRef(op);\n#  endif\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_GIL_DISABLED) && defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        if (local == 0) {\n            _Py_NegativeRefcount(filename, lineno, op);\n        }\n        local--;\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, local);\n        if (local == 0) {\n            _Py_MergeZeroLocalRefcount(op);\n        }\n    }\n    else {\n        _Py_DecRefSharedDebug(op, filename, lineno);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#elif defined(Py_GIL_DISABLED)\nstatic inline void Py_DECREF(PyObject *op)\n{\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        local--;\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, local);\n        if (local == 0) {\n            _Py_MergeZeroLocalRefcount(op);\n        }\n    }\n    else {\n        _Py_DecRefShared(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    if (op->ob_refcnt <= 0) {\n        _Py_NegativeRefcount(filename, lineno, op);\n    }\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#else\nstatic inline Py_ALWAYS_INLINE void Py_DECREF(PyObject *op)\n{\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n#endif\n\n\n/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear\n * and tp_dealloc implementations.\n *\n * Note that \"the obvious\" code can be deadly:\n *\n *     Py_XDECREF(op);\n *     op = NULL;\n *\n * Typically, `op` is something like self->containee, and `self` is done\n * using its `containee` member.  In the code sequence above, suppose\n * `containee` is non-NULL with a refcount of 1.  Its refcount falls to\n * 0 on the first line, which can trigger an arbitrary amount of code,\n * possibly including finalizers (like __del__ methods or weakref callbacks)\n * coded in Python, which in turn can release the GIL and allow other threads\n * to run, etc.  Such code may even invoke methods of `self` again, or cause\n * cyclic gc to trigger, but-- oops! --self->containee still points to the\n * object being torn down, and it may be in an insane state while being torn\n * down.  This has in fact been a rich historic source of miserable (rare &\n * hard-to-diagnose) segfaulting (and other) bugs.\n *\n * The safe way is:\n *\n *      Py_CLEAR(op);\n *\n * That arranges to set `op` to NULL _before_ decref'ing, so that any code\n * triggered as a side-effect of `op` getting torn down no longer believes\n * `op` points to a valid object.\n *\n * There are cases where it's safe to use the naive code, but they're brittle.\n * For example, if `op` points to a Python integer, you know that destroying\n * one of those can't cause problems -- but in part that relies on that\n * Python integers aren't currently weakly referencable.  Best practice is\n * to use Py_CLEAR() even if you can't think of a reason for why you need to.\n *\n * gh-98724: Use a temporary variable to only evaluate the macro argument once,\n * to avoid the duplication of side effects if the argument has side effects.\n *\n * gh-99701: If the PyObject* type is used with casting arguments to PyObject*,\n * the code can be miscompiled with strict aliasing because of type punning.\n * With strict aliasing, a compiler considers that two pointers of different\n * types cannot read or write the same memory which enables optimization\n * opportunities.\n *\n * If available, use _Py_TYPEOF() to use the 'op' type for temporary variables,\n * and so avoid type punning. Otherwise, use memcpy() which causes type erasure\n * and so prevents the compiler to reuse an old cached 'op' value after\n * Py_CLEAR().\n */\n#ifdef _Py_TYPEOF\n#define Py_CLEAR(op) \\\n    do { \\\n        _Py_TYPEOF(op)* _tmp_op_ptr = &(op); \\\n        _Py_TYPEOF(op) _tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            *_tmp_op_ptr = _Py_NULL; \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#else\n#define Py_CLEAR(op) \\\n    do { \\\n        PyObject **_tmp_op_ptr = _Py_CAST(PyObject**, &(op)); \\\n        PyObject *_tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            PyObject *_null_ptr = _Py_NULL; \\\n            memcpy(_tmp_op_ptr, &_null_ptr, sizeof(PyObject*)); \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#endif\n\n\n/* Function to use in case the object pointer can be NULL: */\nstatic inline void Py_XINCREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_INCREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XINCREF(op) Py_XINCREF(_PyObject_CAST(op))\n#endif\n\nstatic inline void Py_XDECREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_DECREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XDECREF(op) Py_XDECREF(_PyObject_CAST(op))\n#endif\n\n// Create a new strong reference to an object:\n// increment the reference count of the object and return the object.\nPyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);\n\n// Similar to Py_NewRef(), but the object can be NULL.\nPyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);\n\nstatic inline PyObject* _Py_NewRef(PyObject *obj)\n{\n    Py_INCREF(obj);\n    return obj;\n}\n\nstatic inline PyObject* _Py_XNewRef(PyObject *obj)\n{\n    Py_XINCREF(obj);\n    return obj;\n}\n\n// Py_NewRef() and Py_XNewRef() are exported as functions for the stable ABI.\n// Names overridden with macros by static inline functions for best\n// performances.\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_NewRef(obj) _Py_NewRef(_PyObject_CAST(obj))\n#  define Py_XNewRef(obj) _Py_XNewRef(_PyObject_CAST(obj))\n#else\n#  define Py_NewRef(obj) _Py_NewRef(obj)\n#  define Py_XNewRef(obj) _Py_XNewRef(obj)\n#endif\n\n\n#define Py_CONSTANT_NONE 0\n#define Py_CONSTANT_FALSE 1\n#define Py_CONSTANT_TRUE 2\n#define Py_CONSTANT_ELLIPSIS 3\n#define Py_CONSTANT_NOT_IMPLEMENTED 4\n#define Py_CONSTANT_ZERO 5\n#define Py_CONSTANT_ONE 6\n#define Py_CONSTANT_EMPTY_STR 7\n#define Py_CONSTANT_EMPTY_BYTES 8\n#define Py_CONSTANT_EMPTY_TUPLE 9\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(PyObject*) Py_GetConstant(unsigned int constant_id);\nPyAPI_FUNC(PyObject*) Py_GetConstantBorrowed(unsigned int constant_id);\n#endif\n\n\n/*\n_Py_NoneStruct is an object of undefined type which can be used in contexts\nwhere NULL (nil) is not suitable (since NULL often means 'error').\n*/\nPyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000\n#  define Py_None Py_GetConstantBorrowed(Py_CONSTANT_NONE)\n#else\n#  define Py_None (&_Py_NoneStruct)\n#endif\n\n// Test if an object is the None singleton, the same as \"x is None\" in Python.\nPyAPI_FUNC(int) Py_IsNone(PyObject *x);\n#define Py_IsNone(x) Py_Is((x), Py_None)\n\n/* Macro for returning Py_None from a function */\n#define Py_RETURN_NONE return Py_None\n\n/*\nPy_NotImplemented is a singleton used to signal that an operation is\nnot implemented for a given type combination.\n*/\nPyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */\n\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000\n#  define Py_NotImplemented Py_GetConstantBorrowed(Py_CONSTANT_NOT_IMPLEMENTED)\n#else\n#  define Py_NotImplemented (&_Py_NotImplementedStruct)\n#endif\n\n/* Macro for returning Py_NotImplemented from a function */\n#define Py_RETURN_NOTIMPLEMENTED return Py_NotImplemented\n\n/* Rich comparison opcodes */\n#define Py_LT 0\n#define Py_LE 1\n#define Py_EQ 2\n#define Py_NE 3\n#define Py_GT 4\n#define Py_GE 5\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000\n/* Result of calling PyIter_Send */\ntypedef enum {\n    PYGEN_RETURN = 0,\n    PYGEN_ERROR = -1,\n    PYGEN_NEXT = 1,\n} PySendResult;\n#endif\n\n/*\n * Macro for implementing rich comparisons\n *\n * Needs to be a macro because any C-comparable type can be used.\n */\n#define Py_RETURN_RICHCOMPARE(val1, val2, op)                               \\\n    do {                                                                    \\\n        switch (op) {                                                       \\\n        case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        default:                                                            \\\n            Py_UNREACHABLE();                                               \\\n        }                                                                   \\\n    } while (0)\n\n\n/*\nMore conventions\n================\n\nArgument Checking\n-----------------\n\nFunctions that take objects as arguments normally don't check for nil\narguments, but they do check the type of the argument, and return an\nerror if the function doesn't apply to the type.\n\nFailure Modes\n-------------\n\nFunctions may fail for a variety of reasons, including running out of\nmemory.  This is communicated to the caller in two ways: an error string\nis set (see errors.h), and the function result differs: functions that\nnormally return a pointer return NULL for failure, functions returning\nan integer return -1 (which could be a legal return value too!), and\nother functions return 0 for success and -1 for failure.\nCallers should always check for errors before using the result.  If\nan error was set, the caller must either explicitly clear it, or pass\nthe error on to its caller.\n\nReference Counts\n----------------\n\nIt takes a while to get used to the proper usage of reference counts.\n\nFunctions that create an object set the reference count to 1; such new\nobjects must be stored somewhere or destroyed again with Py_DECREF().\nSome functions that 'store' objects, such as PyTuple_SetItem() and\nPyList_SetItem(),\ndon't increment the reference count of the object, since the most\nfrequent use is to store a fresh object.  Functions that 'retrieve'\nobjects, such as PyTuple_GetItem() and PyDict_GetItemString(), also\ndon't increment\nthe reference count, since most frequently the object is only looked at\nquickly.  Thus, to retrieve an object and store it again, the caller\nmust call Py_INCREF() explicitly.\n\nNOTE: functions that 'consume' a reference count, like\nPyList_SetItem(), consume the reference even if the object wasn't\nsuccessfully stored, to simplify error handling.\n\nIt seems attractive to make other functions that take an object as\nargument consume a reference count; however, this may quickly get\nconfusing (even the current practice is already confusing).  Consider\nit carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at\ntimes.\n*/\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_OBJECT_H\n#  include \"cpython/object.h\"\n#  undef Py_CPYTHON_OBJECT_H\n#endif\n\n\nstatic inline int\nPyType_HasFeature(PyTypeObject *type, unsigned long feature)\n{\n    unsigned long flags;\n#ifdef Py_LIMITED_API\n    // PyTypeObject is opaque in the limited C API\n    flags = PyType_GetFlags(type);\n#else\n#   ifdef Py_GIL_DISABLED\n        flags = _Py_atomic_load_ulong_relaxed(&type->tp_flags);\n#   else\n        flags = type->tp_flags;\n#   endif\n#endif\n    return ((flags & feature) != 0);\n}\n\n#define PyType_FastSubclass(type, flag) PyType_HasFeature((type), (flag))\n\nstatic inline int PyType_Check(PyObject *op) {\n    return PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_Check(op) PyType_Check(_PyObject_CAST(op))\n#endif\n\n#define _PyType_CAST(op) \\\n    (assert(PyType_Check(op)), _Py_CAST(PyTypeObject*, (op)))\n\nstatic inline int PyType_CheckExact(PyObject *op) {\n    return Py_IS_TYPE(op, &PyType_Type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_CheckExact(op) PyType_CheckExact(_PyObject_CAST(op))\n#endif\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(PyObject *) PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif   // !Py_OBJECT_H\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-null-dereference",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 6917,
                                       "gcc/analyzer/saved_diagnostic/snode": 1391,
                                       "gcc/analyzer/saved_diagnostic/sval": "(struct PyObject *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 0},
                        "level": "warning",
                        "message": {"text": "dereference of NULL 'op'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 305,
                                                                       "startColumn": 12,
                                                                       "endColumn": 22},
                                                            "contextRegion": {"startLine": 305,
                                                                              "snippet": {"text": "    return ob->ob_tid == _Py_ThreadId();\n"}}},
                                       "logicalLocations": [{"name": "Py_DECREF",
                                                             "fullyQualifiedName": "Py_DECREF",
                                                             "decoratedName": "Py_DECREF",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_interpchannelsmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 3398,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 24},
                                                                                                         "contextRegion": {"startLine": 3398,
                                                                                                                           "snippet": {"text": "channelsmod__channel_id(PyObject *self, PyObject *args, PyObject *kwds)\n"}}},
                                                                                    "logicalLocations": [{"name": "channelsmod__channel_id",
                                                                                                          "fullyQualifiedName": "channelsmod__channel_id",
                                                                                                          "decoratedName": "channelsmod__channel_id",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'channelsmod__channel_id'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 150,
                                                                                                                                 "dst_idx": 151,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_interpchannelsmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 3401,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 3401,
                                                                                                                           "snippet": {"text": "    if (state == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "channelsmod__channel_id",
                                                                                                          "fullyQualifiedName": "channelsmod__channel_id",
                                                                                                          "decoratedName": "channelsmod__channel_id",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'state' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 150,
                                                                                                                                 "dst_idx": 151,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_interpchannelsmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 3404,
                                                                                                                    "startColumn": 19,
                                                                                                                    "endColumn": 22},
                                                                                                         "contextRegion": {"startLine": 3404,
                                                                                                                           "snippet": {"text": "    PyTypeObject *cls = state->ChannelIDType;\n"}}},
                                                                                    "logicalLocations": [{"name": "channelsmod__channel_id",
                                                                                                          "fullyQualifiedName": "channelsmod__channel_id",
                                                                                                          "decoratedName": "channelsmod__channel_id",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 152,
                                                                                                                                 "dst_idx": 1389,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_interpchannelsmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 3408,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 3408,
                                                                                                                           "snippet": {"text": "    Py_DECREF(mod);\n"}}},
                                                                                    "logicalLocations": [{"name": "channelsmod__channel_id",
                                                                                                          "fullyQualifiedName": "channelsmod__channel_id",
                                                                                                          "decoratedName": "channelsmod__channel_id",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'Py_DECREF' from 'channelsmod__channel_id'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 896,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 29},
                                                                                                         "contextRegion": {"startLine": 896,
                                                                                                                           "snippet": {"text": "static inline void Py_DECREF(PyObject *op)\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_DECREF",
                                                                                                          "fullyQualifiedName": "Py_DECREF",
                                                                                                          "decoratedName": "Py_DECREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'Py_DECREF'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1390,
                                                                                                                                 "dst_idx": 1391,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 899,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 899,
                                                                                                                           "snippet": {"text": "    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_DECREF",
                                                                                                          "fullyQualifiedName": "Py_DECREF",
                                                                                                          "decoratedName": "Py_DECREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 903,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 903,
                                                                                                                           "snippet": {"text": "    if (_Py_IsOwnedByCurrentThread(op)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_DECREF",
                                                                                                          "fullyQualifiedName": "Py_DECREF",
                                                                                                          "decoratedName": "Py_DECREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to '_Py_IsOwnedByCurrentThread' from 'Py_DECREF'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "Py_DECREF",
                                                                                                                                     "fullyQualifiedName": "Py_DECREF",
                                                                                                                                     "decoratedName": "Py_DECREF",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 2,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1390,
                                                                                                                                 "dst_idx": 1391,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 305,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 22},
                                                                                                         "contextRegion": {"startLine": 305,
                                                                                                                           "snippet": {"text": "    return ob->ob_tid == _Py_ThreadId();\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_IsOwnedByCurrentThread",
                                                                                                          "fullyQualifiedName": "_Py_IsOwnedByCurrentThread",
                                                                                                          "decoratedName": "_Py_IsOwnedByCurrentThread",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "Py_DECREF",
                                                                                                                                     "fullyQualifiedName": "Py_DECREF",
                                                                                                                                     "decoratedName": "Py_DECREF",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 2},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 305,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 22},
                                                                                                         "contextRegion": {"startLine": 305,
                                                                                                                           "snippet": {"text": "    return ob->ob_tid == _Py_ThreadId();\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_IsOwnedByCurrentThread",
                                                                                                          "fullyQualifiedName": "_Py_IsOwnedByCurrentThread",
                                                                                                          "decoratedName": "_Py_IsOwnedByCurrentThread",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "dereference of NULL 'op'"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 9}]}]}]}]}]}
