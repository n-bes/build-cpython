{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-write-to-const",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-write-to-const"}]}},
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.13.0b4/"}},
           "artifacts": [{"location": {"uri": "./Include/internal/pycore_frame.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_INTERNAL_FRAME_H\n#define Py_INTERNAL_FRAME_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_BUILD_CORE\n#  error \"this header requires Py_BUILD_CORE define\"\n#endif\n\n#include <stdbool.h>\n#include <stddef.h>               // offsetof()\n#include \"pycore_code.h\"          // STATS\n\n/* See Objects/frame_layout.md for an explanation of the frame stack\n * including explanation of the PyFrameObject and _PyInterpreterFrame\n * structs. */\n\n\nstruct _frame {\n    PyObject_HEAD\n    PyFrameObject *f_back;      /* previous frame, or NULL */\n    struct _PyInterpreterFrame *f_frame; /* points to the frame data */\n    PyObject *f_trace;          /* Trace function */\n    int f_lineno;               /* Current line number. Only valid if non-zero */\n    char f_trace_lines;         /* Emit per-line trace events? */\n    char f_trace_opcodes;       /* Emit per-opcode trace events? */\n    PyObject *f_extra_locals;   /* Dict for locals set by users using f_locals, could be NULL */\n    /* The frame data, if this frame object owns the frame */\n    PyObject *_f_frame_data[1];\n};\n\nextern PyFrameObject* _PyFrame_New_NoTrack(PyCodeObject *code);\n\n\n/* other API */\n\ntypedef enum _framestate {\n    FRAME_CREATED = -3,\n    FRAME_SUSPENDED = -2,\n    FRAME_SUSPENDED_YIELD_FROM = -1,\n    FRAME_EXECUTING = 0,\n    FRAME_COMPLETED = 1,\n    FRAME_CLEARED = 4\n} PyFrameState;\n\n#define FRAME_STATE_SUSPENDED(S) ((S) == FRAME_SUSPENDED || (S) == FRAME_SUSPENDED_YIELD_FROM)\n#define FRAME_STATE_FINISHED(S) ((S) >= FRAME_COMPLETED)\n\nenum _frameowner {\n    FRAME_OWNED_BY_THREAD = 0,\n    FRAME_OWNED_BY_GENERATOR = 1,\n    FRAME_OWNED_BY_FRAME_OBJECT = 2,\n    FRAME_OWNED_BY_CSTACK = 3,\n};\n\ntypedef struct _PyInterpreterFrame {\n    PyObject *f_executable; /* Strong reference (code object or None) */\n    struct _PyInterpreterFrame *previous;\n    PyObject *f_funcobj; /* Strong reference. Only valid if not on C stack */\n    PyObject *f_globals; /* Borrowed reference. Only valid if not on C stack */\n    PyObject *f_builtins; /* Borrowed reference. Only valid if not on C stack */\n    PyObject *f_locals; /* Strong reference, may be NULL. Only valid if not on C stack */\n    PyFrameObject *frame_obj; /* Strong reference, may be NULL. Only valid if not on C stack */\n    _Py_CODEUNIT *instr_ptr; /* Instruction currently executing (or about to begin) */\n    int stacktop;  /* Offset of TOS from localsplus  */\n    uint16_t return_offset;  /* Only relevant during a function call */\n    char owner;\n    /* Locals and stack */\n    PyObject *localsplus[1];\n} _PyInterpreterFrame;\n\n#define _PyInterpreterFrame_LASTI(IF) \\\n    ((int)((IF)->instr_ptr - _PyCode_CODE(_PyFrame_GetCode(IF))))\n\nstatic inline PyCodeObject *_PyFrame_GetCode(_PyInterpreterFrame *f) {\n    assert(PyCode_Check(f->f_executable));\n    return (PyCodeObject *)f->f_executable;\n}\n\nstatic inline PyObject **_PyFrame_Stackbase(_PyInterpreterFrame *f) {\n    return f->localsplus + _PyFrame_GetCode(f)->co_nlocalsplus;\n}\n\nstatic inline PyObject *_PyFrame_StackPeek(_PyInterpreterFrame *f) {\n    assert(f->stacktop > _PyFrame_GetCode(f)->co_nlocalsplus);\n    assert(f->localsplus[f->stacktop-1] != NULL);\n    return f->localsplus[f->stacktop-1];\n}\n\nstatic inline PyObject *_PyFrame_StackPop(_PyInterpreterFrame *f) {\n    assert(f->stacktop > _PyFrame_GetCode(f)->co_nlocalsplus);\n    f->stacktop--;\n    return f->localsplus[f->stacktop];\n}\n\nstatic inline void _PyFrame_StackPush(_PyInterpreterFrame *f, PyObject *value) {\n    f->localsplus[f->stacktop] = value;\n    f->stacktop++;\n}\n\n#define FRAME_SPECIALS_SIZE ((int)((sizeof(_PyInterpreterFrame)-1)/sizeof(PyObject *)))\n\nstatic inline int\n_PyFrame_NumSlotsForCodeObject(PyCodeObject *code)\n{\n    /* This function needs to remain in sync with the calculation of\n     * co_framesize in Tools/build/deepfreeze.py */\n    assert(code->co_framesize >= FRAME_SPECIALS_SIZE);\n    return code->co_framesize - FRAME_SPECIALS_SIZE;\n}\n\nstatic inline void _PyFrame_Copy(_PyInterpreterFrame *src, _PyInterpreterFrame *dest)\n{\n    assert(src->stacktop >= _PyFrame_GetCode(src)->co_nlocalsplus);\n    *dest = *src;\n    for (int i = 1; i < src->stacktop; i++) {\n        dest->localsplus[i] = src->localsplus[i];\n    }\n    // Don't leave a dangling pointer to the old frame when creating generators\n    // and coroutines:\n    dest->previous = NULL;\n}\n\n/* Consumes reference to func and locals.\n   Does not initialize frame->previous, which happens\n   when frame is linked into the frame stack.\n */\nstatic inline void\n_PyFrame_Initialize(\n    _PyInterpreterFrame *frame, PyFunctionObject *func,\n    PyObject *locals, PyCodeObject *code, int null_locals_from)\n{\n    frame->f_funcobj = (PyObject *)func;\n    frame->f_executable = Py_NewRef(code);\n    frame->f_builtins = func->func_builtins;\n    frame->f_globals = func->func_globals;\n    frame->f_locals = locals;\n    frame->stacktop = code->co_nlocalsplus;\n    frame->frame_obj = NULL;\n    frame->instr_ptr = _PyCode_CODE(code);\n    frame->return_offset = 0;\n    frame->owner = FRAME_OWNED_BY_THREAD;\n\n    for (int i = null_locals_from; i < code->co_nlocalsplus; i++) {\n        frame->localsplus[i] = NULL;\n    }\n}\n\n/* Gets the pointer to the locals array\n * that precedes this frame.\n */\nstatic inline PyObject**\n_PyFrame_GetLocalsArray(_PyInterpreterFrame *frame)\n{\n    return frame->localsplus;\n}\n\n/* Fetches the stack pointer, and sets stacktop to -1.\n   Having stacktop <= 0 ensures that invalid\n   values are not visible to the cycle GC.\n   We choose -1 rather than 0 to assist debugging. */\nstatic inline PyObject**\n_PyFrame_GetStackPointer(_PyInterpreterFrame *frame)\n{\n    PyObject **sp = frame->localsplus + frame->stacktop;\n    frame->stacktop = -1;\n    return sp;\n}\n\nstatic inline void\n_PyFrame_SetStackPointer(_PyInterpreterFrame *frame, PyObject **stack_pointer)\n{\n    frame->stacktop = (int)(stack_pointer - frame->localsplus);\n}\n\n/* Determine whether a frame is incomplete.\n * A frame is incomplete if it is part way through\n * creating cell objects or a generator or coroutine.\n *\n * Frames on the frame stack are incomplete until the\n * first RESUME instruction.\n * Frames owned by a generator are always complete.\n */\nstatic inline bool\n_PyFrame_IsIncomplete(_PyInterpreterFrame *frame)\n{\n    if (frame->owner == FRAME_OWNED_BY_CSTACK) {\n        return true;\n    }\n    return frame->owner != FRAME_OWNED_BY_GENERATOR &&\n        frame->instr_ptr < _PyCode_CODE(_PyFrame_GetCode(frame)) + _PyFrame_GetCode(frame)->_co_firsttraceable;\n}\n\nstatic inline _PyInterpreterFrame *\n_PyFrame_GetFirstComplete(_PyInterpreterFrame *frame)\n{\n    while (frame && _PyFrame_IsIncomplete(frame)) {\n        frame = frame->previous;\n    }\n    return frame;\n}\n\nstatic inline _PyInterpreterFrame *\n_PyThreadState_GetFrame(PyThreadState *tstate)\n{\n    return _PyFrame_GetFirstComplete(tstate->current_frame);\n}\n\n/* For use by _PyFrame_GetFrameObject\n  Do not call directly. */\nPyFrameObject *\n_PyFrame_MakeAndSetFrameObject(_PyInterpreterFrame *frame);\n\n/* Gets the PyFrameObject for this frame, lazily\n * creating it if necessary.\n * Returns a borrowed reference */\nstatic inline PyFrameObject *\n_PyFrame_GetFrameObject(_PyInterpreterFrame *frame)\n{\n\n    assert(!_PyFrame_IsIncomplete(frame));\n    PyFrameObject *res =  frame->frame_obj;\n    if (res != NULL) {\n        return res;\n    }\n    return _PyFrame_MakeAndSetFrameObject(frame);\n}\n\nvoid\n_PyFrame_ClearLocals(_PyInterpreterFrame *frame);\n\n/* Clears all references in the frame.\n * If take is non-zero, then the _PyInterpreterFrame frame\n * may be transferred to the frame object it references\n * instead of being cleared. Either way\n * the caller no longer owns the references\n * in the frame.\n * take should  be set to 1 for heap allocated\n * frames like the ones in generators and coroutines.\n */\nvoid\n_PyFrame_ClearExceptCode(_PyInterpreterFrame * frame);\n\nint\n_PyFrame_Traverse(_PyInterpreterFrame *frame, visitproc visit, void *arg);\n\nbool\n_PyFrame_HasHiddenLocals(_PyInterpreterFrame *frame);\n\nPyObject *\n_PyFrame_GetLocals(_PyInterpreterFrame *frame);\n\nstatic inline bool\n_PyThreadState_HasStackSpace(PyThreadState *tstate, int size)\n{\n    assert(\n        (tstate->datastack_top == NULL && tstate->datastack_limit == NULL)\n        ||\n        (tstate->datastack_top != NULL && tstate->datastack_limit != NULL)\n    );\n    return tstate->datastack_top != NULL &&\n        size < tstate->datastack_limit - tstate->datastack_top;\n}\n\nextern _PyInterpreterFrame *\n_PyThreadState_PushFrame(PyThreadState *tstate, size_t size);\n\nPyAPI_FUNC(void) _PyThreadState_PopFrame(PyThreadState *tstate, _PyInterpreterFrame *frame);\n\n/* Pushes a frame without checking for space.\n * Must be guarded by _PyThreadState_HasStackSpace()\n * Consumes reference to func. */\nstatic inline _PyInterpreterFrame *\n_PyFrame_PushUnchecked(PyThreadState *tstate, PyFunctionObject *func, int null_locals_from)\n{\n    CALL_STAT_INC(frames_pushed);\n    PyCodeObject *code = (PyCodeObject *)func->func_code;\n    _PyInterpreterFrame *new_frame = (_PyInterpreterFrame *)tstate->datastack_top;\n    tstate->datastack_top += code->co_framesize;\n    assert(tstate->datastack_top < tstate->datastack_limit);\n    _PyFrame_Initialize(new_frame, func, NULL, code, null_locals_from);\n    return new_frame;\n}\n\n/* Pushes a trampoline frame without checking for space.\n * Must be guarded by _PyThreadState_HasStackSpace() */\nstatic inline _PyInterpreterFrame *\n_PyFrame_PushTrampolineUnchecked(PyThreadState *tstate, PyCodeObject *code, int stackdepth)\n{\n    CALL_STAT_INC(frames_pushed);\n    _PyInterpreterFrame *frame = (_PyInterpreterFrame *)tstate->datastack_top;\n    tstate->datastack_top += code->co_framesize;\n    assert(tstate->datastack_top < tstate->datastack_limit);\n    frame->f_funcobj = Py_None;\n    frame->f_executable = Py_NewRef(code);\n#ifdef Py_DEBUG\n    frame->f_builtins = NULL;\n    frame->f_globals = NULL;\n#endif\n    frame->f_locals = NULL;\n    frame->stacktop = code->co_nlocalsplus + stackdepth;\n    frame->frame_obj = NULL;\n    frame->instr_ptr = _PyCode_CODE(code);\n    frame->owner = FRAME_OWNED_BY_THREAD;\n    frame->return_offset = 0;\n    return frame;\n}\n\nstatic inline\nPyGenObject *_PyFrame_GetGenerator(_PyInterpreterFrame *frame)\n{\n    assert(frame->owner == FRAME_OWNED_BY_GENERATOR);\n    size_t offset_in_gen = offsetof(PyGenObject, gi_iframe);\n    return (PyGenObject *)(((char *)frame) - offset_in_gen);\n}\n\nPyAPI_FUNC(_PyInterpreterFrame *)\n_PyEvalFramePushAndInit(PyThreadState *tstate, PyFunctionObject *func,\n                        PyObject *locals, PyObject* const* args,\n                        size_t argcount, PyObject *kwnames);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_INTERNAL_FRAME_H */\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/internal/pycore_pystate.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_INTERNAL_PYSTATE_H\n#define Py_INTERNAL_PYSTATE_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_BUILD_CORE\n#  error \"this header requires Py_BUILD_CORE define\"\n#endif\n\n#include \"pycore_freelist.h\"      // _PyFreeListState\n#include \"pycore_runtime.h\"       // _PyRuntime\n#include \"pycore_tstate.h\"        // _PyThreadStateImpl\n\n\n// Values for PyThreadState.state. A thread must be in the \"attached\" state\n// before calling most Python APIs. If the GIL is enabled, then \"attached\"\n// implies that the thread holds the GIL and \"detached\" implies that the\n// thread does not hold the GIL (or is in the process of releasing it). In\n// `--disable-gil` builds, multiple threads may be \"attached\" to the same\n// interpreter at the same time. Only the \"bound\" thread may perform the\n// transitions between \"attached\" and \"detached\" on its own PyThreadState.\n//\n// The \"suspended\" state is used to implement stop-the-world pauses, such as\n// for cyclic garbage collection. It is only used in `--disable-gil` builds.\n// The \"suspended\" state is similar to the \"detached\" state in that in both\n// states the thread is not allowed to call most Python APIs. However, unlike\n// the \"detached\" state, a thread may not transition itself out from the\n// \"suspended\" state. Only the thread performing a stop-the-world pause may\n// transition a thread from the \"suspended\" state back to the \"detached\" state.\n//\n// State transition diagram:\n//\n//            (bound thread)        (stop-the-world thread)\n// [attached]       <->       [detached]       <->       [suspended]\n//   |                                                        ^\n//   +---------------------------->---------------------------+\n//                          (bound thread)\n//\n// The (bound thread) and (stop-the-world thread) labels indicate which thread\n// is allowed to perform the transition.\n#define _Py_THREAD_DETACHED     0\n#define _Py_THREAD_ATTACHED     1\n#define _Py_THREAD_SUSPENDED    2\n\n\n/* Check if the current thread is the main thread.\n   Use _Py_IsMainInterpreter() to check if it's the main interpreter. */\nstatic inline int\n_Py_IsMainThread(void)\n{\n    unsigned long thread = PyThread_get_thread_ident();\n    return (thread == _PyRuntime.main_thread);\n}\n\n\nstatic inline PyInterpreterState *\n_PyInterpreterState_Main(void)\n{\n    return _PyRuntime.interpreters.main;\n}\n\nstatic inline int\n_Py_IsMainInterpreter(PyInterpreterState *interp)\n{\n    return (interp == _PyInterpreterState_Main());\n}\n\nstatic inline int\n_Py_IsMainInterpreterFinalizing(PyInterpreterState *interp)\n{\n    /* bpo-39877: Access _PyRuntime directly rather than using\n       tstate->interp->runtime to support calls from Python daemon threads.\n       After Py_Finalize() has been called, tstate can be a dangling pointer:\n       point to PyThreadState freed memory. */\n    return (_PyRuntimeState_GetFinalizing(&_PyRuntime) != NULL &&\n            interp == &_PyRuntime._main_interpreter);\n}\n\n// Export for _interpreters module.\nPyAPI_FUNC(PyObject *) _PyInterpreterState_GetIDObject(PyInterpreterState *);\n\n// Export for _interpreters module.\nPyAPI_FUNC(int) _PyInterpreterState_SetRunningMain(PyInterpreterState *);\nPyAPI_FUNC(void) _PyInterpreterState_SetNotRunningMain(PyInterpreterState *);\nPyAPI_FUNC(int) _PyInterpreterState_IsRunningMain(PyInterpreterState *);\nPyAPI_FUNC(int) _PyInterpreterState_FailIfRunningMain(PyInterpreterState *);\n\nextern int _PyThreadState_IsRunningMain(PyThreadState *);\nextern void _PyInterpreterState_ReinitRunningMain(PyThreadState *);\n\n\nstatic inline const PyConfig *\n_Py_GetMainConfig(void)\n{\n    PyInterpreterState *interp = _PyInterpreterState_Main();\n    if (interp == NULL) {\n        return NULL;\n    }\n    return _PyInterpreterState_GetConfig(interp);\n}\n\n\n/* Only handle signals on the main thread of the main interpreter. */\nstatic inline int\n_Py_ThreadCanHandleSignals(PyInterpreterState *interp)\n{\n    return (_Py_IsMainThread() && _Py_IsMainInterpreter(interp));\n}\n\n\n/* Variable and static inline functions for in-line access to current thread\n   and interpreter state */\n\n#if defined(HAVE_THREAD_LOCAL) && !defined(Py_BUILD_CORE_MODULE)\nextern _Py_thread_local PyThreadState *_Py_tss_tstate;\n#endif\n\n#ifndef NDEBUG\nextern int _PyThreadState_CheckConsistency(PyThreadState *tstate);\n#endif\n\nint _PyThreadState_MustExit(PyThreadState *tstate);\n\n// Export for most shared extensions, used via _PyThreadState_GET() static\n// inline function.\nPyAPI_FUNC(PyThreadState *) _PyThreadState_GetCurrent(void);\n\n/* Get the current Python thread state.\n\n   This function is unsafe: it does not check for error and it can return NULL.\n\n   The caller must hold the GIL.\n\n   See also PyThreadState_Get() and PyThreadState_GetUnchecked(). */\nstatic inline PyThreadState*\n_PyThreadState_GET(void)\n{\n#if defined(HAVE_THREAD_LOCAL) && !defined(Py_BUILD_CORE_MODULE)\n    return _Py_tss_tstate;\n#else\n    return _PyThreadState_GetCurrent();\n#endif\n}\n\n// Attaches the current thread to the interpreter.\n//\n// This may block while acquiring the GIL (if the GIL is enabled) or while\n// waiting for a stop-the-world pause (if the GIL is disabled).\n//\n// High-level code should generally call PyEval_RestoreThread() instead, which\n// calls this function.\nextern void _PyThreadState_Attach(PyThreadState *tstate);\n\n// Detaches the current thread from the interpreter.\n//\n// High-level code should generally call PyEval_SaveThread() instead, which\n// calls this function.\nextern void _PyThreadState_Detach(PyThreadState *tstate);\n\n// Detaches the current thread to the \"suspended\" state if a stop-the-world\n// pause is in progress.\n//\n// If there is no stop-the-world pause in progress, then the thread switches\n// to the \"detached\" state.\nextern void _PyThreadState_Suspend(PyThreadState *tstate);\n\n// Perform a stop-the-world pause for all threads in the all interpreters.\n//\n// Threads in the \"attached\" state are paused and transitioned to the \"GC\"\n// state. Threads in the \"detached\" state switch to the \"GC\" state, preventing\n// them from reattaching until the stop-the-world pause is complete.\n//\n// NOTE: This is a no-op outside of Py_GIL_DISABLED builds.\nextern void _PyEval_StopTheWorldAll(_PyRuntimeState *runtime);\nextern void _PyEval_StartTheWorldAll(_PyRuntimeState *runtime);\n\n// Perform a stop-the-world pause for threads in the specified interpreter.\n//\n// NOTE: This is a no-op outside of Py_GIL_DISABLED builds.\nextern void _PyEval_StopTheWorld(PyInterpreterState *interp);\nextern void _PyEval_StartTheWorld(PyInterpreterState *interp);\n\n\nstatic inline void\n_Py_EnsureFuncTstateNotNULL(const char *func, PyThreadState *tstate)\n{\n    if (tstate == NULL) {\n        _Py_FatalErrorFunc(func,\n            \"the function must be called with the GIL held, \"\n            \"after Python initialization and before Python finalization, \"\n            \"but the GIL is released (the current Python thread state is NULL)\");\n    }\n}\n\n// Call Py_FatalError() if tstate is NULL\n#define _Py_EnsureTstateNotNULL(tstate) \\\n    _Py_EnsureFuncTstateNotNULL(__func__, (tstate))\n\n\n/* Get the current interpreter state.\n\n   The function is unsafe: it does not check for error and it can return NULL.\n\n   The caller must hold the GIL.\n\n   See also PyInterpreterState_Get()\n   and _PyGILState_GetInterpreterStateUnsafe(). */\nstatic inline PyInterpreterState* _PyInterpreterState_GET(void) {\n    PyThreadState *tstate = _PyThreadState_GET();\n#ifdef Py_DEBUG\n    _Py_EnsureTstateNotNULL(tstate);\n#endif\n    return tstate->interp;\n}\n\n\n// PyThreadState functions\n\n// Export for _testinternalcapi\nPyAPI_FUNC(PyThreadState *) _PyThreadState_New(\n    PyInterpreterState *interp,\n    int whence);\nextern void _PyThreadState_Bind(PyThreadState *tstate);\nPyAPI_FUNC(PyThreadState *) _PyThreadState_NewBound(\n    PyInterpreterState *interp,\n    int whence);\nextern PyThreadState * _PyThreadState_RemoveExcept(PyThreadState *tstate);\nextern void _PyThreadState_DeleteList(PyThreadState *list);\nextern void _PyThreadState_ClearMimallocHeaps(PyThreadState *tstate);\n\n// Export for '_testinternalcapi' shared extension\nPyAPI_FUNC(PyObject*) _PyThreadState_GetDict(PyThreadState *tstate);\n\n/* The implementation of sys._current_exceptions()  Returns a dict mapping\n   thread id to that thread's current exception.\n*/\nextern PyObject* _PyThread_CurrentExceptions(void);\n\n\n/* Other */\n\nextern PyThreadState * _PyThreadState_Swap(\n    _PyRuntimeState *runtime,\n    PyThreadState *newts);\n\nextern PyStatus _PyInterpreterState_Enable(_PyRuntimeState *runtime);\n\n#ifdef HAVE_FORK\nextern PyStatus _PyInterpreterState_DeleteExceptMain(_PyRuntimeState *runtime);\nextern void _PySignal_AfterFork(void);\n#endif\n\n// Export for the stable ABI\nPyAPI_FUNC(int) _PyState_AddModule(\n    PyThreadState *tstate,\n    PyObject* module,\n    PyModuleDef* def);\n\n\nextern int _PyOS_InterruptOccurred(PyThreadState *tstate);\n\n#define HEAD_LOCK(runtime) \\\n    PyMutex_LockFlags(&(runtime)->interpreters.mutex, _Py_LOCK_DONT_DETACH)\n#define HEAD_UNLOCK(runtime) \\\n    PyMutex_Unlock(&(runtime)->interpreters.mutex)\n\n// Get the configuration of the current interpreter.\n// The caller must hold the GIL.\n// Export for test_peg_generator.\nPyAPI_FUNC(const PyConfig*) _Py_GetConfig(void);\n\n// Get the single PyInterpreterState used by this process' GILState\n// implementation.\n//\n// This function doesn't check for error. Return NULL before _PyGILState_Init()\n// is called and after _PyGILState_Fini() is called.\n//\n// See also PyInterpreterState_Get() and _PyInterpreterState_GET().\nextern PyInterpreterState* _PyGILState_GetInterpreterStateUnsafe(void);\n\nstatic inline struct _Py_object_freelists* _Py_object_freelists_GET(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n#ifdef Py_DEBUG\n    _Py_EnsureTstateNotNULL(tstate);\n#endif\n\n#ifdef Py_GIL_DISABLED\n    return &((_PyThreadStateImpl*)tstate)->freelists;\n#else\n    return &tstate->interp->object_state.freelists;\n#endif\n}\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_INTERNAL_PYSTATE_H */\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/internal/pycore_ceval.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_INTERNAL_CEVAL_H\n#define Py_INTERNAL_CEVAL_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_BUILD_CORE\n#  error \"this header requires Py_BUILD_CORE define\"\n#endif\n\n#include \"dynamic_annotations.h\" // _Py_ANNOTATE_RWLOCK_CREATE\n\n#include \"pycore_interp.h\"        // PyInterpreterState.eval_frame\n#include \"pycore_pystate.h\"       // _PyThreadState_GET()\n\n/* Forward declarations */\nstruct pyruntimestate;\nstruct _ceval_runtime_state;\n\n// Export for '_lsprof' shared extension\nPyAPI_FUNC(int) _PyEval_SetProfile(PyThreadState *tstate, Py_tracefunc func, PyObject *arg);\n\nextern int _PyEval_SetTrace(PyThreadState *tstate, Py_tracefunc func, PyObject *arg);\n\nextern int _PyEval_SetOpcodeTrace(PyFrameObject *f, bool enable);\n\n// Helper to look up a builtin object\n// Export for 'array' shared extension\nPyAPI_FUNC(PyObject*) _PyEval_GetBuiltin(PyObject *);\n\nextern PyObject* _PyEval_GetBuiltinId(_Py_Identifier *);\n\nextern void _PyEval_SetSwitchInterval(unsigned long microseconds);\nextern unsigned long _PyEval_GetSwitchInterval(void);\n\n// Export for '_queue' shared extension\nPyAPI_FUNC(int) _PyEval_MakePendingCalls(PyThreadState *);\n\n#ifndef Py_DEFAULT_RECURSION_LIMIT\n#  define Py_DEFAULT_RECURSION_LIMIT 1000\n#endif\n\nextern void _Py_FinishPendingCalls(PyThreadState *tstate);\nextern void _PyEval_InitState(PyInterpreterState *);\nextern void _PyEval_SignalReceived(void);\n\n// bitwise flags:\n#define _Py_PENDING_MAINTHREADONLY 1\n#define _Py_PENDING_RAWFREE 2\n\ntypedef int _Py_add_pending_call_result;\n#define _Py_ADD_PENDING_SUCCESS 0\n#define _Py_ADD_PENDING_FULL -1\n\n// Export for '_testinternalcapi' shared extension\nPyAPI_FUNC(_Py_add_pending_call_result) _PyEval_AddPendingCall(\n    PyInterpreterState *interp,\n    _Py_pending_call_func func,\n    void *arg,\n    int flags);\n\n#ifdef HAVE_FORK\nextern PyStatus _PyEval_ReInitThreads(PyThreadState *tstate);\n#endif\n\n// Used by sys.call_tracing()\nextern PyObject* _PyEval_CallTracing(PyObject *func, PyObject *args);\n\n// Used by sys.get_asyncgen_hooks()\nextern PyObject* _PyEval_GetAsyncGenFirstiter(void);\nextern PyObject* _PyEval_GetAsyncGenFinalizer(void);\n\n// Used by sys.set_asyncgen_hooks()\nextern int _PyEval_SetAsyncGenFirstiter(PyObject *);\nextern int _PyEval_SetAsyncGenFinalizer(PyObject *);\n\n// Used by sys.get_coroutine_origin_tracking_depth()\n// and sys.set_coroutine_origin_tracking_depth()\nextern int _PyEval_GetCoroutineOriginTrackingDepth(void);\nextern int _PyEval_SetCoroutineOriginTrackingDepth(int depth);\n\nextern void _PyEval_Fini(void);\n\n\nextern PyObject* _PyEval_GetBuiltins(PyThreadState *tstate);\nextern PyObject* _PyEval_BuiltinsFromGlobals(\n    PyThreadState *tstate,\n    PyObject *globals);\n\n// Trampoline API\n\ntypedef struct {\n    // Callback to initialize the trampoline state\n    void* (*init_state)(void);\n    // Callback to register every trampoline being created\n    void (*write_state)(void* state, const void *code_addr,\n                        unsigned int code_size, PyCodeObject* code);\n    // Callback to free the trampoline state\n    int (*free_state)(void* state);\n} _PyPerf_Callbacks;\n\nextern int _PyPerfTrampoline_SetCallbacks(_PyPerf_Callbacks *);\nextern void _PyPerfTrampoline_GetCallbacks(_PyPerf_Callbacks *);\nextern int _PyPerfTrampoline_Init(int activate);\nextern int _PyPerfTrampoline_Fini(void);\nextern void _PyPerfTrampoline_FreeArenas(void);\nextern int _PyIsPerfTrampolineActive(void);\nextern PyStatus _PyPerfTrampoline_AfterFork_Child(void);\n#ifdef PY_HAVE_PERF_TRAMPOLINE\nextern _PyPerf_Callbacks _Py_perfmap_callbacks;\nextern _PyPerf_Callbacks _Py_perfmap_jit_callbacks;\n#endif\n\nstatic inline PyObject*\n_PyEval_EvalFrame(PyThreadState *tstate, struct _PyInterpreterFrame *frame, int throwflag)\n{\n    EVAL_CALL_STAT_INC(EVAL_CALL_TOTAL);\n    if (tstate->interp->eval_frame == NULL) {\n        return _PyEval_EvalFrameDefault(tstate, frame, throwflag);\n    }\n    return tstate->interp->eval_frame(tstate, frame, throwflag);\n}\n\nextern PyObject*\n_PyEval_Vector(PyThreadState *tstate,\n            PyFunctionObject *func, PyObject *locals,\n            PyObject* const* args, size_t argcount,\n            PyObject *kwnames);\n\nextern int _PyEval_ThreadsInitialized(void);\nextern void _PyEval_InitGIL(PyThreadState *tstate, int own_gil);\nextern void _PyEval_FiniGIL(PyInterpreterState *interp);\n\nextern void _PyEval_AcquireLock(PyThreadState *tstate);\n\nextern void _PyEval_ReleaseLock(PyInterpreterState *, PyThreadState *,\n                                int final_release);\n\n#ifdef Py_GIL_DISABLED\n// Returns 0 or 1 if the GIL for the given thread's interpreter is disabled or\n// enabled, respectively.\n//\n// The enabled state of the GIL will not change while one or more threads are\n// attached.\nstatic inline int\n_PyEval_IsGILEnabled(PyThreadState *tstate)\n{\n    struct _gil_runtime_state *gil = tstate->interp->ceval.gil;\n    return _Py_atomic_load_int_relaxed(&gil->enabled) != 0;\n}\n\n// Enable or disable the GIL used by the interpreter that owns tstate, which\n// must be the current thread. This may affect other interpreters, if the GIL\n// is shared. All three functions will be no-ops (and return 0) if the\n// interpreter's `enable_gil' config is not _PyConfig_GIL_DEFAULT.\n//\n// Every call to _PyEval_EnableGILTransient() must be paired with exactly one\n// call to either _PyEval_EnableGILPermanent() or\n// _PyEval_DisableGIL(). _PyEval_EnableGILPermanent() and _PyEval_DisableGIL()\n// must only be called while the GIL is enabled from a call to\n// _PyEval_EnableGILTransient().\n//\n// _PyEval_EnableGILTransient() returns 1 if it enabled the GIL, or 0 if the\n// GIL was already enabled, whether transiently or permanently. The caller will\n// hold the GIL upon return.\n//\n// _PyEval_EnableGILPermanent() returns 1 if it permanently enabled the GIL\n// (which must already be enabled), or 0 if it was already permanently\n// enabled. Once _PyEval_EnableGILPermanent() has been called once, all\n// subsequent calls to any of the three functions will be no-ops.\n//\n// _PyEval_DisableGIL() returns 1 if it disabled the GIL, or 0 if the GIL was\n// kept enabled because of another request, whether transient or permanent.\n//\n// All three functions must be called by an attached thread (this implies that\n// if the GIL is enabled, the current thread must hold it).\nextern int _PyEval_EnableGILTransient(PyThreadState *tstate);\nextern int _PyEval_EnableGILPermanent(PyThreadState *tstate);\nextern int _PyEval_DisableGIL(PyThreadState *state);\n#endif\n\nextern void _PyEval_DeactivateOpCache(void);\n\n\n/* --- _Py_EnterRecursiveCall() ----------------------------------------- */\n\n#ifdef USE_STACKCHECK\n/* With USE_STACKCHECK macro defined, trigger stack checks in\n   _Py_CheckRecursiveCall() on every 64th call to _Py_EnterRecursiveCall. */\nstatic inline int _Py_MakeRecCheck(PyThreadState *tstate)  {\n    return (tstate->c_recursion_remaining-- < 0\n            || (tstate->c_recursion_remaining & 63) == 0);\n}\n#else\nstatic inline int _Py_MakeRecCheck(PyThreadState *tstate) {\n    return tstate->c_recursion_remaining-- < 0;\n}\n#endif\n\n// Export for '_json' shared extension, used via _Py_EnterRecursiveCall()\n// static inline function.\nPyAPI_FUNC(int) _Py_CheckRecursiveCall(\n    PyThreadState *tstate,\n    const char *where);\n\nint _Py_CheckRecursiveCallPy(\n    PyThreadState *tstate);\n\nstatic inline int _Py_EnterRecursiveCallTstate(PyThreadState *tstate,\n                                               const char *where) {\n    return (_Py_MakeRecCheck(tstate) && _Py_CheckRecursiveCall(tstate, where));\n}\n\nstatic inline void _Py_EnterRecursiveCallTstateUnchecked(PyThreadState *tstate)  {\n    assert(tstate->c_recursion_remaining > 0);\n    tstate->c_recursion_remaining--;\n}\n\nstatic inline int _Py_EnterRecursiveCall(const char *where) {\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _Py_EnterRecursiveCallTstate(tstate, where);\n}\n\nstatic inline void _Py_LeaveRecursiveCallTstate(PyThreadState *tstate)  {\n    tstate->c_recursion_remaining++;\n}\n\nstatic inline void _Py_LeaveRecursiveCall(void)  {\n    PyThreadState *tstate = _PyThreadState_GET();\n    _Py_LeaveRecursiveCallTstate(tstate);\n}\n\nextern struct _PyInterpreterFrame* _PyEval_GetFrame(void);\n\nPyAPI_FUNC(PyObject *)_Py_MakeCoro(PyFunctionObject *func);\n\n/* Handle signals, pending calls, GIL drop request\n   and asynchronous exception */\nPyAPI_FUNC(int) _Py_HandlePending(PyThreadState *tstate);\n\nextern PyObject * _PyEval_GetFrameLocals(void);\n\ntypedef PyObject *(*conversion_func)(PyObject *);\n\nPyAPI_DATA(const binaryfunc) _PyEval_BinaryOps[];\nPyAPI_DATA(const conversion_func) _PyEval_ConversionFuncs[];\n\nPyAPI_FUNC(int) _PyEval_CheckExceptStarTypeValid(PyThreadState *tstate, PyObject* right);\nPyAPI_FUNC(int) _PyEval_CheckExceptTypeValid(PyThreadState *tstate, PyObject* right);\nPyAPI_FUNC(int) _PyEval_ExceptionGroupMatch(PyObject* exc_value, PyObject *match_type, PyObject **match, PyObject **rest);\nPyAPI_FUNC(void) _PyEval_FormatAwaitableError(PyThreadState *tstate, PyTypeObject *type, int oparg);\nPyAPI_FUNC(void) _PyEval_FormatExcCheckArg(PyThreadState *tstate, PyObject *exc, const char *format_str, PyObject *obj);\nPyAPI_FUNC(void) _PyEval_FormatExcUnbound(PyThreadState *tstate, PyCodeObject *co, int oparg);\nPyAPI_FUNC(void) _PyEval_FormatKwargsError(PyThreadState *tstate, PyObject *func, PyObject *kwargs);\nPyAPI_FUNC(PyObject *)_PyEval_MatchClass(PyThreadState *tstate, PyObject *subject, PyObject *type, Py_ssize_t nargs, PyObject *kwargs);\nPyAPI_FUNC(PyObject *)_PyEval_MatchKeys(PyThreadState *tstate, PyObject *map, PyObject *keys);\nPyAPI_FUNC(int) _PyEval_UnpackIterable(PyThreadState *tstate, PyObject *v, int argcnt, int argcntafter, PyObject **sp);\nPyAPI_FUNC(void) _PyEval_FrameClearAndPop(PyThreadState *tstate, _PyInterpreterFrame *frame);\n\n\n/* Bits that can be set in PyThreadState.eval_breaker */\n#define _PY_GIL_DROP_REQUEST_BIT (1U << 0)\n#define _PY_SIGNALS_PENDING_BIT (1U << 1)\n#define _PY_CALLS_TO_DO_BIT (1U << 2)\n#define _PY_ASYNC_EXCEPTION_BIT (1U << 3)\n#define _PY_GC_SCHEDULED_BIT (1U << 4)\n#define _PY_EVAL_PLEASE_STOP_BIT (1U << 5)\n#define _PY_EVAL_EXPLICIT_MERGE_BIT (1U << 6)\n\n/* Reserve a few bits for future use */\n#define _PY_EVAL_EVENTS_BITS 8\n#define _PY_EVAL_EVENTS_MASK ((1 << _PY_EVAL_EVENTS_BITS)-1)\n\nstatic inline void\n_Py_set_eval_breaker_bit(PyThreadState *tstate, uintptr_t bit)\n{\n    _Py_atomic_or_uintptr(&tstate->eval_breaker, bit);\n}\n\nstatic inline void\n_Py_unset_eval_breaker_bit(PyThreadState *tstate, uintptr_t bit)\n{\n    _Py_atomic_and_uintptr(&tstate->eval_breaker, ~bit);\n}\n\nstatic inline int\n_Py_eval_breaker_bit_is_set(PyThreadState *tstate, uintptr_t bit)\n{\n    uintptr_t b = _Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker);\n    return (b & bit) != 0;\n}\n\n// Free-threaded builds use these functions to set or unset a bit on all\n// threads in the given interpreter.\nvoid _Py_set_eval_breaker_bit_all(PyInterpreterState *interp, uintptr_t bit);\nvoid _Py_unset_eval_breaker_bit_all(PyInterpreterState *interp, uintptr_t bit);\n\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_INTERNAL_CEVAL_H */\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/object.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_OBJECT_H\n#define Py_OBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Object and type object interface */\n\n/*\nObjects are structures allocated on the heap.  Special rules apply to\nthe use of objects to ensure they are properly garbage-collected.\nObjects are never allocated statically or on the stack; they must be\naccessed through special macros and functions only.  (Type objects are\nexceptions to the first rule; the standard types are represented by\nstatically initialized type objects, although work on type/class unification\nfor Python 2.2 made it possible to have heap-allocated type objects too).\n\nAn object has a 'reference count' that is increased or decreased when a\npointer to the object is copied or deleted; when the reference count\nreaches zero there are no references to the object left and it can be\nremoved from the heap.\n\nAn object has a 'type' that determines what it represents and what kind\nof data it contains.  An object's type is fixed when it is created.\nTypes themselves are represented as objects; an object contains a\npointer to the corresponding type object.  The type itself has a type\npointer pointing to the object representing the type 'type', which\ncontains a pointer to itself!.\n\nObjects do not float around in memory; once allocated an object keeps\nthe same size and address.  Objects that must hold variable-size data\ncan contain pointers to variable-size parts of the object.  Not all\nobjects of the same type have the same size; but the size cannot change\nafter allocation.  (These restrictions are made so a reference to an\nobject can be simply a pointer -- moving an object would require\nupdating all the pointers, and changing an object's size would require\nmoving it if there was another object right next to it.)\n\nObjects are always accessed through pointers of the type 'PyObject *'.\nThe type 'PyObject' is a structure that only contains the reference count\nand the type pointer.  The actual memory allocated for an object\ncontains other data that can only be accessed after casting the pointer\nto a pointer to a longer structure type.  This longer type must start\nwith the reference count and type fields; the macro PyObject_HEAD should be\nused for this (to accommodate for future changes).  The implementation\nof a particular object type can cast the object pointer to the proper\ntype and back.\n\nA standard interface exists for objects that contain an array of items\nwhose size is determined when the object is allocated.\n*/\n\n/* Py_DEBUG implies Py_REF_DEBUG. */\n#if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)\n#  define Py_REF_DEBUG\n#endif\n\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   PyObject ob_base;\n\n/*\nImmortalization:\n\nThe following indicates the immortalization strategy depending on the amount\nof available bits in the reference count field. All strategies are backwards\ncompatible but the specific reference count value or immortalization check\nmight change depending on the specializations for the underlying system.\n\nProper deallocation of immortal instances requires distinguishing between\nstatically allocated immortal instances vs those promoted by the runtime to be\nimmortal. The latter should be the only instances that require\ncleanup during runtime finalization.\n*/\n\n#if SIZEOF_VOID_P > 4\n/*\nIn 64+ bit systems, an object will be marked as immortal by setting all of the\nlower 32 bits of the reference count field, which is equal to: 0xFFFFFFFF\n\nUsing the lower 32 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases will use saturated arithmetic, taking advantage of\nhaving all the lower 32 bits set, which will avoid the reference count to go\nbeyond the refcount limit. Immortality checks for reference count decreases will\nbe done by checking the bit sign flag in the lower 32 bits.\n*/\n#define _Py_IMMORTAL_REFCNT _Py_CAST(Py_ssize_t, UINT_MAX)\n\n#else\n/*\nIn 32 bit systems, an object will be marked as immortal by setting all of the\nlower 30 bits of the reference count field, which is equal to: 0x3FFFFFFF\n\nUsing the lower 30 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases and decreases will first go through an immortality\ncheck by comparing the reference count field to the immortality reference count.\n*/\n#define _Py_IMMORTAL_REFCNT _Py_CAST(Py_ssize_t, UINT_MAX >> 2)\n#endif\n\n// Py_GIL_DISABLED builds indicate immortal objects using `ob_ref_local`, which is\n// always 32-bits.\n#ifdef Py_GIL_DISABLED\n#define _Py_IMMORTAL_REFCNT_LOCAL UINT32_MAX\n#endif\n\n// Kept for backward compatibility. It was needed by Py_TRACE_REFS build.\n#define _PyObject_EXTRA_INIT\n\n/* Make all uses of PyObject_HEAD_INIT immortal.\n *\n * Statically allocated objects might be shared between\n * interpreters, so must be marked as immortal.\n */\n#if defined(Py_GIL_DISABLED)\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        0,                          \\\n        0,                          \\\n        { 0 },                      \\\n        0,                          \\\n        _Py_IMMORTAL_REFCNT_LOCAL,  \\\n        0,                          \\\n        (type),                     \\\n    },\n#else\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        { _Py_IMMORTAL_REFCNT },    \\\n        (type)                      \\\n    },\n#endif\n\n#define PyVarObject_HEAD_INIT(type, size) \\\n    {                                     \\\n        PyObject_HEAD_INIT(type)          \\\n        (size)                            \\\n    },\n\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD      PyVarObject ob_base;\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\n#ifndef Py_GIL_DISABLED\nstruct _object {\n#if (defined(__GNUC__) || defined(__clang__)) \\\n        && !(defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L)\n    // On C99 and older, anonymous union is a GCC and clang extension\n    __extension__\n#endif\n#ifdef _MSC_VER\n    // Ignore MSC warning C4201: \"nonstandard extension used:\n    // nameless struct/union\"\n    __pragma(warning(push))\n    __pragma(warning(disable: 4201))\n#endif\n    union {\n       Py_ssize_t ob_refcnt;\n#if SIZEOF_VOID_P > 4\n       PY_UINT32_T ob_refcnt_split[2];\n#endif\n    };\n#ifdef _MSC_VER\n    __pragma(warning(pop))\n#endif\n\n    PyTypeObject *ob_type;\n};\n#else\n// Objects that are not owned by any thread use a thread id (tid) of zero.\n// This includes both immortal objects and objects whose reference count\n// fields have been merged.\n#define _Py_UNOWNED_TID             0\n\n// The shared reference count uses the two least-significant bits to store\n// flags. The remaining bits are used to store the reference count.\n#define _Py_REF_SHARED_SHIFT        2\n#define _Py_REF_SHARED_FLAG_MASK    0x3\n\n// The shared flags are initialized to zero.\n#define _Py_REF_SHARED_INIT         0x0\n#define _Py_REF_MAYBE_WEAKREF       0x1\n#define _Py_REF_QUEUED              0x2\n#define _Py_REF_MERGED              0x3\n\n// Create a shared field from a refcnt and desired flags\n#define _Py_REF_SHARED(refcnt, flags) (((refcnt) << _Py_REF_SHARED_SHIFT) + (flags))\n\nstruct _object {\n    // ob_tid stores the thread id (or zero). It is also used by the GC and the\n    // trashcan mechanism as a linked list pointer and by the GC to store the\n    // computed \"gc_refs\" refcount.\n    uintptr_t ob_tid;\n    uint16_t _padding;\n    PyMutex ob_mutex;           // per-object lock\n    uint8_t ob_gc_bits;         // gc-related state\n    uint32_t ob_ref_local;      // local reference count\n    Py_ssize_t ob_ref_shared;   // shared (atomic) reference count\n    PyTypeObject *ob_type;\n};\n#endif\n\n/* Cast argument to PyObject* type. */\n#define _PyObject_CAST(op) _Py_CAST(PyObject*, (op))\n\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n/* Cast argument to PyVarObject* type. */\n#define _PyVarObject_CAST(op) _Py_CAST(PyVarObject*, (op))\n\n\n// Test if the 'x' object is the 'y' object, the same as \"x is y\" in Python.\nPyAPI_FUNC(int) Py_Is(PyObject *x, PyObject *y);\n#define Py_Is(x, y) ((x) == (y))\n\n#if defined(Py_GIL_DISABLED) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(uintptr_t) _Py_GetThreadLocal_Addr(void);\n\nstatic inline uintptr_t\n_Py_ThreadId(void)\n{\n    uintptr_t tid;\n#if defined(_MSC_VER) && defined(_M_X64)\n    tid = __readgsqword(48);\n#elif defined(_MSC_VER) && defined(_M_IX86)\n    tid = __readfsdword(24);\n#elif defined(_MSC_VER) && defined(_M_ARM64)\n    tid = __getReg(18);\n#elif defined(__i386__)\n    __asm__(\"movl %%gs:0, %0\" : \"=r\" (tid));  // 32-bit always uses GS\n#elif defined(__MACH__) && defined(__x86_64__)\n    __asm__(\"movq %%gs:0, %0\" : \"=r\" (tid));  // x86_64 macOSX uses GS\n#elif defined(__x86_64__)\n   __asm__(\"movq %%fs:0, %0\" : \"=r\" (tid));  // x86_64 Linux, BSD uses FS\n#elif defined(__arm__)\n    __asm__ (\"mrc p15, 0, %0, c13, c0, 3\\nbic %0, %0, #3\" : \"=r\" (tid));\n#elif defined(__aarch64__) && defined(__APPLE__)\n    __asm__ (\"mrs %0, tpidrro_el0\" : \"=r\" (tid));\n#elif defined(__aarch64__)\n    __asm__ (\"mrs %0, tpidr_el0\" : \"=r\" (tid));\n#elif defined(__powerpc64__)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // r13 is reserved for use as system thread ID by the Power 64-bit ABI.\n    register uintptr_t tp __asm__ (\"r13\");\n    __asm__(\"\" : \"=r\" (tp));\n    tid = tp;\n    #endif\n#elif defined(__powerpc__)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // r2 is reserved for use as system thread ID by the Power 32-bit ABI.\n    register uintptr_t tp __asm__ (\"r2\");\n    __asm__ (\"\" : \"=r\" (tp));\n    tid = tp;\n    #endif\n#elif defined(__s390__) && defined(__GNUC__)\n    // Both GCC and Clang have supported __builtin_thread_pointer\n    // for s390 from long time ago.\n    tid = (uintptr_t)__builtin_thread_pointer();\n#elif defined(__riscv)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // tp is Thread Pointer provided by the RISC-V ABI.\n    __asm__ (\"mv %0, tp\" : \"=r\" (tid));\n    #endif\n#else\n    // Fallback to a portable implementation if we do not have a faster\n    // platform-specific implementation.\n    tid = _Py_GetThreadLocal_Addr();\n#endif\n  return tid;\n}\n\nstatic inline Py_ALWAYS_INLINE int\n_Py_IsOwnedByCurrentThread(PyObject *ob)\n{\n#ifdef _Py_THREAD_SANITIZER\n    return _Py_atomic_load_uintptr_relaxed(&ob->ob_tid) == _Py_ThreadId();\n#else\n    return ob->ob_tid == _Py_ThreadId();\n#endif\n}\n#endif\n\nstatic inline Py_ssize_t Py_REFCNT(PyObject *ob) {\n#if !defined(Py_GIL_DISABLED)\n    return ob->ob_refcnt;\n#else\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&ob->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return _Py_IMMORTAL_REFCNT;\n    }\n    Py_ssize_t shared = _Py_atomic_load_ssize_relaxed(&ob->ob_ref_shared);\n    return _Py_STATIC_CAST(Py_ssize_t, local) +\n           Py_ARITHMETIC_RIGHT_SHIFT(Py_ssize_t, shared, _Py_REF_SHARED_SHIFT);\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_REFCNT(ob) Py_REFCNT(_PyObject_CAST(ob))\n#endif\n\n\n// bpo-39573: The Py_SET_TYPE() function must be used to set an object type.\nstatic inline PyTypeObject* Py_TYPE(PyObject *ob) {\n    return ob->ob_type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_TYPE(ob) Py_TYPE(_PyObject_CAST(ob))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyLong_Type;\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n\n// bpo-39573: The Py_SET_SIZE() function must be used to set an object size.\nstatic inline Py_ssize_t Py_SIZE(PyObject *ob) {\n    assert(ob->ob_type != &PyLong_Type);\n    assert(ob->ob_type != &PyBool_Type);\n    return  _PyVarObject_CAST(ob)->ob_size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SIZE(ob) Py_SIZE(_PyObject_CAST(ob))\n#endif\n\nstatic inline Py_ALWAYS_INLINE int _Py_IsImmortal(PyObject *op)\n{\n#if defined(Py_GIL_DISABLED)\n    return (_Py_atomic_load_uint32_relaxed(&op->ob_ref_local) ==\n            _Py_IMMORTAL_REFCNT_LOCAL);\n#elif SIZEOF_VOID_P > 4\n    return (_Py_CAST(PY_INT32_T, op->ob_refcnt) < 0);\n#else\n    return (op->ob_refcnt == _Py_IMMORTAL_REFCNT);\n#endif\n}\n#define _Py_IsImmortal(op) _Py_IsImmortal(_PyObject_CAST(op))\n\nstatic inline int Py_IS_TYPE(PyObject *ob, PyTypeObject *type) {\n    return Py_TYPE(ob) == type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_IS_TYPE(ob, type) Py_IS_TYPE(_PyObject_CAST(ob), (type))\n#endif\n\n\n// Py_SET_REFCNT() implementation for stable ABI\nPyAPI_FUNC(void) _Py_SetRefcnt(PyObject *ob, Py_ssize_t refcnt);\n\nstatic inline void Py_SET_REFCNT(PyObject *ob, Py_ssize_t refcnt) {\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030d0000\n    // Stable ABI implements Py_SET_REFCNT() as a function call\n    // on limited C API version 3.13 and newer.\n    _Py_SetRefcnt(ob, refcnt);\n#else\n    // This immortal check is for code that is unaware of immortal objects.\n    // The runtime tracks these objects and we should avoid as much\n    // as possible having extensions inadvertently change the refcnt\n    // of an immortalized object.\n    if (_Py_IsImmortal(ob)) {\n        return;\n    }\n\n#ifndef Py_GIL_DISABLED\n    ob->ob_refcnt = refcnt;\n#else\n    if (_Py_IsOwnedByCurrentThread(ob)) {\n        if ((size_t)refcnt > (size_t)UINT32_MAX) {\n            // On overflow, make the object immortal\n            ob->ob_tid = _Py_UNOWNED_TID;\n            ob->ob_ref_local = _Py_IMMORTAL_REFCNT_LOCAL;\n            ob->ob_ref_shared = 0;\n        }\n        else {\n            // Set local refcount to desired refcount and shared refcount\n            // to zero, but preserve the shared refcount flags.\n            ob->ob_ref_local = _Py_STATIC_CAST(uint32_t, refcnt);\n            ob->ob_ref_shared &= _Py_REF_SHARED_FLAG_MASK;\n        }\n    }\n    else {\n        // Set local refcount to zero and shared refcount to desired refcount.\n        // Mark the object as merged.\n        ob->ob_tid = _Py_UNOWNED_TID;\n        ob->ob_ref_local = 0;\n        ob->ob_ref_shared = _Py_REF_SHARED(refcnt, _Py_REF_MERGED);\n    }\n#endif  // Py_GIL_DISABLED\n#endif  // Py_LIMITED_API+0 < 0x030d0000\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_REFCNT(ob, refcnt) Py_SET_REFCNT(_PyObject_CAST(ob), (refcnt))\n#endif\n\n\nstatic inline void Py_SET_TYPE(PyObject *ob, PyTypeObject *type) {\n    ob->ob_type = type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_TYPE(ob, type) Py_SET_TYPE(_PyObject_CAST(ob), type)\n#endif\n\nstatic inline void Py_SET_SIZE(PyVarObject *ob, Py_ssize_t size) {\n    assert(ob->ob_base.ob_type != &PyLong_Type);\n    assert(ob->ob_base.ob_type != &PyBool_Type);\n#ifdef Py_GIL_DISABLED\n    _Py_atomic_store_ssize_relaxed(&ob->ob_size, size);\n#else\n    ob->ob_size = size;\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_SIZE(ob, size) Py_SET_SIZE(_PyVarObject_CAST(ob), (size))\n#endif\n\n\n/*\nType objects contain a string containing the type name (to help somewhat\nin debugging), the allocation parameters (see PyObject_New() and\nPyObject_NewVar()),\nand methods for accessing objects of the type.  Methods are optional, a\nnil pointer meaning that particular kind of access is not available for\nthis type.  The Py_DECREF() macro uses the tp_dealloc method without\nchecking for a nil pointer; it should always be implemented except if\nthe implementation can guarantee that the reference count will never\nreach zero (e.g., for statically allocated type objects).\n\nNB: the methods for certain type groups are now contained in separate\nmethod blocks.\n*/\n\ntypedef PyObject * (*unaryfunc)(PyObject *);\ntypedef PyObject * (*binaryfunc)(PyObject *, PyObject *);\ntypedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);\ntypedef int (*inquiry)(PyObject *);\ntypedef Py_ssize_t (*lenfunc)(PyObject *);\ntypedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);\ntypedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);\ntypedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);\ntypedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);\ntypedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);\n\ntypedef int (*objobjproc)(PyObject *, PyObject *);\ntypedef int (*visitproc)(PyObject *, void *);\ntypedef int (*traverseproc)(PyObject *, visitproc, void *);\n\n\ntypedef void (*freefunc)(void *);\ntypedef void (*destructor)(PyObject *);\ntypedef PyObject *(*getattrfunc)(PyObject *, char *);\ntypedef PyObject *(*getattrofunc)(PyObject *, PyObject *);\ntypedef int (*setattrfunc)(PyObject *, char *, PyObject *);\ntypedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*reprfunc)(PyObject *);\ntypedef Py_hash_t (*hashfunc)(PyObject *);\ntypedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);\ntypedef PyObject *(*getiterfunc) (PyObject *);\ntypedef PyObject *(*iternextfunc) (PyObject *);\ntypedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*initproc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*newfunc)(PyTypeObject *, PyObject *, PyObject *);\ntypedef PyObject *(*allocfunc)(PyTypeObject *, Py_ssize_t);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030c0000 // 3.12\ntypedef PyObject *(*vectorcallfunc)(PyObject *callable, PyObject *const *args,\n                                    size_t nargsf, PyObject *kwnames);\n#endif\n\ntypedef struct{\n    int slot;    /* slot id, see below */\n    void *pfunc; /* function pointer */\n} PyType_Slot;\n\ntypedef struct{\n    const char* name;\n    int basicsize;\n    int itemsize;\n    unsigned int flags;\n    PyType_Slot *slots; /* terminated by slot==0. */\n} PyType_Spec;\n\nPyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000\nPyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);\nPyAPI_FUNC(PyObject *) PyType_GetModule(PyTypeObject *);\nPyAPI_FUNC(void *) PyType_GetModuleState(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000\nPyAPI_FUNC(PyObject *) PyType_GetName(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GetQualName(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030D0000\nPyAPI_FUNC(PyObject *) PyType_GetFullyQualifiedName(PyTypeObject *type);\nPyAPI_FUNC(PyObject *) PyType_GetModuleName(PyTypeObject *type);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\nPyAPI_FUNC(PyObject *) PyType_FromMetaclass(PyTypeObject*, PyObject*, PyType_Spec*, PyObject*);\nPyAPI_FUNC(void *) PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls);\nPyAPI_FUNC(Py_ssize_t) PyType_GetTypeDataSize(PyTypeObject *cls);\n#endif\n\n/* Generic type check */\nPyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);\n\nstatic inline int PyObject_TypeCheck(PyObject *ob, PyTypeObject *type) {\n    return Py_IS_TYPE(ob, type) || PyType_IsSubtype(Py_TYPE(ob), type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyObject_TypeCheck(ob, type) PyObject_TypeCheck(_PyObject_CAST(ob), (type))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */\nPyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */\nPyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */\n\nPyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);\n\nPyAPI_FUNC(int) PyType_Ready(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,\n                                               PyObject *, PyObject *);\nPyAPI_FUNC(unsigned int) PyType_ClearCache(void);\nPyAPI_FUNC(void) PyType_Modified(PyTypeObject *);\n\n/* Generic operations on objects */\nPyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);\nPyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);\nPyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);\nPyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);\nPyAPI_FUNC(int) PyObject_DelAttrString(PyObject *v, const char *name);\nPyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(int) PyObject_GetOptionalAttr(PyObject *, PyObject *, PyObject **);\nPyAPI_FUNC(int) PyObject_GetOptionalAttrString(PyObject *, const char *, PyObject **);\n#endif\nPyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_DelAttr(PyObject *v, PyObject *name);\nPyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(int) PyObject_HasAttrWithError(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttrStringWithError(PyObject *, const char *);\n#endif\nPyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);\n#endif\nPyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);\nPyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);\nPyAPI_FUNC(int) PyObject_IsTrue(PyObject *);\nPyAPI_FUNC(int) PyObject_Not(PyObject *);\nPyAPI_FUNC(int) PyCallable_Check(PyObject *);\nPyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);\n\n/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a\n   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),\n   returning the names of the current locals.  In this case, if there are\n   no current locals, NULL is returned, and PyErr_Occurred() is false.\n*/\nPyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);\n\n/* Helpers for printing recursive container types */\nPyAPI_FUNC(int) Py_ReprEnter(PyObject *);\nPyAPI_FUNC(void) Py_ReprLeave(PyObject *);\n\n/* Flag bits for printing: */\n#define Py_PRINT_RAW    1       /* No string quotes etc. */\n\n/*\nType flags (tp_flags)\n\nThese flags are used to change expected features and behavior for a\nparticular type.\n\nArbitration of the flag bit positions will need to be coordinated among\nall extension writers who publicly release their extensions (this will\nbe fewer than you might expect!).\n\nMost flags were removed as of Python 3.0 to make room for new flags.  (Some\nflags are not for backwards compatibility but to indicate the presence of an\noptional feature; these flags remain of course.)\n\nType definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.\n\nCode can use PyType_HasFeature(type_ob, flag_value) to test whether the\ngiven type object has a specified feature.\n*/\n\n#ifndef Py_LIMITED_API\n\n/* Track types initialized using _PyStaticType_InitBuiltin(). */\n#define _Py_TPFLAGS_STATIC_BUILTIN (1 << 1)\n\n/* The values array is placed inline directly after the rest of\n * the object. Implies Py_TPFLAGS_HAVE_GC.\n */\n#define Py_TPFLAGS_INLINE_VALUES (1 << 2)\n\n/* Placement of weakref pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_weaklistoffset.\n */\n#define Py_TPFLAGS_MANAGED_WEAKREF (1 << 3)\n\n/* Placement of dict (and values) pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_dictoffset. Implies Py_TPFLAGS_HAVE_GC.\n */\n#define Py_TPFLAGS_MANAGED_DICT (1 << 4)\n\n#define Py_TPFLAGS_PREHEADER (Py_TPFLAGS_MANAGED_WEAKREF | Py_TPFLAGS_MANAGED_DICT)\n\n/* Set if instances of the type object are treated as sequences for pattern matching */\n#define Py_TPFLAGS_SEQUENCE (1 << 5)\n/* Set if instances of the type object are treated as mappings for pattern matching */\n#define Py_TPFLAGS_MAPPING (1 << 6)\n#endif\n\n/* Disallow creating instances of the type: set tp_new to NULL and don't create\n * the \"__new__\" key in the type dictionary. */\n#define Py_TPFLAGS_DISALLOW_INSTANTIATION (1UL << 7)\n\n/* Set if the type object is immutable: type attributes cannot be set nor deleted */\n#define Py_TPFLAGS_IMMUTABLETYPE (1UL << 8)\n\n/* Set if the type object is dynamically allocated */\n#define Py_TPFLAGS_HEAPTYPE (1UL << 9)\n\n/* Set if the type allows subclassing */\n#define Py_TPFLAGS_BASETYPE (1UL << 10)\n\n/* Set if the type implements the vectorcall protocol (PEP 590) */\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\n#define Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)\n#ifndef Py_LIMITED_API\n// Backwards compatibility alias for API that was provisional in Python 3.8\n#define _Py_TPFLAGS_HAVE_VECTORCALL Py_TPFLAGS_HAVE_VECTORCALL\n#endif\n#endif\n\n/* Set if the type is 'ready' -- fully initialized */\n#define Py_TPFLAGS_READY (1UL << 12)\n\n/* Set while the type is being 'readied', to prevent recursive ready calls */\n#define Py_TPFLAGS_READYING (1UL << 13)\n\n/* Objects support garbage collection (see objimpl.h) */\n#define Py_TPFLAGS_HAVE_GC (1UL << 14)\n\n/* These two bits are preserved for Stackless Python, next after this is 17 */\n#ifdef STACKLESS\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)\n#else\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0\n#endif\n\n/* Objects behave like an unbound method */\n#define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)\n\n/* Unused. Legacy flag */\n#define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)\n\n/* Type is abstract and cannot be instantiated */\n#define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)\n\n// This undocumented flag gives certain built-ins their unique pattern-matching\n// behavior, which allows a single positional subpattern to match against the\n// subject itself (rather than a mapped attribute on it):\n#define _Py_TPFLAGS_MATCH_SELF (1UL << 22)\n\n/* Items (ob_size*tp_itemsize) are found at the end of an instance's memory */\n#define Py_TPFLAGS_ITEMS_AT_END (1UL << 23)\n\n/* These flags are used to determine if a type is a subclass. */\n#define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)\n#define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)\n#define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)\n#define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)\n#define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)\n#define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)\n#define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)\n#define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)\n\n#define Py_TPFLAGS_DEFAULT  ( \\\n                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \\\n                0)\n\n/* NOTE: Some of the following flags reuse lower bits (removed as part of the\n * Python 3.0 transition). */\n\n/* The following flags are kept for compatibility; in previous\n * versions they indicated presence of newer tp_* fields on the\n * type struct.\n * Starting with 3.8, binary compatibility of C extensions across\n * feature releases of Python is not supported anymore (except when\n * using the stable ABI, in which all classes are created dynamically,\n * using the interpreter's memory layout.)\n * Note that older extensions using the stable ABI set these flags,\n * so the bits must not be repurposed.\n */\n#define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)\n#define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)\n\n\n/*\nThe macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement\nreference counts.  Py_DECREF calls the object's deallocator function when\nthe refcount falls to 0; for\nobjects that don't contain references to other objects or heap memory\nthis can be the standard function free().  Both macros can be used\nwherever a void expression is allowed.  The argument must not be a\nNULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.\nThe macro _Py_NewReference(op) initialize reference counts to 1, and\nin special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional\nbookkeeping appropriate to the special build.\n\nWe assume that the reference count field can never overflow; this can\nbe proven when the size of the field is the same as the pointer size, so\nwe ignore the possibility.  Provided a C int is at least 32 bits (which\nis implicitly assumed in many parts of this code), that's enough for\nabout 2**31 references to an object.\n\nXXX The following became out of date in Python 2.2, but I'm not sure\nXXX what the full truth is now.  Certainly, heap-allocated type objects\nXXX can and should be deallocated.\nType objects should never be deallocated; the type pointer in an object\nis not considered to be a reference to the type object, to save\ncomplications in the deallocation function.  (This is actually a\ndecision that's up to the implementer of each new type so if you want,\nyou can count such references to the type object.)\n*/\n\n#if defined(Py_REF_DEBUG) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,\n                                      PyObject *op);\nPyAPI_FUNC(void) _Py_INCREF_IncRefTotal(void);\nPyAPI_FUNC(void) _Py_DECREF_DecRefTotal(void);\n#endif  // Py_REF_DEBUG && !Py_LIMITED_API\n\nPyAPI_FUNC(void) _Py_Dealloc(PyObject *);\n\n/*\nThese are provided as conveniences to Python runtime embedders, so that\nthey can have object code that is not dependent on Python compilation flags.\n*/\nPyAPI_FUNC(void) Py_IncRef(PyObject *);\nPyAPI_FUNC(void) Py_DecRef(PyObject *);\n\n// Similar to Py_IncRef() and Py_DecRef() but the argument must be non-NULL.\n// Private functions used by Py_INCREF() and Py_DECREF().\nPyAPI_FUNC(void) _Py_IncRef(PyObject *);\nPyAPI_FUNC(void) _Py_DecRef(PyObject *);\n\nstatic inline Py_ALWAYS_INLINE void Py_INCREF(PyObject *op)\n{\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n    // Stable ABI implements Py_INCREF() as a function call on limited C API\n    // version 3.12 and newer, and on Python built in debug mode. _Py_IncRef()\n    // was added to Python 3.10.0a7, use Py_IncRef() on older Python versions.\n    // Py_IncRef() accepts NULL whereas _Py_IncRef() doesn't.\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_IncRef(op);\n#  else\n    Py_IncRef(op);\n#  endif\n#else\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n#if defined(Py_GIL_DISABLED)\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    uint32_t new_local = local + 1;\n    if (new_local == 0) {\n        // local is equal to _Py_IMMORTAL_REFCNT: do nothing\n        return;\n    }\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, new_local);\n    }\n    else {\n        _Py_atomic_add_ssize(&op->ob_ref_shared, (1 << _Py_REF_SHARED_SHIFT));\n    }\n#elif SIZEOF_VOID_P > 4\n    // Portable saturated add, branching on the carry flag and set low bits\n    PY_UINT32_T cur_refcnt = op->ob_refcnt_split[PY_BIG_ENDIAN];\n    PY_UINT32_T new_refcnt = cur_refcnt + 1;\n    if (new_refcnt == 0) {\n        // cur_refcnt is equal to _Py_IMMORTAL_REFCNT: the object is immortal,\n        // do nothing\n        return;\n    }\n    op->ob_refcnt_split[PY_BIG_ENDIAN] = new_refcnt;\n#else\n    // Explicitly check immortality against the immortal value\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    op->ob_refcnt++;\n#endif\n    _Py_INCREF_STAT_INC();\n#ifdef Py_REF_DEBUG\n    _Py_INCREF_IncRefTotal();\n#endif\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_INCREF(op) Py_INCREF(_PyObject_CAST(op))\n#endif\n\n\n#if !defined(Py_LIMITED_API) && defined(Py_GIL_DISABLED)\n// Implements Py_DECREF on objects not owned by the current thread.\nPyAPI_FUNC(void) _Py_DecRefShared(PyObject *);\nPyAPI_FUNC(void) _Py_DecRefSharedDebug(PyObject *, const char *, int);\n\n// Called from Py_DECREF by the owning thread when the local refcount reaches\n// zero. The call will deallocate the object if the shared refcount is also\n// zero. Otherwise, the thread gives up ownership and merges the reference\n// count fields.\nPyAPI_FUNC(void) _Py_MergeZeroLocalRefcount(PyObject *);\n#endif\n\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n// Stable ABI implements Py_DECREF() as a function call on limited C API\n// version 3.12 and newer, and on Python built in debug mode. _Py_DecRef() was\n// added to Python 3.10.0a7, use Py_DecRef() on older Python versions.\n// Py_DecRef() accepts NULL whereas _Py_IncRef() doesn't.\nstatic inline void Py_DECREF(PyObject *op) {\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_DecRef(op);\n#  else\n    Py_DecRef(op);\n#  endif\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_GIL_DISABLED) && defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        if (local == 0) {\n            _Py_NegativeRefcount(filename, lineno, op);\n        }\n        local--;\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, local);\n        if (local == 0) {\n            _Py_MergeZeroLocalRefcount(op);\n        }\n    }\n    else {\n        _Py_DecRefSharedDebug(op, filename, lineno);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#elif defined(Py_GIL_DISABLED)\nstatic inline void Py_DECREF(PyObject *op)\n{\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        local--;\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, local);\n        if (local == 0) {\n            _Py_MergeZeroLocalRefcount(op);\n        }\n    }\n    else {\n        _Py_DecRefShared(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    if (op->ob_refcnt <= 0) {\n        _Py_NegativeRefcount(filename, lineno, op);\n    }\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#else\nstatic inline Py_ALWAYS_INLINE void Py_DECREF(PyObject *op)\n{\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n#endif\n\n\n/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear\n * and tp_dealloc implementations.\n *\n * Note that \"the obvious\" code can be deadly:\n *\n *     Py_XDECREF(op);\n *     op = NULL;\n *\n * Typically, `op` is something like self->containee, and `self` is done\n * using its `containee` member.  In the code sequence above, suppose\n * `containee` is non-NULL with a refcount of 1.  Its refcount falls to\n * 0 on the first line, which can trigger an arbitrary amount of code,\n * possibly including finalizers (like __del__ methods or weakref callbacks)\n * coded in Python, which in turn can release the GIL and allow other threads\n * to run, etc.  Such code may even invoke methods of `self` again, or cause\n * cyclic gc to trigger, but-- oops! --self->containee still points to the\n * object being torn down, and it may be in an insane state while being torn\n * down.  This has in fact been a rich historic source of miserable (rare &\n * hard-to-diagnose) segfaulting (and other) bugs.\n *\n * The safe way is:\n *\n *      Py_CLEAR(op);\n *\n * That arranges to set `op` to NULL _before_ decref'ing, so that any code\n * triggered as a side-effect of `op` getting torn down no longer believes\n * `op` points to a valid object.\n *\n * There are cases where it's safe to use the naive code, but they're brittle.\n * For example, if `op` points to a Python integer, you know that destroying\n * one of those can't cause problems -- but in part that relies on that\n * Python integers aren't currently weakly referencable.  Best practice is\n * to use Py_CLEAR() even if you can't think of a reason for why you need to.\n *\n * gh-98724: Use a temporary variable to only evaluate the macro argument once,\n * to avoid the duplication of side effects if the argument has side effects.\n *\n * gh-99701: If the PyObject* type is used with casting arguments to PyObject*,\n * the code can be miscompiled with strict aliasing because of type punning.\n * With strict aliasing, a compiler considers that two pointers of different\n * types cannot read or write the same memory which enables optimization\n * opportunities.\n *\n * If available, use _Py_TYPEOF() to use the 'op' type for temporary variables,\n * and so avoid type punning. Otherwise, use memcpy() which causes type erasure\n * and so prevents the compiler to reuse an old cached 'op' value after\n * Py_CLEAR().\n */\n#ifdef _Py_TYPEOF\n#define Py_CLEAR(op) \\\n    do { \\\n        _Py_TYPEOF(op)* _tmp_op_ptr = &(op); \\\n        _Py_TYPEOF(op) _tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            *_tmp_op_ptr = _Py_NULL; \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#else\n#define Py_CLEAR(op) \\\n    do { \\\n        PyObject **_tmp_op_ptr = _Py_CAST(PyObject**, &(op)); \\\n        PyObject *_tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            PyObject *_null_ptr = _Py_NULL; \\\n            memcpy(_tmp_op_ptr, &_null_ptr, sizeof(PyObject*)); \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#endif\n\n\n/* Function to use in case the object pointer can be NULL: */\nstatic inline void Py_XINCREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_INCREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XINCREF(op) Py_XINCREF(_PyObject_CAST(op))\n#endif\n\nstatic inline void Py_XDECREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_DECREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XDECREF(op) Py_XDECREF(_PyObject_CAST(op))\n#endif\n\n// Create a new strong reference to an object:\n// increment the reference count of the object and return the object.\nPyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);\n\n// Similar to Py_NewRef(), but the object can be NULL.\nPyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);\n\nstatic inline PyObject* _Py_NewRef(PyObject *obj)\n{\n    Py_INCREF(obj);\n    return obj;\n}\n\nstatic inline PyObject* _Py_XNewRef(PyObject *obj)\n{\n    Py_XINCREF(obj);\n    return obj;\n}\n\n// Py_NewRef() and Py_XNewRef() are exported as functions for the stable ABI.\n// Names overridden with macros by static inline functions for best\n// performances.\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_NewRef(obj) _Py_NewRef(_PyObject_CAST(obj))\n#  define Py_XNewRef(obj) _Py_XNewRef(_PyObject_CAST(obj))\n#else\n#  define Py_NewRef(obj) _Py_NewRef(obj)\n#  define Py_XNewRef(obj) _Py_XNewRef(obj)\n#endif\n\n\n#define Py_CONSTANT_NONE 0\n#define Py_CONSTANT_FALSE 1\n#define Py_CONSTANT_TRUE 2\n#define Py_CONSTANT_ELLIPSIS 3\n#define Py_CONSTANT_NOT_IMPLEMENTED 4\n#define Py_CONSTANT_ZERO 5\n#define Py_CONSTANT_ONE 6\n#define Py_CONSTANT_EMPTY_STR 7\n#define Py_CONSTANT_EMPTY_BYTES 8\n#define Py_CONSTANT_EMPTY_TUPLE 9\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(PyObject*) Py_GetConstant(unsigned int constant_id);\nPyAPI_FUNC(PyObject*) Py_GetConstantBorrowed(unsigned int constant_id);\n#endif\n\n\n/*\n_Py_NoneStruct is an object of undefined type which can be used in contexts\nwhere NULL (nil) is not suitable (since NULL often means 'error').\n*/\nPyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000\n#  define Py_None Py_GetConstantBorrowed(Py_CONSTANT_NONE)\n#else\n#  define Py_None (&_Py_NoneStruct)\n#endif\n\n// Test if an object is the None singleton, the same as \"x is None\" in Python.\nPyAPI_FUNC(int) Py_IsNone(PyObject *x);\n#define Py_IsNone(x) Py_Is((x), Py_None)\n\n/* Macro for returning Py_None from a function */\n#define Py_RETURN_NONE return Py_None\n\n/*\nPy_NotImplemented is a singleton used to signal that an operation is\nnot implemented for a given type combination.\n*/\nPyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */\n\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000\n#  define Py_NotImplemented Py_GetConstantBorrowed(Py_CONSTANT_NOT_IMPLEMENTED)\n#else\n#  define Py_NotImplemented (&_Py_NotImplementedStruct)\n#endif\n\n/* Macro for returning Py_NotImplemented from a function */\n#define Py_RETURN_NOTIMPLEMENTED return Py_NotImplemented\n\n/* Rich comparison opcodes */\n#define Py_LT 0\n#define Py_LE 1\n#define Py_EQ 2\n#define Py_NE 3\n#define Py_GT 4\n#define Py_GE 5\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000\n/* Result of calling PyIter_Send */\ntypedef enum {\n    PYGEN_RETURN = 0,\n    PYGEN_ERROR = -1,\n    PYGEN_NEXT = 1,\n} PySendResult;\n#endif\n\n/*\n * Macro for implementing rich comparisons\n *\n * Needs to be a macro because any C-comparable type can be used.\n */\n#define Py_RETURN_RICHCOMPARE(val1, val2, op)                               \\\n    do {                                                                    \\\n        switch (op) {                                                       \\\n        case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        default:                                                            \\\n            Py_UNREACHABLE();                                               \\\n        }                                                                   \\\n    } while (0)\n\n\n/*\nMore conventions\n================\n\nArgument Checking\n-----------------\n\nFunctions that take objects as arguments normally don't check for nil\narguments, but they do check the type of the argument, and return an\nerror if the function doesn't apply to the type.\n\nFailure Modes\n-------------\n\nFunctions may fail for a variety of reasons, including running out of\nmemory.  This is communicated to the caller in two ways: an error string\nis set (see errors.h), and the function result differs: functions that\nnormally return a pointer return NULL for failure, functions returning\nan integer return -1 (which could be a legal return value too!), and\nother functions return 0 for success and -1 for failure.\nCallers should always check for errors before using the result.  If\nan error was set, the caller must either explicitly clear it, or pass\nthe error on to its caller.\n\nReference Counts\n----------------\n\nIt takes a while to get used to the proper usage of reference counts.\n\nFunctions that create an object set the reference count to 1; such new\nobjects must be stored somewhere or destroyed again with Py_DECREF().\nSome functions that 'store' objects, such as PyTuple_SetItem() and\nPyList_SetItem(),\ndon't increment the reference count of the object, since the most\nfrequent use is to store a fresh object.  Functions that 'retrieve'\nobjects, such as PyTuple_GetItem() and PyDict_GetItemString(), also\ndon't increment\nthe reference count, since most frequently the object is only looked at\nquickly.  Thus, to retrieve an object and store it again, the caller\nmust call Py_INCREF() explicitly.\n\nNOTE: functions that 'consume' a reference count, like\nPyList_SetItem(), consume the reference even if the object wasn't\nsuccessfully stored, to simplify error handling.\n\nIt seems attractive to make other functions that take an object as\nargument consume a reference count; however, this may quickly get\nconfusing (even the current practice is already confusing).  Consider\nit carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at\ntimes.\n*/\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_OBJECT_H\n#  include \"cpython/object.h\"\n#  undef Py_CPYTHON_OBJECT_H\n#endif\n\n\nstatic inline int\nPyType_HasFeature(PyTypeObject *type, unsigned long feature)\n{\n    unsigned long flags;\n#ifdef Py_LIMITED_API\n    // PyTypeObject is opaque in the limited C API\n    flags = PyType_GetFlags(type);\n#else\n#   ifdef Py_GIL_DISABLED\n        flags = _Py_atomic_load_ulong_relaxed(&type->tp_flags);\n#   else\n        flags = type->tp_flags;\n#   endif\n#endif\n    return ((flags & feature) != 0);\n}\n\n#define PyType_FastSubclass(type, flag) PyType_HasFeature((type), (flag))\n\nstatic inline int PyType_Check(PyObject *op) {\n    return PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_Check(op) PyType_Check(_PyObject_CAST(op))\n#endif\n\n#define _PyType_CAST(op) \\\n    (assert(PyType_Check(op)), _Py_CAST(PyTypeObject*, (op)))\n\nstatic inline int PyType_CheckExact(PyObject *op) {\n    return Py_IS_TYPE(op, &PyType_Type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_CheckExact(op) PyType_CheckExact(_PyObject_CAST(op))\n#endif\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(PyObject *) PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif   // !Py_OBJECT_H\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/cpython/pyatomic_gcc.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "// This is the implementation of Python atomic operations using GCC's built-in\n// functions that match the C+11 memory model. This implementation is preferred\n// for GCC compatible compilers, such as Clang. These functions are available\n// in GCC 4.8+ without needing to compile with --std=c11 or --std=gnu11.\n\n#ifndef Py_ATOMIC_GCC_H\n#  error \"this header file must not be included directly\"\n#endif\n\n\n// --- _Py_atomic_add --------------------------------------------------------\n\nstatic inline int\n_Py_atomic_add_int(int *obj, int value)\n{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline int8_t\n_Py_atomic_add_int8(int8_t *obj, int8_t value)\n{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline int16_t\n_Py_atomic_add_int16(int16_t *obj, int16_t value)\n{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline int32_t\n_Py_atomic_add_int32(int32_t *obj, int32_t value)\n{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline int64_t\n_Py_atomic_add_int64(int64_t *obj, int64_t value)\n{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline intptr_t\n_Py_atomic_add_intptr(intptr_t *obj, intptr_t value)\n{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline unsigned int\n_Py_atomic_add_uint(unsigned int *obj, unsigned int value)\n{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint8_t\n_Py_atomic_add_uint8(uint8_t *obj, uint8_t value)\n{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint16_t\n_Py_atomic_add_uint16(uint16_t *obj, uint16_t value)\n{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint32_t\n_Py_atomic_add_uint32(uint32_t *obj, uint32_t value)\n{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint64_t\n_Py_atomic_add_uint64(uint64_t *obj, uint64_t value)\n{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uintptr_t\n_Py_atomic_add_uintptr(uintptr_t *obj, uintptr_t value)\n{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline Py_ssize_t\n_Py_atomic_add_ssize(Py_ssize_t *obj, Py_ssize_t value)\n{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n\n\n// --- _Py_atomic_compare_exchange -------------------------------------------\n\nstatic inline int\n_Py_atomic_compare_exchange_int(int *obj, int *expected, int desired)\n{ return __atomic_compare_exchange_n(obj, expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\nstatic inline int\n_Py_atomic_compare_exchange_int8(int8_t *obj, int8_t *expected, int8_t desired)\n{ return __atomic_compare_exchange_n(obj, expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\nstatic inline int\n_Py_atomic_compare_exchange_int16(int16_t *obj, int16_t *expected, int16_t desired)\n{ return __atomic_compare_exchange_n(obj, expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\nstatic inline int\n_Py_atomic_compare_exchange_int32(int32_t *obj, int32_t *expected, int32_t desired)\n{ return __atomic_compare_exchange_n(obj, expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\nstatic inline int\n_Py_atomic_compare_exchange_int64(int64_t *obj, int64_t *expected, int64_t desired)\n{ return __atomic_compare_exchange_n(obj, expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\nstatic inline int\n_Py_atomic_compare_exchange_intptr(intptr_t *obj, intptr_t *expected, intptr_t desired)\n{ return __atomic_compare_exchange_n(obj, expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\nstatic inline int\n_Py_atomic_compare_exchange_uint(unsigned int *obj, unsigned int *expected, unsigned int desired)\n{ return __atomic_compare_exchange_n(obj, expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\nstatic inline int\n_Py_atomic_compare_exchange_uint8(uint8_t *obj, uint8_t *expected, uint8_t desired)\n{ return __atomic_compare_exchange_n(obj, expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\nstatic inline int\n_Py_atomic_compare_exchange_uint16(uint16_t *obj, uint16_t *expected, uint16_t desired)\n{ return __atomic_compare_exchange_n(obj, expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\nstatic inline int\n_Py_atomic_compare_exchange_uint32(uint32_t *obj, uint32_t *expected, uint32_t desired)\n{ return __atomic_compare_exchange_n(obj, expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\nstatic inline int\n_Py_atomic_compare_exchange_uint64(uint64_t *obj, uint64_t *expected, uint64_t desired)\n{ return __atomic_compare_exchange_n(obj, expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\nstatic inline int\n_Py_atomic_compare_exchange_uintptr(uintptr_t *obj, uintptr_t *expected, uintptr_t desired)\n{ return __atomic_compare_exchange_n(obj, expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\nstatic inline int\n_Py_atomic_compare_exchange_ssize(Py_ssize_t *obj, Py_ssize_t *expected, Py_ssize_t desired)\n{ return __atomic_compare_exchange_n(obj, expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\nstatic inline int\n_Py_atomic_compare_exchange_ptr(void *obj, void *expected, void *desired)\n{ return __atomic_compare_exchange_n((void **)obj, (void **)expected, desired, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }\n\n\n// --- _Py_atomic_exchange ---------------------------------------------------\n\nstatic inline int\n_Py_atomic_exchange_int(int *obj, int value)\n{ return __atomic_exchange_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline int8_t\n_Py_atomic_exchange_int8(int8_t *obj, int8_t value)\n{ return __atomic_exchange_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline int16_t\n_Py_atomic_exchange_int16(int16_t *obj, int16_t value)\n{ return __atomic_exchange_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline int32_t\n_Py_atomic_exchange_int32(int32_t *obj, int32_t value)\n{ return __atomic_exchange_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline int64_t\n_Py_atomic_exchange_int64(int64_t *obj, int64_t value)\n{ return __atomic_exchange_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline intptr_t\n_Py_atomic_exchange_intptr(intptr_t *obj, intptr_t value)\n{ return __atomic_exchange_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline unsigned int\n_Py_atomic_exchange_uint(unsigned int *obj, unsigned int value)\n{ return __atomic_exchange_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint8_t\n_Py_atomic_exchange_uint8(uint8_t *obj, uint8_t value)\n{ return __atomic_exchange_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint16_t\n_Py_atomic_exchange_uint16(uint16_t *obj, uint16_t value)\n{ return __atomic_exchange_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint32_t\n_Py_atomic_exchange_uint32(uint32_t *obj, uint32_t value)\n{ return __atomic_exchange_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint64_t\n_Py_atomic_exchange_uint64(uint64_t *obj, uint64_t value)\n{ return __atomic_exchange_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uintptr_t\n_Py_atomic_exchange_uintptr(uintptr_t *obj, uintptr_t value)\n{ return __atomic_exchange_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline Py_ssize_t\n_Py_atomic_exchange_ssize(Py_ssize_t *obj, Py_ssize_t value)\n{ return __atomic_exchange_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void *\n_Py_atomic_exchange_ptr(void *obj, void *value)\n{ return __atomic_exchange_n((void **)obj, value, __ATOMIC_SEQ_CST); }\n\n\n// --- _Py_atomic_and --------------------------------------------------------\n\nstatic inline uint8_t\n_Py_atomic_and_uint8(uint8_t *obj, uint8_t value)\n{ return __atomic_fetch_and(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint16_t\n_Py_atomic_and_uint16(uint16_t *obj, uint16_t value)\n{ return __atomic_fetch_and(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint32_t\n_Py_atomic_and_uint32(uint32_t *obj, uint32_t value)\n{ return __atomic_fetch_and(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint64_t\n_Py_atomic_and_uint64(uint64_t *obj, uint64_t value)\n{ return __atomic_fetch_and(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uintptr_t\n_Py_atomic_and_uintptr(uintptr_t *obj, uintptr_t value)\n{ return __atomic_fetch_and(obj, value, __ATOMIC_SEQ_CST); }\n\n\n// --- _Py_atomic_or ---------------------------------------------------------\n\nstatic inline uint8_t\n_Py_atomic_or_uint8(uint8_t *obj, uint8_t value)\n{ return __atomic_fetch_or(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint16_t\n_Py_atomic_or_uint16(uint16_t *obj, uint16_t value)\n{ return __atomic_fetch_or(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint32_t\n_Py_atomic_or_uint32(uint32_t *obj, uint32_t value)\n{ return __atomic_fetch_or(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uint64_t\n_Py_atomic_or_uint64(uint64_t *obj, uint64_t value)\n{ return __atomic_fetch_or(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline uintptr_t\n_Py_atomic_or_uintptr(uintptr_t *obj, uintptr_t value)\n{ return __atomic_fetch_or(obj, value, __ATOMIC_SEQ_CST); }\n\n\n// --- _Py_atomic_load -------------------------------------------------------\n\nstatic inline int\n_Py_atomic_load_int(const int *obj)\n{ return __atomic_load_n(obj, __ATOMIC_SEQ_CST); }\n\nstatic inline int8_t\n_Py_atomic_load_int8(const int8_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_SEQ_CST); }\n\nstatic inline int16_t\n_Py_atomic_load_int16(const int16_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_SEQ_CST); }\n\nstatic inline int32_t\n_Py_atomic_load_int32(const int32_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_SEQ_CST); }\n\nstatic inline int64_t\n_Py_atomic_load_int64(const int64_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_SEQ_CST); }\n\nstatic inline intptr_t\n_Py_atomic_load_intptr(const intptr_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_SEQ_CST); }\n\nstatic inline uint8_t\n_Py_atomic_load_uint8(const uint8_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_SEQ_CST); }\n\nstatic inline uint16_t\n_Py_atomic_load_uint16(const uint16_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_SEQ_CST); }\n\nstatic inline uint32_t\n_Py_atomic_load_uint32(const uint32_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_SEQ_CST); }\n\nstatic inline uint64_t\n_Py_atomic_load_uint64(const uint64_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_SEQ_CST); }\n\nstatic inline uintptr_t\n_Py_atomic_load_uintptr(const uintptr_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_SEQ_CST); }\n\nstatic inline unsigned int\n_Py_atomic_load_uint(const unsigned int *obj)\n{ return __atomic_load_n(obj, __ATOMIC_SEQ_CST); }\n\nstatic inline Py_ssize_t\n_Py_atomic_load_ssize(const Py_ssize_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_SEQ_CST); }\n\nstatic inline void *\n_Py_atomic_load_ptr(const void *obj)\n{ return (void *)__atomic_load_n((void * const *)obj, __ATOMIC_SEQ_CST); }\n\n\n// --- _Py_atomic_load_relaxed -----------------------------------------------\n\nstatic inline int\n_Py_atomic_load_int_relaxed(const int *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\nstatic inline int8_t\n_Py_atomic_load_int8_relaxed(const int8_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\nstatic inline int16_t\n_Py_atomic_load_int16_relaxed(const int16_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\nstatic inline int32_t\n_Py_atomic_load_int32_relaxed(const int32_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\nstatic inline int64_t\n_Py_atomic_load_int64_relaxed(const int64_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\nstatic inline intptr_t\n_Py_atomic_load_intptr_relaxed(const intptr_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\nstatic inline uint8_t\n_Py_atomic_load_uint8_relaxed(const uint8_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\nstatic inline uint16_t\n_Py_atomic_load_uint16_relaxed(const uint16_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\nstatic inline uint32_t\n_Py_atomic_load_uint32_relaxed(const uint32_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\nstatic inline uint64_t\n_Py_atomic_load_uint64_relaxed(const uint64_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\nstatic inline uintptr_t\n_Py_atomic_load_uintptr_relaxed(const uintptr_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\nstatic inline unsigned int\n_Py_atomic_load_uint_relaxed(const unsigned int *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\nstatic inline Py_ssize_t\n_Py_atomic_load_ssize_relaxed(const Py_ssize_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\nstatic inline void *\n_Py_atomic_load_ptr_relaxed(const void *obj)\n{ return (void *)__atomic_load_n((void * const *)obj, __ATOMIC_RELAXED); }\n\nstatic inline unsigned long long\n_Py_atomic_load_ullong_relaxed(const unsigned long long *obj)\n{ return __atomic_load_n(obj, __ATOMIC_RELAXED); }\n\n\n// --- _Py_atomic_store ------------------------------------------------------\n\nstatic inline void\n_Py_atomic_store_int(int *obj, int value)\n{ __atomic_store_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void\n_Py_atomic_store_int8(int8_t *obj, int8_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void\n_Py_atomic_store_int16(int16_t *obj, int16_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void\n_Py_atomic_store_int32(int32_t *obj, int32_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void\n_Py_atomic_store_int64(int64_t *obj, int64_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void\n_Py_atomic_store_intptr(intptr_t *obj, intptr_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void\n_Py_atomic_store_uint8(uint8_t *obj, uint8_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void\n_Py_atomic_store_uint16(uint16_t *obj, uint16_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void\n_Py_atomic_store_uint32(uint32_t *obj, uint32_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void\n_Py_atomic_store_uint64(uint64_t *obj, uint64_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void\n_Py_atomic_store_uintptr(uintptr_t *obj, uintptr_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void\n_Py_atomic_store_uint(unsigned int *obj, unsigned int value)\n{ __atomic_store_n(obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void\n_Py_atomic_store_ptr(void *obj, void *value)\n{ __atomic_store_n((void **)obj, value, __ATOMIC_SEQ_CST); }\n\nstatic inline void\n_Py_atomic_store_ssize(Py_ssize_t *obj, Py_ssize_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_SEQ_CST); }\n\n\n// --- _Py_atomic_store_relaxed ----------------------------------------------\n\nstatic inline void\n_Py_atomic_store_int_relaxed(int *obj, int value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_int8_relaxed(int8_t *obj, int8_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_int16_relaxed(int16_t *obj, int16_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_int32_relaxed(int32_t *obj, int32_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_int64_relaxed(int64_t *obj, int64_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_intptr_relaxed(intptr_t *obj, intptr_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_uint8_relaxed(uint8_t *obj, uint8_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_uint16_relaxed(uint16_t *obj, uint16_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_uint32_relaxed(uint32_t *obj, uint32_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_uint64_relaxed(uint64_t *obj, uint64_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_uintptr_relaxed(uintptr_t *obj, uintptr_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_uint_relaxed(unsigned int *obj, unsigned int value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_ptr_relaxed(void *obj, void *value)\n{ __atomic_store_n((void **)obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_ssize_relaxed(Py_ssize_t *obj, Py_ssize_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\nstatic inline void\n_Py_atomic_store_ullong_relaxed(unsigned long long *obj,\n                                unsigned long long value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n\n\n// --- _Py_atomic_load_ptr_acquire / _Py_atomic_store_ptr_release ------------\n\nstatic inline void *\n_Py_atomic_load_ptr_acquire(const void *obj)\n{ return (void *)__atomic_load_n((void * const *)obj, __ATOMIC_ACQUIRE); }\n\nstatic inline uintptr_t\n_Py_atomic_load_uintptr_acquire(const uintptr_t *obj)\n{ return (uintptr_t)__atomic_load_n(obj, __ATOMIC_ACQUIRE); }\n\nstatic inline void\n_Py_atomic_store_ptr_release(void *obj, void *value)\n{ __atomic_store_n((void **)obj, value, __ATOMIC_RELEASE); }\n\nstatic inline void\n_Py_atomic_store_uintptr_release(uintptr_t *obj, uintptr_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELEASE); }\n\nstatic inline void\n_Py_atomic_store_int_release(int *obj, int value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELEASE); }\n\nstatic inline void\n_Py_atomic_store_ssize_release(Py_ssize_t *obj, Py_ssize_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELEASE); }\n\nstatic inline int\n_Py_atomic_load_int_acquire(const int *obj)\n{ return __atomic_load_n(obj, __ATOMIC_ACQUIRE); }\n\nstatic inline void\n_Py_atomic_store_uint32_release(uint32_t *obj, uint32_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELEASE); }\n\nstatic inline void\n_Py_atomic_store_uint64_release(uint64_t *obj, uint64_t value)\n{ __atomic_store_n(obj, value, __ATOMIC_RELEASE); }\n\nstatic inline uint64_t\n_Py_atomic_load_uint64_acquire(const uint64_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_ACQUIRE); }\n\nstatic inline uint32_t\n_Py_atomic_load_uint32_acquire(const uint32_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_ACQUIRE); }\n\nstatic inline Py_ssize_t\n_Py_atomic_load_ssize_acquire(const Py_ssize_t *obj)\n{ return __atomic_load_n(obj, __ATOMIC_ACQUIRE); }\n\n// --- _Py_atomic_fence ------------------------------------------------------\n\nstatic inline void\n_Py_atomic_fence_seq_cst(void)\n{ __atomic_thread_fence(__ATOMIC_SEQ_CST); }\n\n static inline void\n_Py_atomic_fence_acquire(void)\n{ __atomic_thread_fence(__ATOMIC_ACQUIRE); }\n\n static inline void\n_Py_atomic_fence_release(void)\n{ __atomic_thread_fence(__ATOMIC_RELEASE); }\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "Python/ceval.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/* Execute compiled code */\n\n#define _PY_INTERPRETER\n\n#include \"Python.h\"\n#include \"pycore_abstract.h\"      // _PyIndex_Check()\n#include \"pycore_backoff.h\"\n#include \"pycore_call.h\"          // _PyObject_CallNoArgs()\n#include \"pycore_cell.h\"          // PyCell_GetRef()\n#include \"pycore_ceval.h\"\n#include \"pycore_code.h\"\n#include \"pycore_emscripten_signal.h\"  // _Py_CHECK_EMSCRIPTEN_SIGNALS\n#include \"pycore_function.h\"\n#include \"pycore_instruments.h\"\n#include \"pycore_intrinsics.h\"\n#include \"pycore_jit.h\"\n#include \"pycore_long.h\"          // _PyLong_GetZero()\n#include \"pycore_moduleobject.h\"  // PyModuleObject\n#include \"pycore_object.h\"        // _PyObject_GC_TRACK()\n#include \"pycore_opcode_metadata.h\" // EXTRA_CASES\n#include \"pycore_optimizer.h\"     // _PyUOpExecutor_Type\n#include \"pycore_opcode_utils.h\"  // MAKE_FUNCTION_*\n#include \"pycore_pyatomic_ft_wrappers.h\" // FT_ATOMIC_*\n#include \"pycore_pyerrors.h\"      // _PyErr_GetRaisedException()\n#include \"pycore_pystate.h\"       // _PyInterpreterState_GET()\n#include \"pycore_range.h\"         // _PyRangeIterObject\n#include \"pycore_setobject.h\"     // _PySet_Update()\n#include \"pycore_sliceobject.h\"   // _PyBuildSlice_ConsumeRefs\n#include \"pycore_sysmodule.h\"     // _PySys_Audit()\n#include \"pycore_tuple.h\"         // _PyTuple_ITEMS()\n#include \"pycore_typeobject.h\"    // _PySuper_Lookup()\n#include \"pycore_uop_ids.h\"       // Uops\n#include \"pycore_pyerrors.h\"\n\n#include \"pycore_dict.h\"\n#include \"dictobject.h\"\n#include \"pycore_frame.h\"\n#include \"frameobject.h\"          // _PyInterpreterFrame_GetLine\n#include \"opcode.h\"\n#include \"pydtrace.h\"\n#include \"setobject.h\"\n\n#include <stdbool.h>              // bool\n\n#ifdef Py_DEBUG\n   /* For debugging the interpreter: */\n#  define LLTRACE  1      /* Low-level trace feature */\n#endif\n\n#if !defined(Py_BUILD_CORE)\n#  error \"ceval.c must be build with Py_BUILD_CORE define for best performance\"\n#endif\n\n#if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_GIL_DISABLED)\n// GH-89279: The MSVC compiler does not inline these static inline functions\n// in PGO build in _PyEval_EvalFrameDefault(), because this function is over\n// the limit of PGO, and that limit cannot be configured.\n// Define them as macros to make sure that they are always inlined by the\n// preprocessor.\n// TODO: implement Py_DECREF macro for Py_GIL_DISABLED\n\n#undef Py_DECREF\n#define Py_DECREF(arg) \\\n    do { \\\n        PyObject *op = _PyObject_CAST(arg); \\\n        if (_Py_IsImmortal(op)) { \\\n            break; \\\n        } \\\n        _Py_DECREF_STAT_INC(); \\\n        if (--op->ob_refcnt == 0) { \\\n            destructor dealloc = Py_TYPE(op)->tp_dealloc; \\\n            (*dealloc)(op); \\\n        } \\\n    } while (0)\n\n#undef Py_XDECREF\n#define Py_XDECREF(arg) \\\n    do { \\\n        PyObject *xop = _PyObject_CAST(arg); \\\n        if (xop != NULL) { \\\n            Py_DECREF(xop); \\\n        } \\\n    } while (0)\n\n#undef Py_IS_TYPE\n#define Py_IS_TYPE(ob, type) \\\n    (_PyObject_CAST(ob)->ob_type == (type))\n\n#undef _Py_DECREF_SPECIALIZED\n#define _Py_DECREF_SPECIALIZED(arg, dealloc) \\\n    do { \\\n        PyObject *op = _PyObject_CAST(arg); \\\n        if (_Py_IsImmortal(op)) { \\\n            break; \\\n        } \\\n        _Py_DECREF_STAT_INC(); \\\n        if (--op->ob_refcnt == 0) { \\\n            destructor d = (destructor)(dealloc); \\\n            d(op); \\\n        } \\\n    } while (0)\n#endif\n\n\n#ifdef LLTRACE\nstatic void\ndump_stack(_PyInterpreterFrame *frame, PyObject **stack_pointer)\n{\n    PyObject **stack_base = _PyFrame_Stackbase(frame);\n    PyObject *exc = PyErr_GetRaisedException();\n    printf(\"    stack=[\");\n    for (PyObject **ptr = stack_base; ptr < stack_pointer; ptr++) {\n        if (ptr != stack_base) {\n            printf(\", \");\n        }\n        if (*ptr == NULL) {\n            printf(\"<nil>\");\n            continue;\n        }\n        if (\n            *ptr == Py_None\n            || PyBool_Check(*ptr)\n            || PyLong_CheckExact(*ptr)\n            || PyFloat_CheckExact(*ptr)\n            || PyUnicode_CheckExact(*ptr)\n        ) {\n            if (PyObject_Print(*ptr, stdout, 0) == 0) {\n                continue;\n            }\n            PyErr_Clear();\n        }\n        // Don't call __repr__(), it might recurse into the interpreter.\n        printf(\"<%s at %p>\", Py_TYPE(*ptr)->tp_name, (void *)(*ptr));\n    }\n    printf(\"]\\n\");\n    fflush(stdout);\n    PyErr_SetRaisedException(exc);\n}\n\nstatic void\nlltrace_instruction(_PyInterpreterFrame *frame,\n                    PyObject **stack_pointer,\n                    _Py_CODEUNIT *next_instr,\n                    int opcode,\n                    int oparg)\n{\n    if (frame->owner == FRAME_OWNED_BY_CSTACK) {\n        return;\n    }\n    dump_stack(frame, stack_pointer);\n    const char *opname = _PyOpcode_OpName[opcode];\n    assert(opname != NULL);\n    int offset = (int)(next_instr - _PyCode_CODE(_PyFrame_GetCode(frame)));\n    if (OPCODE_HAS_ARG((int)_PyOpcode_Deopt[opcode])) {\n        printf(\"%d: %s %d\\n\", offset * 2, opname, oparg);\n    }\n    else {\n        printf(\"%d: %s\\n\", offset * 2, opname);\n    }\n    fflush(stdout);\n}\nstatic void\nlltrace_resume_frame(_PyInterpreterFrame *frame)\n{\n    PyObject *fobj = frame->f_funcobj;\n    if (!PyCode_Check(frame->f_executable) ||\n        fobj == NULL ||\n        !PyFunction_Check(fobj)\n    ) {\n        printf(\"\\nResuming frame.\\n\");\n        return;\n    }\n    PyFunctionObject *f = (PyFunctionObject *)fobj;\n    PyObject *exc = PyErr_GetRaisedException();\n    PyObject *name = f->func_qualname;\n    if (name == NULL) {\n        name = f->func_name;\n    }\n    printf(\"\\nResuming frame\");\n    if (name) {\n        printf(\" for \");\n        if (PyObject_Print(name, stdout, 0) < 0) {\n            PyErr_Clear();\n        }\n    }\n    if (f->func_module) {\n        printf(\" in module \");\n        if (PyObject_Print(f->func_module, stdout, 0) < 0) {\n            PyErr_Clear();\n        }\n    }\n    printf(\"\\n\");\n    fflush(stdout);\n    PyErr_SetRaisedException(exc);\n}\n\nstatic int\nmaybe_lltrace_resume_frame(_PyInterpreterFrame *frame, _PyInterpreterFrame *skip_frame, PyObject *globals)\n{\n    if (globals == NULL) {\n        return 0;\n    }\n    if (frame == skip_frame) {\n        return 0;\n    }\n    int r = PyDict_Contains(globals, &_Py_ID(__lltrace__));\n    if (r < 0) {\n        return -1;\n    }\n    int lltrace = r * 5;  // Levels 1-4 only trace uops\n    if (!lltrace) {\n        // Can also be controlled by environment variable\n        char *python_lltrace = Py_GETENV(\"PYTHON_LLTRACE\");\n        if (python_lltrace != NULL && *python_lltrace >= '0') {\n            lltrace = *python_lltrace - '0';  // TODO: Parse an int and all that\n        }\n    }\n    if (lltrace >= 5) {\n        lltrace_resume_frame(frame);\n    }\n    return lltrace;\n}\n\n#endif\n\nstatic void monitor_raise(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\nstatic void monitor_reraise(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\nstatic int monitor_stop_iteration(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr,\n                 PyObject *value);\nstatic void monitor_unwind(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\nstatic int monitor_handled(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr, PyObject *exc);\nstatic void monitor_throw(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\n\nstatic PyObject * import_name(PyThreadState *, _PyInterpreterFrame *,\n                              PyObject *, PyObject *, PyObject *);\nstatic PyObject * import_from(PyThreadState *, PyObject *, PyObject *);\nstatic int check_args_iterable(PyThreadState *, PyObject *func, PyObject *vararg);\nstatic int get_exception_handler(PyCodeObject *, int, int*, int*, int*);\nstatic  _PyInterpreterFrame *\n_PyEvalFramePushAndInit_Ex(PyThreadState *tstate, PyFunctionObject *func,\n    PyObject *locals, Py_ssize_t nargs, PyObject *callargs, PyObject *kwargs);\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n\nint\nPy_GetRecursionLimit(void)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    return interp->ceval.recursion_limit;\n}\n\nvoid\nPy_SetRecursionLimit(int new_limit)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    interp->ceval.recursion_limit = new_limit;\n    for (PyThreadState *p = interp->threads.head; p != NULL; p = p->next) {\n        int depth = p->py_recursion_limit - p->py_recursion_remaining;\n        p->py_recursion_limit = new_limit;\n        p->py_recursion_remaining = new_limit - depth;\n    }\n}\n\n/* The function _Py_EnterRecursiveCallTstate() only calls _Py_CheckRecursiveCall()\n   if the recursion_depth reaches recursion_limit. */\nint\n_Py_CheckRecursiveCall(PyThreadState *tstate, const char *where)\n{\n#ifdef USE_STACKCHECK\n    if (PyOS_CheckStack()) {\n        ++tstate->c_recursion_remaining;\n        _PyErr_SetString(tstate, PyExc_MemoryError, \"Stack overflow\");\n        return -1;\n    }\n#endif\n    if (tstate->recursion_headroom) {\n        if (tstate->c_recursion_remaining < -50) {\n            /* Overflowing while handling an overflow. Give up. */\n            Py_FatalError(\"Cannot recover from stack overflow.\");\n        }\n    }\n    else {\n        if (tstate->c_recursion_remaining <= 0) {\n            tstate->recursion_headroom++;\n            _PyErr_Format(tstate, PyExc_RecursionError,\n                        \"maximum recursion depth exceeded%s\",\n                        where);\n            tstate->recursion_headroom--;\n            ++tstate->c_recursion_remaining;\n            return -1;\n        }\n    }\n    return 0;\n}\n\n\nconst binaryfunc _PyEval_BinaryOps[] = {\n    [NB_ADD] = PyNumber_Add,\n    [NB_AND] = PyNumber_And,\n    [NB_FLOOR_DIVIDE] = PyNumber_FloorDivide,\n    [NB_LSHIFT] = PyNumber_Lshift,\n    [NB_MATRIX_MULTIPLY] = PyNumber_MatrixMultiply,\n    [NB_MULTIPLY] = PyNumber_Multiply,\n    [NB_REMAINDER] = PyNumber_Remainder,\n    [NB_OR] = PyNumber_Or,\n    [NB_POWER] = _PyNumber_PowerNoMod,\n    [NB_RSHIFT] = PyNumber_Rshift,\n    [NB_SUBTRACT] = PyNumber_Subtract,\n    [NB_TRUE_DIVIDE] = PyNumber_TrueDivide,\n    [NB_XOR] = PyNumber_Xor,\n    [NB_INPLACE_ADD] = PyNumber_InPlaceAdd,\n    [NB_INPLACE_AND] = PyNumber_InPlaceAnd,\n    [NB_INPLACE_FLOOR_DIVIDE] = PyNumber_InPlaceFloorDivide,\n    [NB_INPLACE_LSHIFT] = PyNumber_InPlaceLshift,\n    [NB_INPLACE_MATRIX_MULTIPLY] = PyNumber_InPlaceMatrixMultiply,\n    [NB_INPLACE_MULTIPLY] = PyNumber_InPlaceMultiply,\n    [NB_INPLACE_REMAINDER] = PyNumber_InPlaceRemainder,\n    [NB_INPLACE_OR] = PyNumber_InPlaceOr,\n    [NB_INPLACE_POWER] = _PyNumber_InPlacePowerNoMod,\n    [NB_INPLACE_RSHIFT] = PyNumber_InPlaceRshift,\n    [NB_INPLACE_SUBTRACT] = PyNumber_InPlaceSubtract,\n    [NB_INPLACE_TRUE_DIVIDE] = PyNumber_InPlaceTrueDivide,\n    [NB_INPLACE_XOR] = PyNumber_InPlaceXor,\n};\n\nconst conversion_func _PyEval_ConversionFuncs[4] = {\n    [FVC_STR] = PyObject_Str,\n    [FVC_REPR] = PyObject_Repr,\n    [FVC_ASCII] = PyObject_ASCII\n};\n\n\n// PEP 634: Structural Pattern Matching\n\n\n// Return a tuple of values corresponding to keys, with error checks for\n// duplicate/missing keys.\nPyObject *\n_PyEval_MatchKeys(PyThreadState *tstate, PyObject *map, PyObject *keys)\n{\n    assert(PyTuple_CheckExact(keys));\n    Py_ssize_t nkeys = PyTuple_GET_SIZE(keys);\n    if (!nkeys) {\n        // No keys means no items.\n        return PyTuple_New(0);\n    }\n    PyObject *seen = NULL;\n    PyObject *dummy = NULL;\n    PyObject *values = NULL;\n    PyObject *get = NULL;\n    // We use the two argument form of map.get(key, default) for two reasons:\n    // - Atomically check for a key and get its value without error handling.\n    // - Don't cause key creation or resizing in dict subclasses like\n    //   collections.defaultdict that define __missing__ (or similar).\n    int meth_found = _PyObject_GetMethod(map, &_Py_ID(get), &get);\n    if (get == NULL) {\n        goto fail;\n    }\n    seen = PySet_New(NULL);\n    if (seen == NULL) {\n        goto fail;\n    }\n    // dummy = object()\n    dummy = _PyObject_CallNoArgs((PyObject *)&PyBaseObject_Type);\n    if (dummy == NULL) {\n        goto fail;\n    }\n    values = PyTuple_New(nkeys);\n    if (values == NULL) {\n        goto fail;\n    }\n    for (Py_ssize_t i = 0; i < nkeys; i++) {\n        PyObject *key = PyTuple_GET_ITEM(keys, i);\n        if (PySet_Contains(seen, key) || PySet_Add(seen, key)) {\n            if (!_PyErr_Occurred(tstate)) {\n                // Seen it before!\n                _PyErr_Format(tstate, PyExc_ValueError,\n                              \"mapping pattern checks duplicate key (%R)\", key);\n            }\n            goto fail;\n        }\n        PyObject *args[] = { map, key, dummy };\n        PyObject *value = NULL;\n        if (meth_found) {\n            value = PyObject_Vectorcall(get, args, 3, NULL);\n        }\n        else {\n            value = PyObject_Vectorcall(get, &args[1], 2, NULL);\n        }\n        if (value == NULL) {\n            goto fail;\n        }\n        if (value == dummy) {\n            // key not in map!\n            Py_DECREF(value);\n            Py_DECREF(values);\n            // Return None:\n            values = Py_NewRef(Py_None);\n            goto done;\n        }\n        PyTuple_SET_ITEM(values, i, value);\n    }\n    // Success:\ndone:\n    Py_DECREF(get);\n    Py_DECREF(seen);\n    Py_DECREF(dummy);\n    return values;\nfail:\n    Py_XDECREF(get);\n    Py_XDECREF(seen);\n    Py_XDECREF(dummy);\n    Py_XDECREF(values);\n    return NULL;\n}\n\n// Extract a named attribute from the subject, with additional bookkeeping to\n// raise TypeErrors for repeated lookups. On failure, return NULL (with no\n// error set). Use _PyErr_Occurred(tstate) to disambiguate.\nstatic PyObject *\nmatch_class_attr(PyThreadState *tstate, PyObject *subject, PyObject *type,\n                 PyObject *name, PyObject *seen)\n{\n    assert(PyUnicode_CheckExact(name));\n    assert(PySet_CheckExact(seen));\n    if (PySet_Contains(seen, name) || PySet_Add(seen, name)) {\n        if (!_PyErr_Occurred(tstate)) {\n            // Seen it before!\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"%s() got multiple sub-patterns for attribute %R\",\n                          ((PyTypeObject*)type)->tp_name, name);\n        }\n        return NULL;\n    }\n    PyObject *attr;\n    (void)PyObject_GetOptionalAttr(subject, name, &attr);\n    return attr;\n}\n\n// On success (match), return a tuple of extracted attributes. On failure (no\n// match), return NULL. Use _PyErr_Occurred(tstate) to disambiguate.\nPyObject*\n_PyEval_MatchClass(PyThreadState *tstate, PyObject *subject, PyObject *type,\n                   Py_ssize_t nargs, PyObject *kwargs)\n{\n    if (!PyType_Check(type)) {\n        const char *e = \"called match pattern must be a class\";\n        _PyErr_Format(tstate, PyExc_TypeError, e);\n        return NULL;\n    }\n    assert(PyTuple_CheckExact(kwargs));\n    // First, an isinstance check:\n    if (PyObject_IsInstance(subject, type) <= 0) {\n        return NULL;\n    }\n    // So far so good:\n    PyObject *seen = PySet_New(NULL);\n    if (seen == NULL) {\n        return NULL;\n    }\n    PyObject *attrs = PyList_New(0);\n    if (attrs == NULL) {\n        Py_DECREF(seen);\n        return NULL;\n    }\n    // NOTE: From this point on, goto fail on failure:\n    PyObject *match_args = NULL;\n    // First, the positional subpatterns:\n    if (nargs) {\n        int match_self = 0;\n        if (PyObject_GetOptionalAttr(type, &_Py_ID(__match_args__), &match_args) < 0) {\n            goto fail;\n        }\n        if (match_args) {\n            if (!PyTuple_CheckExact(match_args)) {\n                const char *e = \"%s.__match_args__ must be a tuple (got %s)\";\n                _PyErr_Format(tstate, PyExc_TypeError, e,\n                              ((PyTypeObject *)type)->tp_name,\n                              Py_TYPE(match_args)->tp_name);\n                goto fail;\n            }\n        }\n        else {\n            // _Py_TPFLAGS_MATCH_SELF is only acknowledged if the type does not\n            // define __match_args__. This is natural behavior for subclasses:\n            // it's as if __match_args__ is some \"magic\" value that is lost as\n            // soon as they redefine it.\n            match_args = PyTuple_New(0);\n            match_self = PyType_HasFeature((PyTypeObject*)type,\n                                            _Py_TPFLAGS_MATCH_SELF);\n        }\n        assert(PyTuple_CheckExact(match_args));\n        Py_ssize_t allowed = match_self ? 1 : PyTuple_GET_SIZE(match_args);\n        if (allowed < nargs) {\n            const char *plural = (allowed == 1) ? \"\" : \"s\";\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"%s() accepts %d positional sub-pattern%s (%d given)\",\n                          ((PyTypeObject*)type)->tp_name,\n                          allowed, plural, nargs);\n            goto fail;\n        }\n        if (match_self) {\n            // Easy. Copy the subject itself, and move on to kwargs.\n            if (PyList_Append(attrs, subject) < 0) {\n                goto fail;\n            }\n        }\n        else {\n            for (Py_ssize_t i = 0; i < nargs; i++) {\n                PyObject *name = PyTuple_GET_ITEM(match_args, i);\n                if (!PyUnicode_CheckExact(name)) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"__match_args__ elements must be strings \"\n                                  \"(got %s)\", Py_TYPE(name)->tp_name);\n                    goto fail;\n                }\n                PyObject *attr = match_class_attr(tstate, subject, type, name,\n                                                  seen);\n                if (attr == NULL) {\n                    goto fail;\n                }\n                if (PyList_Append(attrs, attr) < 0) {\n                    Py_DECREF(attr);\n                    goto fail;\n                }\n                Py_DECREF(attr);\n            }\n        }\n        Py_CLEAR(match_args);\n    }\n    // Finally, the keyword subpatterns:\n    for (Py_ssize_t i = 0; i < PyTuple_GET_SIZE(kwargs); i++) {\n        PyObject *name = PyTuple_GET_ITEM(kwargs, i);\n        PyObject *attr = match_class_attr(tstate, subject, type, name, seen);\n        if (attr == NULL) {\n            goto fail;\n        }\n        if (PyList_Append(attrs, attr) < 0) {\n            Py_DECREF(attr);\n            goto fail;\n        }\n        Py_DECREF(attr);\n    }\n    Py_SETREF(attrs, PyList_AsTuple(attrs));\n    Py_DECREF(seen);\n    return attrs;\nfail:\n    // We really don't care whether an error was raised or not... that's our\n    // caller's problem. All we know is that the match failed.\n    Py_XDECREF(match_args);\n    Py_DECREF(seen);\n    Py_DECREF(attrs);\n    return NULL;\n}\n\n\nstatic int do_raise(PyThreadState *tstate, PyObject *exc, PyObject *cause);\n\nPyObject *\nPyEval_EvalCode(PyObject *co, PyObject *globals, PyObject *locals)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (locals == NULL) {\n        locals = globals;\n    }\n    PyObject *builtins = _PyEval_BuiltinsFromGlobals(tstate, globals); // borrowed ref\n    if (builtins == NULL) {\n        return NULL;\n    }\n    PyFrameConstructor desc = {\n        .fc_globals = globals,\n        .fc_builtins = builtins,\n        .fc_name = ((PyCodeObject *)co)->co_name,\n        .fc_qualname = ((PyCodeObject *)co)->co_name,\n        .fc_code = co,\n        .fc_defaults = NULL,\n        .fc_kwdefaults = NULL,\n        .fc_closure = NULL\n    };\n    PyFunctionObject *func = _PyFunction_FromConstructor(&desc);\n    if (func == NULL) {\n        return NULL;\n    }\n    EVAL_CALL_STAT_INC(EVAL_CALL_LEGACY);\n    PyObject *res = _PyEval_Vector(tstate, func, locals, NULL, 0, NULL);\n    Py_DECREF(func);\n    return res;\n}\n\n\n/* Interpreter main loop */\n\nPyObject *\nPyEval_EvalFrame(PyFrameObject *f)\n{\n    /* Function kept for backward compatibility */\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _PyEval_EvalFrame(tstate, f->f_frame, 0);\n}\n\nPyObject *\nPyEval_EvalFrameEx(PyFrameObject *f, int throwflag)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _PyEval_EvalFrame(tstate, f->f_frame, throwflag);\n}\n\n#include \"ceval_macros.h\"\n\nint _Py_CheckRecursiveCallPy(\n    PyThreadState *tstate)\n{\n    if (tstate->recursion_headroom) {\n        if (tstate->py_recursion_remaining < -50) {\n            /* Overflowing while handling an overflow. Give up. */\n            Py_FatalError(\"Cannot recover from Python stack overflow.\");\n        }\n    }\n    else {\n        if (tstate->py_recursion_remaining <= 0) {\n            tstate->recursion_headroom++;\n            _PyErr_Format(tstate, PyExc_RecursionError,\n                        \"maximum recursion depth exceeded\");\n            tstate->recursion_headroom--;\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic const _Py_CODEUNIT _Py_INTERPRETER_TRAMPOLINE_INSTRUCTIONS[] = {\n    /* Put a NOP at the start, so that the IP points into\n    * the code, rather than before it */\n    { .op.code = NOP, .op.arg = 0 },\n    { .op.code = INTERPRETER_EXIT, .op.arg = 0 },  /* reached on return */\n    { .op.code = NOP, .op.arg = 0 },\n    { .op.code = INTERPRETER_EXIT, .op.arg = 0 },  /* reached on yield */\n    { .op.code = RESUME, .op.arg = RESUME_OPARG_DEPTH1_MASK | RESUME_AT_FUNC_START }\n};\n\nextern const struct _PyCode_DEF(8) _Py_InitCleanup;\n\n#ifdef Py_DEBUG\nextern void _PyUOpPrint(const _PyUOpInstruction *uop);\n#endif\n\n\n/* Disable unused label warnings.  They are handy for debugging, even\n   if computed gotos aren't used. */\n\n/* TBD - what about other compilers? */\n#if defined(__GNUC__)\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wunused-label\"\n#elif defined(_MSC_VER) /* MS_WINDOWS */\n#  pragma warning(push)\n#  pragma warning(disable:4102)\n#endif\n\n\n/* _PyEval_EvalFrameDefault() is a *big* function,\n * so consume 3 units of C stack */\n#define PY_EVAL_C_STACK_UNITS 2\n\nPyObject* _Py_HOT_FUNCTION\n_PyEval_EvalFrameDefault(PyThreadState *tstate, _PyInterpreterFrame *frame, int throwflag)\n{\n    _Py_EnsureTstateNotNULL(tstate);\n    CALL_STAT_INC(pyeval_calls);\n\n#if USE_COMPUTED_GOTOS\n/* Import the static jump table */\n#include \"opcode_targets.h\"\n#endif\n\n#ifdef Py_STATS\n    int lastopcode = 0;\n#endif\n    uint8_t opcode;    /* Current opcode */\n    int oparg;         /* Current opcode argument, if any */\n#ifdef LLTRACE\n    int lltrace = 0;\n#endif\n\n    _PyInterpreterFrame  entry_frame;\n\n\n\n#ifdef Py_DEBUG\n    /* Set these to invalid but identifiable values for debugging. */\n    entry_frame.f_funcobj = (PyObject*)0xaaa0;\n    entry_frame.f_locals = (PyObject*)0xaaa1;\n    entry_frame.frame_obj = (PyFrameObject*)0xaaa2;\n    entry_frame.f_globals = (PyObject*)0xaaa3;\n    entry_frame.f_builtins = (PyObject*)0xaaa4;\n#endif\n    entry_frame.f_executable = Py_None;\n    entry_frame.instr_ptr = (_Py_CODEUNIT *)_Py_INTERPRETER_TRAMPOLINE_INSTRUCTIONS + 1;\n    entry_frame.stacktop = 0;\n    entry_frame.owner = FRAME_OWNED_BY_CSTACK;\n    entry_frame.return_offset = 0;\n    /* Push frame */\n    entry_frame.previous = tstate->current_frame;\n    frame->previous = &entry_frame;\n    tstate->current_frame = frame;\n\n    tstate->c_recursion_remaining -= (PY_EVAL_C_STACK_UNITS - 1);\n    if (_Py_EnterRecursiveCallTstate(tstate, \"\")) {\n        tstate->c_recursion_remaining--;\n        tstate->py_recursion_remaining--;\n        goto exit_unwind;\n    }\n\n    /* support for generator.throw() */\n    if (throwflag) {\n        if (_Py_EnterRecursivePy(tstate)) {\n            goto exit_unwind;\n        }\n        /* Because this avoids the RESUME,\n         * we need to update instrumentation */\n        _Py_Instrument(_PyFrame_GetCode(frame), tstate->interp);\n        monitor_throw(tstate, frame, frame->instr_ptr);\n        /* TO DO -- Monitor throw entry. */\n        goto resume_with_error;\n    }\n\n    /* Local \"register\" variables.\n     * These are cached values from the frame and code object.  */\n    _Py_CODEUNIT *next_instr;\n    PyObject **stack_pointer;\n\n#if defined(_Py_TIER2) && !defined(_Py_JIT)\n    /* Tier 2 interpreter state */\n    _PyExecutorObject *current_executor = NULL;\n    const _PyUOpInstruction *next_uop = NULL;\n#endif\n\nstart_frame:\n    if (_Py_EnterRecursivePy(tstate)) {\n        goto exit_unwind;\n    }\n\n    next_instr = frame->instr_ptr;\nresume_frame:\n    stack_pointer = _PyFrame_GetStackPointer(frame);\n\n#ifdef LLTRACE\n    lltrace = maybe_lltrace_resume_frame(frame, &entry_frame, GLOBALS());\n    if (lltrace < 0) {\n        goto exit_unwind;\n    }\n#endif\n\n#ifdef Py_DEBUG\n    /* _PyEval_EvalFrameDefault() must not be called with an exception set,\n       because it can clear it (directly or indirectly) and so the\n       caller loses its exception */\n    assert(!_PyErr_Occurred(tstate));\n#endif\n\n    DISPATCH();\n\n    {\n    /* Start instructions */\n#if !USE_COMPUTED_GOTOS\n    dispatch_opcode:\n        switch (opcode)\n#endif\n        {\n\n#include \"generated_cases.c.h\"\n\n    /* INSTRUMENTED_LINE has to be here, rather than in bytecodes.c,\n     * because it needs to capture frame->instr_ptr before it is updated,\n     * as happens in the standard instruction prologue.\n     */\n#if USE_COMPUTED_GOTOS\n        TARGET_INSTRUMENTED_LINE:\n#else\n        case INSTRUMENTED_LINE:\n#endif\n    {\n        _Py_CODEUNIT *prev = frame->instr_ptr;\n        _Py_CODEUNIT *here = frame->instr_ptr = next_instr;\n        int original_opcode = 0;\n        if (tstate->tracing) {\n            PyCodeObject *code = _PyFrame_GetCode(frame);\n            original_opcode = code->_co_monitoring->lines[(int)(here - _PyCode_CODE(code))].original_opcode;\n        } else {\n            _PyFrame_SetStackPointer(frame, stack_pointer);\n            original_opcode = _Py_call_instrumentation_line(\n                    tstate, frame, here, prev);\n            stack_pointer = _PyFrame_GetStackPointer(frame);\n            if (original_opcode < 0) {\n                next_instr = here+1;\n                goto error;\n            }\n            next_instr = frame->instr_ptr;\n            if (next_instr != here) {\n                DISPATCH();\n            }\n        }\n        if (_PyOpcode_Caches[original_opcode]) {\n            _PyBinaryOpCache *cache = (_PyBinaryOpCache *)(next_instr+1);\n            /* Prevent the underlying instruction from specializing\n             * and overwriting the instrumentation. */\n            PAUSE_ADAPTIVE_COUNTER(cache->counter);\n        }\n        opcode = original_opcode;\n        DISPATCH_GOTO();\n    }\n\n\n#if USE_COMPUTED_GOTOS\n        _unknown_opcode:\n#else\n        EXTRA_CASES  // From pycore_opcode_metadata.h, a 'case' for each unused opcode\n#endif\n            /* Tell C compilers not to hold the opcode variable in the loop.\n               next_instr points the current instruction without TARGET(). */\n            opcode = next_instr->op.code;\n            _PyErr_Format(tstate, PyExc_SystemError,\n                          \"%U:%d: unknown opcode %d\",\n                          _PyFrame_GetCode(frame)->co_filename,\n                          PyUnstable_InterpreterFrame_GetLine(frame),\n                          opcode);\n            goto error;\n\n        } /* End instructions */\n\n        /* This should never be reached. Every opcode should end with DISPATCH()\n           or goto error. */\n        Py_UNREACHABLE();\n\npop_4_error:\n    STACK_SHRINK(1);\npop_3_error:\n    STACK_SHRINK(1);\npop_2_error:\n    STACK_SHRINK(1);\npop_1_error:\n    STACK_SHRINK(1);\nerror:\n        /* Double-check exception status. */\n#ifdef NDEBUG\n        if (!_PyErr_Occurred(tstate)) {\n            _PyErr_SetString(tstate, PyExc_SystemError,\n                             \"error return without exception set\");\n        }\n#else\n        assert(_PyErr_Occurred(tstate));\n#endif\n\n        /* Log traceback info. */\n        assert(frame != &entry_frame);\n        if (!_PyFrame_IsIncomplete(frame)) {\n            PyFrameObject *f = _PyFrame_GetFrameObject(frame);\n            if (f != NULL) {\n                PyTraceBack_Here(f);\n            }\n        }\n        monitor_raise(tstate, frame, next_instr-1);\nexception_unwind:\n        {\n            /* We can't use frame->instr_ptr here, as RERAISE may have set it */\n            int offset = INSTR_OFFSET()-1;\n            int level, handler, lasti;\n            if (get_exception_handler(_PyFrame_GetCode(frame), offset, &level, &handler, &lasti) == 0) {\n                // No handlers, so exit.\n                assert(_PyErr_Occurred(tstate));\n\n                /* Pop remaining stack entries. */\n                PyObject **stackbase = _PyFrame_Stackbase(frame);\n                while (stack_pointer > stackbase) {\n                    PyObject *o = POP();\n                    Py_XDECREF(o);\n                }\n                assert(STACK_LEVEL() == 0);\n                _PyFrame_SetStackPointer(frame, stack_pointer);\n                monitor_unwind(tstate, frame, next_instr-1);\n                goto exit_unwind;\n            }\n\n            assert(STACK_LEVEL() >= level);\n            PyObject **new_top = _PyFrame_Stackbase(frame) + level;\n            while (stack_pointer > new_top) {\n                PyObject *v = POP();\n                Py_XDECREF(v);\n            }\n            if (lasti) {\n                int frame_lasti = _PyInterpreterFrame_LASTI(frame);\n                PyObject *lasti = PyLong_FromLong(frame_lasti);\n                if (lasti == NULL) {\n                    goto exception_unwind;\n                }\n                PUSH(lasti);\n            }\n\n            /* Make the raw exception data\n                available to the handler,\n                so a program can emulate the\n                Python main loop. */\n            PyObject *exc = _PyErr_GetRaisedException(tstate);\n            PUSH(exc);\n            next_instr = _PyCode_CODE(_PyFrame_GetCode(frame)) + handler;\n\n            if (monitor_handled(tstate, frame, next_instr, exc) < 0) {\n                goto exception_unwind;\n            }\n            /* Resume normal execution */\n#ifdef LLTRACE\n            if (lltrace >= 5) {\n                lltrace_resume_frame(frame);\n            }\n#endif\n            DISPATCH();\n        }\n    }\n\nexit_unwind:\n    assert(_PyErr_Occurred(tstate));\n    _Py_LeaveRecursiveCallPy(tstate);\n    assert(frame != &entry_frame);\n    // GH-99729: We need to unlink the frame *before* clearing it:\n    _PyInterpreterFrame *dying = frame;\n    frame = tstate->current_frame = dying->previous;\n    _PyEval_FrameClearAndPop(tstate, dying);\n    frame->return_offset = 0;\n    if (frame == &entry_frame) {\n        /* Restore previous frame and exit */\n        tstate->current_frame = frame->previous;\n        tstate->c_recursion_remaining += PY_EVAL_C_STACK_UNITS;\n        return NULL;\n    }\n\nresume_with_error:\n    next_instr = frame->instr_ptr;\n    stack_pointer = _PyFrame_GetStackPointer(frame);\n    goto error;\n\n\n#ifdef _Py_TIER2\n\n// Tier 2 is also here!\nenter_tier_two:\n\n#ifdef _Py_JIT\n    assert(0);\n#else\n\n#undef LOAD_IP\n#define LOAD_IP(UNUSED) (void)0\n\n#undef GOTO_ERROR\n#define GOTO_ERROR(LABEL) goto LABEL ## _tier_two\n\n#ifdef Py_STATS\n// Disable these macros that apply to Tier 1 stats when we are in Tier 2\n#undef STAT_INC\n#define STAT_INC(opname, name) ((void)0)\n#undef STAT_DEC\n#define STAT_DEC(opname, name) ((void)0)\n#endif\n\n#undef ENABLE_SPECIALIZATION\n#define ENABLE_SPECIALIZATION 0\n\n#ifdef Py_DEBUG\n    #define DPRINTF(level, ...) \\\n        if (lltrace >= (level)) { printf(__VA_ARGS__); }\n#else\n    #define DPRINTF(level, ...)\n#endif\n\n    ; // dummy statement after a label, before a declaration\n    uint16_t uopcode;\n#ifdef Py_STATS\n    int lastuop = 0;\n    uint64_t trace_uop_execution_counter = 0;\n#endif\n\n    assert(next_uop->opcode == _START_EXECUTOR || next_uop->opcode == _COLD_EXIT);\ntier2_dispatch:\n    for (;;) {\n        uopcode = next_uop->opcode;\n#ifdef Py_DEBUG\n        if (lltrace >= 3) {\n            if (next_uop->opcode == _START_EXECUTOR || next_uop->opcode == _COLD_EXIT) {\n                printf(\"%4d uop: \", 0);\n            }\n            else {\n                printf(\"%4d uop: \", (int)(next_uop - current_executor->trace));\n            }\n            _PyUOpPrint(next_uop);\n            printf(\" stack_level=%d\\n\",\n                (int)(stack_pointer - _PyFrame_Stackbase(frame)));\n        }\n#endif\n        next_uop++;\n        OPT_STAT_INC(uops_executed);\n        UOP_STAT_INC(uopcode, execution_count);\n        UOP_PAIR_INC(uopcode, lastuop);\n#ifdef Py_STATS\n        trace_uop_execution_counter++;\n#endif\n\n        switch (uopcode) {\n\n#include \"executor_cases.c.h\"\n\n            default:\n#ifdef Py_DEBUG\n            {\n                printf(\"Unknown uop: \");\n                _PyUOpPrint(&next_uop[-1]);\n                printf(\" @ %d\\n\", (int)(next_uop - current_executor->trace - 1));\n                Py_FatalError(\"Unknown uop\");\n            }\n#else\n            Py_UNREACHABLE();\n#endif\n\n        }\n    }\n\njump_to_error_target:\n#ifdef Py_DEBUG\n    if (lltrace >= 2) {\n        printf(\"Error: [UOp \");\n        _PyUOpPrint(&next_uop[-1]);\n        printf(\" @ %d -> %s]\\n\",\n               (int)(next_uop - current_executor->trace - 1),\n               _PyOpcode_OpName[frame->instr_ptr->op.code]);\n    }\n#endif\n    assert (next_uop[-1].format == UOP_FORMAT_JUMP);\n    uint16_t target = uop_get_error_target(&next_uop[-1]);\n    next_uop = current_executor->trace + target;\n    goto tier2_dispatch;\n\nerror_tier_two:\n    OPT_HIST(trace_uop_execution_counter, trace_run_length_hist);\n    assert(next_uop[-1].format == UOP_FORMAT_TARGET);\n    frame->return_offset = 0;  // Don't leave this random\n    _PyFrame_SetStackPointer(frame, stack_pointer);\n    Py_DECREF(current_executor);\n    tstate->previous_executor = NULL;\n    goto resume_with_error;\n\njump_to_jump_target:\n    assert(next_uop[-1].format == UOP_FORMAT_JUMP);\n    target = uop_get_jump_target(&next_uop[-1]);\n    next_uop = current_executor->trace + target;\n    goto tier2_dispatch;\n\nexit_to_tier1_dynamic:\n    next_instr = frame->instr_ptr;\n    goto goto_to_tier1;\nexit_to_tier1:\n    assert(next_uop[-1].format == UOP_FORMAT_TARGET);\n    next_instr = next_uop[-1].target + _PyCode_CODE(_PyFrame_GetCode(frame));\ngoto_to_tier1:\n#ifdef Py_DEBUG\n    if (lltrace >= 2) {\n        printf(\"DEOPT: [UOp \");\n        _PyUOpPrint(&next_uop[-1]);\n        printf(\" -> %s]\\n\",\n               _PyOpcode_OpName[next_instr->op.code]);\n    }\n#endif\n    OPT_HIST(trace_uop_execution_counter, trace_run_length_hist);\n    Py_DECREF(current_executor);\n    tstate->previous_executor = NULL;\n    DISPATCH();\n\nexit_to_trace:\n    assert(next_uop[-1].format == UOP_FORMAT_EXIT);\n    OPT_HIST(trace_uop_execution_counter, trace_run_length_hist);\n    uint32_t exit_index = next_uop[-1].exit_index;\n    assert(exit_index < current_executor->exit_count);\n    _PyExitData *exit = &current_executor->exits[exit_index];\n#ifdef Py_DEBUG\n    if (lltrace >= 2) {\n        printf(\"SIDE EXIT: [UOp \");\n        _PyUOpPrint(&next_uop[-1]);\n        printf(\", exit %u, temp %d, target %d -> %s]\\n\",\n               exit_index, exit->temperature.as_counter, exit->target,\n               _PyOpcode_OpName[_PyCode_CODE(_PyFrame_GetCode(frame))[exit->target].op.code]);\n    }\n#endif\n    Py_INCREF(exit->executor);\n    tstate->previous_executor = (PyObject *)current_executor;\n    GOTO_TIER_TWO(exit->executor);\n\n#endif  // _Py_JIT\n\n#endif // _Py_TIER2\n\n}\n\n#if defined(__GNUC__)\n#  pragma GCC diagnostic pop\n#elif defined(_MSC_VER) /* MS_WINDOWS */\n#  pragma warning(pop)\n#endif\n\nstatic void\nformat_missing(PyThreadState *tstate, const char *kind,\n               PyCodeObject *co, PyObject *names, PyObject *qualname)\n{\n    int err;\n    Py_ssize_t len = PyList_GET_SIZE(names);\n    PyObject *name_str, *comma, *tail, *tmp;\n\n    assert(PyList_CheckExact(names));\n    assert(len >= 1);\n    /* Deal with the joys of natural language. */\n    switch (len) {\n    case 1:\n        name_str = PyList_GET_ITEM(names, 0);\n        Py_INCREF(name_str);\n        break;\n    case 2:\n        name_str = PyUnicode_FromFormat(\"%U and %U\",\n                                        PyList_GET_ITEM(names, len - 2),\n                                        PyList_GET_ITEM(names, len - 1));\n        break;\n    default:\n        tail = PyUnicode_FromFormat(\", %U, and %U\",\n                                    PyList_GET_ITEM(names, len - 2),\n                                    PyList_GET_ITEM(names, len - 1));\n        if (tail == NULL)\n            return;\n        /* Chop off the last two objects in the list. This shouldn't actually\n           fail, but we can't be too careful. */\n        err = PyList_SetSlice(names, len - 2, len, NULL);\n        if (err == -1) {\n            Py_DECREF(tail);\n            return;\n        }\n        /* Stitch everything up into a nice comma-separated list. */\n        comma = PyUnicode_FromString(\", \");\n        if (comma == NULL) {\n            Py_DECREF(tail);\n            return;\n        }\n        tmp = PyUnicode_Join(comma, names);\n        Py_DECREF(comma);\n        if (tmp == NULL) {\n            Py_DECREF(tail);\n            return;\n        }\n        name_str = PyUnicode_Concat(tmp, tail);\n        Py_DECREF(tmp);\n        Py_DECREF(tail);\n        break;\n    }\n    if (name_str == NULL)\n        return;\n    _PyErr_Format(tstate, PyExc_TypeError,\n                  \"%U() missing %i required %s argument%s: %U\",\n                  qualname,\n                  len,\n                  kind,\n                  len == 1 ? \"\" : \"s\",\n                  name_str);\n    Py_DECREF(name_str);\n}\n\nstatic void\nmissing_arguments(PyThreadState *tstate, PyCodeObject *co,\n                  Py_ssize_t missing, Py_ssize_t defcount,\n                  PyObject **localsplus, PyObject *qualname)\n{\n    Py_ssize_t i, j = 0;\n    Py_ssize_t start, end;\n    int positional = (defcount != -1);\n    const char *kind = positional ? \"positional\" : \"keyword-only\";\n    PyObject *missing_names;\n\n    /* Compute the names of the arguments that are missing. */\n    missing_names = PyList_New(missing);\n    if (missing_names == NULL)\n        return;\n    if (positional) {\n        start = 0;\n        end = co->co_argcount - defcount;\n    }\n    else {\n        start = co->co_argcount;\n        end = start + co->co_kwonlyargcount;\n    }\n    for (i = start; i < end; i++) {\n        if (localsplus[i] == NULL) {\n            PyObject *raw = PyTuple_GET_ITEM(co->co_localsplusnames, i);\n            PyObject *name = PyObject_Repr(raw);\n            if (name == NULL) {\n                Py_DECREF(missing_names);\n                return;\n            }\n            PyList_SET_ITEM(missing_names, j++, name);\n        }\n    }\n    assert(j == missing);\n    format_missing(tstate, kind, co, missing_names, qualname);\n    Py_DECREF(missing_names);\n}\n\nstatic void\ntoo_many_positional(PyThreadState *tstate, PyCodeObject *co,\n                    Py_ssize_t given, PyObject *defaults,\n                    PyObject **localsplus, PyObject *qualname)\n{\n    int plural;\n    Py_ssize_t kwonly_given = 0;\n    Py_ssize_t i;\n    PyObject *sig, *kwonly_sig;\n    Py_ssize_t co_argcount = co->co_argcount;\n\n    assert((co->co_flags & CO_VARARGS) == 0);\n    /* Count missing keyword-only args. */\n    for (i = co_argcount; i < co_argcount + co->co_kwonlyargcount; i++) {\n        if (localsplus[i] != NULL) {\n            kwonly_given++;\n        }\n    }\n    Py_ssize_t defcount = defaults == NULL ? 0 : PyTuple_GET_SIZE(defaults);\n    if (defcount) {\n        Py_ssize_t atleast = co_argcount - defcount;\n        plural = 1;\n        sig = PyUnicode_FromFormat(\"from %zd to %zd\", atleast, co_argcount);\n    }\n    else {\n        plural = (co_argcount != 1);\n        sig = PyUnicode_FromFormat(\"%zd\", co_argcount);\n    }\n    if (sig == NULL)\n        return;\n    if (kwonly_given) {\n        const char *format = \" positional argument%s (and %zd keyword-only argument%s)\";\n        kwonly_sig = PyUnicode_FromFormat(format,\n                                          given != 1 ? \"s\" : \"\",\n                                          kwonly_given,\n                                          kwonly_given != 1 ? \"s\" : \"\");\n        if (kwonly_sig == NULL) {\n            Py_DECREF(sig);\n            return;\n        }\n    }\n    else {\n        /* This will not fail. */\n        kwonly_sig = PyUnicode_FromString(\"\");\n        assert(kwonly_sig != NULL);\n    }\n    _PyErr_Format(tstate, PyExc_TypeError,\n                  \"%U() takes %U positional argument%s but %zd%U %s given\",\n                  qualname,\n                  sig,\n                  plural ? \"s\" : \"\",\n                  given,\n                  kwonly_sig,\n                  given == 1 && !kwonly_given ? \"was\" : \"were\");\n    Py_DECREF(sig);\n    Py_DECREF(kwonly_sig);\n}\n\nstatic int\npositional_only_passed_as_keyword(PyThreadState *tstate, PyCodeObject *co,\n                                  Py_ssize_t kwcount, PyObject* kwnames,\n                                  PyObject *qualname)\n{\n    int posonly_conflicts = 0;\n    PyObject* posonly_names = PyList_New(0);\n    if (posonly_names == NULL) {\n        goto fail;\n    }\n    for(int k=0; k < co->co_posonlyargcount; k++){\n        PyObject* posonly_name = PyTuple_GET_ITEM(co->co_localsplusnames, k);\n\n        for (int k2=0; k2<kwcount; k2++){\n            /* Compare the pointers first and fallback to PyObject_RichCompareBool*/\n            PyObject* kwname = PyTuple_GET_ITEM(kwnames, k2);\n            if (kwname == posonly_name){\n                if(PyList_Append(posonly_names, kwname) != 0) {\n                    goto fail;\n                }\n                posonly_conflicts++;\n                continue;\n            }\n\n            int cmp = PyObject_RichCompareBool(posonly_name, kwname, Py_EQ);\n\n            if ( cmp > 0) {\n                if(PyList_Append(posonly_names, kwname) != 0) {\n                    goto fail;\n                }\n                posonly_conflicts++;\n            } else if (cmp < 0) {\n                goto fail;\n            }\n\n        }\n    }\n    if (posonly_conflicts) {\n        PyObject* comma = PyUnicode_FromString(\", \");\n        if (comma == NULL) {\n            goto fail;\n        }\n        PyObject* error_names = PyUnicode_Join(comma, posonly_names);\n        Py_DECREF(comma);\n        if (error_names == NULL) {\n            goto fail;\n        }\n        _PyErr_Format(tstate, PyExc_TypeError,\n                      \"%U() got some positional-only arguments passed\"\n                      \" as keyword arguments: '%U'\",\n                      qualname, error_names);\n        Py_DECREF(error_names);\n        goto fail;\n    }\n\n    Py_DECREF(posonly_names);\n    return 0;\n\nfail:\n    Py_XDECREF(posonly_names);\n    return 1;\n\n}\n\n\nstatic inline unsigned char *\nscan_back_to_entry_start(unsigned char *p) {\n    for (; (p[0]&128) == 0; p--);\n    return p;\n}\n\nstatic inline unsigned char *\nskip_to_next_entry(unsigned char *p, unsigned char *end) {\n    while (p < end && ((p[0] & 128) == 0)) {\n        p++;\n    }\n    return p;\n}\n\n\n#define MAX_LINEAR_SEARCH 40\n\nstatic int\nget_exception_handler(PyCodeObject *code, int index, int *level, int *handler, int *lasti)\n{\n    unsigned char *start = (unsigned char *)PyBytes_AS_STRING(code->co_exceptiontable);\n    unsigned char *end = start + PyBytes_GET_SIZE(code->co_exceptiontable);\n    /* Invariants:\n     * start_table == end_table OR\n     * start_table points to a legal entry and end_table points\n     * beyond the table or to a legal entry that is after index.\n     */\n    if (end - start > MAX_LINEAR_SEARCH) {\n        int offset;\n        parse_varint(start, &offset);\n        if (offset > index) {\n            return 0;\n        }\n        do {\n            unsigned char * mid = start + ((end-start)>>1);\n            mid = scan_back_to_entry_start(mid);\n            parse_varint(mid, &offset);\n            if (offset > index) {\n                end = mid;\n            }\n            else {\n                start = mid;\n            }\n\n        } while (end - start > MAX_LINEAR_SEARCH);\n    }\n    unsigned char *scan = start;\n    while (scan < end) {\n        int start_offset, size;\n        scan = parse_varint(scan, &start_offset);\n        if (start_offset > index) {\n            break;\n        }\n        scan = parse_varint(scan, &size);\n        if (start_offset + size > index) {\n            scan = parse_varint(scan, handler);\n            int depth_and_lasti;\n            parse_varint(scan, &depth_and_lasti);\n            *level = depth_and_lasti >> 1;\n            *lasti = depth_and_lasti & 1;\n            return 1;\n        }\n        scan = skip_to_next_entry(scan, end);\n    }\n    return 0;\n}\n\nstatic int\ninitialize_locals(PyThreadState *tstate, PyFunctionObject *func,\n    PyObject **localsplus, PyObject *const *args,\n    Py_ssize_t argcount, PyObject *kwnames)\n{\n    PyCodeObject *co = (PyCodeObject*)func->func_code;\n    const Py_ssize_t total_args = co->co_argcount + co->co_kwonlyargcount;\n\n    /* Create a dictionary for keyword parameters (**kwags) */\n    PyObject *kwdict;\n    Py_ssize_t i;\n    if (co->co_flags & CO_VARKEYWORDS) {\n        kwdict = PyDict_New();\n        if (kwdict == NULL) {\n            goto fail_pre_positional;\n        }\n        i = total_args;\n        if (co->co_flags & CO_VARARGS) {\n            i++;\n        }\n        assert(localsplus[i] == NULL);\n        localsplus[i] = kwdict;\n    }\n    else {\n        kwdict = NULL;\n    }\n\n    /* Copy all positional arguments into local variables */\n    Py_ssize_t j, n;\n    if (argcount > co->co_argcount) {\n        n = co->co_argcount;\n    }\n    else {\n        n = argcount;\n    }\n    for (j = 0; j < n; j++) {\n        PyObject *x = args[j];\n        assert(localsplus[j] == NULL);\n        localsplus[j] = x;\n    }\n\n    /* Pack other positional arguments into the *args argument */\n    if (co->co_flags & CO_VARARGS) {\n        PyObject *u = NULL;\n        if (argcount == n) {\n            u = (PyObject *)&_Py_SINGLETON(tuple_empty);\n        }\n        else {\n            assert(args != NULL);\n            u = _PyTuple_FromArraySteal(args + n, argcount - n);\n        }\n        if (u == NULL) {\n            goto fail_post_positional;\n        }\n        assert(localsplus[total_args] == NULL);\n        localsplus[total_args] = u;\n    }\n    else if (argcount > n) {\n        /* Too many postional args. Error is reported later */\n        for (j = n; j < argcount; j++) {\n            Py_DECREF(args[j]);\n        }\n    }\n\n    /* Handle keyword arguments */\n    if (kwnames != NULL) {\n        Py_ssize_t kwcount = PyTuple_GET_SIZE(kwnames);\n        for (i = 0; i < kwcount; i++) {\n            PyObject **co_varnames;\n            PyObject *keyword = PyTuple_GET_ITEM(kwnames, i);\n            PyObject *value = args[i+argcount];\n            Py_ssize_t j;\n\n            if (keyword == NULL || !PyUnicode_Check(keyword)) {\n                _PyErr_Format(tstate, PyExc_TypeError,\n                            \"%U() keywords must be strings\",\n                          func->func_qualname);\n                goto kw_fail;\n            }\n\n            /* Speed hack: do raw pointer compares. As names are\n            normally interned this should almost always hit. */\n            co_varnames = ((PyTupleObject *)(co->co_localsplusnames))->ob_item;\n            for (j = co->co_posonlyargcount; j < total_args; j++) {\n                PyObject *varname = co_varnames[j];\n                if (varname == keyword) {\n                    goto kw_found;\n                }\n            }\n\n            /* Slow fallback, just in case */\n            for (j = co->co_posonlyargcount; j < total_args; j++) {\n                PyObject *varname = co_varnames[j];\n                int cmp = PyObject_RichCompareBool( keyword, varname, Py_EQ);\n                if (cmp > 0) {\n                    goto kw_found;\n                }\n                else if (cmp < 0) {\n                    goto kw_fail;\n                }\n            }\n\n            assert(j >= total_args);\n            if (kwdict == NULL) {\n\n                if (co->co_posonlyargcount\n                    && positional_only_passed_as_keyword(tstate, co,\n                                                        kwcount, kwnames,\n                                                        func->func_qualname))\n                {\n                    goto kw_fail;\n                }\n\n                PyObject* suggestion_keyword = NULL;\n                if (total_args > co->co_posonlyargcount) {\n                    PyObject* possible_keywords = PyList_New(total_args - co->co_posonlyargcount);\n\n                    if (!possible_keywords) {\n                        PyErr_Clear();\n                    } else {\n                        for (Py_ssize_t k = co->co_posonlyargcount; k < total_args; k++) {\n                            PyList_SET_ITEM(possible_keywords, k - co->co_posonlyargcount, co_varnames[k]);\n                        }\n\n                        suggestion_keyword = _Py_CalculateSuggestions(possible_keywords, keyword);\n                        Py_DECREF(possible_keywords);\n                    }\n                }\n\n                if (suggestion_keyword) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                \"%U() got an unexpected keyword argument '%S'. Did you mean '%S'?\",\n                                func->func_qualname, keyword, suggestion_keyword);\n                    Py_DECREF(suggestion_keyword);\n                } else {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                \"%U() got an unexpected keyword argument '%S'\",\n                                func->func_qualname, keyword);\n                }\n\n                goto kw_fail;\n            }\n\n            if (PyDict_SetItem(kwdict, keyword, value) == -1) {\n                goto kw_fail;\n            }\n            Py_DECREF(value);\n            continue;\n\n        kw_fail:\n            for (;i < kwcount; i++) {\n                PyObject *value = args[i+argcount];\n                Py_DECREF(value);\n            }\n            goto fail_post_args;\n\n        kw_found:\n            if (localsplus[j] != NULL) {\n                _PyErr_Format(tstate, PyExc_TypeError,\n                            \"%U() got multiple values for argument '%S'\",\n                          func->func_qualname, keyword);\n                goto kw_fail;\n            }\n            localsplus[j] = value;\n        }\n    }\n\n    /* Check the number of positional arguments */\n    if ((argcount > co->co_argcount) && !(co->co_flags & CO_VARARGS)) {\n        too_many_positional(tstate, co, argcount, func->func_defaults, localsplus,\n                            func->func_qualname);\n        goto fail_post_args;\n    }\n\n    /* Add missing positional arguments (copy default values from defs) */\n    if (argcount < co->co_argcount) {\n        Py_ssize_t defcount = func->func_defaults == NULL ? 0 : PyTuple_GET_SIZE(func->func_defaults);\n        Py_ssize_t m = co->co_argcount - defcount;\n        Py_ssize_t missing = 0;\n        for (i = argcount; i < m; i++) {\n            if (localsplus[i] == NULL) {\n                missing++;\n            }\n        }\n        if (missing) {\n            missing_arguments(tstate, co, missing, defcount, localsplus,\n                              func->func_qualname);\n            goto fail_post_args;\n        }\n        if (n > m)\n            i = n - m;\n        else\n            i = 0;\n        if (defcount) {\n            PyObject **defs = &PyTuple_GET_ITEM(func->func_defaults, 0);\n            for (; i < defcount; i++) {\n                if (localsplus[m+i] == NULL) {\n                    PyObject *def = defs[i];\n                    localsplus[m+i] = Py_NewRef(def);\n                }\n            }\n        }\n    }\n\n    /* Add missing keyword arguments (copy default values from kwdefs) */\n    if (co->co_kwonlyargcount > 0) {\n        Py_ssize_t missing = 0;\n        for (i = co->co_argcount; i < total_args; i++) {\n            if (localsplus[i] != NULL)\n                continue;\n            PyObject *varname = PyTuple_GET_ITEM(co->co_localsplusnames, i);\n            if (func->func_kwdefaults != NULL) {\n                PyObject *def;\n                if (PyDict_GetItemRef(func->func_kwdefaults, varname, &def) < 0) {\n                    goto fail_post_args;\n                }\n                if (def) {\n                    localsplus[i] = def;\n                    continue;\n                }\n            }\n            missing++;\n        }\n        if (missing) {\n            missing_arguments(tstate, co, missing, -1, localsplus,\n                              func->func_qualname);\n            goto fail_post_args;\n        }\n    }\n    return 0;\n\nfail_pre_positional:\n    for (j = 0; j < argcount; j++) {\n        Py_DECREF(args[j]);\n    }\n    /* fall through */\nfail_post_positional:\n    if (kwnames) {\n        Py_ssize_t kwcount = PyTuple_GET_SIZE(kwnames);\n        for (j = argcount; j < argcount+kwcount; j++) {\n            Py_DECREF(args[j]);\n        }\n    }\n    /* fall through */\nfail_post_args:\n    return -1;\n}\n\nstatic void\nclear_thread_frame(PyThreadState *tstate, _PyInterpreterFrame * frame)\n{\n    assert(frame->owner == FRAME_OWNED_BY_THREAD);\n    // Make sure that this is, indeed, the top frame. We can't check this in\n    // _PyThreadState_PopFrame, since f_code is already cleared at that point:\n    assert((PyObject **)frame + _PyFrame_GetCode(frame)->co_framesize ==\n        tstate->datastack_top);\n    tstate->c_recursion_remaining--;\n    assert(frame->frame_obj == NULL || frame->frame_obj->f_frame == frame);\n    _PyFrame_ClearExceptCode(frame);\n    Py_DECREF(frame->f_executable);\n    tstate->c_recursion_remaining++;\n    _PyThreadState_PopFrame(tstate, frame);\n}\n\nstatic void\nclear_gen_frame(PyThreadState *tstate, _PyInterpreterFrame * frame)\n{\n    assert(frame->owner == FRAME_OWNED_BY_GENERATOR);\n    PyGenObject *gen = _PyFrame_GetGenerator(frame);\n    gen->gi_frame_state = FRAME_CLEARED;\n    assert(tstate->exc_info == &gen->gi_exc_state);\n    tstate->exc_info = gen->gi_exc_state.previous_item;\n    gen->gi_exc_state.previous_item = NULL;\n    tstate->c_recursion_remaining--;\n    assert(frame->frame_obj == NULL || frame->frame_obj->f_frame == frame);\n    _PyFrame_ClearExceptCode(frame);\n    _PyErr_ClearExcState(&gen->gi_exc_state);\n    tstate->c_recursion_remaining++;\n    frame->previous = NULL;\n}\n\nvoid\n_PyEval_FrameClearAndPop(PyThreadState *tstate, _PyInterpreterFrame * frame)\n{\n    if (frame->owner == FRAME_OWNED_BY_THREAD) {\n        clear_thread_frame(tstate, frame);\n    }\n    else {\n        clear_gen_frame(tstate, frame);\n    }\n}\n\n/* Consumes references to func, locals and all the args */\n_PyInterpreterFrame *\n_PyEvalFramePushAndInit(PyThreadState *tstate, PyFunctionObject *func,\n                        PyObject *locals, PyObject* const* args,\n                        size_t argcount, PyObject *kwnames)\n{\n    PyCodeObject * code = (PyCodeObject *)func->func_code;\n    CALL_STAT_INC(frames_pushed);\n    _PyInterpreterFrame *frame = _PyThreadState_PushFrame(tstate, code->co_framesize);\n    if (frame == NULL) {\n        goto fail;\n    }\n    _PyFrame_Initialize(frame, func, locals, code, 0);\n    if (initialize_locals(tstate, func, frame->localsplus, args, argcount, kwnames)) {\n        assert(frame->owner == FRAME_OWNED_BY_THREAD);\n        clear_thread_frame(tstate, frame);\n        return NULL;\n    }\n    return frame;\nfail:\n    /* Consume the references */\n    Py_DECREF(func);\n    Py_XDECREF(locals);\n    for (size_t i = 0; i < argcount; i++) {\n        Py_DECREF(args[i]);\n    }\n    if (kwnames) {\n        Py_ssize_t kwcount = PyTuple_GET_SIZE(kwnames);\n        for (Py_ssize_t i = 0; i < kwcount; i++) {\n            Py_DECREF(args[i+argcount]);\n        }\n    }\n    PyErr_NoMemory();\n    return NULL;\n}\n\n/* Same as _PyEvalFramePushAndInit but takes an args tuple and kwargs dict.\n   Steals references to func, callargs and kwargs.\n*/\nstatic _PyInterpreterFrame *\n_PyEvalFramePushAndInit_Ex(PyThreadState *tstate, PyFunctionObject *func,\n    PyObject *locals, Py_ssize_t nargs, PyObject *callargs, PyObject *kwargs)\n{\n    bool has_dict = (kwargs != NULL && PyDict_GET_SIZE(kwargs) > 0);\n    PyObject *kwnames = NULL;\n    PyObject *const *newargs;\n    if (has_dict) {\n        newargs = _PyStack_UnpackDict(tstate, _PyTuple_ITEMS(callargs), nargs, kwargs, &kwnames);\n        if (newargs == NULL) {\n            Py_DECREF(func);\n            goto error;\n        }\n    }\n    else {\n        newargs = &PyTuple_GET_ITEM(callargs, 0);\n        /* We need to incref all our args since the new frame steals the references. */\n        for (Py_ssize_t i = 0; i < nargs; ++i) {\n            Py_INCREF(PyTuple_GET_ITEM(callargs, i));\n        }\n    }\n    _PyInterpreterFrame *new_frame = _PyEvalFramePushAndInit(\n        tstate, (PyFunctionObject *)func, locals,\n        newargs, nargs, kwnames\n    );\n    if (has_dict) {\n        _PyStack_UnpackDict_FreeNoDecRef(newargs, kwnames);\n    }\n    /* No need to decref func here because the reference has been stolen by\n       _PyEvalFramePushAndInit.\n    */\n    Py_DECREF(callargs);\n    Py_XDECREF(kwargs);\n    return new_frame;\nerror:\n    Py_DECREF(callargs);\n    Py_XDECREF(kwargs);\n    return NULL;\n}\n\nPyObject *\n_PyEval_Vector(PyThreadState *tstate, PyFunctionObject *func,\n               PyObject *locals,\n               PyObject* const* args, size_t argcount,\n               PyObject *kwnames)\n{\n    /* _PyEvalFramePushAndInit consumes the references\n     * to func, locals and all its arguments */\n    Py_INCREF(func);\n    Py_XINCREF(locals);\n    for (size_t i = 0; i < argcount; i++) {\n        Py_INCREF(args[i]);\n    }\n    if (kwnames) {\n        Py_ssize_t kwcount = PyTuple_GET_SIZE(kwnames);\n        for (Py_ssize_t i = 0; i < kwcount; i++) {\n            Py_INCREF(args[i+argcount]);\n        }\n    }\n    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n        tstate, func, locals, args, argcount, kwnames);\n    if (frame == NULL) {\n        return NULL;\n    }\n    EVAL_CALL_STAT_INC(EVAL_CALL_VECTOR);\n    return _PyEval_EvalFrame(tstate, frame, 0);\n}\n\n/* Legacy API */\nPyObject *\nPyEval_EvalCodeEx(PyObject *_co, PyObject *globals, PyObject *locals,\n                  PyObject *const *args, int argcount,\n                  PyObject *const *kws, int kwcount,\n                  PyObject *const *defs, int defcount,\n                  PyObject *kwdefs, PyObject *closure)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    PyObject *res = NULL;\n    PyObject *defaults = _PyTuple_FromArray(defs, defcount);\n    if (defaults == NULL) {\n        return NULL;\n    }\n    PyObject *builtins = _PyEval_BuiltinsFromGlobals(tstate, globals); // borrowed ref\n    if (builtins == NULL) {\n        Py_DECREF(defaults);\n        return NULL;\n    }\n    if (locals == NULL) {\n        locals = globals;\n    }\n    PyObject *kwnames = NULL;\n    PyObject *const *allargs;\n    PyObject **newargs = NULL;\n    PyFunctionObject *func = NULL;\n    if (kwcount == 0) {\n        allargs = args;\n    }\n    else {\n        kwnames = PyTuple_New(kwcount);\n        if (kwnames == NULL) {\n            goto fail;\n        }\n        newargs = PyMem_Malloc(sizeof(PyObject *)*(kwcount+argcount));\n        if (newargs == NULL) {\n            goto fail;\n        }\n        for (int i = 0; i < argcount; i++) {\n            newargs[i] = args[i];\n        }\n        for (int i = 0; i < kwcount; i++) {\n            PyTuple_SET_ITEM(kwnames, i, Py_NewRef(kws[2*i]));\n            newargs[argcount+i] = kws[2*i+1];\n        }\n        allargs = newargs;\n    }\n    PyFrameConstructor constr = {\n        .fc_globals = globals,\n        .fc_builtins = builtins,\n        .fc_name = ((PyCodeObject *)_co)->co_name,\n        .fc_qualname = ((PyCodeObject *)_co)->co_name,\n        .fc_code = _co,\n        .fc_defaults = defaults,\n        .fc_kwdefaults = kwdefs,\n        .fc_closure = closure\n    };\n    func = _PyFunction_FromConstructor(&constr);\n    if (func == NULL) {\n        goto fail;\n    }\n    EVAL_CALL_STAT_INC(EVAL_CALL_LEGACY);\n    res = _PyEval_Vector(tstate, func, locals,\n                         allargs, argcount,\n                         kwnames);\nfail:\n    Py_XDECREF(func);\n    Py_XDECREF(kwnames);\n    PyMem_Free(newargs);\n    Py_DECREF(defaults);\n    return res;\n}\n\n\n/* Logic for the raise statement (too complicated for inlining).\n   This *consumes* a reference count to each of its arguments. */\nstatic int\ndo_raise(PyThreadState *tstate, PyObject *exc, PyObject *cause)\n{\n    PyObject *type = NULL, *value = NULL;\n\n    if (exc == NULL) {\n        /* Reraise */\n        _PyErr_StackItem *exc_info = _PyErr_GetTopmostException(tstate);\n        exc = exc_info->exc_value;\n        if (Py_IsNone(exc) || exc == NULL) {\n            _PyErr_SetString(tstate, PyExc_RuntimeError,\n                             \"No active exception to reraise\");\n            return 0;\n        }\n        Py_INCREF(exc);\n        assert(PyExceptionInstance_Check(exc));\n        _PyErr_SetRaisedException(tstate, exc);\n        return 1;\n    }\n\n    /* We support the following forms of raise:\n       raise\n       raise <instance>\n       raise <type> */\n\n    if (PyExceptionClass_Check(exc)) {\n        type = exc;\n        value = _PyObject_CallNoArgs(exc);\n        if (value == NULL)\n            goto raise_error;\n        if (!PyExceptionInstance_Check(value)) {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"calling %R should have returned an instance of \"\n                          \"BaseException, not %R\",\n                          type, Py_TYPE(value));\n             goto raise_error;\n        }\n    }\n    else if (PyExceptionInstance_Check(exc)) {\n        value = exc;\n        type = PyExceptionInstance_Class(exc);\n        Py_INCREF(type);\n    }\n    else {\n        /* Not something you can raise.  You get an exception\n           anyway, just not what you specified :-) */\n        Py_DECREF(exc);\n        _PyErr_SetString(tstate, PyExc_TypeError,\n                         \"exceptions must derive from BaseException\");\n        goto raise_error;\n    }\n\n    assert(type != NULL);\n    assert(value != NULL);\n\n    if (cause) {\n        PyObject *fixed_cause;\n        if (PyExceptionClass_Check(cause)) {\n            fixed_cause = _PyObject_CallNoArgs(cause);\n            if (fixed_cause == NULL)\n                goto raise_error;\n            if (!PyExceptionInstance_Check(fixed_cause)) {\n                _PyErr_Format(tstate, PyExc_TypeError,\n                              \"calling %R should have returned an instance of \"\n                              \"BaseException, not %R\",\n                              cause, Py_TYPE(fixed_cause));\n                goto raise_error;\n            }\n            Py_DECREF(cause);\n        }\n        else if (PyExceptionInstance_Check(cause)) {\n            fixed_cause = cause;\n        }\n        else if (Py_IsNone(cause)) {\n            Py_DECREF(cause);\n            fixed_cause = NULL;\n        }\n        else {\n            _PyErr_SetString(tstate, PyExc_TypeError,\n                             \"exception causes must derive from \"\n                             \"BaseException\");\n            goto raise_error;\n        }\n        PyException_SetCause(value, fixed_cause);\n    }\n\n    _PyErr_SetObject(tstate, type, value);\n    /* _PyErr_SetObject incref's its arguments */\n    Py_DECREF(value);\n    Py_DECREF(type);\n    return 0;\n\nraise_error:\n    Py_XDECREF(value);\n    Py_XDECREF(type);\n    Py_XDECREF(cause);\n    return 0;\n}\n\n/* Logic for matching an exception in an except* clause (too\n   complicated for inlining).\n*/\n\nint\n_PyEval_ExceptionGroupMatch(PyObject* exc_value, PyObject *match_type,\n                            PyObject **match, PyObject **rest)\n{\n    if (Py_IsNone(exc_value)) {\n        *match = Py_NewRef(Py_None);\n        *rest = Py_NewRef(Py_None);\n        return 0;\n    }\n    assert(PyExceptionInstance_Check(exc_value));\n\n    if (PyErr_GivenExceptionMatches(exc_value, match_type)) {\n        /* Full match of exc itself */\n        bool is_eg = _PyBaseExceptionGroup_Check(exc_value);\n        if (is_eg) {\n            *match = Py_NewRef(exc_value);\n        }\n        else {\n            /* naked exception - wrap it */\n            PyObject *excs = PyTuple_Pack(1, exc_value);\n            if (excs == NULL) {\n                return -1;\n            }\n            PyObject *wrapped = _PyExc_CreateExceptionGroup(\"\", excs);\n            Py_DECREF(excs);\n            if (wrapped == NULL) {\n                return -1;\n            }\n            *match = wrapped;\n        }\n        *rest = Py_NewRef(Py_None);\n        return 0;\n    }\n\n    /* exc_value does not match match_type.\n     * Check for partial match if it's an exception group.\n     */\n    if (_PyBaseExceptionGroup_Check(exc_value)) {\n        PyObject *pair = PyObject_CallMethod(exc_value, \"split\", \"(O)\",\n                                             match_type);\n        if (pair == NULL) {\n            return -1;\n        }\n        assert(PyTuple_CheckExact(pair));\n        assert(PyTuple_GET_SIZE(pair) == 2);\n        *match = Py_NewRef(PyTuple_GET_ITEM(pair, 0));\n        *rest = Py_NewRef(PyTuple_GET_ITEM(pair, 1));\n        Py_DECREF(pair);\n        return 0;\n    }\n    /* no match */\n    *match = Py_NewRef(Py_None);\n    *rest = Py_NewRef(exc_value);\n    return 0;\n}\n\n/* Iterate v argcnt times and store the results on the stack (via decreasing\n   sp).  Return 1 for success, 0 if error.\n\n   If argcntafter == -1, do a simple unpack. If it is >= 0, do an unpack\n   with a variable target.\n*/\n\nint\n_PyEval_UnpackIterable(PyThreadState *tstate, PyObject *v,\n                       int argcnt, int argcntafter, PyObject **sp)\n{\n    int i = 0, j = 0;\n    Py_ssize_t ll = 0;\n    PyObject *it;  /* iter(v) */\n    PyObject *w;\n    PyObject *l = NULL; /* variable list */\n\n    assert(v != NULL);\n\n    it = PyObject_GetIter(v);\n    if (it == NULL) {\n        if (_PyErr_ExceptionMatches(tstate, PyExc_TypeError) &&\n            Py_TYPE(v)->tp_iter == NULL && !PySequence_Check(v))\n        {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"cannot unpack non-iterable %.200s object\",\n                          Py_TYPE(v)->tp_name);\n        }\n        return 0;\n    }\n\n    for (; i < argcnt; i++) {\n        w = PyIter_Next(it);\n        if (w == NULL) {\n            /* Iterator done, via error or exhaustion. */\n            if (!_PyErr_Occurred(tstate)) {\n                if (argcntafter == -1) {\n                    _PyErr_Format(tstate, PyExc_ValueError,\n                                  \"not enough values to unpack \"\n                                  \"(expected %d, got %d)\",\n                                  argcnt, i);\n                }\n                else {\n                    _PyErr_Format(tstate, PyExc_ValueError,\n                                  \"not enough values to unpack \"\n                                  \"(expected at least %d, got %d)\",\n                                  argcnt + argcntafter, i);\n                }\n            }\n            goto Error;\n        }\n        *--sp = w;\n    }\n\n    if (argcntafter == -1) {\n        /* We better have exhausted the iterator now. */\n        w = PyIter_Next(it);\n        if (w == NULL) {\n            if (_PyErr_Occurred(tstate))\n                goto Error;\n            Py_DECREF(it);\n            return 1;\n        }\n        Py_DECREF(w);\n        _PyErr_Format(tstate, PyExc_ValueError,\n                      \"too many values to unpack (expected %d)\",\n                      argcnt);\n        goto Error;\n    }\n\n    l = PySequence_List(it);\n    if (l == NULL)\n        goto Error;\n    *--sp = l;\n    i++;\n\n    ll = PyList_GET_SIZE(l);\n    if (ll < argcntafter) {\n        _PyErr_Format(tstate, PyExc_ValueError,\n            \"not enough values to unpack (expected at least %d, got %zd)\",\n            argcnt + argcntafter, argcnt + ll);\n        goto Error;\n    }\n\n    /* Pop the \"after-variable\" args off the list. */\n    for (j = argcntafter; j > 0; j--, i++) {\n        *--sp = PyList_GET_ITEM(l, ll - j);\n    }\n    /* Resize the list. */\n    Py_SET_SIZE(l, ll - argcntafter);\n    Py_DECREF(it);\n    return 1;\n\nError:\n    for (; i > 0; i--, sp++)\n        Py_DECREF(*sp);\n    Py_XDECREF(it);\n    return 0;\n}\n\nstatic int\ndo_monitor_exc(PyThreadState *tstate, _PyInterpreterFrame *frame,\n               _Py_CODEUNIT *instr, int event)\n{\n    assert(event < _PY_MONITORING_UNGROUPED_EVENTS);\n    if (_PyFrame_GetCode(frame)->co_flags & CO_NO_MONITORING_EVENTS) {\n        return 0;\n    }\n    PyObject *exc = PyErr_GetRaisedException();\n    assert(exc != NULL);\n    int err = _Py_call_instrumentation_arg(tstate, event, frame, instr, exc);\n    if (err == 0) {\n        PyErr_SetRaisedException(exc);\n    }\n    else {\n        assert(PyErr_Occurred());\n        Py_DECREF(exc);\n    }\n    return err;\n}\n\nstatic inline bool\nno_tools_for_global_event(PyThreadState *tstate, int event)\n{\n    return tstate->interp->monitors.tools[event] == 0;\n}\n\nstatic inline bool\nno_tools_for_local_event(PyThreadState *tstate, _PyInterpreterFrame *frame, int event)\n{\n    assert(event < _PY_MONITORING_LOCAL_EVENTS);\n    _PyCoMonitoringData *data = _PyFrame_GetCode(frame)->_co_monitoring;\n    if (data) {\n        return data->active_monitors.tools[event] == 0;\n    }\n    else {\n        return no_tools_for_global_event(tstate, event);\n    }\n}\n\nstatic void\nmonitor_raise(PyThreadState *tstate, _PyInterpreterFrame *frame,\n              _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_RAISE)) {\n        return;\n    }\n    do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_RAISE);\n}\n\nstatic void\nmonitor_reraise(PyThreadState *tstate, _PyInterpreterFrame *frame,\n              _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_RERAISE)) {\n        return;\n    }\n    do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_RERAISE);\n}\n\nstatic int\nmonitor_stop_iteration(PyThreadState *tstate, _PyInterpreterFrame *frame,\n                       _Py_CODEUNIT *instr, PyObject *value)\n{\n    if (no_tools_for_local_event(tstate, frame, PY_MONITORING_EVENT_STOP_ITERATION)) {\n        return 0;\n    }\n    assert(!PyErr_Occurred());\n    PyErr_SetObject(PyExc_StopIteration, value);\n    int res = do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_STOP_ITERATION);\n    if (res < 0) {\n        return res;\n    }\n    PyErr_SetRaisedException(NULL);\n    return 0;\n}\n\nstatic void\nmonitor_unwind(PyThreadState *tstate,\n               _PyInterpreterFrame *frame,\n               _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_PY_UNWIND)) {\n        return;\n    }\n    do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_PY_UNWIND);\n}\n\n\nstatic int\nmonitor_handled(PyThreadState *tstate,\n                _PyInterpreterFrame *frame,\n                _Py_CODEUNIT *instr, PyObject *exc)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_EXCEPTION_HANDLED)) {\n        return 0;\n    }\n    return _Py_call_instrumentation_arg(tstate, PY_MONITORING_EVENT_EXCEPTION_HANDLED, frame, instr, exc);\n}\n\nstatic void\nmonitor_throw(PyThreadState *tstate,\n              _PyInterpreterFrame *frame,\n              _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_PY_THROW)) {\n        return;\n    }\n    do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_PY_THROW);\n}\n\nvoid\nPyThreadState_EnterTracing(PyThreadState *tstate)\n{\n    assert(tstate->tracing >= 0);\n    tstate->tracing++;\n}\n\nvoid\nPyThreadState_LeaveTracing(PyThreadState *tstate)\n{\n    assert(tstate->tracing > 0);\n    tstate->tracing--;\n}\n\n\nPyObject*\n_PyEval_CallTracing(PyObject *func, PyObject *args)\n{\n    // Save and disable tracing\n    PyThreadState *tstate = _PyThreadState_GET();\n    int save_tracing = tstate->tracing;\n    tstate->tracing = 0;\n\n    // Call the tracing function\n    PyObject *result = PyObject_Call(func, args, NULL);\n\n    // Restore tracing\n    tstate->tracing = save_tracing;\n    return result;\n}\n\nvoid\nPyEval_SetProfile(Py_tracefunc func, PyObject *arg)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (_PyEval_SetProfile(tstate, func, arg) < 0) {\n        /* Log _PySys_Audit() error */\n        PyErr_FormatUnraisable(\"Exception ignored in PyEval_SetProfile\");\n    }\n}\n\nvoid\nPyEval_SetProfileAllThreads(Py_tracefunc func, PyObject *arg)\n{\n    PyThreadState *this_tstate = _PyThreadState_GET();\n    PyInterpreterState* interp = this_tstate->interp;\n\n    _PyRuntimeState *runtime = &_PyRuntime;\n    HEAD_LOCK(runtime);\n    PyThreadState* ts = PyInterpreterState_ThreadHead(interp);\n    HEAD_UNLOCK(runtime);\n\n    while (ts) {\n        if (_PyEval_SetProfile(ts, func, arg) < 0) {\n            PyErr_FormatUnraisable(\"Exception ignored in PyEval_SetProfileAllThreads\");\n        }\n        HEAD_LOCK(runtime);\n        ts = PyThreadState_Next(ts);\n        HEAD_UNLOCK(runtime);\n    }\n}\n\nvoid\nPyEval_SetTrace(Py_tracefunc func, PyObject *arg)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (_PyEval_SetTrace(tstate, func, arg) < 0) {\n        /* Log _PySys_Audit() error */\n        PyErr_FormatUnraisable(\"Exception ignored in PyEval_SetTrace\");\n    }\n}\n\nvoid\nPyEval_SetTraceAllThreads(Py_tracefunc func, PyObject *arg)\n{\n    PyThreadState *this_tstate = _PyThreadState_GET();\n    PyInterpreterState* interp = this_tstate->interp;\n\n    _PyRuntimeState *runtime = &_PyRuntime;\n    HEAD_LOCK(runtime);\n    PyThreadState* ts = PyInterpreterState_ThreadHead(interp);\n    HEAD_UNLOCK(runtime);\n\n    while (ts) {\n        if (_PyEval_SetTrace(ts, func, arg) < 0) {\n            PyErr_FormatUnraisable(\"Exception ignored in PyEval_SetTraceAllThreads\");\n        }\n        HEAD_LOCK(runtime);\n        ts = PyThreadState_Next(ts);\n        HEAD_UNLOCK(runtime);\n    }\n}\n\nint\n_PyEval_SetCoroutineOriginTrackingDepth(int depth)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (depth < 0) {\n        _PyErr_SetString(tstate, PyExc_ValueError, \"depth must be >= 0\");\n        return -1;\n    }\n    tstate->coroutine_origin_tracking_depth = depth;\n    return 0;\n}\n\n\nint\n_PyEval_GetCoroutineOriginTrackingDepth(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return tstate->coroutine_origin_tracking_depth;\n}\n\nint\n_PyEval_SetAsyncGenFirstiter(PyObject *firstiter)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    if (_PySys_Audit(tstate, \"sys.set_asyncgen_hook_firstiter\", NULL) < 0) {\n        return -1;\n    }\n\n    Py_XSETREF(tstate->async_gen_firstiter, Py_XNewRef(firstiter));\n    return 0;\n}\n\nPyObject *\n_PyEval_GetAsyncGenFirstiter(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return tstate->async_gen_firstiter;\n}\n\nint\n_PyEval_SetAsyncGenFinalizer(PyObject *finalizer)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    if (_PySys_Audit(tstate, \"sys.set_asyncgen_hook_finalizer\", NULL) < 0) {\n        return -1;\n    }\n\n    Py_XSETREF(tstate->async_gen_finalizer, Py_XNewRef(finalizer));\n    return 0;\n}\n\nPyObject *\n_PyEval_GetAsyncGenFinalizer(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return tstate->async_gen_finalizer;\n}\n\n_PyInterpreterFrame *\n_PyEval_GetFrame(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _PyThreadState_GetFrame(tstate);\n}\n\nPyFrameObject *\nPyEval_GetFrame(void)\n{\n    _PyInterpreterFrame *frame = _PyEval_GetFrame();\n    if (frame == NULL) {\n        return NULL;\n    }\n    PyFrameObject *f = _PyFrame_GetFrameObject(frame);\n    if (f == NULL) {\n        PyErr_Clear();\n    }\n    return f;\n}\n\nPyObject *\n_PyEval_GetBuiltins(PyThreadState *tstate)\n{\n    _PyInterpreterFrame *frame = _PyThreadState_GetFrame(tstate);\n    if (frame != NULL) {\n        return frame->f_builtins;\n    }\n    return tstate->interp->builtins;\n}\n\nPyObject *\nPyEval_GetBuiltins(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _PyEval_GetBuiltins(tstate);\n}\n\n/* Convenience function to get a builtin from its name */\nPyObject *\n_PyEval_GetBuiltin(PyObject *name)\n{\n    PyObject *attr;\n    if (PyMapping_GetOptionalItem(PyEval_GetBuiltins(), name, &attr) == 0) {\n        PyErr_SetObject(PyExc_AttributeError, name);\n    }\n    return attr;\n}\n\nPyObject *\n_PyEval_GetBuiltinId(_Py_Identifier *name)\n{\n    return _PyEval_GetBuiltin(_PyUnicode_FromId(name));\n}\n\nPyObject *\nPyEval_GetLocals(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n     _PyInterpreterFrame *current_frame = _PyThreadState_GetFrame(tstate);\n    if (current_frame == NULL) {\n        _PyErr_SetString(tstate, PyExc_SystemError, \"frame does not exist\");\n        return NULL;\n    }\n\n    PyObject *locals = _PyEval_GetFrameLocals();\n    return locals;\n}\n\nPyObject *\n_PyEval_GetFrameLocals(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n     _PyInterpreterFrame *current_frame = _PyThreadState_GetFrame(tstate);\n    if (current_frame == NULL) {\n        _PyErr_SetString(tstate, PyExc_SystemError, \"frame does not exist\");\n        return NULL;\n    }\n\n    PyObject *locals = _PyFrame_GetLocals(current_frame);\n    if (locals == NULL) {\n        return NULL;\n    }\n\n    if (PyFrameLocalsProxy_Check(locals)) {\n        PyObject* ret = PyDict_New();\n        if (ret == NULL) {\n            Py_DECREF(locals);\n            return NULL;\n        }\n        if (PyDict_Update(ret, locals) < 0) {\n            Py_DECREF(ret);\n            Py_DECREF(locals);\n            return NULL;\n        }\n        Py_DECREF(locals);\n        return ret;\n    }\n\n    assert(PyMapping_Check(locals));\n    return locals;\n}\n\nPyObject *\nPyEval_GetGlobals(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    _PyInterpreterFrame *current_frame = _PyThreadState_GetFrame(tstate);\n    if (current_frame == NULL) {\n        return NULL;\n    }\n    return current_frame->f_globals;\n}\n\nPyObject*\nPyEval_GetFrameLocals(void)\n{\n    return _PyEval_GetFrameLocals();\n}\n\nPyObject* PyEval_GetFrameGlobals(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    _PyInterpreterFrame *current_frame = _PyThreadState_GetFrame(tstate);\n    if (current_frame == NULL) {\n        return NULL;\n    }\n    return Py_XNewRef(current_frame->f_globals);\n}\n\nPyObject* PyEval_GetFrameBuiltins(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return Py_XNewRef(_PyEval_GetBuiltins(tstate));\n}\n\nint\nPyEval_MergeCompilerFlags(PyCompilerFlags *cf)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    _PyInterpreterFrame *current_frame = tstate->current_frame;\n    int result = cf->cf_flags != 0;\n\n    if (current_frame != NULL) {\n        const int codeflags = _PyFrame_GetCode(current_frame)->co_flags;\n        const int compilerflags = codeflags & PyCF_MASK;\n        if (compilerflags) {\n            result = 1;\n            cf->cf_flags |= compilerflags;\n        }\n    }\n    return result;\n}\n\n\nconst char *\nPyEval_GetFuncName(PyObject *func)\n{\n    if (PyMethod_Check(func))\n        return PyEval_GetFuncName(PyMethod_GET_FUNCTION(func));\n    else if (PyFunction_Check(func))\n        return PyUnicode_AsUTF8(((PyFunctionObject*)func)->func_name);\n    else if (PyCFunction_Check(func))\n        return ((PyCFunctionObject*)func)->m_ml->ml_name;\n    else\n        return Py_TYPE(func)->tp_name;\n}\n\nconst char *\nPyEval_GetFuncDesc(PyObject *func)\n{\n    if (PyMethod_Check(func))\n        return \"()\";\n    else if (PyFunction_Check(func))\n        return \"()\";\n    else if (PyCFunction_Check(func))\n        return \"()\";\n    else\n        return \" object\";\n}\n\n/* Extract a slice index from a PyLong or an object with the\n   nb_index slot defined, and store in *pi.\n   Silently reduce values larger than PY_SSIZE_T_MAX to PY_SSIZE_T_MAX,\n   and silently boost values less than PY_SSIZE_T_MIN to PY_SSIZE_T_MIN.\n   Return 0 on error, 1 on success.\n*/\nint\n_PyEval_SliceIndex(PyObject *v, Py_ssize_t *pi)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (!Py_IsNone(v)) {\n        Py_ssize_t x;\n        if (_PyIndex_Check(v)) {\n            x = PyNumber_AsSsize_t(v, NULL);\n            if (x == -1 && _PyErr_Occurred(tstate))\n                return 0;\n        }\n        else {\n            _PyErr_SetString(tstate, PyExc_TypeError,\n                             \"slice indices must be integers or \"\n                             \"None or have an __index__ method\");\n            return 0;\n        }\n        *pi = x;\n    }\n    return 1;\n}\n\nint\n_PyEval_SliceIndexNotNone(PyObject *v, Py_ssize_t *pi)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    Py_ssize_t x;\n    if (_PyIndex_Check(v)) {\n        x = PyNumber_AsSsize_t(v, NULL);\n        if (x == -1 && _PyErr_Occurred(tstate))\n            return 0;\n    }\n    else {\n        _PyErr_SetString(tstate, PyExc_TypeError,\n                         \"slice indices must be integers or \"\n                         \"have an __index__ method\");\n        return 0;\n    }\n    *pi = x;\n    return 1;\n}\n\nstatic PyObject *\nimport_name(PyThreadState *tstate, _PyInterpreterFrame *frame,\n            PyObject *name, PyObject *fromlist, PyObject *level)\n{\n    PyObject *import_func;\n    if (PyMapping_GetOptionalItem(frame->f_builtins, &_Py_ID(__import__), &import_func) < 0) {\n        return NULL;\n    }\n    if (import_func == NULL) {\n        _PyErr_SetString(tstate, PyExc_ImportError, \"__import__ not found\");\n        return NULL;\n    }\n\n    PyObject *locals = frame->f_locals;\n    if (locals == NULL) {\n        locals = Py_None;\n    }\n\n    /* Fast path for not overloaded __import__. */\n    if (_PyImport_IsDefaultImportFunc(tstate->interp, import_func)) {\n        Py_DECREF(import_func);\n        int ilevel = PyLong_AsInt(level);\n        if (ilevel == -1 && _PyErr_Occurred(tstate)) {\n            return NULL;\n        }\n        return PyImport_ImportModuleLevelObject(\n                        name,\n                        frame->f_globals,\n                        locals,\n                        fromlist,\n                        ilevel);\n    }\n\n    PyObject* args[5] = {name, frame->f_globals, locals, fromlist, level};\n    PyObject *res = PyObject_Vectorcall(import_func, args, 5, NULL);\n    Py_DECREF(import_func);\n    return res;\n}\n\nstatic PyObject *\nimport_from(PyThreadState *tstate, PyObject *v, PyObject *name)\n{\n    PyObject *x;\n    PyObject *fullmodname, *pkgname, *pkgpath, *pkgname_or_unknown, *errmsg;\n\n    if (PyObject_GetOptionalAttr(v, name, &x) != 0) {\n        return x;\n    }\n    /* Issue #17636: in case this failed because of a circular relative\n       import, try to fallback on reading the module directly from\n       sys.modules. */\n    if (PyObject_GetOptionalAttr(v, &_Py_ID(__name__), &pkgname) < 0) {\n        return NULL;\n    }\n    if (pkgname == NULL || !PyUnicode_Check(pkgname)) {\n        Py_CLEAR(pkgname);\n        goto error;\n    }\n    fullmodname = PyUnicode_FromFormat(\"%U.%U\", pkgname, name);\n    if (fullmodname == NULL) {\n        Py_DECREF(pkgname);\n        return NULL;\n    }\n    x = PyImport_GetModule(fullmodname);\n    Py_DECREF(fullmodname);\n    if (x == NULL && !_PyErr_Occurred(tstate)) {\n        goto error;\n    }\n    Py_DECREF(pkgname);\n    return x;\n error:\n    if (pkgname == NULL) {\n        pkgname_or_unknown = PyUnicode_FromString(\"<unknown module name>\");\n        if (pkgname_or_unknown == NULL) {\n            return NULL;\n        }\n    } else {\n        pkgname_or_unknown = pkgname;\n    }\n\n    pkgpath = NULL;\n    if (PyModule_Check(v)) {\n        pkgpath = PyModule_GetFilenameObject(v);\n        if (pkgpath == NULL) {\n            if (!PyErr_ExceptionMatches(PyExc_SystemError)) {\n                Py_DECREF(pkgname_or_unknown);\n                return NULL;\n            }\n            // module filename missing\n            _PyErr_Clear(tstate);\n        }\n    }\n    if (pkgpath == NULL || !PyUnicode_Check(pkgpath)) {\n        Py_CLEAR(pkgpath);\n        errmsg = PyUnicode_FromFormat(\n            \"cannot import name %R from %R (unknown location)\",\n            name, pkgname_or_unknown\n        );\n    }\n    else {\n        PyObject *spec;\n        int rc = PyObject_GetOptionalAttr(v, &_Py_ID(__spec__), &spec);\n        if (rc > 0) {\n            rc = _PyModuleSpec_IsInitializing(spec);\n            Py_DECREF(spec);\n        }\n        if (rc < 0) {\n            Py_DECREF(pkgname_or_unknown);\n            Py_DECREF(pkgpath);\n            return NULL;\n        }\n        const char *fmt =\n            rc ?\n            \"cannot import name %R from partially initialized module %R \"\n            \"(most likely due to a circular import) (%S)\" :\n            \"cannot import name %R from %R (%S)\";\n\n        errmsg = PyUnicode_FromFormat(fmt, name, pkgname_or_unknown, pkgpath);\n    }\n    /* NULL checks for errmsg and pkgname done by PyErr_SetImportError. */\n    _PyErr_SetImportErrorWithNameFrom(errmsg, pkgname, pkgpath, name);\n\n    Py_XDECREF(errmsg);\n    Py_DECREF(pkgname_or_unknown);\n    Py_XDECREF(pkgpath);\n    return NULL;\n}\n\n#define CANNOT_CATCH_MSG \"catching classes that do not inherit from \"\\\n                         \"BaseException is not allowed\"\n\n#define CANNOT_EXCEPT_STAR_EG \"catching ExceptionGroup with except* \"\\\n                              \"is not allowed. Use except instead.\"\n\nint\n_PyEval_CheckExceptTypeValid(PyThreadState *tstate, PyObject* right)\n{\n    if (PyTuple_Check(right)) {\n        Py_ssize_t i, length;\n        length = PyTuple_GET_SIZE(right);\n        for (i = 0; i < length; i++) {\n            PyObject *exc = PyTuple_GET_ITEM(right, i);\n            if (!PyExceptionClass_Check(exc)) {\n                _PyErr_SetString(tstate, PyExc_TypeError,\n                    CANNOT_CATCH_MSG);\n                return -1;\n            }\n        }\n    }\n    else {\n        if (!PyExceptionClass_Check(right)) {\n            _PyErr_SetString(tstate, PyExc_TypeError,\n                CANNOT_CATCH_MSG);\n            return -1;\n        }\n    }\n    return 0;\n}\n\nint\n_PyEval_CheckExceptStarTypeValid(PyThreadState *tstate, PyObject* right)\n{\n    if (_PyEval_CheckExceptTypeValid(tstate, right) < 0) {\n        return -1;\n    }\n\n    /* reject except *ExceptionGroup */\n\n    int is_subclass = 0;\n    if (PyTuple_Check(right)) {\n        Py_ssize_t length = PyTuple_GET_SIZE(right);\n        for (Py_ssize_t i = 0; i < length; i++) {\n            PyObject *exc = PyTuple_GET_ITEM(right, i);\n            is_subclass = PyObject_IsSubclass(exc, PyExc_BaseExceptionGroup);\n            if (is_subclass < 0) {\n                return -1;\n            }\n            if (is_subclass) {\n                break;\n            }\n        }\n    }\n    else {\n        is_subclass = PyObject_IsSubclass(right, PyExc_BaseExceptionGroup);\n        if (is_subclass < 0) {\n            return -1;\n        }\n    }\n    if (is_subclass) {\n        _PyErr_SetString(tstate, PyExc_TypeError,\n            CANNOT_EXCEPT_STAR_EG);\n            return -1;\n    }\n    return 0;\n}\n\nstatic int\ncheck_args_iterable(PyThreadState *tstate, PyObject *func, PyObject *args)\n{\n    if (Py_TYPE(args)->tp_iter == NULL && !PySequence_Check(args)) {\n        /* check_args_iterable() may be called with a live exception:\n         * clear it to prevent calling _PyObject_FunctionStr() with an\n         * exception set. */\n        _PyErr_Clear(tstate);\n        PyObject *funcstr = _PyObject_FunctionStr(func);\n        if (funcstr != NULL) {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"%U argument after * must be an iterable, not %.200s\",\n                          funcstr, Py_TYPE(args)->tp_name);\n            Py_DECREF(funcstr);\n        }\n        return -1;\n    }\n    return 0;\n}\n\nvoid\n_PyEval_FormatKwargsError(PyThreadState *tstate, PyObject *func, PyObject *kwargs)\n{\n    /* _PyDict_MergeEx raises attribute\n     * error (percolated from an attempt\n     * to get 'keys' attribute) instead of\n     * a type error if its second argument\n     * is not a mapping.\n     */\n    if (_PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {\n        _PyErr_Clear(tstate);\n        PyObject *funcstr = _PyObject_FunctionStr(func);\n        if (funcstr != NULL) {\n            _PyErr_Format(\n                tstate, PyExc_TypeError,\n                \"%U argument after ** must be a mapping, not %.200s\",\n                funcstr, Py_TYPE(kwargs)->tp_name);\n            Py_DECREF(funcstr);\n        }\n    }\n    else if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n        PyObject *exc = _PyErr_GetRaisedException(tstate);\n        PyObject *args = ((PyBaseExceptionObject *)exc)->args;\n        if (exc && PyTuple_Check(args) && PyTuple_GET_SIZE(args) == 1) {\n            _PyErr_Clear(tstate);\n            PyObject *funcstr = _PyObject_FunctionStr(func);\n            if (funcstr != NULL) {\n                PyObject *key = PyTuple_GET_ITEM(args, 0);\n                _PyErr_Format(\n                    tstate, PyExc_TypeError,\n                    \"%U got multiple values for keyword argument '%S'\",\n                    funcstr, key);\n                Py_DECREF(funcstr);\n            }\n            Py_XDECREF(exc);\n        }\n        else {\n            _PyErr_SetRaisedException(tstate, exc);\n        }\n    }\n}\n\nvoid\n_PyEval_FormatExcCheckArg(PyThreadState *tstate, PyObject *exc,\n                          const char *format_str, PyObject *obj)\n{\n    const char *obj_str;\n\n    if (!obj)\n        return;\n\n    obj_str = PyUnicode_AsUTF8(obj);\n    if (!obj_str)\n        return;\n\n    _PyErr_Format(tstate, exc, format_str, obj_str);\n\n    if (exc == PyExc_NameError) {\n        // Include the name in the NameError exceptions to offer suggestions later.\n        PyObject *exc = PyErr_GetRaisedException();\n        if (PyErr_GivenExceptionMatches(exc, PyExc_NameError)) {\n            if (((PyNameErrorObject*)exc)->name == NULL) {\n                // We do not care if this fails because we are going to restore the\n                // NameError anyway.\n                (void)PyObject_SetAttr(exc, &_Py_ID(name), obj);\n            }\n        }\n        PyErr_SetRaisedException(exc);\n    }\n}\n\nvoid\n_PyEval_FormatExcUnbound(PyThreadState *tstate, PyCodeObject *co, int oparg)\n{\n    PyObject *name;\n    /* Don't stomp existing exception */\n    if (_PyErr_Occurred(tstate))\n        return;\n    name = PyTuple_GET_ITEM(co->co_localsplusnames, oparg);\n    if (oparg < PyUnstable_Code_GetFirstFree(co)) {\n        _PyEval_FormatExcCheckArg(tstate, PyExc_UnboundLocalError,\n                                  UNBOUNDLOCAL_ERROR_MSG, name);\n    } else {\n        _PyEval_FormatExcCheckArg(tstate, PyExc_NameError,\n                                  UNBOUNDFREE_ERROR_MSG, name);\n    }\n}\n\nvoid\n_PyEval_FormatAwaitableError(PyThreadState *tstate, PyTypeObject *type, int oparg)\n{\n    if (type->tp_as_async == NULL || type->tp_as_async->am_await == NULL) {\n        if (oparg == 1) {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"'async with' received an object from __aenter__ \"\n                          \"that does not implement __await__: %.100s\",\n                          type->tp_name);\n        }\n        else if (oparg == 2) {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"'async with' received an object from __aexit__ \"\n                          \"that does not implement __await__: %.100s\",\n                          type->tp_name);\n        }\n    }\n}\n\n\nPy_ssize_t\nPyUnstable_Eval_RequestCodeExtraIndex(freefunc free)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    Py_ssize_t new_index;\n\n    if (interp->co_extra_user_count == MAX_CO_EXTRA_USERS - 1) {\n        return -1;\n    }\n    new_index = interp->co_extra_user_count++;\n    interp->co_extra_freefuncs[new_index] = free;\n    return new_index;\n}\n\n/* Implement Py_EnterRecursiveCall() and Py_LeaveRecursiveCall() as functions\n   for the limited API. */\n\nint Py_EnterRecursiveCall(const char *where)\n{\n    return _Py_EnterRecursiveCall(where);\n}\n\nvoid Py_LeaveRecursiveCall(void)\n{\n    _Py_LeaveRecursiveCall();\n}\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "Python/generated_cases.c.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "// This file is generated by Tools/cases_generator/tier1_generator.py\n// from:\n//   Python/bytecodes.c\n// Do not edit!\n\n#ifdef TIER_TWO\n    #error \"This file is for Tier 1 only\"\n#endif\n#define TIER_ONE 1\n\n\n        TARGET(BEFORE_ASYNC_WITH) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(BEFORE_ASYNC_WITH);\n            PyObject *mgr;\n            PyObject *exit;\n            PyObject *res;\n            mgr = stack_pointer[-1];\n            PyObject *enter = _PyObject_LookupSpecial(mgr, &_Py_ID(__aenter__));\n            if (enter == NULL) {\n                if (!_PyErr_Occurred(tstate)) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"'%.200s' object does not support the \"\n                                  \"asynchronous context manager protocol\",\n                                  Py_TYPE(mgr)->tp_name);\n                }\n                goto error;\n            }\n            exit = _PyObject_LookupSpecial(mgr, &_Py_ID(__aexit__));\n            if (exit == NULL) {\n                if (!_PyErr_Occurred(tstate)) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"'%.200s' object does not support the \"\n                                  \"asynchronous context manager protocol \"\n                                  \"(missed __aexit__ method)\",\n                                  Py_TYPE(mgr)->tp_name);\n                }\n                Py_DECREF(enter);\n                goto error;\n            }\n            Py_DECREF(mgr);\n            res = PyObject_CallNoArgs(enter);\n            Py_DECREF(enter);\n            if (res == NULL) {\n                Py_DECREF(exit);\n                if (true) goto pop_1_error;\n            }\n            stack_pointer[-1] = exit;\n            stack_pointer[0] = res;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(BEFORE_WITH) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(BEFORE_WITH);\n            PyObject *mgr;\n            PyObject *exit;\n            PyObject *res;\n            mgr = stack_pointer[-1];\n            /* pop the context manager, push its __exit__ and the\n             * value returned from calling its __enter__\n             */\n            PyObject *enter = _PyObject_LookupSpecial(mgr, &_Py_ID(__enter__));\n            if (enter == NULL) {\n                if (!_PyErr_Occurred(tstate)) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"'%.200s' object does not support the \"\n                                  \"context manager protocol\",\n                                  Py_TYPE(mgr)->tp_name);\n                }\n                goto error;\n            }\n            exit = _PyObject_LookupSpecial(mgr, &_Py_ID(__exit__));\n            if (exit == NULL) {\n                if (!_PyErr_Occurred(tstate)) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"'%.200s' object does not support the \"\n                                  \"context manager protocol \"\n                                  \"(missed __exit__ method)\",\n                                  Py_TYPE(mgr)->tp_name);\n                }\n                Py_DECREF(enter);\n                goto error;\n            }\n            Py_DECREF(mgr);\n            res = PyObject_CallNoArgs(enter);\n            Py_DECREF(enter);\n            if (res == NULL) {\n                Py_DECREF(exit);\n                if (true) goto pop_1_error;\n            }\n            stack_pointer[-1] = exit;\n            stack_pointer[0] = res;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_OP) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_OP);\n            PREDICTED(BINARY_OP);\n            _Py_CODEUNIT *this_instr = next_instr - 2;\n            (void)this_instr;\n            PyObject *rhs;\n            PyObject *lhs;\n            PyObject *res;\n            // _SPECIALIZE_BINARY_OP\n            rhs = stack_pointer[-1];\n            lhs = stack_pointer[-2];\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    next_instr = this_instr;\n                    _Py_Specialize_BinaryOp(lhs, rhs, next_instr, oparg, LOCALS_ARRAY);\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(BINARY_OP, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n                assert(NB_ADD <= oparg);\n                assert(oparg <= NB_INPLACE_XOR);\n            }\n            // _BINARY_OP\n            {\n                assert(_PyEval_BinaryOps[oparg]);\n                res = _PyEval_BinaryOps[oparg](lhs, rhs);\n                Py_DECREF(lhs);\n                Py_DECREF(rhs);\n                if (res == NULL) goto pop_2_error;\n            }\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_OP_ADD_FLOAT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_OP_ADD_FLOAT);\n            static_assert(INLINE_CACHE_ENTRIES_BINARY_OP == 1, \"incorrect cache size\");\n            PyObject *right;\n            PyObject *left;\n            PyObject *res;\n            // _GUARD_BOTH_FLOAT\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            {\n                DEOPT_IF(!PyFloat_CheckExact(left), BINARY_OP);\n                DEOPT_IF(!PyFloat_CheckExact(right), BINARY_OP);\n            }\n            /* Skip 1 cache entry */\n            // _BINARY_OP_ADD_FLOAT\n            {\n                STAT_INC(BINARY_OP, hit);\n                double dres =\n                ((PyFloatObject *)left)->ob_fval +\n                ((PyFloatObject *)right)->ob_fval;\n                DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);\n            }\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_OP_ADD_INT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_OP_ADD_INT);\n            static_assert(INLINE_CACHE_ENTRIES_BINARY_OP == 1, \"incorrect cache size\");\n            PyObject *right;\n            PyObject *left;\n            PyObject *res;\n            // _GUARD_BOTH_INT\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            {\n                DEOPT_IF(!PyLong_CheckExact(left), BINARY_OP);\n                DEOPT_IF(!PyLong_CheckExact(right), BINARY_OP);\n            }\n            /* Skip 1 cache entry */\n            // _BINARY_OP_ADD_INT\n            {\n                STAT_INC(BINARY_OP, hit);\n                res = _PyLong_Add((PyLongObject *)left, (PyLongObject *)right);\n                _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);\n                _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);\n                if (res == NULL) goto pop_2_error;\n            }\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_OP_ADD_UNICODE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_OP_ADD_UNICODE);\n            static_assert(INLINE_CACHE_ENTRIES_BINARY_OP == 1, \"incorrect cache size\");\n            PyObject *right;\n            PyObject *left;\n            PyObject *res;\n            // _GUARD_BOTH_UNICODE\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            {\n                DEOPT_IF(!PyUnicode_CheckExact(left), BINARY_OP);\n                DEOPT_IF(!PyUnicode_CheckExact(right), BINARY_OP);\n            }\n            /* Skip 1 cache entry */\n            // _BINARY_OP_ADD_UNICODE\n            {\n                STAT_INC(BINARY_OP, hit);\n                res = PyUnicode_Concat(left, right);\n                _Py_DECREF_SPECIALIZED(left, _PyUnicode_ExactDealloc);\n                _Py_DECREF_SPECIALIZED(right, _PyUnicode_ExactDealloc);\n                if (res == NULL) goto pop_2_error;\n            }\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_OP_INPLACE_ADD_UNICODE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_OP_INPLACE_ADD_UNICODE);\n            static_assert(INLINE_CACHE_ENTRIES_BINARY_OP == 1, \"incorrect cache size\");\n            PyObject *right;\n            PyObject *left;\n            // _GUARD_BOTH_UNICODE\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            {\n                DEOPT_IF(!PyUnicode_CheckExact(left), BINARY_OP);\n                DEOPT_IF(!PyUnicode_CheckExact(right), BINARY_OP);\n            }\n            /* Skip 1 cache entry */\n            // _BINARY_OP_INPLACE_ADD_UNICODE\n            {\n                assert(next_instr->op.code == STORE_FAST);\n                PyObject **target_local = &GETLOCAL(next_instr->op.arg);\n                DEOPT_IF(*target_local != left, BINARY_OP);\n                STAT_INC(BINARY_OP, hit);\n                /* Handle `left = left + right` or `left += right` for str.\n                 *\n                 * When possible, extend `left` in place rather than\n                 * allocating a new PyUnicodeObject. This attempts to avoid\n                 * quadratic behavior when one neglects to use str.join().\n                 *\n                 * If `left` has only two references remaining (one from\n                 * the stack, one in the locals), DECREFing `left` leaves\n                 * only the locals reference, so PyUnicode_Append knows\n                 * that the string is safe to mutate.\n                 */\n                assert(Py_REFCNT(left) >= 2);\n                _Py_DECREF_NO_DEALLOC(left);\n                PyUnicode_Append(target_local, right);\n                _Py_DECREF_SPECIALIZED(right, _PyUnicode_ExactDealloc);\n                if (*target_local == NULL) goto pop_2_error;\n                // The STORE_FAST is already done.\n                assert(next_instr->op.code == STORE_FAST);\n                SKIP_OVER(1);\n            }\n            stack_pointer += -2;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_OP_MULTIPLY_FLOAT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_OP_MULTIPLY_FLOAT);\n            static_assert(INLINE_CACHE_ENTRIES_BINARY_OP == 1, \"incorrect cache size\");\n            PyObject *right;\n            PyObject *left;\n            PyObject *res;\n            // _GUARD_BOTH_FLOAT\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            {\n                DEOPT_IF(!PyFloat_CheckExact(left), BINARY_OP);\n                DEOPT_IF(!PyFloat_CheckExact(right), BINARY_OP);\n            }\n            /* Skip 1 cache entry */\n            // _BINARY_OP_MULTIPLY_FLOAT\n            {\n                STAT_INC(BINARY_OP, hit);\n                double dres =\n                ((PyFloatObject *)left)->ob_fval *\n                ((PyFloatObject *)right)->ob_fval;\n                DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);\n            }\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_OP_MULTIPLY_INT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_OP_MULTIPLY_INT);\n            static_assert(INLINE_CACHE_ENTRIES_BINARY_OP == 1, \"incorrect cache size\");\n            PyObject *right;\n            PyObject *left;\n            PyObject *res;\n            // _GUARD_BOTH_INT\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            {\n                DEOPT_IF(!PyLong_CheckExact(left), BINARY_OP);\n                DEOPT_IF(!PyLong_CheckExact(right), BINARY_OP);\n            }\n            /* Skip 1 cache entry */\n            // _BINARY_OP_MULTIPLY_INT\n            {\n                STAT_INC(BINARY_OP, hit);\n                res = _PyLong_Multiply((PyLongObject *)left, (PyLongObject *)right);\n                _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);\n                _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);\n                if (res == NULL) goto pop_2_error;\n            }\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_OP_SUBTRACT_FLOAT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_OP_SUBTRACT_FLOAT);\n            static_assert(INLINE_CACHE_ENTRIES_BINARY_OP == 1, \"incorrect cache size\");\n            PyObject *right;\n            PyObject *left;\n            PyObject *res;\n            // _GUARD_BOTH_FLOAT\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            {\n                DEOPT_IF(!PyFloat_CheckExact(left), BINARY_OP);\n                DEOPT_IF(!PyFloat_CheckExact(right), BINARY_OP);\n            }\n            /* Skip 1 cache entry */\n            // _BINARY_OP_SUBTRACT_FLOAT\n            {\n                STAT_INC(BINARY_OP, hit);\n                double dres =\n                ((PyFloatObject *)left)->ob_fval -\n                ((PyFloatObject *)right)->ob_fval;\n                DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);\n            }\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_OP_SUBTRACT_INT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_OP_SUBTRACT_INT);\n            static_assert(INLINE_CACHE_ENTRIES_BINARY_OP == 1, \"incorrect cache size\");\n            PyObject *right;\n            PyObject *left;\n            PyObject *res;\n            // _GUARD_BOTH_INT\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            {\n                DEOPT_IF(!PyLong_CheckExact(left), BINARY_OP);\n                DEOPT_IF(!PyLong_CheckExact(right), BINARY_OP);\n            }\n            /* Skip 1 cache entry */\n            // _BINARY_OP_SUBTRACT_INT\n            {\n                STAT_INC(BINARY_OP, hit);\n                res = _PyLong_Subtract((PyLongObject *)left, (PyLongObject *)right);\n                _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);\n                _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);\n                if (res == NULL) goto pop_2_error;\n            }\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_SLICE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(BINARY_SLICE);\n            PyObject *stop;\n            PyObject *start;\n            PyObject *container;\n            PyObject *res;\n            stop = stack_pointer[-1];\n            start = stack_pointer[-2];\n            container = stack_pointer[-3];\n            PyObject *slice = _PyBuildSlice_ConsumeRefs(start, stop);\n            // Can't use ERROR_IF() here, because we haven't\n            // DECREF'ed container yet, and we still own slice.\n            if (slice == NULL) {\n                res = NULL;\n            }\n            else {\n                res = PyObject_GetItem(container, slice);\n                Py_DECREF(slice);\n            }\n            Py_DECREF(container);\n            if (res == NULL) goto pop_3_error;\n            stack_pointer[-3] = res;\n            stack_pointer += -2;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_SUBSCR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_SUBSCR);\n            PREDICTED(BINARY_SUBSCR);\n            _Py_CODEUNIT *this_instr = next_instr - 2;\n            (void)this_instr;\n            PyObject *sub;\n            PyObject *container;\n            PyObject *res;\n            // _SPECIALIZE_BINARY_SUBSCR\n            sub = stack_pointer[-1];\n            container = stack_pointer[-2];\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    next_instr = this_instr;\n                    _Py_Specialize_BinarySubscr(container, sub, next_instr);\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(BINARY_SUBSCR, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n            }\n            // _BINARY_SUBSCR\n            {\n                res = PyObject_GetItem(container, sub);\n                Py_DECREF(container);\n                Py_DECREF(sub);\n                if (res == NULL) goto pop_2_error;\n            }\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_SUBSCR_DICT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_SUBSCR_DICT);\n            static_assert(INLINE_CACHE_ENTRIES_BINARY_SUBSCR == 1, \"incorrect cache size\");\n            PyObject *sub;\n            PyObject *dict;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            sub = stack_pointer[-1];\n            dict = stack_pointer[-2];\n            DEOPT_IF(!PyDict_CheckExact(dict), BINARY_SUBSCR);\n            STAT_INC(BINARY_SUBSCR, hit);\n            int rc = PyDict_GetItemRef(dict, sub, &res);\n            if (rc == 0) {\n                _PyErr_SetKeyError(sub);\n            }\n            Py_DECREF(dict);\n            Py_DECREF(sub);\n            if (rc <= 0) goto pop_2_error;\n            // not found or error\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_SUBSCR_GETITEM) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_SUBSCR_GETITEM);\n            static_assert(INLINE_CACHE_ENTRIES_BINARY_SUBSCR == 1, \"incorrect cache size\");\n            PyObject *sub;\n            PyObject *container;\n            /* Skip 1 cache entry */\n            sub = stack_pointer[-1];\n            container = stack_pointer[-2];\n            DEOPT_IF(tstate->interp->eval_frame, BINARY_SUBSCR);\n            PyTypeObject *tp = Py_TYPE(container);\n            DEOPT_IF(!PyType_HasFeature(tp, Py_TPFLAGS_HEAPTYPE), BINARY_SUBSCR);\n            PyHeapTypeObject *ht = (PyHeapTypeObject *)tp;\n            PyObject *cached = ht->_spec_cache.getitem;\n            DEOPT_IF(cached == NULL, BINARY_SUBSCR);\n            assert(PyFunction_Check(cached));\n            PyFunctionObject *getitem = (PyFunctionObject *)cached;\n            uint32_t cached_version = ht->_spec_cache.getitem_version;\n            DEOPT_IF(getitem->func_version != cached_version, BINARY_SUBSCR);\n            PyCodeObject *code = (PyCodeObject *)getitem->func_code;\n            assert(code->co_argcount == 2);\n            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), BINARY_SUBSCR);\n            STAT_INC(BINARY_SUBSCR, hit);\n            Py_INCREF(getitem);\n            _PyInterpreterFrame *new_frame = _PyFrame_PushUnchecked(tstate, getitem, 2);\n            STACK_SHRINK(2);\n            new_frame->localsplus[0] = container;\n            new_frame->localsplus[1] = sub;\n            frame->return_offset = (uint16_t)(next_instr - this_instr);\n            DISPATCH_INLINED(new_frame);\n        }\n\n        TARGET(BINARY_SUBSCR_LIST_INT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_SUBSCR_LIST_INT);\n            static_assert(INLINE_CACHE_ENTRIES_BINARY_SUBSCR == 1, \"incorrect cache size\");\n            PyObject *sub;\n            PyObject *list;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            sub = stack_pointer[-1];\n            list = stack_pointer[-2];\n            DEOPT_IF(!PyLong_CheckExact(sub), BINARY_SUBSCR);\n            DEOPT_IF(!PyList_CheckExact(list), BINARY_SUBSCR);\n            // Deopt unless 0 <= sub < PyList_Size(list)\n            DEOPT_IF(!_PyLong_IsNonNegativeCompact((PyLongObject *)sub), BINARY_SUBSCR);\n            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];\n            DEOPT_IF(index >= PyList_GET_SIZE(list), BINARY_SUBSCR);\n            STAT_INC(BINARY_SUBSCR, hit);\n            res = PyList_GET_ITEM(list, index);\n            assert(res != NULL);\n            Py_INCREF(res);\n            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);\n            Py_DECREF(list);\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_SUBSCR_STR_INT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_SUBSCR_STR_INT);\n            static_assert(INLINE_CACHE_ENTRIES_BINARY_SUBSCR == 1, \"incorrect cache size\");\n            PyObject *sub;\n            PyObject *str;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            sub = stack_pointer[-1];\n            str = stack_pointer[-2];\n            DEOPT_IF(!PyLong_CheckExact(sub), BINARY_SUBSCR);\n            DEOPT_IF(!PyUnicode_CheckExact(str), BINARY_SUBSCR);\n            DEOPT_IF(!_PyLong_IsNonNegativeCompact((PyLongObject *)sub), BINARY_SUBSCR);\n            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];\n            DEOPT_IF(PyUnicode_GET_LENGTH(str) <= index, BINARY_SUBSCR);\n            // Specialize for reading an ASCII character from any string:\n            Py_UCS4 c = PyUnicode_READ_CHAR(str, index);\n            DEOPT_IF(Py_ARRAY_LENGTH(_Py_SINGLETON(strings).ascii) <= c, BINARY_SUBSCR);\n            STAT_INC(BINARY_SUBSCR, hit);\n            res = (PyObject*)&_Py_SINGLETON(strings).ascii[c];\n            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);\n            Py_DECREF(str);\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(BINARY_SUBSCR_TUPLE_INT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(BINARY_SUBSCR_TUPLE_INT);\n            static_assert(INLINE_CACHE_ENTRIES_BINARY_SUBSCR == 1, \"incorrect cache size\");\n            PyObject *sub;\n            PyObject *tuple;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            sub = stack_pointer[-1];\n            tuple = stack_pointer[-2];\n            DEOPT_IF(!PyLong_CheckExact(sub), BINARY_SUBSCR);\n            DEOPT_IF(!PyTuple_CheckExact(tuple), BINARY_SUBSCR);\n            // Deopt unless 0 <= sub < PyTuple_Size(list)\n            DEOPT_IF(!_PyLong_IsNonNegativeCompact((PyLongObject *)sub), BINARY_SUBSCR);\n            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];\n            DEOPT_IF(index >= PyTuple_GET_SIZE(tuple), BINARY_SUBSCR);\n            STAT_INC(BINARY_SUBSCR, hit);\n            res = PyTuple_GET_ITEM(tuple, index);\n            assert(res != NULL);\n            Py_INCREF(res);\n            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);\n            Py_DECREF(tuple);\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(BUILD_CONST_KEY_MAP) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(BUILD_CONST_KEY_MAP);\n            PyObject *keys;\n            PyObject **values;\n            PyObject *map;\n            keys = stack_pointer[-1];\n            values = &stack_pointer[-1 - oparg];\n            assert(PyTuple_CheckExact(keys));\n            assert(PyTuple_GET_SIZE(keys) == (Py_ssize_t)oparg);\n            map = _PyDict_FromItems(\n                                    &PyTuple_GET_ITEM(keys, 0), 1,\n                                    values, 1, oparg);\n            for (int _i = oparg; --_i >= 0;) {\n                Py_DECREF(values[_i]);\n            }\n            Py_DECREF(keys);\n            if (map == NULL) { stack_pointer += -1 - oparg; goto error; }\n            stack_pointer[-1 - oparg] = map;\n            stack_pointer += -oparg;\n            DISPATCH();\n        }\n\n        TARGET(BUILD_LIST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(BUILD_LIST);\n            PyObject **values;\n            PyObject *list;\n            values = &stack_pointer[-oparg];\n            list = _PyList_FromArraySteal(values, oparg);\n            if (list == NULL) { stack_pointer += -oparg; goto error; }\n            stack_pointer[-oparg] = list;\n            stack_pointer += 1 - oparg;\n            DISPATCH();\n        }\n\n        TARGET(BUILD_MAP) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(BUILD_MAP);\n            PyObject **values;\n            PyObject *map;\n            values = &stack_pointer[-oparg*2];\n            map = _PyDict_FromItems(\n                                    values, 2,\n                                    values+1, 2,\n                                    oparg);\n            for (int _i = oparg*2; --_i >= 0;) {\n                Py_DECREF(values[_i]);\n            }\n            if (map == NULL) { stack_pointer += -oparg*2; goto error; }\n            stack_pointer[-oparg*2] = map;\n            stack_pointer += 1 - oparg*2;\n            DISPATCH();\n        }\n\n        TARGET(BUILD_SET) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(BUILD_SET);\n            PyObject **values;\n            PyObject *set;\n            values = &stack_pointer[-oparg];\n            set = PySet_New(NULL);\n            if (set == NULL)\n            goto error;\n            int err = 0;\n            for (int i = 0; i < oparg; i++) {\n                PyObject *item = values[i];\n                if (err == 0)\n                err = PySet_Add(set, item);\n                Py_DECREF(item);\n            }\n            if (err != 0) {\n                Py_DECREF(set);\n                if (true) { stack_pointer += -oparg; goto error; }\n            }\n            stack_pointer[-oparg] = set;\n            stack_pointer += 1 - oparg;\n            DISPATCH();\n        }\n\n        TARGET(BUILD_SLICE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(BUILD_SLICE);\n            PyObject *step = NULL;\n            PyObject *stop;\n            PyObject *start;\n            PyObject *slice;\n            if (oparg == 3) { step = stack_pointer[-((oparg == 3) ? 1 : 0)]; }\n            stop = stack_pointer[-1 - ((oparg == 3) ? 1 : 0)];\n            start = stack_pointer[-2 - ((oparg == 3) ? 1 : 0)];\n            slice = PySlice_New(start, stop, step);\n            Py_DECREF(start);\n            Py_DECREF(stop);\n            Py_XDECREF(step);\n            if (slice == NULL) { stack_pointer += -2 - ((oparg == 3) ? 1 : 0); goto error; }\n            stack_pointer[-2 - ((oparg == 3) ? 1 : 0)] = slice;\n            stack_pointer += -1 - ((oparg == 3) ? 1 : 0);\n            DISPATCH();\n        }\n\n        TARGET(BUILD_STRING) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(BUILD_STRING);\n            PyObject **pieces;\n            PyObject *str;\n            pieces = &stack_pointer[-oparg];\n            str = _PyUnicode_JoinArray(&_Py_STR(empty), pieces, oparg);\n            for (int _i = oparg; --_i >= 0;) {\n                Py_DECREF(pieces[_i]);\n            }\n            if (str == NULL) { stack_pointer += -oparg; goto error; }\n            stack_pointer[-oparg] = str;\n            stack_pointer += 1 - oparg;\n            DISPATCH();\n        }\n\n        TARGET(BUILD_TUPLE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(BUILD_TUPLE);\n            PyObject **values;\n            PyObject *tup;\n            values = &stack_pointer[-oparg];\n            tup = _PyTuple_FromArraySteal(values, oparg);\n            if (tup == NULL) { stack_pointer += -oparg; goto error; }\n            stack_pointer[-oparg] = tup;\n            stack_pointer += 1 - oparg;\n            DISPATCH();\n        }\n\n        TARGET(CACHE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(CACHE);\n            assert(0 && \"Executing a cache.\");\n            Py_FatalError(\"Executing a cache.\");\n            DISPATCH();\n        }\n\n        TARGET(CALL) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL);\n            PREDICTED(CALL);\n            _Py_CODEUNIT *this_instr = next_instr - 4;\n            (void)this_instr;\n            PyObject **args;\n            PyObject *self_or_null;\n            PyObject *callable;\n            PyObject *res;\n            // _SPECIALIZE_CALL\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    next_instr = this_instr;\n                    _Py_Specialize_Call(callable, next_instr, oparg + (self_or_null != NULL));\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(CALL, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n            }\n            /* Skip 2 cache entries */\n            // _CALL\n            {\n                // oparg counts all of the args, but *not* self:\n                int total_args = oparg;\n                if (self_or_null != NULL) {\n                    args--;\n                    total_args++;\n                }\n                else if (Py_TYPE(callable) == &PyMethod_Type) {\n                    args--;\n                    total_args++;\n                    PyObject *self = ((PyMethodObject *)callable)->im_self;\n                    args[0] = Py_NewRef(self);\n                    PyObject *method = ((PyMethodObject *)callable)->im_func;\n                    args[-1] = Py_NewRef(method);\n                    Py_DECREF(callable);\n                    callable = method;\n                }\n                // Check if the call can be inlined or not\n                if (Py_TYPE(callable) == &PyFunction_Type &&\n                    tstate->interp->eval_frame == NULL &&\n                    ((PyFunctionObject *)callable)->vectorcall == _PyFunction_Vectorcall)\n                {\n                    int code_flags = ((PyCodeObject*)PyFunction_GET_CODE(callable))->co_flags;\n                    PyObject *locals = code_flags & CO_OPTIMIZED ? NULL : Py_NewRef(PyFunction_GET_GLOBALS(callable));\n                    _PyInterpreterFrame *new_frame = _PyEvalFramePushAndInit(\n                        tstate, (PyFunctionObject *)callable, locals,\n                        args, total_args, NULL\n                    );\n                    // Manipulate stack directly since we leave using DISPATCH_INLINED().\n                    STACK_SHRINK(oparg + 2);\n                    // The frame has stolen all the arguments from the stack,\n                    // so there is no need to clean them up.\n                    if (new_frame == NULL) {\n                        goto error;\n                    }\n                    frame->return_offset = (uint16_t)(next_instr - this_instr);\n                    DISPATCH_INLINED(new_frame);\n                }\n                /* Callable is not a normal Python function */\n                res = PyObject_Vectorcall(\n                                      callable, args,\n                                      total_args | PY_VECTORCALL_ARGUMENTS_OFFSET,\n                                      NULL);\n                if (opcode == INSTRUMENTED_CALL) {\n                    PyObject *arg = total_args == 0 ?\n                    &_PyInstrumentation_MISSING : args[0];\n                    if (res == NULL) {\n                        _Py_call_instrumentation_exc2(\n                            tstate, PY_MONITORING_EVENT_C_RAISE,\n                            frame, this_instr, callable, arg);\n                    }\n                    else {\n                        int err = _Py_call_instrumentation_2args(\n                            tstate, PY_MONITORING_EVENT_C_RETURN,\n                            frame, this_instr, callable, arg);\n                        if (err < 0) {\n                            Py_CLEAR(res);\n                        }\n                    }\n                }\n                assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n                Py_DECREF(callable);\n                for (int i = 0; i < total_args; i++) {\n                    Py_DECREF(args[i]);\n                }\n                if (res == NULL) { stack_pointer += -2 - oparg; goto error; }\n            }\n            // _CHECK_PERIODIC\n            {\n            }\n            stack_pointer[-2 - oparg] = res;\n            stack_pointer += -1 - oparg;\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_ALLOC_AND_ENTER_INIT) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_ALLOC_AND_ENTER_INIT);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject **args;\n            PyObject *null;\n            PyObject *callable;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            args = &stack_pointer[-oparg];\n            null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            /* This instruction does the following:\n             * 1. Creates the object (by calling ``object.__new__``)\n             * 2. Pushes a shim frame to the frame stack (to cleanup after ``__init__``)\n             * 3. Pushes the frame for ``__init__`` to the frame stack\n             * */\n            _PyCallCache *cache = (_PyCallCache *)&this_instr[1];\n            DEOPT_IF(null != NULL, CALL);\n            DEOPT_IF(!PyType_Check(callable), CALL);\n            PyTypeObject *tp = (PyTypeObject *)callable;\n            DEOPT_IF(tp->tp_version_tag != read_u32(cache->func_version), CALL);\n            assert(tp->tp_flags & Py_TPFLAGS_INLINE_VALUES);\n            PyHeapTypeObject *cls = (PyHeapTypeObject *)callable;\n            PyFunctionObject *init = (PyFunctionObject *)cls->_spec_cache.init;\n            PyCodeObject *code = (PyCodeObject *)init->func_code;\n            DEOPT_IF(code->co_argcount != oparg+1, CALL);\n            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize + _Py_InitCleanup.co_framesize), CALL);\n            STAT_INC(CALL, hit);\n            PyObject *self = _PyType_NewManagedObject(tp);\n            if (self == NULL) {\n                goto error;\n            }\n            Py_DECREF(tp);\n            _PyInterpreterFrame *shim = _PyFrame_PushTrampolineUnchecked(\n                tstate, (PyCodeObject *)&_Py_InitCleanup, 1);\n            assert(_PyCode_CODE((PyCodeObject *)shim->f_executable)[0].op.code == EXIT_INIT_CHECK);\n            /* Push self onto stack of shim */\n            Py_INCREF(self);\n            shim->localsplus[0] = self;\n            Py_INCREF(init);\n            _PyInterpreterFrame *init_frame = _PyFrame_PushUnchecked(tstate, init, oparg+1);\n            /* Copy self followed by args to __init__ frame */\n            init_frame->localsplus[0] = self;\n            for (int i = 0; i < oparg; i++) {\n                init_frame->localsplus[i+1] = args[i];\n            }\n            frame->return_offset = (uint16_t)(next_instr - this_instr);\n            STACK_SHRINK(oparg+2);\n            _PyFrame_SetStackPointer(frame, stack_pointer);\n            /* Link frames */\n            init_frame->previous = shim;\n            shim->previous = frame;\n            frame = tstate->current_frame = init_frame;\n            CALL_STAT_INC(inlined_py_calls);\n            /* Account for pushing the extra frame.\n             * We don't check recursion depth here,\n             * as it will be checked after start_frame */\n            tstate->py_recursion_remaining--;\n            goto start_frame;\n        }\n\n        TARGET(CALL_BOUND_METHOD_EXACT_ARGS) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_BOUND_METHOD_EXACT_ARGS);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject *null;\n            PyObject *callable;\n            PyObject *func;\n            PyObject *self;\n            PyObject *self_or_null;\n            PyObject **args;\n            _PyInterpreterFrame *new_frame;\n            /* Skip 1 cache entry */\n            // _CHECK_PEP_523\n            {\n                DEOPT_IF(tstate->interp->eval_frame, CALL);\n            }\n            // _CHECK_CALL_BOUND_METHOD_EXACT_ARGS\n            null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            {\n                DEOPT_IF(null != NULL, CALL);\n                DEOPT_IF(Py_TYPE(callable) != &PyMethod_Type, CALL);\n            }\n            // _INIT_CALL_BOUND_METHOD_EXACT_ARGS\n            {\n                STAT_INC(CALL, hit);\n                self = Py_NewRef(((PyMethodObject *)callable)->im_self);\n                stack_pointer[-1 - oparg] = self;  // Patch stack as it is used by _INIT_CALL_PY_EXACT_ARGS\n                func = Py_NewRef(((PyMethodObject *)callable)->im_func);\n                stack_pointer[-2 - oparg] = func;  // This is used by CALL, upon deoptimization\n                Py_DECREF(callable);\n            }\n            // _CHECK_FUNCTION_EXACT_ARGS\n            self_or_null = self;\n            callable = func;\n            {\n                uint32_t func_version = read_u32(&this_instr[2].cache);\n                DEOPT_IF(!PyFunction_Check(callable), CALL);\n                PyFunctionObject *func = (PyFunctionObject *)callable;\n                DEOPT_IF(func->func_version != func_version, CALL);\n                PyCodeObject *code = (PyCodeObject *)func->func_code;\n                DEOPT_IF(code->co_argcount != oparg + (self_or_null != NULL), CALL);\n            }\n            // _CHECK_STACK_SPACE\n            {\n                PyFunctionObject *func = (PyFunctionObject *)callable;\n                PyCodeObject *code = (PyCodeObject *)func->func_code;\n                DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), CALL);\n                DEOPT_IF(tstate->py_recursion_remaining <= 1, CALL);\n            }\n            // _INIT_CALL_PY_EXACT_ARGS\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            {\n                int has_self = (self_or_null != NULL);\n                STAT_INC(CALL, hit);\n                PyFunctionObject *func = (PyFunctionObject *)callable;\n                new_frame = _PyFrame_PushUnchecked(tstate, func, oparg + has_self);\n                PyObject **first_non_self_local = new_frame->localsplus + has_self;\n                new_frame->localsplus[0] = self_or_null;\n                for (int i = 0; i < oparg; i++) {\n                    first_non_self_local[i] = args[i];\n                }\n            }\n            // _SAVE_RETURN_OFFSET\n            {\n                #if TIER_ONE\n                frame->return_offset = (uint16_t)(next_instr - this_instr);\n                #endif\n                #if TIER_TWO\n                frame->return_offset = oparg;\n                #endif\n            }\n            // _PUSH_FRAME\n            {\n                // Write it out explicitly because it's subtly different.\n                // Eventually this should be the only occurrence of this code.\n                assert(tstate->interp->eval_frame == NULL);\n                stack_pointer += -2 - oparg;\n                _PyFrame_SetStackPointer(frame, stack_pointer);\n                new_frame->previous = frame;\n                CALL_STAT_INC(inlined_py_calls);\n                frame = tstate->current_frame = new_frame;\n                tstate->py_recursion_remaining--;\n                LOAD_SP();\n                LOAD_IP(0);\n                LLTRACE_RESUME_FRAME();\n            }\n            DISPATCH();\n        }\n\n        TARGET(CALL_BOUND_METHOD_GENERAL) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_BOUND_METHOD_GENERAL);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject *null;\n            PyObject *callable;\n            PyObject *method;\n            PyObject *self;\n            PyObject **args;\n            PyObject *self_or_null;\n            _PyInterpreterFrame *new_frame;\n            /* Skip 1 cache entry */\n            // _CHECK_PEP_523\n            {\n                DEOPT_IF(tstate->interp->eval_frame, CALL);\n            }\n            // _CHECK_METHOD_VERSION\n            null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            {\n                uint32_t func_version = read_u32(&this_instr[2].cache);\n                DEOPT_IF(Py_TYPE(callable) != &PyMethod_Type, CALL);\n                PyObject *func = ((PyMethodObject *)callable)->im_func;\n                DEOPT_IF(!PyFunction_Check(func), CALL);\n                DEOPT_IF(((PyFunctionObject *)func)->func_version != func_version, CALL);\n                DEOPT_IF(null != NULL, CALL);\n            }\n            // _EXPAND_METHOD\n            {\n                assert(null == NULL);\n                assert(Py_TYPE(callable) == &PyMethod_Type);\n                self = ((PyMethodObject *)callable)->im_self;\n                Py_INCREF(self);\n                stack_pointer[-1 - oparg] = self;  // Patch stack as it is used by _PY_FRAME_GENERAL\n                method = ((PyMethodObject *)callable)->im_func;\n                assert(PyFunction_Check(method));\n                Py_INCREF(method);\n                Py_DECREF(callable);\n            }\n            // _PY_FRAME_GENERAL\n            args = &stack_pointer[-oparg];\n            self_or_null = self;\n            callable = method;\n            {\n                // oparg counts all of the args, but *not* self:\n                int total_args = oparg;\n                if (self_or_null != NULL) {\n                    args--;\n                    total_args++;\n                }\n                assert(Py_TYPE(callable) == &PyFunction_Type);\n                int code_flags = ((PyCodeObject*)PyFunction_GET_CODE(callable))->co_flags;\n                PyObject *locals = code_flags & CO_OPTIMIZED ? NULL : Py_NewRef(PyFunction_GET_GLOBALS(callable));\n                new_frame = _PyEvalFramePushAndInit(\n                    tstate, (PyFunctionObject *)callable, locals,\n                    args, total_args, NULL\n                );\n                // The frame has stolen all the arguments from the stack,\n                // so there is no need to clean them up.\n                stack_pointer += -2 - oparg;\n                if (new_frame == NULL) {\n                    goto error;\n                }\n            }\n            // _SAVE_RETURN_OFFSET\n            {\n                #if TIER_ONE\n                frame->return_offset = (uint16_t)(next_instr - this_instr);\n                #endif\n                #if TIER_TWO\n                frame->return_offset = oparg;\n                #endif\n            }\n            // _PUSH_FRAME\n            {\n                // Write it out explicitly because it's subtly different.\n                // Eventually this should be the only occurrence of this code.\n                assert(tstate->interp->eval_frame == NULL);\n                _PyFrame_SetStackPointer(frame, stack_pointer);\n                new_frame->previous = frame;\n                CALL_STAT_INC(inlined_py_calls);\n                frame = tstate->current_frame = new_frame;\n                tstate->py_recursion_remaining--;\n                LOAD_SP();\n                LOAD_IP(0);\n                LLTRACE_RESUME_FRAME();\n            }\n            DISPATCH();\n        }\n\n        TARGET(CALL_BUILTIN_CLASS) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_BUILTIN_CLASS);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject **args;\n            PyObject *self_or_null;\n            PyObject *callable;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            // _CALL_BUILTIN_CLASS\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            {\n                int total_args = oparg;\n                if (self_or_null != NULL) {\n                    args--;\n                    total_args++;\n                }\n                DEOPT_IF(!PyType_Check(callable), CALL);\n                PyTypeObject *tp = (PyTypeObject *)callable;\n                DEOPT_IF(tp->tp_vectorcall == NULL, CALL);\n                STAT_INC(CALL, hit);\n                res = tp->tp_vectorcall((PyObject *)tp, args, total_args, NULL);\n                /* Free the arguments. */\n                for (int i = 0; i < total_args; i++) {\n                    Py_DECREF(args[i]);\n                }\n                Py_DECREF(tp);\n                if (res == NULL) { stack_pointer += -2 - oparg; goto error; }\n            }\n            // _CHECK_PERIODIC\n            {\n            }\n            stack_pointer[-2 - oparg] = res;\n            stack_pointer += -1 - oparg;\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_BUILTIN_FAST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_BUILTIN_FAST);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject **args;\n            PyObject *self_or_null;\n            PyObject *callable;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            // _CALL_BUILTIN_FAST\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            {\n                /* Builtin METH_FASTCALL functions, without keywords */\n                int total_args = oparg;\n                if (self_or_null != NULL) {\n                    args--;\n                    total_args++;\n                }\n                DEOPT_IF(!PyCFunction_CheckExact(callable), CALL);\n                DEOPT_IF(PyCFunction_GET_FLAGS(callable) != METH_FASTCALL, CALL);\n                STAT_INC(CALL, hit);\n                PyCFunction cfunc = PyCFunction_GET_FUNCTION(callable);\n                /* res = func(self, args, nargs) */\n                res = ((PyCFunctionFast)(void(*)(void))cfunc)(\n                    PyCFunction_GET_SELF(callable),\n                    args,\n                    total_args);\n                assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n                /* Free the arguments. */\n                for (int i = 0; i < total_args; i++) {\n                    Py_DECREF(args[i]);\n                }\n                Py_DECREF(callable);\n                if (res == NULL) { stack_pointer += -2 - oparg; goto error; }\n            }\n            // _CHECK_PERIODIC\n            {\n            }\n            stack_pointer[-2 - oparg] = res;\n            stack_pointer += -1 - oparg;\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_BUILTIN_FAST_WITH_KEYWORDS) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_BUILTIN_FAST_WITH_KEYWORDS);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject **args;\n            PyObject *self_or_null;\n            PyObject *callable;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            // _CALL_BUILTIN_FAST_WITH_KEYWORDS\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            {\n                /* Builtin METH_FASTCALL | METH_KEYWORDS functions */\n                int total_args = oparg;\n                if (self_or_null != NULL) {\n                    args--;\n                    total_args++;\n                }\n                DEOPT_IF(!PyCFunction_CheckExact(callable), CALL);\n                DEOPT_IF(PyCFunction_GET_FLAGS(callable) != (METH_FASTCALL | METH_KEYWORDS), CALL);\n                STAT_INC(CALL, hit);\n                /* res = func(self, args, nargs, kwnames) */\n                PyCFunctionFastWithKeywords cfunc =\n                (PyCFunctionFastWithKeywords)(void(*)(void))\n                PyCFunction_GET_FUNCTION(callable);\n                res = cfunc(PyCFunction_GET_SELF(callable), args, total_args, NULL);\n                assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n                /* Free the arguments. */\n                for (int i = 0; i < total_args; i++) {\n                    Py_DECREF(args[i]);\n                }\n                Py_DECREF(callable);\n                if (res == NULL) { stack_pointer += -2 - oparg; goto error; }\n            }\n            // _CHECK_PERIODIC\n            {\n            }\n            stack_pointer[-2 - oparg] = res;\n            stack_pointer += -1 - oparg;\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_BUILTIN_O) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_BUILTIN_O);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject **args;\n            PyObject *self_or_null;\n            PyObject *callable;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            // _CALL_BUILTIN_O\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            {\n                /* Builtin METH_O functions */\n                int total_args = oparg;\n                if (self_or_null != NULL) {\n                    args--;\n                    total_args++;\n                }\n                DEOPT_IF(total_args != 1, CALL);\n                DEOPT_IF(!PyCFunction_CheckExact(callable), CALL);\n                DEOPT_IF(PyCFunction_GET_FLAGS(callable) != METH_O, CALL);\n                // CPython promises to check all non-vectorcall function calls.\n                DEOPT_IF(tstate->c_recursion_remaining <= 0, CALL);\n                STAT_INC(CALL, hit);\n                PyCFunction cfunc = PyCFunction_GET_FUNCTION(callable);\n                PyObject *arg = args[0];\n                _Py_EnterRecursiveCallTstateUnchecked(tstate);\n                res = _PyCFunction_TrampolineCall(cfunc, PyCFunction_GET_SELF(callable), arg);\n                _Py_LeaveRecursiveCallTstate(tstate);\n                assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n                Py_DECREF(arg);\n                Py_DECREF(callable);\n                if (res == NULL) { stack_pointer += -2 - oparg; goto error; }\n            }\n            // _CHECK_PERIODIC\n            {\n            }\n            stack_pointer[-2 - oparg] = res;\n            stack_pointer += -1 - oparg;\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_FUNCTION_EX) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(CALL_FUNCTION_EX);\n            PREDICTED(CALL_FUNCTION_EX);\n            _Py_CODEUNIT *this_instr = next_instr - 1;\n            (void)this_instr;\n            PyObject *kwargs = NULL;\n            PyObject *callargs;\n            PyObject *func;\n            PyObject *result;\n            if (oparg & 1) { kwargs = stack_pointer[-(oparg & 1)]; }\n            callargs = stack_pointer[-1 - (oparg & 1)];\n            func = stack_pointer[-3 - (oparg & 1)];\n            // DICT_MERGE is called before this opcode if there are kwargs.\n            // It converts all dict subtypes in kwargs into regular dicts.\n            assert(kwargs == NULL || PyDict_CheckExact(kwargs));\n            if (!PyTuple_CheckExact(callargs)) {\n                if (check_args_iterable(tstate, func, callargs) < 0) {\n                    goto error;\n                }\n                PyObject *tuple = PySequence_Tuple(callargs);\n                if (tuple == NULL) {\n                    goto error;\n                }\n                Py_SETREF(callargs, tuple);\n            }\n            assert(PyTuple_CheckExact(callargs));\n            EVAL_CALL_STAT_INC_IF_FUNCTION(EVAL_CALL_FUNCTION_EX, func);\n            if (opcode == INSTRUMENTED_CALL_FUNCTION_EX) {\n                PyObject *arg = PyTuple_GET_SIZE(callargs) > 0 ?\n                PyTuple_GET_ITEM(callargs, 0) : &_PyInstrumentation_MISSING;\n                int err = _Py_call_instrumentation_2args(\n                    tstate, PY_MONITORING_EVENT_CALL,\n                    frame, this_instr, func, arg);\n                if (err) goto error;\n                result = PyObject_Call(func, callargs, kwargs);\n                if (!PyFunction_Check(func) && !PyMethod_Check(func)) {\n                    if (result == NULL) {\n                        _Py_call_instrumentation_exc2(\n                            tstate, PY_MONITORING_EVENT_C_RAISE,\n                            frame, this_instr, func, arg);\n                    }\n                    else {\n                        int err = _Py_call_instrumentation_2args(\n                            tstate, PY_MONITORING_EVENT_C_RETURN,\n                            frame, this_instr, func, arg);\n                        if (err < 0) {\n                            Py_CLEAR(result);\n                        }\n                    }\n                }\n            }\n            else {\n                if (Py_TYPE(func) == &PyFunction_Type &&\n                    tstate->interp->eval_frame == NULL &&\n                    ((PyFunctionObject *)func)->vectorcall == _PyFunction_Vectorcall) {\n                    assert(PyTuple_CheckExact(callargs));\n                    Py_ssize_t nargs = PyTuple_GET_SIZE(callargs);\n                    int code_flags = ((PyCodeObject *)PyFunction_GET_CODE(func))->co_flags;\n                    PyObject *locals = code_flags & CO_OPTIMIZED ? NULL : Py_NewRef(PyFunction_GET_GLOBALS(func));\n                    _PyInterpreterFrame *new_frame = _PyEvalFramePushAndInit_Ex(tstate,\n                        (PyFunctionObject *)func, locals,\n                        nargs, callargs, kwargs);\n                    // Need to manually shrink the stack since we exit with DISPATCH_INLINED.\n                    STACK_SHRINK(oparg + 3);\n                    if (new_frame == NULL) {\n                        goto error;\n                    }\n                    assert(next_instr - this_instr == 1);\n                    frame->return_offset = 1;\n                    DISPATCH_INLINED(new_frame);\n                }\n                result = PyObject_Call(func, callargs, kwargs);\n            }\n            Py_DECREF(func);\n            Py_DECREF(callargs);\n            Py_XDECREF(kwargs);\n            assert(PEEK(2 + (oparg & 1)) == NULL);\n            if (result == NULL) { stack_pointer += -3 - (oparg & 1); goto error; }\n            stack_pointer[-3 - (oparg & 1)] = result;\n            stack_pointer += -2 - (oparg & 1);\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_INTRINSIC_1) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(CALL_INTRINSIC_1);\n            PyObject *value;\n            PyObject *res;\n            value = stack_pointer[-1];\n            assert(oparg <= MAX_INTRINSIC_1);\n            res = _PyIntrinsics_UnaryFunctions[oparg].func(tstate, value);\n            Py_DECREF(value);\n            if (res == NULL) goto pop_1_error;\n            stack_pointer[-1] = res;\n            DISPATCH();\n        }\n\n        TARGET(CALL_INTRINSIC_2) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(CALL_INTRINSIC_2);\n            PyObject *value1;\n            PyObject *value2;\n            PyObject *res;\n            value1 = stack_pointer[-1];\n            value2 = stack_pointer[-2];\n            assert(oparg <= MAX_INTRINSIC_2);\n            res = _PyIntrinsics_BinaryFunctions[oparg].func(tstate, value2, value1);\n            Py_DECREF(value2);\n            Py_DECREF(value1);\n            if (res == NULL) goto pop_2_error;\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(CALL_ISINSTANCE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_ISINSTANCE);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject **args;\n            PyObject *self_or_null;\n            PyObject *callable;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            /* isinstance(o, o2) */\n            int total_args = oparg;\n            if (self_or_null != NULL) {\n                args--;\n                total_args++;\n            }\n            DEOPT_IF(total_args != 2, CALL);\n            PyInterpreterState *interp = tstate->interp;\n            DEOPT_IF(callable != interp->callable_cache.isinstance, CALL);\n            STAT_INC(CALL, hit);\n            PyObject *cls = args[1];\n            PyObject *inst = args[0];\n            int retval = PyObject_IsInstance(inst, cls);\n            if (retval < 0) {\n                goto error;\n            }\n            res = PyBool_FromLong(retval);\n            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n            if (res == NULL) {\n                GOTO_ERROR(error);\n            }\n            Py_DECREF(inst);\n            Py_DECREF(cls);\n            Py_DECREF(callable);\n            stack_pointer[-2 - oparg] = res;\n            stack_pointer += -1 - oparg;\n            DISPATCH();\n        }\n\n        TARGET(CALL_KW) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(CALL_KW);\n            PREDICTED(CALL_KW);\n            _Py_CODEUNIT *this_instr = next_instr - 1;\n            (void)this_instr;\n            PyObject *kwnames;\n            PyObject **args;\n            PyObject *self_or_null;\n            PyObject *callable;\n            PyObject *res;\n            kwnames = stack_pointer[-1];\n            args = &stack_pointer[-1 - oparg];\n            self_or_null = stack_pointer[-2 - oparg];\n            callable = stack_pointer[-3 - oparg];\n            // oparg counts all of the args, but *not* self:\n            int total_args = oparg;\n            if (self_or_null != NULL) {\n                args--;\n                total_args++;\n            }\n            if (self_or_null == NULL && Py_TYPE(callable) == &PyMethod_Type) {\n                args--;\n                total_args++;\n                PyObject *self = ((PyMethodObject *)callable)->im_self;\n                args[0] = Py_NewRef(self);\n                PyObject *method = ((PyMethodObject *)callable)->im_func;\n                args[-1] = Py_NewRef(method);\n                Py_DECREF(callable);\n                callable = method;\n            }\n            int positional_args = total_args - (int)PyTuple_GET_SIZE(kwnames);\n            // Check if the call can be inlined or not\n            if (Py_TYPE(callable) == &PyFunction_Type &&\n                tstate->interp->eval_frame == NULL &&\n                ((PyFunctionObject *)callable)->vectorcall == _PyFunction_Vectorcall)\n            {\n                int code_flags = ((PyCodeObject*)PyFunction_GET_CODE(callable))->co_flags;\n                PyObject *locals = code_flags & CO_OPTIMIZED ? NULL : Py_NewRef(PyFunction_GET_GLOBALS(callable));\n                _PyInterpreterFrame *new_frame = _PyEvalFramePushAndInit(\n                    tstate, (PyFunctionObject *)callable, locals,\n                    args, positional_args, kwnames\n                );\n                Py_DECREF(kwnames);\n                // Manipulate stack directly since we leave using DISPATCH_INLINED().\n                STACK_SHRINK(oparg + 3);\n                // The frame has stolen all the arguments from the stack,\n                // so there is no need to clean them up.\n                if (new_frame == NULL) {\n                    goto error;\n                }\n                assert(next_instr - this_instr == 1);\n                frame->return_offset = 1;\n                DISPATCH_INLINED(new_frame);\n            }\n            /* Callable is not a normal Python function */\n            res = PyObject_Vectorcall(\n                                      callable, args,\n                                      positional_args | PY_VECTORCALL_ARGUMENTS_OFFSET,\n                                      kwnames);\n            if (opcode == INSTRUMENTED_CALL_KW) {\n                PyObject *arg = total_args == 0 ?\n                &_PyInstrumentation_MISSING : args[0];\n                if (res == NULL) {\n                    _Py_call_instrumentation_exc2(\n                        tstate, PY_MONITORING_EVENT_C_RAISE,\n                        frame, this_instr, callable, arg);\n                }\n                else {\n                    int err = _Py_call_instrumentation_2args(\n                        tstate, PY_MONITORING_EVENT_C_RETURN,\n                        frame, this_instr, callable, arg);\n                    if (err < 0) {\n                        Py_CLEAR(res);\n                    }\n                }\n            }\n            Py_DECREF(kwnames);\n            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n            Py_DECREF(callable);\n            for (int i = 0; i < total_args; i++) {\n                Py_DECREF(args[i]);\n            }\n            if (res == NULL) { stack_pointer += -3 - oparg; goto error; }\n            stack_pointer[-3 - oparg] = res;\n            stack_pointer += -2 - oparg;\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_LEN) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_LEN);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject **args;\n            PyObject *self_or_null;\n            PyObject *callable;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            /* len(o) */\n            int total_args = oparg;\n            if (self_or_null != NULL) {\n                args--;\n                total_args++;\n            }\n            DEOPT_IF(total_args != 1, CALL);\n            PyInterpreterState *interp = tstate->interp;\n            DEOPT_IF(callable != interp->callable_cache.len, CALL);\n            STAT_INC(CALL, hit);\n            PyObject *arg = args[0];\n            Py_ssize_t len_i = PyObject_Length(arg);\n            if (len_i < 0) {\n                goto error;\n            }\n            res = PyLong_FromSsize_t(len_i);\n            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n            if (res == NULL) {\n                GOTO_ERROR(error);\n            }\n            Py_DECREF(callable);\n            Py_DECREF(arg);\n            stack_pointer[-2 - oparg] = res;\n            stack_pointer += -1 - oparg;\n            DISPATCH();\n        }\n\n        TARGET(CALL_LIST_APPEND) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_LIST_APPEND);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject *arg;\n            PyObject *self;\n            PyObject *callable;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            arg = stack_pointer[-1];\n            self = stack_pointer[-2];\n            callable = stack_pointer[-3];\n            assert(oparg == 1);\n            PyInterpreterState *interp = tstate->interp;\n            DEOPT_IF(callable != interp->callable_cache.list_append, CALL);\n            assert(self != NULL);\n            DEOPT_IF(!PyList_Check(self), CALL);\n            STAT_INC(CALL, hit);\n            if (_PyList_AppendTakeRef((PyListObject *)self, arg) < 0) {\n                goto pop_1_error;  // Since arg is DECREF'ed already\n            }\n            Py_DECREF(self);\n            Py_DECREF(callable);\n            STACK_SHRINK(3);\n            // Skip POP_TOP\n            assert(next_instr->op.code == POP_TOP);\n            SKIP_OVER(1);\n            DISPATCH();\n        }\n\n        TARGET(CALL_METHOD_DESCRIPTOR_FAST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_METHOD_DESCRIPTOR_FAST);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject **args;\n            PyObject *self_or_null;\n            PyObject *callable;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            // _CALL_METHOD_DESCRIPTOR_FAST\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            {\n                int total_args = oparg;\n                if (self_or_null != NULL) {\n                    args--;\n                    total_args++;\n                }\n                PyMethodDescrObject *method = (PyMethodDescrObject *)callable;\n                /* Builtin METH_FASTCALL methods, without keywords */\n                DEOPT_IF(!Py_IS_TYPE(method, &PyMethodDescr_Type), CALL);\n                PyMethodDef *meth = method->d_method;\n                DEOPT_IF(meth->ml_flags != METH_FASTCALL, CALL);\n                PyObject *self = args[0];\n                DEOPT_IF(!Py_IS_TYPE(self, method->d_common.d_type), CALL);\n                STAT_INC(CALL, hit);\n                PyCFunctionFast cfunc =\n                (PyCFunctionFast)(void(*)(void))meth->ml_meth;\n                int nargs = total_args - 1;\n                res = cfunc(self, args + 1, nargs);\n                assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n                /* Clear the stack of the arguments. */\n                for (int i = 0; i < total_args; i++) {\n                    Py_DECREF(args[i]);\n                }\n                Py_DECREF(callable);\n                if (res == NULL) { stack_pointer += -2 - oparg; goto error; }\n            }\n            // _CHECK_PERIODIC\n            {\n            }\n            stack_pointer[-2 - oparg] = res;\n            stack_pointer += -1 - oparg;\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject **args;\n            PyObject *self_or_null;\n            PyObject *callable;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            // _CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            {\n                int total_args = oparg;\n                if (self_or_null != NULL) {\n                    args--;\n                    total_args++;\n                }\n                PyMethodDescrObject *method = (PyMethodDescrObject *)callable;\n                DEOPT_IF(!Py_IS_TYPE(method, &PyMethodDescr_Type), CALL);\n                PyMethodDef *meth = method->d_method;\n                DEOPT_IF(meth->ml_flags != (METH_FASTCALL|METH_KEYWORDS), CALL);\n                PyTypeObject *d_type = method->d_common.d_type;\n                PyObject *self = args[0];\n                DEOPT_IF(!Py_IS_TYPE(self, d_type), CALL);\n                STAT_INC(CALL, hit);\n                int nargs = total_args - 1;\n                PyCFunctionFastWithKeywords cfunc =\n                (PyCFunctionFastWithKeywords)(void(*)(void))meth->ml_meth;\n                res = cfunc(self, args + 1, nargs, NULL);\n                assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n                /* Free the arguments. */\n                for (int i = 0; i < total_args; i++) {\n                    Py_DECREF(args[i]);\n                }\n                Py_DECREF(callable);\n                if (res == NULL) { stack_pointer += -2 - oparg; goto error; }\n            }\n            // _CHECK_PERIODIC\n            {\n            }\n            stack_pointer[-2 - oparg] = res;\n            stack_pointer += -1 - oparg;\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_METHOD_DESCRIPTOR_NOARGS) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_METHOD_DESCRIPTOR_NOARGS);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject **args;\n            PyObject *self_or_null;\n            PyObject *callable;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            // _CALL_METHOD_DESCRIPTOR_NOARGS\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            {\n                assert(oparg == 0 || oparg == 1);\n                int total_args = oparg;\n                if (self_or_null != NULL) {\n                    args--;\n                    total_args++;\n                }\n                DEOPT_IF(total_args != 1, CALL);\n                PyMethodDescrObject *method = (PyMethodDescrObject *)callable;\n                DEOPT_IF(!Py_IS_TYPE(method, &PyMethodDescr_Type), CALL);\n                PyMethodDef *meth = method->d_method;\n                PyObject *self = args[0];\n                DEOPT_IF(!Py_IS_TYPE(self, method->d_common.d_type), CALL);\n                DEOPT_IF(meth->ml_flags != METH_NOARGS, CALL);\n                // CPython promises to check all non-vectorcall function calls.\n                DEOPT_IF(tstate->c_recursion_remaining <= 0, CALL);\n                STAT_INC(CALL, hit);\n                PyCFunction cfunc = meth->ml_meth;\n                _Py_EnterRecursiveCallTstateUnchecked(tstate);\n                res = _PyCFunction_TrampolineCall(cfunc, self, NULL);\n                _Py_LeaveRecursiveCallTstate(tstate);\n                assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n                Py_DECREF(self);\n                Py_DECREF(callable);\n                if (res == NULL) { stack_pointer += -2 - oparg; goto error; }\n            }\n            // _CHECK_PERIODIC\n            {\n            }\n            stack_pointer[-2 - oparg] = res;\n            stack_pointer += -1 - oparg;\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_METHOD_DESCRIPTOR_O) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_METHOD_DESCRIPTOR_O);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject **args;\n            PyObject *self_or_null;\n            PyObject *callable;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            // _CALL_METHOD_DESCRIPTOR_O\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            {\n                int total_args = oparg;\n                if (self_or_null != NULL) {\n                    args--;\n                    total_args++;\n                }\n                PyMethodDescrObject *method = (PyMethodDescrObject *)callable;\n                DEOPT_IF(total_args != 2, CALL);\n                DEOPT_IF(!Py_IS_TYPE(method, &PyMethodDescr_Type), CALL);\n                PyMethodDef *meth = method->d_method;\n                DEOPT_IF(meth->ml_flags != METH_O, CALL);\n                // CPython promises to check all non-vectorcall function calls.\n                DEOPT_IF(tstate->c_recursion_remaining <= 0, CALL);\n                PyObject *arg = args[1];\n                PyObject *self = args[0];\n                DEOPT_IF(!Py_IS_TYPE(self, method->d_common.d_type), CALL);\n                STAT_INC(CALL, hit);\n                PyCFunction cfunc = meth->ml_meth;\n                _Py_EnterRecursiveCallTstateUnchecked(tstate);\n                res = _PyCFunction_TrampolineCall(cfunc, self, arg);\n                _Py_LeaveRecursiveCallTstate(tstate);\n                assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n                Py_DECREF(self);\n                Py_DECREF(arg);\n                Py_DECREF(callable);\n                if (res == NULL) { stack_pointer += -2 - oparg; goto error; }\n            }\n            // _CHECK_PERIODIC\n            {\n            }\n            stack_pointer[-2 - oparg] = res;\n            stack_pointer += -1 - oparg;\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_NON_PY_GENERAL) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_NON_PY_GENERAL);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject *callable;\n            PyObject **args;\n            PyObject *self_or_null;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            // _CHECK_IS_NOT_PY_CALLABLE\n            callable = stack_pointer[-2 - oparg];\n            {\n                DEOPT_IF(PyFunction_Check(callable), CALL);\n                DEOPT_IF(Py_TYPE(callable) == &PyMethod_Type, CALL);\n            }\n            // _CALL_NON_PY_GENERAL\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            {\n                #if TIER_ONE\n                assert(opcode != INSTRUMENTED_CALL);\n                #endif\n                int total_args = oparg;\n                if (self_or_null != NULL) {\n                    args--;\n                    total_args++;\n                }\n                /* Callable is not a normal Python function */\n                res = PyObject_Vectorcall(\n                                      callable, args,\n                                      total_args | PY_VECTORCALL_ARGUMENTS_OFFSET,\n                                      NULL);\n                assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n                Py_DECREF(callable);\n                for (int i = 0; i < total_args; i++) {\n                    Py_DECREF(args[i]);\n                }\n                if (res == NULL) { stack_pointer += -2 - oparg; goto error; }\n            }\n            // _CHECK_PERIODIC\n            {\n            }\n            stack_pointer[-2 - oparg] = res;\n            stack_pointer += -1 - oparg;\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_PY_EXACT_ARGS) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_PY_EXACT_ARGS);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject *self_or_null;\n            PyObject *callable;\n            PyObject **args;\n            _PyInterpreterFrame *new_frame;\n            /* Skip 1 cache entry */\n            // _CHECK_PEP_523\n            {\n                DEOPT_IF(tstate->interp->eval_frame, CALL);\n            }\n            // _CHECK_FUNCTION_EXACT_ARGS\n            self_or_null = stack_pointer[-1 - oparg];\n            callable = stack_pointer[-2 - oparg];\n            {\n                uint32_t func_version = read_u32(&this_instr[2].cache);\n                DEOPT_IF(!PyFunction_Check(callable), CALL);\n                PyFunctionObject *func = (PyFunctionObject *)callable;\n                DEOPT_IF(func->func_version != func_version, CALL);\n                PyCodeObject *code = (PyCodeObject *)func->func_code;\n                DEOPT_IF(code->co_argcount != oparg + (self_or_null != NULL), CALL);\n            }\n            // _CHECK_STACK_SPACE\n            {\n                PyFunctionObject *func = (PyFunctionObject *)callable;\n                PyCodeObject *code = (PyCodeObject *)func->func_code;\n                DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), CALL);\n                DEOPT_IF(tstate->py_recursion_remaining <= 1, CALL);\n            }\n            // _INIT_CALL_PY_EXACT_ARGS\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            {\n                int has_self = (self_or_null != NULL);\n                STAT_INC(CALL, hit);\n                PyFunctionObject *func = (PyFunctionObject *)callable;\n                new_frame = _PyFrame_PushUnchecked(tstate, func, oparg + has_self);\n                PyObject **first_non_self_local = new_frame->localsplus + has_self;\n                new_frame->localsplus[0] = self_or_null;\n                for (int i = 0; i < oparg; i++) {\n                    first_non_self_local[i] = args[i];\n                }\n            }\n            // _SAVE_RETURN_OFFSET\n            {\n                #if TIER_ONE\n                frame->return_offset = (uint16_t)(next_instr - this_instr);\n                #endif\n                #if TIER_TWO\n                frame->return_offset = oparg;\n                #endif\n            }\n            // _PUSH_FRAME\n            {\n                // Write it out explicitly because it's subtly different.\n                // Eventually this should be the only occurrence of this code.\n                assert(tstate->interp->eval_frame == NULL);\n                stack_pointer += -2 - oparg;\n                _PyFrame_SetStackPointer(frame, stack_pointer);\n                new_frame->previous = frame;\n                CALL_STAT_INC(inlined_py_calls);\n                frame = tstate->current_frame = new_frame;\n                tstate->py_recursion_remaining--;\n                LOAD_SP();\n                LOAD_IP(0);\n                LLTRACE_RESUME_FRAME();\n            }\n            DISPATCH();\n        }\n\n        TARGET(CALL_PY_GENERAL) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_PY_GENERAL);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject *callable;\n            PyObject **args;\n            PyObject *self_or_null;\n            _PyInterpreterFrame *new_frame;\n            /* Skip 1 cache entry */\n            // _CHECK_PEP_523\n            {\n                DEOPT_IF(tstate->interp->eval_frame, CALL);\n            }\n            // _CHECK_FUNCTION_VERSION\n            callable = stack_pointer[-2 - oparg];\n            {\n                uint32_t func_version = read_u32(&this_instr[2].cache);\n                DEOPT_IF(!PyFunction_Check(callable), CALL);\n                PyFunctionObject *func = (PyFunctionObject *)callable;\n                DEOPT_IF(func->func_version != func_version, CALL);\n            }\n            // _PY_FRAME_GENERAL\n            args = &stack_pointer[-oparg];\n            self_or_null = stack_pointer[-1 - oparg];\n            {\n                // oparg counts all of the args, but *not* self:\n                int total_args = oparg;\n                if (self_or_null != NULL) {\n                    args--;\n                    total_args++;\n                }\n                assert(Py_TYPE(callable) == &PyFunction_Type);\n                int code_flags = ((PyCodeObject*)PyFunction_GET_CODE(callable))->co_flags;\n                PyObject *locals = code_flags & CO_OPTIMIZED ? NULL : Py_NewRef(PyFunction_GET_GLOBALS(callable));\n                new_frame = _PyEvalFramePushAndInit(\n                    tstate, (PyFunctionObject *)callable, locals,\n                    args, total_args, NULL\n                );\n                // The frame has stolen all the arguments from the stack,\n                // so there is no need to clean them up.\n                stack_pointer += -2 - oparg;\n                if (new_frame == NULL) {\n                    goto error;\n                }\n            }\n            // _SAVE_RETURN_OFFSET\n            {\n                #if TIER_ONE\n                frame->return_offset = (uint16_t)(next_instr - this_instr);\n                #endif\n                #if TIER_TWO\n                frame->return_offset = oparg;\n                #endif\n            }\n            // _PUSH_FRAME\n            {\n                // Write it out explicitly because it's subtly different.\n                // Eventually this should be the only occurrence of this code.\n                assert(tstate->interp->eval_frame == NULL);\n                _PyFrame_SetStackPointer(frame, stack_pointer);\n                new_frame->previous = frame;\n                CALL_STAT_INC(inlined_py_calls);\n                frame = tstate->current_frame = new_frame;\n                tstate->py_recursion_remaining--;\n                LOAD_SP();\n                LOAD_IP(0);\n                LLTRACE_RESUME_FRAME();\n            }\n            DISPATCH();\n        }\n\n        TARGET(CALL_STR_1) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_STR_1);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject *arg;\n            PyObject *null;\n            PyObject *callable;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            // _CALL_STR_1\n            arg = stack_pointer[-1];\n            null = stack_pointer[-2];\n            callable = stack_pointer[-3];\n            {\n                assert(oparg == 1);\n                DEOPT_IF(null != NULL, CALL);\n                DEOPT_IF(callable != (PyObject *)&PyUnicode_Type, CALL);\n                STAT_INC(CALL, hit);\n                res = PyObject_Str(arg);\n                Py_DECREF(arg);\n                if (res == NULL) goto pop_3_error;\n            }\n            // _CHECK_PERIODIC\n            {\n            }\n            stack_pointer[-3] = res;\n            stack_pointer += -2;\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_TUPLE_1) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_TUPLE_1);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject *arg;\n            PyObject *null;\n            PyObject *callable;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            // _CALL_TUPLE_1\n            arg = stack_pointer[-1];\n            null = stack_pointer[-2];\n            callable = stack_pointer[-3];\n            {\n                assert(oparg == 1);\n                DEOPT_IF(null != NULL, CALL);\n                DEOPT_IF(callable != (PyObject *)&PyTuple_Type, CALL);\n                STAT_INC(CALL, hit);\n                res = PySequence_Tuple(arg);\n                Py_DECREF(arg);\n                if (res == NULL) goto pop_3_error;\n            }\n            // _CHECK_PERIODIC\n            {\n            }\n            stack_pointer[-3] = res;\n            stack_pointer += -2;\n            CHECK_EVAL_BREAKER();\n            DISPATCH();\n        }\n\n        TARGET(CALL_TYPE_1) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(CALL_TYPE_1);\n            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, \"incorrect cache size\");\n            PyObject *arg;\n            PyObject *null;\n            PyObject *callable;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            arg = stack_pointer[-1];\n            null = stack_pointer[-2];\n            callable = stack_pointer[-3];\n            assert(oparg == 1);\n            DEOPT_IF(null != NULL, CALL);\n            DEOPT_IF(callable != (PyObject *)&PyType_Type, CALL);\n            STAT_INC(CALL, hit);\n            res = Py_NewRef(Py_TYPE(arg));\n            Py_DECREF(arg);\n            stack_pointer[-3] = res;\n            stack_pointer += -2;\n            DISPATCH();\n        }\n\n        TARGET(CHECK_EG_MATCH) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(CHECK_EG_MATCH);\n            PyObject *match_type;\n            PyObject *exc_value;\n            PyObject *rest;\n            PyObject *match;\n            match_type = stack_pointer[-1];\n            exc_value = stack_pointer[-2];\n            if (_PyEval_CheckExceptStarTypeValid(tstate, match_type) < 0) {\n                Py_DECREF(exc_value);\n                Py_DECREF(match_type);\n                if (true) goto pop_2_error;\n            }\n            match = NULL;\n            rest = NULL;\n            int res = _PyEval_ExceptionGroupMatch(exc_value, match_type,\n                &match, &rest);\n            Py_DECREF(exc_value);\n            Py_DECREF(match_type);\n            if (res < 0) goto pop_2_error;\n            assert((match == NULL) == (rest == NULL));\n            if (match == NULL) goto pop_2_error;\n            if (!Py_IsNone(match)) {\n                PyErr_SetHandledException(match);\n            }\n            stack_pointer[-2] = rest;\n            stack_pointer[-1] = match;\n            DISPATCH();\n        }\n\n        TARGET(CHECK_EXC_MATCH) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(CHECK_EXC_MATCH);\n            PyObject *right;\n            PyObject *left;\n            PyObject *b;\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            assert(PyExceptionInstance_Check(left));\n            if (_PyEval_CheckExceptTypeValid(tstate, right) < 0) {\n                Py_DECREF(right);\n                if (true) goto pop_1_error;\n            }\n            int res = PyErr_GivenExceptionMatches(left, right);\n            Py_DECREF(right);\n            b = res ? Py_True : Py_False;\n            stack_pointer[-1] = b;\n            DISPATCH();\n        }\n\n        TARGET(CLEANUP_THROW) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(CLEANUP_THROW);\n            PyObject *exc_value;\n            PyObject *last_sent_val;\n            PyObject *sub_iter;\n            PyObject *none;\n            PyObject *value;\n            exc_value = stack_pointer[-1];\n            last_sent_val = stack_pointer[-2];\n            sub_iter = stack_pointer[-3];\n            assert(throwflag);\n            assert(exc_value && PyExceptionInstance_Check(exc_value));\n            if (PyErr_GivenExceptionMatches(exc_value, PyExc_StopIteration)) {\n                value = Py_NewRef(((PyStopIterationObject *)exc_value)->value);\n                Py_DECREF(sub_iter);\n                Py_DECREF(last_sent_val);\n                Py_DECREF(exc_value);\n                none = Py_None;\n            }\n            else {\n                _PyErr_SetRaisedException(tstate, Py_NewRef(exc_value));\n                monitor_reraise(tstate, frame, this_instr);\n                goto exception_unwind;\n            }\n            stack_pointer[-3] = none;\n            stack_pointer[-2] = value;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(COMPARE_OP) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(COMPARE_OP);\n            PREDICTED(COMPARE_OP);\n            _Py_CODEUNIT *this_instr = next_instr - 2;\n            (void)this_instr;\n            PyObject *right;\n            PyObject *left;\n            PyObject *res;\n            // _SPECIALIZE_COMPARE_OP\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    next_instr = this_instr;\n                    _Py_Specialize_CompareOp(left, right, next_instr, oparg);\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(COMPARE_OP, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n            }\n            // _COMPARE_OP\n            {\n                assert((oparg >> 5) <= Py_GE);\n                res = PyObject_RichCompare(left, right, oparg >> 5);\n                Py_DECREF(left);\n                Py_DECREF(right);\n                if (res == NULL) goto pop_2_error;\n                if (oparg & 16) {\n                    int res_bool = PyObject_IsTrue(res);\n                    Py_DECREF(res);\n                    if (res_bool < 0) goto pop_2_error;\n                    res = res_bool ? Py_True : Py_False;\n                }\n            }\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(COMPARE_OP_FLOAT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(COMPARE_OP_FLOAT);\n            static_assert(INLINE_CACHE_ENTRIES_COMPARE_OP == 1, \"incorrect cache size\");\n            PyObject *right;\n            PyObject *left;\n            PyObject *res;\n            // _GUARD_BOTH_FLOAT\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            {\n                DEOPT_IF(!PyFloat_CheckExact(left), COMPARE_OP);\n                DEOPT_IF(!PyFloat_CheckExact(right), COMPARE_OP);\n            }\n            /* Skip 1 cache entry */\n            // _COMPARE_OP_FLOAT\n            {\n                STAT_INC(COMPARE_OP, hit);\n                double dleft = PyFloat_AS_DOUBLE(left);\n                double dright = PyFloat_AS_DOUBLE(right);\n                // 1 if NaN, 2 if <, 4 if >, 8 if ==; this matches low four bits of the oparg\n                int sign_ish = COMPARISON_BIT(dleft, dright);\n                _Py_DECREF_SPECIALIZED(left, _PyFloat_ExactDealloc);\n                _Py_DECREF_SPECIALIZED(right, _PyFloat_ExactDealloc);\n                res = (sign_ish & oparg) ? Py_True : Py_False;\n                // It's always a bool, so we don't care about oparg & 16.\n            }\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(COMPARE_OP_INT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(COMPARE_OP_INT);\n            static_assert(INLINE_CACHE_ENTRIES_COMPARE_OP == 1, \"incorrect cache size\");\n            PyObject *right;\n            PyObject *left;\n            PyObject *res;\n            // _GUARD_BOTH_INT\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            {\n                DEOPT_IF(!PyLong_CheckExact(left), COMPARE_OP);\n                DEOPT_IF(!PyLong_CheckExact(right), COMPARE_OP);\n            }\n            /* Skip 1 cache entry */\n            // _COMPARE_OP_INT\n            {\n                DEOPT_IF(!_PyLong_IsCompact((PyLongObject *)left), COMPARE_OP);\n                DEOPT_IF(!_PyLong_IsCompact((PyLongObject *)right), COMPARE_OP);\n                STAT_INC(COMPARE_OP, hit);\n                assert(_PyLong_DigitCount((PyLongObject *)left) <= 1 &&\n                   _PyLong_DigitCount((PyLongObject *)right) <= 1);\n                Py_ssize_t ileft = _PyLong_CompactValue((PyLongObject *)left);\n                Py_ssize_t iright = _PyLong_CompactValue((PyLongObject *)right);\n                // 2 if <, 4 if >, 8 if ==; this matches the low 4 bits of the oparg\n                int sign_ish = COMPARISON_BIT(ileft, iright);\n                _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);\n                _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);\n                res = (sign_ish & oparg) ? Py_True : Py_False;\n                // It's always a bool, so we don't care about oparg & 16.\n            }\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(COMPARE_OP_STR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(COMPARE_OP_STR);\n            static_assert(INLINE_CACHE_ENTRIES_COMPARE_OP == 1, \"incorrect cache size\");\n            PyObject *right;\n            PyObject *left;\n            PyObject *res;\n            // _GUARD_BOTH_UNICODE\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            {\n                DEOPT_IF(!PyUnicode_CheckExact(left), COMPARE_OP);\n                DEOPT_IF(!PyUnicode_CheckExact(right), COMPARE_OP);\n            }\n            /* Skip 1 cache entry */\n            // _COMPARE_OP_STR\n            {\n                STAT_INC(COMPARE_OP, hit);\n                int eq = _PyUnicode_Equal(left, right);\n                assert((oparg >> 5) == Py_EQ || (oparg >> 5) == Py_NE);\n                _Py_DECREF_SPECIALIZED(left, _PyUnicode_ExactDealloc);\n                _Py_DECREF_SPECIALIZED(right, _PyUnicode_ExactDealloc);\n                assert(eq == 0 || eq == 1);\n                assert((oparg & 0xf) == COMPARISON_NOT_EQUALS || (oparg & 0xf) == COMPARISON_EQUALS);\n                assert(COMPARISON_NOT_EQUALS + 1 == COMPARISON_EQUALS);\n                res = ((COMPARISON_NOT_EQUALS + eq) & oparg) ? Py_True : Py_False;\n                // It's always a bool, so we don't care about oparg & 16.\n            }\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(CONTAINS_OP) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(CONTAINS_OP);\n            PREDICTED(CONTAINS_OP);\n            _Py_CODEUNIT *this_instr = next_instr - 2;\n            (void)this_instr;\n            PyObject *right;\n            PyObject *left;\n            PyObject *b;\n            // _SPECIALIZE_CONTAINS_OP\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    next_instr = this_instr;\n                    _Py_Specialize_ContainsOp(right, next_instr);\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(CONTAINS_OP, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n            }\n            // _CONTAINS_OP\n            {\n                int res = PySequence_Contains(right, left);\n                Py_DECREF(left);\n                Py_DECREF(right);\n                if (res < 0) goto pop_2_error;\n                b = (res ^ oparg) ? Py_True : Py_False;\n            }\n            stack_pointer[-2] = b;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(CONTAINS_OP_DICT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(CONTAINS_OP_DICT);\n            static_assert(INLINE_CACHE_ENTRIES_CONTAINS_OP == 1, \"incorrect cache size\");\n            PyObject *right;\n            PyObject *left;\n            PyObject *b;\n            /* Skip 1 cache entry */\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            DEOPT_IF(!PyDict_CheckExact(right), CONTAINS_OP);\n            STAT_INC(CONTAINS_OP, hit);\n            int res = PyDict_Contains(right, left);\n            Py_DECREF(left);\n            Py_DECREF(right);\n            if (res < 0) goto pop_2_error;\n            b = (res ^ oparg) ? Py_True : Py_False;\n            stack_pointer[-2] = b;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(CONTAINS_OP_SET) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(CONTAINS_OP_SET);\n            static_assert(INLINE_CACHE_ENTRIES_CONTAINS_OP == 1, \"incorrect cache size\");\n            PyObject *right;\n            PyObject *left;\n            PyObject *b;\n            /* Skip 1 cache entry */\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            DEOPT_IF(!(PySet_CheckExact(right) || PyFrozenSet_CheckExact(right)), CONTAINS_OP);\n            STAT_INC(CONTAINS_OP, hit);\n            // Note: both set and frozenset use the same seq_contains method!\n            int res = _PySet_Contains((PySetObject *)right, left);\n            Py_DECREF(left);\n            Py_DECREF(right);\n            if (res < 0) goto pop_2_error;\n            b = (res ^ oparg) ? Py_True : Py_False;\n            stack_pointer[-2] = b;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(CONVERT_VALUE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(CONVERT_VALUE);\n            PyObject *value;\n            PyObject *result;\n            value = stack_pointer[-1];\n            conversion_func conv_fn;\n            assert(oparg >= FVC_STR && oparg <= FVC_ASCII);\n            conv_fn = _PyEval_ConversionFuncs[oparg];\n            result = conv_fn(value);\n            Py_DECREF(value);\n            if (result == NULL) goto pop_1_error;\n            stack_pointer[-1] = result;\n            DISPATCH();\n        }\n\n        TARGET(COPY) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(COPY);\n            PyObject *bottom;\n            PyObject *top;\n            bottom = stack_pointer[-1 - (oparg-1)];\n            assert(oparg > 0);\n            top = Py_NewRef(bottom);\n            stack_pointer[0] = top;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(COPY_FREE_VARS) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(COPY_FREE_VARS);\n            /* Copy closure variables to free variables */\n            PyCodeObject *co = _PyFrame_GetCode(frame);\n            assert(PyFunction_Check(frame->f_funcobj));\n            PyObject *closure = ((PyFunctionObject *)frame->f_funcobj)->func_closure;\n            assert(oparg == co->co_nfreevars);\n            int offset = co->co_nlocalsplus - oparg;\n            for (int i = 0; i < oparg; ++i) {\n                PyObject *o = PyTuple_GET_ITEM(closure, i);\n                frame->localsplus[offset + i] = Py_NewRef(o);\n            }\n            DISPATCH();\n        }\n\n        TARGET(DELETE_ATTR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(DELETE_ATTR);\n            PyObject *owner;\n            owner = stack_pointer[-1];\n            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);\n            int err = PyObject_DelAttr(owner, name);\n            Py_DECREF(owner);\n            if (err) goto pop_1_error;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(DELETE_DEREF) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(DELETE_DEREF);\n            PyObject *cell = GETLOCAL(oparg);\n            // Can't use ERROR_IF here.\n            // Fortunately we don't need its superpower.\n            PyObject *oldobj = PyCell_SwapTakeRef((PyCellObject *)cell, NULL);\n            if (oldobj == NULL) {\n                _PyEval_FormatExcUnbound(tstate, _PyFrame_GetCode(frame), oparg);\n                goto error;\n            }\n            Py_DECREF(oldobj);\n            DISPATCH();\n        }\n\n        TARGET(DELETE_FAST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(DELETE_FAST);\n            PyObject *v = GETLOCAL(oparg);\n            if (v == NULL) {\n                _PyEval_FormatExcCheckArg(tstate, PyExc_UnboundLocalError,\n                    UNBOUNDLOCAL_ERROR_MSG,\n                    PyTuple_GetItem(_PyFrame_GetCode(frame)->co_localsplusnames, oparg)\n                );\n                if (1) goto error;\n            }\n            SETLOCAL(oparg, NULL);\n            DISPATCH();\n        }\n\n        TARGET(DELETE_GLOBAL) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(DELETE_GLOBAL);\n            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);\n            int err = PyDict_Pop(GLOBALS(), name, NULL);\n            // Can't use ERROR_IF here.\n            if (err < 0) {\n                goto error;\n            }\n            if (err == 0) {\n                _PyEval_FormatExcCheckArg(tstate, PyExc_NameError,\n                    NAME_ERROR_MSG, name);\n                goto error;\n            }\n            DISPATCH();\n        }\n\n        TARGET(DELETE_NAME) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(DELETE_NAME);\n            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);\n            PyObject *ns = LOCALS();\n            int err;\n            if (ns == NULL) {\n                _PyErr_Format(tstate, PyExc_SystemError,\n                              \"no locals when deleting %R\", name);\n                goto error;\n            }\n            err = PyObject_DelItem(ns, name);\n            // Can't use ERROR_IF here.\n            if (err != 0) {\n                _PyEval_FormatExcCheckArg(tstate, PyExc_NameError,\n                    NAME_ERROR_MSG,\n                    name);\n                goto error;\n            }\n            DISPATCH();\n        }\n\n        TARGET(DELETE_SUBSCR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(DELETE_SUBSCR);\n            PyObject *sub;\n            PyObject *container;\n            sub = stack_pointer[-1];\n            container = stack_pointer[-2];\n            /* del container[sub] */\n            int err = PyObject_DelItem(container, sub);\n            Py_DECREF(container);\n            Py_DECREF(sub);\n            if (err) goto pop_2_error;\n            stack_pointer += -2;\n            DISPATCH();\n        }\n\n        TARGET(DICT_MERGE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(DICT_MERGE);\n            PyObject *update;\n            PyObject *dict;\n            PyObject *callable;\n            update = stack_pointer[-1];\n            dict = stack_pointer[-2 - (oparg - 1)];\n            callable = stack_pointer[-5 - (oparg - 1)];\n            if (_PyDict_MergeEx(dict, update, 2) < 0) {\n                _PyEval_FormatKwargsError(tstate, callable, update);\n                Py_DECREF(update);\n                if (true) goto pop_1_error;\n            }\n            Py_DECREF(update);\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(DICT_UPDATE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(DICT_UPDATE);\n            PyObject *update;\n            PyObject *dict;\n            update = stack_pointer[-1];\n            dict = stack_pointer[-2 - (oparg - 1)];\n            if (PyDict_Update(dict, update) < 0) {\n                if (_PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"'%.200s' object is not a mapping\",\n                                  Py_TYPE(update)->tp_name);\n                }\n                Py_DECREF(update);\n                if (true) goto pop_1_error;\n            }\n            Py_DECREF(update);\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(END_ASYNC_FOR) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(END_ASYNC_FOR);\n            PyObject *exc;\n            PyObject *awaitable;\n            exc = stack_pointer[-1];\n            awaitable = stack_pointer[-2];\n            assert(exc && PyExceptionInstance_Check(exc));\n            if (PyErr_GivenExceptionMatches(exc, PyExc_StopAsyncIteration)) {\n                Py_DECREF(awaitable);\n                Py_DECREF(exc);\n            }\n            else {\n                Py_INCREF(exc);\n                _PyErr_SetRaisedException(tstate, exc);\n                monitor_reraise(tstate, frame, this_instr);\n                goto exception_unwind;\n            }\n            stack_pointer += -2;\n            DISPATCH();\n        }\n\n        TARGET(END_FOR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(END_FOR);\n            PyObject *value;\n            value = stack_pointer[-1];\n            Py_DECREF(value);\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(END_SEND) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(END_SEND);\n            PyObject *value;\n            PyObject *receiver;\n            value = stack_pointer[-1];\n            receiver = stack_pointer[-2];\n            Py_DECREF(receiver);\n            stack_pointer[-2] = value;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(ENTER_EXECUTOR) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(ENTER_EXECUTOR);\n            #ifdef _Py_TIER2\n            PyCodeObject *code = _PyFrame_GetCode(frame);\n            _PyExecutorObject *executor = code->co_executors->executors[oparg & 255];\n            assert(executor->vm_data.index == INSTR_OFFSET() - 1);\n            assert(executor->vm_data.code == code);\n            assert(executor->vm_data.valid);\n            assert(tstate->previous_executor == NULL);\n            /* If the eval breaker is set then stay in tier 1.\n             * This avoids any potentially infinite loops\n             * involving _RESUME_CHECK */\n            if (_Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker) & _PY_EVAL_EVENTS_MASK) {\n                opcode = executor->vm_data.opcode;\n                oparg = (oparg & ~255) | executor->vm_data.oparg;\n                next_instr = this_instr;\n                if (_PyOpcode_Caches[_PyOpcode_Deopt[opcode]]) {\n                    PAUSE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                }\n                DISPATCH_GOTO();\n            }\n            tstate->previous_executor = Py_None;\n            Py_INCREF(executor);\n            GOTO_TIER_TWO(executor);\n            #else\n            Py_FatalError(\"ENTER_EXECUTOR is not supported in this build\");\n            #endif /* _Py_TIER2 */\n            DISPATCH();\n        }\n\n        TARGET(EXIT_INIT_CHECK) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(EXIT_INIT_CHECK);\n            PyObject *should_be_none;\n            should_be_none = stack_pointer[-1];\n            assert(STACK_LEVEL() == 2);\n            if (should_be_none != Py_None) {\n                PyErr_Format(PyExc_TypeError,\n                             \"__init__() should return None, not '%.200s'\",\n                             Py_TYPE(should_be_none)->tp_name);\n                goto error;\n            }\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(EXTENDED_ARG) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(EXTENDED_ARG);\n            assert(oparg);\n            opcode = next_instr->op.code;\n            oparg = oparg << 8 | next_instr->op.arg;\n            PRE_DISPATCH_GOTO();\n            DISPATCH_GOTO();\n        }\n\n        TARGET(FORMAT_SIMPLE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(FORMAT_SIMPLE);\n            PyObject *value;\n            PyObject *res;\n            value = stack_pointer[-1];\n            /* If value is a unicode object, then we know the result\n             * of format(value) is value itself. */\n            if (!PyUnicode_CheckExact(value)) {\n                res = PyObject_Format(value, NULL);\n                Py_DECREF(value);\n                if (res == NULL) goto pop_1_error;\n            }\n            else {\n                res = value;\n            }\n            stack_pointer[-1] = res;\n            DISPATCH();\n        }\n\n        TARGET(FORMAT_WITH_SPEC) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(FORMAT_WITH_SPEC);\n            PyObject *fmt_spec;\n            PyObject *value;\n            PyObject *res;\n            fmt_spec = stack_pointer[-1];\n            value = stack_pointer[-2];\n            res = PyObject_Format(value, fmt_spec);\n            Py_DECREF(value);\n            Py_DECREF(fmt_spec);\n            if (res == NULL) goto pop_2_error;\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(FOR_ITER) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(FOR_ITER);\n            PREDICTED(FOR_ITER);\n            _Py_CODEUNIT *this_instr = next_instr - 2;\n            (void)this_instr;\n            PyObject *iter;\n            PyObject *next;\n            // _SPECIALIZE_FOR_ITER\n            iter = stack_pointer[-1];\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    next_instr = this_instr;\n                    _Py_Specialize_ForIter(iter, next_instr, oparg);\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(FOR_ITER, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n            }\n            // _FOR_ITER\n            {\n                /* before: [iter]; after: [iter, iter()] *or* [] (and jump over END_FOR.) */\n                next = (*Py_TYPE(iter)->tp_iternext)(iter);\n                if (next == NULL) {\n                    if (_PyErr_Occurred(tstate)) {\n                        if (!_PyErr_ExceptionMatches(tstate, PyExc_StopIteration)) {\n                            goto error;\n                        }\n                        monitor_raise(tstate, frame, this_instr);\n                        _PyErr_Clear(tstate);\n                    }\n                    /* iterator ended normally */\n                    assert(next_instr[oparg].op.code == END_FOR ||\n                       next_instr[oparg].op.code == INSTRUMENTED_END_FOR);\n                    Py_DECREF(iter);\n                    STACK_SHRINK(1);\n                    /* Jump forward oparg, then skip following END_FOR and POP_TOP instruction */\n                    JUMPBY(oparg + 2);\n                    DISPATCH();\n                }\n                // Common case: no jump, leave it to the code generator\n            }\n            stack_pointer[0] = next;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(FOR_ITER_GEN) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(FOR_ITER_GEN);\n            static_assert(INLINE_CACHE_ENTRIES_FOR_ITER == 1, \"incorrect cache size\");\n            PyObject *iter;\n            _PyInterpreterFrame *gen_frame;\n            _PyInterpreterFrame *new_frame;\n            /* Skip 1 cache entry */\n            // _CHECK_PEP_523\n            {\n                DEOPT_IF(tstate->interp->eval_frame, FOR_ITER);\n            }\n            // _FOR_ITER_GEN_FRAME\n            iter = stack_pointer[-1];\n            {\n                PyGenObject *gen = (PyGenObject *)iter;\n                DEOPT_IF(Py_TYPE(gen) != &PyGen_Type, FOR_ITER);\n                DEOPT_IF(gen->gi_frame_state >= FRAME_EXECUTING, FOR_ITER);\n                STAT_INC(FOR_ITER, hit);\n                gen_frame = (_PyInterpreterFrame *)gen->gi_iframe;\n                _PyFrame_StackPush(gen_frame, Py_None);\n                gen->gi_frame_state = FRAME_EXECUTING;\n                gen->gi_exc_state.previous_item = tstate->exc_info;\n                tstate->exc_info = &gen->gi_exc_state;\n                // oparg is the return offset from the next instruction.\n                frame->return_offset = (uint16_t)(1 + INLINE_CACHE_ENTRIES_FOR_ITER + oparg);\n            }\n            // _PUSH_FRAME\n            new_frame = gen_frame;\n            {\n                // Write it out explicitly because it's subtly different.\n                // Eventually this should be the only occurrence of this code.\n                assert(tstate->interp->eval_frame == NULL);\n                _PyFrame_SetStackPointer(frame, stack_pointer);\n                new_frame->previous = frame;\n                CALL_STAT_INC(inlined_py_calls);\n                frame = tstate->current_frame = new_frame;\n                tstate->py_recursion_remaining--;\n                LOAD_SP();\n                LOAD_IP(0);\n                LLTRACE_RESUME_FRAME();\n            }\n            DISPATCH();\n        }\n\n        TARGET(FOR_ITER_LIST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(FOR_ITER_LIST);\n            static_assert(INLINE_CACHE_ENTRIES_FOR_ITER == 1, \"incorrect cache size\");\n            PyObject *iter;\n            PyObject *next;\n            /* Skip 1 cache entry */\n            // _ITER_CHECK_LIST\n            iter = stack_pointer[-1];\n            {\n                DEOPT_IF(Py_TYPE(iter) != &PyListIter_Type, FOR_ITER);\n            }\n            // _ITER_JUMP_LIST\n            {\n                _PyListIterObject *it = (_PyListIterObject *)iter;\n                assert(Py_TYPE(iter) == &PyListIter_Type);\n                STAT_INC(FOR_ITER, hit);\n                PyListObject *seq = it->it_seq;\n                if (seq == NULL || (size_t)it->it_index >= (size_t)PyList_GET_SIZE(seq)) {\n                    it->it_index = -1;\n                    #ifndef Py_GIL_DISABLED\n                    if (seq != NULL) {\n                        it->it_seq = NULL;\n                        Py_DECREF(seq);\n                    }\n                    #endif\n                    Py_DECREF(iter);\n                    STACK_SHRINK(1);\n                    /* Jump forward oparg, then skip following END_FOR and POP_TOP instructions */\n                    JUMPBY(oparg + 2);\n                    DISPATCH();\n                }\n            }\n            // _ITER_NEXT_LIST\n            {\n                _PyListIterObject *it = (_PyListIterObject *)iter;\n                assert(Py_TYPE(iter) == &PyListIter_Type);\n                PyListObject *seq = it->it_seq;\n                assert(seq);\n                assert(it->it_index < PyList_GET_SIZE(seq));\n                next = Py_NewRef(PyList_GET_ITEM(seq, it->it_index++));\n            }\n            stack_pointer[0] = next;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(FOR_ITER_RANGE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(FOR_ITER_RANGE);\n            static_assert(INLINE_CACHE_ENTRIES_FOR_ITER == 1, \"incorrect cache size\");\n            PyObject *iter;\n            PyObject *next;\n            /* Skip 1 cache entry */\n            // _ITER_CHECK_RANGE\n            iter = stack_pointer[-1];\n            {\n                _PyRangeIterObject *r = (_PyRangeIterObject *)iter;\n                DEOPT_IF(Py_TYPE(r) != &PyRangeIter_Type, FOR_ITER);\n            }\n            // _ITER_JUMP_RANGE\n            {\n                _PyRangeIterObject *r = (_PyRangeIterObject *)iter;\n                assert(Py_TYPE(r) == &PyRangeIter_Type);\n                STAT_INC(FOR_ITER, hit);\n                if (r->len <= 0) {\n                    STACK_SHRINK(1);\n                    Py_DECREF(r);\n                    // Jump over END_FOR and POP_TOP instructions.\n                    JUMPBY(oparg + 2);\n                    DISPATCH();\n                }\n            }\n            // _ITER_NEXT_RANGE\n            {\n                _PyRangeIterObject *r = (_PyRangeIterObject *)iter;\n                assert(Py_TYPE(r) == &PyRangeIter_Type);\n                assert(r->len > 0);\n                long value = r->start;\n                r->start = value + r->step;\n                r->len--;\n                next = PyLong_FromLong(value);\n                if (next == NULL) goto error;\n            }\n            stack_pointer[0] = next;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(FOR_ITER_TUPLE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(FOR_ITER_TUPLE);\n            static_assert(INLINE_CACHE_ENTRIES_FOR_ITER == 1, \"incorrect cache size\");\n            PyObject *iter;\n            PyObject *next;\n            /* Skip 1 cache entry */\n            // _ITER_CHECK_TUPLE\n            iter = stack_pointer[-1];\n            {\n                DEOPT_IF(Py_TYPE(iter) != &PyTupleIter_Type, FOR_ITER);\n            }\n            // _ITER_JUMP_TUPLE\n            {\n                _PyTupleIterObject *it = (_PyTupleIterObject *)iter;\n                assert(Py_TYPE(iter) == &PyTupleIter_Type);\n                STAT_INC(FOR_ITER, hit);\n                PyTupleObject *seq = it->it_seq;\n                if (seq == NULL || it->it_index >= PyTuple_GET_SIZE(seq)) {\n                    if (seq != NULL) {\n                        it->it_seq = NULL;\n                        Py_DECREF(seq);\n                    }\n                    Py_DECREF(iter);\n                    STACK_SHRINK(1);\n                    /* Jump forward oparg, then skip following END_FOR and POP_TOP instructions */\n                    JUMPBY(oparg + 2);\n                    DISPATCH();\n                }\n            }\n            // _ITER_NEXT_TUPLE\n            {\n                _PyTupleIterObject *it = (_PyTupleIterObject *)iter;\n                assert(Py_TYPE(iter) == &PyTupleIter_Type);\n                PyTupleObject *seq = it->it_seq;\n                assert(seq);\n                assert(it->it_index < PyTuple_GET_SIZE(seq));\n                next = Py_NewRef(PyTuple_GET_ITEM(seq, it->it_index++));\n            }\n            stack_pointer[0] = next;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(GET_AITER) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(GET_AITER);\n            PyObject *obj;\n            PyObject *iter;\n            obj = stack_pointer[-1];\n            unaryfunc getter = NULL;\n            PyTypeObject *type = Py_TYPE(obj);\n            if (type->tp_as_async != NULL) {\n                getter = type->tp_as_async->am_aiter;\n            }\n            if (getter == NULL) {\n                _PyErr_Format(tstate, PyExc_TypeError,\n                              \"'async for' requires an object with \"\n                              \"__aiter__ method, got %.100s\",\n                              type->tp_name);\n                Py_DECREF(obj);\n                if (true) goto pop_1_error;\n            }\n            iter = (*getter)(obj);\n            Py_DECREF(obj);\n            if (iter == NULL) goto pop_1_error;\n            if (Py_TYPE(iter)->tp_as_async == NULL ||\n                Py_TYPE(iter)->tp_as_async->am_anext == NULL) {\n                _PyErr_Format(tstate, PyExc_TypeError,\n                              \"'async for' received an object from __aiter__ \"\n                              \"that does not implement __anext__: %.100s\",\n                              Py_TYPE(iter)->tp_name);\n                Py_DECREF(iter);\n                if (true) goto pop_1_error;\n            }\n            stack_pointer[-1] = iter;\n            DISPATCH();\n        }\n\n        TARGET(GET_ANEXT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(GET_ANEXT);\n            PyObject *aiter;\n            PyObject *awaitable;\n            aiter = stack_pointer[-1];\n            unaryfunc getter = NULL;\n            PyObject *next_iter = NULL;\n            PyTypeObject *type = Py_TYPE(aiter);\n            if (PyAsyncGen_CheckExact(aiter)) {\n                awaitable = type->tp_as_async->am_anext(aiter);\n                if (awaitable == NULL) {\n                    goto error;\n                }\n            } else {\n                if (type->tp_as_async != NULL){\n                    getter = type->tp_as_async->am_anext;\n                }\n                if (getter != NULL) {\n                    next_iter = (*getter)(aiter);\n                    if (next_iter == NULL) {\n                        goto error;\n                    }\n                }\n                else {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"'async for' requires an iterator with \"\n                                  \"__anext__ method, got %.100s\",\n                                  type->tp_name);\n                    goto error;\n                }\n                awaitable = _PyCoro_GetAwaitableIter(next_iter);\n                if (awaitable == NULL) {\n                    _PyErr_FormatFromCause(\n                        PyExc_TypeError,\n                        \"'async for' received an invalid object \"\n                        \"from __anext__: %.100s\",\n                        Py_TYPE(next_iter)->tp_name);\n                    Py_DECREF(next_iter);\n                    goto error;\n                } else {\n                    Py_DECREF(next_iter);\n                }\n            }\n            stack_pointer[0] = awaitable;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(GET_AWAITABLE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(GET_AWAITABLE);\n            PyObject *iterable;\n            PyObject *iter;\n            iterable = stack_pointer[-1];\n            iter = _PyCoro_GetAwaitableIter(iterable);\n            if (iter == NULL) {\n                _PyEval_FormatAwaitableError(tstate, Py_TYPE(iterable), oparg);\n            }\n            Py_DECREF(iterable);\n            if (iter != NULL && PyCoro_CheckExact(iter)) {\n                PyObject *yf = _PyGen_yf((PyGenObject*)iter);\n                if (yf != NULL) {\n                    /* `iter` is a coroutine object that is being\n                       awaited, `yf` is a pointer to the current awaitable\n                       being awaited on. */\n                    Py_DECREF(yf);\n                    Py_CLEAR(iter);\n                    _PyErr_SetString(tstate, PyExc_RuntimeError,\n                                     \"coroutine is being awaited already\");\n                    /* The code below jumps to `error` if `iter` is NULL. */\n                }\n            }\n            if (iter == NULL) goto pop_1_error;\n            stack_pointer[-1] = iter;\n            DISPATCH();\n        }\n\n        TARGET(GET_ITER) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(GET_ITER);\n            PyObject *iterable;\n            PyObject *iter;\n            iterable = stack_pointer[-1];\n            /* before: [obj]; after [getiter(obj)] */\n            iter = PyObject_GetIter(iterable);\n            Py_DECREF(iterable);\n            if (iter == NULL) goto pop_1_error;\n            stack_pointer[-1] = iter;\n            DISPATCH();\n        }\n\n        TARGET(GET_LEN) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(GET_LEN);\n            PyObject *obj;\n            PyObject *len_o;\n            obj = stack_pointer[-1];\n            // PUSH(len(TOS))\n            Py_ssize_t len_i = PyObject_Length(obj);\n            if (len_i < 0) goto error;\n            len_o = PyLong_FromSsize_t(len_i);\n            if (len_o == NULL) goto error;\n            stack_pointer[0] = len_o;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(GET_YIELD_FROM_ITER) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(GET_YIELD_FROM_ITER);\n            PyObject *iterable;\n            PyObject *iter;\n            iterable = stack_pointer[-1];\n            /* before: [obj]; after [getiter(obj)] */\n            if (PyCoro_CheckExact(iterable)) {\n                /* `iterable` is a coroutine */\n                if (!(_PyFrame_GetCode(frame)->co_flags & (CO_COROUTINE | CO_ITERABLE_COROUTINE))) {\n                    /* and it is used in a 'yield from' expression of a\n                       regular generator. */\n                    _PyErr_SetString(tstate, PyExc_TypeError,\n                                     \"cannot 'yield from' a coroutine object \"\n                                     \"in a non-coroutine generator\");\n                    goto error;\n                }\n                iter = iterable;\n            }\n            else if (PyGen_CheckExact(iterable)) {\n                iter = iterable;\n            }\n            else {\n                /* `iterable` is not a generator. */\n                iter = PyObject_GetIter(iterable);\n                if (iter == NULL) {\n                    goto error;\n                }\n                Py_DECREF(iterable);\n            }\n            stack_pointer[-1] = iter;\n            DISPATCH();\n        }\n\n        TARGET(IMPORT_FROM) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(IMPORT_FROM);\n            PyObject *from;\n            PyObject *res;\n            from = stack_pointer[-1];\n            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);\n            res = import_from(tstate, from, name);\n            if (res == NULL) goto error;\n            stack_pointer[0] = res;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(IMPORT_NAME) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(IMPORT_NAME);\n            PyObject *fromlist;\n            PyObject *level;\n            PyObject *res;\n            fromlist = stack_pointer[-1];\n            level = stack_pointer[-2];\n            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);\n            res = import_name(tstate, frame, name, fromlist, level);\n            Py_DECREF(level);\n            Py_DECREF(fromlist);\n            if (res == NULL) goto pop_2_error;\n            stack_pointer[-2] = res;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(INSTRUMENTED_CALL) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(INSTRUMENTED_CALL);\n            /* Skip 3 cache entries */\n            int is_meth = PEEK(oparg + 1) != NULL;\n            int total_args = oparg + is_meth;\n            PyObject *function = PEEK(oparg + 2);\n            PyObject *arg = total_args == 0 ?\n            &_PyInstrumentation_MISSING : PEEK(total_args);\n            int err = _Py_call_instrumentation_2args(\n                tstate, PY_MONITORING_EVENT_CALL,\n                frame, this_instr, function, arg);\n            if (err) goto error;\n            PAUSE_ADAPTIVE_COUNTER(this_instr[1].counter);\n            GO_TO_INSTRUCTION(CALL);\n        }\n\n        TARGET(INSTRUMENTED_CALL_FUNCTION_EX) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(INSTRUMENTED_CALL_FUNCTION_EX);\n            GO_TO_INSTRUCTION(CALL_FUNCTION_EX);\n        }\n\n        TARGET(INSTRUMENTED_CALL_KW) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(INSTRUMENTED_CALL_KW);\n            int is_meth = PEEK(oparg + 2) != NULL;\n            int total_args = oparg + is_meth;\n            PyObject *function = PEEK(oparg + 3);\n            PyObject *arg = total_args == 0 ? &_PyInstrumentation_MISSING\n        : PEEK(total_args + 1);\n            int err = _Py_call_instrumentation_2args(\n                tstate, PY_MONITORING_EVENT_CALL,\n                frame, this_instr, function, arg);\n            if (err) goto error;\n            GO_TO_INSTRUCTION(CALL_KW);\n        }\n\n        TARGET(INSTRUMENTED_END_FOR) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(INSTRUMENTED_END_FOR);\n            PyObject *value;\n            PyObject *receiver;\n            value = stack_pointer[-1];\n            receiver = stack_pointer[-2];\n            /* Need to create a fake StopIteration error here,\n             * to conform to PEP 380 */\n            if (PyGen_Check(receiver)) {\n                if (monitor_stop_iteration(tstate, frame, this_instr, value)) {\n                    goto error;\n                }\n            }\n            Py_DECREF(value);\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(INSTRUMENTED_END_SEND) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(INSTRUMENTED_END_SEND);\n            PyObject *value;\n            PyObject *receiver;\n            value = stack_pointer[-1];\n            receiver = stack_pointer[-2];\n            if (PyGen_Check(receiver) || PyCoro_CheckExact(receiver)) {\n                if (monitor_stop_iteration(tstate, frame, this_instr, value)) {\n                    goto error;\n                }\n            }\n            Py_DECREF(receiver);\n            stack_pointer[-2] = value;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(INSTRUMENTED_FOR_ITER) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(INSTRUMENTED_FOR_ITER);\n            /* Skip 1 cache entry */\n            _Py_CODEUNIT *target;\n            PyObject *iter = TOP();\n            PyObject *next = (*Py_TYPE(iter)->tp_iternext)(iter);\n            if (next != NULL) {\n                PUSH(next);\n                target = next_instr;\n            }\n            else {\n                if (_PyErr_Occurred(tstate)) {\n                    if (!_PyErr_ExceptionMatches(tstate, PyExc_StopIteration)) {\n                        goto error;\n                    }\n                    monitor_raise(tstate, frame, this_instr);\n                    _PyErr_Clear(tstate);\n                }\n                /* iterator ended normally */\n                assert(next_instr[oparg].op.code == END_FOR ||\n                       next_instr[oparg].op.code == INSTRUMENTED_END_FOR);\n                STACK_SHRINK(1);\n                Py_DECREF(iter);\n                /* Skip END_FOR and POP_TOP */\n                target = next_instr + oparg + 2;\n            }\n            INSTRUMENTED_JUMP(this_instr, target, PY_MONITORING_EVENT_BRANCH);\n            DISPATCH();\n        }\n\n        TARGET(INSTRUMENTED_INSTRUCTION) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(INSTRUMENTED_INSTRUCTION);\n            int next_opcode = _Py_call_instrumentation_instruction(\n                tstate, frame, this_instr);\n            if (next_opcode < 0) goto error;\n            next_instr = this_instr;\n            if (_PyOpcode_Caches[next_opcode]) {\n                PAUSE_ADAPTIVE_COUNTER(next_instr[1].counter);\n            }\n            assert(next_opcode > 0 && next_opcode < 256);\n            opcode = next_opcode;\n            DISPATCH_GOTO();\n        }\n\n        TARGET(INSTRUMENTED_JUMP_BACKWARD) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(INSTRUMENTED_JUMP_BACKWARD);\n            /* Skip 1 cache entry */\n            CHECK_EVAL_BREAKER();\n            INSTRUMENTED_JUMP(this_instr, next_instr - oparg, PY_MONITORING_EVENT_JUMP);\n            DISPATCH();\n        }\n\n        TARGET(INSTRUMENTED_JUMP_FORWARD) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(INSTRUMENTED_JUMP_FORWARD);\n            INSTRUMENTED_JUMP(this_instr, next_instr + oparg, PY_MONITORING_EVENT_JUMP);\n            DISPATCH();\n        }\n\n        TARGET(INSTRUMENTED_LOAD_SUPER_ATTR) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(INSTRUMENTED_LOAD_SUPER_ATTR);\n            /* Skip 1 cache entry */\n            // cancel out the decrement that will happen in LOAD_SUPER_ATTR; we\n            // don't want to specialize instrumented instructions\n            PAUSE_ADAPTIVE_COUNTER(this_instr[1].counter);\n            GO_TO_INSTRUCTION(LOAD_SUPER_ATTR);\n        }\n\n        TARGET(INSTRUMENTED_POP_JUMP_IF_FALSE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(INSTRUMENTED_POP_JUMP_IF_FALSE);\n            /* Skip 1 cache entry */\n            PyObject *cond = POP();\n            assert(PyBool_Check(cond));\n            int flag = Py_IsFalse(cond);\n            int offset = flag * oparg;\n            #if ENABLE_SPECIALIZATION\n            this_instr[1].cache = (this_instr[1].cache << 1) | flag;\n            #endif\n            INSTRUMENTED_JUMP(this_instr, next_instr + offset, PY_MONITORING_EVENT_BRANCH);\n            DISPATCH();\n        }\n\n        TARGET(INSTRUMENTED_POP_JUMP_IF_NONE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(INSTRUMENTED_POP_JUMP_IF_NONE);\n            /* Skip 1 cache entry */\n            PyObject *value = POP();\n            int flag = Py_IsNone(value);\n            int offset;\n            if (flag) {\n                offset = oparg;\n            }\n            else {\n                Py_DECREF(value);\n                offset = 0;\n            }\n            #if ENABLE_SPECIALIZATION\n            this_instr[1].cache = (this_instr[1].cache << 1) | flag;\n            #endif\n            INSTRUMENTED_JUMP(this_instr, next_instr + offset, PY_MONITORING_EVENT_BRANCH);\n            DISPATCH();\n        }\n\n        TARGET(INSTRUMENTED_POP_JUMP_IF_NOT_NONE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(INSTRUMENTED_POP_JUMP_IF_NOT_NONE);\n            /* Skip 1 cache entry */\n            PyObject *value = POP();\n            int offset;\n            int nflag = Py_IsNone(value);\n            if (nflag) {\n                offset = 0;\n            }\n            else {\n                Py_DECREF(value);\n                offset = oparg;\n            }\n            #if ENABLE_SPECIALIZATION\n            this_instr[1].cache = (this_instr[1].cache << 1) | !nflag;\n            #endif\n            INSTRUMENTED_JUMP(this_instr, next_instr + offset, PY_MONITORING_EVENT_BRANCH);\n            DISPATCH();\n        }\n\n        TARGET(INSTRUMENTED_POP_JUMP_IF_TRUE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(INSTRUMENTED_POP_JUMP_IF_TRUE);\n            /* Skip 1 cache entry */\n            PyObject *cond = POP();\n            assert(PyBool_Check(cond));\n            int flag = Py_IsTrue(cond);\n            int offset = flag * oparg;\n            #if ENABLE_SPECIALIZATION\n            this_instr[1].cache = (this_instr[1].cache << 1) | flag;\n            #endif\n            INSTRUMENTED_JUMP(this_instr, next_instr + offset, PY_MONITORING_EVENT_BRANCH);\n            DISPATCH();\n        }\n\n        TARGET(INSTRUMENTED_RESUME) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(INSTRUMENTED_RESUME);\n            uintptr_t global_version = _Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker) & ~_PY_EVAL_EVENTS_MASK;\n            uintptr_t code_version = FT_ATOMIC_LOAD_UINTPTR_ACQUIRE(_PyFrame_GetCode(frame)->_co_instrumentation_version);\n            if (code_version != global_version && tstate->tracing == 0) {\n                if (_Py_Instrument(_PyFrame_GetCode(frame), tstate->interp)) {\n                    goto error;\n                }\n                next_instr = this_instr;\n            }\n            else {\n                if ((oparg & RESUME_OPARG_LOCATION_MASK) < RESUME_AFTER_YIELD_FROM) {\n                    CHECK_EVAL_BREAKER();\n                }\n                _PyFrame_SetStackPointer(frame, stack_pointer);\n                int err = _Py_call_instrumentation(\n                    tstate, oparg > 0, frame, this_instr);\n                stack_pointer = _PyFrame_GetStackPointer(frame);\n                if (err) goto error;\n                if (frame->instr_ptr != this_instr) {\n                    /* Instrumentation has jumped */\n                    next_instr = frame->instr_ptr;\n                    DISPATCH();\n                }\n            }\n            DISPATCH();\n        }\n\n        TARGET(INSTRUMENTED_RETURN_CONST) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(INSTRUMENTED_RETURN_CONST);\n            PyObject *retval = GETITEM(FRAME_CO_CONSTS, oparg);\n            int err = _Py_call_instrumentation_arg(\n                tstate, PY_MONITORING_EVENT_PY_RETURN,\n                frame, this_instr, retval);\n            if (err) goto error;\n            Py_INCREF(retval);\n            assert(EMPTY());\n            _PyFrame_SetStackPointer(frame, stack_pointer);\n            _Py_LeaveRecursiveCallPy(tstate);\n            assert(frame != &entry_frame);\n            // GH-99729: We need to unlink the frame *before* clearing it:\n            _PyInterpreterFrame *dying = frame;\n            frame = tstate->current_frame = dying->previous;\n            _PyEval_FrameClearAndPop(tstate, dying);\n            _PyFrame_StackPush(frame, retval);\n            LOAD_IP(frame->return_offset);\n            goto resume_frame;\n        }\n\n        TARGET(INSTRUMENTED_RETURN_VALUE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(INSTRUMENTED_RETURN_VALUE);\n            PyObject *retval;\n            retval = stack_pointer[-1];\n            int err = _Py_call_instrumentation_arg(\n                tstate, PY_MONITORING_EVENT_PY_RETURN,\n                frame, this_instr, retval);\n            if (err) goto error;\n            STACK_SHRINK(1);\n            assert(EMPTY());\n            _PyFrame_SetStackPointer(frame, stack_pointer);\n            _Py_LeaveRecursiveCallPy(tstate);\n            assert(frame != &entry_frame);\n            // GH-99729: We need to unlink the frame *before* clearing it:\n            _PyInterpreterFrame *dying = frame;\n            frame = tstate->current_frame = dying->previous;\n            _PyEval_FrameClearAndPop(tstate, dying);\n            _PyFrame_StackPush(frame, retval);\n            LOAD_IP(frame->return_offset);\n            goto resume_frame;\n        }\n\n        TARGET(INSTRUMENTED_YIELD_VALUE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(INSTRUMENTED_YIELD_VALUE);\n            PyObject *retval;\n            retval = stack_pointer[-1];\n            assert(frame != &entry_frame);\n            frame->instr_ptr = next_instr;\n            PyGenObject *gen = _PyFrame_GetGenerator(frame);\n            assert(FRAME_SUSPENDED_YIELD_FROM == FRAME_SUSPENDED + 1);\n            assert(oparg == 0 || oparg == 1);\n            gen->gi_frame_state = FRAME_SUSPENDED + oparg;\n            _PyFrame_SetStackPointer(frame, stack_pointer - 1);\n            int err = _Py_call_instrumentation_arg(\n                tstate, PY_MONITORING_EVENT_PY_YIELD,\n                frame, this_instr, retval);\n            if (err) goto error;\n            tstate->exc_info = gen->gi_exc_state.previous_item;\n            gen->gi_exc_state.previous_item = NULL;\n            _Py_LeaveRecursiveCallPy(tstate);\n            _PyInterpreterFrame *gen_frame = frame;\n            frame = tstate->current_frame = frame->previous;\n            gen_frame->previous = NULL;\n            _PyFrame_StackPush(frame, retval);\n            /* We don't know which of these is relevant here, so keep them equal */\n            assert(INLINE_CACHE_ENTRIES_SEND == INLINE_CACHE_ENTRIES_FOR_ITER);\n            LOAD_IP(1 + INLINE_CACHE_ENTRIES_SEND);\n            goto resume_frame;\n        }\n\n        TARGET(INTERPRETER_EXIT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(INTERPRETER_EXIT);\n            PyObject *retval;\n            retval = stack_pointer[-1];\n            assert(frame == &entry_frame);\n            assert(_PyFrame_IsIncomplete(frame));\n            /* Restore previous frame and return. */\n            tstate->current_frame = frame->previous;\n            assert(!_PyErr_Occurred(tstate));\n            tstate->c_recursion_remaining += PY_EVAL_C_STACK_UNITS;\n            return retval;\n        }\n\n        TARGET(IS_OP) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(IS_OP);\n            PyObject *right;\n            PyObject *left;\n            PyObject *b;\n            right = stack_pointer[-1];\n            left = stack_pointer[-2];\n            int res = Py_Is(left, right) ^ oparg;\n            Py_DECREF(left);\n            Py_DECREF(right);\n            b = res ? Py_True : Py_False;\n            stack_pointer[-2] = b;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(JUMP_BACKWARD) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(JUMP_BACKWARD);\n            /* Skip 1 cache entry */\n            CHECK_EVAL_BREAKER();\n            assert(oparg <= INSTR_OFFSET());\n            JUMPBY(-oparg);\n            #ifdef _Py_TIER2\n            #if ENABLE_SPECIALIZATION\n            _Py_BackoffCounter counter = this_instr[1].counter;\n            if (backoff_counter_triggers(counter) && this_instr->op.code == JUMP_BACKWARD) {\n                _Py_CODEUNIT *start = this_instr;\n                /* Back up over EXTENDED_ARGs so optimizer sees the whole instruction */\n                while (oparg > 255) {\n                    oparg >>= 8;\n                    start--;\n                }\n                _PyExecutorObject *executor;\n                int optimized = _PyOptimizer_Optimize(frame, start, stack_pointer, &executor);\n                if (optimized < 0) goto error;\n                if (optimized) {\n                    assert(tstate->previous_executor == NULL);\n                    tstate->previous_executor = Py_None;\n                    GOTO_TIER_TWO(executor);\n                }\n                else {\n                    this_instr[1].counter = restart_backoff_counter(counter);\n                }\n            }\n            else {\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n            }\n            #endif  /* ENABLE_SPECIALIZATION */\n            #endif /* _Py_TIER2 */\n            DISPATCH();\n        }\n\n        TARGET(JUMP_BACKWARD_NO_INTERRUPT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(JUMP_BACKWARD_NO_INTERRUPT);\n            /* This bytecode is used in the `yield from` or `await` loop.\n             * If there is an interrupt, we want it handled in the innermost\n             * generator or coroutine, so we deliberately do not check it here.\n             * (see bpo-30039).\n             */\n            JUMPBY(-oparg);\n            DISPATCH();\n        }\n\n        TARGET(JUMP_FORWARD) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(JUMP_FORWARD);\n            JUMPBY(oparg);\n            DISPATCH();\n        }\n\n        TARGET(LIST_APPEND) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LIST_APPEND);\n            PyObject *v;\n            PyObject *list;\n            v = stack_pointer[-1];\n            list = stack_pointer[-2 - (oparg-1)];\n            if (_PyList_AppendTakeRef((PyListObject *)list, v) < 0) goto pop_1_error;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(LIST_EXTEND) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LIST_EXTEND);\n            PyObject *iterable;\n            PyObject *list;\n            iterable = stack_pointer[-1];\n            list = stack_pointer[-2 - (oparg-1)];\n            PyObject *none_val = _PyList_Extend((PyListObject *)list, iterable);\n            if (none_val == NULL) {\n                if (_PyErr_ExceptionMatches(tstate, PyExc_TypeError) &&\n                    (Py_TYPE(iterable)->tp_iter == NULL && !PySequence_Check(iterable)))\n                {\n                    _PyErr_Clear(tstate);\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"Value after * must be an iterable, not %.200s\",\n                                  Py_TYPE(iterable)->tp_name);\n                }\n                Py_DECREF(iterable);\n                if (true) goto pop_1_error;\n            }\n            assert(Py_IsNone(none_val));\n            Py_DECREF(iterable);\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_ASSERTION_ERROR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LOAD_ASSERTION_ERROR);\n            PyObject *value;\n            value = Py_NewRef(PyExc_AssertionError);\n            stack_pointer[0] = value;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_ATTR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 10;\n            INSTRUCTION_STATS(LOAD_ATTR);\n            PREDICTED(LOAD_ATTR);\n            _Py_CODEUNIT *this_instr = next_instr - 10;\n            (void)this_instr;\n            PyObject *owner;\n            PyObject *attr;\n            PyObject *self_or_null = NULL;\n            // _SPECIALIZE_LOAD_ATTR\n            owner = stack_pointer[-1];\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    PyObject *name = GETITEM(FRAME_CO_NAMES, oparg>>1);\n                    next_instr = this_instr;\n                    _Py_Specialize_LoadAttr(owner, next_instr, name);\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(LOAD_ATTR, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n            }\n            /* Skip 8 cache entries */\n            // _LOAD_ATTR\n            {\n                PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 1);\n                if (oparg & 1) {\n                    /* Designed to work in tandem with CALL, pushes two values. */\n                    attr = NULL;\n                    if (_PyObject_GetMethod(owner, name, &attr)) {\n                        /* We can bypass temporary bound method object.\n                           meth is unbound method and obj is self.\n                           meth | self | arg1 | ... | argN\n                         */\n                        assert(attr != NULL);  // No errors on this branch\n                        self_or_null = owner;  // Transfer ownership\n                    }\n                    else {\n                        /* meth is not an unbound method (but a regular attr, or\n                           something was returned by a descriptor protocol).  Set\n                           the second element of the stack to NULL, to signal\n                           CALL that it's not a method call.\n                           meth | NULL | arg1 | ... | argN\n                         */\n                        Py_DECREF(owner);\n                        if (attr == NULL) goto pop_1_error;\n                        self_or_null = NULL;\n                    }\n                }\n                else {\n                    /* Classic, pushes one value. */\n                    attr = PyObject_GetAttr(owner, name);\n                    Py_DECREF(owner);\n                    if (attr == NULL) goto pop_1_error;\n                }\n            }\n            stack_pointer[-1] = attr;\n            if (oparg & 1) stack_pointer[0] = self_or_null;\n            stack_pointer += (oparg & 1);\n            DISPATCH();\n        }\n\n        TARGET(LOAD_ATTR_CLASS) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 10;\n            INSTRUCTION_STATS(LOAD_ATTR_CLASS);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_ATTR == 9, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *attr;\n            PyObject *null = NULL;\n            /* Skip 1 cache entry */\n            // _CHECK_ATTR_CLASS\n            owner = stack_pointer[-1];\n            {\n                uint32_t type_version = read_u32(&this_instr[2].cache);\n                DEOPT_IF(!PyType_Check(owner), LOAD_ATTR);\n                assert(type_version != 0);\n                DEOPT_IF(((PyTypeObject *)owner)->tp_version_tag != type_version, LOAD_ATTR);\n            }\n            /* Skip 2 cache entries */\n            // _LOAD_ATTR_CLASS\n            {\n                PyObject *descr = read_obj(&this_instr[6].cache);\n                STAT_INC(LOAD_ATTR, hit);\n                assert(descr != NULL);\n                attr = Py_NewRef(descr);\n                null = NULL;\n                Py_DECREF(owner);\n            }\n            stack_pointer[-1] = attr;\n            if (oparg & 1) stack_pointer[0] = null;\n            stack_pointer += (oparg & 1);\n            DISPATCH();\n        }\n\n        TARGET(LOAD_ATTR_GETATTRIBUTE_OVERRIDDEN) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 10;\n            INSTRUCTION_STATS(LOAD_ATTR_GETATTRIBUTE_OVERRIDDEN);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_ATTR == 9, \"incorrect cache size\");\n            PyObject *owner;\n            /* Skip 1 cache entry */\n            owner = stack_pointer[-1];\n            uint32_t type_version = read_u32(&this_instr[2].cache);\n            uint32_t func_version = read_u32(&this_instr[4].cache);\n            PyObject *getattribute = read_obj(&this_instr[6].cache);\n            assert((oparg & 1) == 0);\n            DEOPT_IF(tstate->interp->eval_frame, LOAD_ATTR);\n            PyTypeObject *cls = Py_TYPE(owner);\n            assert(type_version != 0);\n            DEOPT_IF(cls->tp_version_tag != type_version, LOAD_ATTR);\n            assert(Py_IS_TYPE(getattribute, &PyFunction_Type));\n            PyFunctionObject *f = (PyFunctionObject *)getattribute;\n            assert(func_version != 0);\n            DEOPT_IF(f->func_version != func_version, LOAD_ATTR);\n            PyCodeObject *code = (PyCodeObject *)f->func_code;\n            assert(code->co_argcount == 2);\n            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), LOAD_ATTR);\n            STAT_INC(LOAD_ATTR, hit);\n            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 1);\n            Py_INCREF(f);\n            _PyInterpreterFrame *new_frame = _PyFrame_PushUnchecked(tstate, f, 2);\n            // Manipulate stack directly because we exit with DISPATCH_INLINED().\n            STACK_SHRINK(1);\n            new_frame->localsplus[0] = owner;\n            new_frame->localsplus[1] = Py_NewRef(name);\n            frame->return_offset = (uint16_t)(next_instr - this_instr);\n            DISPATCH_INLINED(new_frame);\n        }\n\n        TARGET(LOAD_ATTR_INSTANCE_VALUE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 10;\n            INSTRUCTION_STATS(LOAD_ATTR_INSTANCE_VALUE);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_ATTR == 9, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *attr;\n            PyObject *null = NULL;\n            /* Skip 1 cache entry */\n            // _GUARD_TYPE_VERSION\n            owner = stack_pointer[-1];\n            {\n                uint32_t type_version = read_u32(&this_instr[2].cache);\n                PyTypeObject *tp = Py_TYPE(owner);\n                assert(type_version != 0);\n                DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);\n            }\n            // _CHECK_MANAGED_OBJECT_HAS_VALUES\n            {\n                assert(Py_TYPE(owner)->tp_dictoffset < 0);\n                assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_INLINE_VALUES);\n                DEOPT_IF(!_PyObject_InlineValues(owner)->valid, LOAD_ATTR);\n            }\n            // _LOAD_ATTR_INSTANCE_VALUE\n            {\n                uint16_t index = read_u16(&this_instr[4].cache);\n                attr = _PyObject_InlineValues(owner)->values[index];\n                DEOPT_IF(attr == NULL, LOAD_ATTR);\n                STAT_INC(LOAD_ATTR, hit);\n                Py_INCREF(attr);\n                null = NULL;\n                Py_DECREF(owner);\n            }\n            /* Skip 5 cache entries */\n            stack_pointer[-1] = attr;\n            if (oparg & 1) stack_pointer[0] = null;\n            stack_pointer += (oparg & 1);\n            DISPATCH();\n        }\n\n        TARGET(LOAD_ATTR_METHOD_LAZY_DICT) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 10;\n            INSTRUCTION_STATS(LOAD_ATTR_METHOD_LAZY_DICT);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_ATTR == 9, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *attr;\n            PyObject *self = NULL;\n            /* Skip 1 cache entry */\n            // _GUARD_TYPE_VERSION\n            owner = stack_pointer[-1];\n            {\n                uint32_t type_version = read_u32(&this_instr[2].cache);\n                PyTypeObject *tp = Py_TYPE(owner);\n                assert(type_version != 0);\n                DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);\n            }\n            // _CHECK_ATTR_METHOD_LAZY_DICT\n            {\n                uint16_t dictoffset = read_u16(&this_instr[4].cache);\n                char *ptr = ((char *)owner) + MANAGED_DICT_OFFSET + dictoffset;\n                PyObject *dict = *(PyObject **)ptr;\n                /* This object has a __dict__, just not yet created */\n                DEOPT_IF(dict != NULL, LOAD_ATTR);\n            }\n            /* Skip 1 cache entry */\n            // _LOAD_ATTR_METHOD_LAZY_DICT\n            {\n                PyObject *descr = read_obj(&this_instr[6].cache);\n                assert(oparg & 1);\n                STAT_INC(LOAD_ATTR, hit);\n                assert(descr != NULL);\n                assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));\n                attr = Py_NewRef(descr);\n                self = owner;\n            }\n            stack_pointer[-1] = attr;\n            stack_pointer[0] = self;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_ATTR_METHOD_NO_DICT) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 10;\n            INSTRUCTION_STATS(LOAD_ATTR_METHOD_NO_DICT);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_ATTR == 9, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *attr;\n            PyObject *self = NULL;\n            /* Skip 1 cache entry */\n            // _GUARD_TYPE_VERSION\n            owner = stack_pointer[-1];\n            {\n                uint32_t type_version = read_u32(&this_instr[2].cache);\n                PyTypeObject *tp = Py_TYPE(owner);\n                assert(type_version != 0);\n                DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);\n            }\n            /* Skip 2 cache entries */\n            // _LOAD_ATTR_METHOD_NO_DICT\n            {\n                PyObject *descr = read_obj(&this_instr[6].cache);\n                assert(oparg & 1);\n                assert(Py_TYPE(owner)->tp_dictoffset == 0);\n                STAT_INC(LOAD_ATTR, hit);\n                assert(descr != NULL);\n                assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));\n                attr = Py_NewRef(descr);\n                self = owner;\n            }\n            stack_pointer[-1] = attr;\n            stack_pointer[0] = self;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_ATTR_METHOD_WITH_VALUES) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 10;\n            INSTRUCTION_STATS(LOAD_ATTR_METHOD_WITH_VALUES);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_ATTR == 9, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *attr;\n            PyObject *self = NULL;\n            /* Skip 1 cache entry */\n            // _GUARD_TYPE_VERSION\n            owner = stack_pointer[-1];\n            {\n                uint32_t type_version = read_u32(&this_instr[2].cache);\n                PyTypeObject *tp = Py_TYPE(owner);\n                assert(type_version != 0);\n                DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);\n            }\n            // _GUARD_DORV_VALUES_INST_ATTR_FROM_DICT\n            {\n                assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_INLINE_VALUES);\n                DEOPT_IF(!_PyObject_InlineValues(owner)->valid, LOAD_ATTR);\n            }\n            // _GUARD_KEYS_VERSION\n            {\n                uint32_t keys_version = read_u32(&this_instr[4].cache);\n                PyTypeObject *owner_cls = Py_TYPE(owner);\n                PyHeapTypeObject *owner_heap_type = (PyHeapTypeObject *)owner_cls;\n                DEOPT_IF(owner_heap_type->ht_cached_keys->dk_version != keys_version, LOAD_ATTR);\n            }\n            // _LOAD_ATTR_METHOD_WITH_VALUES\n            {\n                PyObject *descr = read_obj(&this_instr[6].cache);\n                assert(oparg & 1);\n                /* Cached method object */\n                STAT_INC(LOAD_ATTR, hit);\n                assert(descr != NULL);\n                attr = Py_NewRef(descr);\n                assert(_PyType_HasFeature(Py_TYPE(attr), Py_TPFLAGS_METHOD_DESCRIPTOR));\n                self = owner;\n            }\n            stack_pointer[-1] = attr;\n            stack_pointer[0] = self;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_ATTR_MODULE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 10;\n            INSTRUCTION_STATS(LOAD_ATTR_MODULE);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_ATTR == 9, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *attr;\n            PyObject *null = NULL;\n            /* Skip 1 cache entry */\n            // _CHECK_ATTR_MODULE\n            owner = stack_pointer[-1];\n            {\n                uint32_t dict_version = read_u32(&this_instr[2].cache);\n                DEOPT_IF(!PyModule_CheckExact(owner), LOAD_ATTR);\n                PyDictObject *dict = (PyDictObject *)((PyModuleObject *)owner)->md_dict;\n                assert(dict != NULL);\n                DEOPT_IF(dict->ma_keys->dk_version != dict_version, LOAD_ATTR);\n            }\n            // _LOAD_ATTR_MODULE\n            {\n                uint16_t index = read_u16(&this_instr[4].cache);\n                PyDictObject *dict = (PyDictObject *)((PyModuleObject *)owner)->md_dict;\n                assert(dict->ma_keys->dk_kind == DICT_KEYS_UNICODE);\n                assert(index < dict->ma_keys->dk_nentries);\n                PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(dict->ma_keys) + index;\n                attr = ep->me_value;\n                DEOPT_IF(attr == NULL, LOAD_ATTR);\n                STAT_INC(LOAD_ATTR, hit);\n                Py_INCREF(attr);\n                null = NULL;\n                Py_DECREF(owner);\n            }\n            /* Skip 5 cache entries */\n            stack_pointer[-1] = attr;\n            if (oparg & 1) stack_pointer[0] = null;\n            stack_pointer += (oparg & 1);\n            DISPATCH();\n        }\n\n        TARGET(LOAD_ATTR_NONDESCRIPTOR_NO_DICT) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 10;\n            INSTRUCTION_STATS(LOAD_ATTR_NONDESCRIPTOR_NO_DICT);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_ATTR == 9, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *attr;\n            /* Skip 1 cache entry */\n            // _GUARD_TYPE_VERSION\n            owner = stack_pointer[-1];\n            {\n                uint32_t type_version = read_u32(&this_instr[2].cache);\n                PyTypeObject *tp = Py_TYPE(owner);\n                assert(type_version != 0);\n                DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);\n            }\n            /* Skip 2 cache entries */\n            // _LOAD_ATTR_NONDESCRIPTOR_NO_DICT\n            {\n                PyObject *descr = read_obj(&this_instr[6].cache);\n                assert((oparg & 1) == 0);\n                assert(Py_TYPE(owner)->tp_dictoffset == 0);\n                STAT_INC(LOAD_ATTR, hit);\n                assert(descr != NULL);\n                Py_DECREF(owner);\n                attr = Py_NewRef(descr);\n            }\n            stack_pointer[-1] = attr;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_ATTR_NONDESCRIPTOR_WITH_VALUES) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 10;\n            INSTRUCTION_STATS(LOAD_ATTR_NONDESCRIPTOR_WITH_VALUES);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_ATTR == 9, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *attr;\n            /* Skip 1 cache entry */\n            // _GUARD_TYPE_VERSION\n            owner = stack_pointer[-1];\n            {\n                uint32_t type_version = read_u32(&this_instr[2].cache);\n                PyTypeObject *tp = Py_TYPE(owner);\n                assert(type_version != 0);\n                DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);\n            }\n            // _GUARD_DORV_VALUES_INST_ATTR_FROM_DICT\n            {\n                assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_INLINE_VALUES);\n                DEOPT_IF(!_PyObject_InlineValues(owner)->valid, LOAD_ATTR);\n            }\n            // _GUARD_KEYS_VERSION\n            {\n                uint32_t keys_version = read_u32(&this_instr[4].cache);\n                PyTypeObject *owner_cls = Py_TYPE(owner);\n                PyHeapTypeObject *owner_heap_type = (PyHeapTypeObject *)owner_cls;\n                DEOPT_IF(owner_heap_type->ht_cached_keys->dk_version != keys_version, LOAD_ATTR);\n            }\n            // _LOAD_ATTR_NONDESCRIPTOR_WITH_VALUES\n            {\n                PyObject *descr = read_obj(&this_instr[6].cache);\n                assert((oparg & 1) == 0);\n                STAT_INC(LOAD_ATTR, hit);\n                assert(descr != NULL);\n                Py_DECREF(owner);\n                attr = Py_NewRef(descr);\n            }\n            stack_pointer[-1] = attr;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_ATTR_PROPERTY) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 10;\n            INSTRUCTION_STATS(LOAD_ATTR_PROPERTY);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_ATTR == 9, \"incorrect cache size\");\n            PyObject *owner;\n            /* Skip 1 cache entry */\n            owner = stack_pointer[-1];\n            uint32_t type_version = read_u32(&this_instr[2].cache);\n            uint32_t func_version = read_u32(&this_instr[4].cache);\n            PyObject *fget = read_obj(&this_instr[6].cache);\n            assert((oparg & 1) == 0);\n            DEOPT_IF(tstate->interp->eval_frame, LOAD_ATTR);\n            PyTypeObject *cls = Py_TYPE(owner);\n            assert(type_version != 0);\n            DEOPT_IF(cls->tp_version_tag != type_version, LOAD_ATTR);\n            assert(Py_IS_TYPE(fget, &PyFunction_Type));\n            PyFunctionObject *f = (PyFunctionObject *)fget;\n            assert(func_version != 0);\n            DEOPT_IF(f->func_version != func_version, LOAD_ATTR);\n            PyCodeObject *code = (PyCodeObject *)f->func_code;\n            assert(code->co_argcount == 1);\n            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), LOAD_ATTR);\n            STAT_INC(LOAD_ATTR, hit);\n            Py_INCREF(fget);\n            _PyInterpreterFrame *new_frame = _PyFrame_PushUnchecked(tstate, f, 1);\n            // Manipulate stack directly because we exit with DISPATCH_INLINED().\n            STACK_SHRINK(1);\n            new_frame->localsplus[0] = owner;\n            frame->return_offset = (uint16_t)(next_instr - this_instr);\n            DISPATCH_INLINED(new_frame);\n        }\n\n        TARGET(LOAD_ATTR_SLOT) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 10;\n            INSTRUCTION_STATS(LOAD_ATTR_SLOT);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_ATTR == 9, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *attr;\n            PyObject *null = NULL;\n            /* Skip 1 cache entry */\n            // _GUARD_TYPE_VERSION\n            owner = stack_pointer[-1];\n            {\n                uint32_t type_version = read_u32(&this_instr[2].cache);\n                PyTypeObject *tp = Py_TYPE(owner);\n                assert(type_version != 0);\n                DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);\n            }\n            // _LOAD_ATTR_SLOT\n            {\n                uint16_t index = read_u16(&this_instr[4].cache);\n                char *addr = (char *)owner + index;\n                attr = *(PyObject **)addr;\n                DEOPT_IF(attr == NULL, LOAD_ATTR);\n                STAT_INC(LOAD_ATTR, hit);\n                Py_INCREF(attr);\n                null = NULL;\n                Py_DECREF(owner);\n            }\n            /* Skip 5 cache entries */\n            stack_pointer[-1] = attr;\n            if (oparg & 1) stack_pointer[0] = null;\n            stack_pointer += (oparg & 1);\n            DISPATCH();\n        }\n\n        TARGET(LOAD_ATTR_WITH_HINT) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 10;\n            INSTRUCTION_STATS(LOAD_ATTR_WITH_HINT);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_ATTR == 9, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *attr;\n            PyObject *null = NULL;\n            /* Skip 1 cache entry */\n            // _GUARD_TYPE_VERSION\n            owner = stack_pointer[-1];\n            {\n                uint32_t type_version = read_u32(&this_instr[2].cache);\n                PyTypeObject *tp = Py_TYPE(owner);\n                assert(type_version != 0);\n                DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);\n            }\n            // _CHECK_ATTR_WITH_HINT\n            {\n                assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_MANAGED_DICT);\n                PyDictObject *dict = _PyObject_GetManagedDict(owner);\n                DEOPT_IF(dict == NULL, LOAD_ATTR);\n                assert(PyDict_CheckExact((PyObject *)dict));\n            }\n            // _LOAD_ATTR_WITH_HINT\n            {\n                uint16_t hint = read_u16(&this_instr[4].cache);\n                PyDictObject *dict = _PyObject_GetManagedDict(owner);\n                DEOPT_IF(hint >= (size_t)dict->ma_keys->dk_nentries, LOAD_ATTR);\n                PyObject *name = GETITEM(FRAME_CO_NAMES, oparg>>1);\n                if (DK_IS_UNICODE(dict->ma_keys)) {\n                    PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(dict->ma_keys) + hint;\n                    DEOPT_IF(ep->me_key != name, LOAD_ATTR);\n                    attr = ep->me_value;\n                }\n                else {\n                    PyDictKeyEntry *ep = DK_ENTRIES(dict->ma_keys) + hint;\n                    DEOPT_IF(ep->me_key != name, LOAD_ATTR);\n                    attr = ep->me_value;\n                }\n                DEOPT_IF(attr == NULL, LOAD_ATTR);\n                STAT_INC(LOAD_ATTR, hit);\n                Py_INCREF(attr);\n                null = NULL;\n                Py_DECREF(owner);\n            }\n            /* Skip 5 cache entries */\n            stack_pointer[-1] = attr;\n            if (oparg & 1) stack_pointer[0] = null;\n            stack_pointer += (oparg & 1);\n            DISPATCH();\n        }\n\n        TARGET(LOAD_BUILD_CLASS) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LOAD_BUILD_CLASS);\n            PyObject *bc;\n            if (PyMapping_GetOptionalItem(BUILTINS(), &_Py_ID(__build_class__), &bc) < 0) goto error;\n            if (bc == NULL) {\n                _PyErr_SetString(tstate, PyExc_NameError,\n                                 \"__build_class__ not found\");\n                if (true) goto error;\n            }\n            stack_pointer[0] = bc;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_CONST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LOAD_CONST);\n            PyObject *value;\n            value = GETITEM(FRAME_CO_CONSTS, oparg);\n            Py_INCREF(value);\n            stack_pointer[0] = value;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_DEREF) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LOAD_DEREF);\n            PyObject *value;\n            PyCellObject *cell = (PyCellObject *)GETLOCAL(oparg);\n            value = PyCell_GetRef(cell);\n            if (value == NULL) {\n                _PyEval_FormatExcUnbound(tstate, _PyFrame_GetCode(frame), oparg);\n                if (true) goto error;\n            }\n            stack_pointer[0] = value;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_FAST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LOAD_FAST);\n            PyObject *value;\n            value = GETLOCAL(oparg);\n            assert(value != NULL);\n            Py_INCREF(value);\n            stack_pointer[0] = value;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_FAST_AND_CLEAR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LOAD_FAST_AND_CLEAR);\n            PyObject *value;\n            value = GETLOCAL(oparg);\n            // do not use SETLOCAL here, it decrefs the old value\n            GETLOCAL(oparg) = NULL;\n            stack_pointer[0] = value;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_FAST_CHECK) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LOAD_FAST_CHECK);\n            PyObject *value;\n            value = GETLOCAL(oparg);\n            if (value == NULL) {\n                _PyEval_FormatExcCheckArg(tstate, PyExc_UnboundLocalError,\n                    UNBOUNDLOCAL_ERROR_MSG,\n                    PyTuple_GetItem(_PyFrame_GetCode(frame)->co_localsplusnames, oparg)\n                );\n                if (1) goto error;\n            }\n            Py_INCREF(value);\n            stack_pointer[0] = value;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_FAST_LOAD_FAST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LOAD_FAST_LOAD_FAST);\n            PyObject *value1;\n            PyObject *value2;\n            uint32_t oparg1 = oparg >> 4;\n            uint32_t oparg2 = oparg & 15;\n            value1 = GETLOCAL(oparg1);\n            value2 = GETLOCAL(oparg2);\n            Py_INCREF(value1);\n            Py_INCREF(value2);\n            stack_pointer[0] = value1;\n            stack_pointer[1] = value2;\n            stack_pointer += 2;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_FROM_DICT_OR_DEREF) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LOAD_FROM_DICT_OR_DEREF);\n            PyObject *class_dict;\n            PyObject *value;\n            class_dict = stack_pointer[-1];\n            PyObject *name;\n            assert(class_dict);\n            assert(oparg >= 0 && oparg < _PyFrame_GetCode(frame)->co_nlocalsplus);\n            name = PyTuple_GET_ITEM(_PyFrame_GetCode(frame)->co_localsplusnames, oparg);\n            if (PyMapping_GetOptionalItem(class_dict, name, &value) < 0) {\n                goto error;\n            }\n            if (!value) {\n                PyCellObject *cell = (PyCellObject *)GETLOCAL(oparg);\n                value = PyCell_GetRef(cell);\n                if (value == NULL) {\n                    _PyEval_FormatExcUnbound(tstate, _PyFrame_GetCode(frame), oparg);\n                    goto error;\n                }\n            }\n            Py_DECREF(class_dict);\n            stack_pointer[-1] = value;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_FROM_DICT_OR_GLOBALS) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LOAD_FROM_DICT_OR_GLOBALS);\n            PyObject *mod_or_class_dict;\n            PyObject *v;\n            mod_or_class_dict = stack_pointer[-1];\n            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);\n            if (PyMapping_GetOptionalItem(mod_or_class_dict, name, &v) < 0) {\n                goto error;\n            }\n            if (v == NULL) {\n                if (PyDict_CheckExact(GLOBALS())\n                    && PyDict_CheckExact(BUILTINS()))\n                {\n                    v = _PyDict_LoadGlobal((PyDictObject *)GLOBALS(),\n                        (PyDictObject *)BUILTINS(),\n                        name);\n                    if (v == NULL) {\n                        if (!_PyErr_Occurred(tstate)) {\n                            /* _PyDict_LoadGlobal() returns NULL without raising\n                             * an exception if the key doesn't exist */\n                            _PyEval_FormatExcCheckArg(tstate, PyExc_NameError,\n                                NAME_ERROR_MSG, name);\n                        }\n                        goto error;\n                    }\n                }\n                else {\n                    /* Slow-path if globals or builtins is not a dict */\n                    /* namespace 1: globals */\n                    if (PyMapping_GetOptionalItem(GLOBALS(), name, &v) < 0) goto pop_1_error;\n                    if (v == NULL) {\n                        /* namespace 2: builtins */\n                        if (PyMapping_GetOptionalItem(BUILTINS(), name, &v) < 0) goto pop_1_error;\n                        if (v == NULL) {\n                            _PyEval_FormatExcCheckArg(\n                                tstate, PyExc_NameError,\n                                NAME_ERROR_MSG, name);\n                            if (true) goto pop_1_error;\n                        }\n                    }\n                }\n            }\n            Py_DECREF(mod_or_class_dict);\n            stack_pointer[-1] = v;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_GLOBAL) {\n            frame->instr_ptr = next_instr;\n            next_instr += 5;\n            INSTRUCTION_STATS(LOAD_GLOBAL);\n            PREDICTED(LOAD_GLOBAL);\n            _Py_CODEUNIT *this_instr = next_instr - 5;\n            (void)this_instr;\n            PyObject *res;\n            PyObject *null = NULL;\n            // _SPECIALIZE_LOAD_GLOBAL\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    PyObject *name = GETITEM(FRAME_CO_NAMES, oparg>>1);\n                    next_instr = this_instr;\n                    _Py_Specialize_LoadGlobal(GLOBALS(), BUILTINS(), next_instr, name);\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(LOAD_GLOBAL, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n            }\n            /* Skip 1 cache entry */\n            /* Skip 1 cache entry */\n            /* Skip 1 cache entry */\n            // _LOAD_GLOBAL\n            {\n                PyObject *name = GETITEM(FRAME_CO_NAMES, oparg>>1);\n                if (PyDict_CheckExact(GLOBALS())\n                    && PyDict_CheckExact(BUILTINS()))\n                {\n                    res = _PyDict_LoadGlobal((PyDictObject *)GLOBALS(),\n                        (PyDictObject *)BUILTINS(),\n                        name);\n                    if (res == NULL) {\n                        if (!_PyErr_Occurred(tstate)) {\n                            /* _PyDict_LoadGlobal() returns NULL without raising\n                             * an exception if the key doesn't exist */\n                            _PyEval_FormatExcCheckArg(tstate, PyExc_NameError,\n                                NAME_ERROR_MSG, name);\n                        }\n                        if (true) goto error;\n                    }\n                }\n                else {\n                    /* Slow-path if globals or builtins is not a dict */\n                    /* namespace 1: globals */\n                    if (PyMapping_GetOptionalItem(GLOBALS(), name, &res) < 0) goto error;\n                    if (res == NULL) {\n                        /* namespace 2: builtins */\n                        if (PyMapping_GetOptionalItem(BUILTINS(), name, &res) < 0) goto error;\n                        if (res == NULL) {\n                            _PyEval_FormatExcCheckArg(\n                                tstate, PyExc_NameError,\n                                NAME_ERROR_MSG, name);\n                            if (true) goto error;\n                        }\n                    }\n                }\n                null = NULL;\n            }\n            stack_pointer[0] = res;\n            if (oparg & 1) stack_pointer[1] = null;\n            stack_pointer += 1 + (oparg & 1);\n            DISPATCH();\n        }\n\n        TARGET(LOAD_GLOBAL_BUILTIN) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 5;\n            INSTRUCTION_STATS(LOAD_GLOBAL_BUILTIN);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_GLOBAL == 4, \"incorrect cache size\");\n            PyObject *res;\n            PyObject *null = NULL;\n            /* Skip 1 cache entry */\n            // _GUARD_GLOBALS_VERSION\n            {\n                uint16_t version = read_u16(&this_instr[2].cache);\n                PyDictObject *dict = (PyDictObject *)GLOBALS();\n                DEOPT_IF(!PyDict_CheckExact(dict), LOAD_GLOBAL);\n                DEOPT_IF(dict->ma_keys->dk_version != version, LOAD_GLOBAL);\n                assert(DK_IS_UNICODE(dict->ma_keys));\n            }\n            // _GUARD_BUILTINS_VERSION\n            {\n                uint16_t version = read_u16(&this_instr[3].cache);\n                PyDictObject *dict = (PyDictObject *)BUILTINS();\n                DEOPT_IF(!PyDict_CheckExact(dict), LOAD_GLOBAL);\n                DEOPT_IF(dict->ma_keys->dk_version != version, LOAD_GLOBAL);\n                assert(DK_IS_UNICODE(dict->ma_keys));\n            }\n            // _LOAD_GLOBAL_BUILTINS\n            {\n                uint16_t index = read_u16(&this_instr[4].cache);\n                PyDictObject *bdict = (PyDictObject *)BUILTINS();\n                PyDictUnicodeEntry *entries = DK_UNICODE_ENTRIES(bdict->ma_keys);\n                res = entries[index].me_value;\n                DEOPT_IF(res == NULL, LOAD_GLOBAL);\n                Py_INCREF(res);\n                STAT_INC(LOAD_GLOBAL, hit);\n                null = NULL;\n            }\n            stack_pointer[0] = res;\n            if (oparg & 1) stack_pointer[1] = null;\n            stack_pointer += 1 + (oparg & 1);\n            DISPATCH();\n        }\n\n        TARGET(LOAD_GLOBAL_MODULE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 5;\n            INSTRUCTION_STATS(LOAD_GLOBAL_MODULE);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_GLOBAL == 4, \"incorrect cache size\");\n            PyObject *res;\n            PyObject *null = NULL;\n            /* Skip 1 cache entry */\n            // _GUARD_GLOBALS_VERSION\n            {\n                uint16_t version = read_u16(&this_instr[2].cache);\n                PyDictObject *dict = (PyDictObject *)GLOBALS();\n                DEOPT_IF(!PyDict_CheckExact(dict), LOAD_GLOBAL);\n                DEOPT_IF(dict->ma_keys->dk_version != version, LOAD_GLOBAL);\n                assert(DK_IS_UNICODE(dict->ma_keys));\n            }\n            /* Skip 1 cache entry */\n            // _LOAD_GLOBAL_MODULE\n            {\n                uint16_t index = read_u16(&this_instr[4].cache);\n                PyDictObject *dict = (PyDictObject *)GLOBALS();\n                PyDictUnicodeEntry *entries = DK_UNICODE_ENTRIES(dict->ma_keys);\n                res = entries[index].me_value;\n                DEOPT_IF(res == NULL, LOAD_GLOBAL);\n                Py_INCREF(res);\n                STAT_INC(LOAD_GLOBAL, hit);\n                null = NULL;\n            }\n            stack_pointer[0] = res;\n            if (oparg & 1) stack_pointer[1] = null;\n            stack_pointer += 1 + (oparg & 1);\n            DISPATCH();\n        }\n\n        TARGET(LOAD_LOCALS) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LOAD_LOCALS);\n            PyObject *locals;\n            locals = LOCALS();\n            if (locals == NULL) {\n                _PyErr_SetString(tstate, PyExc_SystemError,\n                                 \"no locals found\");\n                if (true) goto error;\n            }\n            Py_INCREF(locals);\n            stack_pointer[0] = locals;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_NAME) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(LOAD_NAME);\n            PyObject *v;\n            PyObject *mod_or_class_dict = LOCALS();\n            if (mod_or_class_dict == NULL) {\n                _PyErr_SetString(tstate, PyExc_SystemError,\n                                 \"no locals found\");\n                if (true) goto error;\n            }\n            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);\n            if (PyMapping_GetOptionalItem(mod_or_class_dict, name, &v) < 0) {\n                goto error;\n            }\n            if (v == NULL) {\n                if (PyDict_GetItemRef(GLOBALS(), name, &v) < 0) {\n                    goto error;\n                }\n                if (v == NULL) {\n                    if (PyMapping_GetOptionalItem(BUILTINS(), name, &v) < 0) {\n                        goto error;\n                    }\n                    if (v == NULL) {\n                        _PyEval_FormatExcCheckArg(\n                            tstate, PyExc_NameError,\n                            NAME_ERROR_MSG, name);\n                        goto error;\n                    }\n                }\n            }\n            stack_pointer[0] = v;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_SUPER_ATTR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(LOAD_SUPER_ATTR);\n            PREDICTED(LOAD_SUPER_ATTR);\n            _Py_CODEUNIT *this_instr = next_instr - 2;\n            (void)this_instr;\n            PyObject *class;\n            PyObject *global_super;\n            PyObject *self;\n            PyObject *attr;\n            PyObject *null = NULL;\n            // _SPECIALIZE_LOAD_SUPER_ATTR\n            class = stack_pointer[-2];\n            global_super = stack_pointer[-3];\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                int load_method = oparg & 1;\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    next_instr = this_instr;\n                    _Py_Specialize_LoadSuperAttr(global_super, class, next_instr, load_method);\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(LOAD_SUPER_ATTR, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n            }\n            // _LOAD_SUPER_ATTR\n            self = stack_pointer[-1];\n            {\n                if (opcode == INSTRUMENTED_LOAD_SUPER_ATTR) {\n                    PyObject *arg = oparg & 2 ? class : &_PyInstrumentation_MISSING;\n                    int err = _Py_call_instrumentation_2args(\n                        tstate, PY_MONITORING_EVENT_CALL,\n                        frame, this_instr, global_super, arg);\n                    if (err) goto pop_3_error;\n                }\n                // we make no attempt to optimize here; specializations should\n                // handle any case whose performance we care about\n                PyObject *stack[] = {class, self};\n                PyObject *super = PyObject_Vectorcall(global_super, stack, oparg & 2, NULL);\n                if (opcode == INSTRUMENTED_LOAD_SUPER_ATTR) {\n                    PyObject *arg = oparg & 2 ? class : &_PyInstrumentation_MISSING;\n                    if (super == NULL) {\n                        _Py_call_instrumentation_exc2(\n                            tstate, PY_MONITORING_EVENT_C_RAISE,\n                            frame, this_instr, global_super, arg);\n                    }\n                    else {\n                        int err = _Py_call_instrumentation_2args(\n                            tstate, PY_MONITORING_EVENT_C_RETURN,\n                            frame, this_instr, global_super, arg);\n                        if (err < 0) {\n                            Py_CLEAR(super);\n                        }\n                    }\n                }\n                Py_DECREF(global_super);\n                Py_DECREF(class);\n                Py_DECREF(self);\n                if (super == NULL) goto pop_3_error;\n                PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 2);\n                attr = PyObject_GetAttr(super, name);\n                Py_DECREF(super);\n                if (attr == NULL) goto pop_3_error;\n                null = NULL;\n            }\n            stack_pointer[-3] = attr;\n            if (oparg & 1) stack_pointer[-2] = null;\n            stack_pointer += -2 + (oparg & 1);\n            DISPATCH();\n        }\n\n        TARGET(LOAD_SUPER_ATTR_ATTR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(LOAD_SUPER_ATTR_ATTR);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_SUPER_ATTR == 1, \"incorrect cache size\");\n            PyObject *self;\n            PyObject *class;\n            PyObject *global_super;\n            PyObject *attr;\n            /* Skip 1 cache entry */\n            self = stack_pointer[-1];\n            class = stack_pointer[-2];\n            global_super = stack_pointer[-3];\n            assert(!(oparg & 1));\n            DEOPT_IF(global_super != (PyObject *)&PySuper_Type, LOAD_SUPER_ATTR);\n            DEOPT_IF(!PyType_Check(class), LOAD_SUPER_ATTR);\n            STAT_INC(LOAD_SUPER_ATTR, hit);\n            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 2);\n            attr = _PySuper_Lookup((PyTypeObject *)class, self, name, NULL);\n            Py_DECREF(global_super);\n            Py_DECREF(class);\n            Py_DECREF(self);\n            if (attr == NULL) goto pop_3_error;\n            stack_pointer[-3] = attr;\n            stack_pointer += -2;\n            DISPATCH();\n        }\n\n        TARGET(LOAD_SUPER_ATTR_METHOD) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(LOAD_SUPER_ATTR_METHOD);\n            static_assert(INLINE_CACHE_ENTRIES_LOAD_SUPER_ATTR == 1, \"incorrect cache size\");\n            PyObject *self;\n            PyObject *class;\n            PyObject *global_super;\n            PyObject *attr;\n            PyObject *self_or_null;\n            /* Skip 1 cache entry */\n            self = stack_pointer[-1];\n            class = stack_pointer[-2];\n            global_super = stack_pointer[-3];\n            assert(oparg & 1);\n            DEOPT_IF(global_super != (PyObject *)&PySuper_Type, LOAD_SUPER_ATTR);\n            DEOPT_IF(!PyType_Check(class), LOAD_SUPER_ATTR);\n            STAT_INC(LOAD_SUPER_ATTR, hit);\n            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 2);\n            PyTypeObject *cls = (PyTypeObject *)class;\n            int method_found = 0;\n            attr = _PySuper_Lookup(cls, self, name,\n                                   Py_TYPE(self)->tp_getattro == PyObject_GenericGetAttr ? &method_found : NULL);\n            Py_DECREF(global_super);\n            Py_DECREF(class);\n            if (attr == NULL) {\n                Py_DECREF(self);\n                if (true) goto pop_3_error;\n            }\n            if (method_found) {\n                self_or_null = self; // transfer ownership\n            } else {\n                Py_DECREF(self);\n                self_or_null = NULL;\n            }\n            stack_pointer[-3] = attr;\n            stack_pointer[-2] = self_or_null;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(MAKE_CELL) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(MAKE_CELL);\n            // \"initial\" is probably NULL but not if it's an arg (or set\n            // via the f_locals proxy before MAKE_CELL has run).\n            PyObject *initial = GETLOCAL(oparg);\n            PyObject *cell = PyCell_New(initial);\n            if (cell == NULL) {\n                goto error;\n            }\n            SETLOCAL(oparg, cell);\n            DISPATCH();\n        }\n\n        TARGET(MAKE_FUNCTION) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(MAKE_FUNCTION);\n            PyObject *codeobj;\n            PyObject *func;\n            codeobj = stack_pointer[-1];\n            PyFunctionObject *func_obj = (PyFunctionObject *)\n            PyFunction_New(codeobj, GLOBALS());\n            Py_DECREF(codeobj);\n            if (func_obj == NULL) {\n                goto error;\n            }\n            _PyFunction_SetVersion(\n                                   func_obj, ((PyCodeObject *)codeobj)->co_version);\n            func = (PyObject *)func_obj;\n            stack_pointer[-1] = func;\n            DISPATCH();\n        }\n\n        TARGET(MAP_ADD) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(MAP_ADD);\n            PyObject *value;\n            PyObject *key;\n            PyObject *dict;\n            value = stack_pointer[-1];\n            key = stack_pointer[-2];\n            dict = stack_pointer[-3 - (oparg - 1)];\n            assert(PyDict_CheckExact(dict));\n            /* dict[key] = value */\n            // Do not DECREF INPUTS because the function steals the references\n            if (_PyDict_SetItem_Take2((PyDictObject *)dict, key, value) != 0) goto pop_2_error;\n            stack_pointer += -2;\n            DISPATCH();\n        }\n\n        TARGET(MATCH_CLASS) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(MATCH_CLASS);\n            PyObject *names;\n            PyObject *type;\n            PyObject *subject;\n            PyObject *attrs;\n            names = stack_pointer[-1];\n            type = stack_pointer[-2];\n            subject = stack_pointer[-3];\n            // Pop TOS and TOS1. Set TOS to a tuple of attributes on success, or\n            // None on failure.\n            assert(PyTuple_CheckExact(names));\n            attrs = _PyEval_MatchClass(tstate, subject, type, oparg, names);\n            Py_DECREF(subject);\n            Py_DECREF(type);\n            Py_DECREF(names);\n            if (attrs) {\n                assert(PyTuple_CheckExact(attrs));  // Success!\n            }\n            else {\n                if (_PyErr_Occurred(tstate)) goto pop_3_error;\n                // Error!\n                attrs = Py_None;  // Failure!\n            }\n            stack_pointer[-3] = attrs;\n            stack_pointer += -2;\n            DISPATCH();\n        }\n\n        TARGET(MATCH_KEYS) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(MATCH_KEYS);\n            PyObject *keys;\n            PyObject *subject;\n            PyObject *values_or_none;\n            keys = stack_pointer[-1];\n            subject = stack_pointer[-2];\n            // On successful match, PUSH(values). Otherwise, PUSH(None).\n            values_or_none = _PyEval_MatchKeys(tstate, subject, keys);\n            if (values_or_none == NULL) goto error;\n            stack_pointer[0] = values_or_none;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(MATCH_MAPPING) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(MATCH_MAPPING);\n            PyObject *subject;\n            PyObject *res;\n            subject = stack_pointer[-1];\n            int match = Py_TYPE(subject)->tp_flags & Py_TPFLAGS_MAPPING;\n            res = match ? Py_True : Py_False;\n            stack_pointer[0] = res;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(MATCH_SEQUENCE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(MATCH_SEQUENCE);\n            PyObject *subject;\n            PyObject *res;\n            subject = stack_pointer[-1];\n            int match = Py_TYPE(subject)->tp_flags & Py_TPFLAGS_SEQUENCE;\n            res = match ? Py_True : Py_False;\n            stack_pointer[0] = res;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(NOP) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(NOP);\n            DISPATCH();\n        }\n\n        TARGET(POP_EXCEPT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(POP_EXCEPT);\n            PyObject *exc_value;\n            exc_value = stack_pointer[-1];\n            _PyErr_StackItem *exc_info = tstate->exc_info;\n            Py_XSETREF(exc_info->exc_value, exc_value == Py_None ? NULL : exc_value);\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(POP_JUMP_IF_FALSE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(POP_JUMP_IF_FALSE);\n            PyObject *cond;\n            /* Skip 1 cache entry */\n            cond = stack_pointer[-1];\n            assert(PyBool_Check(cond));\n            int flag = Py_IsFalse(cond);\n            #if ENABLE_SPECIALIZATION\n            this_instr[1].cache = (this_instr[1].cache << 1) | flag;\n            #endif\n            JUMPBY(oparg * flag);\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(POP_JUMP_IF_NONE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(POP_JUMP_IF_NONE);\n            PyObject *value;\n            PyObject *b;\n            PyObject *cond;\n            /* Skip 1 cache entry */\n            // _IS_NONE\n            value = stack_pointer[-1];\n            {\n                if (Py_IsNone(value)) {\n                    b = Py_True;\n                }\n                else {\n                    b = Py_False;\n                    Py_DECREF(value);\n                }\n            }\n            // _POP_JUMP_IF_TRUE\n            cond = b;\n            {\n                assert(PyBool_Check(cond));\n                int flag = Py_IsTrue(cond);\n                #if ENABLE_SPECIALIZATION\n                this_instr[1].cache = (this_instr[1].cache << 1) | flag;\n                #endif\n                JUMPBY(oparg * flag);\n            }\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(POP_JUMP_IF_NOT_NONE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(POP_JUMP_IF_NOT_NONE);\n            PyObject *value;\n            PyObject *b;\n            PyObject *cond;\n            /* Skip 1 cache entry */\n            // _IS_NONE\n            value = stack_pointer[-1];\n            {\n                if (Py_IsNone(value)) {\n                    b = Py_True;\n                }\n                else {\n                    b = Py_False;\n                    Py_DECREF(value);\n                }\n            }\n            // _POP_JUMP_IF_FALSE\n            cond = b;\n            {\n                assert(PyBool_Check(cond));\n                int flag = Py_IsFalse(cond);\n                #if ENABLE_SPECIALIZATION\n                this_instr[1].cache = (this_instr[1].cache << 1) | flag;\n                #endif\n                JUMPBY(oparg * flag);\n            }\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(POP_JUMP_IF_TRUE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(POP_JUMP_IF_TRUE);\n            PyObject *cond;\n            /* Skip 1 cache entry */\n            cond = stack_pointer[-1];\n            assert(PyBool_Check(cond));\n            int flag = Py_IsTrue(cond);\n            #if ENABLE_SPECIALIZATION\n            this_instr[1].cache = (this_instr[1].cache << 1) | flag;\n            #endif\n            JUMPBY(oparg * flag);\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(POP_TOP) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(POP_TOP);\n            PyObject *value;\n            value = stack_pointer[-1];\n            Py_DECREF(value);\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(PUSH_EXC_INFO) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(PUSH_EXC_INFO);\n            PyObject *new_exc;\n            PyObject *prev_exc;\n            new_exc = stack_pointer[-1];\n            _PyErr_StackItem *exc_info = tstate->exc_info;\n            if (exc_info->exc_value != NULL) {\n                prev_exc = exc_info->exc_value;\n            }\n            else {\n                prev_exc = Py_None;\n            }\n            assert(PyExceptionInstance_Check(new_exc));\n            exc_info->exc_value = Py_NewRef(new_exc);\n            stack_pointer[-1] = prev_exc;\n            stack_pointer[0] = new_exc;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(PUSH_NULL) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(PUSH_NULL);\n            PyObject *res;\n            res = NULL;\n            stack_pointer[0] = res;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(RAISE_VARARGS) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(RAISE_VARARGS);\n            PyObject **args;\n            args = &stack_pointer[-oparg];\n            PyObject *cause = NULL, *exc = NULL;\n            switch (oparg) {\n                case 2:\n                cause = args[1];\n                /* fall through */\n                case 1:\n                exc = args[0];\n                /* fall through */\n                case 0:\n                if (do_raise(tstate, exc, cause)) {\n                    assert(oparg == 0);\n                    monitor_reraise(tstate, frame, this_instr);\n                    goto exception_unwind;\n                }\n                break;\n                default:\n                _PyErr_SetString(tstate, PyExc_SystemError,\n                                 \"bad RAISE_VARARGS oparg\");\n                break;\n            }\n            if (true) { stack_pointer += -oparg; goto error; }\n        }\n\n        TARGET(RERAISE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            (void)this_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(RERAISE);\n            PyObject *exc;\n            PyObject **values;\n            exc = stack_pointer[-1];\n            values = &stack_pointer[-1 - oparg];\n            assert(oparg >= 0 && oparg <= 2);\n            if (oparg) {\n                PyObject *lasti = values[0];\n                if (PyLong_Check(lasti)) {\n                    frame->instr_ptr = _PyCode_CODE(_PyFrame_GetCode(frame)) + PyLong_AsLong(lasti);\n                    assert(!_PyErr_Occurred(tstate));\n                }\n                else {\n                    assert(PyLong_Check(lasti));\n                    _PyErr_SetString(tstate, PyExc_SystemError, \"lasti is not an int\");\n                    goto error;\n                }\n            }\n            assert(exc && PyExceptionInstance_Check(exc));\n            Py_INCREF(exc);\n            _PyErr_SetRaisedException(tstate, exc);\n            monitor_reraise(tstate, frame, this_instr);\n            goto exception_unwind;\n        }\n\n        TARGET(RESERVED) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(RESERVED);\n            assert(0 && \"Executing RESERVED instruction.\");\n            Py_FatalError(\"Executing RESERVED instruction.\");\n            DISPATCH();\n        }\n\n        TARGET(RESUME) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(RESUME);\n            PREDICTED(RESUME);\n            _Py_CODEUNIT *this_instr = next_instr - 1;\n            (void)this_instr;\n            assert(frame == tstate->current_frame);\n            if (tstate->tracing == 0) {\n                uintptr_t global_version =\n                _Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker) &\n                ~_PY_EVAL_EVENTS_MASK;\n                PyCodeObject* code = _PyFrame_GetCode(frame);\n                uintptr_t code_version = FT_ATOMIC_LOAD_UINTPTR_ACQUIRE(code->_co_instrumentation_version);\n                assert((code_version & 255) == 0);\n                if (code_version != global_version) {\n                    int err = _Py_Instrument(_PyFrame_GetCode(frame), tstate->interp);\n                    if (err) goto error;\n                    next_instr = this_instr;\n                    DISPATCH();\n                }\n                assert(this_instr->op.code == RESUME ||\n                       this_instr->op.code == RESUME_CHECK ||\n                       this_instr->op.code == INSTRUMENTED_RESUME ||\n                       this_instr->op.code == ENTER_EXECUTOR);\n                if (this_instr->op.code == RESUME) {\n                    #if ENABLE_SPECIALIZATION\n                    FT_ATOMIC_STORE_UINT8_RELAXED(this_instr->op.code, RESUME_CHECK);\n                    #endif  /* ENABLE_SPECIALIZATION */\n                }\n            }\n            if ((oparg & RESUME_OPARG_LOCATION_MASK) < RESUME_AFTER_YIELD_FROM) {\n                CHECK_EVAL_BREAKER();\n            }\n            DISPATCH();\n        }\n\n        TARGET(RESUME_CHECK) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(RESUME_CHECK);\n            static_assert(0 == 0, \"incorrect cache size\");\n            #if defined(__EMSCRIPTEN__)\n            DEOPT_IF(_Py_emscripten_signal_clock == 0, RESUME);\n            _Py_emscripten_signal_clock -= Py_EMSCRIPTEN_SIGNAL_HANDLING;\n            #endif\n            uintptr_t eval_breaker = _Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker);\n            uintptr_t version = FT_ATOMIC_LOAD_UINTPTR_ACQUIRE(_PyFrame_GetCode(frame)->_co_instrumentation_version);\n            assert((version & _PY_EVAL_EVENTS_MASK) == 0);\n            DEOPT_IF(eval_breaker != version, RESUME);\n            DISPATCH();\n        }\n\n        TARGET(RETURN_CONST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(RETURN_CONST);\n            PyObject *value;\n            PyObject *retval;\n            // _LOAD_CONST\n            {\n                value = GETITEM(FRAME_CO_CONSTS, oparg);\n                Py_INCREF(value);\n            }\n            // _POP_FRAME\n            retval = value;\n            {\n                #if TIER_ONE\n                assert(frame != &entry_frame);\n                #endif\n                _PyFrame_SetStackPointer(frame, stack_pointer);\n                assert(EMPTY());\n                _Py_LeaveRecursiveCallPy(tstate);\n                // GH-99729: We need to unlink the frame *before* clearing it:\n                _PyInterpreterFrame *dying = frame;\n                frame = tstate->current_frame = dying->previous;\n                _PyEval_FrameClearAndPop(tstate, dying);\n                _PyFrame_StackPush(frame, retval);\n                LOAD_SP();\n                LOAD_IP(frame->return_offset);\n                LLTRACE_RESUME_FRAME();\n            }\n            DISPATCH();\n        }\n\n        TARGET(RETURN_GENERATOR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(RETURN_GENERATOR);\n            PyObject *res;\n            assert(PyFunction_Check(frame->f_funcobj));\n            PyFunctionObject *func = (PyFunctionObject *)frame->f_funcobj;\n            PyGenObject *gen = (PyGenObject *)_Py_MakeCoro(func);\n            if (gen == NULL) {\n                goto error;\n            }\n            assert(EMPTY());\n            _PyFrame_SetStackPointer(frame, stack_pointer);\n            _PyInterpreterFrame *gen_frame = (_PyInterpreterFrame *)gen->gi_iframe;\n            frame->instr_ptr++;\n            _PyFrame_Copy(frame, gen_frame);\n            assert(frame->frame_obj == NULL);\n            gen->gi_frame_state = FRAME_CREATED;\n            gen_frame->owner = FRAME_OWNED_BY_GENERATOR;\n            _Py_LeaveRecursiveCallPy(tstate);\n            res = (PyObject *)gen;\n            _PyInterpreterFrame *prev = frame->previous;\n            _PyThreadState_PopFrame(tstate, frame);\n            frame = tstate->current_frame = prev;\n            LOAD_IP(frame->return_offset);\n            LOAD_SP();\n            LLTRACE_RESUME_FRAME();\n            stack_pointer[0] = res;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(RETURN_VALUE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(RETURN_VALUE);\n            PyObject *retval;\n            retval = stack_pointer[-1];\n            #if TIER_ONE\n            assert(frame != &entry_frame);\n            #endif\n            stack_pointer += -1;\n            _PyFrame_SetStackPointer(frame, stack_pointer);\n            assert(EMPTY());\n            _Py_LeaveRecursiveCallPy(tstate);\n            // GH-99729: We need to unlink the frame *before* clearing it:\n            _PyInterpreterFrame *dying = frame;\n            frame = tstate->current_frame = dying->previous;\n            _PyEval_FrameClearAndPop(tstate, dying);\n            _PyFrame_StackPush(frame, retval);\n            LOAD_SP();\n            LOAD_IP(frame->return_offset);\n            LLTRACE_RESUME_FRAME();\n            DISPATCH();\n        }\n\n        TARGET(SEND) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(SEND);\n            PREDICTED(SEND);\n            _Py_CODEUNIT *this_instr = next_instr - 2;\n            (void)this_instr;\n            PyObject *receiver;\n            PyObject *v;\n            PyObject *retval;\n            // _SPECIALIZE_SEND\n            receiver = stack_pointer[-2];\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    next_instr = this_instr;\n                    _Py_Specialize_Send(receiver, next_instr);\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(SEND, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n            }\n            // _SEND\n            v = stack_pointer[-1];\n            {\n                assert(frame != &entry_frame);\n                if ((tstate->interp->eval_frame == NULL) &&\n                    (Py_TYPE(receiver) == &PyGen_Type || Py_TYPE(receiver) == &PyCoro_Type) &&\n                    ((PyGenObject *)receiver)->gi_frame_state < FRAME_EXECUTING)\n                {\n                    PyGenObject *gen = (PyGenObject *)receiver;\n                    _PyInterpreterFrame *gen_frame = (_PyInterpreterFrame *)gen->gi_iframe;\n                    STACK_SHRINK(1);\n                    _PyFrame_StackPush(gen_frame, v);\n                    gen->gi_frame_state = FRAME_EXECUTING;\n                    gen->gi_exc_state.previous_item = tstate->exc_info;\n                    tstate->exc_info = &gen->gi_exc_state;\n                    assert(next_instr - this_instr + oparg <= UINT16_MAX);\n                    frame->return_offset = (uint16_t)(next_instr - this_instr + oparg);\n                    DISPATCH_INLINED(gen_frame);\n                }\n                if (Py_IsNone(v) && PyIter_Check(receiver)) {\n                    retval = Py_TYPE(receiver)->tp_iternext(receiver);\n                }\n                else {\n                    retval = PyObject_CallMethodOneArg(receiver, &_Py_ID(send), v);\n                }\n                if (retval == NULL) {\n                    if (_PyErr_ExceptionMatches(tstate, PyExc_StopIteration)\n                    ) {\n                        monitor_raise(tstate, frame, this_instr);\n                    }\n                    if (_PyGen_FetchStopIterationValue(&retval) == 0) {\n                        assert(retval != NULL);\n                        JUMPBY(oparg);\n                    }\n                    else {\n                        goto error;\n                    }\n                }\n                Py_DECREF(v);\n            }\n            stack_pointer[-1] = retval;\n            DISPATCH();\n        }\n\n        TARGET(SEND_GEN) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(SEND_GEN);\n            static_assert(INLINE_CACHE_ENTRIES_SEND == 1, \"incorrect cache size\");\n            PyObject *v;\n            PyObject *receiver;\n            /* Skip 1 cache entry */\n            v = stack_pointer[-1];\n            receiver = stack_pointer[-2];\n            DEOPT_IF(tstate->interp->eval_frame, SEND);\n            PyGenObject *gen = (PyGenObject *)receiver;\n            DEOPT_IF(Py_TYPE(gen) != &PyGen_Type && Py_TYPE(gen) != &PyCoro_Type, SEND);\n            DEOPT_IF(gen->gi_frame_state >= FRAME_EXECUTING, SEND);\n            STAT_INC(SEND, hit);\n            _PyInterpreterFrame *gen_frame = (_PyInterpreterFrame *)gen->gi_iframe;\n            STACK_SHRINK(1);\n            _PyFrame_StackPush(gen_frame, v);\n            gen->gi_frame_state = FRAME_EXECUTING;\n            gen->gi_exc_state.previous_item = tstate->exc_info;\n            tstate->exc_info = &gen->gi_exc_state;\n            assert(next_instr - this_instr + oparg <= UINT16_MAX);\n            frame->return_offset = (uint16_t)(next_instr - this_instr + oparg);\n            DISPATCH_INLINED(gen_frame);\n        }\n\n        TARGET(SETUP_ANNOTATIONS) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(SETUP_ANNOTATIONS);\n            int err;\n            PyObject *ann_dict;\n            if (LOCALS() == NULL) {\n                _PyErr_Format(tstate, PyExc_SystemError,\n                              \"no locals found when setting up annotations\");\n                if (true) goto error;\n            }\n            /* check if __annotations__ in locals()... */\n            if (PyMapping_GetOptionalItem(LOCALS(), &_Py_ID(__annotations__), &ann_dict) < 0) goto error;\n            if (ann_dict == NULL) {\n                ann_dict = PyDict_New();\n                if (ann_dict == NULL) goto error;\n                err = PyObject_SetItem(LOCALS(), &_Py_ID(__annotations__),\n                                       ann_dict);\n                Py_DECREF(ann_dict);\n                if (err) goto error;\n            }\n            else {\n                Py_DECREF(ann_dict);\n            }\n            DISPATCH();\n        }\n\n        TARGET(SET_ADD) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(SET_ADD);\n            PyObject *v;\n            PyObject *set;\n            v = stack_pointer[-1];\n            set = stack_pointer[-2 - (oparg-1)];\n            int err = PySet_Add(set, v);\n            Py_DECREF(v);\n            if (err) goto pop_1_error;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(SET_FUNCTION_ATTRIBUTE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(SET_FUNCTION_ATTRIBUTE);\n            PyObject *func;\n            PyObject *attr;\n            func = stack_pointer[-1];\n            attr = stack_pointer[-2];\n            assert(PyFunction_Check(func));\n            PyFunctionObject *func_obj = (PyFunctionObject *)func;\n            switch(oparg) {\n                case MAKE_FUNCTION_CLOSURE:\n                assert(func_obj->func_closure == NULL);\n                func_obj->func_closure = attr;\n                break;\n                case MAKE_FUNCTION_ANNOTATIONS:\n                assert(func_obj->func_annotations == NULL);\n                func_obj->func_annotations = attr;\n                break;\n                case MAKE_FUNCTION_KWDEFAULTS:\n                assert(PyDict_CheckExact(attr));\n                assert(func_obj->func_kwdefaults == NULL);\n                func_obj->func_kwdefaults = attr;\n                break;\n                case MAKE_FUNCTION_DEFAULTS:\n                assert(PyTuple_CheckExact(attr));\n                assert(func_obj->func_defaults == NULL);\n                func_obj->func_defaults = attr;\n                break;\n                default:\n                Py_UNREACHABLE();\n            }\n            stack_pointer[-2] = func;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(SET_UPDATE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(SET_UPDATE);\n            PyObject *iterable;\n            PyObject *set;\n            iterable = stack_pointer[-1];\n            set = stack_pointer[-2 - (oparg-1)];\n            int err = _PySet_Update(set, iterable);\n            Py_DECREF(iterable);\n            if (err < 0) goto pop_1_error;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(STORE_ATTR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 5;\n            INSTRUCTION_STATS(STORE_ATTR);\n            PREDICTED(STORE_ATTR);\n            _Py_CODEUNIT *this_instr = next_instr - 5;\n            (void)this_instr;\n            PyObject *owner;\n            PyObject *v;\n            // _SPECIALIZE_STORE_ATTR\n            owner = stack_pointer[-1];\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);\n                    next_instr = this_instr;\n                    _Py_Specialize_StoreAttr(owner, next_instr, name);\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(STORE_ATTR, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n            }\n            /* Skip 3 cache entries */\n            // _STORE_ATTR\n            v = stack_pointer[-2];\n            {\n                PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);\n                int err = PyObject_SetAttr(owner, name, v);\n                Py_DECREF(v);\n                Py_DECREF(owner);\n                if (err) goto pop_2_error;\n            }\n            stack_pointer += -2;\n            DISPATCH();\n        }\n\n        TARGET(STORE_ATTR_INSTANCE_VALUE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 5;\n            INSTRUCTION_STATS(STORE_ATTR_INSTANCE_VALUE);\n            static_assert(INLINE_CACHE_ENTRIES_STORE_ATTR == 4, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *value;\n            /* Skip 1 cache entry */\n            // _GUARD_TYPE_VERSION\n            owner = stack_pointer[-1];\n            {\n                uint32_t type_version = read_u32(&this_instr[2].cache);\n                PyTypeObject *tp = Py_TYPE(owner);\n                assert(type_version != 0);\n                DEOPT_IF(tp->tp_version_tag != type_version, STORE_ATTR);\n            }\n            // _GUARD_DORV_NO_DICT\n            {\n                assert(Py_TYPE(owner)->tp_dictoffset < 0);\n                assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_INLINE_VALUES);\n                DEOPT_IF(_PyObject_GetManagedDict(owner), STORE_ATTR);\n                DEOPT_IF(_PyObject_InlineValues(owner)->valid == 0, STORE_ATTR);\n            }\n            // _STORE_ATTR_INSTANCE_VALUE\n            value = stack_pointer[-2];\n            {\n                uint16_t index = read_u16(&this_instr[4].cache);\n                STAT_INC(STORE_ATTR, hit);\n                assert(_PyObject_GetManagedDict(owner) == NULL);\n                PyDictValues *values = _PyObject_InlineValues(owner);\n                PyObject *old_value = values->values[index];\n                values->values[index] = value;\n                if (old_value == NULL) {\n                    _PyDictValues_AddToInsertionOrder(values, index);\n                }\n                else {\n                    Py_DECREF(old_value);\n                }\n                Py_DECREF(owner);\n            }\n            stack_pointer += -2;\n            DISPATCH();\n        }\n\n        TARGET(STORE_ATTR_SLOT) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 5;\n            INSTRUCTION_STATS(STORE_ATTR_SLOT);\n            static_assert(INLINE_CACHE_ENTRIES_STORE_ATTR == 4, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *value;\n            /* Skip 1 cache entry */\n            // _GUARD_TYPE_VERSION\n            owner = stack_pointer[-1];\n            {\n                uint32_t type_version = read_u32(&this_instr[2].cache);\n                PyTypeObject *tp = Py_TYPE(owner);\n                assert(type_version != 0);\n                DEOPT_IF(tp->tp_version_tag != type_version, STORE_ATTR);\n            }\n            // _STORE_ATTR_SLOT\n            value = stack_pointer[-2];\n            {\n                uint16_t index = read_u16(&this_instr[4].cache);\n                char *addr = (char *)owner + index;\n                STAT_INC(STORE_ATTR, hit);\n                PyObject *old_value = *(PyObject **)addr;\n                *(PyObject **)addr = value;\n                Py_XDECREF(old_value);\n                Py_DECREF(owner);\n            }\n            stack_pointer += -2;\n            DISPATCH();\n        }\n\n        TARGET(STORE_ATTR_WITH_HINT) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 5;\n            INSTRUCTION_STATS(STORE_ATTR_WITH_HINT);\n            static_assert(INLINE_CACHE_ENTRIES_STORE_ATTR == 4, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *value;\n            /* Skip 1 cache entry */\n            owner = stack_pointer[-1];\n            value = stack_pointer[-2];\n            uint32_t type_version = read_u32(&this_instr[2].cache);\n            uint16_t hint = read_u16(&this_instr[4].cache);\n            PyTypeObject *tp = Py_TYPE(owner);\n            assert(type_version != 0);\n            DEOPT_IF(tp->tp_version_tag != type_version, STORE_ATTR);\n            assert(tp->tp_flags & Py_TPFLAGS_MANAGED_DICT);\n            PyDictObject *dict = _PyObject_GetManagedDict(owner);\n            DEOPT_IF(dict == NULL, STORE_ATTR);\n            assert(PyDict_CheckExact((PyObject *)dict));\n            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);\n            DEOPT_IF(hint >= (size_t)dict->ma_keys->dk_nentries, STORE_ATTR);\n            PyObject *old_value;\n            uint64_t new_version;\n            if (DK_IS_UNICODE(dict->ma_keys)) {\n                PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(dict->ma_keys) + hint;\n                DEOPT_IF(ep->me_key != name, STORE_ATTR);\n                old_value = ep->me_value;\n                DEOPT_IF(old_value == NULL, STORE_ATTR);\n                new_version = _PyDict_NotifyEvent(tstate->interp, PyDict_EVENT_MODIFIED, dict, name, value);\n                ep->me_value = value;\n            }\n            else {\n                PyDictKeyEntry *ep = DK_ENTRIES(dict->ma_keys) + hint;\n                DEOPT_IF(ep->me_key != name, STORE_ATTR);\n                old_value = ep->me_value;\n                DEOPT_IF(old_value == NULL, STORE_ATTR);\n                new_version = _PyDict_NotifyEvent(tstate->interp, PyDict_EVENT_MODIFIED, dict, name, value);\n                ep->me_value = value;\n            }\n            Py_DECREF(old_value);\n            STAT_INC(STORE_ATTR, hit);\n            /* Ensure dict is GC tracked if it needs to be */\n            if (!_PyObject_GC_IS_TRACKED(dict) && _PyObject_GC_MAY_BE_TRACKED(value)) {\n                _PyObject_GC_TRACK(dict);\n            }\n            /* PEP 509 */\n            dict->ma_version_tag = new_version;\n            Py_DECREF(owner);\n            stack_pointer += -2;\n            DISPATCH();\n        }\n\n        TARGET(STORE_DEREF) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(STORE_DEREF);\n            PyObject *v;\n            v = stack_pointer[-1];\n            PyCellObject *cell = (PyCellObject *)GETLOCAL(oparg);\n            PyCell_SetTakeRef(cell, v);\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(STORE_FAST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(STORE_FAST);\n            PyObject *value;\n            value = stack_pointer[-1];\n            SETLOCAL(oparg, value);\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(STORE_FAST_LOAD_FAST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(STORE_FAST_LOAD_FAST);\n            PyObject *value1;\n            PyObject *value2;\n            value1 = stack_pointer[-1];\n            uint32_t oparg1 = oparg >> 4;\n            uint32_t oparg2 = oparg & 15;\n            SETLOCAL(oparg1, value1);\n            value2 = GETLOCAL(oparg2);\n            Py_INCREF(value2);\n            stack_pointer[-1] = value2;\n            DISPATCH();\n        }\n\n        TARGET(STORE_FAST_STORE_FAST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(STORE_FAST_STORE_FAST);\n            PyObject *value1;\n            PyObject *value2;\n            value1 = stack_pointer[-1];\n            value2 = stack_pointer[-2];\n            uint32_t oparg1 = oparg >> 4;\n            uint32_t oparg2 = oparg & 15;\n            SETLOCAL(oparg1, value1);\n            SETLOCAL(oparg2, value2);\n            stack_pointer += -2;\n            DISPATCH();\n        }\n\n        TARGET(STORE_GLOBAL) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(STORE_GLOBAL);\n            PyObject *v;\n            v = stack_pointer[-1];\n            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);\n            int err = PyDict_SetItem(GLOBALS(), name, v);\n            Py_DECREF(v);\n            if (err) goto pop_1_error;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(STORE_NAME) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(STORE_NAME);\n            PyObject *v;\n            v = stack_pointer[-1];\n            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);\n            PyObject *ns = LOCALS();\n            int err;\n            if (ns == NULL) {\n                _PyErr_Format(tstate, PyExc_SystemError,\n                              \"no locals found when storing %R\", name);\n                Py_DECREF(v);\n                if (true) goto pop_1_error;\n            }\n            if (PyDict_CheckExact(ns))\n            err = PyDict_SetItem(ns, name, v);\n            else\n            err = PyObject_SetItem(ns, name, v);\n            Py_DECREF(v);\n            if (err) goto pop_1_error;\n            stack_pointer += -1;\n            DISPATCH();\n        }\n\n        TARGET(STORE_SLICE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(STORE_SLICE);\n            PyObject *stop;\n            PyObject *start;\n            PyObject *container;\n            PyObject *v;\n            stop = stack_pointer[-1];\n            start = stack_pointer[-2];\n            container = stack_pointer[-3];\n            v = stack_pointer[-4];\n            PyObject *slice = _PyBuildSlice_ConsumeRefs(start, stop);\n            int err;\n            if (slice == NULL) {\n                err = 1;\n            }\n            else {\n                err = PyObject_SetItem(container, slice, v);\n                Py_DECREF(slice);\n            }\n            Py_DECREF(v);\n            Py_DECREF(container);\n            if (err) goto pop_4_error;\n            stack_pointer += -4;\n            DISPATCH();\n        }\n\n        TARGET(STORE_SUBSCR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(STORE_SUBSCR);\n            PREDICTED(STORE_SUBSCR);\n            _Py_CODEUNIT *this_instr = next_instr - 2;\n            (void)this_instr;\n            PyObject *sub;\n            PyObject *container;\n            PyObject *v;\n            // _SPECIALIZE_STORE_SUBSCR\n            sub = stack_pointer[-1];\n            container = stack_pointer[-2];\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    next_instr = this_instr;\n                    _Py_Specialize_StoreSubscr(container, sub, next_instr);\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(STORE_SUBSCR, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n            }\n            // _STORE_SUBSCR\n            v = stack_pointer[-3];\n            {\n                /* container[sub] = v */\n                int err = PyObject_SetItem(container, sub, v);\n                Py_DECREF(v);\n                Py_DECREF(container);\n                Py_DECREF(sub);\n                if (err) goto pop_3_error;\n            }\n            stack_pointer += -3;\n            DISPATCH();\n        }\n\n        TARGET(STORE_SUBSCR_DICT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(STORE_SUBSCR_DICT);\n            static_assert(INLINE_CACHE_ENTRIES_STORE_SUBSCR == 1, \"incorrect cache size\");\n            PyObject *sub;\n            PyObject *dict;\n            PyObject *value;\n            /* Skip 1 cache entry */\n            sub = stack_pointer[-1];\n            dict = stack_pointer[-2];\n            value = stack_pointer[-3];\n            DEOPT_IF(!PyDict_CheckExact(dict), STORE_SUBSCR);\n            STAT_INC(STORE_SUBSCR, hit);\n            int err = _PyDict_SetItem_Take2((PyDictObject *)dict, sub, value);\n            Py_DECREF(dict);\n            if (err) goto pop_3_error;\n            stack_pointer += -3;\n            DISPATCH();\n        }\n\n        TARGET(STORE_SUBSCR_LIST_INT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(STORE_SUBSCR_LIST_INT);\n            static_assert(INLINE_CACHE_ENTRIES_STORE_SUBSCR == 1, \"incorrect cache size\");\n            PyObject *sub;\n            PyObject *list;\n            PyObject *value;\n            /* Skip 1 cache entry */\n            sub = stack_pointer[-1];\n            list = stack_pointer[-2];\n            value = stack_pointer[-3];\n            DEOPT_IF(!PyLong_CheckExact(sub), STORE_SUBSCR);\n            DEOPT_IF(!PyList_CheckExact(list), STORE_SUBSCR);\n            // Ensure nonnegative, zero-or-one-digit ints.\n            DEOPT_IF(!_PyLong_IsNonNegativeCompact((PyLongObject *)sub), STORE_SUBSCR);\n            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];\n            // Ensure index < len(list)\n            DEOPT_IF(index >= PyList_GET_SIZE(list), STORE_SUBSCR);\n            STAT_INC(STORE_SUBSCR, hit);\n            PyObject *old_value = PyList_GET_ITEM(list, index);\n            PyList_SET_ITEM(list, index, value);\n            assert(old_value != NULL);\n            Py_DECREF(old_value);\n            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);\n            Py_DECREF(list);\n            stack_pointer += -3;\n            DISPATCH();\n        }\n\n        TARGET(SWAP) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(SWAP);\n            PyObject *top;\n            PyObject *bottom;\n            top = stack_pointer[-1];\n            bottom = stack_pointer[-2 - (oparg-2)];\n            assert(oparg >= 2);\n            stack_pointer[-2 - (oparg-2)] = top;\n            stack_pointer[-1] = bottom;\n            DISPATCH();\n        }\n\n        TARGET(TO_BOOL) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(TO_BOOL);\n            PREDICTED(TO_BOOL);\n            _Py_CODEUNIT *this_instr = next_instr - 4;\n            (void)this_instr;\n            PyObject *value;\n            PyObject *res;\n            // _SPECIALIZE_TO_BOOL\n            value = stack_pointer[-1];\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    next_instr = this_instr;\n                    _Py_Specialize_ToBool(value, next_instr);\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(TO_BOOL, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n            }\n            /* Skip 2 cache entries */\n            // _TO_BOOL\n            {\n                int err = PyObject_IsTrue(value);\n                Py_DECREF(value);\n                if (err < 0) goto pop_1_error;\n                res = err ? Py_True : Py_False;\n            }\n            stack_pointer[-1] = res;\n            DISPATCH();\n        }\n\n        TARGET(TO_BOOL_ALWAYS_TRUE) {\n            _Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(TO_BOOL_ALWAYS_TRUE);\n            static_assert(INLINE_CACHE_ENTRIES_TO_BOOL == 3, \"incorrect cache size\");\n            PyObject *owner;\n            PyObject *value;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            // _GUARD_TYPE_VERSION\n            owner = stack_pointer[-1];\n            {\n                uint32_t type_version = read_u32(&this_instr[2].cache);\n                PyTypeObject *tp = Py_TYPE(owner);\n                assert(type_version != 0);\n                DEOPT_IF(tp->tp_version_tag != type_version, TO_BOOL);\n            }\n            // _REPLACE_WITH_TRUE\n            value = owner;\n            {\n                Py_DECREF(value);\n                res = Py_True;\n            }\n            stack_pointer[-1] = res;\n            DISPATCH();\n        }\n\n        TARGET(TO_BOOL_BOOL) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(TO_BOOL_BOOL);\n            static_assert(INLINE_CACHE_ENTRIES_TO_BOOL == 3, \"incorrect cache size\");\n            PyObject *value;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            value = stack_pointer[-1];\n            DEOPT_IF(!PyBool_Check(value), TO_BOOL);\n            STAT_INC(TO_BOOL, hit);\n            DISPATCH();\n        }\n\n        TARGET(TO_BOOL_INT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(TO_BOOL_INT);\n            static_assert(INLINE_CACHE_ENTRIES_TO_BOOL == 3, \"incorrect cache size\");\n            PyObject *value;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            value = stack_pointer[-1];\n            DEOPT_IF(!PyLong_CheckExact(value), TO_BOOL);\n            STAT_INC(TO_BOOL, hit);\n            if (_PyLong_IsZero((PyLongObject *)value)) {\n                assert(_Py_IsImmortal(value));\n                res = Py_False;\n            }\n            else {\n                Py_DECREF(value);\n                res = Py_True;\n            }\n            stack_pointer[-1] = res;\n            DISPATCH();\n        }\n\n        TARGET(TO_BOOL_LIST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(TO_BOOL_LIST);\n            static_assert(INLINE_CACHE_ENTRIES_TO_BOOL == 3, \"incorrect cache size\");\n            PyObject *value;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            value = stack_pointer[-1];\n            DEOPT_IF(!PyList_CheckExact(value), TO_BOOL);\n            STAT_INC(TO_BOOL, hit);\n            res = Py_SIZE(value) ? Py_True : Py_False;\n            Py_DECREF(value);\n            stack_pointer[-1] = res;\n            DISPATCH();\n        }\n\n        TARGET(TO_BOOL_NONE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(TO_BOOL_NONE);\n            static_assert(INLINE_CACHE_ENTRIES_TO_BOOL == 3, \"incorrect cache size\");\n            PyObject *value;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            value = stack_pointer[-1];\n            // This one is a bit weird, because we expect *some* failures:\n            DEOPT_IF(!Py_IsNone(value), TO_BOOL);\n            STAT_INC(TO_BOOL, hit);\n            res = Py_False;\n            stack_pointer[-1] = res;\n            DISPATCH();\n        }\n\n        TARGET(TO_BOOL_STR) {\n            frame->instr_ptr = next_instr;\n            next_instr += 4;\n            INSTRUCTION_STATS(TO_BOOL_STR);\n            static_assert(INLINE_CACHE_ENTRIES_TO_BOOL == 3, \"incorrect cache size\");\n            PyObject *value;\n            PyObject *res;\n            /* Skip 1 cache entry */\n            /* Skip 2 cache entries */\n            value = stack_pointer[-1];\n            DEOPT_IF(!PyUnicode_CheckExact(value), TO_BOOL);\n            STAT_INC(TO_BOOL, hit);\n            if (value == &_Py_STR(empty)) {\n                assert(_Py_IsImmortal(value));\n                res = Py_False;\n            }\n            else {\n                assert(Py_SIZE(value));\n                Py_DECREF(value);\n                res = Py_True;\n            }\n            stack_pointer[-1] = res;\n            DISPATCH();\n        }\n\n        TARGET(UNARY_INVERT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(UNARY_INVERT);\n            PyObject *value;\n            PyObject *res;\n            value = stack_pointer[-1];\n            res = PyNumber_Invert(value);\n            Py_DECREF(value);\n            if (res == NULL) goto pop_1_error;\n            stack_pointer[-1] = res;\n            DISPATCH();\n        }\n\n        TARGET(UNARY_NEGATIVE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(UNARY_NEGATIVE);\n            PyObject *value;\n            PyObject *res;\n            value = stack_pointer[-1];\n            res = PyNumber_Negative(value);\n            Py_DECREF(value);\n            if (res == NULL) goto pop_1_error;\n            stack_pointer[-1] = res;\n            DISPATCH();\n        }\n\n        TARGET(UNARY_NOT) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(UNARY_NOT);\n            PyObject *value;\n            PyObject *res;\n            value = stack_pointer[-1];\n            assert(PyBool_Check(value));\n            res = Py_IsFalse(value) ? Py_True : Py_False;\n            stack_pointer[-1] = res;\n            DISPATCH();\n        }\n\n        TARGET(UNPACK_EX) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(UNPACK_EX);\n            PyObject *seq;\n            seq = stack_pointer[-1];\n            int totalargs = 1 + (oparg & 0xFF) + (oparg >> 8);\n            PyObject **top = stack_pointer + totalargs - 1;\n            int res = _PyEval_UnpackIterable(tstate, seq, oparg & 0xFF, oparg >> 8, top);\n            Py_DECREF(seq);\n            if (res == 0) goto pop_1_error;\n            stack_pointer += (oparg >> 8) + (oparg & 0xFF);\n            DISPATCH();\n        }\n\n        TARGET(UNPACK_SEQUENCE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(UNPACK_SEQUENCE);\n            PREDICTED(UNPACK_SEQUENCE);\n            _Py_CODEUNIT *this_instr = next_instr - 2;\n            (void)this_instr;\n            PyObject *seq;\n            // _SPECIALIZE_UNPACK_SEQUENCE\n            seq = stack_pointer[-1];\n            {\n                uint16_t counter = read_u16(&this_instr[1].cache);\n                (void)counter;\n                #if ENABLE_SPECIALIZATION\n                if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {\n                    next_instr = this_instr;\n                    _Py_Specialize_UnpackSequence(seq, next_instr, oparg);\n                    DISPATCH_SAME_OPARG();\n                }\n                STAT_INC(UNPACK_SEQUENCE, deferred);\n                ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter);\n                #endif  /* ENABLE_SPECIALIZATION */\n                (void)seq;\n                (void)counter;\n            }\n            // _UNPACK_SEQUENCE\n            {\n                PyObject **top = stack_pointer + oparg - 1;\n                int res = _PyEval_UnpackIterable(tstate, seq, oparg, -1, top);\n                Py_DECREF(seq);\n                if (res == 0) goto pop_1_error;\n            }\n            stack_pointer += -1 + oparg;\n            DISPATCH();\n        }\n\n        TARGET(UNPACK_SEQUENCE_LIST) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(UNPACK_SEQUENCE_LIST);\n            static_assert(INLINE_CACHE_ENTRIES_UNPACK_SEQUENCE == 1, \"incorrect cache size\");\n            PyObject *seq;\n            PyObject **values;\n            /* Skip 1 cache entry */\n            seq = stack_pointer[-1];\n            values = &stack_pointer[-1];\n            DEOPT_IF(!PyList_CheckExact(seq), UNPACK_SEQUENCE);\n            DEOPT_IF(PyList_GET_SIZE(seq) != oparg, UNPACK_SEQUENCE);\n            STAT_INC(UNPACK_SEQUENCE, hit);\n            PyObject **items = _PyList_ITEMS(seq);\n            for (int i = oparg; --i >= 0; ) {\n                *values++ = Py_NewRef(items[i]);\n            }\n            Py_DECREF(seq);\n            stack_pointer += -1 + oparg;\n            DISPATCH();\n        }\n\n        TARGET(UNPACK_SEQUENCE_TUPLE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(UNPACK_SEQUENCE_TUPLE);\n            static_assert(INLINE_CACHE_ENTRIES_UNPACK_SEQUENCE == 1, \"incorrect cache size\");\n            PyObject *seq;\n            PyObject **values;\n            /* Skip 1 cache entry */\n            seq = stack_pointer[-1];\n            values = &stack_pointer[-1];\n            DEOPT_IF(!PyTuple_CheckExact(seq), UNPACK_SEQUENCE);\n            DEOPT_IF(PyTuple_GET_SIZE(seq) != oparg, UNPACK_SEQUENCE);\n            STAT_INC(UNPACK_SEQUENCE, hit);\n            PyObject **items = _PyTuple_ITEMS(seq);\n            for (int i = oparg; --i >= 0; ) {\n                *values++ = Py_NewRef(items[i]);\n            }\n            Py_DECREF(seq);\n            stack_pointer += -1 + oparg;\n            DISPATCH();\n        }\n\n        TARGET(UNPACK_SEQUENCE_TWO_TUPLE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 2;\n            INSTRUCTION_STATS(UNPACK_SEQUENCE_TWO_TUPLE);\n            static_assert(INLINE_CACHE_ENTRIES_UNPACK_SEQUENCE == 1, \"incorrect cache size\");\n            PyObject *seq;\n            PyObject *val1;\n            PyObject *val0;\n            /* Skip 1 cache entry */\n            seq = stack_pointer[-1];\n            assert(oparg == 2);\n            DEOPT_IF(!PyTuple_CheckExact(seq), UNPACK_SEQUENCE);\n            DEOPT_IF(PyTuple_GET_SIZE(seq) != 2, UNPACK_SEQUENCE);\n            STAT_INC(UNPACK_SEQUENCE, hit);\n            val0 = Py_NewRef(PyTuple_GET_ITEM(seq, 0));\n            val1 = Py_NewRef(PyTuple_GET_ITEM(seq, 1));\n            Py_DECREF(seq);\n            stack_pointer[-1] = val1;\n            stack_pointer[0] = val0;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(WITH_EXCEPT_START) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(WITH_EXCEPT_START);\n            PyObject *val;\n            PyObject *lasti;\n            PyObject *exit_func;\n            PyObject *res;\n            val = stack_pointer[-1];\n            lasti = stack_pointer[-3];\n            exit_func = stack_pointer[-4];\n            /* At the top of the stack are 4 values:\n               - val: TOP = exc_info()\n               - unused: SECOND = previous exception\n               - lasti: THIRD = lasti of exception in exc_info()\n               - exit_func: FOURTH = the context.__exit__ bound method\n               We call FOURTH(type(TOP), TOP, GetTraceback(TOP)).\n               Then we push the __exit__ return value.\n             */\n            PyObject *exc, *tb;\n            assert(val && PyExceptionInstance_Check(val));\n            exc = PyExceptionInstance_Class(val);\n            tb = PyException_GetTraceback(val);\n            if (tb == NULL) {\n                tb = Py_None;\n            }\n            else {\n                Py_DECREF(tb);\n            }\n            assert(PyLong_Check(lasti));\n            (void)lasti; // Shut up compiler warning if asserts are off\n            PyObject *stack[4] = {NULL, exc, val, tb};\n            res = PyObject_Vectorcall(exit_func, stack + 1,\n                                      3 | PY_VECTORCALL_ARGUMENTS_OFFSET, NULL);\n            if (res == NULL) goto error;\n            stack_pointer[0] = res;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n\n        TARGET(YIELD_VALUE) {\n            frame->instr_ptr = next_instr;\n            next_instr += 1;\n            INSTRUCTION_STATS(YIELD_VALUE);\n            PyObject *retval;\n            PyObject *value;\n            retval = stack_pointer[-1];\n            // NOTE: It's important that YIELD_VALUE never raises an exception!\n            // The compiler treats any exception raised here as a failed close()\n            // or throw() call.\n            #if TIER_ONE\n            assert(frame != &entry_frame);\n            #endif\n            frame->instr_ptr++;\n            PyGenObject *gen = _PyFrame_GetGenerator(frame);\n            assert(FRAME_SUSPENDED_YIELD_FROM == FRAME_SUSPENDED + 1);\n            assert(oparg == 0 || oparg == 1);\n            gen->gi_frame_state = FRAME_SUSPENDED + oparg;\n            stack_pointer += -1;\n            _PyFrame_SetStackPointer(frame, stack_pointer);\n            tstate->exc_info = gen->gi_exc_state.previous_item;\n            gen->gi_exc_state.previous_item = NULL;\n            _Py_LeaveRecursiveCallPy(tstate);\n            _PyInterpreterFrame *gen_frame = frame;\n            frame = tstate->current_frame = frame->previous;\n            gen_frame->previous = NULL;\n            /* We don't know which of these is relevant here, so keep them equal */\n            assert(INLINE_CACHE_ENTRIES_SEND == INLINE_CACHE_ENTRIES_FOR_ITER);\n            #if TIER_ONE\n            assert(frame->instr_ptr->op.code == INSTRUMENTED_LINE ||\n                   frame->instr_ptr->op.code == INSTRUMENTED_INSTRUCTION ||\n                   _PyOpcode_Deopt[frame->instr_ptr->op.code] == SEND ||\n                   _PyOpcode_Deopt[frame->instr_ptr->op.code] == FOR_ITER ||\n                   _PyOpcode_Deopt[frame->instr_ptr->op.code] == INTERPRETER_EXIT ||\n                   _PyOpcode_Deopt[frame->instr_ptr->op.code] == ENTER_EXECUTOR);\n            #endif\n            LOAD_IP(1 + INLINE_CACHE_ENTRIES_SEND);\n            LOAD_SP();\n            value = retval;\n            LLTRACE_RESUME_FRAME();\n            stack_pointer[0] = value;\n            stack_pointer += 1;\n            DISPATCH();\n        }\n#undef TIER_ONE\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-write-to-const",
                        "properties": {"gcc/analyzer/saved_diagnostic/enode": 26326,
                                       "gcc/analyzer/saved_diagnostic/snode": 85,
                                       "gcc/analyzer/saved_diagnostic/idx": 1},
                        "level": "warning",
                        "message": {"text": "write to 'const' object '_Py_InitCleanup'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/pyatomic_gcc.h",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 63,
                                                                       "startColumn": 10,
                                                                       "endColumn": 28},
                                                            "contextRegion": {"startLine": 63,
                                                                              "snippet": {"text": "{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n"}}},
                                       "logicalLocations": [{"name": "_Py_NewRef.part.0",
                                                             "fullyQualifiedName": "_Py_NewRef.part.0",
                                                             "decoratedName": "_Py_NewRef.part.0",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1814,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 1814,
                                                                                                                           "snippet": {"text": "PyEval_EvalCodeEx(PyObject *_co, PyObject *globals, PyObject *locals,\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'PyEval_EvalCodeEx'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 686,
                                                                                                                                 "dst_idx": 688,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1823,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1823,
                                                                                                                           "snippet": {"text": "    if (defaults == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'defaults' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 686,
                                                                                                                                 "dst_idx": 688,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1826,
                                                                                                                    "startColumn": 26,
                                                                                                                    "endColumn": 70},
                                                                                                         "contextRegion": {"startLine": 1826,
                                                                                                                           "snippet": {"text": "    PyObject *builtins = _PyEval_BuiltinsFromGlobals(tstate, globals); // borrowed ref\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 688,
                                                                                                                                 "dst_idx": 691,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1827,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1827,
                                                                                                                           "snippet": {"text": "    if (builtins == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'builtins' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 688,
                                                                                                                                 "dst_idx": 691,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1831,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1831,
                                                                                                                           "snippet": {"text": "    if (locals == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 693,
                                                                                                                                 "dst_idx": 705,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1838,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1838,
                                                                                                                           "snippet": {"text": "    if (kwcount == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'kwcount == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 693,
                                                                                                                                 "dst_idx": 705,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1859,
                                                                                                                    "startColumn": 24,
                                                                                                                    "endColumn": 30},
                                                                                                         "contextRegion": {"startLine": 1859,
                                                                                                                           "snippet": {"text": "    PyFrameConstructor constr = {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 705,
                                                                                                                                 "dst_idx": 707,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1870,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1870,
                                                                                                                           "snippet": {"text": "    if (func == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'func' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 705,
                                                                                                                                 "dst_idx": 707,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1874,
                                                                                                                    "startColumn": 11,
                                                                                                                    "endLine": 1876,
                                                                                                                    "endColumn": 34},
                                                                                                         "contextRegion": {"startLine": 1874,
                                                                                                                           "endLine": 1876,
                                                                                                                           "snippet": {"text": "    res = _PyEval_Vector(tstate, func, locals,\n                         allargs, argcount,\n                         kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 707,
                                                                                                                                 "dst_idx": 717,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1874,
                                                                                                                    "startColumn": 11,
                                                                                                                    "endLine": 1876,
                                                                                                                    "endColumn": 34},
                                                                                                         "contextRegion": {"startLine": 1874,
                                                                                                                           "endLine": 1876,
                                                                                                                           "snippet": {"text": "    res = _PyEval_Vector(tstate, func, locals,\n                         allargs, argcount,\n                         kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyEval_Vector' from 'PyEval_EvalCodeEx'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1785,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1785,
                                                                                                                           "snippet": {"text": "_PyEval_Vector(PyThreadState *tstate, PyFunctionObject *func,\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyEval_Vector'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 730,
                                                                                                                                 "dst_idx": 738,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1797,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1797,
                                                                                                                           "snippet": {"text": "    if (kwnames) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'kwnames' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 730,
                                                                                                                                 "dst_idx": 738,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1803,
                                                                                                                    "startColumn": 34,
                                                                                                                    "endLine": 1804,
                                                                                                                    "endColumn": 55},
                                                                                                         "contextRegion": {"startLine": 1803,
                                                                                                                           "endLine": 1804,
                                                                                                                           "snippet": {"text": "    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n        tstate, func, locals, args, argcount, kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 738,
                                                                                                                                 "dst_idx": 769,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1803,
                                                                                                                    "startColumn": 34,
                                                                                                                    "endLine": 1804,
                                                                                                                    "endColumn": 55},
                                                                                                         "contextRegion": {"startLine": 1803,
                                                                                                                           "endLine": 1804,
                                                                                                                           "snippet": {"text": "    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n        tstate, func, locals, args, argcount, kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyEvalFramePushAndInit' from '_PyEval_Vector'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1707,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 24},
                                                                                                         "contextRegion": {"startLine": 1707,
                                                                                                                           "snippet": {"text": "_PyEvalFramePushAndInit(PyThreadState *tstate, PyFunctionObject *func,\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyEvalFramePushAndInit'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 770,
                                                                                                                                 "dst_idx": 776,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1714,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1714,
                                                                                                                           "snippet": {"text": "    if (frame == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'frame' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 770,
                                                                                                                                 "dst_idx": 776,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1717,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 54},
                                                                                                         "contextRegion": {"startLine": 1717,
                                                                                                                           "snippet": {"text": "    _PyFrame_Initialize(frame, func, locals, code, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 777,
                                                                                                                                 "dst_idx": 811,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1718,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 84},
                                                                                                         "contextRegion": {"startLine": 1718,
                                                                                                                           "snippet": {"text": "    if (initialize_locals(tstate, func, frame->localsplus, args, argcount, kwnames)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'initialize_locals' from '_PyEvalFramePushAndInit'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1414,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 1414,
                                                                                                                           "snippet": {"text": "initialize_locals(PyThreadState *tstate, PyFunctionObject *func,\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'initialize_locals'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 831,
                                                                                                                                 "dst_idx": 880,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1478,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1478,
                                                                                                                           "snippet": {"text": "    if (kwnames != NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'kwnames' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 831,
                                                                                                                                 "dst_idx": 880,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1581,
                                                                                                                    "startColumn": 21,
                                                                                                                    "endColumn": 36},
                                                                                                         "contextRegion": {"startLine": 1581,
                                                                                                                           "snippet": {"text": "    if ((argcount > co->co_argcount) && !(co->co_flags & CO_VARARGS)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 932,
                                                                                                                                 "dst_idx": 778,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1718,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 84},
                                                                                                         "contextRegion": {"startLine": 1718,
                                                                                                                           "snippet": {"text": "    if (initialize_locals(tstate, func, frame->localsplus, args, argcount, kwnames)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to '_PyEvalFramePushAndInit' from 'initialize_locals'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 22},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(23)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 778,
                                                                                                                                 "dst_idx": 791,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1718,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1718,
                                                                                                                           "snippet": {"text": "    if (initialize_locals(tstate, func, frame->localsplus, args, argcount, kwnames)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 23},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(24)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 778,
                                                                                                                                 "dst_idx": 791,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 24},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(25)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 792,
                                                                                                                                 "dst_idx": 739,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1803,
                                                                                                                    "startColumn": 34,
                                                                                                                    "endLine": 1804,
                                                                                                                    "endColumn": 55},
                                                                                                         "contextRegion": {"startLine": 1803,
                                                                                                                           "endLine": 1804,
                                                                                                                           "snippet": {"text": "    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n        tstate, func, locals, args, argcount, kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to '_PyEval_Vector' from '_PyEvalFramePushAndInit'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 25},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(26)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 739,
                                                                                                                                 "dst_idx": 740,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1805,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1805,
                                                                                                                           "snippet": {"text": "    if (frame == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'frame' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 26},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(27)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 739,
                                                                                                                                 "dst_idx": 740,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1809,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 47},
                                                                                                         "contextRegion": {"startLine": 1809,
                                                                                                                           "snippet": {"text": "    return _PyEval_EvalFrame(tstate, frame, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 27},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(28)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 740,
                                                                                                                                 "dst_idx": 3332,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1809,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 47},
                                                                                                         "contextRegion": {"startLine": 1809,
                                                                                                                           "snippet": {"text": "    return _PyEval_EvalFrame(tstate, frame, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyEval_EvalFrame' from '_PyEval_Vector'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 28},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(29)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_ceval.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 115,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 115,
                                                                                                                           "snippet": {"text": "_PyEval_EvalFrame(PyThreadState *tstate, struct _PyInterpreterFrame *frame, int throwflag)\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrame",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrame",
                                                                                                          "decoratedName": "_PyEval_EvalFrame",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyEval_EvalFrame'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 29},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(30)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3333,
                                                                                                                                 "dst_idx": 3334,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_ceval.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 118,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 118,
                                                                                                                           "snippet": {"text": "    if (tstate->interp->eval_frame == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrame",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrame",
                                                                                                          "decoratedName": "_PyEval_EvalFrame",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 30},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(31)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3333,
                                                                                                                                 "dst_idx": 3334,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_ceval.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 119,
                                                                                                                    "startColumn": 16,
                                                                                                                    "endColumn": 66},
                                                                                                         "contextRegion": {"startLine": 119,
                                                                                                                           "snippet": {"text": "        return _PyEval_EvalFrameDefault(tstate, frame, throwflag);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrame",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrame",
                                                                                                          "decoratedName": "_PyEval_EvalFrame",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 31},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(32)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 3334,
                                                                                                                                 "dst_idx": 1087,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_ceval.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 119,
                                                                                                                    "startColumn": 16,
                                                                                                                    "endColumn": 66},
                                                                                                         "contextRegion": {"startLine": 119,
                                                                                                                           "snippet": {"text": "        return _PyEval_EvalFrameDefault(tstate, frame, throwflag);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrame",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrame",
                                                                                                          "decoratedName": "_PyEval_EvalFrame",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyEval_EvalFrameDefault' from '_PyEval_EvalFrame'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 32},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(33)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 680,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 25},
                                                                                                         "contextRegion": {"startLine": 680,
                                                                                                                           "snippet": {"text": "_PyEval_EvalFrameDefault(PyThreadState *tstate, _PyInterpreterFrame *frame, int throwflag)\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyEval_EvalFrameDefault'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 33},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(34)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 682,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 682,
                                                                                                                           "snippet": {"text": "    _Py_EnsureTstateNotNULL(tstate);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to '_Py_EnsureFuncTstateNotNULL' from '_PyEval_EvalFrameDefault'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 34},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(35)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "_PyEval_EvalFrameDefault",
                                                                                                                                     "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                                                     "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 4,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1088,
                                                                                                                                 "dst_idx": 1090,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_pystate.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 188,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 188,
                                                                                                                           "snippet": {"text": "    if (tstate == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_EnsureFuncTstateNotNULL",
                                                                                                          "fullyQualifiedName": "_Py_EnsureFuncTstateNotNULL",
                                                                                                          "decoratedName": "_Py_EnsureFuncTstateNotNULL",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'tstate' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 35},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(36)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1088,
                                                                                                                                 "dst_idx": 1090,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 711,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 33},
                                                                                                         "contextRegion": {"startLine": 711,
                                                                                                                           "snippet": {"text": "    entry_frame.f_executable = Py_None;\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 36},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(37)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1094,
                                                                                                                                 "dst_idx": 1101,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 729,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 729,
                                                                                                                           "snippet": {"text": "    if (throwflag) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'throwflag == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 37},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(38)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1094,
                                                                                                                                 "dst_idx": 1101,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 752,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 12},
                                                                                                         "contextRegion": {"startLine": 752,
                                                                                                                           "snippet": {"text": "start_frame:\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 38},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(39)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1444,
                                                                                                                                 "dst_idx": 3394,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/generated_cases.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 885,
                                                                                                                    "startColumn": 41,
                                                                                                                    "endLine": 886,
                                                                                                                    "endColumn": 61},
                                                                                                         "contextRegion": {"startLine": 885,
                                                                                                                           "endLine": 886,
                                                                                                                           "snippet": {"text": "            _PyInterpreterFrame *shim = _PyFrame_PushTrampolineUnchecked(\n                tstate, (PyCodeObject *)&_Py_InitCleanup, 1);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyFrame_PushTrampolineUnchecked' from '_PyEval_EvalFrameDefault'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 39},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(40)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_frame.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 289,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 33},
                                                                                                         "contextRegion": {"startLine": 289,
                                                                                                                           "snippet": {"text": "_PyFrame_PushTrampolineUnchecked(PyThreadState *tstate, PyCodeObject *code, int stackdepth)\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyFrame_PushTrampolineUnchecked",
                                                                                                          "fullyQualifiedName": "_PyFrame_PushTrampolineUnchecked",
                                                                                                          "decoratedName": "_PyFrame_PushTrampolineUnchecked",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyFrame_PushTrampolineUnchecked'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 40},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(41)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 3395,
                                                                                                                                 "dst_idx": 3434,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_frame.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 296,
                                                                                                                    "startColumn": 27,
                                                                                                                    "endColumn": 28},
                                                                                                         "contextRegion": {"startLine": 296,
                                                                                                                           "snippet": {"text": "    frame->f_executable = Py_NewRef(code);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyFrame_PushTrampolineUnchecked",
                                                                                                          "fullyQualifiedName": "_PyFrame_PushTrampolineUnchecked",
                                                                                                          "decoratedName": "_PyFrame_PushTrampolineUnchecked",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_Py_NewRef' from '_PyFrame_PushTrampolineUnchecked'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 41},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(42)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1050,
                                                                                                                    "startColumn": 25,
                                                                                                                    "endColumn": 35},
                                                                                                         "contextRegion": {"startLine": 1050,
                                                                                                                           "snippet": {"text": "static inline PyObject* _Py_NewRef(PyObject *obj)\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_NewRef",
                                                                                                          "fullyQualifiedName": "_Py_NewRef",
                                                                                                          "decoratedName": "_Py_NewRef",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_Py_NewRef'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 6,
                                                                       "executionOrder": 42},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(43)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1052,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1052,
                                                                                                                           "snippet": {"text": "    Py_INCREF(obj);\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_NewRef",
                                                                                                          "fullyQualifiedName": "_Py_NewRef",
                                                                                                          "decoratedName": "_Py_NewRef",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'Py_INCREF' from '_Py_NewRef'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 6,
                                                                       "executionOrder": 43},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(44)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "_Py_NewRef",
                                                                                                                                     "fullyQualifiedName": "_Py_NewRef",
                                                                                                                                     "decoratedName": "_Py_NewRef",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 6,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3435,
                                                                                                                                 "dst_idx": 3436,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 806,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 806,
                                                                                                                           "snippet": {"text": "    if (new_local == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'new_local != 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 7,
                                                                       "executionOrder": 44},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(45)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 810,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 810,
                                                                                                                           "snippet": {"text": "    if (_Py_IsOwnedByCurrentThread(op)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to '_Py_IsOwnedByCurrentThread' from 'Py_INCREF'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 7,
                                                                       "executionOrder": 45},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(46)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "_Py_NewRef",
                                                                                                                                     "fullyQualifiedName": "_Py_NewRef",
                                                                                                                                     "decoratedName": "_Py_NewRef",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 6,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3435,
                                                                                                                                 "dst_idx": 3436,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 305,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 22},
                                                                                                         "contextRegion": {"startLine": 305,
                                                                                                                           "snippet": {"text": "    return ob->ob_tid == _Py_ThreadId();\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_IsOwnedByCurrentThread",
                                                                                                          "fullyQualifiedName": "_Py_IsOwnedByCurrentThread",
                                                                                                          "decoratedName": "_Py_IsOwnedByCurrentThread",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 8,
                                                                       "executionOrder": 46},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(47)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "_Py_NewRef",
                                                                                                                                     "fullyQualifiedName": "_Py_NewRef",
                                                                                                                                     "decoratedName": "_Py_NewRef",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 6,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3436,
                                                                                                                                 "dst_idx": 3438,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 810,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 810,
                                                                                                                           "snippet": {"text": "    if (_Py_IsOwnedByCurrentThread(op)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 7,
                                                                       "executionOrder": 47},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(48)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3436,
                                                                                                                                 "dst_idx": 3438,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"logicalLocations": [{"name": "_Py_NewRef",
                                                                                                          "fullyQualifiedName": "_Py_NewRef",
                                                                                                          "decoratedName": "_Py_NewRef",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 6,
                                                                       "executionOrder": 48},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(49)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 3438,
                                                                                                                                 "dst_idx": 83,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"logicalLocations": [{"name": "_Py_NewRef",
                                                                                                          "fullyQualifiedName": "_Py_NewRef",
                                                                                                          "decoratedName": "_Py_NewRef",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_Py_NewRef.part.0' from '_Py_NewRef'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 6,
                                                                       "executionOrder": 49},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(50)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1050,
                                                                                                                    "startColumn": 25,
                                                                                                                    "endColumn": 35},
                                                                                                         "contextRegion": {"startLine": 1050,
                                                                                                                           "snippet": {"text": "static inline PyObject* _Py_NewRef(PyObject *obj)\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_NewRef.part.0",
                                                                                                          "fullyQualifiedName": "_Py_NewRef.part.0",
                                                                                                          "decoratedName": "_Py_NewRef.part.0",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_Py_NewRef.part.0'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 7,
                                                                       "executionOrder": 50},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(51)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1052,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1052,
                                                                                                                           "snippet": {"text": "    Py_INCREF(obj);\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_NewRef.part.0",
                                                                                                          "fullyQualifiedName": "_Py_NewRef.part.0",
                                                                                                          "decoratedName": "_Py_NewRef.part.0",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'Py_INCREF' from '_Py_NewRef.part.0'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 7,
                                                                       "executionOrder": 51},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(52)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 814,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 814,
                                                                                                                           "snippet": {"text": "        _Py_atomic_add_ssize(&op->ob_ref_shared, (1 << _Py_REF_SHARED_SHIFT));\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to '_Py_atomic_add_ssize' from 'Py_INCREF'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 8,
                                                                       "executionOrder": 52},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(53)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "_Py_NewRef.part.0",
                                                                                                                                     "fullyQualifiedName": "_Py_NewRef.part.0",
                                                                                                                                     "decoratedName": "_Py_NewRef.part.0",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 7},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/pyatomic_gcc.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 63,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 28},
                                                                                                         "contextRegion": {"startLine": 63,
                                                                                                                           "snippet": {"text": "{ return __atomic_fetch_add(obj, value, __ATOMIC_SEQ_CST); }\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_atomic_add_ssize",
                                                                                                          "fullyQualifiedName": "_Py_atomic_add_ssize",
                                                                                                          "decoratedName": "_Py_atomic_add_ssize",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "write to 'const' object '_Py_InitCleanup' here"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 9,
                                                                       "executionOrder": 53}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 655,
                                                                              "startColumn": 36,
                                                                              "endColumn": 51},
                                                                   "contextRegion": {"startLine": 655,
                                                                                     "snippet": {"text": "extern const struct _PyCode_DEF(8) _Py_InitCleanup;\n"}}},
                                              "message": {"text": "declared here"}}]},
                       {"ruleId": "-Wanalyzer-write-to-const",
                        "properties": {"gcc/analyzer/saved_diagnostic/enode": 26316,
                                       "gcc/analyzer/saved_diagnostic/snode": 3437,
                                       "gcc/analyzer/saved_diagnostic/idx": 0},
                        "level": "warning",
                        "message": {"text": "write to 'const' object '_Py_InitCleanup'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/pyatomic_gcc.h",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 461,
                                                                       "startColumn": 3,
                                                                       "endColumn": 49},
                                                            "contextRegion": {"startLine": 461,
                                                                              "snippet": {"text": "{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n"}}},
                                       "logicalLocations": [{"name": "_Py_NewRef",
                                                             "fullyQualifiedName": "_Py_NewRef",
                                                             "decoratedName": "_Py_NewRef",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1814,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 1814,
                                                                                                                           "snippet": {"text": "PyEval_EvalCodeEx(PyObject *_co, PyObject *globals, PyObject *locals,\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'PyEval_EvalCodeEx'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 686,
                                                                                                                                 "dst_idx": 688,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1823,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1823,
                                                                                                                           "snippet": {"text": "    if (defaults == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'defaults' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 686,
                                                                                                                                 "dst_idx": 688,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1826,
                                                                                                                    "startColumn": 26,
                                                                                                                    "endColumn": 70},
                                                                                                         "contextRegion": {"startLine": 1826,
                                                                                                                           "snippet": {"text": "    PyObject *builtins = _PyEval_BuiltinsFromGlobals(tstate, globals); // borrowed ref\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 688,
                                                                                                                                 "dst_idx": 691,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1827,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1827,
                                                                                                                           "snippet": {"text": "    if (builtins == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'builtins' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 688,
                                                                                                                                 "dst_idx": 691,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1831,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1831,
                                                                                                                           "snippet": {"text": "    if (locals == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 693,
                                                                                                                                 "dst_idx": 705,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1838,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1838,
                                                                                                                           "snippet": {"text": "    if (kwcount == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'kwcount == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 693,
                                                                                                                                 "dst_idx": 705,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1859,
                                                                                                                    "startColumn": 24,
                                                                                                                    "endColumn": 30},
                                                                                                         "contextRegion": {"startLine": 1859,
                                                                                                                           "snippet": {"text": "    PyFrameConstructor constr = {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 705,
                                                                                                                                 "dst_idx": 707,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1870,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1870,
                                                                                                                           "snippet": {"text": "    if (func == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'func' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 705,
                                                                                                                                 "dst_idx": 707,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1874,
                                                                                                                    "startColumn": 11,
                                                                                                                    "endLine": 1876,
                                                                                                                    "endColumn": 34},
                                                                                                         "contextRegion": {"startLine": 1874,
                                                                                                                           "endLine": 1876,
                                                                                                                           "snippet": {"text": "    res = _PyEval_Vector(tstate, func, locals,\n                         allargs, argcount,\n                         kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 707,
                                                                                                                                 "dst_idx": 717,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1874,
                                                                                                                    "startColumn": 11,
                                                                                                                    "endLine": 1876,
                                                                                                                    "endColumn": 34},
                                                                                                         "contextRegion": {"startLine": 1874,
                                                                                                                           "endLine": 1876,
                                                                                                                           "snippet": {"text": "    res = _PyEval_Vector(tstate, func, locals,\n                         allargs, argcount,\n                         kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyEval_Vector' from 'PyEval_EvalCodeEx'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1785,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1785,
                                                                                                                           "snippet": {"text": "_PyEval_Vector(PyThreadState *tstate, PyFunctionObject *func,\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyEval_Vector'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 730,
                                                                                                                                 "dst_idx": 738,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1797,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1797,
                                                                                                                           "snippet": {"text": "    if (kwnames) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'kwnames' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 730,
                                                                                                                                 "dst_idx": 738,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1803,
                                                                                                                    "startColumn": 34,
                                                                                                                    "endLine": 1804,
                                                                                                                    "endColumn": 55},
                                                                                                         "contextRegion": {"startLine": 1803,
                                                                                                                           "endLine": 1804,
                                                                                                                           "snippet": {"text": "    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n        tstate, func, locals, args, argcount, kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 738,
                                                                                                                                 "dst_idx": 769,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1803,
                                                                                                                    "startColumn": 34,
                                                                                                                    "endLine": 1804,
                                                                                                                    "endColumn": 55},
                                                                                                         "contextRegion": {"startLine": 1803,
                                                                                                                           "endLine": 1804,
                                                                                                                           "snippet": {"text": "    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n        tstate, func, locals, args, argcount, kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyEvalFramePushAndInit' from '_PyEval_Vector'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1707,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 24},
                                                                                                         "contextRegion": {"startLine": 1707,
                                                                                                                           "snippet": {"text": "_PyEvalFramePushAndInit(PyThreadState *tstate, PyFunctionObject *func,\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyEvalFramePushAndInit'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 770,
                                                                                                                                 "dst_idx": 776,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1714,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1714,
                                                                                                                           "snippet": {"text": "    if (frame == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'frame' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 770,
                                                                                                                                 "dst_idx": 776,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1717,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 54},
                                                                                                         "contextRegion": {"startLine": 1717,
                                                                                                                           "snippet": {"text": "    _PyFrame_Initialize(frame, func, locals, code, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 777,
                                                                                                                                 "dst_idx": 811,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1718,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 84},
                                                                                                         "contextRegion": {"startLine": 1718,
                                                                                                                           "snippet": {"text": "    if (initialize_locals(tstate, func, frame->localsplus, args, argcount, kwnames)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'initialize_locals' from '_PyEvalFramePushAndInit'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1414,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 1414,
                                                                                                                           "snippet": {"text": "initialize_locals(PyThreadState *tstate, PyFunctionObject *func,\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'initialize_locals'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 831,
                                                                                                                                 "dst_idx": 880,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1478,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1478,
                                                                                                                           "snippet": {"text": "    if (kwnames != NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'kwnames' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 831,
                                                                                                                                 "dst_idx": 880,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1581,
                                                                                                                    "startColumn": 21,
                                                                                                                    "endColumn": 36},
                                                                                                         "contextRegion": {"startLine": 1581,
                                                                                                                           "snippet": {"text": "    if ((argcount > co->co_argcount) && !(co->co_flags & CO_VARARGS)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 932,
                                                                                                                                 "dst_idx": 778,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1718,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 84},
                                                                                                         "contextRegion": {"startLine": 1718,
                                                                                                                           "snippet": {"text": "    if (initialize_locals(tstate, func, frame->localsplus, args, argcount, kwnames)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to '_PyEvalFramePushAndInit' from 'initialize_locals'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 22},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(23)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 778,
                                                                                                                                 "dst_idx": 791,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1718,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1718,
                                                                                                                           "snippet": {"text": "    if (initialize_locals(tstate, func, frame->localsplus, args, argcount, kwnames)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 23},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(24)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 778,
                                                                                                                                 "dst_idx": 791,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 24},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(25)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 792,
                                                                                                                                 "dst_idx": 739,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1803,
                                                                                                                    "startColumn": 34,
                                                                                                                    "endLine": 1804,
                                                                                                                    "endColumn": 55},
                                                                                                         "contextRegion": {"startLine": 1803,
                                                                                                                           "endLine": 1804,
                                                                                                                           "snippet": {"text": "    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n        tstate, func, locals, args, argcount, kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to '_PyEval_Vector' from '_PyEvalFramePushAndInit'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 25},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(26)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 739,
                                                                                                                                 "dst_idx": 740,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1805,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1805,
                                                                                                                           "snippet": {"text": "    if (frame == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'frame' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 26},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(27)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 739,
                                                                                                                                 "dst_idx": 740,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1809,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 47},
                                                                                                         "contextRegion": {"startLine": 1809,
                                                                                                                           "snippet": {"text": "    return _PyEval_EvalFrame(tstate, frame, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 27},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(28)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 740,
                                                                                                                                 "dst_idx": 3332,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1809,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 47},
                                                                                                         "contextRegion": {"startLine": 1809,
                                                                                                                           "snippet": {"text": "    return _PyEval_EvalFrame(tstate, frame, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyEval_EvalFrame' from '_PyEval_Vector'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 28},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(29)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_ceval.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 115,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 115,
                                                                                                                           "snippet": {"text": "_PyEval_EvalFrame(PyThreadState *tstate, struct _PyInterpreterFrame *frame, int throwflag)\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrame",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrame",
                                                                                                          "decoratedName": "_PyEval_EvalFrame",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyEval_EvalFrame'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 29},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(30)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3333,
                                                                                                                                 "dst_idx": 3334,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_ceval.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 118,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 118,
                                                                                                                           "snippet": {"text": "    if (tstate->interp->eval_frame == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrame",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrame",
                                                                                                          "decoratedName": "_PyEval_EvalFrame",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 30},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(31)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3333,
                                                                                                                                 "dst_idx": 3334,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_ceval.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 119,
                                                                                                                    "startColumn": 16,
                                                                                                                    "endColumn": 66},
                                                                                                         "contextRegion": {"startLine": 119,
                                                                                                                           "snippet": {"text": "        return _PyEval_EvalFrameDefault(tstate, frame, throwflag);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrame",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrame",
                                                                                                          "decoratedName": "_PyEval_EvalFrame",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 31},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(32)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 3334,
                                                                                                                                 "dst_idx": 1087,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_ceval.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 119,
                                                                                                                    "startColumn": 16,
                                                                                                                    "endColumn": 66},
                                                                                                         "contextRegion": {"startLine": 119,
                                                                                                                           "snippet": {"text": "        return _PyEval_EvalFrameDefault(tstate, frame, throwflag);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrame",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrame",
                                                                                                          "decoratedName": "_PyEval_EvalFrame",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyEval_EvalFrameDefault' from '_PyEval_EvalFrame'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 32},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(33)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 680,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 25},
                                                                                                         "contextRegion": {"startLine": 680,
                                                                                                                           "snippet": {"text": "_PyEval_EvalFrameDefault(PyThreadState *tstate, _PyInterpreterFrame *frame, int throwflag)\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyEval_EvalFrameDefault'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 33},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(34)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 682,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 682,
                                                                                                                           "snippet": {"text": "    _Py_EnsureTstateNotNULL(tstate);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to '_Py_EnsureFuncTstateNotNULL' from '_PyEval_EvalFrameDefault'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 34},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(35)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "_PyEval_EvalFrameDefault",
                                                                                                                                     "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                                                     "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 4,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1088,
                                                                                                                                 "dst_idx": 1090,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_pystate.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 188,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 188,
                                                                                                                           "snippet": {"text": "    if (tstate == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_EnsureFuncTstateNotNULL",
                                                                                                          "fullyQualifiedName": "_Py_EnsureFuncTstateNotNULL",
                                                                                                          "decoratedName": "_Py_EnsureFuncTstateNotNULL",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'tstate' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 35},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(36)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1088,
                                                                                                                                 "dst_idx": 1090,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 711,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 33},
                                                                                                         "contextRegion": {"startLine": 711,
                                                                                                                           "snippet": {"text": "    entry_frame.f_executable = Py_None;\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 36},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(37)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1094,
                                                                                                                                 "dst_idx": 1101,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 729,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 729,
                                                                                                                           "snippet": {"text": "    if (throwflag) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'throwflag == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 37},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(38)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1094,
                                                                                                                                 "dst_idx": 1101,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 752,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 12},
                                                                                                         "contextRegion": {"startLine": 752,
                                                                                                                           "snippet": {"text": "start_frame:\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 38},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(39)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1444,
                                                                                                                                 "dst_idx": 3394,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/generated_cases.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 885,
                                                                                                                    "startColumn": 41,
                                                                                                                    "endLine": 886,
                                                                                                                    "endColumn": 61},
                                                                                                         "contextRegion": {"startLine": 885,
                                                                                                                           "endLine": 886,
                                                                                                                           "snippet": {"text": "            _PyInterpreterFrame *shim = _PyFrame_PushTrampolineUnchecked(\n                tstate, (PyCodeObject *)&_Py_InitCleanup, 1);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyFrame_PushTrampolineUnchecked' from '_PyEval_EvalFrameDefault'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 39},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(40)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_frame.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 289,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 33},
                                                                                                         "contextRegion": {"startLine": 289,
                                                                                                                           "snippet": {"text": "_PyFrame_PushTrampolineUnchecked(PyThreadState *tstate, PyCodeObject *code, int stackdepth)\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyFrame_PushTrampolineUnchecked",
                                                                                                          "fullyQualifiedName": "_PyFrame_PushTrampolineUnchecked",
                                                                                                          "decoratedName": "_PyFrame_PushTrampolineUnchecked",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyFrame_PushTrampolineUnchecked'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 40},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(41)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 3395,
                                                                                                                                 "dst_idx": 3434,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_frame.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 296,
                                                                                                                    "startColumn": 27,
                                                                                                                    "endColumn": 28},
                                                                                                         "contextRegion": {"startLine": 296,
                                                                                                                           "snippet": {"text": "    frame->f_executable = Py_NewRef(code);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyFrame_PushTrampolineUnchecked",
                                                                                                          "fullyQualifiedName": "_PyFrame_PushTrampolineUnchecked",
                                                                                                          "decoratedName": "_PyFrame_PushTrampolineUnchecked",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_Py_NewRef' from '_PyFrame_PushTrampolineUnchecked'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 41},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(42)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1050,
                                                                                                                    "startColumn": 25,
                                                                                                                    "endColumn": 35},
                                                                                                         "contextRegion": {"startLine": 1050,
                                                                                                                           "snippet": {"text": "static inline PyObject* _Py_NewRef(PyObject *obj)\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_NewRef",
                                                                                                          "fullyQualifiedName": "_Py_NewRef",
                                                                                                          "decoratedName": "_Py_NewRef",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_Py_NewRef'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 6,
                                                                       "executionOrder": 42},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(43)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1052,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1052,
                                                                                                                           "snippet": {"text": "    Py_INCREF(obj);\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_NewRef",
                                                                                                          "fullyQualifiedName": "_Py_NewRef",
                                                                                                          "decoratedName": "_Py_NewRef",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'Py_INCREF' from '_Py_NewRef'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 6,
                                                                       "executionOrder": 43},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(44)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "_Py_NewRef",
                                                                                                                                     "fullyQualifiedName": "_Py_NewRef",
                                                                                                                                     "decoratedName": "_Py_NewRef",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 6,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3435,
                                                                                                                                 "dst_idx": 3436,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 806,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 806,
                                                                                                                           "snippet": {"text": "    if (new_local == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'new_local != 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 7,
                                                                       "executionOrder": 44},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(45)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 810,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 810,
                                                                                                                           "snippet": {"text": "    if (_Py_IsOwnedByCurrentThread(op)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to '_Py_IsOwnedByCurrentThread' from 'Py_INCREF'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 7,
                                                                       "executionOrder": 45},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(46)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "_Py_NewRef",
                                                                                                                                     "fullyQualifiedName": "_Py_NewRef",
                                                                                                                                     "decoratedName": "_Py_NewRef",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 6,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3435,
                                                                                                                                 "dst_idx": 3436,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 305,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 22},
                                                                                                         "contextRegion": {"startLine": 305,
                                                                                                                           "snippet": {"text": "    return ob->ob_tid == _Py_ThreadId();\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_IsOwnedByCurrentThread",
                                                                                                          "fullyQualifiedName": "_Py_IsOwnedByCurrentThread",
                                                                                                          "decoratedName": "_Py_IsOwnedByCurrentThread",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 8,
                                                                       "executionOrder": 46},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(47)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "_Py_NewRef",
                                                                                                                                     "fullyQualifiedName": "_Py_NewRef",
                                                                                                                                     "decoratedName": "_Py_NewRef",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 6,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3436,
                                                                                                                                 "dst_idx": 3437,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 810,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 810,
                                                                                                                           "snippet": {"text": "    if (_Py_IsOwnedByCurrentThread(op)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 7,
                                                                       "executionOrder": 47},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(48)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 811,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 811,
                                                                                                                           "snippet": {"text": "        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, new_local);\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to '_Py_atomic_store_uint32_relaxed' from 'Py_INCREF'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 7,
                                                                       "executionOrder": 48},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(49)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "_Py_NewRef",
                                                                                                                                     "fullyQualifiedName": "_Py_NewRef",
                                                                                                                                     "decoratedName": "_Py_NewRef",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 6,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3436,
                                                                                                                                 "dst_idx": 3437,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/pyatomic_gcc.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 461,
                                                                                                                    "startColumn": 3,
                                                                                                                    "endColumn": 49},
                                                                                                         "contextRegion": {"startLine": 461,
                                                                                                                           "snippet": {"text": "{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_atomic_store_uint32_relaxed",
                                                                                                          "fullyQualifiedName": "_Py_atomic_store_uint32_relaxed",
                                                                                                          "decoratedName": "_Py_atomic_store_uint32_relaxed",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 8,
                                                                       "executionOrder": 49},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(50)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "_Py_NewRef",
                                                                                                                                     "fullyQualifiedName": "_Py_NewRef",
                                                                                                                                     "decoratedName": "_Py_NewRef",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 6},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/pyatomic_gcc.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 461,
                                                                                                                    "startColumn": 3,
                                                                                                                    "endColumn": 49},
                                                                                                         "contextRegion": {"startLine": 461,
                                                                                                                           "snippet": {"text": "{ __atomic_store_n(obj, value, __ATOMIC_RELAXED); }\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_atomic_store_uint32_relaxed",
                                                                                                          "fullyQualifiedName": "_Py_atomic_store_uint32_relaxed",
                                                                                                          "decoratedName": "_Py_atomic_store_uint32_relaxed",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "write to 'const' object '_Py_InitCleanup' here"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 8,
                                                                       "executionOrder": 50}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 655,
                                                                              "startColumn": 36,
                                                                              "endColumn": 51},
                                                                   "contextRegion": {"startLine": 655,
                                                                                     "snippet": {"text": "extern const struct _PyCode_DEF(8) _Py_InitCleanup;\n"}}},
                                              "message": {"text": "declared here"}}]}]}]}
