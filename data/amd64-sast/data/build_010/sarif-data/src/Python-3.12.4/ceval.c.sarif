{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-null-dereference", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-dereference"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "476", "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}}, "artifacts": [{"location": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "contents": {"text": "/* Execute compiled code */\n\n#define _PY_INTERPRETER\n\n#include \"Python.h\"\n#include \"pycore_abstract.h\"      // _PyIndex_Check()\n#include \"pycore_call.h\"          // _PyObject_FastCallDictTstate()\n#include \"pycore_ceval.h\"         // _PyEval_SignalAsyncExc()\n#include \"pycore_code.h\"\n#include \"pycore_function.h\"\n#include \"pycore_intrinsics.h\"\n#include \"pycore_long.h\"          // _PyLong_GetZero()\n#include \"pycore_instruments.h\"\n#include \"pycore_object.h\"        // _PyObject_GC_TRACK()\n#include \"pycore_moduleobject.h\"  // PyModuleObject\n#include \"pycore_opcode.h\"        // EXTRA_CASES\n#include \"pycore_pyerrors.h\"      // _PyErr_GetRaisedException()\n#include \"pycore_pymem.h\"         // _PyMem_IsPtrFreed()\n#include \"pycore_pystate.h\"       // _PyInterpreterState_GET()\n#include \"pycore_range.h\"         // _PyRangeIterObject\n#include \"pycore_sliceobject.h\"   // _PyBuildSlice_ConsumeRefs\n#include \"pycore_sysmodule.h\"     // _PySys_Audit()\n#include \"pycore_tuple.h\"         // _PyTuple_ITEMS()\n#include \"pycore_typeobject.h\"    // _PySuper_Lookup()\n#include \"pycore_emscripten_signal.h\"  // _Py_CHECK_EMSCRIPTEN_SIGNALS\n\n#include \"pycore_dict.h\"\n#include \"dictobject.h\"\n#include \"pycore_frame.h\"\n#include \"frameobject.h\"          // _PyInterpreterFrame_GetLine\n#include \"opcode.h\"\n#include \"pydtrace.h\"\n#include \"setobject.h\"\n#include \"structmember.h\"         // struct PyMemberDef, T_OFFSET_EX\n\n#include <ctype.h>\n#include <stdbool.h>\n\n#ifdef Py_DEBUG\n   /* For debugging the interpreter: */\n#  define LLTRACE  1      /* Low-level trace feature */\n#endif\n\n#if !defined(Py_BUILD_CORE)\n#  error \"ceval.c must be build with Py_BUILD_CORE define for best performance\"\n#endif\n\n#if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS)\n// GH-89279: The MSVC compiler does not inline these static inline functions\n// in PGO build in _PyEval_EvalFrameDefault(), because this function is over\n// the limit of PGO, and that limit cannot be configured.\n// Define them as macros to make sure that they are always inlined by the\n// preprocessor.\n\n#undef Py_DECREF\n#define Py_DECREF(arg) \\\n    do { \\\n        PyObject *op = _PyObject_CAST(arg); \\\n        if (_Py_IsImmortal(op)) { \\\n            break; \\\n        } \\\n        _Py_DECREF_STAT_INC(); \\\n        if (--op->ob_refcnt == 0) { \\\n            destructor dealloc = Py_TYPE(op)->tp_dealloc; \\\n            (*dealloc)(op); \\\n        } \\\n    } while (0)\n\n#undef Py_XDECREF\n#define Py_XDECREF(arg) \\\n    do { \\\n        PyObject *xop = _PyObject_CAST(arg); \\\n        if (xop != NULL) { \\\n            Py_DECREF(xop); \\\n        } \\\n    } while (0)\n\n#undef Py_IS_TYPE\n#define Py_IS_TYPE(ob, type) \\\n    (_PyObject_CAST(ob)->ob_type == (type))\n\n#undef _Py_DECREF_SPECIALIZED\n#define _Py_DECREF_SPECIALIZED(arg, dealloc) \\\n    do { \\\n        PyObject *op = _PyObject_CAST(arg); \\\n        if (_Py_IsImmortal(op)) { \\\n            break; \\\n        } \\\n        _Py_DECREF_STAT_INC(); \\\n        if (--op->ob_refcnt == 0) { \\\n            destructor d = (destructor)(dealloc); \\\n            d(op); \\\n        } \\\n    } while (0)\n#endif\n\n// GH-89279: Similar to above, force inlining by using a macro.\n#if defined(_MSC_VER) && SIZEOF_INT == 4\n#define _Py_atomic_load_relaxed_int32(ATOMIC_VAL) (assert(sizeof((ATOMIC_VAL)->_value) == 4), *((volatile int*)&((ATOMIC_VAL)->_value)))\n#else\n#define _Py_atomic_load_relaxed_int32(ATOMIC_VAL) _Py_atomic_load_relaxed(ATOMIC_VAL)\n#endif\n\n\n#ifdef LLTRACE\nstatic void\ndump_stack(_PyInterpreterFrame *frame, PyObject **stack_pointer)\n{\n    PyObject **stack_base = _PyFrame_Stackbase(frame);\n    PyObject *exc = PyErr_GetRaisedException();\n    printf(\"    stack=[\");\n    for (PyObject **ptr = stack_base; ptr < stack_pointer; ptr++) {\n        if (ptr != stack_base) {\n            printf(\", \");\n        }\n        if (PyObject_Print(*ptr, stdout, 0) != 0) {\n            PyErr_Clear();\n            printf(\"<%s object at %p>\",\n                   Py_TYPE(*ptr)->tp_name, (void *)(*ptr));\n        }\n    }\n    printf(\"]\\n\");\n    fflush(stdout);\n    PyErr_SetRaisedException(exc);\n}\n\nstatic void\nlltrace_instruction(_PyInterpreterFrame *frame,\n                    PyObject **stack_pointer,\n                    _Py_CODEUNIT *next_instr)\n{\n    /* This dump_stack() operation is risky, since the repr() of some\n       objects enters the interpreter recursively. It is also slow.\n       So you might want to comment it out. */\n    dump_stack(frame, stack_pointer);\n    int oparg = next_instr->op.arg;\n    int opcode = next_instr->op.code;\n    const char *opname = _PyOpcode_OpName[opcode];\n    assert(opname != NULL);\n    int offset = (int)(next_instr - _PyCode_CODE(frame->f_code));\n    if (HAS_ARG((int)_PyOpcode_Deopt[opcode])) {\n        printf(\"%d: %s %d\\n\", offset * 2, opname, oparg);\n    }\n    else {\n        printf(\"%d: %s\\n\", offset * 2, opname);\n    }\n    fflush(stdout);\n}\nstatic void\nlltrace_resume_frame(_PyInterpreterFrame *frame)\n{\n    PyObject *fobj = frame->f_funcobj;\n    if (frame->owner == FRAME_OWNED_BY_CSTACK ||\n        fobj == NULL ||\n        !PyFunction_Check(fobj)\n    ) {\n        printf(\"\\nResuming frame.\\n\");\n        return;\n    }\n    PyFunctionObject *f = (PyFunctionObject *)fobj;\n    PyObject *exc = PyErr_GetRaisedException();\n    PyObject *name = f->func_qualname;\n    if (name == NULL) {\n        name = f->func_name;\n    }\n    printf(\"\\nResuming frame\");\n    if (name) {\n        printf(\" for \");\n        if (PyObject_Print(name, stdout, 0) < 0) {\n            PyErr_Clear();\n        }\n    }\n    if (f->func_module) {\n        printf(\" in module \");\n        if (PyObject_Print(f->func_module, stdout, 0) < 0) {\n            PyErr_Clear();\n        }\n    }\n    printf(\"\\n\");\n    fflush(stdout);\n    PyErr_SetRaisedException(exc);\n}\n#endif\n\nstatic void monitor_raise(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\nstatic void monitor_reraise(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\nstatic int monitor_stop_iteration(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\nstatic void monitor_unwind(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\nstatic int monitor_handled(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr, PyObject *exc);\nstatic void monitor_throw(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\n\nstatic PyObject * import_name(PyThreadState *, _PyInterpreterFrame *,\n                              PyObject *, PyObject *, PyObject *);\nstatic PyObject * import_from(PyThreadState *, PyObject *, PyObject *);\nstatic void format_exc_check_arg(PyThreadState *, PyObject *, const char *, PyObject *);\nstatic void format_exc_unbound(PyThreadState *tstate, PyCodeObject *co, int oparg);\nstatic int check_args_iterable(PyThreadState *, PyObject *func, PyObject *vararg);\nstatic int check_except_type_valid(PyThreadState *tstate, PyObject* right);\nstatic int check_except_star_type_valid(PyThreadState *tstate, PyObject* right);\nstatic void format_kwargs_error(PyThreadState *, PyObject *func, PyObject *kwargs);\nstatic void format_awaitable_error(PyThreadState *, PyTypeObject *, int);\nstatic int get_exception_handler(PyCodeObject *, int, int*, int*, int*);\nstatic _PyInterpreterFrame *\n_PyEvalFramePushAndInit(PyThreadState *tstate, PyFunctionObject *func,\n                        PyObject *locals, PyObject* const* args,\n                        size_t argcount, PyObject *kwnames);\nstatic  _PyInterpreterFrame *\n_PyEvalFramePushAndInit_Ex(PyThreadState *tstate, PyFunctionObject *func,\n    PyObject *locals, Py_ssize_t nargs, PyObject *callargs, PyObject *kwargs);\nstatic void\n_PyEvalFrameClearAndPop(PyThreadState *tstate, _PyInterpreterFrame *frame);\n\n#define UNBOUNDLOCAL_ERROR_MSG \\\n    \"cannot access local variable '%s' where it is not associated with a value\"\n#define UNBOUNDFREE_ERROR_MSG \\\n    \"cannot access free variable '%s' where it is not associated with a\" \\\n    \" value in enclosing scope\"\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n\nint\nPy_GetRecursionLimit(void)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    return interp->ceval.recursion_limit;\n}\n\nvoid\nPy_SetRecursionLimit(int new_limit)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    interp->ceval.recursion_limit = new_limit;\n    for (PyThreadState *p = interp->threads.head; p != NULL; p = p->next) {\n        int depth = p->py_recursion_limit - p->py_recursion_remaining;\n        p->py_recursion_limit = new_limit;\n        p->py_recursion_remaining = new_limit - depth;\n    }\n}\n\n/* The function _Py_EnterRecursiveCallTstate() only calls _Py_CheckRecursiveCall()\n   if the recursion_depth reaches recursion_limit. */\nint\n_Py_CheckRecursiveCall(PyThreadState *tstate, const char *where)\n{\n#ifdef USE_STACKCHECK\n    if (PyOS_CheckStack()) {\n        ++tstate->c_recursion_remaining;\n        _PyErr_SetString(tstate, PyExc_MemoryError, \"Stack overflow\");\n        return -1;\n    }\n#endif\n    if (tstate->recursion_headroom) {\n        if (tstate->c_recursion_remaining < -50) {\n            /* Overflowing while handling an overflow. Give up. */\n            Py_FatalError(\"Cannot recover from stack overflow.\");\n        }\n    }\n    else {\n        if (tstate->c_recursion_remaining <= 0) {\n            tstate->recursion_headroom++;\n            _PyErr_Format(tstate, PyExc_RecursionError,\n                        \"maximum recursion depth exceeded%s\",\n                        where);\n            tstate->recursion_headroom--;\n            ++tstate->c_recursion_remaining;\n            return -1;\n        }\n    }\n    return 0;\n}\n\n\nstatic const binaryfunc binary_ops[] = {\n    [NB_ADD] = PyNumber_Add,\n    [NB_AND] = PyNumber_And,\n    [NB_FLOOR_DIVIDE] = PyNumber_FloorDivide,\n    [NB_LSHIFT] = PyNumber_Lshift,\n    [NB_MATRIX_MULTIPLY] = PyNumber_MatrixMultiply,\n    [NB_MULTIPLY] = PyNumber_Multiply,\n    [NB_REMAINDER] = PyNumber_Remainder,\n    [NB_OR] = PyNumber_Or,\n    [NB_POWER] = _PyNumber_PowerNoMod,\n    [NB_RSHIFT] = PyNumber_Rshift,\n    [NB_SUBTRACT] = PyNumber_Subtract,\n    [NB_TRUE_DIVIDE] = PyNumber_TrueDivide,\n    [NB_XOR] = PyNumber_Xor,\n    [NB_INPLACE_ADD] = PyNumber_InPlaceAdd,\n    [NB_INPLACE_AND] = PyNumber_InPlaceAnd,\n    [NB_INPLACE_FLOOR_DIVIDE] = PyNumber_InPlaceFloorDivide,\n    [NB_INPLACE_LSHIFT] = PyNumber_InPlaceLshift,\n    [NB_INPLACE_MATRIX_MULTIPLY] = PyNumber_InPlaceMatrixMultiply,\n    [NB_INPLACE_MULTIPLY] = PyNumber_InPlaceMultiply,\n    [NB_INPLACE_REMAINDER] = PyNumber_InPlaceRemainder,\n    [NB_INPLACE_OR] = PyNumber_InPlaceOr,\n    [NB_INPLACE_POWER] = _PyNumber_InPlacePowerNoMod,\n    [NB_INPLACE_RSHIFT] = PyNumber_InPlaceRshift,\n    [NB_INPLACE_SUBTRACT] = PyNumber_InPlaceSubtract,\n    [NB_INPLACE_TRUE_DIVIDE] = PyNumber_InPlaceTrueDivide,\n    [NB_INPLACE_XOR] = PyNumber_InPlaceXor,\n};\n\n\n// PEP 634: Structural Pattern Matching\n\n\n// Return a tuple of values corresponding to keys, with error checks for\n// duplicate/missing keys.\nstatic PyObject*\nmatch_keys(PyThreadState *tstate, PyObject *map, PyObject *keys)\n{\n    assert(PyTuple_CheckExact(keys));\n    Py_ssize_t nkeys = PyTuple_GET_SIZE(keys);\n    if (!nkeys) {\n        // No keys means no items.\n        return PyTuple_New(0);\n    }\n    PyObject *seen = NULL;\n    PyObject *dummy = NULL;\n    PyObject *values = NULL;\n    PyObject *get = NULL;\n    // We use the two argument form of map.get(key, default) for two reasons:\n    // - Atomically check for a key and get its value without error handling.\n    // - Don't cause key creation or resizing in dict subclasses like\n    //   collections.defaultdict that define __missing__ (or similar).\n    int meth_found = _PyObject_GetMethod(map, &_Py_ID(get), &get);\n    if (get == NULL) {\n        goto fail;\n    }\n    seen = PySet_New(NULL);\n    if (seen == NULL) {\n        goto fail;\n    }\n    // dummy = object()\n    dummy = _PyObject_CallNoArgs((PyObject *)&PyBaseObject_Type);\n    if (dummy == NULL) {\n        goto fail;\n    }\n    values = PyTuple_New(nkeys);\n    if (values == NULL) {\n        goto fail;\n    }\n    for (Py_ssize_t i = 0; i < nkeys; i++) {\n        PyObject *key = PyTuple_GET_ITEM(keys, i);\n        if (PySet_Contains(seen, key) || PySet_Add(seen, key)) {\n            if (!_PyErr_Occurred(tstate)) {\n                // Seen it before!\n                _PyErr_Format(tstate, PyExc_ValueError,\n                              \"mapping pattern checks duplicate key (%R)\", key);\n            }\n            goto fail;\n        }\n        PyObject *args[] = { map, key, dummy };\n        PyObject *value = NULL;\n        if (meth_found) {\n            value = PyObject_Vectorcall(get, args, 3, NULL);\n        }\n        else {\n            value = PyObject_Vectorcall(get, &args[1], 2, NULL);\n        }\n        if (value == NULL) {\n            goto fail;\n        }\n        if (value == dummy) {\n            // key not in map!\n            Py_DECREF(value);\n            Py_DECREF(values);\n            // Return None:\n            values = Py_NewRef(Py_None);\n            goto done;\n        }\n        PyTuple_SET_ITEM(values, i, value);\n    }\n    // Success:\ndone:\n    Py_DECREF(get);\n    Py_DECREF(seen);\n    Py_DECREF(dummy);\n    return values;\nfail:\n    Py_XDECREF(get);\n    Py_XDECREF(seen);\n    Py_XDECREF(dummy);\n    Py_XDECREF(values);\n    return NULL;\n}\n\n// Extract a named attribute from the subject, with additional bookkeeping to\n// raise TypeErrors for repeated lookups. On failure, return NULL (with no\n// error set). Use _PyErr_Occurred(tstate) to disambiguate.\nstatic PyObject*\nmatch_class_attr(PyThreadState *tstate, PyObject *subject, PyObject *type,\n                 PyObject *name, PyObject *seen)\n{\n    assert(PyUnicode_CheckExact(name));\n    assert(PySet_CheckExact(seen));\n    if (PySet_Contains(seen, name) || PySet_Add(seen, name)) {\n        if (!_PyErr_Occurred(tstate)) {\n            // Seen it before!\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"%s() got multiple sub-patterns for attribute %R\",\n                          ((PyTypeObject*)type)->tp_name, name);\n        }\n        return NULL;\n    }\n    PyObject *attr = PyObject_GetAttr(subject, name);\n    if (attr == NULL && _PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {\n        _PyErr_Clear(tstate);\n    }\n    return attr;\n}\n\n// On success (match), return a tuple of extracted attributes. On failure (no\n// match), return NULL. Use _PyErr_Occurred(tstate) to disambiguate.\nstatic PyObject*\nmatch_class(PyThreadState *tstate, PyObject *subject, PyObject *type,\n            Py_ssize_t nargs, PyObject *kwargs)\n{\n    if (!PyType_Check(type)) {\n        const char *e = \"called match pattern must be a class\";\n        _PyErr_Format(tstate, PyExc_TypeError, e);\n        return NULL;\n    }\n    assert(PyTuple_CheckExact(kwargs));\n    // First, an isinstance check:\n    if (PyObject_IsInstance(subject, type) <= 0) {\n        return NULL;\n    }\n    // So far so good:\n    PyObject *seen = PySet_New(NULL);\n    if (seen == NULL) {\n        return NULL;\n    }\n    PyObject *attrs = PyList_New(0);\n    if (attrs == NULL) {\n        Py_DECREF(seen);\n        return NULL;\n    }\n    // NOTE: From this point on, goto fail on failure:\n    PyObject *match_args = NULL;\n    // First, the positional subpatterns:\n    if (nargs) {\n        int match_self = 0;\n        match_args = PyObject_GetAttrString(type, \"__match_args__\");\n        if (match_args) {\n            if (!PyTuple_CheckExact(match_args)) {\n                const char *e = \"%s.__match_args__ must be a tuple (got %s)\";\n                _PyErr_Format(tstate, PyExc_TypeError, e,\n                              ((PyTypeObject *)type)->tp_name,\n                              Py_TYPE(match_args)->tp_name);\n                goto fail;\n            }\n        }\n        else if (_PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {\n            _PyErr_Clear(tstate);\n            // _Py_TPFLAGS_MATCH_SELF is only acknowledged if the type does not\n            // define __match_args__. This is natural behavior for subclasses:\n            // it's as if __match_args__ is some \"magic\" value that is lost as\n            // soon as they redefine it.\n            match_args = PyTuple_New(0);\n            match_self = PyType_HasFeature((PyTypeObject*)type,\n                                            _Py_TPFLAGS_MATCH_SELF);\n        }\n        else {\n            goto fail;\n        }\n        assert(PyTuple_CheckExact(match_args));\n        Py_ssize_t allowed = match_self ? 1 : PyTuple_GET_SIZE(match_args);\n        if (allowed < nargs) {\n            const char *plural = (allowed == 1) ? \"\" : \"s\";\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"%s() accepts %d positional sub-pattern%s (%d given)\",\n                          ((PyTypeObject*)type)->tp_name,\n                          allowed, plural, nargs);\n            goto fail;\n        }\n        if (match_self) {\n            // Easy. Copy the subject itself, and move on to kwargs.\n            if (PyList_Append(attrs, subject) < 0) {\n                goto fail;\n            }\n        }\n        else {\n            for (Py_ssize_t i = 0; i < nargs; i++) {\n                PyObject *name = PyTuple_GET_ITEM(match_args, i);\n                if (!PyUnicode_CheckExact(name)) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"__match_args__ elements must be strings \"\n                                  \"(got %s)\", Py_TYPE(name)->tp_name);\n                    goto fail;\n                }\n                PyObject *attr = match_class_attr(tstate, subject, type, name,\n                                                  seen);\n                if (attr == NULL) {\n                    goto fail;\n                }\n                if (PyList_Append(attrs, attr) < 0) {\n                    Py_DECREF(attr);\n                    goto fail;\n                }\n                Py_DECREF(attr);\n            }\n        }\n        Py_CLEAR(match_args);\n    }\n    // Finally, the keyword subpatterns:\n    for (Py_ssize_t i = 0; i < PyTuple_GET_SIZE(kwargs); i++) {\n        PyObject *name = PyTuple_GET_ITEM(kwargs, i);\n        PyObject *attr = match_class_attr(tstate, subject, type, name, seen);\n        if (attr == NULL) {\n            goto fail;\n        }\n        if (PyList_Append(attrs, attr) < 0) {\n            Py_DECREF(attr);\n            goto fail;\n        }\n        Py_DECREF(attr);\n    }\n    Py_SETREF(attrs, PyList_AsTuple(attrs));\n    Py_DECREF(seen);\n    return attrs;\nfail:\n    // We really don't care whether an error was raised or not... that's our\n    // caller's problem. All we know is that the match failed.\n    Py_XDECREF(match_args);\n    Py_DECREF(seen);\n    Py_DECREF(attrs);\n    return NULL;\n}\n\n\nstatic int do_raise(PyThreadState *tstate, PyObject *exc, PyObject *cause);\nstatic int exception_group_match(\n    PyObject* exc_value, PyObject *match_type,\n    PyObject **match, PyObject **rest);\n\nstatic int unpack_iterable(PyThreadState *, PyObject *, int, int, PyObject **);\n\nPyObject *\nPyEval_EvalCode(PyObject *co, PyObject *globals, PyObject *locals)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (locals == NULL) {\n        locals = globals;\n    }\n    PyObject *builtins = _PyEval_BuiltinsFromGlobals(tstate, globals); // borrowed ref\n    if (builtins == NULL) {\n        return NULL;\n    }\n    PyFrameConstructor desc = {\n        .fc_globals = globals,\n        .fc_builtins = builtins,\n        .fc_name = ((PyCodeObject *)co)->co_name,\n        .fc_qualname = ((PyCodeObject *)co)->co_name,\n        .fc_code = co,\n        .fc_defaults = NULL,\n        .fc_kwdefaults = NULL,\n        .fc_closure = NULL\n    };\n    PyFunctionObject *func = _PyFunction_FromConstructor(&desc);\n    if (func == NULL) {\n        return NULL;\n    }\n    EVAL_CALL_STAT_INC(EVAL_CALL_LEGACY);\n    PyObject *res = _PyEval_Vector(tstate, func, locals, NULL, 0, NULL);\n    Py_DECREF(func);\n    return res;\n}\n\n\n/* Interpreter main loop */\n\nPyObject *\nPyEval_EvalFrame(PyFrameObject *f)\n{\n    /* Function kept for backward compatibility */\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _PyEval_EvalFrame(tstate, f->f_frame, 0);\n}\n\nPyObject *\nPyEval_EvalFrameEx(PyFrameObject *f, int throwflag)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _PyEval_EvalFrame(tstate, f->f_frame, throwflag);\n}\n\n#include \"ceval_macros.h\"\n\n\nint _Py_CheckRecursiveCallPy(\n    PyThreadState *tstate)\n{\n    if (tstate->recursion_headroom) {\n        if (tstate->py_recursion_remaining < -50) {\n            /* Overflowing while handling an overflow. Give up. */\n            Py_FatalError(\"Cannot recover from Python stack overflow.\");\n        }\n    }\n    else {\n        if (tstate->py_recursion_remaining <= 0) {\n            tstate->recursion_headroom++;\n            _PyErr_Format(tstate, PyExc_RecursionError,\n                        \"maximum recursion depth exceeded\");\n            tstate->recursion_headroom--;\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic inline int _Py_EnterRecursivePy(PyThreadState *tstate) {\n    return (tstate->py_recursion_remaining-- <= 0) &&\n        _Py_CheckRecursiveCallPy(tstate);\n}\n\n\nstatic inline void _Py_LeaveRecursiveCallPy(PyThreadState *tstate)  {\n    tstate->py_recursion_remaining++;\n}\n\n\n/* Disable unused label warnings.  They are handy for debugging, even\n   if computed gotos aren't used. */\n\n/* TBD - what about other compilers? */\n#if defined(__GNUC__)\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wunused-label\"\n#elif defined(_MSC_VER) /* MS_WINDOWS */\n#  pragma warning(push)\n#  pragma warning(disable:4102)\n#endif\n\n\n/* _PyEval_EvalFrameDefault() is a *big* function,\n * so consume 3 units of C stack */\n#define PY_EVAL_C_STACK_UNITS 2\n\nPyObject* _Py_HOT_FUNCTION\n_PyEval_EvalFrameDefault(PyThreadState *tstate, _PyInterpreterFrame *frame, int throwflag)\n{\n    _Py_EnsureTstateNotNULL(tstate);\n    CALL_STAT_INC(pyeval_calls);\n\n#if USE_COMPUTED_GOTOS\n/* Import the static jump table */\n#include \"opcode_targets.h\"\n#endif\n\n#ifdef Py_STATS\n    int lastopcode = 0;\n#endif\n    // opcode is an 8-bit value to improve the code generated by MSVC\n    // for the big switch below (in combination with the EXTRA_CASES macro).\n    uint8_t opcode;        /* Current opcode */\n    int oparg;         /* Current opcode argument, if any */\n#ifdef LLTRACE\n    int lltrace = 0;\n#endif\n\n    _PyCFrame cframe;\n    _PyInterpreterFrame  entry_frame;\n    PyObject *kwnames = NULL; // Borrowed reference. Reset by CALL instructions.\n\n    /* WARNING: Because the _PyCFrame lives on the C stack,\n     * but can be accessed from a heap allocated object (tstate)\n     * strict stack discipline must be maintained.\n     */\n    _PyCFrame *prev_cframe = tstate->cframe;\n    cframe.previous = prev_cframe;\n    tstate->cframe = &cframe;\n\n    assert(tstate->interp->interpreter_trampoline != NULL);\n#ifdef Py_DEBUG\n    /* Set these to invalid but identifiable values for debugging. */\n    entry_frame.f_funcobj = (PyObject*)0xaaa0;\n    entry_frame.f_locals = (PyObject*)0xaaa1;\n    entry_frame.frame_obj = (PyFrameObject*)0xaaa2;\n    entry_frame.f_globals = (PyObject*)0xaaa3;\n    entry_frame.f_builtins = (PyObject*)0xaaa4;\n#endif\n    entry_frame.f_code = tstate->interp->interpreter_trampoline;\n    entry_frame.prev_instr =\n        _PyCode_CODE(tstate->interp->interpreter_trampoline);\n    entry_frame.stacktop = 0;\n    entry_frame.owner = FRAME_OWNED_BY_CSTACK;\n    entry_frame.return_offset = 0;\n    /* Push frame */\n    entry_frame.previous = prev_cframe->current_frame;\n    frame->previous = &entry_frame;\n    cframe.current_frame = frame;\n\n    tstate->c_recursion_remaining -= (PY_EVAL_C_STACK_UNITS - 1);\n    if (_Py_EnterRecursiveCallTstate(tstate, \"\")) {\n        tstate->c_recursion_remaining--;\n        tstate->py_recursion_remaining--;\n        goto exit_unwind;\n    }\n\n    /* support for generator.throw() */\n    if (throwflag) {\n        if (_Py_EnterRecursivePy(tstate)) {\n            goto exit_unwind;\n        }\n        /* Because this avoids the RESUME,\n         * we need to update instrumentation */\n        _Py_Instrument(frame->f_code, tstate->interp);\n        monitor_throw(tstate, frame, frame->prev_instr);\n        /* TO DO -- Monitor throw entry. */\n        goto resume_with_error;\n    }\n\n    /* Local \"register\" variables.\n     * These are cached values from the frame and code object.  */\n\n    _Py_CODEUNIT *next_instr;\n    PyObject **stack_pointer;\n\n/* Sets the above local variables from the frame */\n#define SET_LOCALS_FROM_FRAME() \\\n    assert(_PyInterpreterFrame_LASTI(frame) >= -1); \\\n    /* Jump back to the last instruction executed... */ \\\n    next_instr = frame->prev_instr + 1; \\\n    stack_pointer = _PyFrame_GetStackPointer(frame);\n\nstart_frame:\n    if (_Py_EnterRecursivePy(tstate)) {\n        goto exit_unwind;\n    }\n\nresume_frame:\n    SET_LOCALS_FROM_FRAME();\n\n#ifdef LLTRACE\n    {\n        if (frame != &entry_frame) {\n            int r = PyDict_Contains(GLOBALS(), &_Py_ID(__lltrace__));\n            if (r < 0) {\n                goto exit_unwind;\n            }\n            lltrace = r;\n        }\n        if (lltrace) {\n            lltrace_resume_frame(frame);\n        }\n    }\n#endif\n\n#ifdef Py_DEBUG\n    /* _PyEval_EvalFrameDefault() must not be called with an exception set,\n       because it can clear it (directly or indirectly) and so the\n       caller loses its exception */\n    assert(!_PyErr_Occurred(tstate));\n#endif\n\n    DISPATCH();\n\nhandle_eval_breaker:\n\n    /* Do periodic things, like check for signals and async I/0.\n     * We need to do reasonably frequently, but not too frequently.\n     * All loops should include a check of the eval breaker.\n     * We also check on return from any builtin function.\n     *\n     * ## More Details ###\n     *\n     * The eval loop (this function) normally executes the instructions\n     * of a code object sequentially.  However, the runtime supports a\n     * number of out-of-band execution scenarios that may pause that\n     * sequential execution long enough to do that out-of-band work\n     * in the current thread using the current PyThreadState.\n     *\n     * The scenarios include:\n     *\n     *  - cyclic garbage collection\n     *  - GIL drop requests\n     *  - \"async\" exceptions\n     *  - \"pending calls\"  (some only in the main thread)\n     *  - signal handling (only in the main thread)\n     *\n     * When the need for one of the above is detected, the eval loop\n     * pauses long enough to handle the detected case.  Then, if doing\n     * so didn't trigger an exception, the eval loop resumes executing\n     * the sequential instructions.\n     *\n     * To make this work, the eval loop periodically checks if any\n     * of the above needs to happen.  The individual checks can be\n     * expensive if computed each time, so a while back we switched\n     * to using pre-computed, per-interpreter variables for the checks,\n     * and later consolidated that to a single \"eval breaker\" variable\n     * (now a PyInterpreterState field).\n     *\n     * For the longest time, the eval breaker check would happen\n     * frequently, every 5 or so times through the loop, regardless\n     * of what instruction ran last or what would run next.  Then, in\n     * early 2021 (gh-18334, commit 4958f5d), we switched to checking\n     * the eval breaker less frequently, by hard-coding the check to\n     * specific places in the eval loop (e.g. certain instructions).\n     * The intent then was to check after returning from calls\n     * and on the back edges of loops.\n     *\n     * In addition to being more efficient, that approach keeps\n     * the eval loop from running arbitrary code between instructions\n     * that don't handle that well.  (See gh-74174.)\n     *\n     * Currently, the eval breaker check happens here at the\n     * \"handle_eval_breaker\" label.  Some instructions come here\n     * explicitly (goto) and some indirectly.  Notably, the check\n     * happens on back edges in the control flow graph, which\n     * pretty much applies to all loops and most calls.\n     * (See bytecodes.c for exact information.)\n     *\n     * One consequence of this approach is that it might not be obvious\n     * how to force any specific thread to pick up the eval breaker,\n     * or for any specific thread to not pick it up.  Mostly this\n     * involves judicious uses of locks and careful ordering of code,\n     * while avoiding code that might trigger the eval breaker\n     * until so desired.\n     */\n    if (_Py_HandlePending(tstate) != 0) {\n        goto error;\n    }\n    DISPATCH();\n\n    {\n    /* Start instructions */\n#if !USE_COMPUTED_GOTOS\n    dispatch_opcode:\n        switch (opcode)\n#endif\n        {\n\n#include \"generated_cases.c.h\"\n\n    /* INSTRUMENTED_LINE has to be here, rather than in bytecodes.c,\n     * because it needs to capture frame->prev_instr before it is updated,\n     * as happens in the standard instruction prologue.\n     */\n#if USE_COMPUTED_GOTOS\n        TARGET_INSTRUMENTED_LINE:\n#else\n        case INSTRUMENTED_LINE:\n#endif\n    {\n        _Py_CODEUNIT *prev = frame->prev_instr;\n        _Py_CODEUNIT *here = frame->prev_instr = next_instr;\n        _PyFrame_SetStackPointer(frame, stack_pointer);\n        int original_opcode = _Py_call_instrumentation_line(\n                tstate, frame, here, prev);\n        stack_pointer = _PyFrame_GetStackPointer(frame);\n        if (original_opcode < 0) {\n            next_instr = here+1;\n            goto error;\n        }\n        next_instr = frame->prev_instr;\n        if (next_instr != here) {\n            DISPATCH();\n        }\n        if (_PyOpcode_Caches[original_opcode]) {\n            _PyBinaryOpCache *cache = (_PyBinaryOpCache *)(next_instr+1);\n            /* Prevent the underlying instruction from specializing\n             * and overwriting the instrumentation. */\n            INCREMENT_ADAPTIVE_COUNTER(cache->counter);\n        }\n        opcode = original_opcode;\n        DISPATCH_GOTO();\n    }\n\n\n#if USE_COMPUTED_GOTOS\n        _unknown_opcode:\n#else\n        EXTRA_CASES  // From opcode.h, a 'case' for each unused opcode\n#endif\n            /* Tell C compilers not to hold the opcode variable in the loop.\n               next_instr points the current instruction without TARGET(). */\n            opcode = next_instr->op.code;\n            _PyErr_Format(tstate, PyExc_SystemError,\n                          \"%U:%d: unknown opcode %d\",\n                          frame->f_code->co_filename,\n                          PyUnstable_InterpreterFrame_GetLine(frame),\n                          opcode);\n            goto error;\n\n        } /* End instructions */\n\n        /* This should never be reached. Every opcode should end with DISPATCH()\n           or goto error. */\n        Py_UNREACHABLE();\n\nunbound_local_error:\n        {\n            format_exc_check_arg(tstate, PyExc_UnboundLocalError,\n                UNBOUNDLOCAL_ERROR_MSG,\n                PyTuple_GetItem(frame->f_code->co_localsplusnames, oparg)\n            );\n            goto error;\n        }\n\npop_4_error:\n    STACK_SHRINK(1);\npop_3_error:\n    STACK_SHRINK(1);\npop_2_error:\n    STACK_SHRINK(1);\npop_1_error:\n    STACK_SHRINK(1);\nerror:\n        kwnames = NULL;\n        /* Double-check exception status. */\n#ifdef NDEBUG\n        if (!_PyErr_Occurred(tstate)) {\n            _PyErr_SetString(tstate, PyExc_SystemError,\n                             \"error return without exception set\");\n        }\n#else\n        assert(_PyErr_Occurred(tstate));\n#endif\n\n        /* Log traceback info. */\n        assert(frame != &entry_frame);\n        if (!_PyFrame_IsIncomplete(frame)) {\n            PyFrameObject *f = _PyFrame_GetFrameObject(frame);\n            if (f != NULL) {\n                PyTraceBack_Here(f);\n            }\n        }\n        monitor_raise(tstate, frame, next_instr-1);\nexception_unwind:\n        {\n            /* We can't use frame->f_lasti here, as RERAISE may have set it */\n            int offset = INSTR_OFFSET()-1;\n            int level, handler, lasti;\n            if (get_exception_handler(frame->f_code, offset, &level, &handler, &lasti) == 0) {\n                // No handlers, so exit.\n                assert(_PyErr_Occurred(tstate));\n\n                /* Pop remaining stack entries. */\n                PyObject **stackbase = _PyFrame_Stackbase(frame);\n                while (stack_pointer > stackbase) {\n                    PyObject *o = POP();\n                    Py_XDECREF(o);\n                }\n                assert(STACK_LEVEL() == 0);\n                _PyFrame_SetStackPointer(frame, stack_pointer);\n                monitor_unwind(tstate, frame, next_instr-1);\n                goto exit_unwind;\n            }\n\n            assert(STACK_LEVEL() >= level);\n            PyObject **new_top = _PyFrame_Stackbase(frame) + level;\n            while (stack_pointer > new_top) {\n                PyObject *v = POP();\n                Py_XDECREF(v);\n            }\n            if (lasti) {\n                int frame_lasti = _PyInterpreterFrame_LASTI(frame);\n                PyObject *lasti = PyLong_FromLong(frame_lasti);\n                if (lasti == NULL) {\n                    goto exception_unwind;\n                }\n                PUSH(lasti);\n            }\n\n            /* Make the raw exception data\n                available to the handler,\n                so a program can emulate the\n                Python main loop. */\n            PyObject *exc = _PyErr_GetRaisedException(tstate);\n            PUSH(exc);\n            JUMPTO(handler);\n            if (monitor_handled(tstate, frame, next_instr, exc) < 0) {\n                goto exception_unwind;\n            }\n            /* Resume normal execution */\n            DISPATCH();\n        }\n    }\n\nexit_unwind:\n    assert(_PyErr_Occurred(tstate));\n    _Py_LeaveRecursiveCallPy(tstate);\n    assert(frame != &entry_frame);\n    // GH-99729: We need to unlink the frame *before* clearing it:\n    _PyInterpreterFrame *dying = frame;\n    frame = cframe.current_frame = dying->previous;\n    _PyEvalFrameClearAndPop(tstate, dying);\n    frame->return_offset = 0;\n    if (frame == &entry_frame) {\n        /* Restore previous cframe and exit */\n        tstate->cframe = cframe.previous;\n        assert(tstate->cframe->current_frame == frame->previous);\n        tstate->c_recursion_remaining += PY_EVAL_C_STACK_UNITS;\n        return NULL;\n    }\n\nresume_with_error:\n    SET_LOCALS_FROM_FRAME();\n    goto error;\n\n}\n#if defined(__GNUC__)\n#  pragma GCC diagnostic pop\n#elif defined(_MSC_VER) /* MS_WINDOWS */\n#  pragma warning(pop)\n#endif\n\nstatic void\nformat_missing(PyThreadState *tstate, const char *kind,\n               PyCodeObject *co, PyObject *names, PyObject *qualname)\n{\n    int err;\n    Py_ssize_t len = PyList_GET_SIZE(names);\n    PyObject *name_str, *comma, *tail, *tmp;\n\n    assert(PyList_CheckExact(names));\n    assert(len >= 1);\n    /* Deal with the joys of natural language. */\n    switch (len) {\n    case 1:\n        name_str = PyList_GET_ITEM(names, 0);\n        Py_INCREF(name_str);\n        break;\n    case 2:\n        name_str = PyUnicode_FromFormat(\"%U and %U\",\n                                        PyList_GET_ITEM(names, len - 2),\n                                        PyList_GET_ITEM(names, len - 1));\n        break;\n    default:\n        tail = PyUnicode_FromFormat(\", %U, and %U\",\n                                    PyList_GET_ITEM(names, len - 2),\n                                    PyList_GET_ITEM(names, len - 1));\n        if (tail == NULL)\n            return;\n        /* Chop off the last two objects in the list. This shouldn't actually\n           fail, but we can't be too careful. */\n        err = PyList_SetSlice(names, len - 2, len, NULL);\n        if (err == -1) {\n            Py_DECREF(tail);\n            return;\n        }\n        /* Stitch everything up into a nice comma-separated list. */\n        comma = PyUnicode_FromString(\", \");\n        if (comma == NULL) {\n            Py_DECREF(tail);\n            return;\n        }\n        tmp = PyUnicode_Join(comma, names);\n        Py_DECREF(comma);\n        if (tmp == NULL) {\n            Py_DECREF(tail);\n            return;\n        }\n        name_str = PyUnicode_Concat(tmp, tail);\n        Py_DECREF(tmp);\n        Py_DECREF(tail);\n        break;\n    }\n    if (name_str == NULL)\n        return;\n    _PyErr_Format(tstate, PyExc_TypeError,\n                  \"%U() missing %i required %s argument%s: %U\",\n                  qualname,\n                  len,\n                  kind,\n                  len == 1 ? \"\" : \"s\",\n                  name_str);\n    Py_DECREF(name_str);\n}\n\nstatic void\nmissing_arguments(PyThreadState *tstate, PyCodeObject *co,\n                  Py_ssize_t missing, Py_ssize_t defcount,\n                  PyObject **localsplus, PyObject *qualname)\n{\n    Py_ssize_t i, j = 0;\n    Py_ssize_t start, end;\n    int positional = (defcount != -1);\n    const char *kind = positional ? \"positional\" : \"keyword-only\";\n    PyObject *missing_names;\n\n    /* Compute the names of the arguments that are missing. */\n    missing_names = PyList_New(missing);\n    if (missing_names == NULL)\n        return;\n    if (positional) {\n        start = 0;\n        end = co->co_argcount - defcount;\n    }\n    else {\n        start = co->co_argcount;\n        end = start + co->co_kwonlyargcount;\n    }\n    for (i = start; i < end; i++) {\n        if (localsplus[i] == NULL) {\n            PyObject *raw = PyTuple_GET_ITEM(co->co_localsplusnames, i);\n            PyObject *name = PyObject_Repr(raw);\n            if (name == NULL) {\n                Py_DECREF(missing_names);\n                return;\n            }\n            PyList_SET_ITEM(missing_names, j++, name);\n        }\n    }\n    assert(j == missing);\n    format_missing(tstate, kind, co, missing_names, qualname);\n    Py_DECREF(missing_names);\n}\n\nstatic void\ntoo_many_positional(PyThreadState *tstate, PyCodeObject *co,\n                    Py_ssize_t given, PyObject *defaults,\n                    PyObject **localsplus, PyObject *qualname)\n{\n    int plural;\n    Py_ssize_t kwonly_given = 0;\n    Py_ssize_t i;\n    PyObject *sig, *kwonly_sig;\n    Py_ssize_t co_argcount = co->co_argcount;\n\n    assert((co->co_flags & CO_VARARGS) == 0);\n    /* Count missing keyword-only args. */\n    for (i = co_argcount; i < co_argcount + co->co_kwonlyargcount; i++) {\n        if (localsplus[i] != NULL) {\n            kwonly_given++;\n        }\n    }\n    Py_ssize_t defcount = defaults == NULL ? 0 : PyTuple_GET_SIZE(defaults);\n    if (defcount) {\n        Py_ssize_t atleast = co_argcount - defcount;\n        plural = 1;\n        sig = PyUnicode_FromFormat(\"from %zd to %zd\", atleast, co_argcount);\n    }\n    else {\n        plural = (co_argcount != 1);\n        sig = PyUnicode_FromFormat(\"%zd\", co_argcount);\n    }\n    if (sig == NULL)\n        return;\n    if (kwonly_given) {\n        const char *format = \" positional argument%s (and %zd keyword-only argument%s)\";\n        kwonly_sig = PyUnicode_FromFormat(format,\n                                          given != 1 ? \"s\" : \"\",\n                                          kwonly_given,\n                                          kwonly_given != 1 ? \"s\" : \"\");\n        if (kwonly_sig == NULL) {\n            Py_DECREF(sig);\n            return;\n        }\n    }\n    else {\n        /* This will not fail. */\n        kwonly_sig = PyUnicode_FromString(\"\");\n        assert(kwonly_sig != NULL);\n    }\n    _PyErr_Format(tstate, PyExc_TypeError,\n                  \"%U() takes %U positional argument%s but %zd%U %s given\",\n                  qualname,\n                  sig,\n                  plural ? \"s\" : \"\",\n                  given,\n                  kwonly_sig,\n                  given == 1 && !kwonly_given ? \"was\" : \"were\");\n    Py_DECREF(sig);\n    Py_DECREF(kwonly_sig);\n}\n\nstatic int\npositional_only_passed_as_keyword(PyThreadState *tstate, PyCodeObject *co,\n                                  Py_ssize_t kwcount, PyObject* kwnames,\n                                  PyObject *qualname)\n{\n    int posonly_conflicts = 0;\n    PyObject* posonly_names = PyList_New(0);\n    if (posonly_names == NULL) {\n        goto fail;\n    }\n    for(int k=0; k < co->co_posonlyargcount; k++){\n        PyObject* posonly_name = PyTuple_GET_ITEM(co->co_localsplusnames, k);\n\n        for (int k2=0; k2<kwcount; k2++){\n            /* Compare the pointers first and fallback to PyObject_RichCompareBool*/\n            PyObject* kwname = PyTuple_GET_ITEM(kwnames, k2);\n            if (kwname == posonly_name){\n                if(PyList_Append(posonly_names, kwname) != 0) {\n                    goto fail;\n                }\n                posonly_conflicts++;\n                continue;\n            }\n\n            int cmp = PyObject_RichCompareBool(posonly_name, kwname, Py_EQ);\n\n            if ( cmp > 0) {\n                if(PyList_Append(posonly_names, kwname) != 0) {\n                    goto fail;\n                }\n                posonly_conflicts++;\n            } else if (cmp < 0) {\n                goto fail;\n            }\n\n        }\n    }\n    if (posonly_conflicts) {\n        PyObject* comma = PyUnicode_FromString(\", \");\n        if (comma == NULL) {\n            goto fail;\n        }\n        PyObject* error_names = PyUnicode_Join(comma, posonly_names);\n        Py_DECREF(comma);\n        if (error_names == NULL) {\n            goto fail;\n        }\n        _PyErr_Format(tstate, PyExc_TypeError,\n                      \"%U() got some positional-only arguments passed\"\n                      \" as keyword arguments: '%U'\",\n                      qualname, error_names);\n        Py_DECREF(error_names);\n        goto fail;\n    }\n\n    Py_DECREF(posonly_names);\n    return 0;\n\nfail:\n    Py_XDECREF(posonly_names);\n    return 1;\n\n}\n\n\nstatic inline unsigned char *\nscan_back_to_entry_start(unsigned char *p) {\n    for (; (p[0]&128) == 0; p--);\n    return p;\n}\n\nstatic inline unsigned char *\nskip_to_next_entry(unsigned char *p, unsigned char *end) {\n    while (p < end && ((p[0] & 128) == 0)) {\n        p++;\n    }\n    return p;\n}\n\n\n#define MAX_LINEAR_SEARCH 40\n\nstatic int\nget_exception_handler(PyCodeObject *code, int index, int *level, int *handler, int *lasti)\n{\n    unsigned char *start = (unsigned char *)PyBytes_AS_STRING(code->co_exceptiontable);\n    unsigned char *end = start + PyBytes_GET_SIZE(code->co_exceptiontable);\n    /* Invariants:\n     * start_table == end_table OR\n     * start_table points to a legal entry and end_table points\n     * beyond the table or to a legal entry that is after index.\n     */\n    if (end - start > MAX_LINEAR_SEARCH) {\n        int offset;\n        parse_varint(start, &offset);\n        if (offset > index) {\n            return 0;\n        }\n        do {\n            unsigned char * mid = start + ((end-start)>>1);\n            mid = scan_back_to_entry_start(mid);\n            parse_varint(mid, &offset);\n            if (offset > index) {\n                end = mid;\n            }\n            else {\n                start = mid;\n            }\n\n        } while (end - start > MAX_LINEAR_SEARCH);\n    }\n    unsigned char *scan = start;\n    while (scan < end) {\n        int start_offset, size;\n        scan = parse_varint(scan, &start_offset);\n        if (start_offset > index) {\n            break;\n        }\n        scan = parse_varint(scan, &size);\n        if (start_offset + size > index) {\n            scan = parse_varint(scan, handler);\n            int depth_and_lasti;\n            parse_varint(scan, &depth_and_lasti);\n            *level = depth_and_lasti >> 1;\n            *lasti = depth_and_lasti & 1;\n            return 1;\n        }\n        scan = skip_to_next_entry(scan, end);\n    }\n    return 0;\n}\n\nstatic int\ninitialize_locals(PyThreadState *tstate, PyFunctionObject *func,\n    PyObject **localsplus, PyObject *const *args,\n    Py_ssize_t argcount, PyObject *kwnames)\n{\n    PyCodeObject *co = (PyCodeObject*)func->func_code;\n    const Py_ssize_t total_args = co->co_argcount + co->co_kwonlyargcount;\n\n    /* Create a dictionary for keyword parameters (**kwags) */\n    PyObject *kwdict;\n    Py_ssize_t i;\n    if (co->co_flags & CO_VARKEYWORDS) {\n        kwdict = PyDict_New();\n        if (kwdict == NULL) {\n            goto fail_pre_positional;\n        }\n        i = total_args;\n        if (co->co_flags & CO_VARARGS) {\n            i++;\n        }\n        assert(localsplus[i] == NULL);\n        localsplus[i] = kwdict;\n    }\n    else {\n        kwdict = NULL;\n    }\n\n    /* Copy all positional arguments into local variables */\n    Py_ssize_t j, n;\n    if (argcount > co->co_argcount) {\n        n = co->co_argcount;\n    }\n    else {\n        n = argcount;\n    }\n    for (j = 0; j < n; j++) {\n        PyObject *x = args[j];\n        assert(localsplus[j] == NULL);\n        localsplus[j] = x;\n    }\n\n    /* Pack other positional arguments into the *args argument */\n    if (co->co_flags & CO_VARARGS) {\n        PyObject *u = NULL;\n        if (argcount == n) {\n            u = Py_NewRef(&_Py_SINGLETON(tuple_empty));\n        }\n        else {\n            assert(args != NULL);\n            u = _PyTuple_FromArraySteal(args + n, argcount - n);\n        }\n        if (u == NULL) {\n            goto fail_post_positional;\n        }\n        assert(localsplus[total_args] == NULL);\n        localsplus[total_args] = u;\n    }\n    else if (argcount > n) {\n        /* Too many postional args. Error is reported later */\n        for (j = n; j < argcount; j++) {\n            Py_DECREF(args[j]);\n        }\n    }\n\n    /* Handle keyword arguments */\n    if (kwnames != NULL) {\n        Py_ssize_t kwcount = PyTuple_GET_SIZE(kwnames);\n        for (i = 0; i < kwcount; i++) {\n            PyObject **co_varnames;\n            PyObject *keyword = PyTuple_GET_ITEM(kwnames, i);\n            PyObject *value = args[i+argcount];\n            Py_ssize_t j;\n\n            if (keyword == NULL || !PyUnicode_Check(keyword)) {\n                _PyErr_Format(tstate, PyExc_TypeError,\n                            \"%U() keywords must be strings\",\n                          func->func_qualname);\n                goto kw_fail;\n            }\n\n            /* Speed hack: do raw pointer compares. As names are\n            normally interned this should almost always hit. */\n            co_varnames = ((PyTupleObject *)(co->co_localsplusnames))->ob_item;\n            for (j = co->co_posonlyargcount; j < total_args; j++) {\n                PyObject *varname = co_varnames[j];\n                if (varname == keyword) {\n                    goto kw_found;\n                }\n            }\n\n            /* Slow fallback, just in case */\n            for (j = co->co_posonlyargcount; j < total_args; j++) {\n                PyObject *varname = co_varnames[j];\n                int cmp = PyObject_RichCompareBool( keyword, varname, Py_EQ);\n                if (cmp > 0) {\n                    goto kw_found;\n                }\n                else if (cmp < 0) {\n                    goto kw_fail;\n                }\n            }\n\n            assert(j >= total_args);\n            if (kwdict == NULL) {\n\n                if (co->co_posonlyargcount\n                    && positional_only_passed_as_keyword(tstate, co,\n                                                        kwcount, kwnames,\n                                                        func->func_qualname))\n                {\n                    goto kw_fail;\n                }\n\n                _PyErr_Format(tstate, PyExc_TypeError,\n                            \"%U() got an unexpected keyword argument '%S'\",\n                          func->func_qualname, keyword);\n                goto kw_fail;\n            }\n\n            if (PyDict_SetItem(kwdict, keyword, value) == -1) {\n                goto kw_fail;\n            }\n            Py_DECREF(value);\n            continue;\n\n        kw_fail:\n            for (;i < kwcount; i++) {\n                PyObject *value = args[i+argcount];\n                Py_DECREF(value);\n            }\n            goto fail_post_args;\n\n        kw_found:\n            if (localsplus[j] != NULL) {\n                _PyErr_Format(tstate, PyExc_TypeError,\n                            \"%U() got multiple values for argument '%S'\",\n                          func->func_qualname, keyword);\n                goto kw_fail;\n            }\n            localsplus[j] = value;\n        }\n    }\n\n    /* Check the number of positional arguments */\n    if ((argcount > co->co_argcount) && !(co->co_flags & CO_VARARGS)) {\n        too_many_positional(tstate, co, argcount, func->func_defaults, localsplus,\n                            func->func_qualname);\n        goto fail_post_args;\n    }\n\n    /* Add missing positional arguments (copy default values from defs) */\n    if (argcount < co->co_argcount) {\n        Py_ssize_t defcount = func->func_defaults == NULL ? 0 : PyTuple_GET_SIZE(func->func_defaults);\n        Py_ssize_t m = co->co_argcount - defcount;\n        Py_ssize_t missing = 0;\n        for (i = argcount; i < m; i++) {\n            if (localsplus[i] == NULL) {\n                missing++;\n            }\n        }\n        if (missing) {\n            missing_arguments(tstate, co, missing, defcount, localsplus,\n                              func->func_qualname);\n            goto fail_post_args;\n        }\n        if (n > m)\n            i = n - m;\n        else\n            i = 0;\n        if (defcount) {\n            PyObject **defs = &PyTuple_GET_ITEM(func->func_defaults, 0);\n            for (; i < defcount; i++) {\n                if (localsplus[m+i] == NULL) {\n                    PyObject *def = defs[i];\n                    localsplus[m+i] = Py_NewRef(def);\n                }\n            }\n        }\n    }\n\n    /* Add missing keyword arguments (copy default values from kwdefs) */\n    if (co->co_kwonlyargcount > 0) {\n        Py_ssize_t missing = 0;\n        for (i = co->co_argcount; i < total_args; i++) {\n            if (localsplus[i] != NULL)\n                continue;\n            PyObject *varname = PyTuple_GET_ITEM(co->co_localsplusnames, i);\n            if (func->func_kwdefaults != NULL) {\n                PyObject *def = PyDict_GetItemWithError(func->func_kwdefaults, varname);\n                if (def) {\n                    localsplus[i] = Py_NewRef(def);\n                    continue;\n                }\n                else if (_PyErr_Occurred(tstate)) {\n                    goto fail_post_args;\n                }\n            }\n            missing++;\n        }\n        if (missing) {\n            missing_arguments(tstate, co, missing, -1, localsplus,\n                              func->func_qualname);\n            goto fail_post_args;\n        }\n    }\n    return 0;\n\nfail_pre_positional:\n    for (j = 0; j < argcount; j++) {\n        Py_DECREF(args[j]);\n    }\n    /* fall through */\nfail_post_positional:\n    if (kwnames) {\n        Py_ssize_t kwcount = PyTuple_GET_SIZE(kwnames);\n        for (j = argcount; j < argcount+kwcount; j++) {\n            Py_DECREF(args[j]);\n        }\n    }\n    /* fall through */\nfail_post_args:\n    return -1;\n}\n\nstatic void\nclear_thread_frame(PyThreadState *tstate, _PyInterpreterFrame * frame)\n{\n    assert(frame->owner == FRAME_OWNED_BY_THREAD);\n    // Make sure that this is, indeed, the top frame. We can't check this in\n    // _PyThreadState_PopFrame, since f_code is already cleared at that point:\n    assert((PyObject **)frame + frame->f_code->co_framesize ==\n        tstate->datastack_top);\n    tstate->c_recursion_remaining--;\n    assert(frame->frame_obj == NULL || frame->frame_obj->f_frame == frame);\n    _PyFrame_ClearExceptCode(frame);\n    Py_DECREF(frame->f_code);\n    tstate->c_recursion_remaining++;\n    _PyThreadState_PopFrame(tstate, frame);\n}\n\nstatic void\nclear_gen_frame(PyThreadState *tstate, _PyInterpreterFrame * frame)\n{\n    assert(frame->owner == FRAME_OWNED_BY_GENERATOR);\n    PyGenObject *gen = _PyFrame_GetGenerator(frame);\n    gen->gi_frame_state = FRAME_CLEARED;\n    assert(tstate->exc_info == &gen->gi_exc_state);\n    tstate->exc_info = gen->gi_exc_state.previous_item;\n    gen->gi_exc_state.previous_item = NULL;\n    tstate->c_recursion_remaining--;\n    assert(frame->frame_obj == NULL || frame->frame_obj->f_frame == frame);\n    _PyFrame_ClearExceptCode(frame);\n    tstate->c_recursion_remaining++;\n    frame->previous = NULL;\n}\n\nstatic void\n_PyEvalFrameClearAndPop(PyThreadState *tstate, _PyInterpreterFrame * frame)\n{\n    if (frame->owner == FRAME_OWNED_BY_THREAD) {\n        clear_thread_frame(tstate, frame);\n    }\n    else {\n        clear_gen_frame(tstate, frame);\n    }\n}\n\n/* Consumes references to func, locals and all the args */\nstatic _PyInterpreterFrame *\n_PyEvalFramePushAndInit(PyThreadState *tstate, PyFunctionObject *func,\n                        PyObject *locals, PyObject* const* args,\n                        size_t argcount, PyObject *kwnames)\n{\n    PyCodeObject * code = (PyCodeObject *)func->func_code;\n    CALL_STAT_INC(frames_pushed);\n    _PyInterpreterFrame *frame = _PyThreadState_PushFrame(tstate, code->co_framesize);\n    if (frame == NULL) {\n        goto fail;\n    }\n    _PyFrame_Initialize(frame, func, locals, code, 0);\n    if (initialize_locals(tstate, func, frame->localsplus, args, argcount, kwnames)) {\n        assert(frame->owner == FRAME_OWNED_BY_THREAD);\n        clear_thread_frame(tstate, frame);\n        return NULL;\n    }\n    return frame;\nfail:\n    /* Consume the references */\n    for (size_t i = 0; i < argcount; i++) {\n        Py_DECREF(args[i]);\n    }\n    if (kwnames) {\n        Py_ssize_t kwcount = PyTuple_GET_SIZE(kwnames);\n        for (Py_ssize_t i = 0; i < kwcount; i++) {\n            Py_DECREF(args[i+argcount]);\n        }\n    }\n    PyErr_NoMemory();\n    return NULL;\n}\n\n/* Same as _PyEvalFramePushAndInit but takes an args tuple and kwargs dict.\n   Steals references to func, callargs and kwargs.\n*/\nstatic _PyInterpreterFrame *\n_PyEvalFramePushAndInit_Ex(PyThreadState *tstate, PyFunctionObject *func,\n    PyObject *locals, Py_ssize_t nargs, PyObject *callargs, PyObject *kwargs)\n{\n    bool has_dict = (kwargs != NULL && PyDict_GET_SIZE(kwargs) > 0);\n    PyObject *kwnames = NULL;\n    PyObject *const *newargs;\n    if (has_dict) {\n        newargs = _PyStack_UnpackDict(tstate, _PyTuple_ITEMS(callargs), nargs, kwargs, &kwnames);\n        if (newargs == NULL) {\n            Py_DECREF(func);\n            goto error;\n        }\n    }\n    else {\n        newargs = &PyTuple_GET_ITEM(callargs, 0);\n        /* We need to incref all our args since the new frame steals the references. */\n        for (Py_ssize_t i = 0; i < nargs; ++i) {\n            Py_INCREF(PyTuple_GET_ITEM(callargs, i));\n        }\n    }\n    _PyInterpreterFrame *new_frame = _PyEvalFramePushAndInit(\n        tstate, (PyFunctionObject *)func, locals,\n        newargs, nargs, kwnames\n    );\n    if (has_dict) {\n        _PyStack_UnpackDict_FreeNoDecRef(newargs, kwnames);\n    }\n    /* No need to decref func here because the reference has been stolen by\n       _PyEvalFramePushAndInit.\n    */\n    Py_DECREF(callargs);\n    Py_XDECREF(kwargs);\n    return new_frame;\nerror:\n    Py_DECREF(callargs);\n    Py_XDECREF(kwargs);\n    return NULL;\n}\n\nPyObject *\n_PyEval_Vector(PyThreadState *tstate, PyFunctionObject *func,\n               PyObject *locals,\n               PyObject* const* args, size_t argcount,\n               PyObject *kwnames)\n{\n    /* _PyEvalFramePushAndInit consumes the references\n     * to func, locals and all its arguments */\n    Py_INCREF(func);\n    Py_XINCREF(locals);\n    for (size_t i = 0; i < argcount; i++) {\n        Py_INCREF(args[i]);\n    }\n    if (kwnames) {\n        Py_ssize_t kwcount = PyTuple_GET_SIZE(kwnames);\n        for (Py_ssize_t i = 0; i < kwcount; i++) {\n            Py_INCREF(args[i+argcount]);\n        }\n    }\n    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n        tstate, func, locals, args, argcount, kwnames);\n    if (frame == NULL) {\n        return NULL;\n    }\n    EVAL_CALL_STAT_INC(EVAL_CALL_VECTOR);\n    return _PyEval_EvalFrame(tstate, frame, 0);\n}\n\n/* Legacy API */\nPyObject *\nPyEval_EvalCodeEx(PyObject *_co, PyObject *globals, PyObject *locals,\n                  PyObject *const *args, int argcount,\n                  PyObject *const *kws, int kwcount,\n                  PyObject *const *defs, int defcount,\n                  PyObject *kwdefs, PyObject *closure)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    PyObject *res = NULL;\n    PyObject *defaults = _PyTuple_FromArray(defs, defcount);\n    if (defaults == NULL) {\n        return NULL;\n    }\n    PyObject *builtins = _PyEval_BuiltinsFromGlobals(tstate, globals); // borrowed ref\n    if (builtins == NULL) {\n        Py_DECREF(defaults);\n        return NULL;\n    }\n    if (locals == NULL) {\n        locals = globals;\n    }\n    PyObject *kwnames = NULL;\n    PyObject *const *allargs;\n    PyObject **newargs = NULL;\n    PyFunctionObject *func = NULL;\n    if (kwcount == 0) {\n        allargs = args;\n    }\n    else {\n        kwnames = PyTuple_New(kwcount);\n        if (kwnames == NULL) {\n            goto fail;\n        }\n        newargs = PyMem_Malloc(sizeof(PyObject *)*(kwcount+argcount));\n        if (newargs == NULL) {\n            goto fail;\n        }\n        for (int i = 0; i < argcount; i++) {\n            newargs[i] = args[i];\n        }\n        for (int i = 0; i < kwcount; i++) {\n            PyTuple_SET_ITEM(kwnames, i, Py_NewRef(kws[2*i]));\n            newargs[argcount+i] = kws[2*i+1];\n        }\n        allargs = newargs;\n    }\n    PyFrameConstructor constr = {\n        .fc_globals = globals,\n        .fc_builtins = builtins,\n        .fc_name = ((PyCodeObject *)_co)->co_name,\n        .fc_qualname = ((PyCodeObject *)_co)->co_name,\n        .fc_code = _co,\n        .fc_defaults = defaults,\n        .fc_kwdefaults = kwdefs,\n        .fc_closure = closure\n    };\n    func = _PyFunction_FromConstructor(&constr);\n    if (func == NULL) {\n        goto fail;\n    }\n    EVAL_CALL_STAT_INC(EVAL_CALL_LEGACY);\n    res = _PyEval_Vector(tstate, func, locals,\n                         allargs, argcount,\n                         kwnames);\nfail:\n    Py_XDECREF(func);\n    Py_XDECREF(kwnames);\n    PyMem_Free(newargs);\n    Py_DECREF(defaults);\n    return res;\n}\n\n\n/* Logic for the raise statement (too complicated for inlining).\n   This *consumes* a reference count to each of its arguments. */\nstatic int\ndo_raise(PyThreadState *tstate, PyObject *exc, PyObject *cause)\n{\n    PyObject *type = NULL, *value = NULL;\n\n    if (exc == NULL) {\n        /* Reraise */\n        _PyErr_StackItem *exc_info = _PyErr_GetTopmostException(tstate);\n        exc = exc_info->exc_value;\n        if (Py_IsNone(exc) || exc == NULL) {\n            _PyErr_SetString(tstate, PyExc_RuntimeError,\n                             \"No active exception to reraise\");\n            return 0;\n        }\n        Py_INCREF(exc);\n        assert(PyExceptionInstance_Check(exc));\n        _PyErr_SetRaisedException(tstate, exc);\n        return 1;\n    }\n\n    /* We support the following forms of raise:\n       raise\n       raise <instance>\n       raise <type> */\n\n    if (PyExceptionClass_Check(exc)) {\n        type = exc;\n        value = _PyObject_CallNoArgs(exc);\n        if (value == NULL)\n            goto raise_error;\n        if (!PyExceptionInstance_Check(value)) {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"calling %R should have returned an instance of \"\n                          \"BaseException, not %R\",\n                          type, Py_TYPE(value));\n             goto raise_error;\n        }\n    }\n    else if (PyExceptionInstance_Check(exc)) {\n        value = exc;\n        type = PyExceptionInstance_Class(exc);\n        Py_INCREF(type);\n    }\n    else {\n        /* Not something you can raise.  You get an exception\n           anyway, just not what you specified :-) */\n        Py_DECREF(exc);\n        _PyErr_SetString(tstate, PyExc_TypeError,\n                         \"exceptions must derive from BaseException\");\n        goto raise_error;\n    }\n\n    assert(type != NULL);\n    assert(value != NULL);\n\n    if (cause) {\n        PyObject *fixed_cause;\n        if (PyExceptionClass_Check(cause)) {\n            fixed_cause = _PyObject_CallNoArgs(cause);\n            if (fixed_cause == NULL)\n                goto raise_error;\n            Py_DECREF(cause);\n        }\n        else if (PyExceptionInstance_Check(cause)) {\n            fixed_cause = cause;\n        }\n        else if (Py_IsNone(cause)) {\n            Py_DECREF(cause);\n            fixed_cause = NULL;\n        }\n        else {\n            _PyErr_SetString(tstate, PyExc_TypeError,\n                             \"exception causes must derive from \"\n                             \"BaseException\");\n            goto raise_error;\n        }\n        PyException_SetCause(value, fixed_cause);\n    }\n\n    _PyErr_SetObject(tstate, type, value);\n    /* _PyErr_SetObject incref's its arguments */\n    Py_DECREF(value);\n    Py_DECREF(type);\n    return 0;\n\nraise_error:\n    Py_XDECREF(value);\n    Py_XDECREF(type);\n    Py_XDECREF(cause);\n    return 0;\n}\n\n/* Logic for matching an exception in an except* clause (too\n   complicated for inlining).\n*/\n\nstatic int\nexception_group_match(PyObject* exc_value, PyObject *match_type,\n                      PyObject **match, PyObject **rest)\n{\n    if (Py_IsNone(exc_value)) {\n        *match = Py_NewRef(Py_None);\n        *rest = Py_NewRef(Py_None);\n        return 0;\n    }\n    assert(PyExceptionInstance_Check(exc_value));\n\n    if (PyErr_GivenExceptionMatches(exc_value, match_type)) {\n        /* Full match of exc itself */\n        bool is_eg = _PyBaseExceptionGroup_Check(exc_value);\n        if (is_eg) {\n            *match = Py_NewRef(exc_value);\n        }\n        else {\n            /* naked exception - wrap it */\n            PyObject *excs = PyTuple_Pack(1, exc_value);\n            if (excs == NULL) {\n                return -1;\n            }\n            PyObject *wrapped = _PyExc_CreateExceptionGroup(\"\", excs);\n            Py_DECREF(excs);\n            if (wrapped == NULL) {\n                return -1;\n            }\n            *match = wrapped;\n        }\n        *rest = Py_NewRef(Py_None);\n        return 0;\n    }\n\n    /* exc_value does not match match_type.\n     * Check for partial match if it's an exception group.\n     */\n    if (_PyBaseExceptionGroup_Check(exc_value)) {\n        PyObject *pair = PyObject_CallMethod(exc_value, \"split\", \"(O)\",\n                                             match_type);\n        if (pair == NULL) {\n            return -1;\n        }\n        assert(PyTuple_CheckExact(pair));\n        assert(PyTuple_GET_SIZE(pair) == 2);\n        *match = Py_NewRef(PyTuple_GET_ITEM(pair, 0));\n        *rest = Py_NewRef(PyTuple_GET_ITEM(pair, 1));\n        Py_DECREF(pair);\n        return 0;\n    }\n    /* no match */\n    *match = Py_NewRef(Py_None);\n    *rest = Py_NewRef(exc_value);\n    return 0;\n}\n\n/* Iterate v argcnt times and store the results on the stack (via decreasing\n   sp).  Return 1 for success, 0 if error.\n\n   If argcntafter == -1, do a simple unpack. If it is >= 0, do an unpack\n   with a variable target.\n*/\n\nstatic int\nunpack_iterable(PyThreadState *tstate, PyObject *v,\n                int argcnt, int argcntafter, PyObject **sp)\n{\n    int i = 0, j = 0;\n    Py_ssize_t ll = 0;\n    PyObject *it;  /* iter(v) */\n    PyObject *w;\n    PyObject *l = NULL; /* variable list */\n\n    assert(v != NULL);\n\n    it = PyObject_GetIter(v);\n    if (it == NULL) {\n        if (_PyErr_ExceptionMatches(tstate, PyExc_TypeError) &&\n            Py_TYPE(v)->tp_iter == NULL && !PySequence_Check(v))\n        {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"cannot unpack non-iterable %.200s object\",\n                          Py_TYPE(v)->tp_name);\n        }\n        return 0;\n    }\n\n    for (; i < argcnt; i++) {\n        w = PyIter_Next(it);\n        if (w == NULL) {\n            /* Iterator done, via error or exhaustion. */\n            if (!_PyErr_Occurred(tstate)) {\n                if (argcntafter == -1) {\n                    _PyErr_Format(tstate, PyExc_ValueError,\n                                  \"not enough values to unpack \"\n                                  \"(expected %d, got %d)\",\n                                  argcnt, i);\n                }\n                else {\n                    _PyErr_Format(tstate, PyExc_ValueError,\n                                  \"not enough values to unpack \"\n                                  \"(expected at least %d, got %d)\",\n                                  argcnt + argcntafter, i);\n                }\n            }\n            goto Error;\n        }\n        *--sp = w;\n    }\n\n    if (argcntafter == -1) {\n        /* We better have exhausted the iterator now. */\n        w = PyIter_Next(it);\n        if (w == NULL) {\n            if (_PyErr_Occurred(tstate))\n                goto Error;\n            Py_DECREF(it);\n            return 1;\n        }\n        Py_DECREF(w);\n        _PyErr_Format(tstate, PyExc_ValueError,\n                      \"too many values to unpack (expected %d)\",\n                      argcnt);\n        goto Error;\n    }\n\n    l = PySequence_List(it);\n    if (l == NULL)\n        goto Error;\n    *--sp = l;\n    i++;\n\n    ll = PyList_GET_SIZE(l);\n    if (ll < argcntafter) {\n        _PyErr_Format(tstate, PyExc_ValueError,\n            \"not enough values to unpack (expected at least %d, got %zd)\",\n            argcnt + argcntafter, argcnt + ll);\n        goto Error;\n    }\n\n    /* Pop the \"after-variable\" args off the list. */\n    for (j = argcntafter; j > 0; j--, i++) {\n        *--sp = PyList_GET_ITEM(l, ll - j);\n    }\n    /* Resize the list. */\n    Py_SET_SIZE(l, ll - argcntafter);\n    Py_DECREF(it);\n    return 1;\n\nError:\n    for (; i > 0; i--, sp++)\n        Py_DECREF(*sp);\n    Py_XDECREF(it);\n    return 0;\n}\n\nstatic int\ndo_monitor_exc(PyThreadState *tstate, _PyInterpreterFrame *frame,\n               _Py_CODEUNIT *instr, int event)\n{\n    assert(event < _PY_MONITORING_UNGROUPED_EVENTS);\n    PyObject *exc = PyErr_GetRaisedException();\n    assert(exc != NULL);\n    int err = _Py_call_instrumentation_arg(tstate, event, frame, instr, exc);\n    if (err == 0) {\n        PyErr_SetRaisedException(exc);\n    }\n    else {\n        assert(PyErr_Occurred());\n        Py_DECREF(exc);\n    }\n    return err;\n}\n\nstatic inline bool\nno_tools_for_global_event(PyThreadState *tstate, int event)\n{\n    return tstate->interp->monitors.tools[event] == 0;\n}\n\nstatic inline bool\nno_tools_for_local_event(PyThreadState *tstate, _PyInterpreterFrame *frame, int event)\n{\n    assert(event < _PY_MONITORING_LOCAL_EVENTS);\n    _PyCoMonitoringData *data = frame->f_code->_co_monitoring;\n    if (data) {\n        return data->active_monitors.tools[event] == 0;\n    }\n    else {\n        return no_tools_for_global_event(tstate, event);\n    }\n}\n\nstatic void\nmonitor_raise(PyThreadState *tstate, _PyInterpreterFrame *frame,\n              _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_RAISE)) {\n        return;\n    }\n    do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_RAISE);\n}\n\nstatic void\nmonitor_reraise(PyThreadState *tstate, _PyInterpreterFrame *frame,\n              _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_RERAISE)) {\n        return;\n    }\n    do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_RERAISE);\n}\n\nstatic int\nmonitor_stop_iteration(PyThreadState *tstate, _PyInterpreterFrame *frame,\n                       _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_local_event(tstate, frame, PY_MONITORING_EVENT_STOP_ITERATION)) {\n        return 0;\n    }\n    return do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_STOP_ITERATION);\n}\n\nstatic void\nmonitor_unwind(PyThreadState *tstate,\n               _PyInterpreterFrame *frame,\n               _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_PY_UNWIND)) {\n        return;\n    }\n    do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_PY_UNWIND);\n}\n\n\nstatic int\nmonitor_handled(PyThreadState *tstate,\n                _PyInterpreterFrame *frame,\n                _Py_CODEUNIT *instr, PyObject *exc)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_EXCEPTION_HANDLED)) {\n        return 0;\n    }\n    return _Py_call_instrumentation_arg(tstate, PY_MONITORING_EVENT_EXCEPTION_HANDLED, frame, instr, exc);\n}\n\nstatic void\nmonitor_throw(PyThreadState *tstate,\n              _PyInterpreterFrame *frame,\n              _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_PY_THROW)) {\n        return;\n    }\n    do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_PY_THROW);\n}\n\nvoid\nPyThreadState_EnterTracing(PyThreadState *tstate)\n{\n    assert(tstate->tracing >= 0);\n    tstate->tracing++;\n}\n\nvoid\nPyThreadState_LeaveTracing(PyThreadState *tstate)\n{\n    assert(tstate->tracing > 0);\n    tstate->tracing--;\n}\n\n\nPyObject*\n_PyEval_CallTracing(PyObject *func, PyObject *args)\n{\n    // Save and disable tracing\n    PyThreadState *tstate = _PyThreadState_GET();\n    int save_tracing = tstate->tracing;\n    tstate->tracing = 0;\n\n    // Call the tracing function\n    PyObject *result = PyObject_Call(func, args, NULL);\n\n    // Restore tracing\n    tstate->tracing = save_tracing;\n    return result;\n}\n\nvoid\nPyEval_SetProfile(Py_tracefunc func, PyObject *arg)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (_PyEval_SetProfile(tstate, func, arg) < 0) {\n        /* Log _PySys_Audit() error */\n        _PyErr_WriteUnraisableMsg(\"in PyEval_SetProfile\", NULL);\n    }\n}\n\nvoid\nPyEval_SetProfileAllThreads(Py_tracefunc func, PyObject *arg)\n{\n    PyThreadState *this_tstate = _PyThreadState_GET();\n    PyInterpreterState* interp = this_tstate->interp;\n\n    _PyRuntimeState *runtime = &_PyRuntime;\n    HEAD_LOCK(runtime);\n    PyThreadState* ts = PyInterpreterState_ThreadHead(interp);\n    HEAD_UNLOCK(runtime);\n\n    while (ts) {\n        if (_PyEval_SetProfile(ts, func, arg) < 0) {\n            _PyErr_WriteUnraisableMsg(\"in PyEval_SetProfileAllThreads\", NULL);\n        }\n        HEAD_LOCK(runtime);\n        ts = PyThreadState_Next(ts);\n        HEAD_UNLOCK(runtime);\n    }\n}\n\nvoid\nPyEval_SetTrace(Py_tracefunc func, PyObject *arg)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (_PyEval_SetTrace(tstate, func, arg) < 0) {\n        /* Log _PySys_Audit() error */\n        _PyErr_WriteUnraisableMsg(\"in PyEval_SetTrace\", NULL);\n    }\n}\n\nvoid\nPyEval_SetTraceAllThreads(Py_tracefunc func, PyObject *arg)\n{\n    PyThreadState *this_tstate = _PyThreadState_GET();\n    PyInterpreterState* interp = this_tstate->interp;\n\n    _PyRuntimeState *runtime = &_PyRuntime;\n    HEAD_LOCK(runtime);\n    PyThreadState* ts = PyInterpreterState_ThreadHead(interp);\n    HEAD_UNLOCK(runtime);\n\n    while (ts) {\n        if (_PyEval_SetTrace(ts, func, arg) < 0) {\n            _PyErr_WriteUnraisableMsg(\"in PyEval_SetTraceAllThreads\", NULL);\n        }\n        HEAD_LOCK(runtime);\n        ts = PyThreadState_Next(ts);\n        HEAD_UNLOCK(runtime);\n    }\n}\n\nint\n_PyEval_SetCoroutineOriginTrackingDepth(int depth)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (depth < 0) {\n        _PyErr_SetString(tstate, PyExc_ValueError, \"depth must be >= 0\");\n        return -1;\n    }\n    tstate->coroutine_origin_tracking_depth = depth;\n    return 0;\n}\n\n\nint\n_PyEval_GetCoroutineOriginTrackingDepth(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return tstate->coroutine_origin_tracking_depth;\n}\n\nint\n_PyEval_SetAsyncGenFirstiter(PyObject *firstiter)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    if (_PySys_Audit(tstate, \"sys.set_asyncgen_hook_firstiter\", NULL) < 0) {\n        return -1;\n    }\n\n    Py_XSETREF(tstate->async_gen_firstiter, Py_XNewRef(firstiter));\n    return 0;\n}\n\nPyObject *\n_PyEval_GetAsyncGenFirstiter(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return tstate->async_gen_firstiter;\n}\n\nint\n_PyEval_SetAsyncGenFinalizer(PyObject *finalizer)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    if (_PySys_Audit(tstate, \"sys.set_asyncgen_hook_finalizer\", NULL) < 0) {\n        return -1;\n    }\n\n    Py_XSETREF(tstate->async_gen_finalizer, Py_XNewRef(finalizer));\n    return 0;\n}\n\nPyObject *\n_PyEval_GetAsyncGenFinalizer(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return tstate->async_gen_finalizer;\n}\n\n_PyInterpreterFrame *\n_PyEval_GetFrame(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _PyThreadState_GetFrame(tstate);\n}\n\nPyFrameObject *\nPyEval_GetFrame(void)\n{\n    _PyInterpreterFrame *frame = _PyEval_GetFrame();\n    if (frame == NULL) {\n        return NULL;\n    }\n    PyFrameObject *f = _PyFrame_GetFrameObject(frame);\n    if (f == NULL) {\n        PyErr_Clear();\n    }\n    return f;\n}\n\nPyObject *\n_PyEval_GetBuiltins(PyThreadState *tstate)\n{\n    _PyInterpreterFrame *frame = _PyThreadState_GetFrame(tstate);\n    if (frame != NULL) {\n        return frame->f_builtins;\n    }\n    return tstate->interp->builtins;\n}\n\nPyObject *\nPyEval_GetBuiltins(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _PyEval_GetBuiltins(tstate);\n}\n\n/* Convenience function to get a builtin from its name */\nPyObject *\n_PyEval_GetBuiltin(PyObject *name)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    PyObject *attr = PyObject_GetItem(PyEval_GetBuiltins(), name);\n    if (attr == NULL && _PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n        _PyErr_SetObject(tstate, PyExc_AttributeError, name);\n    }\n    return attr;\n}\n\nPyObject *\n_PyEval_GetBuiltinId(_Py_Identifier *name)\n{\n    return _PyEval_GetBuiltin(_PyUnicode_FromId(name));\n}\n\nPyObject *\nPyEval_GetLocals(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n     _PyInterpreterFrame *current_frame = _PyThreadState_GetFrame(tstate);\n    if (current_frame == NULL) {\n        _PyErr_SetString(tstate, PyExc_SystemError, \"frame does not exist\");\n        return NULL;\n    }\n\n    if (_PyFrame_FastToLocalsWithError(current_frame) < 0) {\n        return NULL;\n    }\n\n    PyObject *locals = current_frame->f_locals;\n    assert(locals != NULL);\n    return locals;\n}\n\nPyObject *\n_PyEval_GetFrameLocals(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n     _PyInterpreterFrame *current_frame = _PyThreadState_GetFrame(tstate);\n    if (current_frame == NULL) {\n        _PyErr_SetString(tstate, PyExc_SystemError, \"frame does not exist\");\n        return NULL;\n    }\n\n    return _PyFrame_GetLocals(current_frame, 1);\n}\n\nPyObject *\nPyEval_GetGlobals(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    _PyInterpreterFrame *current_frame = _PyThreadState_GetFrame(tstate);\n    if (current_frame == NULL) {\n        return NULL;\n    }\n    return current_frame->f_globals;\n}\n\nint\nPyEval_MergeCompilerFlags(PyCompilerFlags *cf)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    _PyInterpreterFrame *current_frame = tstate->cframe->current_frame;\n    int result = cf->cf_flags != 0;\n\n    if (current_frame != NULL) {\n        const int codeflags = current_frame->f_code->co_flags;\n        const int compilerflags = codeflags & PyCF_MASK;\n        if (compilerflags) {\n            result = 1;\n            cf->cf_flags |= compilerflags;\n        }\n    }\n    return result;\n}\n\n\nconst char *\nPyEval_GetFuncName(PyObject *func)\n{\n    if (PyMethod_Check(func))\n        return PyEval_GetFuncName(PyMethod_GET_FUNCTION(func));\n    else if (PyFunction_Check(func))\n        return PyUnicode_AsUTF8(((PyFunctionObject*)func)->func_name);\n    else if (PyCFunction_Check(func))\n        return ((PyCFunctionObject*)func)->m_ml->ml_name;\n    else\n        return Py_TYPE(func)->tp_name;\n}\n\nconst char *\nPyEval_GetFuncDesc(PyObject *func)\n{\n    if (PyMethod_Check(func))\n        return \"()\";\n    else if (PyFunction_Check(func))\n        return \"()\";\n    else if (PyCFunction_Check(func))\n        return \"()\";\n    else\n        return \" object\";\n}\n\n/* Extract a slice index from a PyLong or an object with the\n   nb_index slot defined, and store in *pi.\n   Silently reduce values larger than PY_SSIZE_T_MAX to PY_SSIZE_T_MAX,\n   and silently boost values less than PY_SSIZE_T_MIN to PY_SSIZE_T_MIN.\n   Return 0 on error, 1 on success.\n*/\nint\n_PyEval_SliceIndex(PyObject *v, Py_ssize_t *pi)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (!Py_IsNone(v)) {\n        Py_ssize_t x;\n        if (_PyIndex_Check(v)) {\n            x = PyNumber_AsSsize_t(v, NULL);\n            if (x == -1 && _PyErr_Occurred(tstate))\n                return 0;\n        }\n        else {\n            _PyErr_SetString(tstate, PyExc_TypeError,\n                             \"slice indices must be integers or \"\n                             \"None or have an __index__ method\");\n            return 0;\n        }\n        *pi = x;\n    }\n    return 1;\n}\n\nint\n_PyEval_SliceIndexNotNone(PyObject *v, Py_ssize_t *pi)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    Py_ssize_t x;\n    if (_PyIndex_Check(v)) {\n        x = PyNumber_AsSsize_t(v, NULL);\n        if (x == -1 && _PyErr_Occurred(tstate))\n            return 0;\n    }\n    else {\n        _PyErr_SetString(tstate, PyExc_TypeError,\n                         \"slice indices must be integers or \"\n                         \"have an __index__ method\");\n        return 0;\n    }\n    *pi = x;\n    return 1;\n}\n\nstatic PyObject *\nimport_name(PyThreadState *tstate, _PyInterpreterFrame *frame,\n            PyObject *name, PyObject *fromlist, PyObject *level)\n{\n    PyObject *import_func, *res;\n    PyObject* stack[5];\n\n    import_func = PyObject_GetItem(frame->f_builtins, &_Py_ID(__import__));\n    if (import_func == NULL) {\n        if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n            _PyErr_SetString(tstate, PyExc_ImportError, \"__import__ not found\");\n        }\n        return NULL;\n    }\n    PyObject *locals = frame->f_locals;\n    /* Fast path for not overloaded __import__. */\n    if (_PyImport_IsDefaultImportFunc(tstate->interp, import_func)) {\n        Py_DECREF(import_func);\n        int ilevel = _PyLong_AsInt(level);\n        if (ilevel == -1 && _PyErr_Occurred(tstate)) {\n            return NULL;\n        }\n        res = PyImport_ImportModuleLevelObject(\n                        name,\n                        frame->f_globals,\n                        locals == NULL ? Py_None :locals,\n                        fromlist,\n                        ilevel);\n        return res;\n    }\n\n    stack[0] = name;\n    stack[1] = frame->f_globals;\n    stack[2] = locals == NULL ? Py_None : locals;\n    stack[3] = fromlist;\n    stack[4] = level;\n    res = _PyObject_FastCall(import_func, stack, 5);\n    Py_DECREF(import_func);\n    return res;\n}\n\nstatic PyObject *\nimport_from(PyThreadState *tstate, PyObject *v, PyObject *name)\n{\n    PyObject *x;\n    PyObject *fullmodname, *pkgname, *pkgpath, *pkgname_or_unknown, *errmsg;\n\n    if (_PyObject_LookupAttr(v, name, &x) != 0) {\n        return x;\n    }\n    /* Issue #17636: in case this failed because of a circular relative\n       import, try to fallback on reading the module directly from\n       sys.modules. */\n    pkgname = PyObject_GetAttr(v, &_Py_ID(__name__));\n    if (pkgname == NULL) {\n        goto error;\n    }\n    if (!PyUnicode_Check(pkgname)) {\n        Py_CLEAR(pkgname);\n        goto error;\n    }\n    fullmodname = PyUnicode_FromFormat(\"%U.%U\", pkgname, name);\n    if (fullmodname == NULL) {\n        Py_DECREF(pkgname);\n        return NULL;\n    }\n    x = PyImport_GetModule(fullmodname);\n    Py_DECREF(fullmodname);\n    if (x == NULL && !_PyErr_Occurred(tstate)) {\n        goto error;\n    }\n    Py_DECREF(pkgname);\n    return x;\n error:\n    pkgpath = PyModule_GetFilenameObject(v);\n    if (pkgname == NULL) {\n        pkgname_or_unknown = PyUnicode_FromString(\"<unknown module name>\");\n        if (pkgname_or_unknown == NULL) {\n            Py_XDECREF(pkgpath);\n            return NULL;\n        }\n    } else {\n        pkgname_or_unknown = pkgname;\n    }\n\n    if (pkgpath == NULL || !PyUnicode_Check(pkgpath)) {\n        _PyErr_Clear(tstate);\n        errmsg = PyUnicode_FromFormat(\n            \"cannot import name %R from %R (unknown location)\",\n            name, pkgname_or_unknown\n        );\n        /* NULL checks for errmsg and pkgname done by PyErr_SetImportError. */\n        _PyErr_SetImportErrorWithNameFrom(errmsg, pkgname, NULL, name);\n    }\n    else {\n        PyObject *spec = PyObject_GetAttr(v, &_Py_ID(__spec__));\n        const char *fmt =\n            _PyModuleSpec_IsInitializing(spec) ?\n            \"cannot import name %R from partially initialized module %R \"\n            \"(most likely due to a circular import) (%S)\" :\n            \"cannot import name %R from %R (%S)\";\n        Py_XDECREF(spec);\n\n        errmsg = PyUnicode_FromFormat(fmt, name, pkgname_or_unknown, pkgpath);\n        /* NULL checks for errmsg and pkgname done by PyErr_SetImportError. */\n        _PyErr_SetImportErrorWithNameFrom(errmsg, pkgname, pkgpath, name);\n    }\n\n    Py_XDECREF(errmsg);\n    Py_XDECREF(pkgname_or_unknown);\n    Py_XDECREF(pkgpath);\n    return NULL;\n}\n\n#define CANNOT_CATCH_MSG \"catching classes that do not inherit from \"\\\n                         \"BaseException is not allowed\"\n\n#define CANNOT_EXCEPT_STAR_EG \"catching ExceptionGroup with except* \"\\\n                              \"is not allowed. Use except instead.\"\n\nstatic int\ncheck_except_type_valid(PyThreadState *tstate, PyObject* right)\n{\n    if (PyTuple_Check(right)) {\n        Py_ssize_t i, length;\n        length = PyTuple_GET_SIZE(right);\n        for (i = 0; i < length; i++) {\n            PyObject *exc = PyTuple_GET_ITEM(right, i);\n            if (!PyExceptionClass_Check(exc)) {\n                _PyErr_SetString(tstate, PyExc_TypeError,\n                    CANNOT_CATCH_MSG);\n                return -1;\n            }\n        }\n    }\n    else {\n        if (!PyExceptionClass_Check(right)) {\n            _PyErr_SetString(tstate, PyExc_TypeError,\n                CANNOT_CATCH_MSG);\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic int\ncheck_except_star_type_valid(PyThreadState *tstate, PyObject* right)\n{\n    if (check_except_type_valid(tstate, right) < 0) {\n        return -1;\n    }\n\n    /* reject except *ExceptionGroup */\n\n    int is_subclass = 0;\n    if (PyTuple_Check(right)) {\n        Py_ssize_t length = PyTuple_GET_SIZE(right);\n        for (Py_ssize_t i = 0; i < length; i++) {\n            PyObject *exc = PyTuple_GET_ITEM(right, i);\n            is_subclass = PyObject_IsSubclass(exc, PyExc_BaseExceptionGroup);\n            if (is_subclass < 0) {\n                return -1;\n            }\n            if (is_subclass) {\n                break;\n            }\n        }\n    }\n    else {\n        is_subclass = PyObject_IsSubclass(right, PyExc_BaseExceptionGroup);\n        if (is_subclass < 0) {\n            return -1;\n        }\n    }\n    if (is_subclass) {\n        _PyErr_SetString(tstate, PyExc_TypeError,\n            CANNOT_EXCEPT_STAR_EG);\n            return -1;\n    }\n    return 0;\n}\n\nstatic int\ncheck_args_iterable(PyThreadState *tstate, PyObject *func, PyObject *args)\n{\n    if (Py_TYPE(args)->tp_iter == NULL && !PySequence_Check(args)) {\n        /* check_args_iterable() may be called with a live exception:\n         * clear it to prevent calling _PyObject_FunctionStr() with an\n         * exception set. */\n        _PyErr_Clear(tstate);\n        PyObject *funcstr = _PyObject_FunctionStr(func);\n        if (funcstr != NULL) {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"%U argument after * must be an iterable, not %.200s\",\n                          funcstr, Py_TYPE(args)->tp_name);\n            Py_DECREF(funcstr);\n        }\n        return -1;\n    }\n    return 0;\n}\n\nstatic void\nformat_kwargs_error(PyThreadState *tstate, PyObject *func, PyObject *kwargs)\n{\n    /* _PyDict_MergeEx raises attribute\n     * error (percolated from an attempt\n     * to get 'keys' attribute) instead of\n     * a type error if its second argument\n     * is not a mapping.\n     */\n    if (_PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {\n        _PyErr_Clear(tstate);\n        PyObject *funcstr = _PyObject_FunctionStr(func);\n        if (funcstr != NULL) {\n            _PyErr_Format(\n                tstate, PyExc_TypeError,\n                \"%U argument after ** must be a mapping, not %.200s\",\n                funcstr, Py_TYPE(kwargs)->tp_name);\n            Py_DECREF(funcstr);\n        }\n    }\n    else if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n        PyObject *exc = _PyErr_GetRaisedException(tstate);\n        PyObject *args = ((PyBaseExceptionObject *)exc)->args;\n        if (exc && PyTuple_Check(args) && PyTuple_GET_SIZE(args) == 1) {\n            _PyErr_Clear(tstate);\n            PyObject *funcstr = _PyObject_FunctionStr(func);\n            if (funcstr != NULL) {\n                PyObject *key = PyTuple_GET_ITEM(args, 0);\n                _PyErr_Format(\n                    tstate, PyExc_TypeError,\n                    \"%U got multiple values for keyword argument '%S'\",\n                    funcstr, key);\n                Py_DECREF(funcstr);\n            }\n            Py_XDECREF(exc);\n        }\n        else {\n            _PyErr_SetRaisedException(tstate, exc);\n        }\n    }\n}\n\nstatic void\nformat_exc_check_arg(PyThreadState *tstate, PyObject *exc,\n                     const char *format_str, PyObject *obj)\n{\n    const char *obj_str;\n\n    if (!obj)\n        return;\n\n    obj_str = PyUnicode_AsUTF8(obj);\n    if (!obj_str)\n        return;\n\n    _PyErr_Format(tstate, exc, format_str, obj_str);\n\n    if (exc == PyExc_NameError) {\n        // Include the name in the NameError exceptions to offer suggestions later.\n        PyObject *exc = PyErr_GetRaisedException();\n        if (PyErr_GivenExceptionMatches(exc, PyExc_NameError)) {\n            if (((PyNameErrorObject*)exc)->name == NULL) {\n                // We do not care if this fails because we are going to restore the\n                // NameError anyway.\n                (void)PyObject_SetAttr(exc, &_Py_ID(name), obj);\n            }\n        }\n        PyErr_SetRaisedException(exc);\n    }\n}\n\nstatic void\nformat_exc_unbound(PyThreadState *tstate, PyCodeObject *co, int oparg)\n{\n    PyObject *name;\n    /* Don't stomp existing exception */\n    if (_PyErr_Occurred(tstate))\n        return;\n    name = PyTuple_GET_ITEM(co->co_localsplusnames, oparg);\n    if (oparg < PyCode_GetFirstFree(co)) {\n        format_exc_check_arg(tstate, PyExc_UnboundLocalError,\n                             UNBOUNDLOCAL_ERROR_MSG, name);\n    } else {\n        format_exc_check_arg(tstate, PyExc_NameError,\n                             UNBOUNDFREE_ERROR_MSG, name);\n    }\n}\n\nstatic void\nformat_awaitable_error(PyThreadState *tstate, PyTypeObject *type, int oparg)\n{\n    if (type->tp_as_async == NULL || type->tp_as_async->am_await == NULL) {\n        if (oparg == 1) {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"'async with' received an object from __aenter__ \"\n                          \"that does not implement __await__: %.100s\",\n                          type->tp_name);\n        }\n        else if (oparg == 2) {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"'async with' received an object from __aexit__ \"\n                          \"that does not implement __await__: %.100s\",\n                          type->tp_name);\n        }\n    }\n}\n\n\nPy_ssize_t\nPyUnstable_Eval_RequestCodeExtraIndex(freefunc free)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    Py_ssize_t new_index;\n\n    if (interp->co_extra_user_count == MAX_CO_EXTRA_USERS - 1) {\n        return -1;\n    }\n    new_index = interp->co_extra_user_count++;\n    interp->co_extra_freefuncs[new_index] = free;\n    return new_index;\n}\n\n/* Implement Py_EnterRecursiveCall() and Py_LeaveRecursiveCall() as functions\n   for the limited API. */\n\nint Py_EnterRecursiveCall(const char *where)\n{\n    return _Py_EnterRecursiveCall(where);\n}\n\nvoid Py_LeaveRecursiveCall(void)\n{\n    _Py_LeaveRecursiveCall();\n}\n"}, "sourceLanguage": "c"}, {"location": {"uri": "./Include/internal/pycore_frame.h", "uriBaseId": "PWD"}, "contents": {"text": "#ifndef Py_INTERNAL_FRAME_H\n#define Py_INTERNAL_FRAME_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdbool.h>\n#include <stddef.h>\n#include \"pycore_code.h\"         // STATS\n\n/* See Objects/frame_layout.md for an explanation of the frame stack\n * including explanation of the PyFrameObject and _PyInterpreterFrame\n * structs. */\n\n\nstruct _frame {\n    PyObject_HEAD\n    PyFrameObject *f_back;      /* previous frame, or NULL */\n    struct _PyInterpreterFrame *f_frame; /* points to the frame data */\n    PyObject *f_trace;          /* Trace function */\n    int f_lineno;               /* Current line number. Only valid if non-zero */\n    char f_trace_lines;         /* Emit per-line trace events? */\n    char f_trace_opcodes;       /* Emit per-opcode trace events? */\n    char f_fast_as_locals;      /* Have the fast locals of this frame been converted to a dict? */\n    /* The frame data, if this frame object owns the frame */\n    PyObject *_f_frame_data[1];\n};\n\nextern PyFrameObject* _PyFrame_New_NoTrack(PyCodeObject *code);\n\n\n/* other API */\n\ntypedef enum _framestate {\n    FRAME_CREATED = -2,\n    FRAME_SUSPENDED = -1,\n    FRAME_EXECUTING = 0,\n    FRAME_COMPLETED = 1,\n    FRAME_CLEARED = 4\n} PyFrameState;\n\n#define FRAME_STATE_FINISHED(S) ((S) >= FRAME_COMPLETED)\n\nenum _frameowner {\n    FRAME_OWNED_BY_THREAD = 0,\n    FRAME_OWNED_BY_GENERATOR = 1,\n    FRAME_OWNED_BY_FRAME_OBJECT = 2,\n    FRAME_OWNED_BY_CSTACK = 3,\n};\n\ntypedef struct _PyInterpreterFrame {\n    PyCodeObject *f_code; /* Strong reference */\n    struct _PyInterpreterFrame *previous;\n    PyObject *f_funcobj; /* Strong reference. Only valid if not on C stack */\n    PyObject *f_globals; /* Borrowed reference. Only valid if not on C stack */\n    PyObject *f_builtins; /* Borrowed reference. Only valid if not on C stack */\n    PyObject *f_locals; /* Strong reference, may be NULL. Only valid if not on C stack */\n    PyFrameObject *frame_obj; /* Strong reference, may be NULL. Only valid if not on C stack */\n    // NOTE: This is not necessarily the last instruction started in the given\n    // frame. Rather, it is the code unit *prior to* the *next* instruction. For\n    // example, it may be an inline CACHE entry, an instruction we just jumped\n    // over, or (in the case of a newly-created frame) a totally invalid value:\n    _Py_CODEUNIT *prev_instr;\n    int stacktop;  /* Offset of TOS from localsplus  */\n    /* The return_offset determines where a `RETURN` should go in the caller,\n     * relative to `prev_instr`.\n     * It is only meaningful to the callee,\n     * so it needs to be set in any CALL (to a Python function)\n     * or SEND (to a coroutine or generator).\n     * If there is no callee, then it is meaningless. */\n    uint16_t return_offset;\n    char owner;\n    /* Locals and stack */\n    PyObject *localsplus[1];\n} _PyInterpreterFrame;\n\n#define _PyInterpreterFrame_LASTI(IF) \\\n    ((int)((IF)->prev_instr - _PyCode_CODE((IF)->f_code)))\n\nstatic inline PyObject **_PyFrame_Stackbase(_PyInterpreterFrame *f) {\n    return f->localsplus + f->f_code->co_nlocalsplus;\n}\n\nstatic inline PyObject *_PyFrame_StackPeek(_PyInterpreterFrame *f) {\n    assert(f->stacktop > f->f_code->co_nlocalsplus);\n    assert(f->localsplus[f->stacktop-1] != NULL);\n    return f->localsplus[f->stacktop-1];\n}\n\nstatic inline PyObject *_PyFrame_StackPop(_PyInterpreterFrame *f) {\n    assert(f->stacktop > f->f_code->co_nlocalsplus);\n    f->stacktop--;\n    return f->localsplus[f->stacktop];\n}\n\nstatic inline void _PyFrame_StackPush(_PyInterpreterFrame *f, PyObject *value) {\n    f->localsplus[f->stacktop] = value;\n    f->stacktop++;\n}\n\n#define FRAME_SPECIALS_SIZE ((int)((sizeof(_PyInterpreterFrame)-1)/sizeof(PyObject *)))\n\nstatic inline int\n_PyFrame_NumSlotsForCodeObject(PyCodeObject *code)\n{\n    /* This function needs to remain in sync with the calculation of\n     * co_framesize in Tools/build/deepfreeze.py */\n    assert(code->co_framesize >= FRAME_SPECIALS_SIZE);\n    return code->co_framesize - FRAME_SPECIALS_SIZE;\n}\n\nvoid _PyFrame_Copy(_PyInterpreterFrame *src, _PyInterpreterFrame *dest);\n\n/* Consumes reference to func and locals.\n   Does not initialize frame->previous, which happens\n   when frame is linked into the frame stack.\n */\nstatic inline void\n_PyFrame_Initialize(\n    _PyInterpreterFrame *frame, PyFunctionObject *func,\n    PyObject *locals, PyCodeObject *code, int null_locals_from)\n{\n    frame->f_funcobj = (PyObject *)func;\n    frame->f_code = (PyCodeObject *)Py_NewRef(code);\n    frame->f_builtins = func->func_builtins;\n    frame->f_globals = func->func_globals;\n    frame->f_locals = locals;\n    frame->stacktop = code->co_nlocalsplus;\n    frame->frame_obj = NULL;\n    frame->prev_instr = _PyCode_CODE(code) - 1;\n    frame->return_offset = 0;\n    frame->owner = FRAME_OWNED_BY_THREAD;\n\n    for (int i = null_locals_from; i < code->co_nlocalsplus; i++) {\n        frame->localsplus[i] = NULL;\n    }\n}\n\n/* Gets the pointer to the locals array\n * that precedes this frame.\n */\nstatic inline PyObject**\n_PyFrame_GetLocalsArray(_PyInterpreterFrame *frame)\n{\n    return frame->localsplus;\n}\n\n/* Fetches the stack pointer, and sets stacktop to -1.\n   Having stacktop <= 0 ensures that invalid\n   values are not visible to the cycle GC.\n   We choose -1 rather than 0 to assist debugging. */\nstatic inline PyObject**\n_PyFrame_GetStackPointer(_PyInterpreterFrame *frame)\n{\n    PyObject **sp = frame->localsplus + frame->stacktop;\n    frame->stacktop = -1;\n    return sp;\n}\n\nstatic inline void\n_PyFrame_SetStackPointer(_PyInterpreterFrame *frame, PyObject **stack_pointer)\n{\n    frame->stacktop = (int)(stack_pointer - frame->localsplus);\n}\n\n/* Determine whether a frame is incomplete.\n * A frame is incomplete if it is part way through\n * creating cell objects or a generator or coroutine.\n *\n * Frames on the frame stack are incomplete until the\n * first RESUME instruction.\n * Frames owned by a generator are always complete.\n */\nstatic inline bool\n_PyFrame_IsIncomplete(_PyInterpreterFrame *frame)\n{\n    return frame->owner != FRAME_OWNED_BY_GENERATOR &&\n    frame->prev_instr < _PyCode_CODE(frame->f_code) + frame->f_code->_co_firsttraceable;\n}\n\nstatic inline _PyInterpreterFrame *\n_PyFrame_GetFirstComplete(_PyInterpreterFrame *frame)\n{\n    while (frame && _PyFrame_IsIncomplete(frame)) {\n        frame = frame->previous;\n    }\n    return frame;\n}\n\nstatic inline _PyInterpreterFrame *\n_PyThreadState_GetFrame(PyThreadState *tstate)\n{\n    return _PyFrame_GetFirstComplete(tstate->cframe->current_frame);\n}\n\n/* For use by _PyFrame_GetFrameObject\n  Do not call directly. */\nPyFrameObject *\n_PyFrame_MakeAndSetFrameObject(_PyInterpreterFrame *frame);\n\n/* Gets the PyFrameObject for this frame, lazily\n * creating it if necessary.\n * Returns a borrowed referennce */\nstatic inline PyFrameObject *\n_PyFrame_GetFrameObject(_PyInterpreterFrame *frame)\n{\n\n    assert(!_PyFrame_IsIncomplete(frame));\n    PyFrameObject *res =  frame->frame_obj;\n    if (res != NULL) {\n        return res;\n    }\n    return _PyFrame_MakeAndSetFrameObject(frame);\n}\n\nvoid\n_PyFrame_ClearLocals(_PyInterpreterFrame *frame);\n\n/* Clears all references in the frame.\n * If take is non-zero, then the _PyInterpreterFrame frame\n * may be transferred to the frame object it references\n * instead of being cleared. Either way\n * the caller no longer owns the references\n * in the frame.\n * take should  be set to 1 for heap allocated\n * frames like the ones in generators and coroutines.\n */\nvoid\n_PyFrame_ClearExceptCode(_PyInterpreterFrame * frame);\n\nint\n_PyFrame_Traverse(_PyInterpreterFrame *frame, visitproc visit, void *arg);\n\nPyObject *\n_PyFrame_GetLocals(_PyInterpreterFrame *frame, int include_hidden);\n\nint\n_PyFrame_FastToLocalsWithError(_PyInterpreterFrame *frame);\n\nvoid\n_PyFrame_LocalsToFast(_PyInterpreterFrame *frame, int clear);\n\nstatic inline bool\n_PyThreadState_HasStackSpace(PyThreadState *tstate, int size)\n{\n    assert(\n        (tstate->datastack_top == NULL && tstate->datastack_limit == NULL)\n        ||\n        (tstate->datastack_top != NULL && tstate->datastack_limit != NULL)\n    );\n    return tstate->datastack_top != NULL &&\n        size < tstate->datastack_limit - tstate->datastack_top;\n}\n\nextern _PyInterpreterFrame *\n_PyThreadState_PushFrame(PyThreadState *tstate, size_t size);\n\nvoid _PyThreadState_PopFrame(PyThreadState *tstate, _PyInterpreterFrame *frame);\n\n/* Pushes a frame without checking for space.\n * Must be guarded by _PyThreadState_HasStackSpace()\n * Consumes reference to func. */\nstatic inline _PyInterpreterFrame *\n_PyFrame_PushUnchecked(PyThreadState *tstate, PyFunctionObject *func, int null_locals_from)\n{\n    CALL_STAT_INC(frames_pushed);\n    PyCodeObject *code = (PyCodeObject *)func->func_code;\n    _PyInterpreterFrame *new_frame = (_PyInterpreterFrame *)tstate->datastack_top;\n    tstate->datastack_top += code->co_framesize;\n    assert(tstate->datastack_top < tstate->datastack_limit);\n    _PyFrame_Initialize(new_frame, func, NULL, code, null_locals_from);\n    return new_frame;\n}\n\nstatic inline\nPyGenObject *_PyFrame_GetGenerator(_PyInterpreterFrame *frame)\n{\n    assert(frame->owner == FRAME_OWNED_BY_GENERATOR);\n    size_t offset_in_gen = offsetof(PyGenObject, gi_iframe);\n    return (PyGenObject *)(((char *)frame) - offset_in_gen);\n}\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_INTERNAL_FRAME_H */\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-null-dereference", "taxa": [{"id": "476", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "dereference of NULL 'args'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1350, "startColumn": 19, "endColumn": 20}, "contextRegion": {"startLine": 1350, "snippet": {"text": "        PyObject *x = args[j];\n"}}}, "logicalLocations": [{"name": "initialize_locals", "fullyQualifiedName": "initialize_locals", "decoratedName": "initialize_locals", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 553, "startColumn": 1, "endColumn": 16}, "contextRegion": {"startLine": 553, "snippet": {"text": "PyEval_EvalCode(PyObject *co, PyObject *globals, PyObject *locals)\n"}}}, "logicalLocations": [{"name": "PyEval_EvalCode", "fullyQualifiedName": "PyEval_EvalCode", "decoratedName": "PyEval_EvalCode", "kind": "function"}], "message": {"text": "entry to 'PyEval_EvalCode'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 560, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 560, "snippet": {"text": "    if (builtins == NULL) {\n"}}}, "logicalLocations": [{"name": "PyEval_EvalCode", "fullyQualifiedName": "PyEval_EvalCode", "decoratedName": "PyEval_EvalCode", "kind": "function"}], "message": {"text": "following 'false' branch (when 'builtins' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 563, "startColumn": 5, "endColumn": 23}, "contextRegion": {"startLine": 563, "snippet": {"text": "    PyFrameConstructor desc = {\n"}}}, "logicalLocations": [{"name": "PyEval_EvalCode", "fullyQualifiedName": "PyEval_EvalCode", "decoratedName": "PyEval_EvalCode", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 574, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 574, "snippet": {"text": "    if (func == NULL) {\n"}}}, "logicalLocations": [{"name": "PyEval_EvalCode", "fullyQualifiedName": "PyEval_EvalCode", "decoratedName": "PyEval_EvalCode", "kind": "function"}], "message": {"text": "following 'false' branch (when 'func' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 577, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 577, "snippet": {"text": "    EVAL_CALL_STAT_INC(EVAL_CALL_LEGACY);\n"}}}, "logicalLocations": [{"name": "PyEval_EvalCode", "fullyQualifiedName": "PyEval_EvalCode", "decoratedName": "PyEval_EvalCode", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 578, "startColumn": 21, "endColumn": 72}, "contextRegion": {"startLine": 578, "snippet": {"text": "    PyObject *res = _PyEval_Vector(tstate, func, locals, NULL, 0, NULL);\n"}}}, "logicalLocations": [{"name": "PyEval_EvalCode", "fullyQualifiedName": "PyEval_EvalCode", "decoratedName": "PyEval_EvalCode", "kind": "function"}], "message": {"text": "calling '_PyEval_Vector' from 'PyEval_EvalCode'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1659, "startColumn": 1, "endColumn": 15}, "contextRegion": {"startLine": 1659, "snippet": {"text": "_PyEval_Vector(PyThreadState *tstate, PyFunctionObject *func,\n"}}}, "logicalLocations": [{"name": "_PyEval_Vector", "fullyQualifiedName": "_PyEval_Vector", "decoratedName": "_PyEval_Vector", "kind": "function"}], "message": {"text": "entry to '_PyEval_Vector'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1668, "startColumn": 24, "endColumn": 36}, "contextRegion": {"startLine": 1668, "snippet": {"text": "    for (size_t i = 0; i < argcount; i++) {\n"}}}, "logicalLocations": [{"name": "_PyEval_Vector", "fullyQualifiedName": "_PyEval_Vector", "decoratedName": "_PyEval_Vector", "kind": "function"}], "message": {"text": "following 'false' branch (when 'i >= argcount')..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1671, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 1671, "snippet": {"text": "    if (kwnames) {\n"}}}, "logicalLocations": [{"name": "_PyEval_Vector", "fullyQualifiedName": "_PyEval_Vector", "decoratedName": "_PyEval_Vector", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1671, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1671, "snippet": {"text": "    if (kwnames) {\n"}}}, "logicalLocations": [{"name": "_PyEval_Vector", "fullyQualifiedName": "_PyEval_Vector", "decoratedName": "_PyEval_Vector", "kind": "function"}], "message": {"text": "following 'false' branch (when 'kwnames' is NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1677, "startColumn": 5, "endColumn": 24}, "contextRegion": {"startLine": 1677, "snippet": {"text": "    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n"}}}, "logicalLocations": [{"name": "_PyEval_Vector", "fullyQualifiedName": "_PyEval_Vector", "decoratedName": "_PyEval_Vector", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1677, "startColumn": 34, "endLine": 1678, "endColumn": 55}, "contextRegion": {"startLine": 1677, "endLine": 1678, "snippet": {"text": "    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n        tstate, func, locals, args, argcount, kwnames);\n"}}}, "logicalLocations": [{"name": "_PyEval_Vector", "fullyQualifiedName": "_PyEval_Vector", "decoratedName": "_PyEval_Vector", "kind": "function"}], "message": {"text": "calling '_PyEvalFramePushAndInit' from '_PyEval_Vector'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1583, "startColumn": 1, "endColumn": 24}, "contextRegion": {"startLine": 1583, "snippet": {"text": "_PyEvalFramePushAndInit(PyThreadState *tstate, PyFunctionObject *func,\n"}}}, "logicalLocations": [{"name": "_PyEvalFramePushAndInit", "fullyQualifiedName": "_PyEvalFramePushAndInit", "decoratedName": "_PyEvalFramePushAndInit", "kind": "function"}], "message": {"text": "entry to '_PyEvalFramePushAndInit'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1590, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1590, "snippet": {"text": "    if (frame == NULL) {\n"}}}, "logicalLocations": [{"name": "_PyEvalFramePushAndInit", "fullyQualifiedName": "_PyEvalFramePushAndInit", "decoratedName": "_PyEvalFramePushAndInit", "kind": "function"}], "message": {"text": "following 'false' branch (when 'frame' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1593, "startColumn": 5, "endColumn": 24}, "contextRegion": {"startLine": 1593, "snippet": {"text": "    _PyFrame_Initialize(frame, func, locals, code, 0);\n"}}}, "logicalLocations": [{"name": "_PyEvalFramePushAndInit", "fullyQualifiedName": "_PyEvalFramePushAndInit", "decoratedName": "_PyEvalFramePushAndInit", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1593, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1593, "snippet": {"text": "    _PyFrame_Initialize(frame, func, locals, code, 0);\n"}}}, "logicalLocations": [{"name": "_PyEvalFramePushAndInit", "fullyQualifiedName": "_PyEvalFramePushAndInit", "decoratedName": "_PyEvalFramePushAndInit", "kind": "function"}], "message": {"text": "inlined call to '_PyFrame_Initialize' from '_PyEvalFramePushAndInit'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_frame.h", "uriBaseId": "PWD"}, "region": {"startLine": 134, "startColumn": 36, "endColumn": 60}, "contextRegion": {"startLine": 134, "snippet": {"text": "    for (int i = null_locals_from; i < code->co_nlocalsplus; i++) {\n"}}}, "logicalLocations": [{"name": "_PyFrame_Initialize", "fullyQualifiedName": "_PyFrame_Initialize", "decoratedName": "_PyFrame_Initialize", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1593, "startColumn": 5, "endColumn": 54}, "contextRegion": {"startLine": 1593, "snippet": {"text": "    _PyFrame_Initialize(frame, func, locals, code, 0);\n"}}}, "logicalLocations": [{"name": "_PyEvalFramePushAndInit", "fullyQualifiedName": "_PyEvalFramePushAndInit", "decoratedName": "_PyEvalFramePushAndInit", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1594, "startColumn": 9, "endColumn": 84}, "contextRegion": {"startLine": 1594, "snippet": {"text": "    if (initialize_locals(tstate, func, frame->localsplus, args, argcount, kwnames)) {\n"}}}, "logicalLocations": [{"name": "_PyEvalFramePushAndInit", "fullyQualifiedName": "_PyEvalFramePushAndInit", "decoratedName": "_PyEvalFramePushAndInit", "kind": "function"}], "message": {"text": "calling 'initialize_locals' from '_PyEvalFramePushAndInit'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1315, "startColumn": 1, "endColumn": 18}, "contextRegion": {"startLine": 1315, "snippet": {"text": "initialize_locals(PyThreadState *tstate, PyFunctionObject *func,\n"}}}, "logicalLocations": [{"name": "initialize_locals", "fullyQualifiedName": "initialize_locals", "decoratedName": "initialize_locals", "kind": "function"}], "message": {"text": "entry to 'initialize_locals'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1325, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1325, "snippet": {"text": "    if (co->co_flags & CO_VARKEYWORDS) {\n"}}}, "logicalLocations": [{"name": "initialize_locals", "fullyQualifiedName": "initialize_locals", "decoratedName": "initialize_locals", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1342, "startColumn": 5, "endColumn": 15}, "contextRegion": {"startLine": 1342, "snippet": {"text": "    Py_ssize_t j, n;\n"}}}, "logicalLocations": [{"name": "initialize_locals", "fullyQualifiedName": "initialize_locals", "decoratedName": "initialize_locals", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1349, "startColumn": 17, "endColumn": 22}, "contextRegion": {"startLine": 1349, "snippet": {"text": "    for (j = 0; j < n; j++) {\n"}}}, "logicalLocations": [{"name": "initialize_locals", "fullyQualifiedName": "initialize_locals", "decoratedName": "initialize_locals", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1350, "startColumn": 9, "endColumn": 17}, "contextRegion": {"startLine": 1350, "snippet": {"text": "        PyObject *x = args[j];\n"}}}, "logicalLocations": [{"name": "initialize_locals", "fullyQualifiedName": "initialize_locals", "decoratedName": "initialize_locals", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1350, "startColumn": 27, "endColumn": 28}, "contextRegion": {"startLine": 1350, "snippet": {"text": "        PyObject *x = args[j];\n"}}}, "logicalLocations": [{"name": "initialize_locals", "fullyQualifiedName": "initialize_locals", "decoratedName": "initialize_locals", "kind": "function"}], "message": {"text": "'args' is NULL"}}, "kinds": ["release", "memory"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c", "uriBaseId": "PWD"}, "region": {"startLine": 1350, "startColumn": 19, "endColumn": 20}, "contextRegion": {"startLine": 1350, "snippet": {"text": "        PyObject *x = args[j];\n"}}}, "logicalLocations": [{"name": "initialize_locals", "fullyQualifiedName": "initialize_locals", "decoratedName": "initialize_locals", "kind": "function"}], "message": {"text": "dereference of NULL 'args + (long unsigned int)j * 8'"}}, "kinds": ["danger"], "nestingLevel": 4}]}]}]}]}]}
