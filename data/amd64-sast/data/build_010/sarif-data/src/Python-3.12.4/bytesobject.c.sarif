{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-use-of-uninitialized-value", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-use-of-uninitialized-value"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "457", "helpUri": "https://cwe.mitre.org/data/definitions/457.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}}, "artifacts": [{"location": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "contents": {"text": "/* bytes object implementation */\n\n#define PY_SSIZE_T_CLEAN\n\n#include \"Python.h\"\n#include \"pycore_abstract.h\"      // _PyIndex_Check()\n#include \"pycore_bytesobject.h\"   // _PyBytes_Find(), _PyBytes_Repeat()\n#include \"pycore_bytes_methods.h\" // _Py_bytes_startswith()\n#include \"pycore_call.h\"          // _PyObject_CallNoArgs()\n#include \"pycore_format.h\"        // F_LJUST\n#include \"pycore_global_objects.h\"  // _Py_GET_GLOBAL_OBJECT()\n#include \"pycore_initconfig.h\"    // _PyStatus_OK()\n#include \"pycore_long.h\"          // _PyLong_DigitValue\n#include \"pycore_object.h\"        // _PyObject_GC_TRACK\n#include \"pycore_pymem.h\"         // PYMEM_CLEANBYTE\n#include \"pycore_strhex.h\"        // _Py_strhex_with_sep()\n\n#include <stddef.h>\n\n/*[clinic input]\nclass bytes \"PyBytesObject *\" \"&PyBytes_Type\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=7a238f965d64892b]*/\n\n#include \"clinic/bytesobject.c.h\"\n\n/* PyBytesObject_SIZE gives the basic size of a bytes object; any memory allocation\n   for a bytes object of length n should request PyBytesObject_SIZE + n bytes.\n\n   Using PyBytesObject_SIZE instead of sizeof(PyBytesObject) saves\n   3 or 7 bytes per bytes object allocation on a typical system.\n*/\n#define PyBytesObject_SIZE (offsetof(PyBytesObject, ob_sval) + 1)\n\n/* Forward declaration */\nPy_LOCAL_INLINE(Py_ssize_t) _PyBytesWriter_GetSize(_PyBytesWriter *writer,\n                                                   char *str);\n\n\n#define CHARACTERS _Py_SINGLETON(bytes_characters)\n#define CHARACTER(ch) \\\n     ((PyBytesObject *)&(CHARACTERS[ch]));\n#define EMPTY (&_Py_SINGLETON(bytes_empty))\n\n\n// Return a borrowed reference to the empty bytes string singleton.\nstatic inline PyObject* bytes_get_empty(void)\n{\n    return &EMPTY->ob_base.ob_base;\n}\n\n\n// Return a strong reference to the empty bytes string singleton.\nstatic inline PyObject* bytes_new_empty(void)\n{\n    return Py_NewRef(EMPTY);\n}\n\n\n/*\n   For PyBytes_FromString(), the parameter `str' points to a null-terminated\n   string containing exactly `size' bytes.\n\n   For PyBytes_FromStringAndSize(), the parameter `str' is\n   either NULL or else points to a string containing at least `size' bytes.\n   For PyBytes_FromStringAndSize(), the string in the `str' parameter does\n   not have to be null-terminated.  (Therefore it is safe to construct a\n   substring by calling `PyBytes_FromStringAndSize(origstring, substrlen)'.)\n   If `str' is NULL then PyBytes_FromStringAndSize() will allocate `size+1'\n   bytes (setting the last byte to the null terminating character) and you can\n   fill in the data yourself.  If `str' is non-NULL then the resulting\n   PyBytes object must be treated as immutable and you must not fill in nor\n   alter the data yourself, since the strings may be shared.\n\n   The PyObject member `op->ob_size', which denotes the number of \"extra\n   items\" in a variable-size object, will contain the number of bytes\n   allocated for string data, not counting the null terminating character.\n   It is therefore equal to the `size' parameter (for\n   PyBytes_FromStringAndSize()) or the length of the string in the `str'\n   parameter (for PyBytes_FromString()).\n*/\nstatic PyObject *\n_PyBytes_FromSize(Py_ssize_t size, int use_calloc)\n{\n    PyBytesObject *op;\n    assert(size >= 0);\n\n    if (size == 0) {\n        return bytes_new_empty();\n    }\n\n    if ((size_t)size > (size_t)PY_SSIZE_T_MAX - PyBytesObject_SIZE) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"byte string is too large\");\n        return NULL;\n    }\n\n    /* Inline PyObject_NewVar */\n    if (use_calloc)\n        op = (PyBytesObject *)PyObject_Calloc(1, PyBytesObject_SIZE + size);\n    else\n        op = (PyBytesObject *)PyObject_Malloc(PyBytesObject_SIZE + size);\n    if (op == NULL) {\n        return PyErr_NoMemory();\n    }\n    _PyObject_InitVar((PyVarObject*)op, &PyBytes_Type, size);\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n    op->ob_shash = -1;\n_Py_COMP_DIAG_POP\n    if (!use_calloc) {\n        op->ob_sval[size] = '\\0';\n    }\n    return (PyObject *) op;\n}\n\nPyObject *\nPyBytes_FromStringAndSize(const char *str, Py_ssize_t size)\n{\n    PyBytesObject *op;\n    if (size < 0) {\n        PyErr_SetString(PyExc_SystemError,\n            \"Negative size passed to PyBytes_FromStringAndSize\");\n        return NULL;\n    }\n    if (size == 1 && str != NULL) {\n        op = CHARACTER(*str & 255);\n        return Py_NewRef(op);\n    }\n    if (size == 0) {\n        return bytes_new_empty();\n    }\n\n    op = (PyBytesObject *)_PyBytes_FromSize(size, 0);\n    if (op == NULL)\n        return NULL;\n    if (str == NULL)\n        return (PyObject *) op;\n\n    memcpy(op->ob_sval, str, size);\n    return (PyObject *) op;\n}\n\nPyObject *\nPyBytes_FromString(const char *str)\n{\n    size_t size;\n    PyBytesObject *op;\n\n    assert(str != NULL);\n    size = strlen(str);\n    if (size > PY_SSIZE_T_MAX - PyBytesObject_SIZE) {\n        PyErr_SetString(PyExc_OverflowError,\n            \"byte string is too long\");\n        return NULL;\n    }\n\n    if (size == 0) {\n        return bytes_new_empty();\n    }\n    else if (size == 1) {\n        op = CHARACTER(*str & 255);\n        return Py_NewRef(op);\n    }\n\n    /* Inline PyObject_NewVar */\n    op = (PyBytesObject *)PyObject_Malloc(PyBytesObject_SIZE + size);\n    if (op == NULL) {\n        return PyErr_NoMemory();\n    }\n    _PyObject_InitVar((PyVarObject*)op, &PyBytes_Type, size);\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n    op->ob_shash = -1;\n_Py_COMP_DIAG_POP\n    memcpy(op->ob_sval, str, size+1);\n    return (PyObject *) op;\n}\n\nPyObject *\nPyBytes_FromFormatV(const char *format, va_list vargs)\n{\n    char *s;\n    const char *f;\n    const char *p;\n    Py_ssize_t prec;\n    int longflag;\n    int size_tflag;\n    /* Longest 64-bit formatted numbers:\n       - \"18446744073709551615\\0\" (21 bytes)\n       - \"-9223372036854775808\\0\" (21 bytes)\n       Decimal takes the most space (it isn't enough for octal.)\n\n       Longest 64-bit pointer representation:\n       \"0xffffffffffffffff\\0\" (19 bytes). */\n    char buffer[21];\n    _PyBytesWriter writer;\n\n    _PyBytesWriter_Init(&writer);\n\n    s = _PyBytesWriter_Alloc(&writer, strlen(format));\n    if (s == NULL)\n        return NULL;\n    writer.overallocate = 1;\n\n#define WRITE_BYTES(str) \\\n    do { \\\n        s = _PyBytesWriter_WriteBytes(&writer, s, (str), strlen(str)); \\\n        if (s == NULL) \\\n            goto error; \\\n    } while (0)\n\n    for (f = format; *f; f++) {\n        if (*f != '%') {\n            *s++ = *f;\n            continue;\n        }\n\n        p = f++;\n\n        /* ignore the width (ex: 10 in \"%10s\") */\n        while (Py_ISDIGIT(*f))\n            f++;\n\n        /* parse the precision (ex: 10 in \"%.10s\") */\n        prec = 0;\n        if (*f == '.') {\n            f++;\n            for (; Py_ISDIGIT(*f); f++) {\n                prec = (prec * 10) + (*f - '0');\n            }\n        }\n\n        while (*f && *f != '%' && !Py_ISALPHA(*f))\n            f++;\n\n        /* handle the long flag ('l'), but only for %ld and %lu.\n           others can be added when necessary. */\n        longflag = 0;\n        if (*f == 'l' && (f[1] == 'd' || f[1] == 'u')) {\n            longflag = 1;\n            ++f;\n        }\n\n        /* handle the size_t flag ('z'). */\n        size_tflag = 0;\n        if (*f == 'z' && (f[1] == 'd' || f[1] == 'u')) {\n            size_tflag = 1;\n            ++f;\n        }\n\n        /* subtract bytes preallocated for the format string\n           (ex: 2 for \"%s\") */\n        writer.min_size -= (f - p + 1);\n\n        switch (*f) {\n        case 'c':\n        {\n            int c = va_arg(vargs, int);\n            if (c < 0 || c > 255) {\n                PyErr_SetString(PyExc_OverflowError,\n                                \"PyBytes_FromFormatV(): %c format \"\n                                \"expects an integer in range [0; 255]\");\n                goto error;\n            }\n            writer.min_size++;\n            *s++ = (unsigned char)c;\n            break;\n        }\n\n        case 'd':\n            if (longflag) {\n                sprintf(buffer, \"%ld\", va_arg(vargs, long));\n            }\n            else if (size_tflag) {\n                sprintf(buffer, \"%zd\", va_arg(vargs, Py_ssize_t));\n            }\n            else {\n                sprintf(buffer, \"%d\", va_arg(vargs, int));\n            }\n            assert(strlen(buffer) < sizeof(buffer));\n            WRITE_BYTES(buffer);\n            break;\n\n        case 'u':\n            if (longflag) {\n                sprintf(buffer, \"%lu\", va_arg(vargs, unsigned long));\n            }\n            else if (size_tflag) {\n                sprintf(buffer, \"%zu\", va_arg(vargs, size_t));\n            }\n            else {\n                sprintf(buffer, \"%u\", va_arg(vargs, unsigned int));\n            }\n            assert(strlen(buffer) < sizeof(buffer));\n            WRITE_BYTES(buffer);\n            break;\n\n        case 'i':\n            sprintf(buffer, \"%i\", va_arg(vargs, int));\n            assert(strlen(buffer) < sizeof(buffer));\n            WRITE_BYTES(buffer);\n            break;\n\n        case 'x':\n            sprintf(buffer, \"%x\", va_arg(vargs, int));\n            assert(strlen(buffer) < sizeof(buffer));\n            WRITE_BYTES(buffer);\n            break;\n\n        case 's':\n        {\n            Py_ssize_t i;\n\n            p = va_arg(vargs, const char*);\n            if (prec <= 0) {\n                i = strlen(p);\n            }\n            else {\n                i = 0;\n                while (i < prec && p[i]) {\n                    i++;\n                }\n            }\n            s = _PyBytesWriter_WriteBytes(&writer, s, p, i);\n            if (s == NULL)\n                goto error;\n            break;\n        }\n\n        case 'p':\n            sprintf(buffer, \"%p\", va_arg(vargs, void*));\n            assert(strlen(buffer) < sizeof(buffer));\n            /* %p is ill-defined:  ensure leading 0x. */\n            if (buffer[1] == 'X')\n                buffer[1] = 'x';\n            else if (buffer[1] != 'x') {\n                memmove(buffer+2, buffer, strlen(buffer)+1);\n                buffer[0] = '0';\n                buffer[1] = 'x';\n            }\n            WRITE_BYTES(buffer);\n            break;\n\n        case '%':\n            writer.min_size++;\n            *s++ = '%';\n            break;\n\n        default:\n            if (*f == 0) {\n                /* fix min_size if we reached the end of the format string */\n                writer.min_size++;\n            }\n\n            /* invalid format string: copy unformatted string and exit */\n            WRITE_BYTES(p);\n            return _PyBytesWriter_Finish(&writer, s);\n        }\n    }\n\n#undef WRITE_BYTES\n\n    return _PyBytesWriter_Finish(&writer, s);\n\n error:\n    _PyBytesWriter_Dealloc(&writer);\n    return NULL;\n}\n\nPyObject *\nPyBytes_FromFormat(const char *format, ...)\n{\n    PyObject* ret;\n    va_list vargs;\n\n    va_start(vargs, format);\n    ret = PyBytes_FromFormatV(format, vargs);\n    va_end(vargs);\n    return ret;\n}\n\n/* Helpers for formatstring */\n\nPy_LOCAL_INLINE(PyObject *)\ngetnextarg(PyObject *args, Py_ssize_t arglen, Py_ssize_t *p_argidx)\n{\n    Py_ssize_t argidx = *p_argidx;\n    if (argidx < arglen) {\n        (*p_argidx)++;\n        if (arglen < 0)\n            return args;\n        else\n            return PyTuple_GetItem(args, argidx);\n    }\n    PyErr_SetString(PyExc_TypeError,\n                    \"not enough arguments for format string\");\n    return NULL;\n}\n\n/* Returns a new reference to a PyBytes object, or NULL on failure. */\n\nstatic char*\nformatfloat(PyObject *v, int flags, int prec, int type,\n            PyObject **p_result, _PyBytesWriter *writer, char *str)\n{\n    char *p;\n    PyObject *result;\n    double x;\n    size_t len;\n    int dtoa_flags = 0;\n\n    x = PyFloat_AsDouble(v);\n    if (x == -1.0 && PyErr_Occurred()) {\n        PyErr_Format(PyExc_TypeError, \"float argument required, \"\n                     \"not %.200s\", Py_TYPE(v)->tp_name);\n        return NULL;\n    }\n\n    if (prec < 0)\n        prec = 6;\n\n    if (flags & F_ALT) {\n        dtoa_flags |= Py_DTSF_ALT;\n    }\n    p = PyOS_double_to_string(x, type, prec, dtoa_flags, NULL);\n\n    if (p == NULL)\n        return NULL;\n\n    len = strlen(p);\n    if (writer != NULL) {\n        str = _PyBytesWriter_Prepare(writer, str, len);\n        if (str == NULL) {\n            PyMem_Free(p);\n            return NULL;\n        }\n        memcpy(str, p, len);\n        PyMem_Free(p);\n        str += len;\n        return str;\n    }\n\n    result = PyBytes_FromStringAndSize(p, len);\n    PyMem_Free(p);\n    *p_result = result;\n    return result != NULL ? str : NULL;\n}\n\nstatic PyObject *\nformatlong(PyObject *v, int flags, int prec, int type)\n{\n    PyObject *result, *iobj;\n    if (type == 'i')\n        type = 'd';\n    if (PyLong_Check(v))\n        return _PyUnicode_FormatLong(v, flags & F_ALT, prec, type);\n    if (PyNumber_Check(v)) {\n        /* make sure number is a type of integer for o, x, and X */\n        if (type == 'o' || type == 'x' || type == 'X')\n            iobj = _PyNumber_Index(v);\n        else\n            iobj = PyNumber_Long(v);\n        if (iobj != NULL) {\n            assert(PyLong_Check(iobj));\n            result = _PyUnicode_FormatLong(iobj, flags & F_ALT, prec, type);\n            Py_DECREF(iobj);\n            return result;\n        }\n        if (!PyErr_ExceptionMatches(PyExc_TypeError))\n            return NULL;\n    }\n    PyErr_Format(PyExc_TypeError,\n        \"%%%c format: %s is required, not %.200s\", type,\n        (type == 'o' || type == 'x' || type == 'X') ? \"an integer\"\n                                                    : \"a real number\",\n        Py_TYPE(v)->tp_name);\n    return NULL;\n}\n\nstatic int\nbyte_converter(PyObject *arg, char *p)\n{\n    if (PyBytes_Check(arg) && PyBytes_GET_SIZE(arg) == 1) {\n        *p = PyBytes_AS_STRING(arg)[0];\n        return 1;\n    }\n    else if (PyByteArray_Check(arg) && PyByteArray_GET_SIZE(arg) == 1) {\n        *p = PyByteArray_AS_STRING(arg)[0];\n        return 1;\n    }\n    else {\n        int overflow;\n        long ival = PyLong_AsLongAndOverflow(arg, &overflow);\n        if (ival == -1 && PyErr_Occurred()) {\n            if (PyErr_ExceptionMatches(PyExc_TypeError)) {\n                goto onError;\n            }\n            return 0;\n        }\n        if (!(0 <= ival && ival <= 255)) {\n            /* this includes an overflow in converting to C long */\n            PyErr_SetString(PyExc_OverflowError,\n                            \"%c arg not in range(256)\");\n            return 0;\n        }\n        *p = (char)ival;\n        return 1;\n    }\n  onError:\n    PyErr_SetString(PyExc_TypeError,\n        \"%c requires an integer in range(256) or a single byte\");\n    return 0;\n}\n\nstatic PyObject *_PyBytes_FromBuffer(PyObject *x);\n\nstatic PyObject *\nformat_obj(PyObject *v, const char **pbuf, Py_ssize_t *plen)\n{\n    PyObject *func, *result;\n    /* is it a bytes object? */\n    if (PyBytes_Check(v)) {\n        *pbuf = PyBytes_AS_STRING(v);\n        *plen = PyBytes_GET_SIZE(v);\n        return Py_NewRef(v);\n    }\n    if (PyByteArray_Check(v)) {\n        *pbuf = PyByteArray_AS_STRING(v);\n        *plen = PyByteArray_GET_SIZE(v);\n        return Py_NewRef(v);\n    }\n    /* does it support __bytes__? */\n    func = _PyObject_LookupSpecial(v, &_Py_ID(__bytes__));\n    if (func != NULL) {\n        result = _PyObject_CallNoArgs(func);\n        Py_DECREF(func);\n        if (result == NULL)\n            return NULL;\n        if (!PyBytes_Check(result)) {\n            PyErr_Format(PyExc_TypeError,\n                         \"__bytes__ returned non-bytes (type %.200s)\",\n                         Py_TYPE(result)->tp_name);\n            Py_DECREF(result);\n            return NULL;\n        }\n        *pbuf = PyBytes_AS_STRING(result);\n        *plen = PyBytes_GET_SIZE(result);\n        return result;\n    }\n    /* does it support buffer protocol? */\n    if (PyObject_CheckBuffer(v)) {\n        /* maybe we can avoid making a copy of the buffer object here? */\n        result = _PyBytes_FromBuffer(v);\n        if (result == NULL)\n            return NULL;\n        *pbuf = PyBytes_AS_STRING(result);\n        *plen = PyBytes_GET_SIZE(result);\n        return result;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"%%b requires a bytes-like object, \"\n                 \"or an object that implements __bytes__, not '%.100s'\",\n                 Py_TYPE(v)->tp_name);\n    return NULL;\n}\n\n/* fmt%(v1,v2,...) is roughly equivalent to sprintf(fmt, v1, v2, ...) */\n\nPyObject *\n_PyBytes_FormatEx(const char *format, Py_ssize_t format_len,\n                  PyObject *args, int use_bytearray)\n{\n    const char *fmt;\n    char *res;\n    Py_ssize_t arglen, argidx;\n    Py_ssize_t fmtcnt;\n    int args_owned = 0;\n    PyObject *dict = NULL;\n    _PyBytesWriter writer;\n\n    if (args == NULL) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n    fmt = format;\n    fmtcnt = format_len;\n\n    _PyBytesWriter_Init(&writer);\n    writer.use_bytearray = use_bytearray;\n\n    res = _PyBytesWriter_Alloc(&writer, fmtcnt);\n    if (res == NULL)\n        return NULL;\n    if (!use_bytearray)\n        writer.overallocate = 1;\n\n    if (PyTuple_Check(args)) {\n        arglen = PyTuple_GET_SIZE(args);\n        argidx = 0;\n    }\n    else {\n        arglen = -1;\n        argidx = -2;\n    }\n    if (Py_TYPE(args)->tp_as_mapping && Py_TYPE(args)->tp_as_mapping->mp_subscript &&\n        !PyTuple_Check(args) && !PyBytes_Check(args) && !PyUnicode_Check(args) &&\n        !PyByteArray_Check(args)) {\n            dict = args;\n    }\n\n    while (--fmtcnt >= 0) {\n        if (*fmt != '%') {\n            Py_ssize_t len;\n            char *pos;\n\n            pos = (char *)memchr(fmt + 1, '%', fmtcnt);\n            if (pos != NULL)\n                len = pos - fmt;\n            else\n                len = fmtcnt + 1;\n            assert(len != 0);\n\n            memcpy(res, fmt, len);\n            res += len;\n            fmt += len;\n            fmtcnt -= (len - 1);\n        }\n        else {\n            /* Got a format specifier */\n            int flags = 0;\n            Py_ssize_t width = -1;\n            int prec = -1;\n            int c = '\\0';\n            int fill;\n            PyObject *v = NULL;\n            PyObject *temp = NULL;\n            const char *pbuf = NULL;\n            int sign;\n            Py_ssize_t len = 0;\n            char onechar; /* For byte_converter() */\n            Py_ssize_t alloc;\n\n            fmt++;\n            if (*fmt == '%') {\n                *res++ = '%';\n                fmt++;\n                fmtcnt--;\n                continue;\n            }\n            if (*fmt == '(') {\n                const char *keystart;\n                Py_ssize_t keylen;\n                PyObject *key;\n                int pcount = 1;\n\n                if (dict == NULL) {\n                    PyErr_SetString(PyExc_TypeError,\n                             \"format requires a mapping\");\n                    goto error;\n                }\n                ++fmt;\n                --fmtcnt;\n                keystart = fmt;\n                /* Skip over balanced parentheses */\n                while (pcount > 0 && --fmtcnt >= 0) {\n                    if (*fmt == ')')\n                        --pcount;\n                    else if (*fmt == '(')\n                        ++pcount;\n                    fmt++;\n                }\n                keylen = fmt - keystart - 1;\n                if (fmtcnt < 0 || pcount > 0) {\n                    PyErr_SetString(PyExc_ValueError,\n                               \"incomplete format key\");\n                    goto error;\n                }\n                key = PyBytes_FromStringAndSize(keystart,\n                                                 keylen);\n                if (key == NULL)\n                    goto error;\n                if (args_owned) {\n                    Py_DECREF(args);\n                    args_owned = 0;\n                }\n                args = PyObject_GetItem(dict, key);\n                Py_DECREF(key);\n                if (args == NULL) {\n                    goto error;\n                }\n                args_owned = 1;\n                arglen = -1;\n                argidx = -2;\n            }\n\n            /* Parse flags. Example: \"%+i\" => flags=F_SIGN. */\n            while (--fmtcnt >= 0) {\n                switch (c = *fmt++) {\n                case '-': flags |= F_LJUST; continue;\n                case '+': flags |= F_SIGN; continue;\n                case ' ': flags |= F_BLANK; continue;\n                case '#': flags |= F_ALT; continue;\n                case '0': flags |= F_ZERO; continue;\n                }\n                break;\n            }\n\n            /* Parse width. Example: \"%10s\" => width=10 */\n            if (c == '*') {\n                v = getnextarg(args, arglen, &argidx);\n                if (v == NULL)\n                    goto error;\n                if (!PyLong_Check(v)) {\n                    PyErr_SetString(PyExc_TypeError,\n                                    \"* wants int\");\n                    goto error;\n                }\n                width = PyLong_AsSsize_t(v);\n                if (width == -1 && PyErr_Occurred())\n                    goto error;\n                if (width < 0) {\n                    flags |= F_LJUST;\n                    width = -width;\n                }\n                if (--fmtcnt >= 0)\n                    c = *fmt++;\n            }\n            else if (c >= 0 && isdigit(c)) {\n                width = c - '0';\n                while (--fmtcnt >= 0) {\n                    c = Py_CHARMASK(*fmt++);\n                    if (!isdigit(c))\n                        break;\n                    if (width > (PY_SSIZE_T_MAX - ((int)c - '0')) / 10) {\n                        PyErr_SetString(\n                            PyExc_ValueError,\n                            \"width too big\");\n                        goto error;\n                    }\n                    width = width*10 + (c - '0');\n                }\n            }\n\n            /* Parse precision. Example: \"%.3f\" => prec=3 */\n            if (c == '.') {\n                prec = 0;\n                if (--fmtcnt >= 0)\n                    c = *fmt++;\n                if (c == '*') {\n                    v = getnextarg(args, arglen, &argidx);\n                    if (v == NULL)\n                        goto error;\n                    if (!PyLong_Check(v)) {\n                        PyErr_SetString(\n                            PyExc_TypeError,\n                            \"* wants int\");\n                        goto error;\n                    }\n                    prec = _PyLong_AsInt(v);\n                    if (prec == -1 && PyErr_Occurred())\n                        goto error;\n                    if (prec < 0)\n                        prec = 0;\n                    if (--fmtcnt >= 0)\n                        c = *fmt++;\n                }\n                else if (c >= 0 && isdigit(c)) {\n                    prec = c - '0';\n                    while (--fmtcnt >= 0) {\n                        c = Py_CHARMASK(*fmt++);\n                        if (!isdigit(c))\n                            break;\n                        if (prec > (INT_MAX - ((int)c - '0')) / 10) {\n                            PyErr_SetString(\n                                PyExc_ValueError,\n                                \"prec too big\");\n                            goto error;\n                        }\n                        prec = prec*10 + (c - '0');\n                    }\n                }\n            } /* prec */\n            if (fmtcnt >= 0) {\n                if (c == 'h' || c == 'l' || c == 'L') {\n                    if (--fmtcnt >= 0)\n                        c = *fmt++;\n                }\n            }\n            if (fmtcnt < 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"incomplete format\");\n                goto error;\n            }\n            v = getnextarg(args, arglen, &argidx);\n            if (v == NULL)\n                goto error;\n\n            if (fmtcnt == 0) {\n                /* last write: disable writer overallocation */\n                writer.overallocate = 0;\n            }\n\n            sign = 0;\n            fill = ' ';\n            switch (c) {\n            case 'r':\n                // %r is only for 2/3 code; 3 only code should use %a\n            case 'a':\n                temp = PyObject_ASCII(v);\n                if (temp == NULL)\n                    goto error;\n                assert(PyUnicode_IS_ASCII(temp));\n                pbuf = (const char *)PyUnicode_1BYTE_DATA(temp);\n                len = PyUnicode_GET_LENGTH(temp);\n                if (prec >= 0 && len > prec)\n                    len = prec;\n                break;\n\n            case 's':\n                // %s is only for 2/3 code; 3 only code should use %b\n            case 'b':\n                temp = format_obj(v, &pbuf, &len);\n                if (temp == NULL)\n                    goto error;\n                if (prec >= 0 && len > prec)\n                    len = prec;\n                break;\n\n            case 'i':\n            case 'd':\n            case 'u':\n            case 'o':\n            case 'x':\n            case 'X':\n                if (PyLong_CheckExact(v)\n                    && width == -1 && prec == -1\n                    && !(flags & (F_SIGN | F_BLANK))\n                    && c != 'X')\n                {\n                    /* Fast path */\n                    int alternate = flags & F_ALT;\n                    int base;\n\n                    switch(c)\n                    {\n                        default:\n                            Py_UNREACHABLE();\n                        case 'd':\n                        case 'i':\n                        case 'u':\n                            base = 10;\n                            break;\n                        case 'o':\n                            base = 8;\n                            break;\n                        case 'x':\n                        case 'X':\n                            base = 16;\n                            break;\n                    }\n\n                    /* Fast path */\n                    writer.min_size -= 2; /* size preallocated for \"%d\" */\n                    res = _PyLong_FormatBytesWriter(&writer, res,\n                                                    v, base, alternate);\n                    if (res == NULL)\n                        goto error;\n                    continue;\n                }\n\n                temp = formatlong(v, flags, prec, c);\n                if (!temp)\n                    goto error;\n                assert(PyUnicode_IS_ASCII(temp));\n                pbuf = (const char *)PyUnicode_1BYTE_DATA(temp);\n                len = PyUnicode_GET_LENGTH(temp);\n                sign = 1;\n                if (flags & F_ZERO)\n                    fill = '0';\n                break;\n\n            case 'e':\n            case 'E':\n            case 'f':\n            case 'F':\n            case 'g':\n            case 'G':\n                if (width == -1 && prec == -1\n                    && !(flags & (F_SIGN | F_BLANK)))\n                {\n                    /* Fast path */\n                    writer.min_size -= 2; /* size preallocated for \"%f\" */\n                    res = formatfloat(v, flags, prec, c, NULL, &writer, res);\n                    if (res == NULL)\n                        goto error;\n                    continue;\n                }\n\n                if (!formatfloat(v, flags, prec, c, &temp, NULL, res))\n                    goto error;\n                pbuf = PyBytes_AS_STRING(temp);\n                len = PyBytes_GET_SIZE(temp);\n                sign = 1;\n                if (flags & F_ZERO)\n                    fill = '0';\n                break;\n\n            case 'c':\n                pbuf = &onechar;\n                len = byte_converter(v, &onechar);\n                if (!len)\n                    goto error;\n                if (width == -1) {\n                    /* Fast path */\n                    *res++ = onechar;\n                    continue;\n                }\n                break;\n\n            default:\n                PyErr_Format(PyExc_ValueError,\n                  \"unsupported format character '%c' (0x%x) \"\n                  \"at index %zd\",\n                  c, c,\n                  (Py_ssize_t)(fmt - 1 - format));\n                goto error;\n            }\n\n            if (sign) {\n                if (*pbuf == '-' || *pbuf == '+') {\n                    sign = *pbuf++;\n                    len--;\n                }\n                else if (flags & F_SIGN)\n                    sign = '+';\n                else if (flags & F_BLANK)\n                    sign = ' ';\n                else\n                    sign = 0;\n            }\n            if (width < len)\n                width = len;\n\n            alloc = width;\n            if (sign != 0 && len == width)\n                alloc++;\n            /* 2: size preallocated for %s */\n            if (alloc > 2) {\n                res = _PyBytesWriter_Prepare(&writer, res, alloc - 2);\n                if (res == NULL)\n                    goto error;\n            }\n#ifndef NDEBUG\n            char *before = res;\n#endif\n\n            /* Write the sign if needed */\n            if (sign) {\n                if (fill != ' ')\n                    *res++ = sign;\n                if (width > len)\n                    width--;\n            }\n\n            /* Write the numeric prefix for \"x\", \"X\" and \"o\" formats\n               if the alternate form is used.\n               For example, write \"0x\" for the \"%#x\" format. */\n            if ((flags & F_ALT) && (c == 'o' || c == 'x' || c == 'X')) {\n                assert(pbuf[0] == '0');\n                assert(pbuf[1] == c);\n                if (fill != ' ') {\n                    *res++ = *pbuf++;\n                    *res++ = *pbuf++;\n                }\n                width -= 2;\n                if (width < 0)\n                    width = 0;\n                len -= 2;\n            }\n\n            /* Pad left with the fill character if needed */\n            if (width > len && !(flags & F_LJUST)) {\n                memset(res, fill, width - len);\n                res += (width - len);\n                width = len;\n            }\n\n            /* If padding with spaces: write sign if needed and/or numeric\n               prefix if the alternate form is used */\n            if (fill == ' ') {\n                if (sign)\n                    *res++ = sign;\n                if ((flags & F_ALT) && (c == 'o' || c == 'x' || c == 'X')) {\n                    assert(pbuf[0] == '0');\n                    assert(pbuf[1] == c);\n                    *res++ = *pbuf++;\n                    *res++ = *pbuf++;\n                }\n            }\n\n            /* Copy bytes */\n            memcpy(res, pbuf, len);\n            res += len;\n\n            /* Pad right with the fill character if needed */\n            if (width > len) {\n                memset(res, ' ', width - len);\n                res += (width - len);\n            }\n\n            if (dict && (argidx < arglen)) {\n                PyErr_SetString(PyExc_TypeError,\n                           \"not all arguments converted during bytes formatting\");\n                Py_XDECREF(temp);\n                goto error;\n            }\n            Py_XDECREF(temp);\n\n#ifndef NDEBUG\n            /* check that we computed the exact size for this write */\n            assert((res - before) == alloc);\n#endif\n        } /* '%' */\n\n        /* If overallocation was disabled, ensure that it was the last\n           write. Otherwise, we missed an optimization */\n        assert(writer.overallocate || fmtcnt == 0 || use_bytearray);\n    } /* until end */\n\n    if (argidx < arglen && !dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"not all arguments converted during bytes formatting\");\n        goto error;\n    }\n\n    if (args_owned) {\n        Py_DECREF(args);\n    }\n    return _PyBytesWriter_Finish(&writer, res);\n\n error:\n    _PyBytesWriter_Dealloc(&writer);\n    if (args_owned) {\n        Py_DECREF(args);\n    }\n    return NULL;\n}\n\n/* Unescape a backslash-escaped string. */\nPyObject *_PyBytes_DecodeEscape(const char *s,\n                                Py_ssize_t len,\n                                const char *errors,\n                                const char **first_invalid_escape)\n{\n    int c;\n    char *p;\n    const char *end;\n    _PyBytesWriter writer;\n\n    _PyBytesWriter_Init(&writer);\n\n    p = _PyBytesWriter_Alloc(&writer, len);\n    if (p == NULL)\n        return NULL;\n    writer.overallocate = 1;\n\n    *first_invalid_escape = NULL;\n\n    end = s + len;\n    while (s < end) {\n        if (*s != '\\\\') {\n            *p++ = *s++;\n            continue;\n        }\n\n        s++;\n        if (s == end) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"Trailing \\\\ in string\");\n            goto failed;\n        }\n\n        switch (*s++) {\n        /* XXX This assumes ASCII! */\n        case '\\n': break;\n        case '\\\\': *p++ = '\\\\'; break;\n        case '\\'': *p++ = '\\''; break;\n        case '\\\"': *p++ = '\\\"'; break;\n        case 'b': *p++ = '\\b'; break;\n        case 'f': *p++ = '\\014'; break; /* FF */\n        case 't': *p++ = '\\t'; break;\n        case 'n': *p++ = '\\n'; break;\n        case 'r': *p++ = '\\r'; break;\n        case 'v': *p++ = '\\013'; break; /* VT */\n        case 'a': *p++ = '\\007'; break; /* BEL, not classic C */\n        case '0': case '1': case '2': case '3':\n        case '4': case '5': case '6': case '7':\n            c = s[-1] - '0';\n            if (s < end && '0' <= *s && *s <= '7') {\n                c = (c<<3) + *s++ - '0';\n                if (s < end && '0' <= *s && *s <= '7')\n                    c = (c<<3) + *s++ - '0';\n            }\n            if (c > 0377) {\n                if (*first_invalid_escape == NULL) {\n                    *first_invalid_escape = s-3; /* Back up 3 chars, since we've\n                                                    already incremented s. */\n                }\n            }\n            *p++ = c;\n            break;\n        case 'x':\n            if (s+1 < end) {\n                int digit1, digit2;\n                digit1 = _PyLong_DigitValue[Py_CHARMASK(s[0])];\n                digit2 = _PyLong_DigitValue[Py_CHARMASK(s[1])];\n                if (digit1 < 16 && digit2 < 16) {\n                    *p++ = (unsigned char)((digit1 << 4) + digit2);\n                    s += 2;\n                    break;\n                }\n            }\n            /* invalid hexadecimal digits */\n\n            if (!errors || strcmp(errors, \"strict\") == 0) {\n                PyErr_Format(PyExc_ValueError,\n                             \"invalid \\\\x escape at position %zd\",\n                             s - 2 - (end - len));\n                goto failed;\n            }\n            if (strcmp(errors, \"replace\") == 0) {\n                *p++ = '?';\n            } else if (strcmp(errors, \"ignore\") == 0)\n                /* do nothing */;\n            else {\n                PyErr_Format(PyExc_ValueError,\n                             \"decoding error; unknown \"\n                             \"error handling code: %.400s\",\n                             errors);\n                goto failed;\n            }\n            /* skip \\x */\n            if (s < end && Py_ISXDIGIT(s[0]))\n                s++; /* and a hexdigit */\n            break;\n\n        default:\n            if (*first_invalid_escape == NULL) {\n                *first_invalid_escape = s-1; /* Back up one char, since we've\n                                                already incremented s. */\n            }\n            *p++ = '\\\\';\n            s--;\n        }\n    }\n\n    return _PyBytesWriter_Finish(&writer, p);\n\n  failed:\n    _PyBytesWriter_Dealloc(&writer);\n    return NULL;\n}\n\nPyObject *PyBytes_DecodeEscape(const char *s,\n                                Py_ssize_t len,\n                                const char *errors,\n                                Py_ssize_t Py_UNUSED(unicode),\n                                const char *Py_UNUSED(recode_encoding))\n{\n    const char* first_invalid_escape;\n    PyObject *result = _PyBytes_DecodeEscape(s, len, errors,\n                                             &first_invalid_escape);\n    if (result == NULL)\n        return NULL;\n    if (first_invalid_escape != NULL) {\n        unsigned char c = *first_invalid_escape;\n        if ('4' <= c && c <= '7') {\n            if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,\n                                 \"invalid octal escape sequence '\\\\%.3s'\",\n                                 first_invalid_escape) < 0)\n            {\n                Py_DECREF(result);\n                return NULL;\n            }\n        }\n        else {\n            if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,\n                                 \"invalid escape sequence '\\\\%c'\",\n                                 c) < 0)\n            {\n                Py_DECREF(result);\n                return NULL;\n            }\n        }\n    }\n    return result;\n\n}\n/* -------------------------------------------------------------------- */\n/* object api */\n\nPy_ssize_t\nPyBytes_Size(PyObject *op)\n{\n    if (!PyBytes_Check(op)) {\n        PyErr_Format(PyExc_TypeError,\n             \"expected bytes, %.200s found\", Py_TYPE(op)->tp_name);\n        return -1;\n    }\n    return Py_SIZE(op);\n}\n\nchar *\nPyBytes_AsString(PyObject *op)\n{\n    if (!PyBytes_Check(op)) {\n        PyErr_Format(PyExc_TypeError,\n             \"expected bytes, %.200s found\", Py_TYPE(op)->tp_name);\n        return NULL;\n    }\n    return ((PyBytesObject *)op)->ob_sval;\n}\n\nint\nPyBytes_AsStringAndSize(PyObject *obj,\n                         char **s,\n                         Py_ssize_t *len)\n{\n    if (s == NULL) {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n\n    if (!PyBytes_Check(obj)) {\n        PyErr_Format(PyExc_TypeError,\n             \"expected bytes, %.200s found\", Py_TYPE(obj)->tp_name);\n        return -1;\n    }\n\n    *s = PyBytes_AS_STRING(obj);\n    if (len != NULL)\n        *len = PyBytes_GET_SIZE(obj);\n    else if (strlen(*s) != (size_t)PyBytes_GET_SIZE(obj)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"embedded null byte\");\n        return -1;\n    }\n    return 0;\n}\n\n/* -------------------------------------------------------------------- */\n/* Methods */\n\n#define STRINGLIB_GET_EMPTY() bytes_get_empty()\n\n#include \"stringlib/stringdefs.h\"\n#define STRINGLIB_MUTABLE 0\n\n#include \"stringlib/fastsearch.h\"\n#include \"stringlib/count.h\"\n#include \"stringlib/find.h\"\n#include \"stringlib/join.h\"\n#include \"stringlib/partition.h\"\n#include \"stringlib/split.h\"\n#include \"stringlib/ctype.h\"\n\n#include \"stringlib/transmogrify.h\"\n\n#undef STRINGLIB_GET_EMPTY\n\nPy_ssize_t\n_PyBytes_Find(const char *haystack, Py_ssize_t len_haystack,\n              const char *needle, Py_ssize_t len_needle,\n              Py_ssize_t offset)\n{\n    assert(len_haystack >= 0);\n    assert(len_needle >= 0);\n    // Extra checks because stringlib_find accesses haystack[len_haystack].\n    if (len_needle == 0) {\n        return offset;\n    }\n    if (len_needle > len_haystack) {\n        return -1;\n    }\n    assert(len_haystack >= 1);\n    Py_ssize_t res = stringlib_find(haystack, len_haystack - 1,\n                                    needle, len_needle, offset);\n    if (res == -1) {\n        Py_ssize_t last_align = len_haystack - len_needle;\n        if (memcmp(haystack + last_align, needle, len_needle) == 0) {\n            return offset + last_align;\n        }\n    }\n    return res;\n}\n\nPy_ssize_t\n_PyBytes_ReverseFind(const char *haystack, Py_ssize_t len_haystack,\n                     const char *needle, Py_ssize_t len_needle,\n                     Py_ssize_t offset)\n{\n    return stringlib_rfind(haystack, len_haystack,\n                           needle, len_needle, offset);\n}\n\nPyObject *\nPyBytes_Repr(PyObject *obj, int smartquotes)\n{\n    PyBytesObject* op = (PyBytesObject*) obj;\n    Py_ssize_t i, length = Py_SIZE(op);\n    Py_ssize_t newsize, squotes, dquotes;\n    PyObject *v;\n    unsigned char quote;\n    const unsigned char *s;\n    Py_UCS1 *p;\n\n    /* Compute size of output string */\n    squotes = dquotes = 0;\n    newsize = 3; /* b'' */\n    s = (const unsigned char*)op->ob_sval;\n    for (i = 0; i < length; i++) {\n        Py_ssize_t incr = 1;\n        switch(s[i]) {\n        case '\\'': squotes++; break;\n        case '\"':  dquotes++; break;\n        case '\\\\': case '\\t': case '\\n': case '\\r':\n            incr = 2; break; /* \\C */\n        default:\n            if (s[i] < ' ' || s[i] >= 0x7f)\n                incr = 4; /* \\xHH */\n        }\n        if (newsize > PY_SSIZE_T_MAX - incr)\n            goto overflow;\n        newsize += incr;\n    }\n    quote = '\\'';\n    if (smartquotes && squotes && !dquotes)\n        quote = '\"';\n    if (squotes && quote == '\\'') {\n        if (newsize > PY_SSIZE_T_MAX - squotes)\n            goto overflow;\n        newsize += squotes;\n    }\n\n    v = PyUnicode_New(newsize, 127);\n    if (v == NULL) {\n        return NULL;\n    }\n    p = PyUnicode_1BYTE_DATA(v);\n\n    *p++ = 'b', *p++ = quote;\n    for (i = 0; i < length; i++) {\n        unsigned char c = op->ob_sval[i];\n        if (c == quote || c == '\\\\')\n            *p++ = '\\\\', *p++ = c;\n        else if (c == '\\t')\n            *p++ = '\\\\', *p++ = 't';\n        else if (c == '\\n')\n            *p++ = '\\\\', *p++ = 'n';\n        else if (c == '\\r')\n            *p++ = '\\\\', *p++ = 'r';\n        else if (c < ' ' || c >= 0x7f) {\n            *p++ = '\\\\';\n            *p++ = 'x';\n            *p++ = Py_hexdigits[(c & 0xf0) >> 4];\n            *p++ = Py_hexdigits[c & 0xf];\n        }\n        else\n            *p++ = c;\n    }\n    *p++ = quote;\n    assert(_PyUnicode_CheckConsistency(v, 1));\n    return v;\n\n  overflow:\n    PyErr_SetString(PyExc_OverflowError,\n                    \"bytes object is too large to make repr\");\n    return NULL;\n}\n\nstatic PyObject *\nbytes_repr(PyObject *op)\n{\n    return PyBytes_Repr(op, 1);\n}\n\nstatic PyObject *\nbytes_str(PyObject *op)\n{\n    if (_Py_GetConfig()->bytes_warning) {\n        if (PyErr_WarnEx(PyExc_BytesWarning,\n                         \"str() on a bytes instance\", 1)) {\n            return NULL;\n        }\n    }\n    return bytes_repr(op);\n}\n\nstatic Py_ssize_t\nbytes_length(PyBytesObject *a)\n{\n    return Py_SIZE(a);\n}\n\n/* This is also used by PyBytes_Concat() */\nstatic PyObject *\nbytes_concat(PyObject *a, PyObject *b)\n{\n    Py_buffer va, vb;\n    PyObject *result = NULL;\n\n    va.len = -1;\n    vb.len = -1;\n    if (PyObject_GetBuffer(a, &va, PyBUF_SIMPLE) != 0 ||\n        PyObject_GetBuffer(b, &vb, PyBUF_SIMPLE) != 0) {\n        PyErr_Format(PyExc_TypeError, \"can't concat %.100s to %.100s\",\n                     Py_TYPE(b)->tp_name, Py_TYPE(a)->tp_name);\n        goto done;\n    }\n\n    /* Optimize end cases */\n    if (va.len == 0 && PyBytes_CheckExact(b)) {\n        result = Py_NewRef(b);\n        goto done;\n    }\n    if (vb.len == 0 && PyBytes_CheckExact(a)) {\n        result = Py_NewRef(a);\n        goto done;\n    }\n\n    if (va.len > PY_SSIZE_T_MAX - vb.len) {\n        PyErr_NoMemory();\n        goto done;\n    }\n\n    result = PyBytes_FromStringAndSize(NULL, va.len + vb.len);\n    if (result != NULL) {\n        memcpy(PyBytes_AS_STRING(result), va.buf, va.len);\n        memcpy(PyBytes_AS_STRING(result) + va.len, vb.buf, vb.len);\n    }\n\n  done:\n    if (va.len != -1)\n        PyBuffer_Release(&va);\n    if (vb.len != -1)\n        PyBuffer_Release(&vb);\n    return result;\n}\n\nstatic PyObject *\nbytes_repeat(PyBytesObject *a, Py_ssize_t n)\n{\n    Py_ssize_t size;\n    PyBytesObject *op;\n    size_t nbytes;\n    if (n < 0)\n        n = 0;\n    /* watch out for overflows:  the size can overflow int,\n     * and the # of bytes needed can overflow size_t\n     */\n    if (n > 0 && Py_SIZE(a) > PY_SSIZE_T_MAX / n) {\n        PyErr_SetString(PyExc_OverflowError,\n            \"repeated bytes are too long\");\n        return NULL;\n    }\n    size = Py_SIZE(a) * n;\n    if (size == Py_SIZE(a) && PyBytes_CheckExact(a)) {\n        return Py_NewRef(a);\n    }\n    nbytes = (size_t)size;\n    if (nbytes + PyBytesObject_SIZE <= nbytes) {\n        PyErr_SetString(PyExc_OverflowError,\n            \"repeated bytes are too long\");\n        return NULL;\n    }\n    op = (PyBytesObject *)PyObject_Malloc(PyBytesObject_SIZE + nbytes);\n    if (op == NULL) {\n        return PyErr_NoMemory();\n    }\n    _PyObject_InitVar((PyVarObject*)op, &PyBytes_Type, size);\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n    op->ob_shash = -1;\n_Py_COMP_DIAG_POP\n    op->ob_sval[size] = '\\0';\n\n    _PyBytes_Repeat(op->ob_sval, size, a->ob_sval, Py_SIZE(a));\n\n    return (PyObject *) op;\n}\n\nstatic int\nbytes_contains(PyObject *self, PyObject *arg)\n{\n    return _Py_bytes_contains(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self), arg);\n}\n\nstatic PyObject *\nbytes_item(PyBytesObject *a, Py_ssize_t i)\n{\n    if (i < 0 || i >= Py_SIZE(a)) {\n        PyErr_SetString(PyExc_IndexError, \"index out of range\");\n        return NULL;\n    }\n    return _PyLong_FromUnsignedChar((unsigned char)a->ob_sval[i]);\n}\n\nstatic int\nbytes_compare_eq(PyBytesObject *a, PyBytesObject *b)\n{\n    int cmp;\n    Py_ssize_t len;\n\n    len = Py_SIZE(a);\n    if (Py_SIZE(b) != len)\n        return 0;\n\n    if (a->ob_sval[0] != b->ob_sval[0])\n        return 0;\n\n    cmp = memcmp(a->ob_sval, b->ob_sval, len);\n    return (cmp == 0);\n}\n\nstatic PyObject*\nbytes_richcompare(PyBytesObject *a, PyBytesObject *b, int op)\n{\n    int c;\n    Py_ssize_t len_a, len_b;\n    Py_ssize_t min_len;\n\n    /* Make sure both arguments are strings. */\n    if (!(PyBytes_Check(a) && PyBytes_Check(b))) {\n        if (_Py_GetConfig()->bytes_warning && (op == Py_EQ || op == Py_NE)) {\n            if (PyUnicode_Check(a) || PyUnicode_Check(b)) {\n                if (PyErr_WarnEx(PyExc_BytesWarning,\n                                 \"Comparison between bytes and string\", 1))\n                    return NULL;\n            }\n            if (PyLong_Check(a) || PyLong_Check(b)) {\n                if (PyErr_WarnEx(PyExc_BytesWarning,\n                                 \"Comparison between bytes and int\", 1))\n                    return NULL;\n            }\n        }\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n    else if (a == b) {\n        switch (op) {\n        case Py_EQ:\n        case Py_LE:\n        case Py_GE:\n            /* a byte string is equal to itself */\n            Py_RETURN_TRUE;\n        case Py_NE:\n        case Py_LT:\n        case Py_GT:\n            Py_RETURN_FALSE;\n        default:\n            PyErr_BadArgument();\n            return NULL;\n        }\n    }\n    else if (op == Py_EQ || op == Py_NE) {\n        int eq = bytes_compare_eq(a, b);\n        eq ^= (op == Py_NE);\n        return PyBool_FromLong(eq);\n    }\n    else {\n        len_a = Py_SIZE(a);\n        len_b = Py_SIZE(b);\n        min_len = Py_MIN(len_a, len_b);\n        if (min_len > 0) {\n            c = Py_CHARMASK(*a->ob_sval) - Py_CHARMASK(*b->ob_sval);\n            if (c == 0)\n                c = memcmp(a->ob_sval, b->ob_sval, min_len);\n        }\n        else\n            c = 0;\n        if (c != 0)\n            Py_RETURN_RICHCOMPARE(c, 0, op);\n        Py_RETURN_RICHCOMPARE(len_a, len_b, op);\n    }\n}\n\nstatic Py_hash_t\nbytes_hash(PyBytesObject *a)\n{\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n    if (a->ob_shash == -1) {\n        /* Can't fail */\n        a->ob_shash = _Py_HashBytes(a->ob_sval, Py_SIZE(a));\n    }\n    return a->ob_shash;\n_Py_COMP_DIAG_POP\n}\n\nstatic PyObject*\nbytes_subscript(PyBytesObject* self, PyObject* item)\n{\n    if (_PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n        if (i == -1 && PyErr_Occurred())\n            return NULL;\n        if (i < 0)\n            i += PyBytes_GET_SIZE(self);\n        if (i < 0 || i >= PyBytes_GET_SIZE(self)) {\n            PyErr_SetString(PyExc_IndexError,\n                            \"index out of range\");\n            return NULL;\n        }\n        return _PyLong_FromUnsignedChar((unsigned char)self->ob_sval[i]);\n    }\n    else if (PySlice_Check(item)) {\n        Py_ssize_t start, stop, step, slicelength, i;\n        size_t cur;\n        const char* source_buf;\n        char* result_buf;\n        PyObject* result;\n\n        if (PySlice_Unpack(item, &start, &stop, &step) < 0) {\n            return NULL;\n        }\n        slicelength = PySlice_AdjustIndices(PyBytes_GET_SIZE(self), &start,\n                                            &stop, step);\n\n        if (slicelength <= 0) {\n            return PyBytes_FromStringAndSize(\"\", 0);\n        }\n        else if (start == 0 && step == 1 &&\n                 slicelength == PyBytes_GET_SIZE(self) &&\n                 PyBytes_CheckExact(self)) {\n            return Py_NewRef(self);\n        }\n        else if (step == 1) {\n            return PyBytes_FromStringAndSize(\n                PyBytes_AS_STRING(self) + start,\n                slicelength);\n        }\n        else {\n            source_buf = PyBytes_AS_STRING(self);\n            result = PyBytes_FromStringAndSize(NULL, slicelength);\n            if (result == NULL)\n                return NULL;\n\n            result_buf = PyBytes_AS_STRING(result);\n            for (cur = start, i = 0; i < slicelength;\n                 cur += step, i++) {\n                result_buf[i] = source_buf[cur];\n            }\n\n            return result;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"byte indices must be integers or slices, not %.200s\",\n                     Py_TYPE(item)->tp_name);\n        return NULL;\n    }\n}\n\nstatic int\nbytes_buffer_getbuffer(PyBytesObject *self, Py_buffer *view, int flags)\n{\n    return PyBuffer_FillInfo(view, (PyObject*)self, (void *)self->ob_sval, Py_SIZE(self),\n                             1, flags);\n}\n\nstatic PySequenceMethods bytes_as_sequence = {\n    (lenfunc)bytes_length, /*sq_length*/\n    (binaryfunc)bytes_concat, /*sq_concat*/\n    (ssizeargfunc)bytes_repeat, /*sq_repeat*/\n    (ssizeargfunc)bytes_item, /*sq_item*/\n    0,                  /*sq_slice*/\n    0,                  /*sq_ass_item*/\n    0,                  /*sq_ass_slice*/\n    (objobjproc)bytes_contains /*sq_contains*/\n};\n\nstatic PyMappingMethods bytes_as_mapping = {\n    (lenfunc)bytes_length,\n    (binaryfunc)bytes_subscript,\n    0,\n};\n\nstatic PyBufferProcs bytes_as_buffer = {\n    (getbufferproc)bytes_buffer_getbuffer,\n    NULL,\n};\n\n\n/*[clinic input]\nbytes.__bytes__\nConvert this value to exact type bytes.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes___bytes___impl(PyBytesObject *self)\n/*[clinic end generated code: output=63a306a9bc0caac5 input=34ec5ddba98bd6bb]*/\n{\n    if (PyBytes_CheckExact(self)) {\n        return Py_NewRef(self);\n    }\n    else {\n        return PyBytes_FromStringAndSize(self->ob_sval, Py_SIZE(self));\n    }\n}\n\n\n#define LEFTSTRIP 0\n#define RIGHTSTRIP 1\n#define BOTHSTRIP 2\n\n/*[clinic input]\nbytes.split\n\n    sep: object = None\n        The delimiter according which to split the bytes.\n        None (the default value) means split on ASCII whitespace characters\n        (space, tab, return, newline, formfeed, vertical tab).\n    maxsplit: Py_ssize_t = -1\n        Maximum number of splits to do.\n        -1 (the default value) means no limit.\n\nReturn a list of the sections in the bytes, using sep as the delimiter.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_split_impl(PyBytesObject *self, PyObject *sep, Py_ssize_t maxsplit)\n/*[clinic end generated code: output=52126b5844c1d8ef input=8b809b39074abbfa]*/\n{\n    Py_ssize_t len = PyBytes_GET_SIZE(self), n;\n    const char *s = PyBytes_AS_STRING(self), *sub;\n    Py_buffer vsub;\n    PyObject *list;\n\n    if (maxsplit < 0)\n        maxsplit = PY_SSIZE_T_MAX;\n    if (sep == Py_None)\n        return stringlib_split_whitespace((PyObject*) self, s, len, maxsplit);\n    if (PyObject_GetBuffer(sep, &vsub, PyBUF_SIMPLE) != 0)\n        return NULL;\n    sub = vsub.buf;\n    n = vsub.len;\n\n    list = stringlib_split((PyObject*) self, s, len, sub, n, maxsplit);\n    PyBuffer_Release(&vsub);\n    return list;\n}\n\n/*[clinic input]\nbytes.partition\n\n    sep: Py_buffer\n    /\n\nPartition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes. If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing the original bytes\nobject and two empty bytes objects.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_partition_impl(PyBytesObject *self, Py_buffer *sep)\n/*[clinic end generated code: output=f532b392a17ff695 input=61cca95519406099]*/\n{\n    return stringlib_partition(\n        (PyObject*) self,\n        PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),\n        sep->obj, (const char *)sep->buf, sep->len\n        );\n}\n\n/*[clinic input]\nbytes.rpartition\n\n    sep: Py_buffer\n    /\n\nPartition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing two empty bytes\nobjects and the original bytes object.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_rpartition_impl(PyBytesObject *self, Py_buffer *sep)\n/*[clinic end generated code: output=191b114cbb028e50 input=d78db010c8cfdbe1]*/\n{\n    return stringlib_rpartition(\n        (PyObject*) self,\n        PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),\n        sep->obj, (const char *)sep->buf, sep->len\n        );\n}\n\n/*[clinic input]\nbytes.rsplit = bytes.split\n\nReturn a list of the sections in the bytes, using sep as the delimiter.\n\nSplitting is done starting at the end of the bytes and working to the front.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_rsplit_impl(PyBytesObject *self, PyObject *sep, Py_ssize_t maxsplit)\n/*[clinic end generated code: output=ba698d9ea01e1c8f input=0f86c9f28f7d7b7b]*/\n{\n    Py_ssize_t len = PyBytes_GET_SIZE(self), n;\n    const char *s = PyBytes_AS_STRING(self), *sub;\n    Py_buffer vsub;\n    PyObject *list;\n\n    if (maxsplit < 0)\n        maxsplit = PY_SSIZE_T_MAX;\n    if (sep == Py_None)\n        return stringlib_rsplit_whitespace((PyObject*) self, s, len, maxsplit);\n    if (PyObject_GetBuffer(sep, &vsub, PyBUF_SIMPLE) != 0)\n        return NULL;\n    sub = vsub.buf;\n    n = vsub.len;\n\n    list = stringlib_rsplit((PyObject*) self, s, len, sub, n, maxsplit);\n    PyBuffer_Release(&vsub);\n    return list;\n}\n\n\n/*[clinic input]\nbytes.join\n\n    iterable_of_bytes: object\n    /\n\nConcatenate any number of bytes objects.\n\nThe bytes whose method is called is inserted in between each pair.\n\nThe result is returned as a new bytes object.\n\nExample: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_join(PyBytesObject *self, PyObject *iterable_of_bytes)\n/*[clinic end generated code: output=a046f379f626f6f8 input=7fe377b95bd549d2]*/\n{\n    return stringlib_bytes_join((PyObject*)self, iterable_of_bytes);\n}\n\nPyObject *\n_PyBytes_Join(PyObject *sep, PyObject *x)\n{\n    assert(sep != NULL && PyBytes_Check(sep));\n    assert(x != NULL);\n    return bytes_join((PyBytesObject*)sep, x);\n}\n\nstatic PyObject *\nbytes_find(PyBytesObject *self, PyObject *args)\n{\n    return _Py_bytes_find(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self), args);\n}\n\nstatic PyObject *\nbytes_index(PyBytesObject *self, PyObject *args)\n{\n    return _Py_bytes_index(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self), args);\n}\n\n\nstatic PyObject *\nbytes_rfind(PyBytesObject *self, PyObject *args)\n{\n    return _Py_bytes_rfind(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self), args);\n}\n\n\nstatic PyObject *\nbytes_rindex(PyBytesObject *self, PyObject *args)\n{\n    return _Py_bytes_rindex(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self), args);\n}\n\n\nPy_LOCAL_INLINE(PyObject *)\ndo_xstrip(PyBytesObject *self, int striptype, PyObject *sepobj)\n{\n    Py_buffer vsep;\n    const char *s = PyBytes_AS_STRING(self);\n    Py_ssize_t len = PyBytes_GET_SIZE(self);\n    char *sep;\n    Py_ssize_t seplen;\n    Py_ssize_t i, j;\n\n    if (PyObject_GetBuffer(sepobj, &vsep, PyBUF_SIMPLE) != 0)\n        return NULL;\n    sep = vsep.buf;\n    seplen = vsep.len;\n\n    i = 0;\n    if (striptype != RIGHTSTRIP) {\n        while (i < len && memchr(sep, Py_CHARMASK(s[i]), seplen)) {\n            i++;\n        }\n    }\n\n    j = len;\n    if (striptype != LEFTSTRIP) {\n        do {\n            j--;\n        } while (j >= i && memchr(sep, Py_CHARMASK(s[j]), seplen));\n        j++;\n    }\n\n    PyBuffer_Release(&vsep);\n\n    if (i == 0 && j == len && PyBytes_CheckExact(self)) {\n        return Py_NewRef(self);\n    }\n    else\n        return PyBytes_FromStringAndSize(s+i, j-i);\n}\n\n\nPy_LOCAL_INLINE(PyObject *)\ndo_strip(PyBytesObject *self, int striptype)\n{\n    const char *s = PyBytes_AS_STRING(self);\n    Py_ssize_t len = PyBytes_GET_SIZE(self), i, j;\n\n    i = 0;\n    if (striptype != RIGHTSTRIP) {\n        while (i < len && Py_ISSPACE(s[i])) {\n            i++;\n        }\n    }\n\n    j = len;\n    if (striptype != LEFTSTRIP) {\n        do {\n            j--;\n        } while (j >= i && Py_ISSPACE(s[j]));\n        j++;\n    }\n\n    if (i == 0 && j == len && PyBytes_CheckExact(self)) {\n        return Py_NewRef(self);\n    }\n    else\n        return PyBytes_FromStringAndSize(s+i, j-i);\n}\n\n\nPy_LOCAL_INLINE(PyObject *)\ndo_argstrip(PyBytesObject *self, int striptype, PyObject *bytes)\n{\n    if (bytes != Py_None) {\n        return do_xstrip(self, striptype, bytes);\n    }\n    return do_strip(self, striptype);\n}\n\n/*[clinic input]\nbytes.strip\n\n    bytes: object = None\n    /\n\nStrip leading and trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading and trailing ASCII whitespace.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_strip_impl(PyBytesObject *self, PyObject *bytes)\n/*[clinic end generated code: output=c7c228d3bd104a1b input=8a354640e4e0b3ef]*/\n{\n    return do_argstrip(self, BOTHSTRIP, bytes);\n}\n\n/*[clinic input]\nbytes.lstrip\n\n    bytes: object = None\n    /\n\nStrip leading bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading  ASCII whitespace.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_lstrip_impl(PyBytesObject *self, PyObject *bytes)\n/*[clinic end generated code: output=28602e586f524e82 input=9baff4398c3f6857]*/\n{\n    return do_argstrip(self, LEFTSTRIP, bytes);\n}\n\n/*[clinic input]\nbytes.rstrip\n\n    bytes: object = None\n    /\n\nStrip trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip trailing ASCII whitespace.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_rstrip_impl(PyBytesObject *self, PyObject *bytes)\n/*[clinic end generated code: output=547e3815c95447da input=b78af445c727e32b]*/\n{\n    return do_argstrip(self, RIGHTSTRIP, bytes);\n}\n\n\nstatic PyObject *\nbytes_count(PyBytesObject *self, PyObject *args)\n{\n    return _Py_bytes_count(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self), args);\n}\n\n\n/*[clinic input]\nbytes.translate\n\n    table: object\n        Translation table, which must be a bytes object of length 256.\n    /\n    delete as deletechars: object(c_default=\"NULL\") = b''\n\nReturn a copy with each character mapped by the given translation table.\n\nAll characters occurring in the optional argument delete are removed.\nThe remaining characters are mapped through the given translation table.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_translate_impl(PyBytesObject *self, PyObject *table,\n                     PyObject *deletechars)\n/*[clinic end generated code: output=43be3437f1956211 input=0ecdf159f654233c]*/\n{\n    const char *input;\n    char *output;\n    Py_buffer table_view = {NULL, NULL};\n    Py_buffer del_table_view = {NULL, NULL};\n    const char *table_chars;\n    Py_ssize_t i, c, changed = 0;\n    PyObject *input_obj = (PyObject*)self;\n    const char *output_start, *del_table_chars=NULL;\n    Py_ssize_t inlen, tablen, dellen = 0;\n    PyObject *result;\n    int trans_table[256];\n\n    if (PyBytes_Check(table)) {\n        table_chars = PyBytes_AS_STRING(table);\n        tablen = PyBytes_GET_SIZE(table);\n    }\n    else if (table == Py_None) {\n        table_chars = NULL;\n        tablen = 256;\n    }\n    else {\n        if (PyObject_GetBuffer(table, &table_view, PyBUF_SIMPLE) != 0)\n            return NULL;\n        table_chars = table_view.buf;\n        tablen = table_view.len;\n    }\n\n    if (tablen != 256) {\n        PyErr_SetString(PyExc_ValueError,\n          \"translation table must be 256 characters long\");\n        PyBuffer_Release(&table_view);\n        return NULL;\n    }\n\n    if (deletechars != NULL) {\n        if (PyBytes_Check(deletechars)) {\n            del_table_chars = PyBytes_AS_STRING(deletechars);\n            dellen = PyBytes_GET_SIZE(deletechars);\n        }\n        else {\n            if (PyObject_GetBuffer(deletechars, &del_table_view, PyBUF_SIMPLE) != 0) {\n                PyBuffer_Release(&table_view);\n                return NULL;\n            }\n            del_table_chars = del_table_view.buf;\n            dellen = del_table_view.len;\n        }\n    }\n    else {\n        del_table_chars = NULL;\n        dellen = 0;\n    }\n\n    inlen = PyBytes_GET_SIZE(input_obj);\n    result = PyBytes_FromStringAndSize((char *)NULL, inlen);\n    if (result == NULL) {\n        PyBuffer_Release(&del_table_view);\n        PyBuffer_Release(&table_view);\n        return NULL;\n    }\n    output_start = output = PyBytes_AS_STRING(result);\n    input = PyBytes_AS_STRING(input_obj);\n\n    if (dellen == 0 && table_chars != NULL) {\n        /* If no deletions are required, use faster code */\n        for (i = inlen; --i >= 0; ) {\n            c = Py_CHARMASK(*input++);\n            if (Py_CHARMASK((*output++ = table_chars[c])) != c)\n                changed = 1;\n        }\n        if (!changed && PyBytes_CheckExact(input_obj)) {\n            Py_SETREF(result, Py_NewRef(input_obj));\n        }\n        PyBuffer_Release(&del_table_view);\n        PyBuffer_Release(&table_view);\n        return result;\n    }\n\n    if (table_chars == NULL) {\n        for (i = 0; i < 256; i++)\n            trans_table[i] = Py_CHARMASK(i);\n    } else {\n        for (i = 0; i < 256; i++)\n            trans_table[i] = Py_CHARMASK(table_chars[i]);\n    }\n    PyBuffer_Release(&table_view);\n\n    for (i = 0; i < dellen; i++)\n        trans_table[(int) Py_CHARMASK(del_table_chars[i])] = -1;\n    PyBuffer_Release(&del_table_view);\n\n    for (i = inlen; --i >= 0; ) {\n        c = Py_CHARMASK(*input++);\n        if (trans_table[c] != -1)\n            if (Py_CHARMASK(*output++ = (char)trans_table[c]) == c)\n                continue;\n        changed = 1;\n    }\n    if (!changed && PyBytes_CheckExact(input_obj)) {\n        Py_DECREF(result);\n        return Py_NewRef(input_obj);\n    }\n    /* Fix the size of the resulting byte string */\n    if (inlen > 0)\n        _PyBytes_Resize(&result, output - output_start);\n    return result;\n}\n\n\n/*[clinic input]\n\n@staticmethod\nbytes.maketrans\n\n    frm: Py_buffer\n    to: Py_buffer\n    /\n\nReturn a translation table useable for the bytes or bytearray translate method.\n\nThe returned table will be one where each byte in frm is mapped to the byte at\nthe same position in to.\n\nThe bytes objects frm and to must be of the same length.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_maketrans_impl(Py_buffer *frm, Py_buffer *to)\n/*[clinic end generated code: output=a36f6399d4b77f6f input=de7a8fc5632bb8f1]*/\n{\n    return _Py_bytes_maketrans(frm, to);\n}\n\n\n/*[clinic input]\nbytes.replace\n\n    old: Py_buffer\n    new: Py_buffer\n    count: Py_ssize_t = -1\n        Maximum number of occurrences to replace.\n        -1 (the default value) means replace all occurrences.\n    /\n\nReturn a copy with all occurrences of substring old replaced by new.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_replace_impl(PyBytesObject *self, Py_buffer *old, Py_buffer *new,\n                   Py_ssize_t count)\n/*[clinic end generated code: output=994fa588b6b9c104 input=b2fbbf0bf04de8e5]*/\n{\n    return stringlib_replace((PyObject *)self,\n                             (const char *)old->buf, old->len,\n                             (const char *)new->buf, new->len, count);\n}\n\n/** End DALKE **/\n\n/*[clinic input]\nbytes.removeprefix as bytes_removeprefix\n\n    prefix: Py_buffer\n    /\n\nReturn a bytes object with the given prefix string removed if present.\n\nIf the bytes starts with the prefix string, return bytes[len(prefix):].\nOtherwise, return a copy of the original bytes.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_removeprefix_impl(PyBytesObject *self, Py_buffer *prefix)\n/*[clinic end generated code: output=f006865331a06ab6 input=0c93bac817a8502c]*/\n{\n    const char *self_start = PyBytes_AS_STRING(self);\n    Py_ssize_t self_len = PyBytes_GET_SIZE(self);\n    const char *prefix_start = prefix->buf;\n    Py_ssize_t prefix_len = prefix->len;\n\n    if (self_len >= prefix_len\n        && prefix_len > 0\n        && memcmp(self_start, prefix_start, prefix_len) == 0)\n    {\n        return PyBytes_FromStringAndSize(self_start + prefix_len,\n                                         self_len - prefix_len);\n    }\n\n    if (PyBytes_CheckExact(self)) {\n        return Py_NewRef(self);\n    }\n\n    return PyBytes_FromStringAndSize(self_start, self_len);\n}\n\n/*[clinic input]\nbytes.removesuffix as bytes_removesuffix\n\n    suffix: Py_buffer\n    /\n\nReturn a bytes object with the given suffix string removed if present.\n\nIf the bytes ends with the suffix string and that suffix is not empty,\nreturn bytes[:-len(prefix)].  Otherwise, return a copy of the original\nbytes.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_removesuffix_impl(PyBytesObject *self, Py_buffer *suffix)\n/*[clinic end generated code: output=d887d308e3242eeb input=9f4e1da8c637bbf1]*/\n{\n    const char *self_start = PyBytes_AS_STRING(self);\n    Py_ssize_t self_len = PyBytes_GET_SIZE(self);\n    const char *suffix_start = suffix->buf;\n    Py_ssize_t suffix_len = suffix->len;\n\n    if (self_len >= suffix_len\n        && suffix_len > 0\n        && memcmp(self_start + self_len - suffix_len,\n                  suffix_start, suffix_len) == 0)\n    {\n        return PyBytes_FromStringAndSize(self_start,\n                                         self_len - suffix_len);\n    }\n\n    if (PyBytes_CheckExact(self)) {\n        return Py_NewRef(self);\n    }\n\n    return PyBytes_FromStringAndSize(self_start, self_len);\n}\n\nstatic PyObject *\nbytes_startswith(PyBytesObject *self, PyObject *args)\n{\n    return _Py_bytes_startswith(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self), args);\n}\n\nstatic PyObject *\nbytes_endswith(PyBytesObject *self, PyObject *args)\n{\n    return _Py_bytes_endswith(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self), args);\n}\n\n\n/*[clinic input]\nbytes.decode\n\n    encoding: str(c_default=\"NULL\") = 'utf-8'\n        The encoding with which to decode the bytes.\n    errors: str(c_default=\"NULL\") = 'strict'\n        The error handling scheme to use for the handling of decoding errors.\n        The default is 'strict' meaning that decoding errors raise a\n        UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n        as well as any other name registered with codecs.register_error that\n        can handle UnicodeDecodeErrors.\n\nDecode the bytes using the codec registered for encoding.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_decode_impl(PyBytesObject *self, const char *encoding,\n                  const char *errors)\n/*[clinic end generated code: output=5649a53dde27b314 input=958174769d2a40ca]*/\n{\n    return PyUnicode_FromEncodedObject((PyObject*)self, encoding, errors);\n}\n\n\n/*[clinic input]\nbytes.splitlines\n\n    keepends: bool = False\n\nReturn a list of the lines in the bytes, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_splitlines_impl(PyBytesObject *self, int keepends)\n/*[clinic end generated code: output=3484149a5d880ffb input=5d7b898af2fe55c0]*/\n{\n    return stringlib_splitlines(\n        (PyObject*) self, PyBytes_AS_STRING(self),\n        PyBytes_GET_SIZE(self), keepends\n        );\n}\n\n/*[clinic input]\n@classmethod\nbytes.fromhex\n\n    string: unicode\n    /\n\nCreate a bytes object from a string of hexadecimal numbers.\n\nSpaces between two numbers are accepted.\nExample: bytes.fromhex('B9 01EF') -> b'\\\\xb9\\\\x01\\\\xef'.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_fromhex_impl(PyTypeObject *type, PyObject *string)\n/*[clinic end generated code: output=0973acc63661bb2e input=bf4d1c361670acd3]*/\n{\n    PyObject *result = _PyBytes_FromHex(string, 0);\n    if (type != &PyBytes_Type && result != NULL) {\n        Py_SETREF(result, PyObject_CallOneArg((PyObject *)type, result));\n    }\n    return result;\n}\n\nPyObject*\n_PyBytes_FromHex(PyObject *string, int use_bytearray)\n{\n    char *buf;\n    Py_ssize_t hexlen, invalid_char;\n    unsigned int top, bot;\n    const Py_UCS1 *str, *end;\n    _PyBytesWriter writer;\n\n    _PyBytesWriter_Init(&writer);\n    writer.use_bytearray = use_bytearray;\n\n    assert(PyUnicode_Check(string));\n    if (PyUnicode_READY(string))\n        return NULL;\n    hexlen = PyUnicode_GET_LENGTH(string);\n\n    if (!PyUnicode_IS_ASCII(string)) {\n        const void *data = PyUnicode_DATA(string);\n        int kind = PyUnicode_KIND(string);\n        Py_ssize_t i;\n\n        /* search for the first non-ASCII character */\n        for (i = 0; i < hexlen; i++) {\n            if (PyUnicode_READ(kind, data, i) >= 128)\n                break;\n        }\n        invalid_char = i;\n        goto error;\n    }\n\n    assert(PyUnicode_KIND(string) == PyUnicode_1BYTE_KIND);\n    str = PyUnicode_1BYTE_DATA(string);\n\n    /* This overestimates if there are spaces */\n    buf = _PyBytesWriter_Alloc(&writer, hexlen / 2);\n    if (buf == NULL)\n        return NULL;\n\n    end = str + hexlen;\n    while (str < end) {\n        /* skip over spaces in the input */\n        if (Py_ISSPACE(*str)) {\n            do {\n                str++;\n            } while (Py_ISSPACE(*str));\n            if (str >= end)\n                break;\n        }\n\n        top = _PyLong_DigitValue[*str];\n        if (top >= 16) {\n            invalid_char = str - PyUnicode_1BYTE_DATA(string);\n            goto error;\n        }\n        str++;\n\n        bot = _PyLong_DigitValue[*str];\n        if (bot >= 16) {\n            invalid_char = str - PyUnicode_1BYTE_DATA(string);\n            goto error;\n        }\n        str++;\n\n        *buf++ = (unsigned char)((top << 4) + bot);\n    }\n\n    return _PyBytesWriter_Finish(&writer, buf);\n\n  error:\n    PyErr_Format(PyExc_ValueError,\n                 \"non-hexadecimal number found in \"\n                 \"fromhex() arg at position %zd\", invalid_char);\n    _PyBytesWriter_Dealloc(&writer);\n    return NULL;\n}\n\n/*[clinic input]\nbytes.hex\n\n    sep: object = NULL\n        An optional single character or byte to separate hex bytes.\n    bytes_per_sep: int = 1\n        How many bytes between separators.  Positive values count from the\n        right, negative values count from the left.\n\nCreate a string of hexadecimal numbers from a bytes object.\n\nExample:\n>>> value = b'\\xb9\\x01\\xef'\n>>> value.hex()\n'b901ef'\n>>> value.hex(':')\n'b9:01:ef'\n>>> value.hex(':', 2)\n'b9:01ef'\n>>> value.hex(':', -2)\n'b901:ef'\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_hex_impl(PyBytesObject *self, PyObject *sep, int bytes_per_sep)\n/*[clinic end generated code: output=1f134da504064139 input=1a21282b1f1ae595]*/\n{\n    const char *argbuf = PyBytes_AS_STRING(self);\n    Py_ssize_t arglen = PyBytes_GET_SIZE(self);\n    return _Py_strhex_with_sep(argbuf, arglen, sep, bytes_per_sep);\n}\n\nstatic PyObject *\nbytes_getnewargs(PyBytesObject *v, PyObject *Py_UNUSED(ignored))\n{\n    return Py_BuildValue(\"(y#)\", v->ob_sval, Py_SIZE(v));\n}\n\n\nstatic PyMethodDef\nbytes_methods[] = {\n    {\"__getnewargs__\",          (PyCFunction)bytes_getnewargs,  METH_NOARGS},\n    BYTES___BYTES___METHODDEF\n    {\"capitalize\", stringlib_capitalize, METH_NOARGS,\n     _Py_capitalize__doc__},\n    STRINGLIB_CENTER_METHODDEF\n    {\"count\", (PyCFunction)bytes_count, METH_VARARGS,\n     _Py_count__doc__},\n    BYTES_DECODE_METHODDEF\n    {\"endswith\", (PyCFunction)bytes_endswith, METH_VARARGS,\n     _Py_endswith__doc__},\n    STRINGLIB_EXPANDTABS_METHODDEF\n    {\"find\", (PyCFunction)bytes_find, METH_VARARGS,\n     _Py_find__doc__},\n    BYTES_FROMHEX_METHODDEF\n    BYTES_HEX_METHODDEF\n    {\"index\", (PyCFunction)bytes_index, METH_VARARGS, _Py_index__doc__},\n    {\"isalnum\", stringlib_isalnum, METH_NOARGS,\n     _Py_isalnum__doc__},\n    {\"isalpha\", stringlib_isalpha, METH_NOARGS,\n     _Py_isalpha__doc__},\n    {\"isascii\", stringlib_isascii, METH_NOARGS,\n     _Py_isascii__doc__},\n    {\"isdigit\", stringlib_isdigit, METH_NOARGS,\n     _Py_isdigit__doc__},\n    {\"islower\", stringlib_islower, METH_NOARGS,\n     _Py_islower__doc__},\n    {\"isspace\", stringlib_isspace, METH_NOARGS,\n     _Py_isspace__doc__},\n    {\"istitle\", stringlib_istitle, METH_NOARGS,\n     _Py_istitle__doc__},\n    {\"isupper\", stringlib_isupper, METH_NOARGS,\n     _Py_isupper__doc__},\n    BYTES_JOIN_METHODDEF\n    STRINGLIB_LJUST_METHODDEF\n    {\"lower\", stringlib_lower, METH_NOARGS, _Py_lower__doc__},\n    BYTES_LSTRIP_METHODDEF\n    BYTES_MAKETRANS_METHODDEF\n    BYTES_PARTITION_METHODDEF\n    BYTES_REPLACE_METHODDEF\n    BYTES_REMOVEPREFIX_METHODDEF\n    BYTES_REMOVESUFFIX_METHODDEF\n    {\"rfind\", (PyCFunction)bytes_rfind, METH_VARARGS, _Py_rfind__doc__},\n    {\"rindex\", (PyCFunction)bytes_rindex, METH_VARARGS, _Py_rindex__doc__},\n    STRINGLIB_RJUST_METHODDEF\n    BYTES_RPARTITION_METHODDEF\n    BYTES_RSPLIT_METHODDEF\n    BYTES_RSTRIP_METHODDEF\n    BYTES_SPLIT_METHODDEF\n    BYTES_SPLITLINES_METHODDEF\n    {\"startswith\", (PyCFunction)bytes_startswith, METH_VARARGS,\n     _Py_startswith__doc__},\n    BYTES_STRIP_METHODDEF\n    {\"swapcase\", stringlib_swapcase, METH_NOARGS,\n     _Py_swapcase__doc__},\n    {\"title\", stringlib_title, METH_NOARGS, _Py_title__doc__},\n    BYTES_TRANSLATE_METHODDEF\n    {\"upper\", stringlib_upper, METH_NOARGS, _Py_upper__doc__},\n    STRINGLIB_ZFILL_METHODDEF\n    {NULL,     NULL}                         /* sentinel */\n};\n\nstatic PyObject *\nbytes_mod(PyObject *self, PyObject *arg)\n{\n    if (!PyBytes_Check(self)) {\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n    return _PyBytes_FormatEx(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),\n                             arg, 0);\n}\n\nstatic PyNumberMethods bytes_as_number = {\n    0,              /*nb_add*/\n    0,              /*nb_subtract*/\n    0,              /*nb_multiply*/\n    bytes_mod,      /*nb_remainder*/\n};\n\nstatic PyObject *\nbytes_subtype_new(PyTypeObject *, PyObject *);\n\n/*[clinic input]\n@classmethod\nbytes.__new__ as bytes_new\n\n    source as x: object = NULL\n    encoding: str = NULL\n    errors: str = NULL\n\n[clinic start generated code]*/\n\nstatic PyObject *\nbytes_new_impl(PyTypeObject *type, PyObject *x, const char *encoding,\n               const char *errors)\n/*[clinic end generated code: output=1e0c471be311a425 input=f0a966d19b7262b4]*/\n{\n    PyObject *bytes;\n    PyObject *func;\n    Py_ssize_t size;\n\n    if (x == NULL) {\n        if (encoding != NULL || errors != NULL) {\n            PyErr_SetString(PyExc_TypeError,\n                            encoding != NULL ?\n                            \"encoding without a string argument\" :\n                            \"errors without a string argument\");\n            return NULL;\n        }\n        bytes = PyBytes_FromStringAndSize(NULL, 0);\n    }\n    else if (encoding != NULL) {\n        /* Encode via the codec registry */\n        if (!PyUnicode_Check(x)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"encoding without a string argument\");\n            return NULL;\n        }\n        bytes = PyUnicode_AsEncodedString(x, encoding, errors);\n    }\n    else if (errors != NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        PyUnicode_Check(x) ?\n                        \"string argument without an encoding\" :\n                        \"errors without a string argument\");\n        return NULL;\n    }\n    /* We'd like to call PyObject_Bytes here, but we need to check for an\n       integer argument before deferring to PyBytes_FromObject, something\n       PyObject_Bytes doesn't do. */\n    else if ((func = _PyObject_LookupSpecial(x, &_Py_ID(__bytes__))) != NULL) {\n        bytes = _PyObject_CallNoArgs(func);\n        Py_DECREF(func);\n        if (bytes == NULL)\n            return NULL;\n        if (!PyBytes_Check(bytes)) {\n            PyErr_Format(PyExc_TypeError,\n                        \"__bytes__ returned non-bytes (type %.200s)\",\n                        Py_TYPE(bytes)->tp_name);\n            Py_DECREF(bytes);\n            return NULL;\n        }\n    }\n    else if (PyErr_Occurred())\n        return NULL;\n    else if (PyUnicode_Check(x)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"string argument without an encoding\");\n        return NULL;\n    }\n    /* Is it an integer? */\n    else if (_PyIndex_Check(x)) {\n        size = PyNumber_AsSsize_t(x, PyExc_OverflowError);\n        if (size == -1 && PyErr_Occurred()) {\n            if (!PyErr_ExceptionMatches(PyExc_TypeError))\n                return NULL;\n            PyErr_Clear();  /* fall through */\n            bytes = PyBytes_FromObject(x);\n        }\n        else {\n            if (size < 0) {\n                PyErr_SetString(PyExc_ValueError, \"negative count\");\n                return NULL;\n            }\n            bytes = _PyBytes_FromSize(size, 1);\n        }\n    }\n    else {\n        bytes = PyBytes_FromObject(x);\n    }\n\n    if (bytes != NULL && type != &PyBytes_Type) {\n        Py_SETREF(bytes, bytes_subtype_new(type, bytes));\n    }\n\n    return bytes;\n}\n\nstatic PyObject*\n_PyBytes_FromBuffer(PyObject *x)\n{\n    PyObject *new;\n    Py_buffer view;\n\n    if (PyObject_GetBuffer(x, &view, PyBUF_FULL_RO) < 0)\n        return NULL;\n\n    new = PyBytes_FromStringAndSize(NULL, view.len);\n    if (!new)\n        goto fail;\n    if (PyBuffer_ToContiguous(((PyBytesObject *)new)->ob_sval,\n                &view, view.len, 'C') < 0)\n        goto fail;\n    PyBuffer_Release(&view);\n    return new;\n\nfail:\n    Py_XDECREF(new);\n    PyBuffer_Release(&view);\n    return NULL;\n}\n\nstatic PyObject*\n_PyBytes_FromList(PyObject *x)\n{\n    Py_ssize_t i, size = PyList_GET_SIZE(x);\n    Py_ssize_t value;\n    char *str;\n    PyObject *item;\n    _PyBytesWriter writer;\n\n    _PyBytesWriter_Init(&writer);\n    str = _PyBytesWriter_Alloc(&writer, size);\n    if (str == NULL)\n        return NULL;\n    writer.overallocate = 1;\n    size = writer.allocated;\n\n    for (i = 0; i < PyList_GET_SIZE(x); i++) {\n        item = PyList_GET_ITEM(x, i);\n        Py_INCREF(item);\n        value = PyNumber_AsSsize_t(item, NULL);\n        Py_DECREF(item);\n        if (value == -1 && PyErr_Occurred())\n            goto error;\n\n        if (value < 0 || value >= 256) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"bytes must be in range(0, 256)\");\n            goto error;\n        }\n\n        if (i >= size) {\n            str = _PyBytesWriter_Resize(&writer, str, size+1);\n            if (str == NULL)\n                return NULL;\n            size = writer.allocated;\n        }\n        *str++ = (char) value;\n    }\n    return _PyBytesWriter_Finish(&writer, str);\n\n  error:\n    _PyBytesWriter_Dealloc(&writer);\n    return NULL;\n}\n\nstatic PyObject*\n_PyBytes_FromTuple(PyObject *x)\n{\n    PyObject *bytes;\n    Py_ssize_t i, size = PyTuple_GET_SIZE(x);\n    Py_ssize_t value;\n    char *str;\n    PyObject *item;\n\n    bytes = PyBytes_FromStringAndSize(NULL, size);\n    if (bytes == NULL)\n        return NULL;\n    str = ((PyBytesObject *)bytes)->ob_sval;\n\n    for (i = 0; i < size; i++) {\n        item = PyTuple_GET_ITEM(x, i);\n        value = PyNumber_AsSsize_t(item, NULL);\n        if (value == -1 && PyErr_Occurred())\n            goto error;\n\n        if (value < 0 || value >= 256) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"bytes must be in range(0, 256)\");\n            goto error;\n        }\n        *str++ = (char) value;\n    }\n    return bytes;\n\n  error:\n    Py_DECREF(bytes);\n    return NULL;\n}\n\nstatic PyObject *\n_PyBytes_FromIterator(PyObject *it, PyObject *x)\n{\n    char *str;\n    Py_ssize_t i, size;\n    _PyBytesWriter writer;\n\n    /* For iterator version, create a bytes object and resize as needed */\n    size = PyObject_LengthHint(x, 64);\n    if (size == -1 && PyErr_Occurred())\n        return NULL;\n\n    _PyBytesWriter_Init(&writer);\n    str = _PyBytesWriter_Alloc(&writer, size);\n    if (str == NULL)\n        return NULL;\n    writer.overallocate = 1;\n    size = writer.allocated;\n\n    /* Run the iterator to exhaustion */\n    for (i = 0; ; i++) {\n        PyObject *item;\n        Py_ssize_t value;\n\n        /* Get the next item */\n        item = PyIter_Next(it);\n        if (item == NULL) {\n            if (PyErr_Occurred())\n                goto error;\n            break;\n        }\n\n        /* Interpret it as an int (__index__) */\n        value = PyNumber_AsSsize_t(item, NULL);\n        Py_DECREF(item);\n        if (value == -1 && PyErr_Occurred())\n            goto error;\n\n        /* Range check */\n        if (value < 0 || value >= 256) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"bytes must be in range(0, 256)\");\n            goto error;\n        }\n\n        /* Append the byte */\n        if (i >= size) {\n            str = _PyBytesWriter_Resize(&writer, str, size+1);\n            if (str == NULL)\n                return NULL;\n            size = writer.allocated;\n        }\n        *str++ = (char) value;\n    }\n\n    return _PyBytesWriter_Finish(&writer, str);\n\n  error:\n    _PyBytesWriter_Dealloc(&writer);\n    return NULL;\n}\n\nPyObject *\nPyBytes_FromObject(PyObject *x)\n{\n    PyObject *it, *result;\n\n    if (x == NULL) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n\n    if (PyBytes_CheckExact(x)) {\n        return Py_NewRef(x);\n    }\n\n    /* Use the modern buffer interface */\n    if (PyObject_CheckBuffer(x))\n        return _PyBytes_FromBuffer(x);\n\n    if (PyList_CheckExact(x))\n        return _PyBytes_FromList(x);\n\n    if (PyTuple_CheckExact(x))\n        return _PyBytes_FromTuple(x);\n\n    if (!PyUnicode_Check(x)) {\n        it = PyObject_GetIter(x);\n        if (it != NULL) {\n            result = _PyBytes_FromIterator(it, x);\n            Py_DECREF(it);\n            return result;\n        }\n        if (!PyErr_ExceptionMatches(PyExc_TypeError)) {\n            return NULL;\n        }\n    }\n\n    PyErr_Format(PyExc_TypeError,\n                 \"cannot convert '%.200s' object to bytes\",\n                 Py_TYPE(x)->tp_name);\n    return NULL;\n}\n\n/* This allocator is needed for subclasses don't want to use __new__.\n * See https://github.com/python/cpython/issues/91020#issuecomment-1096793239\n *\n * This allocator will be removed when ob_shash is removed.\n */\nstatic PyObject *\nbytes_alloc(PyTypeObject *self, Py_ssize_t nitems)\n{\n    PyBytesObject *obj = (PyBytesObject*)PyType_GenericAlloc(self, nitems);\n    if (obj == NULL) {\n        return NULL;\n    }\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n    obj->ob_shash = -1;\n_Py_COMP_DIAG_POP\n    return (PyObject*)obj;\n}\n\nstatic PyObject *\nbytes_subtype_new(PyTypeObject *type, PyObject *tmp)\n{\n    PyObject *pnew;\n    Py_ssize_t n;\n\n    assert(PyType_IsSubtype(type, &PyBytes_Type));\n    assert(PyBytes_Check(tmp));\n    n = PyBytes_GET_SIZE(tmp);\n    pnew = type->tp_alloc(type, n);\n    if (pnew != NULL) {\n        memcpy(PyBytes_AS_STRING(pnew),\n                  PyBytes_AS_STRING(tmp), n+1);\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n        ((PyBytesObject *)pnew)->ob_shash =\n            ((PyBytesObject *)tmp)->ob_shash;\n_Py_COMP_DIAG_POP\n    }\n    return pnew;\n}\n\nPyDoc_STRVAR(bytes_doc,\n\"bytes(iterable_of_ints) -> bytes\\n\\\nbytes(string, encoding[, errors]) -> bytes\\n\\\nbytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\\n\\\nbytes(int) -> bytes object of size given by the parameter initialized with null bytes\\n\\\nbytes() -> empty bytes object\\n\\\n\\n\\\nConstruct an immutable array of bytes from:\\n\\\n  - an iterable yielding integers in range(256)\\n\\\n  - a text string encoded using the specified encoding\\n\\\n  - any object implementing the buffer API.\\n\\\n  - an integer\");\n\nstatic PyObject *bytes_iter(PyObject *seq);\n\nPyTypeObject PyBytes_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"bytes\",\n    PyBytesObject_SIZE,\n    sizeof(char),\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    (reprfunc)bytes_repr,                       /* tp_repr */\n    &bytes_as_number,                           /* tp_as_number */\n    &bytes_as_sequence,                         /* tp_as_sequence */\n    &bytes_as_mapping,                          /* tp_as_mapping */\n    (hashfunc)bytes_hash,                       /* tp_hash */\n    0,                                          /* tp_call */\n    bytes_str,                                  /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &bytes_as_buffer,                           /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n        Py_TPFLAGS_BYTES_SUBCLASS |\n        _Py_TPFLAGS_MATCH_SELF,               /* tp_flags */\n    bytes_doc,                                  /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    (richcmpfunc)bytes_richcompare,             /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    bytes_iter,                                 /* tp_iter */\n    0,                                          /* tp_iternext */\n    bytes_methods,                              /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    bytes_alloc,                                /* tp_alloc */\n    bytes_new,                                  /* tp_new */\n    PyObject_Del,                               /* tp_free */\n};\n\nvoid\nPyBytes_Concat(PyObject **pv, PyObject *w)\n{\n    assert(pv != NULL);\n    if (*pv == NULL)\n        return;\n    if (w == NULL) {\n        Py_CLEAR(*pv);\n        return;\n    }\n\n    if (Py_REFCNT(*pv) == 1 && PyBytes_CheckExact(*pv)) {\n        /* Only one reference, so we can resize in place */\n        Py_ssize_t oldsize;\n        Py_buffer wb;\n\n        if (PyObject_GetBuffer(w, &wb, PyBUF_SIMPLE) != 0) {\n            PyErr_Format(PyExc_TypeError, \"can't concat %.100s to %.100s\",\n                         Py_TYPE(w)->tp_name, Py_TYPE(*pv)->tp_name);\n            Py_CLEAR(*pv);\n            return;\n        }\n\n        oldsize = PyBytes_GET_SIZE(*pv);\n        if (oldsize > PY_SSIZE_T_MAX - wb.len) {\n            PyErr_NoMemory();\n            goto error;\n        }\n        if (_PyBytes_Resize(pv, oldsize + wb.len) < 0)\n            goto error;\n\n        memcpy(PyBytes_AS_STRING(*pv) + oldsize, wb.buf, wb.len);\n        PyBuffer_Release(&wb);\n        return;\n\n      error:\n        PyBuffer_Release(&wb);\n        Py_CLEAR(*pv);\n        return;\n    }\n\n    else {\n        /* Multiple references, need to create new object */\n        PyObject *v;\n        v = bytes_concat(*pv, w);\n        Py_SETREF(*pv, v);\n    }\n}\n\nvoid\nPyBytes_ConcatAndDel(PyObject **pv, PyObject *w)\n{\n    PyBytes_Concat(pv, w);\n    Py_XDECREF(w);\n}\n\n\n/* The following function breaks the notion that bytes are immutable:\n   it changes the size of a bytes object.  We get away with this only if there\n   is only one module referencing the object.  You can also think of it\n   as creating a new bytes object and destroying the old one, only\n   more efficiently.  In any case, don't use this if the bytes object may\n   already be known to some other part of the code...\n   Note that if there's not enough memory to resize the bytes object, the\n   original bytes object at *pv is deallocated, *pv is set to NULL, an \"out of\n   memory\" exception is set, and -1 is returned.  Else (on success) 0 is\n   returned, and the value in *pv may or may not be the same as on input.\n   As always, an extra byte is allocated for a trailing \\0 byte (newsize\n   does *not* include that), and a trailing \\0 byte is stored.\n*/\n\nint\n_PyBytes_Resize(PyObject **pv, Py_ssize_t newsize)\n{\n    PyObject *v;\n    PyBytesObject *sv;\n    v = *pv;\n    if (!PyBytes_Check(v) || newsize < 0) {\n        goto error;\n    }\n    if (Py_SIZE(v) == newsize) {\n        /* return early if newsize equals to v->ob_size */\n        return 0;\n    }\n    if (Py_SIZE(v) == 0) {\n        if (newsize == 0) {\n            return 0;\n        }\n        *pv = _PyBytes_FromSize(newsize, 0);\n        Py_DECREF(v);\n        return (*pv == NULL) ? -1 : 0;\n    }\n    if (Py_REFCNT(v) != 1) {\n        goto error;\n    }\n    if (newsize == 0) {\n        *pv = bytes_new_empty();\n        Py_DECREF(v);\n        return 0;\n    }\n#ifdef Py_TRACE_REFS\n    _Py_ForgetReference(v);\n#endif\n    *pv = (PyObject *)\n        PyObject_Realloc(v, PyBytesObject_SIZE + newsize);\n    if (*pv == NULL) {\n#ifdef Py_REF_DEBUG\n        _Py_DecRefTotal(_PyInterpreterState_GET());\n#endif\n        PyObject_Free(v);\n        PyErr_NoMemory();\n        return -1;\n    }\n    _Py_NewReferenceNoTotal(*pv);\n    sv = (PyBytesObject *) *pv;\n    Py_SET_SIZE(sv, newsize);\n    sv->ob_sval[newsize] = '\\0';\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n    sv->ob_shash = -1;          /* invalidate cached hash value */\n_Py_COMP_DIAG_POP\n    return 0;\nerror:\n    *pv = 0;\n    Py_DECREF(v);\n    PyErr_BadInternalCall();\n    return -1;\n}\n\n\n/*********************** Bytes Iterator ****************************/\n\ntypedef struct {\n    PyObject_HEAD\n    Py_ssize_t it_index;\n    PyBytesObject *it_seq; /* Set to NULL when iterator is exhausted */\n} striterobject;\n\nstatic void\nstriter_dealloc(striterobject *it)\n{\n    _PyObject_GC_UNTRACK(it);\n    Py_XDECREF(it->it_seq);\n    PyObject_GC_Del(it);\n}\n\nstatic int\nstriter_traverse(striterobject *it, visitproc visit, void *arg)\n{\n    Py_VISIT(it->it_seq);\n    return 0;\n}\n\nstatic PyObject *\nstriter_next(striterobject *it)\n{\n    PyBytesObject *seq;\n\n    assert(it != NULL);\n    seq = it->it_seq;\n    if (seq == NULL)\n        return NULL;\n    assert(PyBytes_Check(seq));\n\n    if (it->it_index < PyBytes_GET_SIZE(seq)) {\n        return _PyLong_FromUnsignedChar(\n            (unsigned char)seq->ob_sval[it->it_index++]);\n    }\n\n    it->it_seq = NULL;\n    Py_DECREF(seq);\n    return NULL;\n}\n\nstatic PyObject *\nstriter_len(striterobject *it, PyObject *Py_UNUSED(ignored))\n{\n    Py_ssize_t len = 0;\n    if (it->it_seq)\n        len = PyBytes_GET_SIZE(it->it_seq) - it->it_index;\n    return PyLong_FromSsize_t(len);\n}\n\nPyDoc_STRVAR(length_hint_doc,\n             \"Private method returning an estimate of len(list(it)).\");\n\nstatic PyObject *\nstriter_reduce(striterobject *it, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *iter = _PyEval_GetBuiltin(&_Py_ID(iter));\n\n    /* _PyEval_GetBuiltin can invoke arbitrary code,\n     * call must be before access of iterator pointers.\n     * see issue #101765 */\n\n    if (it->it_seq != NULL) {\n        return Py_BuildValue(\"N(O)n\", iter, it->it_seq, it->it_index);\n    } else {\n        return Py_BuildValue(\"N(())\", iter);\n    }\n}\n\nPyDoc_STRVAR(reduce_doc, \"Return state information for pickling.\");\n\nstatic PyObject *\nstriter_setstate(striterobject *it, PyObject *state)\n{\n    Py_ssize_t index = PyLong_AsSsize_t(state);\n    if (index == -1 && PyErr_Occurred())\n        return NULL;\n    if (it->it_seq != NULL) {\n        if (index < 0)\n            index = 0;\n        else if (index > PyBytes_GET_SIZE(it->it_seq))\n            index = PyBytes_GET_SIZE(it->it_seq); /* iterator exhausted */\n        it->it_index = index;\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(setstate_doc, \"Set state information for unpickling.\");\n\nstatic PyMethodDef striter_methods[] = {\n    {\"__length_hint__\", (PyCFunction)striter_len, METH_NOARGS,\n     length_hint_doc},\n    {\"__reduce__\",      (PyCFunction)striter_reduce, METH_NOARGS,\n     reduce_doc},\n    {\"__setstate__\",    (PyCFunction)striter_setstate, METH_O,\n     setstate_doc},\n    {NULL,              NULL}           /* sentinel */\n};\n\nPyTypeObject PyBytesIter_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"bytes_iterator\",                           /* tp_name */\n    sizeof(striterobject),                      /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    /* methods */\n    (destructor)striter_dealloc,                /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)striter_traverse,     /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    PyObject_SelfIter,                          /* tp_iter */\n    (iternextfunc)striter_next,                 /* tp_iternext */\n    striter_methods,                            /* tp_methods */\n    0,\n};\n\nstatic PyObject *\nbytes_iter(PyObject *seq)\n{\n    striterobject *it;\n\n    if (!PyBytes_Check(seq)) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n    it = PyObject_GC_New(striterobject, &PyBytesIter_Type);\n    if (it == NULL)\n        return NULL;\n    it->it_index = 0;\n    it->it_seq = (PyBytesObject *)Py_NewRef(seq);\n    _PyObject_GC_TRACK(it);\n    return (PyObject *)it;\n}\n\n\n/* _PyBytesWriter API */\n\n#ifdef MS_WINDOWS\n   /* On Windows, overallocate by 50% is the best factor */\n#  define OVERALLOCATE_FACTOR 2\n#else\n   /* On Linux, overallocate by 25% is the best factor */\n#  define OVERALLOCATE_FACTOR 4\n#endif\n\nvoid\n_PyBytesWriter_Init(_PyBytesWriter *writer)\n{\n    /* Set all attributes before small_buffer to 0 */\n    memset(writer, 0, offsetof(_PyBytesWriter, small_buffer));\n#ifndef NDEBUG\n    memset(writer->small_buffer, PYMEM_CLEANBYTE,\n           sizeof(writer->small_buffer));\n#endif\n}\n\nvoid\n_PyBytesWriter_Dealloc(_PyBytesWriter *writer)\n{\n    Py_CLEAR(writer->buffer);\n}\n\nPy_LOCAL_INLINE(char*)\n_PyBytesWriter_AsString(_PyBytesWriter *writer)\n{\n    if (writer->use_small_buffer) {\n        assert(writer->buffer == NULL);\n        return writer->small_buffer;\n    }\n    else if (writer->use_bytearray) {\n        assert(writer->buffer != NULL);\n        return PyByteArray_AS_STRING(writer->buffer);\n    }\n    else {\n        assert(writer->buffer != NULL);\n        return PyBytes_AS_STRING(writer->buffer);\n    }\n}\n\nPy_LOCAL_INLINE(Py_ssize_t)\n_PyBytesWriter_GetSize(_PyBytesWriter *writer, char *str)\n{\n    const char *start = _PyBytesWriter_AsString(writer);\n    assert(str != NULL);\n    assert(str >= start);\n    assert(str - start <= writer->allocated);\n    return str - start;\n}\n\n#ifndef NDEBUG\nPy_LOCAL_INLINE(int)\n_PyBytesWriter_CheckConsistency(_PyBytesWriter *writer, char *str)\n{\n    const char *start, *end;\n\n    if (writer->use_small_buffer) {\n        assert(writer->buffer == NULL);\n    }\n    else {\n        assert(writer->buffer != NULL);\n        if (writer->use_bytearray)\n            assert(PyByteArray_CheckExact(writer->buffer));\n        else\n            assert(PyBytes_CheckExact(writer->buffer));\n        assert(Py_REFCNT(writer->buffer) == 1);\n    }\n\n    if (writer->use_bytearray) {\n        /* bytearray has its own overallocation algorithm,\n           writer overallocation must be disabled */\n        assert(!writer->overallocate);\n    }\n\n    assert(0 <= writer->allocated);\n    assert(0 <= writer->min_size && writer->min_size <= writer->allocated);\n    /* the last byte must always be null */\n    start = _PyBytesWriter_AsString(writer);\n    assert(start[writer->allocated] == 0);\n\n    end = start + writer->allocated;\n    assert(str != NULL);\n    assert(start <= str && str <= end);\n    return 1;\n}\n#endif\n\nvoid*\n_PyBytesWriter_Resize(_PyBytesWriter *writer, void *str, Py_ssize_t size)\n{\n    Py_ssize_t allocated, pos;\n\n    assert(_PyBytesWriter_CheckConsistency(writer, str));\n    assert(writer->allocated < size);\n\n    allocated = size;\n    if (writer->overallocate\n        && allocated <= (PY_SSIZE_T_MAX - allocated / OVERALLOCATE_FACTOR)) {\n        /* overallocate to limit the number of realloc() */\n        allocated += allocated / OVERALLOCATE_FACTOR;\n    }\n\n    pos = _PyBytesWriter_GetSize(writer, str);\n    if (!writer->use_small_buffer) {\n        if (writer->use_bytearray) {\n            if (PyByteArray_Resize(writer->buffer, allocated))\n                goto error;\n            /* writer->allocated can be smaller than writer->buffer->ob_alloc,\n               but we cannot use ob_alloc because bytes may need to be moved\n               to use the whole buffer. bytearray uses an internal optimization\n               to avoid moving or copying bytes when bytes are removed at the\n               beginning (ex: del bytearray[:1]). */\n        }\n        else {\n            if (_PyBytes_Resize(&writer->buffer, allocated))\n                goto error;\n        }\n    }\n    else {\n        /* convert from stack buffer to bytes object buffer */\n        assert(writer->buffer == NULL);\n\n        if (writer->use_bytearray)\n            writer->buffer = PyByteArray_FromStringAndSize(NULL, allocated);\n        else\n            writer->buffer = PyBytes_FromStringAndSize(NULL, allocated);\n        if (writer->buffer == NULL)\n            goto error;\n\n        if (pos != 0) {\n            char *dest;\n            if (writer->use_bytearray)\n                dest = PyByteArray_AS_STRING(writer->buffer);\n            else\n                dest = PyBytes_AS_STRING(writer->buffer);\n            memcpy(dest,\n                      writer->small_buffer,\n                      pos);\n        }\n\n        writer->use_small_buffer = 0;\n#ifndef NDEBUG\n        memset(writer->small_buffer, PYMEM_CLEANBYTE,\n               sizeof(writer->small_buffer));\n#endif\n    }\n    writer->allocated = allocated;\n\n    str = _PyBytesWriter_AsString(writer) + pos;\n    assert(_PyBytesWriter_CheckConsistency(writer, str));\n    return str;\n\nerror:\n    _PyBytesWriter_Dealloc(writer);\n    return NULL;\n}\n\nvoid*\n_PyBytesWriter_Prepare(_PyBytesWriter *writer, void *str, Py_ssize_t size)\n{\n    Py_ssize_t new_min_size;\n\n    assert(_PyBytesWriter_CheckConsistency(writer, str));\n    assert(size >= 0);\n\n    if (size == 0) {\n        /* nothing to do */\n        return str;\n    }\n\n    if (writer->min_size > PY_SSIZE_T_MAX - size) {\n        PyErr_NoMemory();\n        _PyBytesWriter_Dealloc(writer);\n        return NULL;\n    }\n    new_min_size = writer->min_size + size;\n\n    if (new_min_size > writer->allocated)\n        str = _PyBytesWriter_Resize(writer, str, new_min_size);\n\n    writer->min_size = new_min_size;\n    return str;\n}\n\n/* Allocate the buffer to write size bytes.\n   Return the pointer to the beginning of buffer data.\n   Raise an exception and return NULL on error. */\nvoid*\n_PyBytesWriter_Alloc(_PyBytesWriter *writer, Py_ssize_t size)\n{\n    /* ensure that _PyBytesWriter_Alloc() is only called once */\n    assert(writer->min_size == 0 && writer->buffer == NULL);\n    assert(size >= 0);\n\n    writer->use_small_buffer = 1;\n#ifndef NDEBUG\n    writer->allocated = sizeof(writer->small_buffer) - 1;\n    /* In debug mode, don't use the full small buffer because it is less\n       efficient than bytes and bytearray objects to detect buffer underflow\n       and buffer overflow. Use 10 bytes of the small buffer to test also\n       code using the smaller buffer in debug mode.\n\n       Don't modify the _PyBytesWriter structure (use a shorter small buffer)\n       in debug mode to also be able to detect stack overflow when running\n       tests in debug mode. The _PyBytesWriter is large (more than 512 bytes),\n       if _Py_EnterRecursiveCall() is not used in deep C callback, we may hit a\n       stack overflow. */\n    writer->allocated = Py_MIN(writer->allocated, 10);\n    /* _PyBytesWriter_CheckConsistency() requires the last byte to be 0,\n       to detect buffer overflow */\n    writer->small_buffer[writer->allocated] = 0;\n#else\n    writer->allocated = sizeof(writer->small_buffer);\n#endif\n    return _PyBytesWriter_Prepare(writer, writer->small_buffer, size);\n}\n\nPyObject *\n_PyBytesWriter_Finish(_PyBytesWriter *writer, void *str)\n{\n    Py_ssize_t size;\n    PyObject *result;\n\n    assert(_PyBytesWriter_CheckConsistency(writer, str));\n\n    size = _PyBytesWriter_GetSize(writer, str);\n    if (size == 0 && !writer->use_bytearray) {\n        Py_CLEAR(writer->buffer);\n        /* Get the empty byte string singleton */\n        result = PyBytes_FromStringAndSize(NULL, 0);\n    }\n    else if (writer->use_small_buffer) {\n        if (writer->use_bytearray) {\n            result = PyByteArray_FromStringAndSize(writer->small_buffer, size);\n        }\n        else {\n            result = PyBytes_FromStringAndSize(writer->small_buffer, size);\n        }\n    }\n    else {\n        result = writer->buffer;\n        writer->buffer = NULL;\n\n        if (size != writer->allocated) {\n            if (writer->use_bytearray) {\n                if (PyByteArray_Resize(result, size)) {\n                    Py_DECREF(result);\n                    return NULL;\n                }\n            }\n            else {\n                if (_PyBytes_Resize(&result, size)) {\n                    assert(result == NULL);\n                    return NULL;\n                }\n            }\n        }\n    }\n    return result;\n}\n\nvoid*\n_PyBytesWriter_WriteBytes(_PyBytesWriter *writer, void *ptr,\n                          const void *bytes, Py_ssize_t size)\n{\n    char *str = (char *)ptr;\n\n    str = _PyBytesWriter_Prepare(writer, str, size);\n    if (str == NULL)\n        return NULL;\n\n    memcpy(str, bytes, size);\n    str += size;\n\n    return str;\n}\n\n\nvoid\n_PyBytes_Repeat(char* dest, Py_ssize_t len_dest,\n    const char* src, Py_ssize_t len_src)\n{\n    if (len_dest == 0) {\n        return;\n    }\n    if (len_src == 1) {\n        memset(dest, src[0], len_dest);\n    }\n    else {\n        if (src != dest) {\n            memcpy(dest, src, len_src);\n        }\n        Py_ssize_t copied = len_src;\n        while (copied < len_dest) {\n            Py_ssize_t bytes_to_copy = Py_MIN(copied, len_dest - copied);\n            memcpy(dest + copied, dest, bytes_to_copy);\n            copied += bytes_to_copy;\n        }\n    }\n}\n\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value '*str'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 127, "startColumn": 14, "endColumn": 15}, "contextRegion": {"startLine": 127, "snippet": {"text": "        op = CHARACTER(*str & 255);\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize.part.0", "fullyQualifiedName": "PyBytes_FromStringAndSize.part.0", "decoratedName": "PyBytes_FromStringAndSize.part.0", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2694, "startColumn": 1, "endColumn": 18}, "contextRegion": {"startLine": 2694, "snippet": {"text": "_PyBytes_FromList(PyObject *x)\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "entry to '_PyBytes_FromList'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2700, "startColumn": 20, "endColumn": 26}, "contextRegion": {"startLine": 2700, "snippet": {"text": "    _PyBytesWriter writer;\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2703, "startColumn": 11, "endColumn": 12}, "contextRegion": {"startLine": 2703, "snippet": {"text": "    str = _PyBytesWriter_Alloc(&writer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "inlined call to '_PyBytesWriter_Alloc' from '_PyBytes_FromList'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3478, "startColumn": 12, "endColumn": 70}, "contextRegion": {"startLine": 3478, "snippet": {"text": "    return _PyBytesWriter_Prepare(writer, writer->small_buffer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Alloc", "fullyQualifiedName": "_PyBytesWriter_Alloc", "decoratedName": "_PyBytesWriter_Alloc", "kind": "function"}], "message": {"text": "calling '_PyBytesWriter_Prepare' from '_PyBytes_FromList'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3422, "startColumn": 1, "endColumn": 23}, "contextRegion": {"startLine": 3422, "snippet": {"text": "_PyBytesWriter_Prepare(_PyBytesWriter *writer, void *str, Py_ssize_t size)\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Prepare", "fullyQualifiedName": "_PyBytesWriter_Prepare", "decoratedName": "_PyBytesWriter_Prepare", "kind": "function"}], "message": {"text": "entry to '_PyBytesWriter_Prepare'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3429, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3429, "snippet": {"text": "    if (size == 0) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Prepare", "fullyQualifiedName": "_PyBytesWriter_Prepare", "decoratedName": "_PyBytesWriter_Prepare", "kind": "function"}], "message": {"text": "following 'true' branch (when 'size == 0')..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"logicalLocations": [{"name": "_PyBytesWriter_Prepare", "fullyQualifiedName": "_PyBytesWriter_Prepare", "decoratedName": "_PyBytesWriter_Prepare", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2703, "startColumn": 11, "endColumn": 12}, "contextRegion": {"startLine": 2703, "snippet": {"text": "    str = _PyBytesWriter_Alloc(&writer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "inlined call to '_PyBytesWriter_Alloc' from '_PyBytes_FromList'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3478, "startColumn": 12, "endColumn": 70}, "contextRegion": {"startLine": 3478, "snippet": {"text": "    return _PyBytesWriter_Prepare(writer, writer->small_buffer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Alloc", "fullyQualifiedName": "_PyBytesWriter_Alloc", "decoratedName": "_PyBytesWriter_Alloc", "kind": "function"}], "message": {"text": "returning to '_PyBytes_FromList' from '_PyBytesWriter_Prepare'"}}, "kinds": ["return", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2704, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2704, "snippet": {"text": "    if (str == NULL)\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2706, "startColumn": 5, "endColumn": 11}, "contextRegion": {"startLine": 2706, "snippet": {"text": "    writer.overallocate = 1;\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2709, "startColumn": 17, "endColumn": 22}, "contextRegion": {"startLine": 2709, "snippet": {"text": "    for (i = 0; i < PyList_GET_SIZE(x); i++) {\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2731, "startColumn": 5, "endColumn": 11}, "contextRegion": {"startLine": 2731, "snippet": {"text": "    return _PyBytesWriter_Finish(&writer, str);\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2731, "startColumn": 12, "endColumn": 47}, "contextRegion": {"startLine": 2731, "snippet": {"text": "    return _PyBytesWriter_Finish(&writer, str);\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "calling '_PyBytesWriter_Finish' from '_PyBytes_FromList'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3482, "startColumn": 1, "endColumn": 22}, "contextRegion": {"startLine": 3482, "snippet": {"text": "_PyBytesWriter_Finish(_PyBytesWriter *writer, void *str)\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "entry to '_PyBytesWriter_Finish'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3489, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 3489, "snippet": {"text": "    size = _PyBytesWriter_GetSize(writer, str);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "inlined call to '_PyBytesWriter_GetSize' from '_PyBytesWriter_Finish'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3307, "startColumn": 25, "endColumn": 26}, "contextRegion": {"startLine": 3307, "snippet": {"text": "    const char *start = _PyBytesWriter_AsString(writer);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_GetSize", "fullyQualifiedName": "_PyBytesWriter_GetSize", "decoratedName": "_PyBytesWriter_GetSize", "kind": "function"}], "message": {"text": "inlined call to '_PyBytesWriter_AsString' from '_PyBytesWriter_GetSize'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3290, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3290, "snippet": {"text": "    if (writer->use_small_buffer) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_AsString", "fullyQualifiedName": "_PyBytesWriter_AsString", "decoratedName": "_PyBytesWriter_AsString", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3291, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 3291, "snippet": {"text": "        assert(writer->buffer == NULL);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_AsString", "fullyQualifiedName": "_PyBytesWriter_AsString", "decoratedName": "_PyBytesWriter_AsString", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3490, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3490, "snippet": {"text": "    if (size == 0 && !writer->use_bytearray) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3495, "startColumn": 10, "endColumn": 12}, "contextRegion": {"startLine": 3495, "snippet": {"text": "    else if (writer->use_small_buffer) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3495, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 3495, "snippet": {"text": "    else if (writer->use_small_buffer) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3496, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 3496, "snippet": {"text": "        if (writer->use_bytearray) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3496, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 3496, "snippet": {"text": "        if (writer->use_bytearray) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3500, "startColumn": 13, "endColumn": 19}, "contextRegion": {"startLine": 3500, "snippet": {"text": "            result = PyBytes_FromStringAndSize(writer->small_buffer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3500, "startColumn": 22, "endColumn": 75}, "contextRegion": {"startLine": 3500, "snippet": {"text": "            result = PyBytes_FromStringAndSize(writer->small_buffer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "calling 'PyBytes_FromStringAndSize' from '_PyBytesWriter_Finish'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 118, "startColumn": 1, "endColumn": 26}, "contextRegion": {"startLine": 118, "snippet": {"text": "PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "entry to 'PyBytes_FromStringAndSize'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 121, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 121, "snippet": {"text": "    if (size < 0) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "following 'false' branch (when 'size >= 0')..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 126, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 126, "snippet": {"text": "    if (size == 1 && str != NULL) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 126, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 126, "snippet": {"text": "    if (size == 1 && str != NULL) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "calling 'PyBytes_FromStringAndSize.part.0' from 'PyBytes_FromStringAndSize'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 118, "startColumn": 1, "endColumn": 26}, "contextRegion": {"startLine": 118, "snippet": {"text": "PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize.part.0", "fullyQualifiedName": "PyBytes_FromStringAndSize.part.0", "decoratedName": "PyBytes_FromStringAndSize.part.0", "kind": "function"}], "message": {"text": "entry to 'PyBytes_FromStringAndSize.part.0'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 127, "startColumn": 14, "endColumn": 15}, "contextRegion": {"startLine": 127, "snippet": {"text": "        op = CHARACTER(*str & 255);\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize.part.0", "fullyQualifiedName": "PyBytes_FromStringAndSize.part.0", "decoratedName": "PyBytes_FromStringAndSize.part.0", "kind": "function"}], "message": {"text": "use of uninitialized value '*str' here"}}, "kinds": ["danger"], "nestingLevel": 4}]}]}]}, {"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value '*str'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 127, "startColumn": 14, "endColumn": 15}, "contextRegion": {"startLine": 127, "snippet": {"text": "        op = CHARACTER(*str & 255);\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize.part.0", "fullyQualifiedName": "PyBytes_FromStringAndSize.part.0", "decoratedName": "PyBytes_FromStringAndSize.part.0", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2835, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 2835, "snippet": {"text": "PyBytes_FromObject(PyObject *x)\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "entry to 'PyBytes_FromObject'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2839, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2839, "snippet": {"text": "    if (x == NULL) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "following 'false' branch (when 'x' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2844, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 2844, "snippet": {"text": "    if (PyBytes_CheckExact(x)) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2844, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2844, "snippet": {"text": "    if (PyBytes_CheckExact(x)) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2849, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 2849, "snippet": {"text": "    if (PyObject_CheckBuffer(x))\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2849, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2849, "snippet": {"text": "    if (PyObject_CheckBuffer(x))\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2852, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 2852, "snippet": {"text": "    if (PyList_CheckExact(x))\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2852, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2852, "snippet": {"text": "    if (PyList_CheckExact(x))\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2853, "startColumn": 9, "endColumn": 15}, "contextRegion": {"startLine": 2853, "snippet": {"text": "        return _PyBytes_FromList(x);\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2853, "startColumn": 16, "endColumn": 36}, "contextRegion": {"startLine": 2853, "snippet": {"text": "        return _PyBytes_FromList(x);\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "calling '_PyBytes_FromList' from 'PyBytes_FromObject'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2694, "startColumn": 1, "endColumn": 18}, "contextRegion": {"startLine": 2694, "snippet": {"text": "_PyBytes_FromList(PyObject *x)\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "entry to '_PyBytes_FromList'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2700, "startColumn": 20, "endColumn": 26}, "contextRegion": {"startLine": 2700, "snippet": {"text": "    _PyBytesWriter writer;\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2703, "startColumn": 11, "endColumn": 12}, "contextRegion": {"startLine": 2703, "snippet": {"text": "    str = _PyBytesWriter_Alloc(&writer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "inlined call to '_PyBytesWriter_Alloc' from '_PyBytes_FromList'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3478, "startColumn": 12, "endColumn": 70}, "contextRegion": {"startLine": 3478, "snippet": {"text": "    return _PyBytesWriter_Prepare(writer, writer->small_buffer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Alloc", "fullyQualifiedName": "_PyBytesWriter_Alloc", "decoratedName": "_PyBytesWriter_Alloc", "kind": "function"}], "message": {"text": "calling '_PyBytesWriter_Prepare' from '_PyBytes_FromList'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3422, "startColumn": 1, "endColumn": 23}, "contextRegion": {"startLine": 3422, "snippet": {"text": "_PyBytesWriter_Prepare(_PyBytesWriter *writer, void *str, Py_ssize_t size)\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Prepare", "fullyQualifiedName": "_PyBytesWriter_Prepare", "decoratedName": "_PyBytesWriter_Prepare", "kind": "function"}], "message": {"text": "entry to '_PyBytesWriter_Prepare'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3429, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3429, "snippet": {"text": "    if (size == 0) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Prepare", "fullyQualifiedName": "_PyBytesWriter_Prepare", "decoratedName": "_PyBytesWriter_Prepare", "kind": "function"}], "message": {"text": "following 'true' branch (when 'size == 0')..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"logicalLocations": [{"name": "_PyBytesWriter_Prepare", "fullyQualifiedName": "_PyBytesWriter_Prepare", "decoratedName": "_PyBytesWriter_Prepare", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2703, "startColumn": 11, "endColumn": 12}, "contextRegion": {"startLine": 2703, "snippet": {"text": "    str = _PyBytesWriter_Alloc(&writer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "inlined call to '_PyBytesWriter_Alloc' from '_PyBytes_FromList'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3478, "startColumn": 12, "endColumn": 70}, "contextRegion": {"startLine": 3478, "snippet": {"text": "    return _PyBytesWriter_Prepare(writer, writer->small_buffer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Alloc", "fullyQualifiedName": "_PyBytesWriter_Alloc", "decoratedName": "_PyBytesWriter_Alloc", "kind": "function"}], "message": {"text": "returning to '_PyBytes_FromList' from '_PyBytesWriter_Prepare'"}}, "kinds": ["return", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2704, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2704, "snippet": {"text": "    if (str == NULL)\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2706, "startColumn": 5, "endColumn": 11}, "contextRegion": {"startLine": 2706, "snippet": {"text": "    writer.overallocate = 1;\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2709, "startColumn": 17, "endColumn": 22}, "contextRegion": {"startLine": 2709, "snippet": {"text": "    for (i = 0; i < PyList_GET_SIZE(x); i++) {\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2731, "startColumn": 5, "endColumn": 11}, "contextRegion": {"startLine": 2731, "snippet": {"text": "    return _PyBytesWriter_Finish(&writer, str);\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2731, "startColumn": 12, "endColumn": 47}, "contextRegion": {"startLine": 2731, "snippet": {"text": "    return _PyBytesWriter_Finish(&writer, str);\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "calling '_PyBytesWriter_Finish' from '_PyBytes_FromList'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3482, "startColumn": 1, "endColumn": 22}, "contextRegion": {"startLine": 3482, "snippet": {"text": "_PyBytesWriter_Finish(_PyBytesWriter *writer, void *str)\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "entry to '_PyBytesWriter_Finish'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3489, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 3489, "snippet": {"text": "    size = _PyBytesWriter_GetSize(writer, str);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "inlined call to '_PyBytesWriter_GetSize' from '_PyBytesWriter_Finish'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3307, "startColumn": 25, "endColumn": 26}, "contextRegion": {"startLine": 3307, "snippet": {"text": "    const char *start = _PyBytesWriter_AsString(writer);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_GetSize", "fullyQualifiedName": "_PyBytesWriter_GetSize", "decoratedName": "_PyBytesWriter_GetSize", "kind": "function"}], "message": {"text": "inlined call to '_PyBytesWriter_AsString' from '_PyBytesWriter_GetSize'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3290, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3290, "snippet": {"text": "    if (writer->use_small_buffer) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_AsString", "fullyQualifiedName": "_PyBytesWriter_AsString", "decoratedName": "_PyBytesWriter_AsString", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3291, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 3291, "snippet": {"text": "        assert(writer->buffer == NULL);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_AsString", "fullyQualifiedName": "_PyBytesWriter_AsString", "decoratedName": "_PyBytesWriter_AsString", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3490, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3490, "snippet": {"text": "    if (size == 0 && !writer->use_bytearray) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3495, "startColumn": 10, "endColumn": 12}, "contextRegion": {"startLine": 3495, "snippet": {"text": "    else if (writer->use_small_buffer) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3495, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 3495, "snippet": {"text": "    else if (writer->use_small_buffer) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3496, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 3496, "snippet": {"text": "        if (writer->use_bytearray) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3496, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 3496, "snippet": {"text": "        if (writer->use_bytearray) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3500, "startColumn": 13, "endColumn": 19}, "contextRegion": {"startLine": 3500, "snippet": {"text": "            result = PyBytes_FromStringAndSize(writer->small_buffer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3500, "startColumn": 22, "endColumn": 75}, "contextRegion": {"startLine": 3500, "snippet": {"text": "            result = PyBytes_FromStringAndSize(writer->small_buffer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "calling 'PyBytes_FromStringAndSize' from '_PyBytesWriter_Finish'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 118, "startColumn": 1, "endColumn": 26}, "contextRegion": {"startLine": 118, "snippet": {"text": "PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "entry to 'PyBytes_FromStringAndSize'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 121, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 121, "snippet": {"text": "    if (size < 0) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "following 'false' branch (when 'size >= 0')..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 126, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 126, "snippet": {"text": "    if (size == 1 && str != NULL) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 126, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 126, "snippet": {"text": "    if (size == 1 && str != NULL) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "calling 'PyBytes_FromStringAndSize.part.0' from 'PyBytes_FromStringAndSize'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 118, "startColumn": 1, "endColumn": 26}, "contextRegion": {"startLine": 118, "snippet": {"text": "PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize.part.0", "fullyQualifiedName": "PyBytes_FromStringAndSize.part.0", "decoratedName": "PyBytes_FromStringAndSize.part.0", "kind": "function"}], "message": {"text": "entry to 'PyBytes_FromStringAndSize.part.0'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 127, "startColumn": 14, "endColumn": 15}, "contextRegion": {"startLine": 127, "snippet": {"text": "        op = CHARACTER(*str & 255);\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize.part.0", "fullyQualifiedName": "PyBytes_FromStringAndSize.part.0", "decoratedName": "PyBytes_FromStringAndSize.part.0", "kind": "function"}], "message": {"text": "use of uninitialized value '*str' here"}}, "kinds": ["danger"], "nestingLevel": 5}]}]}]}, {"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value '*str'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 127, "startColumn": 14, "endColumn": 15}, "contextRegion": {"startLine": 127, "snippet": {"text": "        op = CHARACTER(*str & 255);\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize.part.0", "fullyQualifiedName": "PyBytes_FromStringAndSize.part.0", "decoratedName": "PyBytes_FromStringAndSize.part.0", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2584, "startColumn": 1, "endColumn": 15}, "contextRegion": {"startLine": 2584, "snippet": {"text": "bytes_new_impl(PyTypeObject *type, PyObject *x, const char *encoding,\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "entry to 'bytes_new_impl'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2592, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2592, "snippet": {"text": "    if (x == NULL) {\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "following 'false' branch (when 'x' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2602, "startColumn": 10, "endColumn": 12}, "contextRegion": {"startLine": 2602, "snippet": {"text": "    else if (encoding != NULL) {\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2602, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 2602, "snippet": {"text": "    else if (encoding != NULL) {\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "following 'false' branch (when 'encoding' is NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2611, "startColumn": 10, "endColumn": 12}, "contextRegion": {"startLine": 2611, "snippet": {"text": "    else if (errors != NULL) {\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2611, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 2611, "snippet": {"text": "    else if (errors != NULL) {\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "following 'false' branch (when 'errors' is NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2621, "startColumn": 10, "endColumn": 12}, "contextRegion": {"startLine": 2621, "snippet": {"text": "    else if ((func = _PyObject_LookupSpecial(x, &_Py_ID(__bytes__))) != NULL) {\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2621, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 2621, "snippet": {"text": "    else if ((func = _PyObject_LookupSpecial(x, &_Py_ID(__bytes__))) != NULL) {\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "following 'false' branch (when 'func' is NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2634, "startColumn": 10, "endColumn": 12}, "contextRegion": {"startLine": 2634, "snippet": {"text": "    else if (PyErr_Occurred())\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2634, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 2634, "snippet": {"text": "    else if (PyErr_Occurred())\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2636, "startColumn": 10, "endColumn": 12}, "contextRegion": {"startLine": 2636, "snippet": {"text": "    else if (PyUnicode_Check(x)) {\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2636, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 2636, "snippet": {"text": "    else if (PyUnicode_Check(x)) {\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2642, "startColumn": 10, "endColumn": 12}, "contextRegion": {"startLine": 2642, "snippet": {"text": "    else if (_PyIndex_Check(x)) {\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2659, "startColumn": 17, "endColumn": 38}, "contextRegion": {"startLine": 2659, "snippet": {"text": "        bytes = PyBytes_FromObject(x);\n"}}}, "logicalLocations": [{"name": "bytes_new_impl", "fullyQualifiedName": "bytes_new_impl", "decoratedName": "bytes_new_impl", "kind": "function"}], "message": {"text": "calling 'PyBytes_FromObject' from 'bytes_new_impl'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2835, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 2835, "snippet": {"text": "PyBytes_FromObject(PyObject *x)\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "entry to 'PyBytes_FromObject'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2839, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2839, "snippet": {"text": "    if (x == NULL) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "following 'false' branch (when 'x' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2844, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 2844, "snippet": {"text": "    if (PyBytes_CheckExact(x)) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2844, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2844, "snippet": {"text": "    if (PyBytes_CheckExact(x)) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2849, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 2849, "snippet": {"text": "    if (PyObject_CheckBuffer(x))\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2849, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2849, "snippet": {"text": "    if (PyObject_CheckBuffer(x))\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2852, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 2852, "snippet": {"text": "    if (PyList_CheckExact(x))\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2852, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2852, "snippet": {"text": "    if (PyList_CheckExact(x))\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2853, "startColumn": 9, "endColumn": 15}, "contextRegion": {"startLine": 2853, "snippet": {"text": "        return _PyBytes_FromList(x);\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2853, "startColumn": 16, "endColumn": 36}, "contextRegion": {"startLine": 2853, "snippet": {"text": "        return _PyBytes_FromList(x);\n"}}}, "logicalLocations": [{"name": "PyBytes_FromObject", "fullyQualifiedName": "PyBytes_FromObject", "decoratedName": "PyBytes_FromObject", "kind": "function"}], "message": {"text": "calling '_PyBytes_FromList' from 'PyBytes_FromObject'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2694, "startColumn": 1, "endColumn": 18}, "contextRegion": {"startLine": 2694, "snippet": {"text": "_PyBytes_FromList(PyObject *x)\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "entry to '_PyBytes_FromList'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2700, "startColumn": 20, "endColumn": 26}, "contextRegion": {"startLine": 2700, "snippet": {"text": "    _PyBytesWriter writer;\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2703, "startColumn": 11, "endColumn": 12}, "contextRegion": {"startLine": 2703, "snippet": {"text": "    str = _PyBytesWriter_Alloc(&writer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "inlined call to '_PyBytesWriter_Alloc' from '_PyBytes_FromList'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3478, "startColumn": 12, "endColumn": 70}, "contextRegion": {"startLine": 3478, "snippet": {"text": "    return _PyBytesWriter_Prepare(writer, writer->small_buffer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Alloc", "fullyQualifiedName": "_PyBytesWriter_Alloc", "decoratedName": "_PyBytesWriter_Alloc", "kind": "function"}], "message": {"text": "calling '_PyBytesWriter_Prepare' from '_PyBytes_FromList'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3422, "startColumn": 1, "endColumn": 23}, "contextRegion": {"startLine": 3422, "snippet": {"text": "_PyBytesWriter_Prepare(_PyBytesWriter *writer, void *str, Py_ssize_t size)\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Prepare", "fullyQualifiedName": "_PyBytesWriter_Prepare", "decoratedName": "_PyBytesWriter_Prepare", "kind": "function"}], "message": {"text": "entry to '_PyBytesWriter_Prepare'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3429, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3429, "snippet": {"text": "    if (size == 0) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Prepare", "fullyQualifiedName": "_PyBytesWriter_Prepare", "decoratedName": "_PyBytesWriter_Prepare", "kind": "function"}], "message": {"text": "following 'true' branch (when 'size == 0')..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"logicalLocations": [{"name": "_PyBytesWriter_Prepare", "fullyQualifiedName": "_PyBytesWriter_Prepare", "decoratedName": "_PyBytesWriter_Prepare", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2703, "startColumn": 11, "endColumn": 12}, "contextRegion": {"startLine": 2703, "snippet": {"text": "    str = _PyBytesWriter_Alloc(&writer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "inlined call to '_PyBytesWriter_Alloc' from '_PyBytes_FromList'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3478, "startColumn": 12, "endColumn": 70}, "contextRegion": {"startLine": 3478, "snippet": {"text": "    return _PyBytesWriter_Prepare(writer, writer->small_buffer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Alloc", "fullyQualifiedName": "_PyBytesWriter_Alloc", "decoratedName": "_PyBytesWriter_Alloc", "kind": "function"}], "message": {"text": "returning to '_PyBytes_FromList' from '_PyBytesWriter_Prepare'"}}, "kinds": ["return", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2704, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2704, "snippet": {"text": "    if (str == NULL)\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2706, "startColumn": 5, "endColumn": 11}, "contextRegion": {"startLine": 2706, "snippet": {"text": "    writer.overallocate = 1;\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2709, "startColumn": 17, "endColumn": 22}, "contextRegion": {"startLine": 2709, "snippet": {"text": "    for (i = 0; i < PyList_GET_SIZE(x); i++) {\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2731, "startColumn": 5, "endColumn": 11}, "contextRegion": {"startLine": 2731, "snippet": {"text": "    return _PyBytesWriter_Finish(&writer, str);\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2731, "startColumn": 12, "endColumn": 47}, "contextRegion": {"startLine": 2731, "snippet": {"text": "    return _PyBytesWriter_Finish(&writer, str);\n"}}}, "logicalLocations": [{"name": "_PyBytes_FromList", "fullyQualifiedName": "_PyBytes_FromList", "decoratedName": "_PyBytes_FromList", "kind": "function"}], "message": {"text": "calling '_PyBytesWriter_Finish' from '_PyBytes_FromList'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3482, "startColumn": 1, "endColumn": 22}, "contextRegion": {"startLine": 3482, "snippet": {"text": "_PyBytesWriter_Finish(_PyBytesWriter *writer, void *str)\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "entry to '_PyBytesWriter_Finish'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3489, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 3489, "snippet": {"text": "    size = _PyBytesWriter_GetSize(writer, str);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "inlined call to '_PyBytesWriter_GetSize' from '_PyBytesWriter_Finish'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3307, "startColumn": 25, "endColumn": 26}, "contextRegion": {"startLine": 3307, "snippet": {"text": "    const char *start = _PyBytesWriter_AsString(writer);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_GetSize", "fullyQualifiedName": "_PyBytesWriter_GetSize", "decoratedName": "_PyBytesWriter_GetSize", "kind": "function"}], "message": {"text": "inlined call to '_PyBytesWriter_AsString' from '_PyBytesWriter_GetSize'"}}, "kinds": ["call", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3290, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3290, "snippet": {"text": "    if (writer->use_small_buffer) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_AsString", "fullyQualifiedName": "_PyBytesWriter_AsString", "decoratedName": "_PyBytesWriter_AsString", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 6}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3291, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 3291, "snippet": {"text": "        assert(writer->buffer == NULL);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_AsString", "fullyQualifiedName": "_PyBytesWriter_AsString", "decoratedName": "_PyBytesWriter_AsString", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 6}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3490, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3490, "snippet": {"text": "    if (size == 0 && !writer->use_bytearray) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3495, "startColumn": 10, "endColumn": 12}, "contextRegion": {"startLine": 3495, "snippet": {"text": "    else if (writer->use_small_buffer) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3495, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 3495, "snippet": {"text": "    else if (writer->use_small_buffer) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3496, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 3496, "snippet": {"text": "        if (writer->use_bytearray) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3496, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 3496, "snippet": {"text": "        if (writer->use_bytearray) {\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3500, "startColumn": 13, "endColumn": 19}, "contextRegion": {"startLine": 3500, "snippet": {"text": "            result = PyBytes_FromStringAndSize(writer->small_buffer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 3500, "startColumn": 22, "endColumn": 75}, "contextRegion": {"startLine": 3500, "snippet": {"text": "            result = PyBytes_FromStringAndSize(writer->small_buffer, size);\n"}}}, "logicalLocations": [{"name": "_PyBytesWriter_Finish", "fullyQualifiedName": "_PyBytesWriter_Finish", "decoratedName": "_PyBytesWriter_Finish", "kind": "function"}], "message": {"text": "calling 'PyBytes_FromStringAndSize' from '_PyBytesWriter_Finish'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 118, "startColumn": 1, "endColumn": 26}, "contextRegion": {"startLine": 118, "snippet": {"text": "PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "entry to 'PyBytes_FromStringAndSize'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 121, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 121, "snippet": {"text": "    if (size < 0) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "following 'false' branch (when 'size >= 0')..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 126, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 126, "snippet": {"text": "    if (size == 1 && str != NULL) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 126, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 126, "snippet": {"text": "    if (size == 1 && str != NULL) {\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"logicalLocations": [{"name": "PyBytes_FromStringAndSize", "fullyQualifiedName": "PyBytes_FromStringAndSize", "decoratedName": "PyBytes_FromStringAndSize", "kind": "function"}], "message": {"text": "calling 'PyBytes_FromStringAndSize.part.0' from 'PyBytes_FromStringAndSize'"}}, "kinds": ["call", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 118, "startColumn": 1, "endColumn": 26}, "contextRegion": {"startLine": 118, "snippet": {"text": "PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize.part.0", "fullyQualifiedName": "PyBytes_FromStringAndSize.part.0", "decoratedName": "PyBytes_FromStringAndSize.part.0", "kind": "function"}], "message": {"text": "entry to 'PyBytes_FromStringAndSize.part.0'"}}, "kinds": ["enter", "function"], "nestingLevel": 6}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytesobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 127, "startColumn": 14, "endColumn": 15}, "contextRegion": {"startLine": 127, "snippet": {"text": "        op = CHARACTER(*str & 255);\n"}}}, "logicalLocations": [{"name": "PyBytes_FromStringAndSize.part.0", "fullyQualifiedName": "PyBytes_FromStringAndSize.part.0", "decoratedName": "PyBytes_FromStringAndSize.part.0", "kind": "function"}], "message": {"text": "use of uninitialized value '*str' here"}}, "kinds": ["danger"], "nestingLevel": 6}]}]}]}]}]}
