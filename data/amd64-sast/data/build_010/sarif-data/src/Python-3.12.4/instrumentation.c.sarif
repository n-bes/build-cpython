{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-use-of-uninitialized-value", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-use-of-uninitialized-value"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "457", "helpUri": "https://cwe.mitre.org/data/definitions/457.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}}, "artifacts": [{"location": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "contents": {"text": "\n\n\n\n#include \"Python.h\"\n#include \"pycore_call.h\"\n#include \"pycore_frame.h\"\n#include \"pycore_interp.h\"\n#include \"pycore_long.h\"\n#include \"pycore_namespace.h\"\n#include \"pycore_object.h\"\n#include \"pycore_opcode.h\"\n#include \"pycore_pyerrors.h\"\n#include \"pycore_pystate.h\"\n\n/* Uncomment this to dump debugging output when assertions fail */\n// #define INSTRUMENT_DEBUG 1\n\nPyObject _PyInstrumentation_DISABLE =\n{\n    .ob_refcnt = _Py_IMMORTAL_REFCNT,\n    .ob_type = &PyBaseObject_Type\n};\n\nPyObject _PyInstrumentation_MISSING =\n{\n    .ob_refcnt = _Py_IMMORTAL_REFCNT,\n    .ob_type = &PyBaseObject_Type\n};\n\nstatic const int8_t EVENT_FOR_OPCODE[256] = {\n    [RETURN_CONST] = PY_MONITORING_EVENT_PY_RETURN,\n    [INSTRUMENTED_RETURN_CONST] = PY_MONITORING_EVENT_PY_RETURN,\n    [RETURN_VALUE] = PY_MONITORING_EVENT_PY_RETURN,\n    [INSTRUMENTED_RETURN_VALUE] = PY_MONITORING_EVENT_PY_RETURN,\n    [CALL] = PY_MONITORING_EVENT_CALL,\n    [INSTRUMENTED_CALL] = PY_MONITORING_EVENT_CALL,\n    [CALL_FUNCTION_EX] = PY_MONITORING_EVENT_CALL,\n    [INSTRUMENTED_CALL_FUNCTION_EX] = PY_MONITORING_EVENT_CALL,\n    [LOAD_SUPER_ATTR] = PY_MONITORING_EVENT_CALL,\n    [INSTRUMENTED_LOAD_SUPER_ATTR] = PY_MONITORING_EVENT_CALL,\n    [RESUME] = -1,\n    [YIELD_VALUE] = PY_MONITORING_EVENT_PY_YIELD,\n    [INSTRUMENTED_YIELD_VALUE] = PY_MONITORING_EVENT_PY_YIELD,\n    [JUMP_FORWARD] = PY_MONITORING_EVENT_JUMP,\n    [JUMP_BACKWARD] = PY_MONITORING_EVENT_JUMP,\n    [POP_JUMP_IF_FALSE] = PY_MONITORING_EVENT_BRANCH,\n    [POP_JUMP_IF_TRUE] = PY_MONITORING_EVENT_BRANCH,\n    [POP_JUMP_IF_NONE] = PY_MONITORING_EVENT_BRANCH,\n    [POP_JUMP_IF_NOT_NONE] = PY_MONITORING_EVENT_BRANCH,\n    [INSTRUMENTED_JUMP_FORWARD] = PY_MONITORING_EVENT_JUMP,\n    [INSTRUMENTED_JUMP_BACKWARD] = PY_MONITORING_EVENT_JUMP,\n    [INSTRUMENTED_POP_JUMP_IF_FALSE] = PY_MONITORING_EVENT_BRANCH,\n    [INSTRUMENTED_POP_JUMP_IF_TRUE] = PY_MONITORING_EVENT_BRANCH,\n    [INSTRUMENTED_POP_JUMP_IF_NONE] = PY_MONITORING_EVENT_BRANCH,\n    [INSTRUMENTED_POP_JUMP_IF_NOT_NONE] = PY_MONITORING_EVENT_BRANCH,\n    [FOR_ITER] = PY_MONITORING_EVENT_BRANCH,\n    [INSTRUMENTED_FOR_ITER] = PY_MONITORING_EVENT_BRANCH,\n    [END_FOR] = PY_MONITORING_EVENT_STOP_ITERATION,\n    [INSTRUMENTED_END_FOR] = PY_MONITORING_EVENT_STOP_ITERATION,\n    [END_SEND] = PY_MONITORING_EVENT_STOP_ITERATION,\n    [INSTRUMENTED_END_SEND] = PY_MONITORING_EVENT_STOP_ITERATION,\n};\n\nstatic const uint8_t DE_INSTRUMENT[256] = {\n    [INSTRUMENTED_RESUME] = RESUME,\n    [INSTRUMENTED_RETURN_VALUE] = RETURN_VALUE,\n    [INSTRUMENTED_RETURN_CONST] = RETURN_CONST,\n    [INSTRUMENTED_CALL] = CALL,\n    [INSTRUMENTED_CALL_FUNCTION_EX] = CALL_FUNCTION_EX,\n    [INSTRUMENTED_YIELD_VALUE] = YIELD_VALUE,\n    [INSTRUMENTED_JUMP_FORWARD] = JUMP_FORWARD,\n    [INSTRUMENTED_JUMP_BACKWARD] = JUMP_BACKWARD,\n    [INSTRUMENTED_POP_JUMP_IF_FALSE] = POP_JUMP_IF_FALSE,\n    [INSTRUMENTED_POP_JUMP_IF_TRUE] = POP_JUMP_IF_TRUE,\n    [INSTRUMENTED_POP_JUMP_IF_NONE] = POP_JUMP_IF_NONE,\n    [INSTRUMENTED_POP_JUMP_IF_NOT_NONE] = POP_JUMP_IF_NOT_NONE,\n    [INSTRUMENTED_FOR_ITER] = FOR_ITER,\n    [INSTRUMENTED_END_FOR] = END_FOR,\n    [INSTRUMENTED_END_SEND] = END_SEND,\n    [INSTRUMENTED_LOAD_SUPER_ATTR] = LOAD_SUPER_ATTR,\n};\n\nstatic const uint8_t INSTRUMENTED_OPCODES[256] = {\n    [RETURN_CONST] = INSTRUMENTED_RETURN_CONST,\n    [INSTRUMENTED_RETURN_CONST] = INSTRUMENTED_RETURN_CONST,\n    [RETURN_VALUE] = INSTRUMENTED_RETURN_VALUE,\n    [INSTRUMENTED_RETURN_VALUE] = INSTRUMENTED_RETURN_VALUE,\n    [CALL] = INSTRUMENTED_CALL,\n    [INSTRUMENTED_CALL] = INSTRUMENTED_CALL,\n    [CALL_FUNCTION_EX] = INSTRUMENTED_CALL_FUNCTION_EX,\n    [INSTRUMENTED_CALL_FUNCTION_EX] = INSTRUMENTED_CALL_FUNCTION_EX,\n    [YIELD_VALUE] = INSTRUMENTED_YIELD_VALUE,\n    [INSTRUMENTED_YIELD_VALUE] = INSTRUMENTED_YIELD_VALUE,\n    [RESUME] = INSTRUMENTED_RESUME,\n    [INSTRUMENTED_RESUME] = INSTRUMENTED_RESUME,\n    [JUMP_FORWARD] = INSTRUMENTED_JUMP_FORWARD,\n    [INSTRUMENTED_JUMP_FORWARD] = INSTRUMENTED_JUMP_FORWARD,\n    [JUMP_BACKWARD] = INSTRUMENTED_JUMP_BACKWARD,\n    [INSTRUMENTED_JUMP_BACKWARD] = INSTRUMENTED_JUMP_BACKWARD,\n    [POP_JUMP_IF_FALSE] = INSTRUMENTED_POP_JUMP_IF_FALSE,\n    [INSTRUMENTED_POP_JUMP_IF_FALSE] = INSTRUMENTED_POP_JUMP_IF_FALSE,\n    [POP_JUMP_IF_TRUE] = INSTRUMENTED_POP_JUMP_IF_TRUE,\n    [INSTRUMENTED_POP_JUMP_IF_TRUE] = INSTRUMENTED_POP_JUMP_IF_TRUE,\n    [POP_JUMP_IF_NONE] = INSTRUMENTED_POP_JUMP_IF_NONE,\n    [INSTRUMENTED_POP_JUMP_IF_NONE] = INSTRUMENTED_POP_JUMP_IF_NONE,\n    [POP_JUMP_IF_NOT_NONE] = INSTRUMENTED_POP_JUMP_IF_NOT_NONE,\n    [INSTRUMENTED_POP_JUMP_IF_NOT_NONE] = INSTRUMENTED_POP_JUMP_IF_NOT_NONE,\n    [END_FOR] = INSTRUMENTED_END_FOR,\n    [INSTRUMENTED_END_FOR] = INSTRUMENTED_END_FOR,\n    [END_SEND] = INSTRUMENTED_END_SEND,\n    [INSTRUMENTED_END_SEND] = INSTRUMENTED_END_SEND,\n    [FOR_ITER] = INSTRUMENTED_FOR_ITER,\n    [INSTRUMENTED_FOR_ITER] = INSTRUMENTED_FOR_ITER,\n    [LOAD_SUPER_ATTR] = INSTRUMENTED_LOAD_SUPER_ATTR,\n    [INSTRUMENTED_LOAD_SUPER_ATTR] = INSTRUMENTED_LOAD_SUPER_ATTR,\n\n    [INSTRUMENTED_LINE] = INSTRUMENTED_LINE,\n    [INSTRUMENTED_INSTRUCTION] = INSTRUMENTED_INSTRUCTION,\n};\n\nstatic inline bool\nopcode_has_event(int opcode)\n{\n    return (\n        opcode < INSTRUMENTED_LINE &&\n        INSTRUMENTED_OPCODES[opcode] > 0\n    );\n}\n\nstatic inline bool\nis_instrumented(int opcode)\n{\n    assert(opcode != 0);\n    assert(opcode != RESERVED);\n    return opcode >= MIN_INSTRUMENTED_OPCODE;\n}\n\n#ifndef NDEBUG\nstatic inline bool\nmonitors_equals(_Py_LocalMonitors a, _Py_LocalMonitors b)\n{\n    for (int i = 0; i < _PY_MONITORING_LOCAL_EVENTS; i++) {\n        if (a.tools[i] != b.tools[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n#endif\n\nstatic inline _Py_LocalMonitors\nmonitors_sub(_Py_LocalMonitors a, _Py_LocalMonitors b)\n{\n    _Py_LocalMonitors res;\n    for (int i = 0; i < _PY_MONITORING_LOCAL_EVENTS; i++) {\n        res.tools[i] = a.tools[i] & ~b.tools[i];\n    }\n    return res;\n}\n\n#ifndef NDEBUG\nstatic inline _Py_LocalMonitors\nmonitors_and(_Py_LocalMonitors a, _Py_LocalMonitors b)\n{\n    _Py_LocalMonitors res;\n    for (int i = 0; i < _PY_MONITORING_LOCAL_EVENTS; i++) {\n        res.tools[i] = a.tools[i] & b.tools[i];\n    }\n    return res;\n}\n#endif\n\n/* The union of the *local* events in a and b.\n * Global events like RAISE are ignored.\n * Used for instrumentation, as only local\n * events get instrumented.\n */\nstatic inline _Py_LocalMonitors\nlocal_union(_Py_GlobalMonitors a, _Py_LocalMonitors b)\n{\n    _Py_LocalMonitors res;\n    for (int i = 0; i < _PY_MONITORING_LOCAL_EVENTS; i++) {\n        res.tools[i] = a.tools[i] | b.tools[i];\n    }\n    return res;\n}\n\nstatic inline bool\nmonitors_are_empty(_Py_LocalMonitors m)\n{\n    for (int i = 0; i < _PY_MONITORING_LOCAL_EVENTS; i++) {\n        if (m.tools[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstatic inline bool\nmultiple_tools(_Py_LocalMonitors *m)\n{\n    for (int i = 0; i < _PY_MONITORING_LOCAL_EVENTS; i++) {\n        if (_Py_popcount32(m->tools[i]) > 1) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic inline _PyMonitoringEventSet\nget_local_events(_Py_LocalMonitors *m, int tool_id)\n{\n    _PyMonitoringEventSet result = 0;\n    for (int e = 0; e < _PY_MONITORING_LOCAL_EVENTS; e++) {\n        if ((m->tools[e] >> tool_id) & 1) {\n            result |= (1 << e);\n        }\n    }\n    return result;\n}\n\nstatic inline _PyMonitoringEventSet\nget_events(_Py_GlobalMonitors *m, int tool_id)\n{\n    _PyMonitoringEventSet result = 0;\n    for (int e = 0; e < _PY_MONITORING_UNGROUPED_EVENTS; e++) {\n        if ((m->tools[e] >> tool_id) & 1) {\n            result |= (1 << e);\n        }\n    }\n    return result;\n}\n\n/* Line delta.\n * 8 bit value.\n * if line_delta == -128:\n *     line = None # represented as -1\n * elif line_delta == -127:\n *     line = PyCode_Addr2Line(code, offset * sizeof(_Py_CODEUNIT));\n * else:\n *     line = first_line  + (offset >> OFFSET_SHIFT) + line_delta;\n */\n\n#define NO_LINE -128\n#define COMPUTED_LINE -127\n\n#define OFFSET_SHIFT 4\n\nstatic int8_t\ncompute_line_delta(PyCodeObject *code, int offset, int line)\n{\n    if (line < 0) {\n        return NO_LINE;\n    }\n    int delta = line - code->co_firstlineno - (offset >> OFFSET_SHIFT);\n    if (delta <= INT8_MAX && delta > COMPUTED_LINE) {\n        return delta;\n    }\n    return COMPUTED_LINE;\n}\n\nstatic int\ncompute_line(PyCodeObject *code, int offset, int8_t line_delta)\n{\n    if (line_delta > COMPUTED_LINE) {\n        return code->co_firstlineno + (offset >> OFFSET_SHIFT) + line_delta;\n    }\n    if (line_delta == NO_LINE) {\n\n        return -1;\n    }\n    assert(line_delta == COMPUTED_LINE);\n    /* Look it up */\n    return PyCode_Addr2Line(code, offset * sizeof(_Py_CODEUNIT));\n}\n\nstatic int\ninstruction_length(PyCodeObject *code, int offset)\n{\n    int opcode = _PyCode_CODE(code)[offset].op.code;\n    assert(opcode != 0);\n    assert(opcode != RESERVED);\n    if (opcode == INSTRUMENTED_LINE) {\n        opcode = code->_co_monitoring->lines[offset].original_opcode;\n    }\n    if (opcode == INSTRUMENTED_INSTRUCTION) {\n        opcode = code->_co_monitoring->per_instruction_opcodes[offset];\n    }\n    int deinstrumented = DE_INSTRUMENT[opcode];\n    if (deinstrumented) {\n        opcode = deinstrumented;\n    }\n    else {\n        opcode = _PyOpcode_Deopt[opcode];\n    }\n    assert(opcode != 0);\n    assert(!is_instrumented(opcode));\n    assert(opcode == _PyOpcode_Deopt[opcode]);\n    return 1 + _PyOpcode_Caches[opcode];\n}\n\n#ifdef INSTRUMENT_DEBUG\n\nstatic void\ndump_instrumentation_data_tools(PyCodeObject *code, uint8_t *tools, int i, FILE*out)\n{\n    if (tools == NULL) {\n        fprintf(out, \"tools = NULL\");\n    }\n    else {\n        fprintf(out, \"tools = %d\", tools[i]);\n    }\n}\n\nstatic void\ndump_instrumentation_data_lines(PyCodeObject *code, _PyCoLineInstrumentationData *lines, int i, FILE*out)\n{\n    if (lines == NULL) {\n        fprintf(out, \", lines = NULL\");\n    }\n    else if (lines[i].original_opcode == 0) {\n        fprintf(out, \", lines = {original_opcode = No LINE (0), line_delta = %d)\", lines[i].line_delta);\n    }\n    else {\n        fprintf(out, \", lines = {original_opcode = %s, line_delta = %d)\", _PyOpcode_OpName[lines[i].original_opcode], lines[i].line_delta);\n    }\n}\n\nstatic void\ndump_instrumentation_data_line_tools(PyCodeObject *code, uint8_t *line_tools, int i, FILE*out)\n{\n    if (line_tools == NULL) {\n        fprintf(out, \", line_tools = NULL\");\n    }\n    else {\n        fprintf(out, \", line_tools = %d\", line_tools[i]);\n    }\n}\n\nstatic void\ndump_instrumentation_data_per_instruction(PyCodeObject *code, _PyCoMonitoringData *data, int i, FILE*out)\n{\n    if (data->per_instruction_opcodes == NULL) {\n        fprintf(out, \", per-inst opcode = NULL\");\n    }\n    else {\n        fprintf(out, \", per-inst opcode = %s\", _PyOpcode_OpName[data->per_instruction_opcodes[i]]);\n    }\n    if (data->per_instruction_tools == NULL) {\n        fprintf(out, \", per-inst tools = NULL\");\n    }\n    else {\n        fprintf(out, \", per-inst tools = %d\", data->per_instruction_tools[i]);\n    }\n}\n\nstatic void\ndump_global_monitors(const char *prefix, _Py_GlobalMonitors monitors, FILE*out)\n{\n    fprintf(out, \"%s monitors:\\n\", prefix);\n    for (int event = 0; event < _PY_MONITORING_UNGROUPED_EVENTS; event++) {\n        fprintf(out, \"    Event %d: Tools %x\\n\", event, monitors.tools[event]);\n    }\n}\n\nstatic void\ndump_local_monitors(const char *prefix, _Py_LocalMonitors monitors, FILE*out)\n{\n    fprintf(out, \"%s monitors:\\n\", prefix);\n    for (int event = 0; event < _PY_MONITORING_LOCAL_EVENTS; event++) {\n        fprintf(out, \"    Event %d: Tools %x\\n\", event, monitors.tools[event]);\n    }\n}\n\n/* No error checking -- Don't use this for anything but experimental debugging */\nstatic void\ndump_instrumentation_data(PyCodeObject *code, int star, FILE*out)\n{\n    _PyCoMonitoringData *data = code->_co_monitoring;\n    fprintf(out, \"\\n\");\n    PyObject_Print(code->co_name, out, Py_PRINT_RAW);\n    fprintf(out, \"\\n\");\n    if (data == NULL) {\n        fprintf(out, \"NULL\\n\");\n        return;\n    }\n    dump_global_monitors(\"Global\", _PyInterpreterState_GET()->monitors, out);\n    dump_local_monitors(\"Code\", data->local_monitors, out);\n    dump_local_monitors(\"Active\", data->active_monitors, out);\n    int code_len = (int)Py_SIZE(code);\n    bool starred = false;\n    for (int i = 0; i < code_len; i += instruction_length(code, i)) {\n        _Py_CODEUNIT *instr = &_PyCode_CODE(code)[i];\n        int opcode = instr->op.code;\n        if (i == star) {\n            fprintf(out, \"**  \");\n            starred = true;\n        }\n        fprintf(out, \"Offset: %d, line: %d %s: \", i, PyCode_Addr2Line(code, i*2), _PyOpcode_OpName[opcode]);\n        dump_instrumentation_data_tools(code, data->tools, i, out);\n        dump_instrumentation_data_lines(code, data->lines, i, out);\n        dump_instrumentation_data_line_tools(code, data->line_tools, i, out);\n        dump_instrumentation_data_per_instruction(code, data, i, out);\n        fprintf(out, \"\\n\");\n        ;\n    }\n    if (!starred && star >= 0) {\n        fprintf(out, \"Error offset not at valid instruction offset: %d\\n\", star);\n        fprintf(out, \"    \");\n        dump_instrumentation_data_tools(code, data->tools, star, out);\n        dump_instrumentation_data_lines(code, data->lines, star, out);\n        dump_instrumentation_data_line_tools(code, data->line_tools, star, out);\n        dump_instrumentation_data_per_instruction(code, data, star, out);\n        fprintf(out, \"\\n\");\n    }\n}\n\n#define CHECK(test) do { \\\n    if (!(test)) { \\\n        dump_instrumentation_data(code, i, stderr); \\\n    } \\\n    assert(test); \\\n} while (0)\n\nstatic bool\nvalid_opcode(int opcode)\n{\n    if (opcode > 0 &&\n        opcode != RESERVED &&\n        opcode < 255 &&\n        _PyOpcode_OpName[opcode] &&\n        _PyOpcode_OpName[opcode][0] != '<')\n    {\n       return true;\n    }\n    return false;\n}\n\nstatic void\nsanity_check_instrumentation(PyCodeObject *code)\n{\n    _PyCoMonitoringData *data = code->_co_monitoring;\n    if (data == NULL) {\n        return;\n    }\n    _Py_GlobalMonitors global_monitors = _PyInterpreterState_GET()->monitors;\n    _Py_LocalMonitors active_monitors;\n    if (code->_co_monitoring) {\n        _Py_LocalMonitors local_monitors = code->_co_monitoring->local_monitors;\n        active_monitors = local_union(global_monitors, local_monitors);\n    }\n    else {\n        _Py_LocalMonitors empty = (_Py_LocalMonitors) { 0 };\n        active_monitors = local_union(global_monitors, empty);\n    }\n    assert(monitors_equals(\n        code->_co_monitoring->active_monitors,\n        active_monitors));\n    int code_len = (int)Py_SIZE(code);\n    for (int i = 0; i < code_len;) {\n        _Py_CODEUNIT *instr = &_PyCode_CODE(code)[i];\n        int opcode = instr->op.code;\n        int base_opcode = _Py_GetBaseOpcode(code, i);\n        CHECK(valid_opcode(opcode));\n        CHECK(valid_opcode(base_opcode));\n        if (opcode == INSTRUMENTED_INSTRUCTION) {\n            opcode = data->per_instruction_opcodes[i];\n            if (!is_instrumented(opcode)) {\n                CHECK(_PyOpcode_Deopt[opcode] == opcode);\n            }\n            if (data->per_instruction_tools) {\n                uint8_t tools = active_monitors.tools[PY_MONITORING_EVENT_INSTRUCTION];\n                CHECK((tools & data->per_instruction_tools[i]) == data->per_instruction_tools[i]);\n            }\n        }\n        if (opcode == INSTRUMENTED_LINE) {\n            CHECK(data->lines);\n            CHECK(valid_opcode(data->lines[i].original_opcode));\n            opcode = data->lines[i].original_opcode;\n            CHECK(opcode != END_FOR);\n            CHECK(opcode != RESUME);\n            CHECK(opcode != RESUME_CHECK);\n            CHECK(opcode != INSTRUMENTED_RESUME);\n            if (!is_instrumented(opcode)) {\n                CHECK(_PyOpcode_Deopt[opcode] == opcode);\n            }\n            CHECK(opcode != INSTRUMENTED_LINE);\n        }\n        else if (data->lines) {\n            /* If original_opcode is INSTRUMENTED_INSTRUCTION\n             * *and* we are executing a INSTRUMENTED_LINE instruction\n             * that has de-instrumented itself, then we will execute\n             * an invalid INSTRUMENTED_INSTRUCTION */\n            CHECK(data->lines[i].original_opcode != INSTRUMENTED_INSTRUCTION);\n        }\n        if (opcode == INSTRUMENTED_INSTRUCTION) {\n            CHECK(data->per_instruction_opcodes[i] != 0);\n            opcode = data->per_instruction_opcodes[i];\n        }\n        if (is_instrumented(opcode)) {\n            CHECK(DE_INSTRUMENT[opcode] == base_opcode);\n            int event = EVENT_FOR_OPCODE[DE_INSTRUMENT[opcode]];\n            if (event < 0) {\n                /* RESUME fixup */\n                event = instr->op.arg ? 1: 0;\n            }\n            CHECK(active_monitors.tools[event] != 0);\n        }\n        if (data->lines && base_opcode != END_FOR) {\n            int line1 = compute_line(code, i, data->lines[i].line_delta);\n            int line2 = PyCode_Addr2Line(code, i*sizeof(_Py_CODEUNIT));\n            CHECK(line1 == line2);\n        }\n        CHECK(valid_opcode(opcode));\n        if (data->tools) {\n            uint8_t local_tools = data->tools[i];\n            if (opcode_has_event(base_opcode)) {\n                int event = EVENT_FOR_OPCODE[base_opcode];\n                if (event == -1) {\n                    /* RESUME fixup */\n                    event = _PyCode_CODE(code)[i].op.arg;\n                }\n                CHECK((active_monitors.tools[event] & local_tools) == local_tools);\n            }\n            else {\n                CHECK(local_tools == 0xff);\n            }\n        }\n        i += instruction_length(code, i);\n        assert(i <= code_len);\n    }\n}\n#else\n\n#define CHECK(test) assert(test)\n\n#endif\n\n/* Get the underlying opcode, stripping instrumentation */\nint _Py_GetBaseOpcode(PyCodeObject *code, int i)\n{\n    int opcode = _PyCode_CODE(code)[i].op.code;\n    if (opcode == INSTRUMENTED_LINE) {\n        opcode = code->_co_monitoring->lines[i].original_opcode;\n    }\n    if (opcode == INSTRUMENTED_INSTRUCTION) {\n        opcode = code->_co_monitoring->per_instruction_opcodes[i];\n    }\n    CHECK(opcode != INSTRUMENTED_INSTRUCTION);\n    CHECK(opcode != INSTRUMENTED_LINE);\n    int deinstrumented = DE_INSTRUMENT[opcode];\n    if (deinstrumented) {\n        return deinstrumented;\n    }\n    return _PyOpcode_Deopt[opcode];\n}\n\nstatic void\nde_instrument(PyCodeObject *code, int i, int event)\n{\n    assert(event != PY_MONITORING_EVENT_INSTRUCTION);\n    assert(event != PY_MONITORING_EVENT_LINE);\n\n    _Py_CODEUNIT *instr = &_PyCode_CODE(code)[i];\n    uint8_t *opcode_ptr = &instr->op.code;\n    int opcode = *opcode_ptr;\n    if (opcode == INSTRUMENTED_LINE) {\n        opcode_ptr = &code->_co_monitoring->lines[i].original_opcode;\n        opcode = *opcode_ptr;\n    }\n    if (opcode == INSTRUMENTED_INSTRUCTION) {\n        opcode_ptr = &code->_co_monitoring->per_instruction_opcodes[i];\n        opcode = *opcode_ptr;\n    }\n    int deinstrumented = DE_INSTRUMENT[opcode];\n    if (deinstrumented == 0) {\n        return;\n    }\n    CHECK(_PyOpcode_Deopt[deinstrumented] == deinstrumented);\n    *opcode_ptr = deinstrumented;\n    if (_PyOpcode_Caches[deinstrumented]) {\n        instr[1].cache = adaptive_counter_warmup();\n    }\n}\n\nstatic void\nde_instrument_line(PyCodeObject *code, int i)\n{\n    _Py_CODEUNIT *instr = &_PyCode_CODE(code)[i];\n    int opcode = instr->op.code;\n    if (opcode != INSTRUMENTED_LINE) {\n        return;\n    }\n    _PyCoLineInstrumentationData *lines = &code->_co_monitoring->lines[i];\n    int original_opcode = lines->original_opcode;\n    if (original_opcode == INSTRUMENTED_INSTRUCTION) {\n        lines->original_opcode = code->_co_monitoring->per_instruction_opcodes[i];\n    }\n    CHECK(original_opcode != 0);\n    CHECK(original_opcode == _PyOpcode_Deopt[original_opcode]);\n    instr->op.code = original_opcode;\n    if (_PyOpcode_Caches[original_opcode]) {\n        instr[1].cache = adaptive_counter_warmup();\n    }\n    assert(instr->op.code != INSTRUMENTED_LINE);\n}\n\nstatic void\nde_instrument_per_instruction(PyCodeObject *code, int i)\n{\n    _Py_CODEUNIT *instr = &_PyCode_CODE(code)[i];\n    uint8_t *opcode_ptr = &instr->op.code;\n    int opcode = *opcode_ptr;\n    if (opcode == INSTRUMENTED_LINE) {\n        opcode_ptr = &code->_co_monitoring->lines[i].original_opcode;\n        opcode = *opcode_ptr;\n    }\n    if (opcode != INSTRUMENTED_INSTRUCTION) {\n        return;\n    }\n    int original_opcode = code->_co_monitoring->per_instruction_opcodes[i];\n    CHECK(original_opcode != 0);\n    CHECK(original_opcode == _PyOpcode_Deopt[original_opcode]);\n    *opcode_ptr = original_opcode;\n    if (_PyOpcode_Caches[original_opcode]) {\n        instr[1].cache = adaptive_counter_warmup();\n    }\n    assert(*opcode_ptr != INSTRUMENTED_INSTRUCTION);\n    assert(instr->op.code != INSTRUMENTED_INSTRUCTION);\n    /* Keep things clean for sanity check */\n    code->_co_monitoring->per_instruction_opcodes[i] = 0;\n}\n\n\nstatic void\ninstrument(PyCodeObject *code, int i)\n{\n    _Py_CODEUNIT *instr = &_PyCode_CODE(code)[i];\n    uint8_t *opcode_ptr = &instr->op.code;\n    int opcode =*opcode_ptr;\n    if (opcode == INSTRUMENTED_LINE) {\n        _PyCoLineInstrumentationData *lines = &code->_co_monitoring->lines[i];\n        opcode_ptr = &lines->original_opcode;\n        opcode = *opcode_ptr;\n    }\n    if (opcode == INSTRUMENTED_INSTRUCTION) {\n        opcode_ptr = &code->_co_monitoring->per_instruction_opcodes[i];\n        opcode = *opcode_ptr;\n        CHECK(opcode != INSTRUMENTED_INSTRUCTION && opcode != INSTRUMENTED_LINE);\n        CHECK(opcode == _PyOpcode_Deopt[opcode]);\n    }\n    CHECK(opcode != 0);\n    if (!is_instrumented(opcode)) {\n        int deopt = _PyOpcode_Deopt[opcode];\n        int instrumented = INSTRUMENTED_OPCODES[deopt];\n        assert(instrumented);\n        *opcode_ptr = instrumented;\n        if (_PyOpcode_Caches[deopt]) {\n            instr[1].cache = adaptive_counter_warmup();\n        }\n    }\n}\n\nstatic void\ninstrument_line(PyCodeObject *code, int i)\n{\n    uint8_t *opcode_ptr = &_PyCode_CODE(code)[i].op.code;\n    int opcode = *opcode_ptr;\n    if (opcode == INSTRUMENTED_LINE) {\n        return;\n    }\n    _PyCoLineInstrumentationData *lines = &code->_co_monitoring->lines[i];\n    lines->original_opcode = _PyOpcode_Deopt[opcode];\n    CHECK(lines->original_opcode > 0);\n    *opcode_ptr = INSTRUMENTED_LINE;\n}\n\nstatic void\ninstrument_per_instruction(PyCodeObject *code, int i)\n{\n    _Py_CODEUNIT *instr = &_PyCode_CODE(code)[i];\n    uint8_t *opcode_ptr = &instr->op.code;\n    int opcode = *opcode_ptr;\n    if (opcode == INSTRUMENTED_LINE) {\n        _PyCoLineInstrumentationData *lines = &code->_co_monitoring->lines[i];\n        opcode_ptr = &lines->original_opcode;\n        opcode = *opcode_ptr;\n    }\n    if (opcode == INSTRUMENTED_INSTRUCTION) {\n        assert(code->_co_monitoring->per_instruction_opcodes[i] > 0);\n        return;\n    }\n    CHECK(opcode != 0);\n    if (is_instrumented(opcode)) {\n        code->_co_monitoring->per_instruction_opcodes[i] = opcode;\n    }\n    else {\n        assert(opcode != 0);\n        assert(_PyOpcode_Deopt[opcode] != 0);\n        assert(_PyOpcode_Deopt[opcode] != RESUME);\n        code->_co_monitoring->per_instruction_opcodes[i] = _PyOpcode_Deopt[opcode];\n    }\n    assert(code->_co_monitoring->per_instruction_opcodes[i] > 0);\n    *opcode_ptr = INSTRUMENTED_INSTRUCTION;\n}\n\nstatic void\nremove_tools(PyCodeObject * code, int offset, int event, int tools)\n{\n    assert(event != PY_MONITORING_EVENT_LINE);\n    assert(event != PY_MONITORING_EVENT_INSTRUCTION);\n    assert(PY_MONITORING_IS_INSTRUMENTED_EVENT(event));\n    assert(opcode_has_event(_Py_GetBaseOpcode(code, offset)));\n    _PyCoMonitoringData *monitoring = code->_co_monitoring;\n    if (monitoring && monitoring->tools) {\n        monitoring->tools[offset] &= ~tools;\n        if (monitoring->tools[offset] == 0) {\n            de_instrument(code, offset, event);\n        }\n    }\n    else {\n        /* Single tool */\n        uint8_t single_tool = code->_co_monitoring->active_monitors.tools[event];\n        assert(_Py_popcount32(single_tool) <= 1);\n        if (((single_tool & tools) == single_tool)) {\n            de_instrument(code, offset, event);\n        }\n    }\n}\n\n#ifndef NDEBUG\nstatic bool\ntools_is_subset_for_event(PyCodeObject * code, int event, int tools)\n{\n    int global_tools = PyInterpreterState_Get()->monitors.tools[event];\n    int local_tools = code->_co_monitoring->local_monitors.tools[event];\n    return tools == ((global_tools | local_tools) & tools);\n}\n#endif\n\nstatic void\nremove_line_tools(PyCodeObject * code, int offset, int tools)\n{\n    assert(code->_co_monitoring);\n    if (code->_co_monitoring->line_tools)\n    {\n        uint8_t *toolsptr = &code->_co_monitoring->line_tools[offset];\n        *toolsptr &= ~tools;\n        if (*toolsptr == 0 ) {\n            de_instrument_line(code, offset);\n        }\n    }\n    else {\n        /* Single tool */\n        uint8_t single_tool = code->_co_monitoring->active_monitors.tools[PY_MONITORING_EVENT_LINE];\n        assert(_Py_popcount32(single_tool) <= 1);\n        if (((single_tool & tools) == single_tool)) {\n            de_instrument_line(code, offset);\n        }\n    }\n}\n\nstatic void\nadd_tools(PyCodeObject * code, int offset, int event, int tools)\n{\n    assert(event != PY_MONITORING_EVENT_LINE);\n    assert(event != PY_MONITORING_EVENT_INSTRUCTION);\n    assert(PY_MONITORING_IS_INSTRUMENTED_EVENT(event));\n    assert(code->_co_monitoring);\n    if (code->_co_monitoring &&\n        code->_co_monitoring->tools\n    ) {\n        code->_co_monitoring->tools[offset] |= tools;\n    }\n    else {\n        /* Single tool */\n        assert(_Py_popcount32(tools) == 1);\n        assert(tools_is_subset_for_event(code, event, tools));\n    }\n    instrument(code, offset);\n}\n\nstatic void\nadd_line_tools(PyCodeObject * code, int offset, int tools)\n{\n    assert(tools_is_subset_for_event(code, PY_MONITORING_EVENT_LINE, tools));\n    assert(code->_co_monitoring);\n    if (code->_co_monitoring->line_tools) {\n        code->_co_monitoring->line_tools[offset] |= tools;\n    }\n    else {\n        /* Single tool */\n        assert(_Py_popcount32(tools) == 1);\n    }\n    instrument_line(code, offset);\n}\n\n\nstatic void\nadd_per_instruction_tools(PyCodeObject * code, int offset, int tools)\n{\n    assert(tools_is_subset_for_event(code, PY_MONITORING_EVENT_INSTRUCTION, tools));\n    assert(code->_co_monitoring);\n    if (code->_co_monitoring->per_instruction_tools) {\n        code->_co_monitoring->per_instruction_tools[offset] |= tools;\n    }\n    else {\n        /* Single tool */\n        assert(_Py_popcount32(tools) == 1);\n    }\n    instrument_per_instruction(code, offset);\n}\n\n\nstatic void\nremove_per_instruction_tools(PyCodeObject * code, int offset, int tools)\n{\n    assert(code->_co_monitoring);\n    if (code->_co_monitoring->per_instruction_tools) {\n        uint8_t *toolsptr = &code->_co_monitoring->per_instruction_tools[offset];\n        *toolsptr &= ~tools;\n        if (*toolsptr == 0) {\n            de_instrument_per_instruction(code, offset);\n        }\n    }\n    else {\n        /* Single tool */\n        uint8_t single_tool = code->_co_monitoring->active_monitors.tools[PY_MONITORING_EVENT_INSTRUCTION];\n        assert(_Py_popcount32(single_tool) <= 1);\n        if (((single_tool & tools) == single_tool)) {\n            de_instrument_per_instruction(code, offset);\n        }\n    }\n}\n\n\n/* Return 1 if DISABLE returned, -1 if error, 0 otherwise */\nstatic int\ncall_one_instrument(\n    PyInterpreterState *interp, PyThreadState *tstate, PyObject **args,\n    Py_ssize_t nargsf, int8_t tool, int event)\n{\n    assert(0 <= tool && tool < 8);\n    assert(tstate->tracing == 0);\n    PyObject *instrument = interp->monitoring_callables[tool][event];\n    if (instrument == NULL) {\n        return 0;\n    }\n    int old_what = tstate->what_event;\n    tstate->what_event = event;\n    tstate->tracing++;\n    PyObject *res = _PyObject_VectorcallTstate(tstate, instrument, args, nargsf, NULL);\n    tstate->tracing--;\n    tstate->what_event = old_what;\n    if (res == NULL) {\n        return -1;\n    }\n    Py_DECREF(res);\n    return (res == &_PyInstrumentation_DISABLE);\n}\n\nstatic const int8_t MOST_SIGNIFICANT_BITS[16] = {\n    -1, 0, 1, 1,\n    2, 2, 2, 2,\n    3, 3, 3, 3,\n    3, 3, 3, 3,\n};\n\n/* We could use _Py_bit_length here, but that is designed for larger (32/64)\n * bit ints, and can perform relatively poorly on platforms without the\n * necessary intrinsics. */\nstatic inline int most_significant_bit(uint8_t bits) {\n    assert(bits != 0);\n    if (bits > 15) {\n        return MOST_SIGNIFICANT_BITS[bits>>4]+4;\n    }\n    return MOST_SIGNIFICANT_BITS[bits];\n}\n\nstatic bool\nis_version_up_to_date(PyCodeObject *code, PyInterpreterState *interp)\n{\n    return interp->monitoring_version == code->_co_instrumentation_version;\n}\n\n#ifndef NDEBUG\nstatic bool\ninstrumentation_cross_checks(PyInterpreterState *interp, PyCodeObject *code)\n{\n    _Py_LocalMonitors expected = local_union(\n        interp->monitors,\n        code->_co_monitoring->local_monitors);\n    return monitors_equals(code->_co_monitoring->active_monitors, expected);\n}\n#endif\n\nstatic inline uint8_t\nget_tools_for_instruction(PyCodeObject *code, PyInterpreterState *interp, int i, int event)\n{\n    uint8_t tools;\n    assert(event != PY_MONITORING_EVENT_LINE);\n    assert(event != PY_MONITORING_EVENT_INSTRUCTION);\n    if (event >= _PY_MONITORING_UNGROUPED_EVENTS) {\n        assert(event == PY_MONITORING_EVENT_C_RAISE ||\n                event == PY_MONITORING_EVENT_C_RETURN);\n        event = PY_MONITORING_EVENT_CALL;\n    }\n    if (PY_MONITORING_IS_INSTRUMENTED_EVENT(event)) {\n        CHECK(is_version_up_to_date(code, interp));\n        CHECK(instrumentation_cross_checks(interp, code));\n        if (code->_co_monitoring->tools) {\n            tools = code->_co_monitoring->tools[i];\n        }\n        else {\n            tools = code->_co_monitoring->active_monitors.tools[event];\n        }\n    }\n    else {\n        tools = interp->monitors.tools[event];\n    }\n    return tools;\n}\n\nstatic const char *const event_names [] = {\n    [PY_MONITORING_EVENT_PY_START] = \"PY_START\",\n    [PY_MONITORING_EVENT_PY_RESUME] = \"PY_RESUME\",\n    [PY_MONITORING_EVENT_PY_RETURN] = \"PY_RETURN\",\n    [PY_MONITORING_EVENT_PY_YIELD] = \"PY_YIELD\",\n    [PY_MONITORING_EVENT_CALL] = \"CALL\",\n    [PY_MONITORING_EVENT_LINE] = \"LINE\",\n    [PY_MONITORING_EVENT_INSTRUCTION] = \"INSTRUCTION\",\n    [PY_MONITORING_EVENT_JUMP] = \"JUMP\",\n    [PY_MONITORING_EVENT_BRANCH] = \"BRANCH\",\n    [PY_MONITORING_EVENT_C_RETURN] = \"C_RETURN\",\n    [PY_MONITORING_EVENT_PY_THROW] = \"PY_THROW\",\n    [PY_MONITORING_EVENT_RAISE] = \"RAISE\",\n    [PY_MONITORING_EVENT_RERAISE] = \"RERAISE\",\n    [PY_MONITORING_EVENT_EXCEPTION_HANDLED] = \"EXCEPTION_HANDLED\",\n    [PY_MONITORING_EVENT_C_RAISE] = \"C_RAISE\",\n    [PY_MONITORING_EVENT_PY_UNWIND] = \"PY_UNWIND\",\n    [PY_MONITORING_EVENT_STOP_ITERATION] = \"STOP_ITERATION\",\n};\n\nstatic int\ncall_instrumentation_vector(\n    PyThreadState *tstate, int event,\n    _PyInterpreterFrame *frame, _Py_CODEUNIT *instr, Py_ssize_t nargs, PyObject *args[])\n{\n    if (tstate->tracing) {\n        return 0;\n    }\n    assert(!_PyErr_Occurred(tstate));\n    assert(args[0] == NULL);\n    PyCodeObject *code = frame->f_code;\n    assert(code->_co_instrumentation_version == tstate->interp->monitoring_version);\n    assert(is_version_up_to_date(code, tstate->interp));\n    assert(instrumentation_cross_checks(tstate->interp, code));\n    assert(args[1] == NULL);\n    args[1] = (PyObject *)code;\n    int offset = (int)(instr - _PyCode_CODE(code));\n    /* Offset visible to user should be the offset in bytes, as that is the\n     * convention for APIs involving code offsets. */\n    int bytes_offset = offset * (int)sizeof(_Py_CODEUNIT);\n    PyObject *offset_obj = PyLong_FromSsize_t(bytes_offset);\n    if (offset_obj == NULL) {\n        return -1;\n    }\n    assert(args[2] == NULL);\n    args[2] = offset_obj;\n    PyInterpreterState *interp = tstate->interp;\n    uint8_t tools = get_tools_for_instruction(code, interp, offset, event);\n    Py_ssize_t nargsf = nargs | PY_VECTORCALL_ARGUMENTS_OFFSET;\n    PyObject **callargs = &args[1];\n    int err = 0;\n    while (tools) {\n        int tool = most_significant_bit(tools);\n        assert(tool >= 0 && tool < 8);\n        assert(tools & (1 << tool));\n        tools ^= (1 << tool);\n        int res = call_one_instrument(interp, tstate, callargs, nargsf, tool, event);\n        if (res == 0) {\n            /* Nothing to do */\n        }\n        else if (res < 0) {\n            /* error */\n            err = -1;\n            break;\n        }\n        else {\n            /* DISABLE */\n            if (!PY_MONITORING_IS_INSTRUMENTED_EVENT(event)) {\n                PyErr_Format(PyExc_ValueError,\n                              \"Cannot disable %s events. Callback removed.\",\n                             event_names[event]);\n                /* Clear tool to prevent infinite loop */\n                Py_CLEAR(interp->monitoring_callables[tool][event]);\n                err = -1;\n                break;\n            }\n            else {\n                remove_tools(code, offset, event, 1 << tool);\n            }\n        }\n    }\n    Py_DECREF(offset_obj);\n    return err;\n}\n\nint\n_Py_call_instrumentation(\n    PyThreadState *tstate, int event,\n    _PyInterpreterFrame *frame, _Py_CODEUNIT *instr)\n{\n    PyObject *args[3] = { NULL, NULL, NULL };\n    return call_instrumentation_vector(tstate, event, frame, instr, 2, args);\n}\n\nint\n_Py_call_instrumentation_arg(\n    PyThreadState *tstate, int event,\n    _PyInterpreterFrame *frame, _Py_CODEUNIT *instr, PyObject *arg)\n{\n    PyObject *args[4] = { NULL, NULL, NULL, arg };\n    return call_instrumentation_vector(tstate, event, frame, instr, 3, args);\n}\n\nint\n_Py_call_instrumentation_2args(\n    PyThreadState *tstate, int event,\n    _PyInterpreterFrame *frame, _Py_CODEUNIT *instr, PyObject *arg0, PyObject *arg1)\n{\n    PyObject *args[5] = { NULL, NULL, NULL, arg0, arg1 };\n    return call_instrumentation_vector(tstate, event, frame, instr, 4, args);\n}\n\n_Py_CODEUNIT *\n_Py_call_instrumentation_jump(\n    PyThreadState *tstate, int event,\n    _PyInterpreterFrame *frame, _Py_CODEUNIT *instr, _Py_CODEUNIT *target)\n{\n    assert(event == PY_MONITORING_EVENT_JUMP ||\n           event == PY_MONITORING_EVENT_BRANCH);\n    assert(frame->prev_instr == instr);\n    /* Event should occur after the jump */\n    frame->prev_instr = target;\n    PyCodeObject *code = frame->f_code;\n    int to = (int)(target - _PyCode_CODE(code));\n    PyObject *to_obj = PyLong_FromLong(to * (int)sizeof(_Py_CODEUNIT));\n    if (to_obj == NULL) {\n        return NULL;\n    }\n    PyObject *args[4] = { NULL, NULL, NULL, to_obj };\n    int err = call_instrumentation_vector(tstate, event, frame, instr, 3, args);\n    Py_DECREF(to_obj);\n    if (err) {\n        return NULL;\n    }\n    if (frame->prev_instr != target) {\n        /* The callback has caused a jump (by setting the line number) */\n        return frame->prev_instr;\n    }\n    /* Reset prev_instr for INSTRUMENTED_LINE */\n    frame->prev_instr = instr;\n    return target;\n}\n\nstatic void\ncall_instrumentation_vector_protected(\n    PyThreadState *tstate, int event,\n    _PyInterpreterFrame *frame, _Py_CODEUNIT *instr, Py_ssize_t nargs, PyObject *args[])\n{\n    assert(_PyErr_Occurred(tstate));\n    PyObject *exc = _PyErr_GetRaisedException(tstate);\n    int err = call_instrumentation_vector(tstate, event, frame, instr, nargs, args);\n    if (err) {\n        Py_XDECREF(exc);\n    }\n    else {\n        _PyErr_SetRaisedException(tstate, exc);\n    }\n    assert(_PyErr_Occurred(tstate));\n}\n\nvoid\n_Py_call_instrumentation_exc2(\n    PyThreadState *tstate, int event,\n    _PyInterpreterFrame *frame, _Py_CODEUNIT *instr, PyObject *arg0, PyObject *arg1)\n{\n    assert(_PyErr_Occurred(tstate));\n    PyObject *args[5] = { NULL, NULL, NULL, arg0, arg1 };\n    call_instrumentation_vector_protected(tstate, event, frame, instr, 4, args);\n}\n\n\nint\n_Py_Instrumentation_GetLine(PyCodeObject *code, int index)\n{\n    _PyCoMonitoringData *monitoring = code->_co_monitoring;\n    assert(monitoring != NULL);\n    assert(monitoring->lines != NULL);\n    assert(index >= code->_co_firsttraceable);\n    assert(index < Py_SIZE(code));\n    _PyCoLineInstrumentationData *line_data = &monitoring->lines[index];\n    int8_t line_delta = line_data->line_delta;\n    int line = compute_line(code, index, line_delta);\n    return line;\n}\n\nint\n_Py_call_instrumentation_line(PyThreadState *tstate, _PyInterpreterFrame* frame, _Py_CODEUNIT *instr, _Py_CODEUNIT *prev)\n{\n    frame->prev_instr = instr;\n    PyCodeObject *code = frame->f_code;\n    assert(is_version_up_to_date(code, tstate->interp));\n    assert(instrumentation_cross_checks(tstate->interp, code));\n    int i = (int)(instr - _PyCode_CODE(code));\n\n    _PyCoMonitoringData *monitoring = code->_co_monitoring;\n    _PyCoLineInstrumentationData *line_data = &monitoring->lines[i];\n    if (tstate->tracing) {\n        goto done;\n    }\n    PyInterpreterState *interp = tstate->interp;\n    int8_t line_delta = line_data->line_delta;\n    int line = compute_line(code, i, line_delta);\n    assert(line >= 0);\n    int prev_index = (int)(prev - _PyCode_CODE(code));\n    int prev_line = _Py_Instrumentation_GetLine(code, prev_index);\n    if (prev_line == line) {\n        int prev_opcode = _PyCode_CODE(code)[prev_index].op.code;\n        /* RESUME and INSTRUMENTED_RESUME are needed for the operation of\n         * instrumentation, so must never be hidden by an INSTRUMENTED_LINE.\n         */\n        if (prev_opcode != RESUME && prev_opcode != INSTRUMENTED_RESUME) {\n            goto done;\n        }\n    }\n    uint8_t tools = code->_co_monitoring->line_tools != NULL ?\n        code->_co_monitoring->line_tools[i] :\n        (interp->monitors.tools[PY_MONITORING_EVENT_LINE] |\n         code->_co_monitoring->local_monitors.tools[PY_MONITORING_EVENT_LINE]\n        );\n    PyObject *line_obj = PyLong_FromSsize_t(line);\n    if (line_obj == NULL) {\n        return -1;\n    }\n    PyObject *args[3] = { NULL, (PyObject *)code, line_obj };\n    while (tools) {\n        int tool = most_significant_bit(tools);\n        assert(tool >= 0 && tool < 8);\n        assert(tools & (1 << tool));\n        tools &= ~(1 << tool);\n        int res = call_one_instrument(interp, tstate, &args[1],\n                                      2 | PY_VECTORCALL_ARGUMENTS_OFFSET,\n                                      tool, PY_MONITORING_EVENT_LINE);\n        if (res == 0) {\n            /* Nothing to do */\n        }\n        else if (res < 0) {\n            /* error */\n            Py_DECREF(line_obj);\n            return -1;\n        }\n        else {\n            /* DISABLE  */\n            remove_line_tools(code, i, 1 << tool);\n        }\n    }\n    Py_DECREF(line_obj);\n    uint8_t original_opcode;\ndone:\n    original_opcode = line_data->original_opcode;\n    assert(original_opcode != 0);\n    assert(original_opcode < INSTRUMENTED_LINE);\n    assert(_PyOpcode_Deopt[original_opcode] == original_opcode);\n    return original_opcode;\n}\n\nint\n_Py_call_instrumentation_instruction(PyThreadState *tstate, _PyInterpreterFrame* frame, _Py_CODEUNIT *instr)\n{\n    PyCodeObject *code = frame->f_code;\n    assert(is_version_up_to_date(code, tstate->interp));\n    assert(instrumentation_cross_checks(tstate->interp, code));\n    int offset = (int)(instr - _PyCode_CODE(code));\n    _PyCoMonitoringData *instrumentation_data = code->_co_monitoring;\n    assert(instrumentation_data->per_instruction_opcodes);\n    int next_opcode = instrumentation_data->per_instruction_opcodes[offset];\n    if (tstate->tracing) {\n        return next_opcode;\n    }\n    PyInterpreterState *interp = tstate->interp;\n    uint8_t tools = instrumentation_data->per_instruction_tools != NULL ?\n        instrumentation_data->per_instruction_tools[offset] :\n        (interp->monitors.tools[PY_MONITORING_EVENT_INSTRUCTION] |\n         code->_co_monitoring->local_monitors.tools[PY_MONITORING_EVENT_INSTRUCTION]\n        );\n    int bytes_offset = offset * (int)sizeof(_Py_CODEUNIT);\n    PyObject *offset_obj = PyLong_FromSsize_t(bytes_offset);\n    if (offset_obj == NULL) {\n        return -1;\n    }\n    PyObject *args[3] = { NULL, (PyObject *)code, offset_obj };\n    while (tools) {\n        int tool = most_significant_bit(tools);\n        assert(tool >= 0 && tool < 8);\n        assert(tools & (1 << tool));\n        tools &= ~(1 << tool);\n        int res = call_one_instrument(interp, tstate, &args[1],\n                                      2 | PY_VECTORCALL_ARGUMENTS_OFFSET,\n                                      tool, PY_MONITORING_EVENT_INSTRUCTION);\n        if (res == 0) {\n            /* Nothing to do */\n        }\n        else if (res < 0) {\n            /* error */\n            Py_DECREF(offset_obj);\n            return -1;\n        }\n        else {\n            /* DISABLE  */\n            remove_per_instruction_tools(code, offset, 1 << tool);\n        }\n    }\n    Py_DECREF(offset_obj);\n    assert(next_opcode != 0);\n    return next_opcode;\n}\n\n\nPyObject *\n_PyMonitoring_RegisterCallback(int tool_id, int event_id, PyObject *obj)\n{\n    PyInterpreterState *is = _PyInterpreterState_Get();\n    assert(0 <= tool_id && tool_id < PY_MONITORING_TOOL_IDS);\n    assert(0 <= event_id && event_id < _PY_MONITORING_EVENTS);\n    PyObject *callback = is->monitoring_callables[tool_id][event_id];\n    is->monitoring_callables[tool_id][event_id] = Py_XNewRef(obj);\n    return callback;\n}\n\nstatic void\ninitialize_tools(PyCodeObject *code)\n{\n    uint8_t* tools = code->_co_monitoring->tools;\n    assert(tools != NULL);\n    int code_len = (int)Py_SIZE(code);\n    for (int i = 0; i < code_len; i++) {\n        _Py_CODEUNIT *instr = &_PyCode_CODE(code)[i];\n        int opcode = instr->op.code;\n        if (opcode == INSTRUMENTED_LINE) {\n            opcode = code->_co_monitoring->lines[i].original_opcode;\n        }\n        if (opcode == INSTRUMENTED_INSTRUCTION) {\n            opcode = code->_co_monitoring->per_instruction_opcodes[i];\n        }\n        bool instrumented = is_instrumented(opcode);\n        if (instrumented) {\n            opcode = DE_INSTRUMENT[opcode];\n            assert(opcode != 0);\n        }\n        opcode = _PyOpcode_Deopt[opcode];\n        if (opcode_has_event(opcode)) {\n            if (instrumented) {\n                int8_t event;\n                if (opcode == RESUME) {\n                    event = instr->op.arg != 0;\n                }\n                else {\n                    event = EVENT_FOR_OPCODE[opcode];\n                    assert(event > 0);\n                }\n                assert(event >= 0);\n                assert(PY_MONITORING_IS_INSTRUMENTED_EVENT(event));\n                tools[i] = code->_co_monitoring->active_monitors.tools[event];\n                CHECK(tools[i] != 0);\n            }\n            else {\n                tools[i] = 0;\n            }\n        }\n#ifdef Py_DEBUG\n        /* Initialize tools for invalid locations to all ones to try to catch errors */\n        else {\n            tools[i] = 0xff;\n        }\n        for (int j = 1; j <= _PyOpcode_Caches[opcode]; j++) {\n            tools[i+j] = 0xff;\n        }\n#endif\n        i += _PyOpcode_Caches[opcode];\n    }\n}\n\n#define NO_LINE -128\n\nstatic void\ninitialize_lines(PyCodeObject *code)\n{\n    _PyCoLineInstrumentationData *line_data = code->_co_monitoring->lines;\n    assert(line_data != NULL);\n    int code_len = (int)Py_SIZE(code);\n    PyCodeAddressRange range;\n    _PyCode_InitAddressRange(code, &range);\n    for (int i = 0; i < code->_co_firsttraceable && i < code_len; i++) {\n        line_data[i].original_opcode = 0;\n        line_data[i].line_delta = -127;\n    }\n    int current_line = -1;\n    for (int i = code->_co_firsttraceable; i < code_len; ) {\n        int opcode = _Py_GetBaseOpcode(code, i);\n        int line = _PyCode_CheckLineNumber(i*(int)sizeof(_Py_CODEUNIT), &range);\n        line_data[i].line_delta = compute_line_delta(code, i, line);\n        int length = instruction_length(code, i);\n        switch (opcode) {\n            case END_ASYNC_FOR:\n            case END_FOR:\n            case END_SEND:\n            case RESUME:\n                /* END_FOR cannot start a line, as it is skipped by FOR_ITER\n                 * END_SEND cannot start a line, as it is skipped by SEND\n                 * RESUME must not be instrumented with INSTRUMENT_LINE */\n                line_data[i].original_opcode = 0;\n                break;\n            default:\n                /* Set original_opcode to the opcode iff the instruction\n                 * starts a line, and thus should be instrumented.\n                 * This saves having to perform this check every time the\n                 * we turn instrumentation on or off, and serves as a sanity\n                 * check when debugging.\n                 */\n                if (line != current_line && line >= 0) {\n                    line_data[i].original_opcode = opcode;\n                }\n                else {\n                    line_data[i].original_opcode = 0;\n                }\n                current_line = line;\n        }\n        for (int j = 1; j < length; j++) {\n            line_data[i+j].original_opcode = 0;\n            line_data[i+j].line_delta = NO_LINE;\n        }\n        i += length;\n    }\n    for (int i = code->_co_firsttraceable; i < code_len; ) {\n        int opcode = _Py_GetBaseOpcode(code, i);\n        int oparg = 0;\n        while (opcode == EXTENDED_ARG) {\n            oparg = (oparg << 8) | _PyCode_CODE(code)[i].op.arg;\n            i++;\n            opcode = _Py_GetBaseOpcode(code, i);\n        }\n        oparg = (oparg << 8) | _PyCode_CODE(code)[i].op.arg;\n        i += instruction_length(code, i);\n        int target = -1;\n        switch (opcode) {\n            case POP_JUMP_IF_FALSE:\n            case POP_JUMP_IF_TRUE:\n            case POP_JUMP_IF_NONE:\n            case POP_JUMP_IF_NOT_NONE:\n            case JUMP_FORWARD:\n            {\n                target = i + oparg;\n                break;\n            }\n            case FOR_ITER:\n            case SEND:\n            {\n                /* Skip over END_FOR/END_SEND */\n                target = i + oparg + 1;\n                break;\n            }\n            case JUMP_BACKWARD:\n            case JUMP_BACKWARD_NO_INTERRUPT:\n            {\n                target = i - oparg;\n                break;\n            }\n            default:\n                continue;\n        }\n        assert(target >= 0);\n        if (line_data[target].line_delta != NO_LINE) {\n            line_data[target].original_opcode = _Py_GetBaseOpcode(code, target);\n        }\n    }\n    /* Scan exception table */\n    unsigned char *start = (unsigned char *)PyBytes_AS_STRING(code->co_exceptiontable);\n    unsigned char *end = start + PyBytes_GET_SIZE(code->co_exceptiontable);\n    unsigned char *scan = start;\n    while (scan < end) {\n        int start_offset, size, handler;\n        scan = parse_varint(scan, &start_offset);\n        assert(start_offset >= 0 && start_offset < code_len);\n        scan = parse_varint(scan, &size);\n        assert(size >= 0 && start_offset+size <= code_len);\n        scan = parse_varint(scan, &handler);\n        assert(handler >= 0 && handler < code_len);\n        int depth_and_lasti;\n        scan = parse_varint(scan, &depth_and_lasti);\n        int original_opcode = _Py_GetBaseOpcode(code, handler);\n        /* Skip if not the start of a line.\n         * END_ASYNC_FOR is a bit special as it marks the end of\n         * an `async for` loop, which should not generate its own\n         * line event. */\n        if (line_data[handler].line_delta != NO_LINE &&\n            original_opcode != END_ASYNC_FOR) {\n            line_data[handler].original_opcode = original_opcode;\n        }\n    }\n}\n\nstatic void\ninitialize_line_tools(PyCodeObject *code, _Py_LocalMonitors *all_events)\n{\n    uint8_t *line_tools = code->_co_monitoring->line_tools;\n    assert(line_tools != NULL);\n    int code_len = (int)Py_SIZE(code);\n    for (int i = 0; i < code_len; i++) {\n        line_tools[i] = all_events->tools[PY_MONITORING_EVENT_LINE];\n    }\n}\n\nstatic int\nallocate_instrumentation_data(PyCodeObject *code)\n{\n\n    if (code->_co_monitoring == NULL) {\n        code->_co_monitoring = PyMem_Malloc(sizeof(_PyCoMonitoringData));\n        if (code->_co_monitoring == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        code->_co_monitoring->local_monitors = (_Py_LocalMonitors){ 0 };\n        code->_co_monitoring->active_monitors = (_Py_LocalMonitors){ 0 };\n        code->_co_monitoring->tools = NULL;\n        code->_co_monitoring->lines = NULL;\n        code->_co_monitoring->line_tools = NULL;\n        code->_co_monitoring->per_instruction_opcodes = NULL;\n        code->_co_monitoring->per_instruction_tools = NULL;\n    }\n    return 0;\n}\n\nstatic int\nupdate_instrumentation_data(PyCodeObject *code, PyInterpreterState *interp)\n{\n    int code_len = (int)Py_SIZE(code);\n    if (allocate_instrumentation_data(code)) {\n        return -1;\n    }\n    _Py_LocalMonitors all_events = local_union(\n        interp->monitors,\n        code->_co_monitoring->local_monitors);\n    bool multitools = multiple_tools(&all_events);\n    if (code->_co_monitoring->tools == NULL && multitools) {\n        code->_co_monitoring->tools = PyMem_Malloc(code_len);\n        if (code->_co_monitoring->tools == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        initialize_tools(code);\n    }\n    if (all_events.tools[PY_MONITORING_EVENT_LINE]) {\n        if (code->_co_monitoring->lines == NULL) {\n            code->_co_monitoring->lines = PyMem_Malloc(code_len * sizeof(_PyCoLineInstrumentationData));\n            if (code->_co_monitoring->lines == NULL) {\n                PyErr_NoMemory();\n                return -1;\n            }\n            initialize_lines(code);\n        }\n        if (multitools && code->_co_monitoring->line_tools == NULL) {\n            code->_co_monitoring->line_tools = PyMem_Malloc(code_len);\n            if (code->_co_monitoring->line_tools == NULL) {\n                PyErr_NoMemory();\n                return -1;\n            }\n            initialize_line_tools(code, &all_events);\n        }\n    }\n    if (all_events.tools[PY_MONITORING_EVENT_INSTRUCTION]) {\n        if (code->_co_monitoring->per_instruction_opcodes == NULL) {\n            code->_co_monitoring->per_instruction_opcodes = PyMem_Malloc(code_len * sizeof(_PyCoLineInstrumentationData));\n            if (code->_co_monitoring->per_instruction_opcodes == NULL) {\n                PyErr_NoMemory();\n                return -1;\n            }\n            /* This may not be necessary, as we can initialize this memory lazily, but it helps catch errors. */\n            for (int i = 0; i < code_len; i++) {\n                code->_co_monitoring->per_instruction_opcodes[i] = 0;\n            }\n        }\n        if (multitools && code->_co_monitoring->per_instruction_tools == NULL) {\n            code->_co_monitoring->per_instruction_tools = PyMem_Malloc(code_len);\n            if (code->_co_monitoring->per_instruction_tools == NULL) {\n                PyErr_NoMemory();\n                return -1;\n            }\n            /* This may not be necessary, as we can initialize this memory lazily, but it helps catch errors. */\n            for (int i = 0; i < code_len; i++) {\n                code->_co_monitoring->per_instruction_tools[i] = 0;\n            }\n        }\n    }\n    return 0;\n}\n\nstatic const uint8_t super_instructions[256] = {\n    [LOAD_FAST__LOAD_FAST] = 1,\n    [LOAD_FAST__LOAD_CONST] = 1,\n    [STORE_FAST__LOAD_FAST] = 1,\n    [STORE_FAST__STORE_FAST] = 1,\n    [LOAD_CONST__LOAD_FAST] = 1,\n};\n\n/* Should use instruction metadata for this */\nstatic bool\nis_super_instruction(uint8_t opcode) {\n    return super_instructions[opcode] != 0;\n}\n\nint\n_Py_Instrument(PyCodeObject *code, PyInterpreterState *interp)\n{\n\n    if (is_version_up_to_date(code, interp)) {\n        assert(\n            interp->monitoring_version == 0 ||\n            instrumentation_cross_checks(interp, code)\n        );\n        return 0;\n    }\n    int code_len = (int)Py_SIZE(code);\n    /* code->_co_firsttraceable >= code_len indicates\n     * that no instrumentation can be inserted.\n     * Exit early to avoid creating instrumentation\n     * data for potential statically allocated code\n     * objects.\n     * See https://github.com/python/cpython/issues/108390 */\n    if (code->_co_firsttraceable >= code_len) {\n        return 0;\n    }\n    if (update_instrumentation_data(code, interp)) {\n        return -1;\n    }\n    _Py_LocalMonitors active_events = local_union(\n        interp->monitors,\n        code->_co_monitoring->local_monitors);\n    _Py_LocalMonitors new_events;\n    _Py_LocalMonitors removed_events;\n\n    bool restarted = interp->last_restart_version > code->_co_instrumentation_version;\n    if (restarted) {\n        removed_events = code->_co_monitoring->active_monitors;\n        new_events = active_events;\n    }\n    else {\n        removed_events = monitors_sub(code->_co_monitoring->active_monitors, active_events);\n        new_events = monitors_sub(active_events, code->_co_monitoring->active_monitors);\n        assert(monitors_are_empty(monitors_and(new_events, removed_events)));\n    }\n    code->_co_monitoring->active_monitors = active_events;\n    code->_co_instrumentation_version = interp->monitoring_version;\n    if (monitors_are_empty(new_events) && monitors_are_empty(removed_events)) {\n#ifdef INSTRUMENT_DEBUG\n        sanity_check_instrumentation(code);\n#endif\n        return 0;\n    }\n    /* Insert instrumentation */\n    for (int i = 0; i < code_len; i+= instruction_length(code, i)) {\n        _Py_CODEUNIT *instr = &_PyCode_CODE(code)[i];\n        if (is_super_instruction(instr->op.code)) {\n            instr->op.code = _PyOpcode_Deopt[instr->op.code];\n        }\n        CHECK(instr->op.code != 0);\n        int base_opcode = _Py_GetBaseOpcode(code, i);\n        if (opcode_has_event(base_opcode)) {\n            int8_t event;\n            if (base_opcode == RESUME) {\n                event = instr->op.arg > 0;\n            }\n            else {\n                event = EVENT_FOR_OPCODE[base_opcode];\n                assert(event > 0);\n            }\n            uint8_t removed_tools = removed_events.tools[event];\n            if (removed_tools) {\n                remove_tools(code, i, event, removed_tools);\n            }\n            uint8_t new_tools = new_events.tools[event];\n            if (new_tools) {\n                add_tools(code, i, event, new_tools);\n            }\n        }\n    }\n\n    // GH-103845: We need to remove both the line and instruction instrumentation before\n    // adding new ones, otherwise we may remove the newly added instrumentation.\n\n    uint8_t removed_line_tools = removed_events.tools[PY_MONITORING_EVENT_LINE];\n    uint8_t removed_per_instruction_tools = removed_events.tools[PY_MONITORING_EVENT_INSTRUCTION];\n\n    if (removed_line_tools) {\n        _PyCoLineInstrumentationData *line_data = code->_co_monitoring->lines;\n        for (int i = code->_co_firsttraceable; i < code_len;) {\n            if (line_data[i].original_opcode) {\n                if (removed_line_tools) {\n                    remove_line_tools(code, i, removed_line_tools);\n                }\n            }\n            i += instruction_length(code, i);\n        }\n    }\n    if (removed_per_instruction_tools) {\n        for (int i = code->_co_firsttraceable; i < code_len;) {\n            int opcode = _Py_GetBaseOpcode(code, i);\n            if (opcode == RESUME || opcode == END_FOR) {\n                i += instruction_length(code, i);\n                continue;\n            }\n            if (removed_per_instruction_tools) {\n                remove_per_instruction_tools(code, i, removed_per_instruction_tools);\n            }\n            i += instruction_length(code, i);\n        }\n    }\n#ifdef INSTRUMENT_DEBUG\n    sanity_check_instrumentation(code);\n#endif\n    uint8_t new_line_tools = new_events.tools[PY_MONITORING_EVENT_LINE];\n    uint8_t new_per_instruction_tools = new_events.tools[PY_MONITORING_EVENT_INSTRUCTION];\n\n    if (new_line_tools) {\n        _PyCoLineInstrumentationData *line_data = code->_co_monitoring->lines;\n        for (int i = code->_co_firsttraceable; i < code_len;) {\n            if (line_data[i].original_opcode) {\n                if (new_line_tools) {\n                    add_line_tools(code, i, new_line_tools);\n                }\n            }\n            i += instruction_length(code, i);\n        }\n    }\n    if (new_per_instruction_tools) {\n        for (int i = code->_co_firsttraceable; i < code_len;) {\n            int opcode = _Py_GetBaseOpcode(code, i);\n            if (opcode == RESUME || opcode == END_FOR) {\n                i += instruction_length(code, i);\n                continue;\n            }\n            if (new_per_instruction_tools) {\n                add_per_instruction_tools(code, i, new_per_instruction_tools);\n            }\n            i += instruction_length(code, i);\n        }\n    }\n#ifdef INSTRUMENT_DEBUG\n    sanity_check_instrumentation(code);\n#endif\n    return 0;\n}\n\n#define C_RETURN_EVENTS \\\n    ((1 << PY_MONITORING_EVENT_C_RETURN) | \\\n     (1 << PY_MONITORING_EVENT_C_RAISE))\n\n#define C_CALL_EVENTS \\\n    (C_RETURN_EVENTS | (1 << PY_MONITORING_EVENT_CALL))\n\n\nstatic int\ninstrument_all_executing_code_objects(PyInterpreterState *interp) {\n    _PyRuntimeState *runtime = &_PyRuntime;\n    HEAD_LOCK(runtime);\n    PyThreadState* ts = PyInterpreterState_ThreadHead(interp);\n    HEAD_UNLOCK(runtime);\n    while (ts) {\n        _PyInterpreterFrame *frame = ts->cframe->current_frame;\n        while (frame) {\n            if (frame->owner != FRAME_OWNED_BY_CSTACK) {\n                if (_Py_Instrument(frame->f_code, interp)) {\n                    return -1;\n                }\n            }\n            frame = frame->previous;\n        }\n        HEAD_LOCK(runtime);\n        ts = PyThreadState_Next(ts);\n        HEAD_UNLOCK(runtime);\n    }\n    return 0;\n}\n\nstatic void\nset_events(_Py_GlobalMonitors *m, int tool_id, _PyMonitoringEventSet events)\n{\n    assert(0 <= tool_id && tool_id < PY_MONITORING_TOOL_IDS);\n    for (int e = 0; e < _PY_MONITORING_UNGROUPED_EVENTS; e++) {\n        uint8_t *tools = &m->tools[e];\n        int active = (events >> e) & 1;\n        *tools &= ~(1 << tool_id);\n        *tools |= (active << tool_id);\n    }\n}\n\nstatic void\nset_local_events(_Py_LocalMonitors *m, int tool_id, _PyMonitoringEventSet events)\n{\n    assert(0 <= tool_id && tool_id < PY_MONITORING_TOOL_IDS);\n    for (int e = 0; e < _PY_MONITORING_LOCAL_EVENTS; e++) {\n        uint8_t *tools = &m->tools[e];\n        int val = (events >> e) & 1;\n        *tools &= ~(1 << tool_id);\n        *tools |= (val << tool_id);\n    }\n}\n\nstatic int\ncheck_tool(PyInterpreterState *interp, int tool_id)\n{\n    if (tool_id < PY_MONITORING_SYS_PROFILE_ID &&\n        interp->monitoring_tool_names[tool_id] == NULL)\n    {\n        PyErr_Format(PyExc_ValueError, \"tool %d is not in use\", tool_id);\n        return -1;\n    }\n    return 0;\n}\n\nint\n_PyMonitoring_SetEvents(int tool_id, _PyMonitoringEventSet events)\n{\n    assert(0 <= tool_id && tool_id < PY_MONITORING_TOOL_IDS);\n    PyInterpreterState *interp = _PyInterpreterState_Get();\n    assert(events < (1 << _PY_MONITORING_UNGROUPED_EVENTS));\n    if (check_tool(interp, tool_id)) {\n        return -1;\n    }\n    uint32_t existing_events = get_events(&interp->monitors, tool_id);\n    if (existing_events == events) {\n        return 0;\n    }\n    set_events(&interp->monitors, tool_id, events);\n    interp->monitoring_version++;\n    return instrument_all_executing_code_objects(interp);\n}\n\nint\n_PyMonitoring_SetLocalEvents(PyCodeObject *code, int tool_id, _PyMonitoringEventSet events)\n{\n    assert(0 <= tool_id && tool_id < PY_MONITORING_TOOL_IDS);\n    PyInterpreterState *interp = _PyInterpreterState_Get();\n    assert(events < (1 << _PY_MONITORING_LOCAL_EVENTS));\n    if (code->_co_firsttraceable >= Py_SIZE(code)) {\n        PyErr_Format(PyExc_SystemError, \"cannot instrument shim code object '%U'\", code->co_name);\n        return -1;\n    }\n    if (check_tool(interp, tool_id)) {\n        return -1;\n    }\n    if (allocate_instrumentation_data(code)) {\n        return -1;\n    }\n    _Py_LocalMonitors *local = &code->_co_monitoring->local_monitors;\n    uint32_t existing_events = get_local_events(local, tool_id);\n    if (existing_events == events) {\n        return 0;\n    }\n    set_local_events(local, tool_id, events);\n    if (is_version_up_to_date(code, interp)) {\n        /* Force instrumentation update */\n        code->_co_instrumentation_version = UINT64_MAX;\n    }\n    if (_Py_Instrument(code, interp)) {\n        return -1;\n    }\n    return 0;\n}\n\n/*[clinic input]\nmodule monitoring\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=37257f5987a360cf]*/\n/*[clinic end generated code]*/\n\n#include \"clinic/instrumentation.c.h\"\n\nstatic int\ncheck_valid_tool(int tool_id)\n{\n    if (tool_id < 0 || tool_id >= PY_MONITORING_SYS_PROFILE_ID) {\n        PyErr_Format(PyExc_ValueError, \"invalid tool %d (must be between 0 and 5)\", tool_id);\n        return -1;\n    }\n    return 0;\n}\n\n/*[clinic input]\nmonitoring.use_tool_id\n\n    tool_id: int\n    name: object\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\nmonitoring_use_tool_id_impl(PyObject *module, int tool_id, PyObject *name)\n/*[clinic end generated code: output=30d76dc92b7cd653 input=ebc453761c621be1]*/\n{\n    if (check_valid_tool(tool_id))  {\n        return NULL;\n    }\n    if (!PyUnicode_Check(name)) {\n        PyErr_SetString(PyExc_ValueError, \"tool name must be a str\");\n        return NULL;\n    }\n    PyInterpreterState *interp = _PyInterpreterState_Get();\n    if (interp->monitoring_tool_names[tool_id] != NULL) {\n        PyErr_Format(PyExc_ValueError, \"tool %d is already in use\", tool_id);\n        return NULL;\n    }\n    interp->monitoring_tool_names[tool_id] = Py_NewRef(name);\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nmonitoring.free_tool_id\n\n    tool_id: int\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\nmonitoring_free_tool_id_impl(PyObject *module, int tool_id)\n/*[clinic end generated code: output=86c2d2a1219a8591 input=a23fb6be3a8618e9]*/\n{\n    if (check_valid_tool(tool_id))  {\n        return NULL;\n    }\n    PyInterpreterState *interp = _PyInterpreterState_Get();\n    Py_CLEAR(interp->monitoring_tool_names[tool_id]);\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nmonitoring.get_tool\n\n    tool_id: int\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\nmonitoring_get_tool_impl(PyObject *module, int tool_id)\n/*[clinic end generated code: output=1c05a98b404a9a16 input=eeee9bebd0bcae9d]*/\n\n/*[clinic end generated code]*/\n{\n    if (check_valid_tool(tool_id))  {\n        return NULL;\n    }\n    PyInterpreterState *interp = _PyInterpreterState_Get();\n    PyObject *name = interp->monitoring_tool_names[tool_id];\n    if (name == NULL) {\n        Py_RETURN_NONE;\n    }\n    return Py_NewRef(name);\n}\n\n/*[clinic input]\nmonitoring.register_callback\n\n\n    tool_id: int\n    event: int\n    func: object\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\nmonitoring_register_callback_impl(PyObject *module, int tool_id, int event,\n                                  PyObject *func)\n/*[clinic end generated code: output=e64daa363004030c input=df6d70ea4cf81007]*/\n{\n    if (check_valid_tool(tool_id))  {\n        return NULL;\n    }\n    if (_Py_popcount32(event) != 1) {\n        PyErr_SetString(PyExc_ValueError, \"The callback can only be set for one event at a time\");\n        return NULL;\n    }\n    int event_id = _Py_bit_length(event)-1;\n    if (event_id < 0 || event_id >= _PY_MONITORING_EVENTS) {\n        PyErr_Format(PyExc_ValueError, \"invalid event %d\", event);\n        return NULL;\n    }\n    if (PySys_Audit(\"sys.monitoring.register_callback\", \"O\", func) < 0) {\n        return NULL;\n    }\n    if (func == Py_None) {\n        func = NULL;\n    }\n    func = _PyMonitoring_RegisterCallback(tool_id, event_id, func);\n    if (func == NULL) {\n        Py_RETURN_NONE;\n    }\n    return func;\n}\n\n/*[clinic input]\nmonitoring.get_events -> int\n\n    tool_id: int\n    /\n\n[clinic start generated code]*/\n\nstatic int\nmonitoring_get_events_impl(PyObject *module, int tool_id)\n/*[clinic end generated code: output=4450cc13f826c8c0 input=a64b238f76c4b2f7]*/\n{\n    if (check_valid_tool(tool_id))  {\n        return -1;\n    }\n    _Py_GlobalMonitors *m = &_PyInterpreterState_GET()->monitors;\n    _PyMonitoringEventSet event_set = get_events(m, tool_id);\n    return event_set;\n}\n\n/*[clinic input]\nmonitoring.set_events\n\n    tool_id: int\n    event_set: int\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\nmonitoring_set_events_impl(PyObject *module, int tool_id, int event_set)\n/*[clinic end generated code: output=1916c1e49cfb5bdb input=a77ba729a242142b]*/\n{\n    if (check_valid_tool(tool_id))  {\n        return NULL;\n    }\n    if (event_set < 0 || event_set >= (1 << _PY_MONITORING_EVENTS)) {\n        PyErr_Format(PyExc_ValueError, \"invalid event set 0x%x\", event_set);\n        return NULL;\n    }\n    if ((event_set & C_RETURN_EVENTS) && (event_set & C_CALL_EVENTS) != C_CALL_EVENTS) {\n        PyErr_Format(PyExc_ValueError, \"cannot set C_RETURN or C_RAISE events independently\");\n        return NULL;\n    }\n    event_set &= ~C_RETURN_EVENTS;\n    if (_PyMonitoring_SetEvents(tool_id, event_set)) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nmonitoring.get_local_events -> int\n\n    tool_id: int\n    code: object\n    /\n\n[clinic start generated code]*/\n\nstatic int\nmonitoring_get_local_events_impl(PyObject *module, int tool_id,\n                                 PyObject *code)\n/*[clinic end generated code: output=d3e92c1c9c1de8f9 input=bb0f927530386a94]*/\n{\n    if (!PyCode_Check(code)) {\n        PyErr_Format(\n            PyExc_TypeError,\n            \"code must be a code object\"\n        );\n        return -1;\n    }\n    if (check_valid_tool(tool_id))  {\n        return -1;\n    }\n    _PyMonitoringEventSet event_set = 0;\n    _PyCoMonitoringData *data = ((PyCodeObject *)code)->_co_monitoring;\n    if (data != NULL) {\n        for (int e = 0; e < _PY_MONITORING_LOCAL_EVENTS; e++) {\n            if ((data->local_monitors.tools[e] >> tool_id) & 1) {\n                event_set |= (1 << e);\n            }\n        }\n    }\n    return event_set;\n}\n\n/*[clinic input]\nmonitoring.set_local_events\n\n    tool_id: int\n    code: object\n    event_set: int\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\nmonitoring_set_local_events_impl(PyObject *module, int tool_id,\n                                 PyObject *code, int event_set)\n/*[clinic end generated code: output=68cc755a65dfea99 input=5655ecd78d937a29]*/\n{\n    if (!PyCode_Check(code)) {\n        PyErr_Format(\n            PyExc_TypeError,\n            \"code must be a code object\"\n        );\n        return NULL;\n    }\n    if (check_valid_tool(tool_id))  {\n        return NULL;\n    }\n    if ((event_set & C_RETURN_EVENTS) && (event_set & C_CALL_EVENTS) != C_CALL_EVENTS) {\n        PyErr_Format(PyExc_ValueError, \"cannot set C_RETURN or C_RAISE events independently\");\n        return NULL;\n    }\n    event_set &= ~C_RETURN_EVENTS;\n    if (event_set < 0 || event_set >= (1 << _PY_MONITORING_LOCAL_EVENTS)) {\n        PyErr_Format(PyExc_ValueError, \"invalid local event set 0x%x\", event_set);\n        return NULL;\n    }\n\n    if (_PyMonitoring_SetLocalEvents((PyCodeObject*)code, tool_id, event_set)) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nmonitoring.restart_events\n\n[clinic start generated code]*/\n\nstatic PyObject *\nmonitoring_restart_events_impl(PyObject *module)\n/*[clinic end generated code: output=e025dd5ba33314c4 input=add8a855063c8008]*/\n{\n    /* We want to ensure that:\n     * last restart version > instrumented version for all code objects\n     * last restart version < current version\n     */\n    PyInterpreterState *interp = _PyInterpreterState_Get();\n    interp->last_restart_version = interp->monitoring_version + 1;\n    interp->monitoring_version = interp->last_restart_version + 1;\n    if (instrument_all_executing_code_objects(interp)) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nstatic int\nadd_power2_constant(PyObject *obj, const char *name, int i)\n{\n    PyObject *val = PyLong_FromLong(1<<i);\n    if (val == NULL) {\n        return -1;\n    }\n    int err = PyObject_SetAttrString(obj, name, val);\n    Py_DECREF(val);\n    return err;\n}\n\n/*[clinic input]\nmonitoring._all_events\n[clinic start generated code]*/\n\nstatic PyObject *\nmonitoring__all_events_impl(PyObject *module)\n/*[clinic end generated code: output=6b7581e2dbb690f6 input=62ee9672c17b7f0e]*/\n{\n    PyInterpreterState *interp = _PyInterpreterState_Get();\n    PyObject *res = PyDict_New();\n    if (res == NULL) {\n        return NULL;\n    }\n    for (int e = 0; e < _PY_MONITORING_UNGROUPED_EVENTS; e++) {\n        uint8_t tools = interp->monitors.tools[e];\n        if (tools == 0) {\n            continue;\n        }\n        PyObject *tools_obj = PyLong_FromLong(tools);\n        assert(tools_obj != NULL);\n        int err = PyDict_SetItemString(res, event_names[e], tools_obj);\n        Py_DECREF(tools_obj);\n        if (err < 0) {\n            Py_DECREF(res);\n            return NULL;\n        }\n    }\n    return res;\n}\n\nstatic PyMethodDef methods[] = {\n    MONITORING_USE_TOOL_ID_METHODDEF\n    MONITORING_FREE_TOOL_ID_METHODDEF\n    MONITORING_GET_TOOL_METHODDEF\n    MONITORING_REGISTER_CALLBACK_METHODDEF\n    MONITORING_GET_EVENTS_METHODDEF\n    MONITORING_SET_EVENTS_METHODDEF\n    MONITORING_GET_LOCAL_EVENTS_METHODDEF\n    MONITORING_SET_LOCAL_EVENTS_METHODDEF\n    MONITORING_RESTART_EVENTS_METHODDEF\n    MONITORING__ALL_EVENTS_METHODDEF\n    {NULL, NULL}  // sentinel\n};\n\nstatic struct PyModuleDef monitoring_module = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = \"sys.monitoring\",\n    .m_size = -1, /* multiple \"initialization\" just copies the module dict. */\n    .m_methods = methods,\n};\n\nPyObject *_Py_CreateMonitoringObject(void)\n{\n    PyObject *mod = _PyModule_CreateInitialized(&monitoring_module, PYTHON_API_VERSION);\n    if (mod == NULL) {\n        return NULL;\n    }\n    if (PyObject_SetAttrString(mod, \"DISABLE\", &_PyInstrumentation_DISABLE)) {\n        goto error;\n    }\n    if (PyObject_SetAttrString(mod, \"MISSING\", &_PyInstrumentation_MISSING)) {\n        goto error;\n    }\n    PyObject *events = _PyNamespace_New(NULL);\n    if (events == NULL) {\n        goto error;\n    }\n    int err = PyObject_SetAttrString(mod, \"events\", events);\n    Py_DECREF(events);\n    if (err) {\n        goto error;\n    }\n    for (int i = 0; i < _PY_MONITORING_EVENTS; i++) {\n        if (add_power2_constant(events, event_names[i], i)) {\n            goto error;\n        }\n    }\n    err = PyObject_SetAttrString(events, \"NO_EVENTS\", _PyLong_GetZero());\n    if (err) goto error;\n    PyObject *val = PyLong_FromLong(PY_MONITORING_DEBUGGER_ID);\n    err = PyObject_SetAttrString(mod, \"DEBUGGER_ID\", val);\n    Py_DECREF(val);\n    if (err) goto error;\n    val = PyLong_FromLong(PY_MONITORING_COVERAGE_ID);\n    err = PyObject_SetAttrString(mod, \"COVERAGE_ID\", val);\n    Py_DECREF(val);\n    if (err) goto error;\n    val = PyLong_FromLong(PY_MONITORING_PROFILER_ID);\n    err = PyObject_SetAttrString(mod, \"PROFILER_ID\", val);\n    Py_DECREF(val);\n    if (err) goto error;\n    val = PyLong_FromLong(PY_MONITORING_OPTIMIZER_ID);\n    err = PyObject_SetAttrString(mod, \"OPTIMIZER_ID\", val);\n    Py_DECREF(val);\n    if (err) goto error;\n    return mod;\nerror:\n    Py_DECREF(mod);\n    return NULL;\n}\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value 'all_events.tools[5]'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1466, "startColumn": 9, "endColumn": 51}, "contextRegion": {"startLine": 1466, "snippet": {"text": "    if (all_events.tools[PY_MONITORING_EVENT_LINE]) {\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 2051, "startColumn": 1, "endColumn": 31}, "contextRegion": {"startLine": 2051, "snippet": {"text": "monitoring_restart_events_impl(PyObject *module)\n"}}}, "logicalLocations": [{"name": "monitoring_restart_events_impl", "fullyQualifiedName": "monitoring_restart_events_impl", "decoratedName": "monitoring_restart_events_impl", "kind": "function"}], "message": {"text": "entry to 'monitoring_restart_events_impl'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 2061, "startColumn": 9, "endColumn": 54}, "contextRegion": {"startLine": 2061, "snippet": {"text": "    if (instrument_all_executing_code_objects(interp)) {\n"}}}, "logicalLocations": [{"name": "monitoring_restart_events_impl", "fullyQualifiedName": "monitoring_restart_events_impl", "decoratedName": "monitoring_restart_events_impl", "kind": "function"}], "message": {"text": "calling 'instrument_all_executing_code_objects' from 'monitoring_restart_events_impl'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1676, "startColumn": 1, "endColumn": 38}, "contextRegion": {"startLine": 1676, "snippet": {"text": "instrument_all_executing_code_objects(PyInterpreterState *interp) {\n"}}}, "logicalLocations": [{"name": "instrument_all_executing_code_objects", "fullyQualifiedName": "instrument_all_executing_code_objects", "decoratedName": "instrument_all_executing_code_objects", "kind": "function"}], "message": {"text": "entry to 'instrument_all_executing_code_objects'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1681, "startColumn": 12, "endColumn": 14}, "contextRegion": {"startLine": 1681, "snippet": {"text": "    while (ts) {\n"}}}, "logicalLocations": [{"name": "instrument_all_executing_code_objects", "fullyQualifiedName": "instrument_all_executing_code_objects", "decoratedName": "instrument_all_executing_code_objects", "kind": "function"}], "message": {"text": "following 'true' branch (when 'ts' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1682, "startColumn": 9, "endColumn": 28}, "contextRegion": {"startLine": 1682, "snippet": {"text": "        _PyInterpreterFrame *frame = ts->cframe->current_frame;\n"}}}, "logicalLocations": [{"name": "instrument_all_executing_code_objects", "fullyQualifiedName": "instrument_all_executing_code_objects", "decoratedName": "instrument_all_executing_code_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1681, "startColumn": 12, "endColumn": 14}, "contextRegion": {"startLine": 1681, "snippet": {"text": "    while (ts) {\n"}}}, "logicalLocations": [{"name": "instrument_all_executing_code_objects", "fullyQualifiedName": "instrument_all_executing_code_objects", "decoratedName": "instrument_all_executing_code_objects", "kind": "function"}], "message": {"text": "following 'true' branch (when 'ts' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1682, "startColumn": 9, "endColumn": 28}, "contextRegion": {"startLine": 1682, "snippet": {"text": "        _PyInterpreterFrame *frame = ts->cframe->current_frame;\n"}}}, "logicalLocations": [{"name": "instrument_all_executing_code_objects", "fullyQualifiedName": "instrument_all_executing_code_objects", "decoratedName": "instrument_all_executing_code_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1685, "startColumn": 21, "endColumn": 58}, "contextRegion": {"startLine": 1685, "snippet": {"text": "                if (_Py_Instrument(frame->f_code, interp)) {\n"}}}, "logicalLocations": [{"name": "instrument_all_executing_code_objects", "fullyQualifiedName": "instrument_all_executing_code_objects", "decoratedName": "instrument_all_executing_code_objects", "kind": "function"}], "message": {"text": "calling '_Py_Instrument' from 'instrument_all_executing_code_objects'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1526, "startColumn": 1, "endColumn": 15}, "contextRegion": {"startLine": 1526, "snippet": {"text": "_Py_Instrument(PyCodeObject *code, PyInterpreterState *interp)\n"}}}, "logicalLocations": [{"name": "_Py_Instrument", "fullyQualifiedName": "_Py_Instrument", "decoratedName": "_Py_Instrument", "kind": "function"}], "message": {"text": "entry to '_Py_Instrument'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1546, "startColumn": 9, "endColumn": 50}, "contextRegion": {"startLine": 1546, "snippet": {"text": "    if (update_instrumentation_data(code, interp)) {\n"}}}, "logicalLocations": [{"name": "_Py_Instrument", "fullyQualifiedName": "_Py_Instrument", "decoratedName": "_Py_Instrument", "kind": "function"}], "message": {"text": "calling 'update_instrumentation_data' from '_Py_Instrument'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1448, "startColumn": 1, "endColumn": 28}, "contextRegion": {"startLine": 1448, "snippet": {"text": "update_instrumentation_data(PyCodeObject *code, PyInterpreterState *interp)\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "entry to 'update_instrumentation_data'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1454, "startColumn": 23, "endColumn": 33}, "contextRegion": {"startLine": 1454, "snippet": {"text": "    _Py_LocalMonitors all_events = local_union(\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1451, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1451, "snippet": {"text": "    if (allocate_instrumentation_data(code)) {\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1454, "startColumn": 5, "endColumn": 22}, "contextRegion": {"startLine": 1454, "snippet": {"text": "    _Py_LocalMonitors all_events = local_union(\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1454, "startColumn": 36, "endColumn": 37}, "contextRegion": {"startLine": 1454, "snippet": {"text": "    _Py_LocalMonitors all_events = local_union(\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "inlined call to 'local_union' from 'update_instrumentation_data'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 183, "startColumn": 21, "endColumn": 26}, "contextRegion": {"startLine": 183, "snippet": {"text": "    for (int i = 0; i < _PY_MONITORING_LOCAL_EVENTS; i++) {\n"}}}, "logicalLocations": [{"name": "local_union", "fullyQualifiedName": "local_union", "decoratedName": "local_union", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i != 10')..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 184, "startColumn": 9, "endColumn": 12}, "contextRegion": {"startLine": 184, "snippet": {"text": "        res.tools[i] = a.tools[i] | b.tools[i];\n"}}}, "logicalLocations": [{"name": "local_union", "fullyQualifiedName": "local_union", "decoratedName": "local_union", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 183, "startColumn": 21, "endColumn": 26}, "contextRegion": {"startLine": 183, "snippet": {"text": "    for (int i = 0; i < _PY_MONITORING_LOCAL_EVENTS; i++) {\n"}}}, "logicalLocations": [{"name": "local_union", "fullyQualifiedName": "local_union", "decoratedName": "local_union", "kind": "function"}], "message": {"text": "following 'false' branch (when 'i == 10')..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 186, "startColumn": 5, "endColumn": 11}, "contextRegion": {"startLine": 186, "snippet": {"text": "    return res;\n"}}}, "logicalLocations": [{"name": "local_union", "fullyQualifiedName": "local_union", "decoratedName": "local_union", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1457, "startColumn": 23, "endColumn": 24}, "contextRegion": {"startLine": 1457, "snippet": {"text": "    bool multitools = multiple_tools(&all_events);\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "inlined call to 'multiple_tools' from 'update_instrumentation_data'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 203, "startColumn": 21, "endColumn": 26}, "contextRegion": {"startLine": 203, "snippet": {"text": "    for (int i = 0; i < _PY_MONITORING_LOCAL_EVENTS; i++) {\n"}}}, "logicalLocations": [{"name": "multiple_tools", "fullyQualifiedName": "multiple_tools", "decoratedName": "multiple_tools", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i != 10')..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 204, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 204, "snippet": {"text": "        if (_Py_popcount32(m->tools[i]) > 1) {\n"}}}, "logicalLocations": [{"name": "multiple_tools", "fullyQualifiedName": "multiple_tools", "decoratedName": "multiple_tools", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1466, "startColumn": 9, "endColumn": 51}, "contextRegion": {"startLine": 1466, "snippet": {"text": "    if (all_events.tools[PY_MONITORING_EVENT_LINE]) {\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "use of uninitialized value 'all_events.tools[5]' here"}}, "kinds": ["danger"], "nestingLevel": 4}]}]}]}, {"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value 'all_events.tools[5]'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1466, "startColumn": 9, "endColumn": 51}, "contextRegion": {"startLine": 1466, "snippet": {"text": "    if (all_events.tools[PY_MONITORING_EVENT_LINE]) {\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1947, "startColumn": 1, "endColumn": 27}, "contextRegion": {"startLine": 1947, "snippet": {"text": "monitoring_set_events_impl(PyObject *module, int tool_id, int event_set)\n"}}}, "logicalLocations": [{"name": "monitoring_set_events_impl", "fullyQualifiedName": "monitoring_set_events_impl", "decoratedName": "monitoring_set_events_impl", "kind": "function"}], "message": {"text": "entry to 'monitoring_set_events_impl'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1950, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 1950, "snippet": {"text": "    if (check_valid_tool(tool_id))  {\n"}}}, "logicalLocations": [{"name": "monitoring_set_events_impl", "fullyQualifiedName": "monitoring_set_events_impl", "decoratedName": "monitoring_set_events_impl", "kind": "function"}], "message": {"text": "inlined call to 'check_valid_tool' from 'monitoring_set_events_impl'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1795, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1795, "snippet": {"text": "    if (tool_id < 0 || tool_id >= PY_MONITORING_SYS_PROFILE_ID) {\n"}}}, "logicalLocations": [{"name": "check_valid_tool", "fullyQualifiedName": "check_valid_tool", "decoratedName": "check_valid_tool", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1950, "startColumn": 9, "endColumn": 34}, "contextRegion": {"startLine": 1950, "snippet": {"text": "    if (check_valid_tool(tool_id))  {\n"}}}, "logicalLocations": [{"name": "monitoring_set_events_impl", "fullyQualifiedName": "monitoring_set_events_impl", "decoratedName": "monitoring_set_events_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1953, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1953, "snippet": {"text": "    if (event_set < 0 || event_set >= (1 << _PY_MONITORING_EVENTS)) {\n"}}}, "logicalLocations": [{"name": "monitoring_set_events_impl", "fullyQualifiedName": "monitoring_set_events_impl", "decoratedName": "monitoring_set_events_impl", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1957, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 1957, "snippet": {"text": "    if ((event_set & C_RETURN_EVENTS) && (event_set & C_CALL_EVENTS) != C_CALL_EVENTS) {\n"}}}, "logicalLocations": [{"name": "monitoring_set_events_impl", "fullyQualifiedName": "monitoring_set_events_impl", "decoratedName": "monitoring_set_events_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1962, "startColumn": 9, "endColumn": 52}, "contextRegion": {"startLine": 1962, "snippet": {"text": "    if (_PyMonitoring_SetEvents(tool_id, event_set)) {\n"}}}, "logicalLocations": [{"name": "monitoring_set_events_impl", "fullyQualifiedName": "monitoring_set_events_impl", "decoratedName": "monitoring_set_events_impl", "kind": "function"}], "message": {"text": "calling '_PyMonitoring_SetEvents' from 'monitoring_set_events_impl'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1735, "startColumn": 1, "endColumn": 24}, "contextRegion": {"startLine": 1735, "snippet": {"text": "_PyMonitoring_SetEvents(int tool_id, _PyMonitoringEventSet events)\n"}}}, "logicalLocations": [{"name": "_PyMonitoring_SetEvents", "fullyQualifiedName": "_PyMonitoring_SetEvents", "decoratedName": "_PyMonitoring_SetEvents", "kind": "function"}], "message": {"text": "entry to '_PyMonitoring_SetEvents'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1743, "startColumn": 32, "endColumn": 33}, "contextRegion": {"startLine": 1743, "snippet": {"text": "    uint32_t existing_events = get_events(&interp->monitors, tool_id);\n"}}}, "logicalLocations": [{"name": "_PyMonitoring_SetEvents", "fullyQualifiedName": "_PyMonitoring_SetEvents", "decoratedName": "_PyMonitoring_SetEvents", "kind": "function"}], "message": {"text": "inlined call to 'get_events' from '_PyMonitoring_SetEvents'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 227, "startColumn": 21, "endColumn": 26}, "contextRegion": {"startLine": 227, "snippet": {"text": "    for (int e = 0; e < _PY_MONITORING_UNGROUPED_EVENTS; e++) {\n"}}}, "logicalLocations": [{"name": "get_events", "fullyQualifiedName": "get_events", "decoratedName": "get_events", "kind": "function"}], "message": {"text": "following 'true' branch (when 'e != 15')..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 228, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 228, "snippet": {"text": "        if ((m->tools[e] >> tool_id) & 1) {\n"}}}, "logicalLocations": [{"name": "get_events", "fullyQualifiedName": "get_events", "decoratedName": "get_events", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1744, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1744, "snippet": {"text": "    if (existing_events == events) {\n"}}}, "logicalLocations": [{"name": "_PyMonitoring_SetEvents", "fullyQualifiedName": "_PyMonitoring_SetEvents", "decoratedName": "_PyMonitoring_SetEvents", "kind": "function"}], "message": {"text": "following 'false' branch (when 'events != result')..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"logicalLocations": [{"name": "_PyMonitoring_SetEvents", "fullyQualifiedName": "_PyMonitoring_SetEvents", "decoratedName": "_PyMonitoring_SetEvents", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1747, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1747, "snippet": {"text": "    set_events(&interp->monitors, tool_id, events);\n"}}}, "logicalLocations": [{"name": "_PyMonitoring_SetEvents", "fullyQualifiedName": "_PyMonitoring_SetEvents", "decoratedName": "_PyMonitoring_SetEvents", "kind": "function"}], "message": {"text": "inlined call to 'set_events' from '_PyMonitoring_SetEvents'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1702, "startColumn": 21, "endColumn": 26}, "contextRegion": {"startLine": 1702, "snippet": {"text": "    for (int e = 0; e < _PY_MONITORING_UNGROUPED_EVENTS; e++) {\n"}}}, "logicalLocations": [{"name": "set_events", "fullyQualifiedName": "set_events", "decoratedName": "set_events", "kind": "function"}], "message": {"text": "following 'true' branch (when 'e != 15')..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1703, "startColumn": 9, "endColumn": 16}, "contextRegion": {"startLine": 1703, "snippet": {"text": "        uint8_t *tools = &m->tools[e];\n"}}}, "logicalLocations": [{"name": "set_events", "fullyQualifiedName": "set_events", "decoratedName": "set_events", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1749, "startColumn": 12, "endColumn": 57}, "contextRegion": {"startLine": 1749, "snippet": {"text": "    return instrument_all_executing_code_objects(interp);\n"}}}, "logicalLocations": [{"name": "_PyMonitoring_SetEvents", "fullyQualifiedName": "_PyMonitoring_SetEvents", "decoratedName": "_PyMonitoring_SetEvents", "kind": "function"}], "message": {"text": "calling 'instrument_all_executing_code_objects' from '_PyMonitoring_SetEvents'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1676, "startColumn": 1, "endColumn": 38}, "contextRegion": {"startLine": 1676, "snippet": {"text": "instrument_all_executing_code_objects(PyInterpreterState *interp) {\n"}}}, "logicalLocations": [{"name": "instrument_all_executing_code_objects", "fullyQualifiedName": "instrument_all_executing_code_objects", "decoratedName": "instrument_all_executing_code_objects", "kind": "function"}], "message": {"text": "entry to 'instrument_all_executing_code_objects'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1681, "startColumn": 12, "endColumn": 14}, "contextRegion": {"startLine": 1681, "snippet": {"text": "    while (ts) {\n"}}}, "logicalLocations": [{"name": "instrument_all_executing_code_objects", "fullyQualifiedName": "instrument_all_executing_code_objects", "decoratedName": "instrument_all_executing_code_objects", "kind": "function"}], "message": {"text": "following 'true' branch (when 'ts' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1682, "startColumn": 9, "endColumn": 28}, "contextRegion": {"startLine": 1682, "snippet": {"text": "        _PyInterpreterFrame *frame = ts->cframe->current_frame;\n"}}}, "logicalLocations": [{"name": "instrument_all_executing_code_objects", "fullyQualifiedName": "instrument_all_executing_code_objects", "decoratedName": "instrument_all_executing_code_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1681, "startColumn": 12, "endColumn": 14}, "contextRegion": {"startLine": 1681, "snippet": {"text": "    while (ts) {\n"}}}, "logicalLocations": [{"name": "instrument_all_executing_code_objects", "fullyQualifiedName": "instrument_all_executing_code_objects", "decoratedName": "instrument_all_executing_code_objects", "kind": "function"}], "message": {"text": "following 'true' branch (when 'ts' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1682, "startColumn": 9, "endColumn": 28}, "contextRegion": {"startLine": 1682, "snippet": {"text": "        _PyInterpreterFrame *frame = ts->cframe->current_frame;\n"}}}, "logicalLocations": [{"name": "instrument_all_executing_code_objects", "fullyQualifiedName": "instrument_all_executing_code_objects", "decoratedName": "instrument_all_executing_code_objects", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1685, "startColumn": 21, "endColumn": 58}, "contextRegion": {"startLine": 1685, "snippet": {"text": "                if (_Py_Instrument(frame->f_code, interp)) {\n"}}}, "logicalLocations": [{"name": "instrument_all_executing_code_objects", "fullyQualifiedName": "instrument_all_executing_code_objects", "decoratedName": "instrument_all_executing_code_objects", "kind": "function"}], "message": {"text": "calling '_Py_Instrument' from 'instrument_all_executing_code_objects'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1526, "startColumn": 1, "endColumn": 15}, "contextRegion": {"startLine": 1526, "snippet": {"text": "_Py_Instrument(PyCodeObject *code, PyInterpreterState *interp)\n"}}}, "logicalLocations": [{"name": "_Py_Instrument", "fullyQualifiedName": "_Py_Instrument", "decoratedName": "_Py_Instrument", "kind": "function"}], "message": {"text": "entry to '_Py_Instrument'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1546, "startColumn": 9, "endColumn": 50}, "contextRegion": {"startLine": 1546, "snippet": {"text": "    if (update_instrumentation_data(code, interp)) {\n"}}}, "logicalLocations": [{"name": "_Py_Instrument", "fullyQualifiedName": "_Py_Instrument", "decoratedName": "_Py_Instrument", "kind": "function"}], "message": {"text": "calling 'update_instrumentation_data' from '_Py_Instrument'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1448, "startColumn": 1, "endColumn": 28}, "contextRegion": {"startLine": 1448, "snippet": {"text": "update_instrumentation_data(PyCodeObject *code, PyInterpreterState *interp)\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "entry to 'update_instrumentation_data'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1454, "startColumn": 23, "endColumn": 33}, "contextRegion": {"startLine": 1454, "snippet": {"text": "    _Py_LocalMonitors all_events = local_union(\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1451, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 1451, "snippet": {"text": "    if (allocate_instrumentation_data(code)) {\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1454, "startColumn": 5, "endColumn": 22}, "contextRegion": {"startLine": 1454, "snippet": {"text": "    _Py_LocalMonitors all_events = local_union(\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1454, "startColumn": 36, "endColumn": 37}, "contextRegion": {"startLine": 1454, "snippet": {"text": "    _Py_LocalMonitors all_events = local_union(\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "inlined call to 'local_union' from 'update_instrumentation_data'"}}, "kinds": ["call", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 183, "startColumn": 21, "endColumn": 26}, "contextRegion": {"startLine": 183, "snippet": {"text": "    for (int i = 0; i < _PY_MONITORING_LOCAL_EVENTS; i++) {\n"}}}, "logicalLocations": [{"name": "local_union", "fullyQualifiedName": "local_union", "decoratedName": "local_union", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i != 10')..."}}, "kinds": ["branch", "true"], "nestingLevel": 6}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 184, "startColumn": 9, "endColumn": 12}, "contextRegion": {"startLine": 184, "snippet": {"text": "        res.tools[i] = a.tools[i] | b.tools[i];\n"}}}, "logicalLocations": [{"name": "local_union", "fullyQualifiedName": "local_union", "decoratedName": "local_union", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 6}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 183, "startColumn": 21, "endColumn": 26}, "contextRegion": {"startLine": 183, "snippet": {"text": "    for (int i = 0; i < _PY_MONITORING_LOCAL_EVENTS; i++) {\n"}}}, "logicalLocations": [{"name": "local_union", "fullyQualifiedName": "local_union", "decoratedName": "local_union", "kind": "function"}], "message": {"text": "following 'false' branch (when 'i == 10')..."}}, "kinds": ["branch", "false"], "nestingLevel": 6}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 186, "startColumn": 5, "endColumn": 11}, "contextRegion": {"startLine": 186, "snippet": {"text": "    return res;\n"}}}, "logicalLocations": [{"name": "local_union", "fullyQualifiedName": "local_union", "decoratedName": "local_union", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 6}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1457, "startColumn": 23, "endColumn": 24}, "contextRegion": {"startLine": 1457, "snippet": {"text": "    bool multitools = multiple_tools(&all_events);\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "inlined call to 'multiple_tools' from 'update_instrumentation_data'"}}, "kinds": ["call", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 203, "startColumn": 21, "endColumn": 26}, "contextRegion": {"startLine": 203, "snippet": {"text": "    for (int i = 0; i < _PY_MONITORING_LOCAL_EVENTS; i++) {\n"}}}, "logicalLocations": [{"name": "multiple_tools", "fullyQualifiedName": "multiple_tools", "decoratedName": "multiple_tools", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i != 10')..."}}, "kinds": ["branch", "true"], "nestingLevel": 6}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 204, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 204, "snippet": {"text": "        if (_Py_popcount32(m->tools[i]) > 1) {\n"}}}, "logicalLocations": [{"name": "multiple_tools", "fullyQualifiedName": "multiple_tools", "decoratedName": "multiple_tools", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 6}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/instrumentation.c", "uriBaseId": "PWD"}, "region": {"startLine": 1466, "startColumn": 9, "endColumn": 51}, "contextRegion": {"startLine": 1466, "snippet": {"text": "    if (all_events.tools[PY_MONITORING_EVENT_LINE]) {\n"}}}, "logicalLocations": [{"name": "update_instrumentation_data", "fullyQualifiedName": "update_instrumentation_data", "decoratedName": "update_instrumentation_data", "kind": "function"}], "message": {"text": "use of uninitialized value 'all_events.tools[5]' here"}}, "kinds": ["danger"], "nestingLevel": 5}]}]}]}]}]}
