{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-use-of-uninitialized-value", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-use-of-uninitialized-value"}, {"id": "-Wanalyzer-null-dereference", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-dereference"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "457", "helpUri": "https://cwe.mitre.org/data/definitions/457.html"}, {"id": "476", "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}}, "artifacts": [{"location": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "contents": {"text": "/*\n *   This is a curses module for Python.\n *\n *   Based on prior work by Lance Ellinghaus and Oliver Andrich\n *   Version 1.2 of this module: Copyright 1994 by Lance Ellinghouse,\n *    Cathedral City, California Republic, United States of America.\n *\n *   Version 1.5b1, heavily extended for ncurses by Oliver Andrich:\n *   Copyright 1996,1997 by Oliver Andrich, Koblenz, Germany.\n *\n *   Tidied for Python 1.6, and currently maintained by <amk@amk.ca>.\n *\n *   Permission is hereby granted, free of charge, to any person obtaining\n *   a copy of this source file to use, copy, modify, merge, or publish it\n *   subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included\n *   in all copies or in any new file that contains a substantial portion of\n *   this file.\n *\n *   THE  AUTHOR  MAKES  NO  REPRESENTATIONS ABOUT  THE  SUITABILITY  OF\n *   THE  SOFTWARE FOR  ANY  PURPOSE.  IT IS  PROVIDED  \"AS IS\"  WITHOUT\n *   EXPRESS OR  IMPLIED WARRANTY.  THE AUTHOR DISCLAIMS  ALL WARRANTIES\n *   WITH  REGARD TO  THIS  SOFTWARE, INCLUDING  ALL IMPLIED  WARRANTIES\n *   OF   MERCHANTABILITY,  FITNESS   FOR  A   PARTICULAR  PURPOSE   AND\n *   NON-INFRINGEMENT  OF THIRD  PARTY  RIGHTS. IN  NO  EVENT SHALL  THE\n *   AUTHOR  BE LIABLE  TO  YOU  OR ANY  OTHER  PARTY  FOR ANY  SPECIAL,\n *   INDIRECT,  OR  CONSEQUENTIAL  DAMAGES  OR  ANY  DAMAGES  WHATSOEVER\n *   WHETHER IN AN  ACTION OF CONTRACT, NEGLIGENCE,  STRICT LIABILITY OR\n *   ANY OTHER  ACTION ARISING OUT OF  OR IN CONNECTION WITH  THE USE OR\n *   PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n\n  A number of SysV or ncurses functions don't have wrappers yet; if you\n  need a given function, add it and send a patch.  See\n  https://www.python.org/dev/patches/ for instructions on how to submit\n  patches to Python.\n\n  Here's a list of currently unsupported functions:\n\n  addchnstr addchstr color_set define_key\n  del_curterm delscreen dupwin inchnstr inchstr innstr keyok\n  mcprint mvaddchnstr mvaddchstr mvcur mvinchnstr\n  mvinchstr mvinnstr mmvwaddchnstr mvwaddchstr\n  mvwinchnstr mvwinchstr mvwinnstr newterm\n  restartterm ripoffline scr_dump\n  scr_init scr_restore scr_set scrl set_curterm set_term setterm\n  tgetent tgetflag tgetnum tgetstr tgoto timeout tputs\n  vidattr vidputs waddchnstr waddchstr\n  wcolor_set winchnstr winchstr winnstr wmouse_trafo wscrl\n\n  Low-priority:\n  slk_attr slk_attr_off slk_attr_on slk_attr_set slk_attroff\n  slk_attron slk_attrset slk_clear slk_color slk_init slk_label\n  slk_noutrefresh slk_refresh slk_restore slk_set slk_touch\n\n  Menu extension (ncurses and probably SYSV):\n  current_item free_item free_menu item_count item_description\n  item_index item_init item_name item_opts item_opts_off\n  item_opts_on item_term item_userptr item_value item_visible\n  menu_back menu_driver menu_fore menu_format menu_grey\n  menu_init menu_items menu_mark menu_opts menu_opts_off\n  menu_opts_on menu_pad menu_pattern menu_request_by_name\n  menu_request_name menu_spacing menu_sub menu_term menu_userptr\n  menu_win new_item new_menu pos_menu_cursor post_menu\n  scale_menu set_current_item set_item_init set_item_opts\n  set_item_term set_item_userptr set_item_value set_menu_back\n  set_menu_fore set_menu_format set_menu_grey set_menu_init\n  set_menu_items set_menu_mark set_menu_opts set_menu_pad\n  set_menu_pattern set_menu_spacing set_menu_sub set_menu_term\n  set_menu_userptr set_menu_win set_top_row top_row unpost_menu\n\n  Form extension (ncurses and probably SYSV):\n  current_field data_ahead data_behind dup_field\n  dynamic_fieldinfo field_arg field_back field_buffer\n  field_count field_fore field_index field_info field_init\n  field_just field_opts field_opts_off field_opts_on field_pad\n  field_status field_term field_type field_userptr form_driver\n  form_fields form_init form_opts form_opts_off form_opts_on\n  form_page form_request_by_name form_request_name form_sub\n  form_term form_userptr form_win free_field free_form\n  link_field link_fieldtype move_field new_field new_form\n  new_page pos_form_cursor post_form scale_form\n  set_current_field set_field_back set_field_buffer\n  set_field_fore set_field_init set_field_just set_field_opts\n  set_field_pad set_field_status set_field_term set_field_type\n  set_field_userptr set_fieldtype_arg set_fieldtype_choice\n  set_form_fields set_form_init set_form_opts set_form_page\n  set_form_sub set_form_term set_form_userptr set_form_win\n  set_max_field set_new_page unpost_form\n\n\n*/\n\n/* Release Number */\n\nstatic const char PyCursesVersion[] = \"2.2\";\n\n/* Includes */\n\n#ifndef Py_BUILD_CORE_BUILTIN\n#  define Py_BUILD_CORE_MODULE 1\n#endif\n\n#define PY_SSIZE_T_CLEAN\n\n#include \"Python.h\"\n#include \"pycore_long.h\"          // _PyLong_GetZero()\n#include \"pycore_structseq.h\"     // _PyStructSequence_NewType()\n\n#ifdef __hpux\n#define STRICT_SYSV_CURSES\n#endif\n\n#define CURSES_MODULE\n#include \"py_curses.h\"\n\n#if defined(HAVE_TERM_H) || defined(__sgi)\n/* For termname, longname, putp, tigetflag, tigetnum, tigetstr, tparm\n   which are not declared in SysV curses and for setupterm. */\n#include <term.h>\n/* Including <term.h> #defines many common symbols. */\n#undef lines\n#undef columns\n#endif\n\n#ifdef HAVE_LANGINFO_H\n#include <langinfo.h>\n#endif\n\n#if !defined(HAVE_NCURSES_H) && (defined(sgi) || defined(__sun) || defined(SCO5))\n#define STRICT_SYSV_CURSES       /* Don't use ncurses extensions */\ntypedef chtype attr_t;           /* No attr_t type is available */\n#endif\n\n#if defined(_AIX)\n#define STRICT_SYSV_CURSES\n#endif\n\n#if NCURSES_EXT_FUNCS+0 >= 20170401 && NCURSES_EXT_COLORS+0 >= 20170401\n#define _NCURSES_EXTENDED_COLOR_FUNCS   1\n#else\n#define _NCURSES_EXTENDED_COLOR_FUNCS   0\n#endif\n\n#if _NCURSES_EXTENDED_COLOR_FUNCS\n#define _CURSES_COLOR_VAL_TYPE          int\n#define _CURSES_COLOR_NUM_TYPE          int\n#define _CURSES_INIT_COLOR_FUNC         init_extended_color\n#define _CURSES_INIT_PAIR_FUNC          init_extended_pair\n#define _COLOR_CONTENT_FUNC             extended_color_content\n#define _CURSES_PAIR_CONTENT_FUNC       extended_pair_content\n#else\n#define _CURSES_COLOR_VAL_TYPE          short\n#define _CURSES_COLOR_NUM_TYPE          short\n#define _CURSES_INIT_COLOR_FUNC         init_color\n#define _CURSES_INIT_PAIR_FUNC          init_pair\n#define _COLOR_CONTENT_FUNC             color_content\n#define _CURSES_PAIR_CONTENT_FUNC       pair_content\n#endif  /* _NCURSES_EXTENDED_COLOR_FUNCS */\n\n/*[clinic input]\nmodule _curses\nclass _curses.window \"PyCursesWindowObject *\" \"&PyCursesWindow_Type\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=43265c372c2887d6]*/\n\n/* Definition of exception curses.error */\n\nstatic PyObject *PyCursesError;\n\n/* Tells whether setupterm() has been called to initialise terminfo.  */\nstatic int initialised_setupterm = FALSE;\n\n/* Tells whether initscr() has been called to initialise curses.  */\nstatic int initialised = FALSE;\n\n/* Tells whether start_color() has been called to initialise color usage. */\nstatic int initialisedcolors = FALSE;\n\nstatic char *screen_encoding = NULL;\n\n/* Utility Macros */\n#define PyCursesSetupTermCalled                                         \\\n    if (initialised_setupterm != TRUE) {                                \\\n        PyErr_SetString(PyCursesError,                                  \\\n                        \"must call (at least) setupterm() first\");      \\\n        return 0; }\n\n#define PyCursesInitialised                             \\\n    if (initialised != TRUE) {                          \\\n        PyErr_SetString(PyCursesError,                  \\\n                        \"must call initscr() first\");   \\\n        return 0; }\n\n#define PyCursesInitialisedColor                                \\\n    if (initialisedcolors != TRUE) {                            \\\n        PyErr_SetString(PyCursesError,                          \\\n                        \"must call start_color() first\");       \\\n        return 0; }\n\n/* Utility Functions */\n\n/*\n * Check the return code from a curses function and return None\n * or raise an exception as appropriate.  These are exported using the\n * capsule API.\n */\n\nstatic PyObject *\nPyCursesCheckERR(int code, const char *fname)\n{\n    if (code != ERR) {\n        Py_RETURN_NONE;\n    } else {\n        if (fname == NULL) {\n            PyErr_SetString(PyCursesError, catchall_ERR);\n        } else {\n            PyErr_Format(PyCursesError, \"%s() returned ERR\", fname);\n        }\n        return NULL;\n    }\n}\n\n/* Convert an object to a byte (an integer of type chtype):\n\n   - int\n   - bytes of length 1\n   - str of length 1\n\n   Return 1 on success, 0 on error (invalid type or integer overflow). */\nstatic int\nPyCurses_ConvertToChtype(PyCursesWindowObject *win, PyObject *obj, chtype *ch)\n{\n    long value;\n    if(PyBytes_Check(obj) && PyBytes_Size(obj) == 1) {\n        value = (unsigned char)PyBytes_AsString(obj)[0];\n    }\n    else if (PyUnicode_Check(obj)) {\n        if (PyUnicode_GetLength(obj) != 1) {\n            PyErr_Format(PyExc_TypeError,\n                         \"expect bytes or str of length 1, or int, \"\n                         \"got a str of length %zi\",\n                         PyUnicode_GET_LENGTH(obj));\n            return 0;\n        }\n        value = PyUnicode_READ_CHAR(obj, 0);\n        if (128 < value) {\n            PyObject *bytes;\n            const char *encoding;\n            if (win)\n                encoding = win->encoding;\n            else\n                encoding = screen_encoding;\n            bytes = PyUnicode_AsEncodedString(obj, encoding, NULL);\n            if (bytes == NULL)\n                return 0;\n            if (PyBytes_GET_SIZE(bytes) == 1)\n                value = (unsigned char)PyBytes_AS_STRING(bytes)[0];\n            else\n                value = -1;\n            Py_DECREF(bytes);\n            if (value < 0)\n                goto overflow;\n        }\n    }\n    else if (PyLong_CheckExact(obj)) {\n        int long_overflow;\n        value = PyLong_AsLongAndOverflow(obj, &long_overflow);\n        if (long_overflow)\n            goto overflow;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"expect bytes or str of length 1, or int, got %s\",\n                     Py_TYPE(obj)->tp_name);\n        return 0;\n    }\n    *ch = (chtype)value;\n    if ((long)*ch != value)\n        goto overflow;\n    return 1;\n\noverflow:\n    PyErr_SetString(PyExc_OverflowError,\n                    \"byte doesn't fit in chtype\");\n    return 0;\n}\n\n/* Convert an object to a byte (chtype) or a character (cchar_t):\n\n    - int\n    - bytes of length 1\n    - str of length 1\n\n   Return:\n\n    - 2 if obj is a character (written into *wch)\n    - 1 if obj is a byte (written into *ch)\n    - 0 on error: raise an exception */\nstatic int\nPyCurses_ConvertToCchar_t(PyCursesWindowObject *win, PyObject *obj,\n                          chtype *ch\n#ifdef HAVE_NCURSESW\n                          , wchar_t *wch\n#endif\n                          )\n{\n    long value;\n#ifdef HAVE_NCURSESW\n    wchar_t buffer[2];\n#endif\n\n    if (PyUnicode_Check(obj)) {\n#ifdef HAVE_NCURSESW\n        if (PyUnicode_AsWideChar(obj, buffer, 2) != 1) {\n            PyErr_Format(PyExc_TypeError,\n                         \"expect bytes or str of length 1, or int, \"\n                         \"got a str of length %zi\",\n                         PyUnicode_GET_LENGTH(obj));\n            return 0;\n        }\n        *wch = buffer[0];\n        return 2;\n#else\n        return PyCurses_ConvertToChtype(win, obj, ch);\n#endif\n    }\n    else if(PyBytes_Check(obj) && PyBytes_Size(obj) == 1) {\n        value = (unsigned char)PyBytes_AsString(obj)[0];\n    }\n    else if (PyLong_CheckExact(obj)) {\n        int overflow;\n        value = PyLong_AsLongAndOverflow(obj, &overflow);\n        if (overflow) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"int doesn't fit in long\");\n            return 0;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"expect bytes or str of length 1, or int, got %s\",\n                     Py_TYPE(obj)->tp_name);\n        return 0;\n    }\n\n    *ch = (chtype)value;\n    if ((long)*ch != value) {\n        PyErr_Format(PyExc_OverflowError,\n                     \"byte doesn't fit in chtype\");\n        return 0;\n    }\n    return 1;\n}\n\n/* Convert an object to a byte string (char*) or a wide character string\n   (wchar_t*). Return:\n\n    - 2 if obj is a character string (written into *wch)\n    - 1 if obj is a byte string (written into *bytes)\n    - 0 on error: raise an exception */\nstatic int\nPyCurses_ConvertToString(PyCursesWindowObject *win, PyObject *obj,\n                         PyObject **bytes, wchar_t **wstr)\n{\n    char *str;\n    if (PyUnicode_Check(obj)) {\n#ifdef HAVE_NCURSESW\n        assert (wstr != NULL);\n\n        *wstr = PyUnicode_AsWideCharString(obj, NULL);\n        if (*wstr == NULL)\n            return 0;\n        return 2;\n#else\n        assert (wstr == NULL);\n        *bytes = PyUnicode_AsEncodedString(obj, win->encoding, NULL);\n        if (*bytes == NULL)\n            return 0;\n        /* check for embedded null bytes */\n        if (PyBytes_AsStringAndSize(*bytes, &str, NULL) < 0) {\n            Py_CLEAR(*bytes);\n            return 0;\n        }\n        return 1;\n#endif\n    }\n    else if (PyBytes_Check(obj)) {\n        *bytes = Py_NewRef(obj);\n        /* check for embedded null bytes */\n        if (PyBytes_AsStringAndSize(*bytes, &str, NULL) < 0) {\n            Py_DECREF(obj);\n            return 0;\n        }\n        return 1;\n    }\n\n    PyErr_Format(PyExc_TypeError, \"expect bytes or str, got %s\",\n                 Py_TYPE(obj)->tp_name);\n    return 0;\n}\n\nstatic int\ncolor_allow_default_converter(PyObject *arg, void *ptr)\n{\n    long color_number;\n    int overflow;\n\n    color_number = PyLong_AsLongAndOverflow(arg, &overflow);\n    if (color_number == -1 && PyErr_Occurred())\n        return 0;\n\n    if (overflow > 0 || color_number >= COLORS) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Color number is greater than COLORS-1 (%d).\",\n                     COLORS - 1);\n        return 0;\n    }\n    else if (overflow < 0 || color_number < 0) {\n        color_number = -1;\n    }\n\n    *(int *)ptr = (int)color_number;\n    return 1;\n}\n\nstatic int\ncolor_converter(PyObject *arg, void *ptr)\n{\n    if (!color_allow_default_converter(arg, ptr)) {\n        return 0;\n    }\n    if (*(int *)ptr < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"Color number is less than 0.\");\n        return 0;\n    }\n    return 1;\n}\n\n/*[python input]\nclass color_converter(CConverter):\n    type = 'int'\n    converter = 'color_converter'\n[python start generated code]*/\n/*[python end generated code: output=da39a3ee5e6b4b0d input=4260d2b6e66b3709]*/\n\n/*[python input]\nclass color_allow_default_converter(CConverter):\n    type = 'int'\n    converter = 'color_allow_default_converter'\n[python start generated code]*/\n/*[python end generated code: output=da39a3ee5e6b4b0d input=975602bc058a872d]*/\n\nstatic int\npair_converter(PyObject *arg, void *ptr)\n{\n    long pair_number;\n    int overflow;\n\n    pair_number = PyLong_AsLongAndOverflow(arg, &overflow);\n    if (pair_number == -1 && PyErr_Occurred())\n        return 0;\n\n#if _NCURSES_EXTENDED_COLOR_FUNCS\n    if (overflow > 0 || pair_number > INT_MAX) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Color pair is greater than maximum (%d).\",\n                     INT_MAX);\n        return 0;\n    }\n#else\n    if (overflow > 0 || pair_number >= COLOR_PAIRS) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Color pair is greater than COLOR_PAIRS-1 (%d).\",\n                     COLOR_PAIRS - 1);\n        return 0;\n    }\n#endif\n    else if (overflow < 0 || pair_number < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"Color pair is less than 0.\");\n        return 0;\n    }\n\n    *(int *)ptr = (int)pair_number;\n    return 1;\n}\n\n/*[python input]\nclass pair_converter(CConverter):\n    type = 'int'\n    converter = 'pair_converter'\n[python start generated code]*/\n/*[python end generated code: output=da39a3ee5e6b4b0d input=1a918ae6a1b32af7]*/\n\nstatic int\ncomponent_converter(PyObject *arg, void *ptr)\n{\n    long component;\n    int overflow;\n\n    component = PyLong_AsLongAndOverflow(arg, &overflow);\n    if (component == -1 && PyErr_Occurred())\n        return 0;\n\n    if (overflow > 0 || component > 1000) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"Color component is greater than 1000\");\n        return 0;\n    }\n    else if (overflow < 0 || component < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"Color component is less than 0\");\n        return 0;\n    }\n\n    *(short *)ptr = (short)component;\n    return 1;\n}\n\n/*[python input]\nclass component_converter(CConverter):\n    type = 'short'\n    converter = 'component_converter'\n[python start generated code]*/\n/*[python end generated code: output=da39a3ee5e6b4b0d input=38e9be01d33927fb]*/\n\n/* Function versions of the 3 functions for testing whether curses has been\n   initialised or not. */\n\nstatic int func_PyCursesSetupTermCalled(void)\n{\n    PyCursesSetupTermCalled;\n    return 1;\n}\n\nstatic int func_PyCursesInitialised(void)\n{\n    PyCursesInitialised;\n    return 1;\n}\n\nstatic int func_PyCursesInitialisedColor(void)\n{\n    PyCursesInitialisedColor;\n    return 1;\n}\n\n/*****************************************************************************\n The Window Object\n******************************************************************************/\n\n/* Definition of the window type */\n\nPyTypeObject PyCursesWindow_Type;\n\n/* Function prototype macros for Window object\n\n   X - function name\n   TYPE - parameter Type\n   ERGSTR - format string for construction of the return value\n   PARSESTR - format string for argument parsing\n*/\n\n#define Window_NoArgNoReturnFunction(X)                         \\\n    static PyObject *PyCursesWindow_ ## X                       \\\n    (PyCursesWindowObject *self, PyObject *Py_UNUSED(ignored))  \\\n    { return PyCursesCheckERR(X(self->win), # X); }\n\n#define Window_NoArgTrueFalseFunction(X)                                \\\n    static PyObject * PyCursesWindow_ ## X                              \\\n    (PyCursesWindowObject *self, PyObject *Py_UNUSED(ignored))          \\\n    {                                                                   \\\n        return PyBool_FromLong(X(self->win)); }\n\n#define Window_NoArgNoReturnVoidFunction(X)                     \\\n    static PyObject * PyCursesWindow_ ## X                      \\\n    (PyCursesWindowObject *self, PyObject *Py_UNUSED(ignored))  \\\n    {                                                           \\\n        X(self->win); Py_RETURN_NONE; }\n\n#define Window_NoArg2TupleReturnFunction(X, TYPE, ERGSTR)               \\\n    static PyObject * PyCursesWindow_ ## X                              \\\n    (PyCursesWindowObject *self, PyObject *Py_UNUSED(ignored))          \\\n    {                                                                   \\\n        TYPE arg1, arg2;                                                \\\n        X(self->win,arg1,arg2); return Py_BuildValue(ERGSTR, arg1, arg2); }\n\n#define Window_OneArgNoReturnVoidFunction(X, TYPE, PARSESTR)            \\\n    static PyObject * PyCursesWindow_ ## X                              \\\n    (PyCursesWindowObject *self, PyObject *args)                        \\\n    {                                                                   \\\n        TYPE arg1;                                                      \\\n        if (!PyArg_ParseTuple(args, PARSESTR, &arg1)) return NULL;      \\\n        X(self->win,arg1); Py_RETURN_NONE; }\n\n#define Window_OneArgNoReturnFunction(X, TYPE, PARSESTR)                \\\n    static PyObject * PyCursesWindow_ ## X                              \\\n    (PyCursesWindowObject *self, PyObject *args)                        \\\n    {                                                                   \\\n        TYPE arg1;                                                      \\\n        if (!PyArg_ParseTuple(args,PARSESTR, &arg1)) return NULL;       \\\n        return PyCursesCheckERR(X(self->win, arg1), # X); }\n\n#define Window_TwoArgNoReturnFunction(X, TYPE, PARSESTR)                \\\n    static PyObject * PyCursesWindow_ ## X                              \\\n    (PyCursesWindowObject *self, PyObject *args)                        \\\n    {                                                                   \\\n        TYPE arg1, arg2;                                                \\\n        if (!PyArg_ParseTuple(args,PARSESTR, &arg1, &arg2)) return NULL; \\\n        return PyCursesCheckERR(X(self->win, arg1, arg2), # X); }\n\n/* ------------- WINDOW routines --------------- */\n\nWindow_NoArgNoReturnFunction(untouchwin)\nWindow_NoArgNoReturnFunction(touchwin)\nWindow_NoArgNoReturnFunction(redrawwin)\nWindow_NoArgNoReturnFunction(winsertln)\nWindow_NoArgNoReturnFunction(werase)\nWindow_NoArgNoReturnFunction(wdeleteln)\n\nWindow_NoArgTrueFalseFunction(is_wintouched)\n\nWindow_NoArgNoReturnVoidFunction(wsyncup)\nWindow_NoArgNoReturnVoidFunction(wsyncdown)\nWindow_NoArgNoReturnVoidFunction(wstandend)\nWindow_NoArgNoReturnVoidFunction(wstandout)\nWindow_NoArgNoReturnVoidFunction(wcursyncup)\nWindow_NoArgNoReturnVoidFunction(wclrtoeol)\nWindow_NoArgNoReturnVoidFunction(wclrtobot)\nWindow_NoArgNoReturnVoidFunction(wclear)\n\nWindow_OneArgNoReturnVoidFunction(idcok, int, \"i;True(1) or False(0)\")\n#ifdef HAVE_CURSES_IMMEDOK\nWindow_OneArgNoReturnVoidFunction(immedok, int, \"i;True(1) or False(0)\")\n#endif\nWindow_OneArgNoReturnVoidFunction(wtimeout, int, \"i;delay\")\n\nWindow_NoArg2TupleReturnFunction(getyx, int, \"ii\")\nWindow_NoArg2TupleReturnFunction(getbegyx, int, \"ii\")\nWindow_NoArg2TupleReturnFunction(getmaxyx, int, \"ii\")\nWindow_NoArg2TupleReturnFunction(getparyx, int, \"ii\")\n\nWindow_OneArgNoReturnFunction(clearok, int, \"i;True(1) or False(0)\")\nWindow_OneArgNoReturnFunction(idlok, int, \"i;True(1) or False(0)\")\nWindow_OneArgNoReturnFunction(keypad, int, \"i;True(1) or False(0)\")\nWindow_OneArgNoReturnFunction(leaveok, int, \"i;True(1) or False(0)\")\nWindow_OneArgNoReturnFunction(nodelay, int, \"i;True(1) or False(0)\")\nWindow_OneArgNoReturnFunction(notimeout, int, \"i;True(1) or False(0)\")\nWindow_OneArgNoReturnFunction(scrollok, int, \"i;True(1) or False(0)\")\nWindow_OneArgNoReturnFunction(winsdelln, int, \"i;nlines\")\n#ifdef HAVE_CURSES_SYNCOK\nWindow_OneArgNoReturnFunction(syncok, int, \"i;True(1) or False(0)\")\n#endif\n\nWindow_TwoArgNoReturnFunction(mvwin, int, \"ii;y,x\")\nWindow_TwoArgNoReturnFunction(mvderwin, int, \"ii;y,x\")\nWindow_TwoArgNoReturnFunction(wmove, int, \"ii;y,x\")\n#ifndef STRICT_SYSV_CURSES\nWindow_TwoArgNoReturnFunction(wresize, int, \"ii;lines,columns\")\n#endif\n\n/* Allocation and deallocation of Window Objects */\n\nstatic PyObject *\nPyCursesWindow_New(WINDOW *win, const char *encoding)\n{\n    PyCursesWindowObject *wo;\n\n    if (encoding == NULL) {\n#if defined(MS_WINDOWS)\n        char *buffer[100];\n        UINT cp;\n        cp = GetConsoleOutputCP();\n        if (cp != 0) {\n            PyOS_snprintf(buffer, sizeof(buffer), \"cp%u\", cp);\n            encoding = buffer;\n        }\n#elif defined(CODESET)\n        const char *codeset = nl_langinfo(CODESET);\n        if (codeset != NULL && codeset[0] != 0)\n            encoding = codeset;\n#endif\n        if (encoding == NULL)\n            encoding = \"utf-8\";\n    }\n\n    wo = PyObject_New(PyCursesWindowObject, &PyCursesWindow_Type);\n    if (wo == NULL) return NULL;\n    wo->win = win;\n    wo->encoding = _PyMem_Strdup(encoding);\n    if (wo->encoding == NULL) {\n        Py_DECREF(wo);\n        PyErr_NoMemory();\n        return NULL;\n    }\n    return (PyObject *)wo;\n}\n\nstatic void\nPyCursesWindow_Dealloc(PyCursesWindowObject *wo)\n{\n    if (wo->win != stdscr) delwin(wo->win);\n    if (wo->encoding != NULL)\n        PyMem_Free(wo->encoding);\n    PyObject_Free(wo);\n}\n\n/* Addch, Addstr, Addnstr */\n\n/*[clinic input]\n_curses.window.addch\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n\n    ch: object\n        Character to add.\n\n    [\n    attr: long(c_default=\"A_NORMAL\") = _curses.A_NORMAL\n        Attributes for the character.\n    ]\n    /\n\nPaint the character.\n\nPaint character ch at (y, x) with attributes attr,\noverwriting any character previously painted at that location.\nBy default, the character position and attributes are the\ncurrent settings for the window object.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_addch_impl(PyCursesWindowObject *self, int group_left_1,\n                          int y, int x, PyObject *ch, int group_right_1,\n                          long attr)\n/*[clinic end generated code: output=00f4c37af3378f45 input=95ce131578458196]*/\n{\n    int coordinates_group = group_left_1;\n    int rtn;\n    int type;\n    chtype cch = 0;\n#ifdef HAVE_NCURSESW\n    wchar_t wstr[2];\n    cchar_t wcval;\n#endif\n    const char *funcname;\n\n#ifdef HAVE_NCURSESW\n    type = PyCurses_ConvertToCchar_t(self, ch, &cch, wstr);\n    if (type == 2) {\n        funcname = \"add_wch\";\n        wstr[1] = L'\\0';\n        setcchar(&wcval, wstr, attr, PAIR_NUMBER(attr), NULL);\n        if (coordinates_group)\n            rtn = mvwadd_wch(self->win,y,x, &wcval);\n        else {\n            rtn = wadd_wch(self->win, &wcval);\n        }\n    }\n    else\n#else\n    type = PyCurses_ConvertToCchar_t(self, ch, &cch);\n#endif\n    if (type == 1) {\n        funcname = \"addch\";\n        if (coordinates_group)\n            rtn = mvwaddch(self->win,y,x, cch | (attr_t) attr);\n        else {\n            rtn = waddch(self->win, cch | (attr_t) attr);\n        }\n    }\n    else {\n        return NULL;\n    }\n    return PyCursesCheckERR(rtn, funcname);\n}\n\n/*[clinic input]\n_curses.window.addstr\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n\n    str: object\n        String to add.\n\n    [\n    attr: long\n        Attributes for characters.\n    ]\n    /\n\nPaint the string.\n\nPaint the string str at (y, x) with attributes attr,\noverwriting anything previously on the display.\nBy default, the character position and attributes are the\ncurrent settings for the window object.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_addstr_impl(PyCursesWindowObject *self, int group_left_1,\n                           int y, int x, PyObject *str, int group_right_1,\n                           long attr)\n/*[clinic end generated code: output=65a928ea85ff3115 input=ff6cbb91448a22a3]*/\n{\n    int rtn;\n    int strtype;\n    PyObject *bytesobj = NULL;\n#ifdef HAVE_NCURSESW\n    wchar_t *wstr = NULL;\n#endif\n    attr_t attr_old = A_NORMAL;\n    int use_xy = group_left_1, use_attr = group_right_1;\n    const char *funcname;\n\n#ifdef HAVE_NCURSESW\n    strtype = PyCurses_ConvertToString(self, str, &bytesobj, &wstr);\n#else\n    strtype = PyCurses_ConvertToString(self, str, &bytesobj, NULL);\n#endif\n    if (strtype == 0) {\n        return NULL;\n    }\n    if (use_attr) {\n        attr_old = getattrs(self->win);\n        (void)wattrset(self->win,attr);\n    }\n#ifdef HAVE_NCURSESW\n    if (strtype == 2) {\n        funcname = \"addwstr\";\n        if (use_xy)\n            rtn = mvwaddwstr(self->win,y,x,wstr);\n        else\n            rtn = waddwstr(self->win,wstr);\n        PyMem_Free(wstr);\n    }\n    else\n#endif\n    {\n        const char *str = PyBytes_AS_STRING(bytesobj);\n        funcname = \"addstr\";\n        if (use_xy)\n            rtn = mvwaddstr(self->win,y,x,str);\n        else\n            rtn = waddstr(self->win,str);\n        Py_DECREF(bytesobj);\n    }\n    if (use_attr)\n        (void)wattrset(self->win,attr_old);\n    return PyCursesCheckERR(rtn, funcname);\n}\n\n/*[clinic input]\n_curses.window.addnstr\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n\n    str: object\n        String to add.\n\n    n: int\n        Maximal number of characters.\n\n    [\n    attr: long\n        Attributes for characters.\n    ]\n    /\n\nPaint at most n characters of the string.\n\nPaint at most n characters of the string str at (y, x) with\nattributes attr, overwriting anything previously on the display.\nBy default, the character position and attributes are the\ncurrent settings for the window object.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_addnstr_impl(PyCursesWindowObject *self, int group_left_1,\n                            int y, int x, PyObject *str, int n,\n                            int group_right_1, long attr)\n/*[clinic end generated code: output=6d21cee2ce6876d9 input=72718415c2744a2a]*/\n{\n    int rtn;\n    int strtype;\n    PyObject *bytesobj = NULL;\n#ifdef HAVE_NCURSESW\n    wchar_t *wstr = NULL;\n#endif\n    attr_t attr_old = A_NORMAL;\n    int use_xy = group_left_1, use_attr = group_right_1;\n    const char *funcname;\n\n#ifdef HAVE_NCURSESW\n    strtype = PyCurses_ConvertToString(self, str, &bytesobj, &wstr);\n#else\n    strtype = PyCurses_ConvertToString(self, str, &bytesobj, NULL);\n#endif\n    if (strtype == 0)\n        return NULL;\n\n    if (use_attr) {\n        attr_old = getattrs(self->win);\n        (void)wattrset(self->win,attr);\n    }\n#ifdef HAVE_NCURSESW\n    if (strtype == 2) {\n        funcname = \"addnwstr\";\n        if (use_xy)\n            rtn = mvwaddnwstr(self->win,y,x,wstr,n);\n        else\n            rtn = waddnwstr(self->win,wstr,n);\n        PyMem_Free(wstr);\n    }\n    else\n#endif\n    {\n        const char *str = PyBytes_AS_STRING(bytesobj);\n        funcname = \"addnstr\";\n        if (use_xy)\n            rtn = mvwaddnstr(self->win,y,x,str,n);\n        else\n            rtn = waddnstr(self->win,str,n);\n        Py_DECREF(bytesobj);\n    }\n    if (use_attr)\n        (void)wattrset(self->win,attr_old);\n    return PyCursesCheckERR(rtn, funcname);\n}\n\n/*[clinic input]\n_curses.window.bkgd\n\n    ch: object\n        Background character.\n    attr: long(c_default=\"A_NORMAL\") = _curses.A_NORMAL\n        Background attributes.\n    /\n\nSet the background property of the window.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_bkgd_impl(PyCursesWindowObject *self, PyObject *ch, long attr)\n/*[clinic end generated code: output=058290afb2cf4034 input=634015bcb339283d]*/\n{\n    chtype bkgd;\n\n    if (!PyCurses_ConvertToChtype(self, ch, &bkgd))\n        return NULL;\n\n    return PyCursesCheckERR(wbkgd(self->win, bkgd | attr), \"bkgd\");\n}\n\n/*[clinic input]\n_curses.window.attroff\n\n    attr: long\n    /\n\nRemove attribute attr from the \"background\" set.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_attroff_impl(PyCursesWindowObject *self, long attr)\n/*[clinic end generated code: output=8a2fcd4df682fc64 input=786beedf06a7befe]*/\n{\n    return PyCursesCheckERR(wattroff(self->win, (attr_t)attr), \"attroff\");\n}\n\n/*[clinic input]\n_curses.window.attron\n\n    attr: long\n    /\n\nAdd attribute attr from the \"background\" set.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_attron_impl(PyCursesWindowObject *self, long attr)\n/*[clinic end generated code: output=7afea43b237fa870 input=5a88fba7b1524f32]*/\n{\n    return PyCursesCheckERR(wattron(self->win, (attr_t)attr), \"attron\");\n}\n\n/*[clinic input]\n_curses.window.attrset\n\n    attr: long\n    /\n\nSet the \"background\" set of attributes.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_attrset_impl(PyCursesWindowObject *self, long attr)\n/*[clinic end generated code: output=84e379bff20c0433 input=42e400c0d0154ab5]*/\n{\n    return PyCursesCheckERR(wattrset(self->win, (attr_t)attr), \"attrset\");\n}\n\n/*[clinic input]\n_curses.window.bkgdset\n\n    ch: object\n        Background character.\n    attr: long(c_default=\"A_NORMAL\") = _curses.A_NORMAL\n        Background attributes.\n    /\n\nSet the window's background.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_bkgdset_impl(PyCursesWindowObject *self, PyObject *ch,\n                            long attr)\n/*[clinic end generated code: output=8cb994fc4d7e2496 input=e09c682425c9e45b]*/\n{\n    chtype bkgd;\n\n    if (!PyCurses_ConvertToChtype(self, ch, &bkgd))\n        return NULL;\n\n    wbkgdset(self->win, bkgd | attr);\n    return PyCursesCheckERR(0, \"bkgdset\");\n}\n\n/*[clinic input]\n_curses.window.border\n\n    ls: object(c_default=\"NULL\") = _curses.ACS_VLINE\n        Left side.\n    rs: object(c_default=\"NULL\") = _curses.ACS_VLINE\n        Right side.\n    ts: object(c_default=\"NULL\") = _curses.ACS_HLINE\n        Top side.\n    bs: object(c_default=\"NULL\") = _curses.ACS_HLINE\n        Bottom side.\n    tl: object(c_default=\"NULL\") = _curses.ACS_ULCORNER\n        Upper-left corner.\n    tr: object(c_default=\"NULL\") = _curses.ACS_URCORNER\n        Upper-right corner.\n    bl: object(c_default=\"NULL\") = _curses.ACS_LLCORNER\n        Bottom-left corner.\n    br: object(c_default=\"NULL\") = _curses.ACS_LRCORNER\n        Bottom-right corner.\n    /\n\nDraw a border around the edges of the window.\n\nEach parameter specifies the character to use for a specific part of the\nborder.  The characters can be specified as integers or as one-character\nstrings.  A 0 value for any parameter will cause the default character to be\nused for that parameter.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_border_impl(PyCursesWindowObject *self, PyObject *ls,\n                           PyObject *rs, PyObject *ts, PyObject *bs,\n                           PyObject *tl, PyObject *tr, PyObject *bl,\n                           PyObject *br)\n/*[clinic end generated code: output=670ef38d3d7c2aa3 input=e015f735d67a240b]*/\n{\n    chtype ch[8];\n    int i;\n\n    /* Clear the array of parameters */\n    for(i=0; i<8; i++)\n        ch[i] = 0;\n\n#define CONVERTTOCHTYPE(obj, i) \\\n    if ((obj) != NULL && !PyCurses_ConvertToChtype(self, (obj), &ch[(i)])) \\\n        return NULL;\n\n    CONVERTTOCHTYPE(ls, 0);\n    CONVERTTOCHTYPE(rs, 1);\n    CONVERTTOCHTYPE(ts, 2);\n    CONVERTTOCHTYPE(bs, 3);\n    CONVERTTOCHTYPE(tl, 4);\n    CONVERTTOCHTYPE(tr, 5);\n    CONVERTTOCHTYPE(bl, 6);\n    CONVERTTOCHTYPE(br, 7);\n\n#undef CONVERTTOCHTYPE\n\n    wborder(self->win,\n            ch[0], ch[1], ch[2], ch[3],\n            ch[4], ch[5], ch[6], ch[7]);\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n_curses.window.box\n\n    [\n    verch: object(c_default=\"_PyLong_GetZero()\") = 0\n        Left and right side.\n    horch: object(c_default=\"_PyLong_GetZero()\") = 0\n        Top and bottom side.\n    ]\n    /\n\nDraw a border around the edges of the window.\n\nSimilar to border(), but both ls and rs are verch and both ts and bs are\nhorch.  The default corner characters are always used by this function.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_box_impl(PyCursesWindowObject *self, int group_right_1,\n                        PyObject *verch, PyObject *horch)\n/*[clinic end generated code: output=f3fcb038bb287192 input=f00435f9c8c98f60]*/\n{\n    chtype ch1 = 0, ch2 = 0;\n    if (group_right_1) {\n        if (!PyCurses_ConvertToChtype(self, verch, &ch1)) {\n            return NULL;\n        }\n        if (!PyCurses_ConvertToChtype(self, horch, &ch2)) {\n            return NULL;\n        }\n    }\n    box(self->win,ch1,ch2);\n    Py_RETURN_NONE;\n}\n\n#if defined(HAVE_NCURSES_H) || defined(MVWDELCH_IS_EXPRESSION)\n#define py_mvwdelch mvwdelch\n#else\nint py_mvwdelch(WINDOW *w, int y, int x)\n{\n    mvwdelch(w,y,x);\n    /* On HP/UX, mvwdelch already returns. On other systems,\n       we may well run into this return statement. */\n    return 0;\n}\n#endif\n\n#if defined(HAVE_CURSES_IS_PAD)\n#define py_is_pad(win)      is_pad(win)\n#elif defined(WINDOW_HAS_FLAGS)\n#define py_is_pad(win)      ((win) ? ((win)->_flags & _ISPAD) != 0 : FALSE)\n#endif\n\n/* chgat, added by Fabian Kreutz <fabian.kreutz at gmx.net> */\n#ifdef HAVE_CURSES_WCHGAT\n/*[-clinic input]\n_curses.window.chgat\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n\n    n: int = -1\n        Number of characters.\n\n    attr: long\n        Attributes for characters.\n    /\n\nSet the attributes of characters.\n\nSet the attributes of num characters at the current cursor position, or at\nposition (y, x) if supplied.  If no value of num is given or num = -1, the\nattribute will be set on all the characters to the end of the line.  This\nfunction does not move the cursor.  The changed line will be touched using\nthe touchline() method so that the contents will be redisplayed by the next\nwindow refresh.\n[-clinic start generated code]*/\nstatic PyObject *\nPyCursesWindow_ChgAt(PyCursesWindowObject *self, PyObject *args)\n{\n    int rtn;\n    int x, y;\n    int num = -1;\n    short color;\n    attr_t attr = A_NORMAL;\n    long lattr;\n    int use_xy = FALSE;\n\n    switch (PyTuple_Size(args)) {\n    case 1:\n        if (!PyArg_ParseTuple(args,\"l;attr\", &lattr))\n            return NULL;\n        attr = lattr;\n        break;\n    case 2:\n        if (!PyArg_ParseTuple(args,\"il;n,attr\", &num, &lattr))\n            return NULL;\n        attr = lattr;\n        break;\n    case 3:\n        if (!PyArg_ParseTuple(args,\"iil;int,int,attr\", &y, &x, &lattr))\n            return NULL;\n        attr = lattr;\n        use_xy = TRUE;\n        break;\n    case 4:\n        if (!PyArg_ParseTuple(args,\"iiil;int,int,n,attr\", &y, &x, &num, &lattr))\n            return NULL;\n        attr = lattr;\n        use_xy = TRUE;\n        break;\n    default:\n        PyErr_SetString(PyExc_TypeError, \"chgat requires 1 to 4 arguments\");\n        return NULL;\n    }\n\n    color = (short) PAIR_NUMBER(attr);\n    attr = attr & A_ATTRIBUTES;\n\n    if (use_xy) {\n        rtn = mvwchgat(self->win,y,x,num,attr,color,NULL);\n        touchline(self->win,y,1);\n    } else {\n        getyx(self->win,y,x);\n        rtn = wchgat(self->win,num,attr,color,NULL);\n        touchline(self->win,y,1);\n    }\n    return PyCursesCheckERR(rtn, \"chgat\");\n}\n#endif\n\n/*[clinic input]\n_curses.window.delch\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n    /\n\nDelete any character at (y, x).\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_delch_impl(PyCursesWindowObject *self, int group_right_1,\n                          int y, int x)\n/*[clinic end generated code: output=22e77bb9fa11b461 input=d2f79e630a4fc6d0]*/\n{\n    if (!group_right_1) {\n        return PyCursesCheckERR(wdelch(self->win), \"wdelch\");\n    }\n    else {\n        return PyCursesCheckERR(py_mvwdelch(self->win, y, x), \"mvwdelch\");\n    }\n}\n\n/*[clinic input]\n_curses.window.derwin\n\n    [\n    nlines: int = 0\n        Height.\n    ncols: int = 0\n        Width.\n    ]\n    begin_y: int\n        Top side y-coordinate.\n    begin_x: int\n        Left side x-coordinate.\n    /\n\nCreate a sub-window (window-relative coordinates).\n\nderwin() is the same as calling subwin(), except that begin_y and begin_x\nare relative to the origin of the window, rather than relative to the entire\nscreen.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_derwin_impl(PyCursesWindowObject *self, int group_left_1,\n                           int nlines, int ncols, int begin_y, int begin_x)\n/*[clinic end generated code: output=7924b112d9f70d6e input=966d9481f7f5022e]*/\n{\n    WINDOW *win;\n\n    win = derwin(self->win,nlines,ncols,begin_y,begin_x);\n\n    if (win == NULL) {\n        PyErr_SetString(PyCursesError, catchall_NULL);\n        return NULL;\n    }\n\n    return (PyObject *)PyCursesWindow_New(win, NULL);\n}\n\n/*[clinic input]\n_curses.window.echochar\n\n    ch: object\n        Character to add.\n\n    attr: long(c_default=\"A_NORMAL\") = _curses.A_NORMAL\n        Attributes for the character.\n    /\n\nAdd character ch with attribute attr, and refresh.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_echochar_impl(PyCursesWindowObject *self, PyObject *ch,\n                             long attr)\n/*[clinic end generated code: output=13e7dd875d4b9642 input=e7f34b964e92b156]*/\n{\n    chtype ch_;\n\n    if (!PyCurses_ConvertToChtype(self, ch, &ch_))\n        return NULL;\n\n#ifdef py_is_pad\n    if (py_is_pad(self->win)) {\n        return PyCursesCheckERR(pechochar(self->win, ch_ | (attr_t)attr),\n                                \"echochar\");\n    }\n    else\n#endif\n        return PyCursesCheckERR(wechochar(self->win, ch_ | (attr_t)attr),\n                                \"echochar\");\n}\n\n#ifdef NCURSES_MOUSE_VERSION\n/*[clinic input]\n_curses.window.enclose\n\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    /\n\nReturn True if the screen-relative coordinates are enclosed by the window.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_enclose_impl(PyCursesWindowObject *self, int y, int x)\n/*[clinic end generated code: output=8679beef50502648 input=4fd3355d723f7bc9]*/\n{\n    return PyBool_FromLong(wenclose(self->win, y, x));\n}\n#endif\n\n/*[clinic input]\n_curses.window.getbkgd -> long\n\nReturn the window's current background character/attribute pair.\n[clinic start generated code]*/\n\nstatic long\n_curses_window_getbkgd_impl(PyCursesWindowObject *self)\n/*[clinic end generated code: output=c52b25dc16b215c3 input=a69db882fa35426c]*/\n{\n    return (long) getbkgd(self->win);\n}\n\n/*[clinic input]\n_curses.window.getch -> int\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n    /\n\nGet a character code from terminal keyboard.\n\nThe integer returned does not have to be in ASCII range: function keys,\nkeypad keys and so on return numbers higher than 256.  In no-delay mode, -1\nis returned if there is no input, else getch() waits until a key is pressed.\n[clinic start generated code]*/\n\nstatic int\n_curses_window_getch_impl(PyCursesWindowObject *self, int group_right_1,\n                          int y, int x)\n/*[clinic end generated code: output=980aa6af0c0ca387 input=bb24ebfb379f991f]*/\n{\n    int rtn;\n\n    Py_BEGIN_ALLOW_THREADS\n    if (!group_right_1) {\n        rtn = wgetch(self->win);\n    }\n    else {\n        rtn = mvwgetch(self->win, y, x);\n    }\n    Py_END_ALLOW_THREADS\n\n    return rtn;\n}\n\n/*[clinic input]\n_curses.window.getkey\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n    /\n\nGet a character (string) from terminal keyboard.\n\nReturning a string instead of an integer, as getch() does.  Function keys,\nkeypad keys and other special keys return a multibyte string containing the\nkey name.  In no-delay mode, an exception is raised if there is no input.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_getkey_impl(PyCursesWindowObject *self, int group_right_1,\n                           int y, int x)\n/*[clinic end generated code: output=8490a182db46b10f input=be2dee34f5cf57f8]*/\n{\n    int rtn;\n\n    Py_BEGIN_ALLOW_THREADS\n    if (!group_right_1) {\n        rtn = wgetch(self->win);\n    }\n    else {\n        rtn = mvwgetch(self->win, y, x);\n    }\n    Py_END_ALLOW_THREADS\n\n    if (rtn == ERR) {\n        /* getch() returns ERR in nodelay mode */\n        PyErr_CheckSignals();\n        if (!PyErr_Occurred())\n            PyErr_SetString(PyCursesError, \"no input\");\n        return NULL;\n    } else if (rtn <= 255) {\n#ifdef NCURSES_VERSION_MAJOR\n#if NCURSES_VERSION_MAJOR*100+NCURSES_VERSION_MINOR <= 507\n        /* Work around a bug in ncurses 5.7 and earlier */\n        if (rtn < 0) {\n            rtn += 256;\n        }\n#endif\n#endif\n        return PyUnicode_FromOrdinal(rtn);\n    } else {\n        const char *knp = keyname(rtn);\n        return PyUnicode_FromString((knp == NULL) ? \"\" : knp);\n    }\n}\n\n#ifdef HAVE_NCURSESW\n/*[clinic input]\n_curses.window.get_wch\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n    /\n\nGet a wide character from terminal keyboard.\n\nReturn a character for most keys, or an integer for function keys,\nkeypad keys, and other special keys.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_get_wch_impl(PyCursesWindowObject *self, int group_right_1,\n                            int y, int x)\n/*[clinic end generated code: output=9f4f86e91fe50ef3 input=dd7e5367fb49dc48]*/\n{\n    int ct;\n    wint_t rtn;\n\n    Py_BEGIN_ALLOW_THREADS\n    if (!group_right_1) {\n        ct = wget_wch(self->win ,&rtn);\n    }\n    else {\n        ct = mvwget_wch(self->win, y, x, &rtn);\n    }\n    Py_END_ALLOW_THREADS\n\n    if (ct == ERR) {\n        if (PyErr_CheckSignals())\n            return NULL;\n\n        /* get_wch() returns ERR in nodelay mode */\n        PyErr_SetString(PyCursesError, \"no input\");\n        return NULL;\n    }\n    if (ct == KEY_CODE_YES)\n        return PyLong_FromLong(rtn);\n    else\n        return PyUnicode_FromOrdinal(rtn);\n}\n#endif\n\n/*[-clinic input]\n_curses.window.getstr\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n    n: int = 1023\n        Maximal number of characters.\n    /\n\nRead a string from the user, with primitive line editing capacity.\n[-clinic start generated code]*/\n\nstatic PyObject *\nPyCursesWindow_GetStr(PyCursesWindowObject *self, PyObject *args)\n{\n    int x, y, n;\n    char rtn[1024]; /* This should be big enough.. I hope */\n    int rtn2;\n\n    switch (PyTuple_Size(args)) {\n    case 0:\n        Py_BEGIN_ALLOW_THREADS\n        rtn2 = wgetnstr(self->win,rtn, 1023);\n        Py_END_ALLOW_THREADS\n        break;\n    case 1:\n        if (!PyArg_ParseTuple(args,\"i;n\", &n))\n            return NULL;\n        if (n < 0) {\n            PyErr_SetString(PyExc_ValueError, \"'n' must be nonnegative\");\n            return NULL;\n        }\n        Py_BEGIN_ALLOW_THREADS\n        rtn2 = wgetnstr(self->win, rtn, Py_MIN(n, 1023));\n        Py_END_ALLOW_THREADS\n        break;\n    case 2:\n        if (!PyArg_ParseTuple(args,\"ii;y,x\",&y,&x))\n            return NULL;\n        Py_BEGIN_ALLOW_THREADS\n#ifdef STRICT_SYSV_CURSES\n        rtn2 = wmove(self->win,y,x)==ERR ? ERR : wgetnstr(self->win, rtn, 1023);\n#else\n        rtn2 = mvwgetnstr(self->win,y,x,rtn, 1023);\n#endif\n        Py_END_ALLOW_THREADS\n        break;\n    case 3:\n        if (!PyArg_ParseTuple(args,\"iii;y,x,n\", &y, &x, &n))\n            return NULL;\n        if (n < 0) {\n            PyErr_SetString(PyExc_ValueError, \"'n' must be nonnegative\");\n            return NULL;\n        }\n#ifdef STRICT_SYSV_CURSES\n        Py_BEGIN_ALLOW_THREADS\n        rtn2 = wmove(self->win,y,x)==ERR ? ERR :\n        wgetnstr(self->win, rtn, Py_MIN(n, 1023));\n        Py_END_ALLOW_THREADS\n#else\n        Py_BEGIN_ALLOW_THREADS\n        rtn2 = mvwgetnstr(self->win, y, x, rtn, Py_MIN(n, 1023));\n        Py_END_ALLOW_THREADS\n#endif\n        break;\n    default:\n        PyErr_SetString(PyExc_TypeError, \"getstr requires 0 to 3 arguments\");\n        return NULL;\n    }\n    if (rtn2 == ERR)\n        rtn[0] = 0;\n    return PyBytes_FromString(rtn);\n}\n\n/*[clinic input]\n_curses.window.hline\n\n    [\n    y: int\n        Starting Y-coordinate.\n    x: int\n        Starting X-coordinate.\n    ]\n\n    ch: object\n        Character to draw.\n    n: int\n        Line length.\n\n    [\n    attr: long(c_default=\"A_NORMAL\") = _curses.A_NORMAL\n        Attributes for the characters.\n    ]\n    /\n\nDisplay a horizontal line.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_hline_impl(PyCursesWindowObject *self, int group_left_1,\n                          int y, int x, PyObject *ch, int n,\n                          int group_right_1, long attr)\n/*[clinic end generated code: output=c00d489d61fc9eef input=81a4dea47268163e]*/\n{\n    chtype ch_;\n\n    if (!PyCurses_ConvertToChtype(self, ch, &ch_))\n        return NULL;\n    if (group_left_1) {\n        if (wmove(self->win, y, x) == ERR) {\n            return PyCursesCheckERR(ERR, \"wmove\");\n        }\n    }\n    return PyCursesCheckERR(whline(self->win, ch_ | (attr_t)attr, n), \"hline\");\n}\n\n/*[clinic input]\n_curses.window.insch\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n\n    ch: object\n        Character to insert.\n\n    [\n    attr: long(c_default=\"A_NORMAL\") = _curses.A_NORMAL\n        Attributes for the character.\n    ]\n    /\n\nInsert a character before the current or specified position.\n\nAll characters to the right of the cursor are shifted one position right, with\nthe rightmost characters on the line being lost.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_insch_impl(PyCursesWindowObject *self, int group_left_1,\n                          int y, int x, PyObject *ch, int group_right_1,\n                          long attr)\n/*[clinic end generated code: output=ade8cfe3a3bf3e34 input=336342756ee19812]*/\n{\n    int rtn;\n    chtype ch_ = 0;\n\n    if (!PyCurses_ConvertToChtype(self, ch, &ch_))\n        return NULL;\n\n    if (!group_left_1) {\n        rtn = winsch(self->win, ch_ | (attr_t)attr);\n    }\n    else {\n        rtn = mvwinsch(self->win, y, x, ch_ | (attr_t)attr);\n    }\n\n    return PyCursesCheckERR(rtn, \"insch\");\n}\n\n/*[clinic input]\n_curses.window.inch -> unsigned_long\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n    /\n\nReturn the character at the given position in the window.\n\nThe bottom 8 bits are the character proper, and upper bits are the attributes.\n[clinic start generated code]*/\n\nstatic unsigned long\n_curses_window_inch_impl(PyCursesWindowObject *self, int group_right_1,\n                         int y, int x)\n/*[clinic end generated code: output=6c4719fe978fe86a input=fac23ee11e3b3a66]*/\n{\n    unsigned long rtn;\n\n    if (!group_right_1) {\n        rtn = winch(self->win);\n    }\n    else {\n        rtn = mvwinch(self->win, y, x);\n    }\n\n    return rtn;\n}\n\n/*[-clinic input]\n_curses.window.instr\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n    n: int = 1023\n        Maximal number of characters.\n    /\n\nReturn a string of characters, extracted from the window.\n\nReturn a string of characters, extracted from the window starting at the\ncurrent cursor position, or at y, x if specified.  Attributes are stripped\nfrom the characters.  If n is specified, instr() returns a string at most\nn characters long (exclusive of the trailing NUL).\n[-clinic start generated code]*/\nstatic PyObject *\nPyCursesWindow_InStr(PyCursesWindowObject *self, PyObject *args)\n{\n    int x, y, n;\n    char rtn[1024]; /* This should be big enough.. I hope */\n    int rtn2;\n\n    switch (PyTuple_Size(args)) {\n    case 0:\n        rtn2 = winnstr(self->win,rtn, 1023);\n        break;\n    case 1:\n        if (!PyArg_ParseTuple(args,\"i;n\", &n))\n            return NULL;\n        if (n < 0) {\n            PyErr_SetString(PyExc_ValueError, \"'n' must be nonnegative\");\n            return NULL;\n        }\n        rtn2 = winnstr(self->win, rtn, Py_MIN(n, 1023));\n        break;\n    case 2:\n        if (!PyArg_ParseTuple(args,\"ii;y,x\",&y,&x))\n            return NULL;\n        rtn2 = mvwinnstr(self->win,y,x,rtn,1023);\n        break;\n    case 3:\n        if (!PyArg_ParseTuple(args, \"iii;y,x,n\", &y, &x, &n))\n            return NULL;\n        if (n < 0) {\n            PyErr_SetString(PyExc_ValueError, \"'n' must be nonnegative\");\n            return NULL;\n        }\n        rtn2 = mvwinnstr(self->win, y, x, rtn, Py_MIN(n,1023));\n        break;\n    default:\n        PyErr_SetString(PyExc_TypeError, \"instr requires 0 or 3 arguments\");\n        return NULL;\n    }\n    if (rtn2 == ERR)\n        rtn[0] = 0;\n    return PyBytes_FromString(rtn);\n}\n\n/*[clinic input]\n_curses.window.insstr\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n\n    str: object\n        String to insert.\n\n    [\n    attr: long\n        Attributes for characters.\n    ]\n    /\n\nInsert the string before the current or specified position.\n\nInsert a character string (as many characters as will fit on the line)\nbefore the character under the cursor.  All characters to the right of\nthe cursor are shifted right, with the rightmost characters on the line\nbeing lost.  The cursor position does not change (after moving to y, x,\nif specified).\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_insstr_impl(PyCursesWindowObject *self, int group_left_1,\n                           int y, int x, PyObject *str, int group_right_1,\n                           long attr)\n/*[clinic end generated code: output=c259a5265ad0b777 input=6827cddc6340a7f3]*/\n{\n    int rtn;\n    int strtype;\n    PyObject *bytesobj = NULL;\n#ifdef HAVE_NCURSESW\n    wchar_t *wstr = NULL;\n#endif\n    attr_t attr_old = A_NORMAL;\n    int use_xy = group_left_1, use_attr = group_right_1;\n    const char *funcname;\n\n#ifdef HAVE_NCURSESW\n    strtype = PyCurses_ConvertToString(self, str, &bytesobj, &wstr);\n#else\n    strtype = PyCurses_ConvertToString(self, str, &bytesobj, NULL);\n#endif\n    if (strtype == 0)\n        return NULL;\n\n    if (use_attr) {\n        attr_old = getattrs(self->win);\n        (void)wattrset(self->win, (attr_t)attr);\n    }\n#ifdef HAVE_NCURSESW\n    if (strtype == 2) {\n        funcname = \"inswstr\";\n        if (use_xy)\n            rtn = mvwins_wstr(self->win,y,x,wstr);\n        else\n            rtn = wins_wstr(self->win,wstr);\n        PyMem_Free(wstr);\n    }\n    else\n#endif\n    {\n        const char *str = PyBytes_AS_STRING(bytesobj);\n        funcname = \"insstr\";\n        if (use_xy)\n            rtn = mvwinsstr(self->win,y,x,str);\n        else\n            rtn = winsstr(self->win,str);\n        Py_DECREF(bytesobj);\n    }\n    if (use_attr)\n        (void)wattrset(self->win,attr_old);\n    return PyCursesCheckERR(rtn, funcname);\n}\n\n/*[clinic input]\n_curses.window.insnstr\n\n    [\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    ]\n\n    str: object\n        String to insert.\n\n    n: int\n        Maximal number of characters.\n\n    [\n    attr: long\n        Attributes for characters.\n    ]\n    /\n\nInsert at most n characters of the string.\n\nInsert a character string (as many characters as will fit on the line)\nbefore the character under the cursor, up to n characters.  If n is zero\nor negative, the entire string is inserted.  All characters to the right\nof the cursor are shifted right, with the rightmost characters on the line\nbeing lost.  The cursor position does not change (after moving to y, x, if\nspecified).\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_insnstr_impl(PyCursesWindowObject *self, int group_left_1,\n                            int y, int x, PyObject *str, int n,\n                            int group_right_1, long attr)\n/*[clinic end generated code: output=971a32ea6328ec8b input=70fa0cd543901a4c]*/\n{\n    int rtn;\n    int strtype;\n    PyObject *bytesobj = NULL;\n#ifdef HAVE_NCURSESW\n    wchar_t *wstr = NULL;\n#endif\n    attr_t attr_old = A_NORMAL;\n    int use_xy = group_left_1, use_attr = group_right_1;\n    const char *funcname;\n\n#ifdef HAVE_NCURSESW\n    strtype = PyCurses_ConvertToString(self, str, &bytesobj, &wstr);\n#else\n    strtype = PyCurses_ConvertToString(self, str, &bytesobj, NULL);\n#endif\n    if (strtype == 0)\n        return NULL;\n\n    if (use_attr) {\n        attr_old = getattrs(self->win);\n        (void)wattrset(self->win, (attr_t)attr);\n    }\n#ifdef HAVE_NCURSESW\n    if (strtype == 2) {\n        funcname = \"insn_wstr\";\n        if (use_xy)\n            rtn = mvwins_nwstr(self->win,y,x,wstr,n);\n        else\n            rtn = wins_nwstr(self->win,wstr,n);\n        PyMem_Free(wstr);\n    }\n    else\n#endif\n    {\n        const char *str = PyBytes_AS_STRING(bytesobj);\n        funcname = \"insnstr\";\n        if (use_xy)\n            rtn = mvwinsnstr(self->win,y,x,str,n);\n        else\n            rtn = winsnstr(self->win,str,n);\n        Py_DECREF(bytesobj);\n    }\n    if (use_attr)\n        (void)wattrset(self->win,attr_old);\n    return PyCursesCheckERR(rtn, funcname);\n}\n\n/*[clinic input]\n_curses.window.is_linetouched\n\n    line: int\n        Line number.\n    /\n\nReturn True if the specified line was modified, otherwise return False.\n\nRaise a curses.error exception if line is not valid for the given window.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_is_linetouched_impl(PyCursesWindowObject *self, int line)\n/*[clinic end generated code: output=ad4a4edfee2db08c input=a7be0c189f243914]*/\n{\n    int erg;\n    erg = is_linetouched(self->win, line);\n    if (erg == ERR) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"is_linetouched: line number outside of boundaries\");\n        return NULL;\n    }\n    return PyBool_FromLong(erg);\n}\n\n#ifdef py_is_pad\n/*[clinic input]\n_curses.window.noutrefresh\n\n    [\n    pminrow: int\n    pmincol: int\n    sminrow: int\n    smincol: int\n    smaxrow: int\n    smaxcol: int\n    ]\n    /\n\nMark for refresh but wait.\n\nThis function updates the data structure representing the desired state of the\nwindow, but does not force an update of the physical screen.  To accomplish\nthat, call doupdate().\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_noutrefresh_impl(PyCursesWindowObject *self,\n                                int group_right_1, int pminrow, int pmincol,\n                                int sminrow, int smincol, int smaxrow,\n                                int smaxcol)\n/*[clinic end generated code: output=809a1f3c6a03e23e input=3e56898388cd739e]*/\n#else\n/*[clinic input]\n_curses.window.noutrefresh\n\nMark for refresh but wait.\n\nThis function updates the data structure representing the desired state of the\nwindow, but does not force an update of the physical screen.  To accomplish\nthat, call doupdate().\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_noutrefresh_impl(PyCursesWindowObject *self)\n/*[clinic end generated code: output=6ef6dec666643fee input=876902e3fa431dbd]*/\n#endif\n{\n    int rtn;\n\n#ifdef py_is_pad\n    if (py_is_pad(self->win)) {\n        if (!group_right_1) {\n            PyErr_SetString(PyCursesError,\n                            \"noutrefresh() called for a pad \"\n                            \"requires 6 arguments\");\n            return NULL;\n        }\n        Py_BEGIN_ALLOW_THREADS\n        rtn = pnoutrefresh(self->win, pminrow, pmincol,\n                           sminrow, smincol, smaxrow, smaxcol);\n        Py_END_ALLOW_THREADS\n        return PyCursesCheckERR(rtn, \"pnoutrefresh\");\n    }\n    if (group_right_1) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"noutrefresh() takes no arguments (6 given)\");\n        return NULL;\n    }\n#endif\n    Py_BEGIN_ALLOW_THREADS\n    rtn = wnoutrefresh(self->win);\n    Py_END_ALLOW_THREADS\n    return PyCursesCheckERR(rtn, \"wnoutrefresh\");\n}\n\n/*[clinic input]\n_curses.window.overlay\n\n    destwin: object(type=\"PyCursesWindowObject *\", subclass_of=\"&PyCursesWindow_Type\")\n\n    [\n    sminrow: int\n    smincol: int\n    dminrow: int\n    dmincol: int\n    dmaxrow: int\n    dmaxcol: int\n    ]\n    /\n\nOverlay the window on top of destwin.\n\nThe windows need not be the same size, only the overlapping region is copied.\nThis copy is non-destructive, which means that the current background\ncharacter does not overwrite the old contents of destwin.\n\nTo get fine-grained control over the copied region, the second form of\noverlay() can be used.  sminrow and smincol are the upper-left coordinates\nof the source window, and the other variables mark a rectangle in the\ndestination window.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_overlay_impl(PyCursesWindowObject *self,\n                            PyCursesWindowObject *destwin, int group_right_1,\n                            int sminrow, int smincol, int dminrow,\n                            int dmincol, int dmaxrow, int dmaxcol)\n/*[clinic end generated code: output=82bb2c4cb443ca58 input=7edd23ad22cc1984]*/\n{\n    int rtn;\n\n    if (group_right_1) {\n        rtn = copywin(self->win, destwin->win, sminrow, smincol,\n                      dminrow, dmincol, dmaxrow, dmaxcol, TRUE);\n        return PyCursesCheckERR(rtn, \"copywin\");\n    }\n    else {\n        rtn = overlay(self->win, destwin->win);\n        return PyCursesCheckERR(rtn, \"overlay\");\n    }\n}\n\n/*[clinic input]\n_curses.window.overwrite\n\n    destwin: object(type=\"PyCursesWindowObject *\", subclass_of=\"&PyCursesWindow_Type\")\n\n    [\n    sminrow: int\n    smincol: int\n    dminrow: int\n    dmincol: int\n    dmaxrow: int\n    dmaxcol: int\n    ]\n    /\n\nOverwrite the window on top of destwin.\n\nThe windows need not be the same size, in which case only the overlapping\nregion is copied.  This copy is destructive, which means that the current\nbackground character overwrites the old contents of destwin.\n\nTo get fine-grained control over the copied region, the second form of\noverwrite() can be used. sminrow and smincol are the upper-left coordinates\nof the source window, the other variables mark a rectangle in the destination\nwindow.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_overwrite_impl(PyCursesWindowObject *self,\n                              PyCursesWindowObject *destwin,\n                              int group_right_1, int sminrow, int smincol,\n                              int dminrow, int dmincol, int dmaxrow,\n                              int dmaxcol)\n/*[clinic end generated code: output=12ae007d1681be28 input=ea5de1b35cd948e0]*/\n{\n    int rtn;\n\n    if (group_right_1) {\n        rtn = copywin(self->win, destwin->win, sminrow, smincol,\n                      dminrow, dmincol, dmaxrow, dmaxcol, FALSE);\n        return PyCursesCheckERR(rtn, \"copywin\");\n    }\n    else {\n        rtn = overwrite(self->win, destwin->win);\n        return PyCursesCheckERR(rtn, \"overwrite\");\n    }\n}\n\n/*[clinic input]\n_curses.window.putwin\n\n    file: object\n    /\n\nWrite all data associated with the window into the provided file object.\n\nThis information can be later retrieved using the getwin() function.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_putwin(PyCursesWindowObject *self, PyObject *file)\n/*[clinic end generated code: output=3a25e2a5e7a040ac input=0608648e09c8ea0a]*/\n{\n    /* We have to simulate this by writing to a temporary FILE*,\n       then reading back, then writing to the argument file. */\n    FILE *fp;\n    PyObject *res = NULL;\n\n    fp = tmpfile();\n    if (fp == NULL)\n        return PyErr_SetFromErrno(PyExc_OSError);\n    if (_Py_set_inheritable(fileno(fp), 0, NULL) < 0)\n        goto exit;\n    res = PyCursesCheckERR(putwin(self->win, fp), \"putwin\");\n    if (res == NULL)\n        goto exit;\n    fseek(fp, 0, 0);\n    while (1) {\n        char buf[BUFSIZ];\n        Py_ssize_t n = fread(buf, 1, BUFSIZ, fp);\n\n        if (n <= 0)\n            break;\n        Py_DECREF(res);\n        res = PyObject_CallMethod(file, \"write\", \"y#\", buf, n);\n        if (res == NULL)\n            break;\n    }\n\nexit:\n    fclose(fp);\n    return res;\n}\n\n/*[clinic input]\n_curses.window.redrawln\n\n    beg: int\n        Starting line number.\n    num: int\n        The number of lines.\n    /\n\nMark the specified lines corrupted.\n\nThey should be completely redrawn on the next refresh() call.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_redrawln_impl(PyCursesWindowObject *self, int beg, int num)\n/*[clinic end generated code: output=ea216e334f9ce1b4 input=152155e258a77a7a]*/\n{\n    return PyCursesCheckERR(wredrawln(self->win,beg,num), \"redrawln\");\n}\n\n/*[clinic input]\n_curses.window.refresh\n\n    [\n    pminrow: int\n    pmincol: int\n    sminrow: int\n    smincol: int\n    smaxrow: int\n    smaxcol: int\n    ]\n    /\n\nUpdate the display immediately.\n\nSynchronize actual screen with previous drawing/deleting methods.\nThe 6 optional arguments can only be specified when the window is a pad\ncreated with newpad().  The additional parameters are needed to indicate\nwhat part of the pad and screen are involved.  pminrow and pmincol specify\nthe upper left-hand corner of the rectangle to be displayed in the pad.\nsminrow, smincol, smaxrow, and smaxcol specify the edges of the rectangle to\nbe displayed on the screen.  The lower right-hand corner of the rectangle to\nbe displayed in the pad is calculated from the screen coordinates, since the\nrectangles must be the same size.  Both rectangles must be entirely contained\nwithin their respective structures.  Negative values of pminrow, pmincol,\nsminrow, or smincol are treated as if they were zero.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_refresh_impl(PyCursesWindowObject *self, int group_right_1,\n                            int pminrow, int pmincol, int sminrow,\n                            int smincol, int smaxrow, int smaxcol)\n/*[clinic end generated code: output=42199543115e6e63 input=95e01cb5ffc635d0]*/\n{\n    int rtn;\n\n#ifdef py_is_pad\n    if (py_is_pad(self->win)) {\n        if (!group_right_1) {\n            PyErr_SetString(PyCursesError,\n                            \"refresh() for a pad requires 6 arguments\");\n            return NULL;\n        }\n        Py_BEGIN_ALLOW_THREADS\n        rtn = prefresh(self->win, pminrow, pmincol,\n                       sminrow, smincol, smaxrow, smaxcol);\n        Py_END_ALLOW_THREADS\n        return PyCursesCheckERR(rtn, \"prefresh\");\n    }\n#endif\n    if (group_right_1) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"refresh() takes no arguments (6 given)\");\n        return NULL;\n    }\n    Py_BEGIN_ALLOW_THREADS\n    rtn = wrefresh(self->win);\n    Py_END_ALLOW_THREADS\n    return PyCursesCheckERR(rtn, \"prefresh\");\n}\n\n/*[clinic input]\n_curses.window.setscrreg\n\n    top: int\n        First line number.\n    bottom: int\n        Last line number.\n    /\n\nDefine a software scrolling region.\n\nAll scrolling actions will take place in this region.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_setscrreg_impl(PyCursesWindowObject *self, int top,\n                              int bottom)\n/*[clinic end generated code: output=486ab5db218d2b1a input=1b517b986838bf0e]*/\n{\n    return PyCursesCheckERR(wsetscrreg(self->win, top, bottom), \"wsetscrreg\");\n}\n\n/*[clinic input]\n_curses.window.subwin\n\n    [\n    nlines: int = 0\n        Height.\n    ncols: int = 0\n        Width.\n    ]\n    begin_y: int\n        Top side y-coordinate.\n    begin_x: int\n        Left side x-coordinate.\n    /\n\nCreate a sub-window (screen-relative coordinates).\n\nBy default, the sub-window will extend from the specified position to the\nlower right corner of the window.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_subwin_impl(PyCursesWindowObject *self, int group_left_1,\n                           int nlines, int ncols, int begin_y, int begin_x)\n/*[clinic end generated code: output=93e898afc348f59a input=2129fa47fd57721c]*/\n{\n    WINDOW *win;\n\n    /* printf(\"Subwin: %i %i %i %i   \\n\", nlines, ncols, begin_y, begin_x); */\n#ifdef py_is_pad\n    if (py_is_pad(self->win)) {\n        win = subpad(self->win, nlines, ncols, begin_y, begin_x);\n    }\n    else\n#endif\n        win = subwin(self->win, nlines, ncols, begin_y, begin_x);\n\n    if (win == NULL) {\n        PyErr_SetString(PyCursesError, catchall_NULL);\n        return NULL;\n    }\n\n    return (PyObject *)PyCursesWindow_New(win, self->encoding);\n}\n\n/*[clinic input]\n_curses.window.scroll\n\n    [\n    lines: int = 1\n        Number of lines to scroll.\n    ]\n    /\n\nScroll the screen or scrolling region.\n\nScroll upward if the argument is positive and downward if it is negative.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_scroll_impl(PyCursesWindowObject *self, int group_right_1,\n                           int lines)\n/*[clinic end generated code: output=4541a8a11852d360 input=c969ca0cfabbdbec]*/\n{\n    if (!group_right_1) {\n        return PyCursesCheckERR(scroll(self->win), \"scroll\");\n    }\n    else {\n        return PyCursesCheckERR(wscrl(self->win, lines), \"scroll\");\n    }\n}\n\n/*[clinic input]\n_curses.window.touchline\n\n    start: int\n    count: int\n    [\n    changed: bool = True\n    ]\n    /\n\nPretend count lines have been changed, starting with line start.\n\nIf changed is supplied, it specifies whether the affected lines are marked\nas having been changed (changed=True) or unchanged (changed=False).\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_touchline_impl(PyCursesWindowObject *self, int start,\n                              int count, int group_right_1, int changed)\n/*[clinic end generated code: output=65d05b3f7438c61d input=a98aa4f79b6be845]*/\n{\n    if (!group_right_1) {\n        return PyCursesCheckERR(touchline(self->win, start, count), \"touchline\");\n    }\n    else {\n        return PyCursesCheckERR(wtouchln(self->win, start, count, changed), \"touchline\");\n    }\n}\n\n/*[clinic input]\n_curses.window.vline\n\n    [\n    y: int\n        Starting Y-coordinate.\n    x: int\n        Starting X-coordinate.\n    ]\n\n    ch: object\n        Character to draw.\n    n: int\n        Line length.\n\n    [\n    attr: long(c_default=\"A_NORMAL\") = _curses.A_NORMAL\n        Attributes for the character.\n    ]\n    /\n\nDisplay a vertical line.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_window_vline_impl(PyCursesWindowObject *self, int group_left_1,\n                          int y, int x, PyObject *ch, int n,\n                          int group_right_1, long attr)\n/*[clinic end generated code: output=287ad1cc8982217f input=a6f2dc86a4648b32]*/\n{\n    chtype ch_;\n\n    if (!PyCurses_ConvertToChtype(self, ch, &ch_))\n        return NULL;\n    if (group_left_1) {\n        if (wmove(self->win, y, x) == ERR)\n            return PyCursesCheckERR(ERR, \"wmove\");\n    }\n    return PyCursesCheckERR(wvline(self->win, ch_ | (attr_t)attr, n), \"vline\");\n}\n\nstatic PyObject *\nPyCursesWindow_get_encoding(PyCursesWindowObject *self, void *closure)\n{\n    return PyUnicode_FromString(self->encoding);\n}\n\nstatic int\nPyCursesWindow_set_encoding(PyCursesWindowObject *self, PyObject *value, void *Py_UNUSED(ignored))\n{\n    PyObject *ascii;\n    char *encoding;\n\n    /* It is illegal to del win.encoding */\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"encoding may not be deleted\");\n        return -1;\n    }\n\n    if (!PyUnicode_Check(value)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"setting encoding to a non-string\");\n        return -1;\n    }\n    ascii = PyUnicode_AsASCIIString(value);\n    if (ascii == NULL)\n        return -1;\n    encoding = _PyMem_Strdup(PyBytes_AS_STRING(ascii));\n    Py_DECREF(ascii);\n    if (encoding == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    PyMem_Free(self->encoding);\n    self->encoding = encoding;\n    return 0;\n}\n\n#include \"clinic/_cursesmodule.c.h\"\n\nstatic PyMethodDef PyCursesWindow_Methods[] = {\n    _CURSES_WINDOW_ADDCH_METHODDEF\n    _CURSES_WINDOW_ADDNSTR_METHODDEF\n    _CURSES_WINDOW_ADDSTR_METHODDEF\n    _CURSES_WINDOW_ATTROFF_METHODDEF\n    _CURSES_WINDOW_ATTRON_METHODDEF\n    _CURSES_WINDOW_ATTRSET_METHODDEF\n    _CURSES_WINDOW_BKGD_METHODDEF\n#ifdef HAVE_CURSES_WCHGAT\n    {\"chgat\",           (PyCFunction)PyCursesWindow_ChgAt, METH_VARARGS},\n#endif\n    _CURSES_WINDOW_BKGDSET_METHODDEF\n    _CURSES_WINDOW_BORDER_METHODDEF\n    _CURSES_WINDOW_BOX_METHODDEF\n    {\"clear\",           (PyCFunction)PyCursesWindow_wclear, METH_NOARGS},\n    {\"clearok\",         (PyCFunction)PyCursesWindow_clearok, METH_VARARGS},\n    {\"clrtobot\",        (PyCFunction)PyCursesWindow_wclrtobot, METH_NOARGS},\n    {\"clrtoeol\",        (PyCFunction)PyCursesWindow_wclrtoeol, METH_NOARGS},\n    {\"cursyncup\",       (PyCFunction)PyCursesWindow_wcursyncup, METH_NOARGS},\n    _CURSES_WINDOW_DELCH_METHODDEF\n    {\"deleteln\",        (PyCFunction)PyCursesWindow_wdeleteln, METH_NOARGS},\n    _CURSES_WINDOW_DERWIN_METHODDEF\n    _CURSES_WINDOW_ECHOCHAR_METHODDEF\n    _CURSES_WINDOW_ENCLOSE_METHODDEF\n    {\"erase\",           (PyCFunction)PyCursesWindow_werase, METH_NOARGS},\n    {\"getbegyx\",        (PyCFunction)PyCursesWindow_getbegyx, METH_NOARGS},\n    _CURSES_WINDOW_GETBKGD_METHODDEF\n    _CURSES_WINDOW_GETCH_METHODDEF\n    _CURSES_WINDOW_GETKEY_METHODDEF\n    _CURSES_WINDOW_GET_WCH_METHODDEF\n    {\"getmaxyx\",        (PyCFunction)PyCursesWindow_getmaxyx, METH_NOARGS},\n    {\"getparyx\",        (PyCFunction)PyCursesWindow_getparyx, METH_NOARGS},\n    {\"getstr\",          (PyCFunction)PyCursesWindow_GetStr, METH_VARARGS},\n    {\"getyx\",           (PyCFunction)PyCursesWindow_getyx, METH_NOARGS},\n    _CURSES_WINDOW_HLINE_METHODDEF\n    {\"idcok\",           (PyCFunction)PyCursesWindow_idcok, METH_VARARGS},\n    {\"idlok\",           (PyCFunction)PyCursesWindow_idlok, METH_VARARGS},\n#ifdef HAVE_CURSES_IMMEDOK\n    {\"immedok\",         (PyCFunction)PyCursesWindow_immedok, METH_VARARGS},\n#endif\n    _CURSES_WINDOW_INCH_METHODDEF\n    _CURSES_WINDOW_INSCH_METHODDEF\n    {\"insdelln\",        (PyCFunction)PyCursesWindow_winsdelln, METH_VARARGS},\n    {\"insertln\",        (PyCFunction)PyCursesWindow_winsertln, METH_NOARGS},\n    _CURSES_WINDOW_INSNSTR_METHODDEF\n    _CURSES_WINDOW_INSSTR_METHODDEF\n    {\"instr\",           (PyCFunction)PyCursesWindow_InStr, METH_VARARGS},\n    _CURSES_WINDOW_IS_LINETOUCHED_METHODDEF\n    {\"is_wintouched\",   (PyCFunction)PyCursesWindow_is_wintouched, METH_NOARGS},\n    {\"keypad\",          (PyCFunction)PyCursesWindow_keypad, METH_VARARGS},\n    {\"leaveok\",         (PyCFunction)PyCursesWindow_leaveok, METH_VARARGS},\n    {\"move\",            (PyCFunction)PyCursesWindow_wmove, METH_VARARGS},\n    {\"mvderwin\",        (PyCFunction)PyCursesWindow_mvderwin, METH_VARARGS},\n    {\"mvwin\",           (PyCFunction)PyCursesWindow_mvwin, METH_VARARGS},\n    {\"nodelay\",         (PyCFunction)PyCursesWindow_nodelay, METH_VARARGS},\n    {\"notimeout\",       (PyCFunction)PyCursesWindow_notimeout, METH_VARARGS},\n    _CURSES_WINDOW_NOUTREFRESH_METHODDEF\n    _CURSES_WINDOW_OVERLAY_METHODDEF\n    _CURSES_WINDOW_OVERWRITE_METHODDEF\n    _CURSES_WINDOW_PUTWIN_METHODDEF\n    _CURSES_WINDOW_REDRAWLN_METHODDEF\n    {\"redrawwin\",       (PyCFunction)PyCursesWindow_redrawwin, METH_NOARGS},\n    _CURSES_WINDOW_REFRESH_METHODDEF\n#ifndef STRICT_SYSV_CURSES\n    {\"resize\",          (PyCFunction)PyCursesWindow_wresize, METH_VARARGS},\n#endif\n    _CURSES_WINDOW_SCROLL_METHODDEF\n    {\"scrollok\",        (PyCFunction)PyCursesWindow_scrollok, METH_VARARGS},\n    _CURSES_WINDOW_SETSCRREG_METHODDEF\n    {\"standend\",        (PyCFunction)PyCursesWindow_wstandend, METH_NOARGS},\n    {\"standout\",        (PyCFunction)PyCursesWindow_wstandout, METH_NOARGS},\n    {\"subpad\", (PyCFunction)_curses_window_subwin, METH_VARARGS, _curses_window_subwin__doc__},\n    _CURSES_WINDOW_SUBWIN_METHODDEF\n    {\"syncdown\",        (PyCFunction)PyCursesWindow_wsyncdown, METH_NOARGS},\n#ifdef HAVE_CURSES_SYNCOK\n    {\"syncok\",          (PyCFunction)PyCursesWindow_syncok, METH_VARARGS},\n#endif\n    {\"syncup\",          (PyCFunction)PyCursesWindow_wsyncup, METH_NOARGS},\n    {\"timeout\",         (PyCFunction)PyCursesWindow_wtimeout, METH_VARARGS},\n    _CURSES_WINDOW_TOUCHLINE_METHODDEF\n    {\"touchwin\",        (PyCFunction)PyCursesWindow_touchwin, METH_NOARGS},\n    {\"untouchwin\",      (PyCFunction)PyCursesWindow_untouchwin, METH_NOARGS},\n    _CURSES_WINDOW_VLINE_METHODDEF\n    {NULL,                  NULL}   /* sentinel */\n};\n\nstatic PyGetSetDef PyCursesWindow_getsets[] = {\n    {\"encoding\",\n     (getter)PyCursesWindow_get_encoding,\n     (setter)PyCursesWindow_set_encoding,\n     \"the typecode character used to create the array\"},\n    {NULL, NULL, NULL, NULL }  /* sentinel */\n};\n\n/* -------------------------------------------------------*/\n\nPyTypeObject PyCursesWindow_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_curses.window\",           /*tp_name*/\n    sizeof(PyCursesWindowObject),       /*tp_basicsize*/\n    0,                          /*tp_itemsize*/\n    /* methods */\n    (destructor)PyCursesWindow_Dealloc, /*tp_dealloc*/\n    0,                          /*tp_vectorcall_offset*/\n    (getattrfunc)0,             /*tp_getattr*/\n    (setattrfunc)0,             /*tp_setattr*/\n    0,                          /*tp_as_async*/\n    0,                          /*tp_repr*/\n    0,                          /*tp_as_number*/\n    0,                          /*tp_as_sequence*/\n    0,                          /*tp_as_mapping*/\n    0,                          /*tp_hash*/\n    0,                          /*tp_call*/\n    0,                          /*tp_str*/\n    0,                          /*tp_getattro*/\n    0,                          /*tp_setattro*/\n    0,                          /*tp_as_buffer*/\n    Py_TPFLAGS_DEFAULT,         /*tp_flags*/\n    0,                          /*tp_doc*/\n    0,                          /*tp_traverse*/\n    0,                          /*tp_clear*/\n    0,                          /*tp_richcompare*/\n    0,                          /*tp_weaklistoffset*/\n    0,                          /*tp_iter*/\n    0,                          /*tp_iternext*/\n    PyCursesWindow_Methods,     /*tp_methods*/\n    0,                          /* tp_members */\n    PyCursesWindow_getsets,     /* tp_getset */\n};\n\n/* Function Prototype Macros - They are ugly but very, very useful. ;-)\n\n   X - function name\n   TYPE - parameter Type\n   ERGSTR - format string for construction of the return value\n   PARSESTR - format string for argument parsing\n   */\n\n#define NoArgNoReturnFunctionBody(X) \\\n{ \\\n  PyCursesInitialised \\\n  return PyCursesCheckERR(X(), # X); }\n\n#define NoArgOrFlagNoReturnFunctionBody(X, flag) \\\n{ \\\n    PyCursesInitialised \\\n    if (flag) \\\n        return PyCursesCheckERR(X(), # X); \\\n    else \\\n        return PyCursesCheckERR(no ## X(), # X); \\\n}\n\n#define NoArgReturnIntFunctionBody(X) \\\n{ \\\n PyCursesInitialised \\\n return PyLong_FromLong((long) X()); }\n\n\n#define NoArgReturnStringFunctionBody(X) \\\n{ \\\n  PyCursesInitialised \\\n  return PyBytes_FromString(X()); }\n\n#define NoArgTrueFalseFunctionBody(X) \\\n{ \\\n  PyCursesInitialised \\\n  return PyBool_FromLong(X()); }\n\n#define NoArgNoReturnVoidFunctionBody(X) \\\n{ \\\n  PyCursesInitialised \\\n  X(); \\\n  Py_RETURN_NONE; }\n\n/*********************************************************************\n Global Functions\n**********************************************************************/\n\n#ifdef HAVE_CURSES_FILTER\n/*[clinic input]\n_curses.filter\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_filter_impl(PyObject *module)\n/*[clinic end generated code: output=fb5b8a3642eb70b5 input=668c75a6992d3624]*/\n{\n    /* not checking for PyCursesInitialised here since filter() must\n       be called before initscr() */\n    filter();\n    Py_RETURN_NONE;\n}\n#endif\n\n/*[clinic input]\n_curses.baudrate\n\nReturn the output speed of the terminal in bits per second.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_baudrate_impl(PyObject *module)\n/*[clinic end generated code: output=3c63c6c401d7d9c0 input=921f022ed04a0fd9]*/\nNoArgReturnIntFunctionBody(baudrate)\n\n/*[clinic input]\n_curses.beep\n\nEmit a short attention sound.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_beep_impl(PyObject *module)\n/*[clinic end generated code: output=425274962abe49a2 input=a35698ca7d0162bc]*/\nNoArgNoReturnFunctionBody(beep)\n\n/*[clinic input]\n_curses.can_change_color\n\nReturn True if the programmer can change the colors displayed by the terminal.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_can_change_color_impl(PyObject *module)\n/*[clinic end generated code: output=359df8c3c77d8bf1 input=d7718884de0092f2]*/\nNoArgTrueFalseFunctionBody(can_change_color)\n\n/*[clinic input]\n_curses.cbreak\n\n    flag: bool = True\n        If false, the effect is the same as calling nocbreak().\n    /\n\nEnter cbreak mode.\n\nIn cbreak mode (sometimes called \"rare\" mode) normal tty line buffering is\nturned off and characters are available to be read one by one.  However,\nunlike raw mode, special characters (interrupt, quit, suspend, and flow\ncontrol) retain their effects on the tty driver and calling program.\nCalling first raw() then cbreak() leaves the terminal in cbreak mode.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_cbreak_impl(PyObject *module, int flag)\n/*[clinic end generated code: output=9f9dee9664769751 input=c7d0bddda93016c1]*/\nNoArgOrFlagNoReturnFunctionBody(cbreak, flag)\n\n/*[clinic input]\n_curses.color_content\n\n    color_number: color\n        The number of the color (0 - (COLORS-1)).\n    /\n\nReturn the red, green, and blue (RGB) components of the specified color.\n\nA 3-tuple is returned, containing the R, G, B values for the given color,\nwhich will be between 0 (no component) and 1000 (maximum amount of component).\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_color_content_impl(PyObject *module, int color_number)\n/*[clinic end generated code: output=17b466df7054e0de input=03b5ed0472662aea]*/\n{\n    _CURSES_COLOR_VAL_TYPE r,g,b;\n\n    PyCursesInitialised;\n    PyCursesInitialisedColor;\n\n    if (_COLOR_CONTENT_FUNC(color_number, &r, &g, &b) == ERR) {\n        PyErr_Format(PyCursesError, \"%s() returned ERR\",\n                        Py_STRINGIFY(_COLOR_CONTENT_FUNC));\n        return NULL;\n    }\n\n    return Py_BuildValue(\"(iii)\", r, g, b);\n}\n\n/*[clinic input]\n_curses.color_pair\n\n    pair_number: int\n        The number of the color pair.\n    /\n\nReturn the attribute value for displaying text in the specified color.\n\nThis attribute value can be combined with A_STANDOUT, A_REVERSE, and the\nother A_* attributes.  pair_number() is the counterpart to this function.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_color_pair_impl(PyObject *module, int pair_number)\n/*[clinic end generated code: output=60718abb10ce9feb input=6034e9146f343802]*/\n{\n    PyCursesInitialised;\n    PyCursesInitialisedColor;\n\n    return  PyLong_FromLong(COLOR_PAIR(pair_number));\n}\n\n/*[clinic input]\n_curses.curs_set\n\n    visibility: int\n        0 for invisible, 1 for normal visible, or 2 for very visible.\n    /\n\nSet the cursor state.\n\nIf the terminal supports the visibility requested, the previous cursor\nstate is returned; otherwise, an exception is raised.  On many terminals,\nthe \"visible\" mode is an underline cursor and the \"very visible\" mode is\na block cursor.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_curs_set_impl(PyObject *module, int visibility)\n/*[clinic end generated code: output=ee8e62483b1d6cd4 input=81a7924a65d29504]*/\n{\n    int erg;\n\n    PyCursesInitialised;\n\n    erg = curs_set(visibility);\n    if (erg == ERR) return PyCursesCheckERR(erg, \"curs_set\");\n\n    return PyLong_FromLong((long) erg);\n}\n\n/*[clinic input]\n_curses.def_prog_mode\n\nSave the current terminal mode as the \"program\" mode.\n\nThe \"program\" mode is the mode when the running program is using curses.\n\nSubsequent calls to reset_prog_mode() will restore this mode.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_def_prog_mode_impl(PyObject *module)\n/*[clinic end generated code: output=05d5a351fff874aa input=768b9cace620dda5]*/\nNoArgNoReturnFunctionBody(def_prog_mode)\n\n/*[clinic input]\n_curses.def_shell_mode\n\nSave the current terminal mode as the \"shell\" mode.\n\nThe \"shell\" mode is the mode when the running program is not using curses.\n\nSubsequent calls to reset_shell_mode() will restore this mode.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_def_shell_mode_impl(PyObject *module)\n/*[clinic end generated code: output=d6e42f5c768f860f input=5ead21f6f0baa894]*/\nNoArgNoReturnFunctionBody(def_shell_mode)\n\n/*[clinic input]\n_curses.delay_output\n\n    ms: int\n        Duration in milliseconds.\n    /\n\nInsert a pause in output.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_delay_output_impl(PyObject *module, int ms)\n/*[clinic end generated code: output=b6613a67f17fa4f4 input=5316457f5f59196c]*/\n{\n    PyCursesInitialised;\n\n    return PyCursesCheckERR(delay_output(ms), \"delay_output\");\n}\n\n/*[clinic input]\n_curses.doupdate\n\nUpdate the physical screen to match the virtual screen.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_doupdate_impl(PyObject *module)\n/*[clinic end generated code: output=f34536975a75680c input=8da80914432a6489]*/\nNoArgNoReturnFunctionBody(doupdate)\n\n/*[clinic input]\n_curses.echo\n\n    flag: bool = True\n        If false, the effect is the same as calling noecho().\n    /\n\nEnter echo mode.\n\nIn echo mode, each character input is echoed to the screen as it is entered.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_echo_impl(PyObject *module, int flag)\n/*[clinic end generated code: output=03acb2ddfa6c8729 input=86cd4d5bb1d569c0]*/\nNoArgOrFlagNoReturnFunctionBody(echo, flag)\n\n/*[clinic input]\n_curses.endwin\n\nDe-initialize the library, and return terminal to normal status.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_endwin_impl(PyObject *module)\n/*[clinic end generated code: output=c0150cd96d2f4128 input=e172cfa43062f3fa]*/\nNoArgNoReturnFunctionBody(endwin)\n\n/*[clinic input]\n_curses.erasechar\n\nReturn the user's current erase character.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_erasechar_impl(PyObject *module)\n/*[clinic end generated code: output=3df305dc6b926b3f input=628c136c3c5758d3]*/\n{\n    char ch;\n\n    PyCursesInitialised;\n\n    ch = erasechar();\n\n    return PyBytes_FromStringAndSize(&ch, 1);\n}\n\n/*[clinic input]\n_curses.flash\n\nFlash the screen.\n\nThat is, change it to reverse-video and then change it back in a short interval.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_flash_impl(PyObject *module)\n/*[clinic end generated code: output=488b8a0ebd9ea9b8 input=02fdfb06c8fc3171]*/\nNoArgNoReturnFunctionBody(flash)\n\n/*[clinic input]\n_curses.flushinp\n\nFlush all input buffers.\n\nThis throws away any typeahead that has been typed by the user and has not\nyet been processed by the program.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_flushinp_impl(PyObject *module)\n/*[clinic end generated code: output=7e7a1fc1473960f5 input=59d042e705cef5ec]*/\nNoArgNoReturnVoidFunctionBody(flushinp)\n\n#ifdef getsyx\n/*[clinic input]\n_curses.getsyx\n\nReturn the current coordinates of the virtual screen cursor.\n\nReturn a (y, x) tuple.  If leaveok is currently true, return (-1, -1).\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_getsyx_impl(PyObject *module)\n/*[clinic end generated code: output=c8e6c3f42349a038 input=9e1f862f3b4f7cba]*/\n{\n    int x = 0;\n    int y = 0;\n\n    PyCursesInitialised;\n\n    getsyx(y, x);\n\n    return Py_BuildValue(\"(ii)\", y, x);\n}\n#endif\n\n#ifdef NCURSES_MOUSE_VERSION\n/*[clinic input]\n_curses.getmouse\n\nRetrieve the queued mouse event.\n\nAfter getch() returns KEY_MOUSE to signal a mouse event, this function\nreturns a 5-tuple (id, x, y, z, bstate).\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_getmouse_impl(PyObject *module)\n/*[clinic end generated code: output=ccf4242546b9cfa8 input=5b756ee6f5b481b1]*/\n{\n    int rtn;\n    MEVENT event;\n\n    PyCursesInitialised;\n\n    rtn = getmouse( &event );\n    if (rtn == ERR) {\n        PyErr_SetString(PyCursesError, \"getmouse() returned ERR\");\n        return NULL;\n    }\n    return Py_BuildValue(\"(hiiik)\",\n                         (short)event.id,\n                         (int)event.x, (int)event.y, (int)event.z,\n                         (unsigned long) event.bstate);\n}\n\n/*[clinic input]\n_curses.ungetmouse\n\n    id: short\n    x: int\n    y: int\n    z: int\n    bstate: unsigned_long(bitwise=True)\n    /\n\nPush a KEY_MOUSE event onto the input queue.\n\nThe following getmouse() will return the given state data.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_ungetmouse_impl(PyObject *module, short id, int x, int y, int z,\n                        unsigned long bstate)\n/*[clinic end generated code: output=3430c9b0fc5c4341 input=fd650b2ca5a01e8f]*/\n{\n    MEVENT event;\n\n    PyCursesInitialised;\n\n    event.id = id;\n    event.x = x;\n    event.y = y;\n    event.z = z;\n    event.bstate = bstate;\n    return PyCursesCheckERR(ungetmouse(&event), \"ungetmouse\");\n}\n#endif\n\n/*[clinic input]\n_curses.getwin\n\n    file: object\n    /\n\nRead window related data stored in the file by an earlier putwin() call.\n\nThe routine then creates and initializes a new window using that data,\nreturning the new window object.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_getwin(PyObject *module, PyObject *file)\n/*[clinic end generated code: output=a79e0df3379af756 input=f713d2bba0e4c929]*/\n{\n    FILE *fp;\n    PyObject *data;\n    size_t datalen;\n    WINDOW *win;\n    PyObject *res = NULL;\n\n    PyCursesInitialised;\n\n    fp = tmpfile();\n    if (fp == NULL)\n        return PyErr_SetFromErrno(PyExc_OSError);\n\n    if (_Py_set_inheritable(fileno(fp), 0, NULL) < 0)\n        goto error;\n\n    data = PyObject_CallMethod(file, \"read\", NULL);\n    if (data == NULL)\n        goto error;\n    if (!PyBytes_Check(data)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"f.read() returned %.100s instead of bytes\",\n                     Py_TYPE(data)->tp_name);\n        Py_DECREF(data);\n        goto error;\n    }\n    datalen = PyBytes_GET_SIZE(data);\n    if (fwrite(PyBytes_AS_STRING(data), 1, datalen, fp) != datalen) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        Py_DECREF(data);\n        goto error;\n    }\n    Py_DECREF(data);\n\n    fseek(fp, 0, 0);\n    win = getwin(fp);\n    if (win == NULL) {\n        PyErr_SetString(PyCursesError, catchall_NULL);\n        goto error;\n    }\n    res = PyCursesWindow_New(win, NULL);\n\nerror:\n    fclose(fp);\n    return res;\n}\n\n/*[clinic input]\n_curses.halfdelay\n\n    tenths: byte\n        Maximal blocking delay in tenths of seconds (1 - 255).\n    /\n\nEnter half-delay mode.\n\nUse nocbreak() to leave half-delay mode.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_halfdelay_impl(PyObject *module, unsigned char tenths)\n/*[clinic end generated code: output=e92cdf0ef33c0663 input=e42dce7259c15100]*/\n{\n    PyCursesInitialised;\n\n    return PyCursesCheckERR(halfdelay(tenths), \"halfdelay\");\n}\n\n/*[clinic input]\n_curses.has_colors\n\nReturn True if the terminal can display colors; otherwise, return False.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_has_colors_impl(PyObject *module)\n/*[clinic end generated code: output=db5667483139e3e2 input=b2ec41b739d896c6]*/\nNoArgTrueFalseFunctionBody(has_colors)\n\n/*[clinic input]\n_curses.has_ic\n\nReturn True if the terminal has insert- and delete-character capabilities.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_has_ic_impl(PyObject *module)\n/*[clinic end generated code: output=6be24da9cb1268fe input=9bc2d3a797cc7324]*/\nNoArgTrueFalseFunctionBody(has_ic)\n\n/*[clinic input]\n_curses.has_il\n\nReturn True if the terminal has insert- and delete-line capabilities.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_has_il_impl(PyObject *module)\n/*[clinic end generated code: output=d45bd7788ff9f5f4 input=cd939d5607ee5427]*/\nNoArgTrueFalseFunctionBody(has_il)\n\n#ifdef HAVE_CURSES_HAS_KEY\n/*[clinic input]\n_curses.has_key\n\n    key: int\n        Key number.\n    /\n\nReturn True if the current terminal type recognizes a key with that value.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_has_key_impl(PyObject *module, int key)\n/*[clinic end generated code: output=19ad48319414d0b1 input=78bd44acf1a4997c]*/\n{\n    PyCursesInitialised;\n\n    return PyBool_FromLong(has_key(key));\n}\n#endif\n\n/*[clinic input]\n_curses.init_color\n\n    color_number: color\n        The number of the color to be changed (0 - (COLORS-1)).\n    r: component\n        Red component (0 - 1000).\n    g: component\n        Green component (0 - 1000).\n    b: component\n        Blue component (0 - 1000).\n    /\n\nChange the definition of a color.\n\nWhen init_color() is used, all occurrences of that color on the screen\nimmediately change to the new definition.  This function is a no-op on\nmost terminals; it is active only if can_change_color() returns true.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_init_color_impl(PyObject *module, int color_number, short r, short g,\n                        short b)\n/*[clinic end generated code: output=d7ed71b2d818cdf2 input=ae2b8bea0f152c80]*/\n{\n    PyCursesInitialised;\n    PyCursesInitialisedColor;\n\n    return PyCursesCheckERR(_CURSES_INIT_COLOR_FUNC(color_number, r, g, b),\n                            Py_STRINGIFY(_CURSES_INIT_COLOR_FUNC));\n}\n\n/*[clinic input]\n_curses.init_pair\n\n    pair_number: pair\n        The number of the color-pair to be changed (1 - (COLOR_PAIRS-1)).\n    fg: color_allow_default\n        Foreground color number (-1 - (COLORS-1)).\n    bg: color_allow_default\n        Background color number (-1 - (COLORS-1)).\n    /\n\nChange the definition of a color-pair.\n\nIf the color-pair was previously initialized, the screen is refreshed and\nall occurrences of that color-pair are changed to the new definition.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_init_pair_impl(PyObject *module, int pair_number, int fg, int bg)\n/*[clinic end generated code: output=a0bba03d2bbc3ee6 input=54b421b44c12c389]*/\n{\n    PyCursesInitialised;\n    PyCursesInitialisedColor;\n\n    if (_CURSES_INIT_PAIR_FUNC(pair_number, fg, bg) == ERR) {\n        if (pair_number >= COLOR_PAIRS) {\n            PyErr_Format(PyExc_ValueError,\n                         \"Color pair is greater than COLOR_PAIRS-1 (%d).\",\n                         COLOR_PAIRS - 1);\n        }\n        else {\n            PyErr_Format(PyCursesError, \"%s() returned ERR\",\n                         Py_STRINGIFY(_CURSES_INIT_PAIR_FUNC));\n        }\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *ModDict;\n\n/*[clinic input]\n_curses.initscr\n\nInitialize the library.\n\nReturn a WindowObject which represents the whole screen.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_initscr_impl(PyObject *module)\n/*[clinic end generated code: output=619fb68443810b7b input=514f4bce1821f6b5]*/\n{\n    WINDOW *win;\n    PyCursesWindowObject *winobj;\n\n    if (initialised) {\n        wrefresh(stdscr);\n        return (PyObject *)PyCursesWindow_New(stdscr, NULL);\n    }\n\n    win = initscr();\n\n    if (win == NULL) {\n        PyErr_SetString(PyCursesError, catchall_NULL);\n        return NULL;\n    }\n\n    initialised = initialised_setupterm = TRUE;\n\n/* This was moved from initcurses() because it core dumped on SGI,\n   where they're not defined until you've called initscr() */\n#define SetDictInt(string,ch)                                           \\\n    do {                                                                \\\n        PyObject *o = PyLong_FromLong((long) (ch));                     \\\n        if (o && PyDict_SetItemString(ModDict, string, o) == 0)     {   \\\n            Py_DECREF(o);                                               \\\n        }                                                               \\\n    } while (0)\n\n    /* Here are some graphic symbols you can use */\n    SetDictInt(\"ACS_ULCORNER\",      (ACS_ULCORNER));\n    SetDictInt(\"ACS_LLCORNER\",      (ACS_LLCORNER));\n    SetDictInt(\"ACS_URCORNER\",      (ACS_URCORNER));\n    SetDictInt(\"ACS_LRCORNER\",      (ACS_LRCORNER));\n    SetDictInt(\"ACS_LTEE\",          (ACS_LTEE));\n    SetDictInt(\"ACS_RTEE\",          (ACS_RTEE));\n    SetDictInt(\"ACS_BTEE\",          (ACS_BTEE));\n    SetDictInt(\"ACS_TTEE\",          (ACS_TTEE));\n    SetDictInt(\"ACS_HLINE\",         (ACS_HLINE));\n    SetDictInt(\"ACS_VLINE\",         (ACS_VLINE));\n    SetDictInt(\"ACS_PLUS\",          (ACS_PLUS));\n#if !defined(__hpux) || defined(HAVE_NCURSES_H)\n    /* On HP/UX 11, these are of type cchar_t, which is not an\n       integral type. If this is a problem on more platforms, a\n       configure test should be added to determine whether ACS_S1\n       is of integral type. */\n    SetDictInt(\"ACS_S1\",            (ACS_S1));\n    SetDictInt(\"ACS_S9\",            (ACS_S9));\n    SetDictInt(\"ACS_DIAMOND\",       (ACS_DIAMOND));\n    SetDictInt(\"ACS_CKBOARD\",       (ACS_CKBOARD));\n    SetDictInt(\"ACS_DEGREE\",        (ACS_DEGREE));\n    SetDictInt(\"ACS_PLMINUS\",       (ACS_PLMINUS));\n    SetDictInt(\"ACS_BULLET\",        (ACS_BULLET));\n    SetDictInt(\"ACS_LARROW\",        (ACS_LARROW));\n    SetDictInt(\"ACS_RARROW\",        (ACS_RARROW));\n    SetDictInt(\"ACS_DARROW\",        (ACS_DARROW));\n    SetDictInt(\"ACS_UARROW\",        (ACS_UARROW));\n    SetDictInt(\"ACS_BOARD\",         (ACS_BOARD));\n    SetDictInt(\"ACS_LANTERN\",       (ACS_LANTERN));\n    SetDictInt(\"ACS_BLOCK\",         (ACS_BLOCK));\n#endif\n    SetDictInt(\"ACS_BSSB\",          (ACS_ULCORNER));\n    SetDictInt(\"ACS_SSBB\",          (ACS_LLCORNER));\n    SetDictInt(\"ACS_BBSS\",          (ACS_URCORNER));\n    SetDictInt(\"ACS_SBBS\",          (ACS_LRCORNER));\n    SetDictInt(\"ACS_SBSS\",          (ACS_RTEE));\n    SetDictInt(\"ACS_SSSB\",          (ACS_LTEE));\n    SetDictInt(\"ACS_SSBS\",          (ACS_BTEE));\n    SetDictInt(\"ACS_BSSS\",          (ACS_TTEE));\n    SetDictInt(\"ACS_BSBS\",          (ACS_HLINE));\n    SetDictInt(\"ACS_SBSB\",          (ACS_VLINE));\n    SetDictInt(\"ACS_SSSS\",          (ACS_PLUS));\n\n    /* The following are never available with strict SYSV curses */\n#ifdef ACS_S3\n    SetDictInt(\"ACS_S3\",            (ACS_S3));\n#endif\n#ifdef ACS_S7\n    SetDictInt(\"ACS_S7\",            (ACS_S7));\n#endif\n#ifdef ACS_LEQUAL\n    SetDictInt(\"ACS_LEQUAL\",        (ACS_LEQUAL));\n#endif\n#ifdef ACS_GEQUAL\n    SetDictInt(\"ACS_GEQUAL\",        (ACS_GEQUAL));\n#endif\n#ifdef ACS_PI\n    SetDictInt(\"ACS_PI\",            (ACS_PI));\n#endif\n#ifdef ACS_NEQUAL\n    SetDictInt(\"ACS_NEQUAL\",        (ACS_NEQUAL));\n#endif\n#ifdef ACS_STERLING\n    SetDictInt(\"ACS_STERLING\",      (ACS_STERLING));\n#endif\n\n    SetDictInt(\"LINES\", LINES);\n    SetDictInt(\"COLS\", COLS);\n\n    winobj = (PyCursesWindowObject *)PyCursesWindow_New(win, NULL);\n    screen_encoding = winobj->encoding;\n    return (PyObject *)winobj;\n}\n\n/*[clinic input]\n_curses.setupterm\n\n    term: str(accept={str, NoneType}) = None\n        Terminal name.\n        If omitted, the value of the TERM environment variable will be used.\n    fd: int = -1\n        File descriptor to which any initialization sequences will be sent.\n        If not supplied, the file descriptor for sys.stdout will be used.\n\nInitialize the terminal.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_setupterm_impl(PyObject *module, const char *term, int fd)\n/*[clinic end generated code: output=4584e587350f2848 input=4511472766af0c12]*/\n{\n    int err;\n\n    if (fd == -1) {\n        PyObject* sys_stdout;\n\n        sys_stdout = PySys_GetObject(\"stdout\");\n\n        if (sys_stdout == NULL || sys_stdout == Py_None) {\n            PyErr_SetString(\n                PyCursesError,\n                \"lost sys.stdout\");\n            return NULL;\n        }\n\n        fd = PyObject_AsFileDescriptor(sys_stdout);\n\n        if (fd == -1) {\n            return NULL;\n        }\n    }\n\n    if (!initialised_setupterm && setupterm((char *)term, fd, &err) == ERR) {\n        const char* s = \"setupterm: unknown error\";\n\n        if (err == 0) {\n            s = \"setupterm: could not find terminal\";\n        } else if (err == -1) {\n            s = \"setupterm: could not find terminfo database\";\n        }\n\n        PyErr_SetString(PyCursesError,s);\n        return NULL;\n    }\n\n    initialised_setupterm = TRUE;\n\n    Py_RETURN_NONE;\n}\n\n#if defined(NCURSES_EXT_FUNCS) && NCURSES_EXT_FUNCS >= 20081102\n// https://invisible-island.net/ncurses/NEWS.html#index-t20080119\n\n/*[clinic input]\n_curses.get_escdelay\n\nGets the curses ESCDELAY setting.\n\nGets the number of milliseconds to wait after reading an escape character,\nto distinguish between an individual escape character entered on the\nkeyboard from escape sequences sent by cursor and function keys.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_get_escdelay_impl(PyObject *module)\n/*[clinic end generated code: output=222fa1a822555d60 input=be2d5b3dd974d0a4]*/\n{\n    return PyLong_FromLong(ESCDELAY);\n}\n/*[clinic input]\n_curses.set_escdelay\n    ms: int\n        length of the delay in milliseconds.\n    /\n\nSets the curses ESCDELAY setting.\n\nSets the number of milliseconds to wait after reading an escape character,\nto distinguish between an individual escape character entered on the\nkeyboard from escape sequences sent by cursor and function keys.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_set_escdelay_impl(PyObject *module, int ms)\n/*[clinic end generated code: output=43818efbf7980ac4 input=7796fe19f111e250]*/\n{\n    if (ms <= 0) {\n        PyErr_SetString(PyExc_ValueError, \"ms must be > 0\");\n        return NULL;\n    }\n\n    return PyCursesCheckERR(set_escdelay(ms), \"set_escdelay\");\n}\n\n/*[clinic input]\n_curses.get_tabsize\n\nGets the curses TABSIZE setting.\n\nGets the number of columns used by the curses library when converting a tab\ncharacter to spaces as it adds the tab to a window.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_get_tabsize_impl(PyObject *module)\n/*[clinic end generated code: output=7e9e51fb6126fbdf input=74af86bf6c9f5d7e]*/\n{\n    return PyLong_FromLong(TABSIZE);\n}\n/*[clinic input]\n_curses.set_tabsize\n    size: int\n        rendered cell width of a tab character.\n    /\n\nSets the curses TABSIZE setting.\n\nSets the number of columns used by the curses library when converting a tab\ncharacter to spaces as it adds the tab to a window.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_set_tabsize_impl(PyObject *module, int size)\n/*[clinic end generated code: output=c1de5a76c0daab1e input=78cba6a3021ad061]*/\n{\n    if (size <= 0) {\n        PyErr_SetString(PyExc_ValueError, \"size must be > 0\");\n        return NULL;\n    }\n\n    return PyCursesCheckERR(set_tabsize(size), \"set_tabsize\");\n}\n#endif\n\n/*[clinic input]\n_curses.intrflush\n\n    flag: bool\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_intrflush_impl(PyObject *module, int flag)\n/*[clinic end generated code: output=c1986df35e999a0f input=c65fe2ef973fe40a]*/\n{\n    PyCursesInitialised;\n\n    return PyCursesCheckERR(intrflush(NULL, flag), \"intrflush\");\n}\n\n/*[clinic input]\n_curses.isendwin\n\nReturn True if endwin() has been called.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_isendwin_impl(PyObject *module)\n/*[clinic end generated code: output=d73179e4a7e1eb8c input=6cdb01a7ebf71397]*/\nNoArgTrueFalseFunctionBody(isendwin)\n\n#ifdef HAVE_CURSES_IS_TERM_RESIZED\n/*[clinic input]\n_curses.is_term_resized\n\n    nlines: int\n        Height.\n    ncols: int\n        Width.\n    /\n\nReturn True if resize_term() would modify the window structure, False otherwise.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_is_term_resized_impl(PyObject *module, int nlines, int ncols)\n/*[clinic end generated code: output=aafe04afe50f1288 input=ca9c0bd0fb8ab444]*/\n{\n    PyCursesInitialised;\n\n    return PyBool_FromLong(is_term_resized(nlines, ncols));\n}\n#endif /* HAVE_CURSES_IS_TERM_RESIZED */\n\n/*[clinic input]\n_curses.keyname\n\n    key: int\n        Key number.\n    /\n\nReturn the name of specified key.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_keyname_impl(PyObject *module, int key)\n/*[clinic end generated code: output=fa2675ab3f4e056b input=ee4b1d0f243a2a2b]*/\n{\n    const char *knp;\n\n    PyCursesInitialised;\n\n    if (key < 0) {\n        PyErr_SetString(PyExc_ValueError, \"invalid key number\");\n        return NULL;\n    }\n    knp = keyname(key);\n\n    return PyBytes_FromString((knp == NULL) ? \"\" : knp);\n}\n\n/*[clinic input]\n_curses.killchar\n\nReturn the user's current line kill character.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_killchar_impl(PyObject *module)\n/*[clinic end generated code: output=31c3a45b2c528269 input=1ff171c38df5ccad]*/\n{\n    char ch;\n\n    ch = killchar();\n\n    return PyBytes_FromStringAndSize(&ch, 1);\n}\n\n/*[clinic input]\n_curses.longname\n\nReturn the terminfo long name field describing the current terminal.\n\nThe maximum length of a verbose description is 128 characters.  It is defined\nonly after the call to initscr().\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_longname_impl(PyObject *module)\n/*[clinic end generated code: output=fdf30433727ef568 input=84c3f20201b1098e]*/\nNoArgReturnStringFunctionBody(longname)\n\n/*[clinic input]\n_curses.meta\n\n    yes: bool\n    /\n\nEnable/disable meta keys.\n\nIf yes is True, allow 8-bit characters to be input.  If yes is False,\nallow only 7-bit characters.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_meta_impl(PyObject *module, int yes)\n/*[clinic end generated code: output=22f5abda46a605d8 input=cfe7da79f51d0e30]*/\n{\n    PyCursesInitialised;\n\n    return PyCursesCheckERR(meta(stdscr, yes), \"meta\");\n}\n\n#ifdef NCURSES_MOUSE_VERSION\n/*[clinic input]\n_curses.mouseinterval\n\n    interval: int\n        Time in milliseconds.\n    /\n\nSet and retrieve the maximum time between press and release in a click.\n\nSet the maximum time that can elapse between press and release events in\norder for them to be recognized as a click, and return the previous interval\nvalue.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_mouseinterval_impl(PyObject *module, int interval)\n/*[clinic end generated code: output=c4f5ff04354634c5 input=75aaa3f0db10ac4e]*/\n{\n    PyCursesInitialised;\n\n    return PyCursesCheckERR(mouseinterval(interval), \"mouseinterval\");\n}\n\n/*[clinic input]\n_curses.mousemask\n\n    newmask: unsigned_long(bitwise=True)\n    /\n\nSet the mouse events to be reported, and return a tuple (availmask, oldmask).\n\nReturn a tuple (availmask, oldmask).  availmask indicates which of the\nspecified mouse events can be reported; on complete failure it returns 0.\noldmask is the previous value of the given window's mouse event mask.\nIf this function is never called, no mouse events are ever reported.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_mousemask_impl(PyObject *module, unsigned long newmask)\n/*[clinic end generated code: output=9406cf1b8a36e485 input=bdf76b7568a3c541]*/\n{\n    mmask_t oldmask, availmask;\n\n    PyCursesInitialised;\n    availmask = mousemask((mmask_t)newmask, &oldmask);\n    return Py_BuildValue(\"(kk)\",\n                         (unsigned long)availmask, (unsigned long)oldmask);\n}\n#endif\n\n/*[clinic input]\n_curses.napms\n\n    ms: int\n        Duration in milliseconds.\n    /\n\nSleep for specified time.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_napms_impl(PyObject *module, int ms)\n/*[clinic end generated code: output=a40a1da2e39ea438 input=20cd3af2b6900f56]*/\n{\n    PyCursesInitialised;\n\n    return Py_BuildValue(\"i\", napms(ms));\n}\n\n\n/*[clinic input]\n_curses.newpad\n\n    nlines: int\n        Height.\n    ncols: int\n        Width.\n    /\n\nCreate and return a pointer to a new pad data structure.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_newpad_impl(PyObject *module, int nlines, int ncols)\n/*[clinic end generated code: output=de52a56eb1098ec9 input=93f1272f240d8894]*/\n{\n    WINDOW *win;\n\n    PyCursesInitialised;\n\n    win = newpad(nlines, ncols);\n\n    if (win == NULL) {\n        PyErr_SetString(PyCursesError, catchall_NULL);\n        return NULL;\n    }\n\n    return (PyObject *)PyCursesWindow_New(win, NULL);\n}\n\n/*[clinic input]\n_curses.newwin\n\n    nlines: int\n        Height.\n    ncols: int\n        Width.\n    [\n    begin_y: int = 0\n        Top side y-coordinate.\n    begin_x: int = 0\n        Left side x-coordinate.\n    ]\n    /\n\nReturn a new window.\n\nBy default, the window will extend from the specified position to the lower\nright corner of the screen.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_newwin_impl(PyObject *module, int nlines, int ncols,\n                    int group_right_1, int begin_y, int begin_x)\n/*[clinic end generated code: output=c1e0a8dc8ac2826c input=29312c15a72a003d]*/\n{\n    WINDOW *win;\n\n    PyCursesInitialised;\n\n    win = newwin(nlines,ncols,begin_y,begin_x);\n    if (win == NULL) {\n        PyErr_SetString(PyCursesError, catchall_NULL);\n        return NULL;\n    }\n\n    return (PyObject *)PyCursesWindow_New(win, NULL);\n}\n\n/*[clinic input]\n_curses.nl\n\n    flag: bool = True\n        If false, the effect is the same as calling nonl().\n    /\n\nEnter newline mode.\n\nThis mode translates the return key into newline on input, and translates\nnewline into return and line-feed on output.  Newline mode is initially on.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_nl_impl(PyObject *module, int flag)\n/*[clinic end generated code: output=b39cc0ffc9015003 input=18e3e9c6e8cfcf6f]*/\nNoArgOrFlagNoReturnFunctionBody(nl, flag)\n\n/*[clinic input]\n_curses.nocbreak\n\nLeave cbreak mode.\n\nReturn to normal \"cooked\" mode with line buffering.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_nocbreak_impl(PyObject *module)\n/*[clinic end generated code: output=eabf3833a4fbf620 input=e4b65f7d734af400]*/\nNoArgNoReturnFunctionBody(nocbreak)\n\n/*[clinic input]\n_curses.noecho\n\nLeave echo mode.\n\nEchoing of input characters is turned off.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_noecho_impl(PyObject *module)\n/*[clinic end generated code: output=cc95ab45bc98f41b input=76714df529e614c3]*/\nNoArgNoReturnFunctionBody(noecho)\n\n/*[clinic input]\n_curses.nonl\n\nLeave newline mode.\n\nDisable translation of return into newline on input, and disable low-level\ntranslation of newline into newline/return on output.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_nonl_impl(PyObject *module)\n/*[clinic end generated code: output=99e917e9715770c6 input=9d37dd122d3022fc]*/\nNoArgNoReturnFunctionBody(nonl)\n\n/*[clinic input]\n_curses.noqiflush\n\nDisable queue flushing.\n\nWhen queue flushing is disabled, normal flush of input and output queues\nassociated with the INTR, QUIT and SUSP characters will not be done.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_noqiflush_impl(PyObject *module)\n/*[clinic end generated code: output=8b95a4229bbf0877 input=ba3e6b2e3e54c4df]*/\nNoArgNoReturnVoidFunctionBody(noqiflush)\n\n/*[clinic input]\n_curses.noraw\n\nLeave raw mode.\n\nReturn to normal \"cooked\" mode with line buffering.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_noraw_impl(PyObject *module)\n/*[clinic end generated code: output=39894e5524c430cc input=6ec86692096dffb5]*/\nNoArgNoReturnFunctionBody(noraw)\n\n/*[clinic input]\n_curses.pair_content\n\n    pair_number: pair\n        The number of the color pair (0 - (COLOR_PAIRS-1)).\n    /\n\nReturn a tuple (fg, bg) containing the colors for the requested color pair.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_pair_content_impl(PyObject *module, int pair_number)\n/*[clinic end generated code: output=4a726dd0e6885f3f input=03970f840fc7b739]*/\n{\n    _CURSES_COLOR_NUM_TYPE f, b;\n\n    PyCursesInitialised;\n    PyCursesInitialisedColor;\n\n    if (_CURSES_PAIR_CONTENT_FUNC(pair_number, &f, &b) == ERR) {\n        if (pair_number >= COLOR_PAIRS) {\n            PyErr_Format(PyExc_ValueError,\n                         \"Color pair is greater than COLOR_PAIRS-1 (%d).\",\n                         COLOR_PAIRS - 1);\n        }\n        else {\n            PyErr_Format(PyCursesError, \"%s() returned ERR\",\n                         Py_STRINGIFY(_CURSES_PAIR_CONTENT_FUNC));\n        }\n        return NULL;\n    }\n\n    return Py_BuildValue(\"(ii)\", f, b);\n}\n\n/*[clinic input]\n_curses.pair_number\n\n    attr: int\n    /\n\nReturn the number of the color-pair set by the specified attribute value.\n\ncolor_pair() is the counterpart to this function.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_pair_number_impl(PyObject *module, int attr)\n/*[clinic end generated code: output=85bce7d65c0aa3f4 input=d478548e33f5e61a]*/\n{\n    PyCursesInitialised;\n    PyCursesInitialisedColor;\n\n    return PyLong_FromLong(PAIR_NUMBER(attr));\n}\n\n/*[clinic input]\n_curses.putp\n\n    string: str(accept={robuffer})\n    /\n\nEmit the value of a specified terminfo capability for the current terminal.\n\nNote that the output of putp() always goes to standard output.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_putp_impl(PyObject *module, const char *string)\n/*[clinic end generated code: output=e98081d1b8eb5816 input=1601faa828b44cb3]*/\n{\n    return PyCursesCheckERR(putp(string), \"putp\");\n}\n\n/*[clinic input]\n_curses.qiflush\n\n    flag: bool = True\n        If false, the effect is the same as calling noqiflush().\n    /\n\nEnable queue flushing.\n\nIf queue flushing is enabled, all output in the display driver queue\nwill be flushed when the INTR, QUIT and SUSP characters are read.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_qiflush_impl(PyObject *module, int flag)\n/*[clinic end generated code: output=9167e862f760ea30 input=6ec8b3e2b717ec40]*/\n{\n    PyCursesInitialised;\n\n    if (flag) {\n        qiflush();\n    }\n    else {\n        noqiflush();\n    }\n    Py_RETURN_NONE;\n}\n\n/* Internal helper used for updating curses.LINES, curses.COLS, _curses.LINES\n * and _curses.COLS */\n#if defined(HAVE_CURSES_RESIZETERM) || defined(HAVE_CURSES_RESIZE_TERM)\nstatic int\nupdate_lines_cols(void)\n{\n    PyObject *o;\n    PyObject *m = PyImport_ImportModule(\"curses\");\n\n    if (!m)\n        return 0;\n\n    o = PyLong_FromLong(LINES);\n    if (!o) {\n        Py_DECREF(m);\n        return 0;\n    }\n    if (PyObject_SetAttrString(m, \"LINES\", o)) {\n        Py_DECREF(m);\n        Py_DECREF(o);\n        return 0;\n    }\n    if (PyDict_SetItemString(ModDict, \"LINES\", o)) {\n        Py_DECREF(m);\n        Py_DECREF(o);\n        return 0;\n    }\n    Py_DECREF(o);\n    o = PyLong_FromLong(COLS);\n    if (!o) {\n        Py_DECREF(m);\n        return 0;\n    }\n    if (PyObject_SetAttrString(m, \"COLS\", o)) {\n        Py_DECREF(m);\n        Py_DECREF(o);\n        return 0;\n    }\n    if (PyDict_SetItemString(ModDict, \"COLS\", o)) {\n        Py_DECREF(m);\n        Py_DECREF(o);\n        return 0;\n    }\n    Py_DECREF(o);\n    Py_DECREF(m);\n    return 1;\n}\n\n/*[clinic input]\n_curses.update_lines_cols\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_update_lines_cols_impl(PyObject *module)\n/*[clinic end generated code: output=423f2b1e63ed0f75 input=5f065ab7a28a5d90]*/\n{\n    if (!update_lines_cols()) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\n#endif\n\n/*[clinic input]\n_curses.raw\n\n    flag: bool = True\n        If false, the effect is the same as calling noraw().\n    /\n\nEnter raw mode.\n\nIn raw mode, normal line buffering and processing of interrupt, quit,\nsuspend, and flow control keys are turned off; characters are presented to\ncurses input functions one by one.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_raw_impl(PyObject *module, int flag)\n/*[clinic end generated code: output=a750e4b342be015b input=4b447701389fb4df]*/\nNoArgOrFlagNoReturnFunctionBody(raw, flag)\n\n/*[clinic input]\n_curses.reset_prog_mode\n\nRestore the terminal to \"program\" mode, as previously saved by def_prog_mode().\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_reset_prog_mode_impl(PyObject *module)\n/*[clinic end generated code: output=15eb765abf0b6575 input=3d82bea2b3243471]*/\nNoArgNoReturnFunctionBody(reset_prog_mode)\n\n/*[clinic input]\n_curses.reset_shell_mode\n\nRestore the terminal to \"shell\" mode, as previously saved by def_shell_mode().\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_reset_shell_mode_impl(PyObject *module)\n/*[clinic end generated code: output=0238de2962090d33 input=1c738fa64bd1a24f]*/\nNoArgNoReturnFunctionBody(reset_shell_mode)\n\n/*[clinic input]\n_curses.resetty\n\nRestore terminal mode.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_resetty_impl(PyObject *module)\n/*[clinic end generated code: output=ff4b448e80a7cd63 input=940493de03624bb0]*/\nNoArgNoReturnFunctionBody(resetty)\n\n#ifdef HAVE_CURSES_RESIZETERM\n/*[clinic input]\n_curses.resizeterm\n\n    nlines: int\n        Height.\n    ncols: int\n        Width.\n    /\n\nResize the standard and current windows to the specified dimensions.\n\nAdjusts other bookkeeping data used by the curses library that record the\nwindow dimensions (in particular the SIGWINCH handler).\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_resizeterm_impl(PyObject *module, int nlines, int ncols)\n/*[clinic end generated code: output=56d6bcc5194ad055 input=0fca02ebad5ffa82]*/\n{\n    PyObject *result;\n\n    PyCursesInitialised;\n\n    result = PyCursesCheckERR(resizeterm(nlines, ncols), \"resizeterm\");\n    if (!result)\n        return NULL;\n    if (!update_lines_cols()) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    return result;\n}\n\n#endif\n\n#ifdef HAVE_CURSES_RESIZE_TERM\n/*[clinic input]\n_curses.resize_term\n\n    nlines: int\n        Height.\n    ncols: int\n        Width.\n    /\n\nBackend function used by resizeterm(), performing most of the work.\n\nWhen resizing the windows, resize_term() blank-fills the areas that are\nextended.  The calling application should fill in these areas with appropriate\ndata.  The resize_term() function attempts to resize all windows.  However,\ndue to the calling convention of pads, it is not possible to resize these\nwithout additional interaction with the application.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_resize_term_impl(PyObject *module, int nlines, int ncols)\n/*[clinic end generated code: output=9e26d8b9ea311ed2 input=2197edd05b049ed4]*/\n{\n    PyObject *result;\n\n    PyCursesInitialised;\n\n    result = PyCursesCheckERR(resize_term(nlines, ncols), \"resize_term\");\n    if (!result)\n        return NULL;\n    if (!update_lines_cols()) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    return result;\n}\n#endif /* HAVE_CURSES_RESIZE_TERM */\n\n/*[clinic input]\n_curses.savetty\n\nSave terminal mode.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_savetty_impl(PyObject *module)\n/*[clinic end generated code: output=6babc49f12b42199 input=fce6b2b7d2200102]*/\nNoArgNoReturnFunctionBody(savetty)\n\n#ifdef getsyx\n/*[clinic input]\n_curses.setsyx\n\n    y: int\n        Y-coordinate.\n    x: int\n        X-coordinate.\n    /\n\nSet the virtual screen cursor.\n\nIf y and x are both -1, then leaveok is set.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_setsyx_impl(PyObject *module, int y, int x)\n/*[clinic end generated code: output=23dcf753511a2464 input=fa7f2b208e10a557]*/\n{\n    PyCursesInitialised;\n\n    setsyx(y,x);\n\n    Py_RETURN_NONE;\n}\n#endif\n\n/*[clinic input]\n_curses.start_color\n\nInitializes eight basic colors and global variables COLORS and COLOR_PAIRS.\n\nMust be called if the programmer wants to use colors, and before any other\ncolor manipulation routine is called.  It is good practice to call this\nroutine right after initscr().\n\nIt also restores the colors on the terminal to the values they had when the\nterminal was just turned on.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_start_color_impl(PyObject *module)\n/*[clinic end generated code: output=8b772b41d8090ede input=0ca0ecb2b77e1a12]*/\n{\n    int code;\n    PyObject *c, *cp;\n\n    PyCursesInitialised;\n\n    code = start_color();\n    if (code != ERR) {\n        initialisedcolors = TRUE;\n        c = PyLong_FromLong((long) COLORS);\n        if (c == NULL)\n            return NULL;\n        if (PyDict_SetItemString(ModDict, \"COLORS\", c) < 0) {\n            Py_DECREF(c);\n            return NULL;\n        }\n        Py_DECREF(c);\n        cp = PyLong_FromLong((long) COLOR_PAIRS);\n        if (cp == NULL)\n            return NULL;\n        if (PyDict_SetItemString(ModDict, \"COLOR_PAIRS\", cp) < 0) {\n            Py_DECREF(cp);\n            return NULL;\n        }\n        Py_DECREF(cp);\n        Py_RETURN_NONE;\n    } else {\n        PyErr_SetString(PyCursesError, \"start_color() returned ERR\");\n        return NULL;\n    }\n}\n\n/*[clinic input]\n_curses.termattrs\n\nReturn a logical OR of all video attributes supported by the terminal.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_termattrs_impl(PyObject *module)\n/*[clinic end generated code: output=b06f437fce1b6fc4 input=0559882a04f84d1d]*/\nNoArgReturnIntFunctionBody(termattrs)\n\n/*[clinic input]\n_curses.termname\n\nReturn the value of the environment variable TERM, truncated to 14 characters.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_termname_impl(PyObject *module)\n/*[clinic end generated code: output=96375577ebbd67fd input=33c08d000944f33f]*/\nNoArgReturnStringFunctionBody(termname)\n\n/*[clinic input]\n_curses.tigetflag\n\n    capname: str\n        The terminfo capability name.\n    /\n\nReturn the value of the Boolean capability.\n\nThe value -1 is returned if capname is not a Boolean capability, or 0 if\nit is canceled or absent from the terminal description.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_tigetflag_impl(PyObject *module, const char *capname)\n/*[clinic end generated code: output=8853c0e55542195b input=b0787af9e3e9a6ce]*/\n{\n    PyCursesSetupTermCalled;\n\n    return PyLong_FromLong( (long) tigetflag( (char *)capname ) );\n}\n\n/*[clinic input]\n_curses.tigetnum\n\n    capname: str\n        The terminfo capability name.\n    /\n\nReturn the value of the numeric capability.\n\nThe value -2 is returned if capname is not a numeric capability, or -1 if\nit is canceled or absent from the terminal description.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_tigetnum_impl(PyObject *module, const char *capname)\n/*[clinic end generated code: output=46f8b0a1b5dff42f input=5cdf2f410b109720]*/\n{\n    PyCursesSetupTermCalled;\n\n    return PyLong_FromLong( (long) tigetnum( (char *)capname ) );\n}\n\n/*[clinic input]\n_curses.tigetstr\n\n    capname: str\n        The terminfo capability name.\n    /\n\nReturn the value of the string capability.\n\nNone is returned if capname is not a string capability, or is canceled or\nabsent from the terminal description.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_tigetstr_impl(PyObject *module, const char *capname)\n/*[clinic end generated code: output=f22b576ad60248f3 input=36644df25c73c0a7]*/\n{\n    PyCursesSetupTermCalled;\n\n    capname = tigetstr( (char *)capname );\n    if (capname == NULL || capname == (char*) -1) {\n        Py_RETURN_NONE;\n    }\n    return PyBytes_FromString( capname );\n}\n\n/*[clinic input]\n_curses.tparm\n\n    str: str(accept={robuffer})\n        Parameterized byte string obtained from the terminfo database.\n    i1: int = 0\n    i2: int = 0\n    i3: int = 0\n    i4: int = 0\n    i5: int = 0\n    i6: int = 0\n    i7: int = 0\n    i8: int = 0\n    i9: int = 0\n    /\n\nInstantiate the specified byte string with the supplied parameters.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_tparm_impl(PyObject *module, const char *str, int i1, int i2, int i3,\n                   int i4, int i5, int i6, int i7, int i8, int i9)\n/*[clinic end generated code: output=599f62b615c667ff input=5e30b15786f032aa]*/\n{\n    char* result = NULL;\n\n    PyCursesSetupTermCalled;\n\n    result = tparm((char *)str,i1,i2,i3,i4,i5,i6,i7,i8,i9);\n    if (!result) {\n        PyErr_SetString(PyCursesError, \"tparm() returned NULL\");\n        return NULL;\n    }\n\n    return PyBytes_FromString(result);\n}\n\n#ifdef HAVE_CURSES_TYPEAHEAD\n/*[clinic input]\n_curses.typeahead\n\n    fd: int\n        File descriptor.\n    /\n\nSpecify that the file descriptor fd be used for typeahead checking.\n\nIf fd is -1, then no typeahead checking is done.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_typeahead_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=084bb649d7066583 input=f2968d8e1805051b]*/\n{\n    PyCursesInitialised;\n\n    return PyCursesCheckERR(typeahead( fd ), \"typeahead\");\n}\n#endif\n\n/*[clinic input]\n_curses.unctrl\n\n    ch: object\n    /\n\nReturn a string which is a printable representation of the character ch.\n\nControl characters are displayed as a caret followed by the character,\nfor example as ^C.  Printing characters are left as they are.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_unctrl(PyObject *module, PyObject *ch)\n/*[clinic end generated code: output=8e07fafc430c9434 input=cd1e35e16cd1ace4]*/\n{\n    chtype ch_;\n\n    PyCursesInitialised;\n\n    if (!PyCurses_ConvertToChtype(NULL, ch, &ch_))\n        return NULL;\n\n    return PyBytes_FromString(unctrl(ch_));\n}\n\n/*[clinic input]\n_curses.ungetch\n\n    ch: object\n    /\n\nPush ch so the next getch() will return it.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_ungetch(PyObject *module, PyObject *ch)\n/*[clinic end generated code: output=9b19d8268376d887 input=6681e6ae4c42e5eb]*/\n{\n    chtype ch_;\n\n    PyCursesInitialised;\n\n    if (!PyCurses_ConvertToChtype(NULL, ch, &ch_))\n        return NULL;\n\n    return PyCursesCheckERR(ungetch(ch_), \"ungetch\");\n}\n\n#ifdef HAVE_NCURSESW\n/* Convert an object to a character (wchar_t):\n\n    - int\n    - str of length 1\n\n   Return 1 on success, 0 on error. */\nstatic int\nPyCurses_ConvertToWchar_t(PyObject *obj,\n                          wchar_t *wch)\n{\n    if (PyUnicode_Check(obj)) {\n        wchar_t buffer[2];\n        if (PyUnicode_AsWideChar(obj, buffer, 2) != 1) {\n            PyErr_Format(PyExc_TypeError,\n                         \"expect str of length 1 or int, \"\n                         \"got a str of length %zi\",\n                         PyUnicode_GET_LENGTH(obj));\n            return 0;\n        }\n        *wch = buffer[0];\n        return 2;\n    }\n    else if (PyLong_CheckExact(obj)) {\n        long value;\n        int overflow;\n        value = PyLong_AsLongAndOverflow(obj, &overflow);\n        if (overflow) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"int doesn't fit in long\");\n            return 0;\n        }\n        *wch = (wchar_t)value;\n        if ((long)*wch != value) {\n            PyErr_Format(PyExc_OverflowError,\n                         \"character doesn't fit in wchar_t\");\n            return 0;\n        }\n        return 1;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"expect str of length 1 or int, got %s\",\n                     Py_TYPE(obj)->tp_name);\n        return 0;\n    }\n}\n\n/*[clinic input]\n_curses.unget_wch\n\n    ch: object\n    /\n\nPush ch so the next get_wch() will return it.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_unget_wch(PyObject *module, PyObject *ch)\n/*[clinic end generated code: output=1974c9fb01d37863 input=0d56dc65a46feebb]*/\n{\n    wchar_t wch;\n\n    PyCursesInitialised;\n\n    if (!PyCurses_ConvertToWchar_t(ch, &wch))\n        return NULL;\n    return PyCursesCheckERR(unget_wch(wch), \"unget_wch\");\n}\n#endif\n\n#ifdef HAVE_CURSES_USE_ENV\n/*[clinic input]\n_curses.use_env\n\n    flag: bool\n    /\n\nUse environment variables LINES and COLUMNS.\n\nIf used, this function should be called before initscr() or newterm() are\ncalled.\n\nWhen flag is False, the values of lines and columns specified in the terminfo\ndatabase will be used, even if environment variables LINES and COLUMNS (used\nby default) are set, or if curses is running in a window (in which case\ndefault behavior would be to use the window size if LINES and COLUMNS are\nnot set).\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_use_env_impl(PyObject *module, int flag)\n/*[clinic end generated code: output=b2c445e435c0b164 input=06ac30948f2d78e4]*/\n{\n    use_env(flag);\n    Py_RETURN_NONE;\n}\n#endif\n\n#ifndef STRICT_SYSV_CURSES\n/*[clinic input]\n_curses.use_default_colors\n\nAllow use of default values for colors on terminals supporting this feature.\n\nUse this to support transparency in your application.  The default color\nis assigned to the color number -1.\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_use_default_colors_impl(PyObject *module)\n/*[clinic end generated code: output=a3b81ff71dd901be input=656844367470e8fc]*/\n{\n    int code;\n\n    PyCursesInitialised;\n    PyCursesInitialisedColor;\n\n    code = use_default_colors();\n    if (code != ERR) {\n        Py_RETURN_NONE;\n    } else {\n        PyErr_SetString(PyCursesError, \"use_default_colors() returned ERR\");\n        return NULL;\n    }\n}\n#endif /* STRICT_SYSV_CURSES */\n\n\n#ifdef NCURSES_VERSION\n\nPyDoc_STRVAR(ncurses_version__doc__,\n\"curses.ncurses_version\\n\\\n\\n\\\nNcurses version information as a named tuple.\");\n\nstatic PyStructSequence_Field ncurses_version_fields[] = {\n    {\"major\", \"Major release number\"},\n    {\"minor\", \"Minor release number\"},\n    {\"patch\", \"Patch release number\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc ncurses_version_desc = {\n    \"curses.ncurses_version\",  /* name */\n    ncurses_version__doc__,    /* doc */\n    ncurses_version_fields,    /* fields */\n    3\n};\n\nstatic PyObject *\nmake_ncurses_version(PyTypeObject *type)\n{\n    PyObject *ncurses_version;\n    int pos = 0;\n\n    ncurses_version = PyStructSequence_New(type);\n    if (ncurses_version == NULL) {\n        return NULL;\n    }\n\n#define SetIntItem(flag) \\\n    PyStructSequence_SET_ITEM(ncurses_version, pos++, PyLong_FromLong(flag)); \\\n    if (PyErr_Occurred()) { \\\n        Py_CLEAR(ncurses_version); \\\n        return NULL; \\\n    }\n\n    SetIntItem(NCURSES_VERSION_MAJOR)\n    SetIntItem(NCURSES_VERSION_MINOR)\n    SetIntItem(NCURSES_VERSION_PATCH)\n#undef SetIntItem\n\n    return ncurses_version;\n}\n\n#endif /* NCURSES_VERSION */\n\n/*[clinic input]\n_curses.has_extended_color_support\n\nReturn True if the module supports extended colors; otherwise, return False.\n\nExtended color support allows more than 256 color-pairs for terminals\nthat support more than 16 colors (e.g. xterm-256color).\n[clinic start generated code]*/\n\nstatic PyObject *\n_curses_has_extended_color_support_impl(PyObject *module)\n/*[clinic end generated code: output=68f1be2b57d92e22 input=4b905f046e35ee9f]*/\n{\n    return PyBool_FromLong(_NCURSES_EXTENDED_COLOR_FUNCS);\n}\n\n/* List of functions defined in the module */\n\nstatic PyMethodDef PyCurses_methods[] = {\n    _CURSES_BAUDRATE_METHODDEF\n    _CURSES_BEEP_METHODDEF\n    _CURSES_CAN_CHANGE_COLOR_METHODDEF\n    _CURSES_CBREAK_METHODDEF\n    _CURSES_COLOR_CONTENT_METHODDEF\n    _CURSES_COLOR_PAIR_METHODDEF\n    _CURSES_CURS_SET_METHODDEF\n    _CURSES_DEF_PROG_MODE_METHODDEF\n    _CURSES_DEF_SHELL_MODE_METHODDEF\n    _CURSES_DELAY_OUTPUT_METHODDEF\n    _CURSES_DOUPDATE_METHODDEF\n    _CURSES_ECHO_METHODDEF\n    _CURSES_ENDWIN_METHODDEF\n    _CURSES_ERASECHAR_METHODDEF\n    _CURSES_FILTER_METHODDEF\n    _CURSES_FLASH_METHODDEF\n    _CURSES_FLUSHINP_METHODDEF\n    _CURSES_GETMOUSE_METHODDEF\n    _CURSES_UNGETMOUSE_METHODDEF\n    _CURSES_GETSYX_METHODDEF\n    _CURSES_GETWIN_METHODDEF\n    _CURSES_HAS_COLORS_METHODDEF\n    _CURSES_HAS_EXTENDED_COLOR_SUPPORT_METHODDEF\n    _CURSES_HAS_IC_METHODDEF\n    _CURSES_HAS_IL_METHODDEF\n    _CURSES_HAS_KEY_METHODDEF\n    _CURSES_HALFDELAY_METHODDEF\n    _CURSES_INIT_COLOR_METHODDEF\n    _CURSES_INIT_PAIR_METHODDEF\n    _CURSES_INITSCR_METHODDEF\n    _CURSES_INTRFLUSH_METHODDEF\n    _CURSES_ISENDWIN_METHODDEF\n    _CURSES_IS_TERM_RESIZED_METHODDEF\n    _CURSES_KEYNAME_METHODDEF\n    _CURSES_KILLCHAR_METHODDEF\n    _CURSES_LONGNAME_METHODDEF\n    _CURSES_META_METHODDEF\n    _CURSES_MOUSEINTERVAL_METHODDEF\n    _CURSES_MOUSEMASK_METHODDEF\n    _CURSES_NAPMS_METHODDEF\n    _CURSES_NEWPAD_METHODDEF\n    _CURSES_NEWWIN_METHODDEF\n    _CURSES_NL_METHODDEF\n    _CURSES_NOCBREAK_METHODDEF\n    _CURSES_NOECHO_METHODDEF\n    _CURSES_NONL_METHODDEF\n    _CURSES_NOQIFLUSH_METHODDEF\n    _CURSES_NORAW_METHODDEF\n    _CURSES_PAIR_CONTENT_METHODDEF\n    _CURSES_PAIR_NUMBER_METHODDEF\n    _CURSES_PUTP_METHODDEF\n    _CURSES_QIFLUSH_METHODDEF\n    _CURSES_RAW_METHODDEF\n    _CURSES_RESET_PROG_MODE_METHODDEF\n    _CURSES_RESET_SHELL_MODE_METHODDEF\n    _CURSES_RESETTY_METHODDEF\n    _CURSES_RESIZETERM_METHODDEF\n    _CURSES_RESIZE_TERM_METHODDEF\n    _CURSES_SAVETTY_METHODDEF\n#if defined(NCURSES_EXT_FUNCS) && NCURSES_EXT_FUNCS >= 20081102\n    _CURSES_GET_ESCDELAY_METHODDEF\n    _CURSES_SET_ESCDELAY_METHODDEF\n#endif\n    _CURSES_GET_TABSIZE_METHODDEF\n    _CURSES_SET_TABSIZE_METHODDEF\n    _CURSES_SETSYX_METHODDEF\n    _CURSES_SETUPTERM_METHODDEF\n    _CURSES_START_COLOR_METHODDEF\n    _CURSES_TERMATTRS_METHODDEF\n    _CURSES_TERMNAME_METHODDEF\n    _CURSES_TIGETFLAG_METHODDEF\n    _CURSES_TIGETNUM_METHODDEF\n    _CURSES_TIGETSTR_METHODDEF\n    _CURSES_TPARM_METHODDEF\n    _CURSES_TYPEAHEAD_METHODDEF\n    _CURSES_UNCTRL_METHODDEF\n    _CURSES_UNGETCH_METHODDEF\n    _CURSES_UPDATE_LINES_COLS_METHODDEF\n    _CURSES_UNGET_WCH_METHODDEF\n    _CURSES_USE_ENV_METHODDEF\n    _CURSES_USE_DEFAULT_COLORS_METHODDEF\n    {NULL,                  NULL}         /* sentinel */\n};\n\n/* Initialization function for the module */\n\n\nstatic struct PyModuleDef _cursesmodule = {\n    PyModuleDef_HEAD_INIT,\n    \"_curses\",\n    NULL,\n    -1,\n    PyCurses_methods,\n    NULL,\n    NULL,\n    NULL,\n    NULL\n};\n\nstatic void\ncurses_destructor(PyObject *op)\n{\n    void *ptr = PyCapsule_GetPointer(op, PyCurses_CAPSULE_NAME);\n    Py_DECREF(*(void **)ptr);\n    PyMem_Free(ptr);\n}\n\nPyMODINIT_FUNC\nPyInit__curses(void)\n{\n    PyObject *m, *d, *v, *c_api_object;\n\n    /* Initialize object type */\n    if (PyType_Ready(&PyCursesWindow_Type) < 0)\n        return NULL;\n\n    /* Create the module and add the functions */\n    m = PyModule_Create(&_cursesmodule);\n    if (m == NULL)\n        return NULL;\n\n    /* Add some symbolic constants to the module */\n    d = PyModule_GetDict(m);\n    if (d == NULL)\n        return NULL;\n    ModDict = d; /* For PyCurses_InitScr to use later */\n\n    void **PyCurses_API = PyMem_Calloc(PyCurses_API_pointers, sizeof(void *));\n    if (PyCurses_API == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    /* Initialize the C API pointer array */\n    PyCurses_API[0] = (void *)Py_NewRef(&PyCursesWindow_Type);\n    PyCurses_API[1] = (void *)func_PyCursesSetupTermCalled;\n    PyCurses_API[2] = (void *)func_PyCursesInitialised;\n    PyCurses_API[3] = (void *)func_PyCursesInitialisedColor;\n\n    /* Add a capsule for the C API */\n    c_api_object = PyCapsule_New(PyCurses_API, PyCurses_CAPSULE_NAME,\n                                 curses_destructor);\n    if (c_api_object == NULL) {\n        Py_DECREF(PyCurses_API[0]);\n        PyMem_Free(PyCurses_API);\n        return NULL;\n    }\n    if (PyDict_SetItemString(d, \"_C_API\", c_api_object) < 0) {\n        Py_DECREF(c_api_object);\n        return NULL;\n    }\n    Py_DECREF(c_api_object);\n\n    /* For exception curses.error */\n    PyCursesError = PyErr_NewException(\"_curses.error\", NULL, NULL);\n    PyDict_SetItemString(d, \"error\", PyCursesError);\n\n    /* Make the version available */\n    v = PyBytes_FromString(PyCursesVersion);\n    PyDict_SetItemString(d, \"version\", v);\n    PyDict_SetItemString(d, \"__version__\", v);\n    Py_DECREF(v);\n\n#ifdef NCURSES_VERSION\n    /* ncurses_version */\n    PyTypeObject *version_type;\n    version_type = _PyStructSequence_NewType(&ncurses_version_desc,\n                                             Py_TPFLAGS_DISALLOW_INSTANTIATION);\n    if (version_type == NULL) {\n        return NULL;\n    }\n    v = make_ncurses_version(version_type);\n    Py_DECREF(version_type);\n    if (v == NULL) {\n        return NULL;\n    }\n    PyDict_SetItemString(d, \"ncurses_version\", v);\n    Py_DECREF(v);\n#endif /* NCURSES_VERSION */\n\n    SetDictInt(\"ERR\", ERR);\n    SetDictInt(\"OK\", OK);\n\n    /* Here are some attributes you can add to chars to print */\n\n    SetDictInt(\"A_ATTRIBUTES\",      A_ATTRIBUTES);\n    SetDictInt(\"A_NORMAL\",              A_NORMAL);\n    SetDictInt(\"A_STANDOUT\",            A_STANDOUT);\n    SetDictInt(\"A_UNDERLINE\",           A_UNDERLINE);\n    SetDictInt(\"A_REVERSE\",             A_REVERSE);\n    SetDictInt(\"A_BLINK\",               A_BLINK);\n    SetDictInt(\"A_DIM\",                 A_DIM);\n    SetDictInt(\"A_BOLD\",                A_BOLD);\n    SetDictInt(\"A_ALTCHARSET\",          A_ALTCHARSET);\n    SetDictInt(\"A_INVIS\",           A_INVIS);\n    SetDictInt(\"A_PROTECT\",         A_PROTECT);\n    SetDictInt(\"A_CHARTEXT\",        A_CHARTEXT);\n    SetDictInt(\"A_COLOR\",           A_COLOR);\n\n    /* The following are never available with strict SYSV curses */\n#ifdef A_HORIZONTAL\n    SetDictInt(\"A_HORIZONTAL\",      A_HORIZONTAL);\n#endif\n#ifdef A_LEFT\n    SetDictInt(\"A_LEFT\",            A_LEFT);\n#endif\n#ifdef A_LOW\n    SetDictInt(\"A_LOW\",             A_LOW);\n#endif\n#ifdef A_RIGHT\n    SetDictInt(\"A_RIGHT\",           A_RIGHT);\n#endif\n#ifdef A_TOP\n    SetDictInt(\"A_TOP\",             A_TOP);\n#endif\n#ifdef A_VERTICAL\n    SetDictInt(\"A_VERTICAL\",        A_VERTICAL);\n#endif\n\n    /* ncurses extension */\n#ifdef A_ITALIC\n    SetDictInt(\"A_ITALIC\",          A_ITALIC);\n#endif\n\n    SetDictInt(\"COLOR_BLACK\",       COLOR_BLACK);\n    SetDictInt(\"COLOR_RED\",         COLOR_RED);\n    SetDictInt(\"COLOR_GREEN\",       COLOR_GREEN);\n    SetDictInt(\"COLOR_YELLOW\",      COLOR_YELLOW);\n    SetDictInt(\"COLOR_BLUE\",        COLOR_BLUE);\n    SetDictInt(\"COLOR_MAGENTA\",     COLOR_MAGENTA);\n    SetDictInt(\"COLOR_CYAN\",        COLOR_CYAN);\n    SetDictInt(\"COLOR_WHITE\",       COLOR_WHITE);\n\n#ifdef NCURSES_MOUSE_VERSION\n    /* Mouse-related constants */\n    SetDictInt(\"BUTTON1_PRESSED\",          BUTTON1_PRESSED);\n    SetDictInt(\"BUTTON1_RELEASED\",         BUTTON1_RELEASED);\n    SetDictInt(\"BUTTON1_CLICKED\",          BUTTON1_CLICKED);\n    SetDictInt(\"BUTTON1_DOUBLE_CLICKED\",   BUTTON1_DOUBLE_CLICKED);\n    SetDictInt(\"BUTTON1_TRIPLE_CLICKED\",   BUTTON1_TRIPLE_CLICKED);\n\n    SetDictInt(\"BUTTON2_PRESSED\",          BUTTON2_PRESSED);\n    SetDictInt(\"BUTTON2_RELEASED\",         BUTTON2_RELEASED);\n    SetDictInt(\"BUTTON2_CLICKED\",          BUTTON2_CLICKED);\n    SetDictInt(\"BUTTON2_DOUBLE_CLICKED\",   BUTTON2_DOUBLE_CLICKED);\n    SetDictInt(\"BUTTON2_TRIPLE_CLICKED\",   BUTTON2_TRIPLE_CLICKED);\n\n    SetDictInt(\"BUTTON3_PRESSED\",          BUTTON3_PRESSED);\n    SetDictInt(\"BUTTON3_RELEASED\",         BUTTON3_RELEASED);\n    SetDictInt(\"BUTTON3_CLICKED\",          BUTTON3_CLICKED);\n    SetDictInt(\"BUTTON3_DOUBLE_CLICKED\",   BUTTON3_DOUBLE_CLICKED);\n    SetDictInt(\"BUTTON3_TRIPLE_CLICKED\",   BUTTON3_TRIPLE_CLICKED);\n\n    SetDictInt(\"BUTTON4_PRESSED\",          BUTTON4_PRESSED);\n    SetDictInt(\"BUTTON4_RELEASED\",         BUTTON4_RELEASED);\n    SetDictInt(\"BUTTON4_CLICKED\",          BUTTON4_CLICKED);\n    SetDictInt(\"BUTTON4_DOUBLE_CLICKED\",   BUTTON4_DOUBLE_CLICKED);\n    SetDictInt(\"BUTTON4_TRIPLE_CLICKED\",   BUTTON4_TRIPLE_CLICKED);\n\n#if NCURSES_MOUSE_VERSION > 1\n    SetDictInt(\"BUTTON5_PRESSED\",          BUTTON5_PRESSED);\n    SetDictInt(\"BUTTON5_RELEASED\",         BUTTON5_RELEASED);\n    SetDictInt(\"BUTTON5_CLICKED\",          BUTTON5_CLICKED);\n    SetDictInt(\"BUTTON5_DOUBLE_CLICKED\",   BUTTON5_DOUBLE_CLICKED);\n    SetDictInt(\"BUTTON5_TRIPLE_CLICKED\",   BUTTON5_TRIPLE_CLICKED);\n#endif\n\n    SetDictInt(\"BUTTON_SHIFT\",             BUTTON_SHIFT);\n    SetDictInt(\"BUTTON_CTRL\",              BUTTON_CTRL);\n    SetDictInt(\"BUTTON_ALT\",               BUTTON_ALT);\n\n    SetDictInt(\"ALL_MOUSE_EVENTS\",         ALL_MOUSE_EVENTS);\n    SetDictInt(\"REPORT_MOUSE_POSITION\",    REPORT_MOUSE_POSITION);\n#endif\n    /* Now set everything up for KEY_ variables */\n    {\n        int key;\n        char *key_n;\n        char *key_n2;\n        for (key=KEY_MIN;key < KEY_MAX; key++) {\n            key_n = (char *)keyname(key);\n            if (key_n == NULL || strcmp(key_n,\"UNKNOWN KEY\")==0)\n                continue;\n            if (strncmp(key_n,\"KEY_F(\",6)==0) {\n                char *p1, *p2;\n                key_n2 = PyMem_Malloc(strlen(key_n)+1);\n                if (!key_n2) {\n                    PyErr_NoMemory();\n                    break;\n                }\n                p1 = key_n;\n                p2 = key_n2;\n                while (*p1) {\n                    if (*p1 != '(' && *p1 != ')') {\n                        *p2 = *p1;\n                        p2++;\n                    }\n                    p1++;\n                }\n                *p2 = (char)0;\n            } else\n                key_n2 = key_n;\n            SetDictInt(key_n2,key);\n            if (key_n2 != key_n)\n                PyMem_Free(key_n2);\n        }\n        SetDictInt(\"KEY_MIN\", KEY_MIN);\n        SetDictInt(\"KEY_MAX\", KEY_MAX);\n    }\n\n    if (PyModule_AddType(m, &PyCursesWindow_Type) < 0) {\n        return NULL;\n    }\n    return m;\n}\n"}, "sourceLanguage": "c"}, {"location": {"uri": "./Modules/clinic/_cursesmodule.c.h", "uriBaseId": "PWD"}, "contents": {"text": "/*[clinic input]\npreserve\n[clinic start generated code]*/\n\n#if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n#  include \"pycore_gc.h\"            // PyGC_Head\n#  include \"pycore_runtime.h\"       // _Py_ID()\n#endif\n\n\nPyDoc_STRVAR(_curses_window_addch__doc__,\n\"addch([y, x,] ch, [attr=_curses.A_NORMAL])\\n\"\n\"Paint the character.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Y-coordinate.\\n\"\n\"  x\\n\"\n\"    X-coordinate.\\n\"\n\"  ch\\n\"\n\"    Character to add.\\n\"\n\"  attr\\n\"\n\"    Attributes for the character.\\n\"\n\"\\n\"\n\"Paint character ch at (y, x) with attributes attr,\\n\"\n\"overwriting any character previously painted at that location.\\n\"\n\"By default, the character position and attributes are the\\n\"\n\"current settings for the window object.\");\n\n#define _CURSES_WINDOW_ADDCH_METHODDEF    \\\n    {\"addch\", (PyCFunction)_curses_window_addch, METH_VARARGS, _curses_window_addch__doc__},\n\nstatic PyObject *\n_curses_window_addch_impl(PyCursesWindowObject *self, int group_left_1,\n                          int y, int x, PyObject *ch, int group_right_1,\n                          long attr);\n\nstatic PyObject *\n_curses_window_addch(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_left_1 = 0;\n    int y = 0;\n    int x = 0;\n    PyObject *ch;\n    int group_right_1 = 0;\n    long attr = A_NORMAL;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 1:\n            if (!PyArg_ParseTuple(args, \"O:addch\", &ch)) {\n                goto exit;\n            }\n            break;\n        case 2:\n            if (!PyArg_ParseTuple(args, \"Ol:addch\", &ch, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        case 3:\n            if (!PyArg_ParseTuple(args, \"iiO:addch\", &y, &x, &ch)) {\n                goto exit;\n            }\n            group_left_1 = 1;\n            break;\n        case 4:\n            if (!PyArg_ParseTuple(args, \"iiOl:addch\", &y, &x, &ch, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            group_left_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.addch requires 1 to 4 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_addch_impl(self, group_left_1, y, x, ch, group_right_1, attr);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_addstr__doc__,\n\"addstr([y, x,] str, [attr])\\n\"\n\"Paint the string.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Y-coordinate.\\n\"\n\"  x\\n\"\n\"    X-coordinate.\\n\"\n\"  str\\n\"\n\"    String to add.\\n\"\n\"  attr\\n\"\n\"    Attributes for characters.\\n\"\n\"\\n\"\n\"Paint the string str at (y, x) with attributes attr,\\n\"\n\"overwriting anything previously on the display.\\n\"\n\"By default, the character position and attributes are the\\n\"\n\"current settings for the window object.\");\n\n#define _CURSES_WINDOW_ADDSTR_METHODDEF    \\\n    {\"addstr\", (PyCFunction)_curses_window_addstr, METH_VARARGS, _curses_window_addstr__doc__},\n\nstatic PyObject *\n_curses_window_addstr_impl(PyCursesWindowObject *self, int group_left_1,\n                           int y, int x, PyObject *str, int group_right_1,\n                           long attr);\n\nstatic PyObject *\n_curses_window_addstr(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_left_1 = 0;\n    int y = 0;\n    int x = 0;\n    PyObject *str;\n    int group_right_1 = 0;\n    long attr = 0;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 1:\n            if (!PyArg_ParseTuple(args, \"O:addstr\", &str)) {\n                goto exit;\n            }\n            break;\n        case 2:\n            if (!PyArg_ParseTuple(args, \"Ol:addstr\", &str, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        case 3:\n            if (!PyArg_ParseTuple(args, \"iiO:addstr\", &y, &x, &str)) {\n                goto exit;\n            }\n            group_left_1 = 1;\n            break;\n        case 4:\n            if (!PyArg_ParseTuple(args, \"iiOl:addstr\", &y, &x, &str, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            group_left_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.addstr requires 1 to 4 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_addstr_impl(self, group_left_1, y, x, str, group_right_1, attr);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_addnstr__doc__,\n\"addnstr([y, x,] str, n, [attr])\\n\"\n\"Paint at most n characters of the string.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Y-coordinate.\\n\"\n\"  x\\n\"\n\"    X-coordinate.\\n\"\n\"  str\\n\"\n\"    String to add.\\n\"\n\"  n\\n\"\n\"    Maximal number of characters.\\n\"\n\"  attr\\n\"\n\"    Attributes for characters.\\n\"\n\"\\n\"\n\"Paint at most n characters of the string str at (y, x) with\\n\"\n\"attributes attr, overwriting anything previously on the display.\\n\"\n\"By default, the character position and attributes are the\\n\"\n\"current settings for the window object.\");\n\n#define _CURSES_WINDOW_ADDNSTR_METHODDEF    \\\n    {\"addnstr\", (PyCFunction)_curses_window_addnstr, METH_VARARGS, _curses_window_addnstr__doc__},\n\nstatic PyObject *\n_curses_window_addnstr_impl(PyCursesWindowObject *self, int group_left_1,\n                            int y, int x, PyObject *str, int n,\n                            int group_right_1, long attr);\n\nstatic PyObject *\n_curses_window_addnstr(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_left_1 = 0;\n    int y = 0;\n    int x = 0;\n    PyObject *str;\n    int n;\n    int group_right_1 = 0;\n    long attr = 0;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 2:\n            if (!PyArg_ParseTuple(args, \"Oi:addnstr\", &str, &n)) {\n                goto exit;\n            }\n            break;\n        case 3:\n            if (!PyArg_ParseTuple(args, \"Oil:addnstr\", &str, &n, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        case 4:\n            if (!PyArg_ParseTuple(args, \"iiOi:addnstr\", &y, &x, &str, &n)) {\n                goto exit;\n            }\n            group_left_1 = 1;\n            break;\n        case 5:\n            if (!PyArg_ParseTuple(args, \"iiOil:addnstr\", &y, &x, &str, &n, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            group_left_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.addnstr requires 2 to 5 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_addnstr_impl(self, group_left_1, y, x, str, n, group_right_1, attr);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_bkgd__doc__,\n\"bkgd($self, ch, attr=_curses.A_NORMAL, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the background property of the window.\\n\"\n\"\\n\"\n\"  ch\\n\"\n\"    Background character.\\n\"\n\"  attr\\n\"\n\"    Background attributes.\");\n\n#define _CURSES_WINDOW_BKGD_METHODDEF    \\\n    {\"bkgd\", _PyCFunction_CAST(_curses_window_bkgd), METH_FASTCALL, _curses_window_bkgd__doc__},\n\nstatic PyObject *\n_curses_window_bkgd_impl(PyCursesWindowObject *self, PyObject *ch, long attr);\n\nstatic PyObject *\n_curses_window_bkgd(PyCursesWindowObject *self, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    PyObject *ch;\n    long attr = A_NORMAL;\n\n    if (!_PyArg_CheckPositional(\"bkgd\", nargs, 1, 2)) {\n        goto exit;\n    }\n    ch = args[0];\n    if (nargs < 2) {\n        goto skip_optional;\n    }\n    attr = PyLong_AsLong(args[1]);\n    if (attr == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional:\n    return_value = _curses_window_bkgd_impl(self, ch, attr);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_attroff__doc__,\n\"attroff($self, attr, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Remove attribute attr from the \\\"background\\\" set.\");\n\n#define _CURSES_WINDOW_ATTROFF_METHODDEF    \\\n    {\"attroff\", (PyCFunction)_curses_window_attroff, METH_O, _curses_window_attroff__doc__},\n\nstatic PyObject *\n_curses_window_attroff_impl(PyCursesWindowObject *self, long attr);\n\nstatic PyObject *\n_curses_window_attroff(PyCursesWindowObject *self, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    long attr;\n\n    attr = PyLong_AsLong(arg);\n    if (attr == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_window_attroff_impl(self, attr);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_attron__doc__,\n\"attron($self, attr, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Add attribute attr from the \\\"background\\\" set.\");\n\n#define _CURSES_WINDOW_ATTRON_METHODDEF    \\\n    {\"attron\", (PyCFunction)_curses_window_attron, METH_O, _curses_window_attron__doc__},\n\nstatic PyObject *\n_curses_window_attron_impl(PyCursesWindowObject *self, long attr);\n\nstatic PyObject *\n_curses_window_attron(PyCursesWindowObject *self, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    long attr;\n\n    attr = PyLong_AsLong(arg);\n    if (attr == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_window_attron_impl(self, attr);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_attrset__doc__,\n\"attrset($self, attr, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the \\\"background\\\" set of attributes.\");\n\n#define _CURSES_WINDOW_ATTRSET_METHODDEF    \\\n    {\"attrset\", (PyCFunction)_curses_window_attrset, METH_O, _curses_window_attrset__doc__},\n\nstatic PyObject *\n_curses_window_attrset_impl(PyCursesWindowObject *self, long attr);\n\nstatic PyObject *\n_curses_window_attrset(PyCursesWindowObject *self, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    long attr;\n\n    attr = PyLong_AsLong(arg);\n    if (attr == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_window_attrset_impl(self, attr);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_bkgdset__doc__,\n\"bkgdset($self, ch, attr=_curses.A_NORMAL, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the window\\'s background.\\n\"\n\"\\n\"\n\"  ch\\n\"\n\"    Background character.\\n\"\n\"  attr\\n\"\n\"    Background attributes.\");\n\n#define _CURSES_WINDOW_BKGDSET_METHODDEF    \\\n    {\"bkgdset\", _PyCFunction_CAST(_curses_window_bkgdset), METH_FASTCALL, _curses_window_bkgdset__doc__},\n\nstatic PyObject *\n_curses_window_bkgdset_impl(PyCursesWindowObject *self, PyObject *ch,\n                            long attr);\n\nstatic PyObject *\n_curses_window_bkgdset(PyCursesWindowObject *self, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    PyObject *ch;\n    long attr = A_NORMAL;\n\n    if (!_PyArg_CheckPositional(\"bkgdset\", nargs, 1, 2)) {\n        goto exit;\n    }\n    ch = args[0];\n    if (nargs < 2) {\n        goto skip_optional;\n    }\n    attr = PyLong_AsLong(args[1]);\n    if (attr == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional:\n    return_value = _curses_window_bkgdset_impl(self, ch, attr);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_border__doc__,\n\"border($self, ls=_curses.ACS_VLINE, rs=_curses.ACS_VLINE,\\n\"\n\"       ts=_curses.ACS_HLINE, bs=_curses.ACS_HLINE,\\n\"\n\"       tl=_curses.ACS_ULCORNER, tr=_curses.ACS_URCORNER,\\n\"\n\"       bl=_curses.ACS_LLCORNER, br=_curses.ACS_LRCORNER, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Draw a border around the edges of the window.\\n\"\n\"\\n\"\n\"  ls\\n\"\n\"    Left side.\\n\"\n\"  rs\\n\"\n\"    Right side.\\n\"\n\"  ts\\n\"\n\"    Top side.\\n\"\n\"  bs\\n\"\n\"    Bottom side.\\n\"\n\"  tl\\n\"\n\"    Upper-left corner.\\n\"\n\"  tr\\n\"\n\"    Upper-right corner.\\n\"\n\"  bl\\n\"\n\"    Bottom-left corner.\\n\"\n\"  br\\n\"\n\"    Bottom-right corner.\\n\"\n\"\\n\"\n\"Each parameter specifies the character to use for a specific part of the\\n\"\n\"border.  The characters can be specified as integers or as one-character\\n\"\n\"strings.  A 0 value for any parameter will cause the default character to be\\n\"\n\"used for that parameter.\");\n\n#define _CURSES_WINDOW_BORDER_METHODDEF    \\\n    {\"border\", _PyCFunction_CAST(_curses_window_border), METH_FASTCALL, _curses_window_border__doc__},\n\nstatic PyObject *\n_curses_window_border_impl(PyCursesWindowObject *self, PyObject *ls,\n                           PyObject *rs, PyObject *ts, PyObject *bs,\n                           PyObject *tl, PyObject *tr, PyObject *bl,\n                           PyObject *br);\n\nstatic PyObject *\n_curses_window_border(PyCursesWindowObject *self, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    PyObject *ls = NULL;\n    PyObject *rs = NULL;\n    PyObject *ts = NULL;\n    PyObject *bs = NULL;\n    PyObject *tl = NULL;\n    PyObject *tr = NULL;\n    PyObject *bl = NULL;\n    PyObject *br = NULL;\n\n    if (!_PyArg_CheckPositional(\"border\", nargs, 0, 8)) {\n        goto exit;\n    }\n    if (nargs < 1) {\n        goto skip_optional;\n    }\n    ls = args[0];\n    if (nargs < 2) {\n        goto skip_optional;\n    }\n    rs = args[1];\n    if (nargs < 3) {\n        goto skip_optional;\n    }\n    ts = args[2];\n    if (nargs < 4) {\n        goto skip_optional;\n    }\n    bs = args[3];\n    if (nargs < 5) {\n        goto skip_optional;\n    }\n    tl = args[4];\n    if (nargs < 6) {\n        goto skip_optional;\n    }\n    tr = args[5];\n    if (nargs < 7) {\n        goto skip_optional;\n    }\n    bl = args[6];\n    if (nargs < 8) {\n        goto skip_optional;\n    }\n    br = args[7];\nskip_optional:\n    return_value = _curses_window_border_impl(self, ls, rs, ts, bs, tl, tr, bl, br);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_box__doc__,\n\"box([verch=0, horch=0])\\n\"\n\"Draw a border around the edges of the window.\\n\"\n\"\\n\"\n\"  verch\\n\"\n\"    Left and right side.\\n\"\n\"  horch\\n\"\n\"    Top and bottom side.\\n\"\n\"\\n\"\n\"Similar to border(), but both ls and rs are verch and both ts and bs are\\n\"\n\"horch.  The default corner characters are always used by this function.\");\n\n#define _CURSES_WINDOW_BOX_METHODDEF    \\\n    {\"box\", (PyCFunction)_curses_window_box, METH_VARARGS, _curses_window_box__doc__},\n\nstatic PyObject *\n_curses_window_box_impl(PyCursesWindowObject *self, int group_right_1,\n                        PyObject *verch, PyObject *horch);\n\nstatic PyObject *\n_curses_window_box(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_right_1 = 0;\n    PyObject *verch = _PyLong_GetZero();\n    PyObject *horch = _PyLong_GetZero();\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 0:\n            break;\n        case 2:\n            if (!PyArg_ParseTuple(args, \"OO:box\", &verch, &horch)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.box requires 0 to 2 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_box_impl(self, group_right_1, verch, horch);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_delch__doc__,\n\"delch([y, x])\\n\"\n\"Delete any character at (y, x).\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Y-coordinate.\\n\"\n\"  x\\n\"\n\"    X-coordinate.\");\n\n#define _CURSES_WINDOW_DELCH_METHODDEF    \\\n    {\"delch\", (PyCFunction)_curses_window_delch, METH_VARARGS, _curses_window_delch__doc__},\n\nstatic PyObject *\n_curses_window_delch_impl(PyCursesWindowObject *self, int group_right_1,\n                          int y, int x);\n\nstatic PyObject *\n_curses_window_delch(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_right_1 = 0;\n    int y = 0;\n    int x = 0;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 0:\n            break;\n        case 2:\n            if (!PyArg_ParseTuple(args, \"ii:delch\", &y, &x)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.delch requires 0 to 2 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_delch_impl(self, group_right_1, y, x);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_derwin__doc__,\n\"derwin([nlines=0, ncols=0,] begin_y, begin_x)\\n\"\n\"Create a sub-window (window-relative coordinates).\\n\"\n\"\\n\"\n\"  nlines\\n\"\n\"    Height.\\n\"\n\"  ncols\\n\"\n\"    Width.\\n\"\n\"  begin_y\\n\"\n\"    Top side y-coordinate.\\n\"\n\"  begin_x\\n\"\n\"    Left side x-coordinate.\\n\"\n\"\\n\"\n\"derwin() is the same as calling subwin(), except that begin_y and begin_x\\n\"\n\"are relative to the origin of the window, rather than relative to the entire\\n\"\n\"screen.\");\n\n#define _CURSES_WINDOW_DERWIN_METHODDEF    \\\n    {\"derwin\", (PyCFunction)_curses_window_derwin, METH_VARARGS, _curses_window_derwin__doc__},\n\nstatic PyObject *\n_curses_window_derwin_impl(PyCursesWindowObject *self, int group_left_1,\n                           int nlines, int ncols, int begin_y, int begin_x);\n\nstatic PyObject *\n_curses_window_derwin(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_left_1 = 0;\n    int nlines = 0;\n    int ncols = 0;\n    int begin_y;\n    int begin_x;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 2:\n            if (!PyArg_ParseTuple(args, \"ii:derwin\", &begin_y, &begin_x)) {\n                goto exit;\n            }\n            break;\n        case 4:\n            if (!PyArg_ParseTuple(args, \"iiii:derwin\", &nlines, &ncols, &begin_y, &begin_x)) {\n                goto exit;\n            }\n            group_left_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.derwin requires 2 to 4 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_derwin_impl(self, group_left_1, nlines, ncols, begin_y, begin_x);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_echochar__doc__,\n\"echochar($self, ch, attr=_curses.A_NORMAL, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Add character ch with attribute attr, and refresh.\\n\"\n\"\\n\"\n\"  ch\\n\"\n\"    Character to add.\\n\"\n\"  attr\\n\"\n\"    Attributes for the character.\");\n\n#define _CURSES_WINDOW_ECHOCHAR_METHODDEF    \\\n    {\"echochar\", _PyCFunction_CAST(_curses_window_echochar), METH_FASTCALL, _curses_window_echochar__doc__},\n\nstatic PyObject *\n_curses_window_echochar_impl(PyCursesWindowObject *self, PyObject *ch,\n                             long attr);\n\nstatic PyObject *\n_curses_window_echochar(PyCursesWindowObject *self, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    PyObject *ch;\n    long attr = A_NORMAL;\n\n    if (!_PyArg_CheckPositional(\"echochar\", nargs, 1, 2)) {\n        goto exit;\n    }\n    ch = args[0];\n    if (nargs < 2) {\n        goto skip_optional;\n    }\n    attr = PyLong_AsLong(args[1]);\n    if (attr == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional:\n    return_value = _curses_window_echochar_impl(self, ch, attr);\n\nexit:\n    return return_value;\n}\n\n#if defined(NCURSES_MOUSE_VERSION)\n\nPyDoc_STRVAR(_curses_window_enclose__doc__,\n\"enclose($self, y, x, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the screen-relative coordinates are enclosed by the window.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Y-coordinate.\\n\"\n\"  x\\n\"\n\"    X-coordinate.\");\n\n#define _CURSES_WINDOW_ENCLOSE_METHODDEF    \\\n    {\"enclose\", _PyCFunction_CAST(_curses_window_enclose), METH_FASTCALL, _curses_window_enclose__doc__},\n\nstatic PyObject *\n_curses_window_enclose_impl(PyCursesWindowObject *self, int y, int x);\n\nstatic PyObject *\n_curses_window_enclose(PyCursesWindowObject *self, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int y;\n    int x;\n\n    if (!_PyArg_CheckPositional(\"enclose\", nargs, 2, 2)) {\n        goto exit;\n    }\n    y = _PyLong_AsInt(args[0]);\n    if (y == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    x = _PyLong_AsInt(args[1]);\n    if (x == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_window_enclose_impl(self, y, x);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(NCURSES_MOUSE_VERSION) */\n\nPyDoc_STRVAR(_curses_window_getbkgd__doc__,\n\"getbkgd($self, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the window\\'s current background character/attribute pair.\");\n\n#define _CURSES_WINDOW_GETBKGD_METHODDEF    \\\n    {\"getbkgd\", (PyCFunction)_curses_window_getbkgd, METH_NOARGS, _curses_window_getbkgd__doc__},\n\nstatic long\n_curses_window_getbkgd_impl(PyCursesWindowObject *self);\n\nstatic PyObject *\n_curses_window_getbkgd(PyCursesWindowObject *self, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *return_value = NULL;\n    long _return_value;\n\n    _return_value = _curses_window_getbkgd_impl(self);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong(_return_value);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_getch__doc__,\n\"getch([y, x])\\n\"\n\"Get a character code from terminal keyboard.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Y-coordinate.\\n\"\n\"  x\\n\"\n\"    X-coordinate.\\n\"\n\"\\n\"\n\"The integer returned does not have to be in ASCII range: function keys,\\n\"\n\"keypad keys and so on return numbers higher than 256.  In no-delay mode, -1\\n\"\n\"is returned if there is no input, else getch() waits until a key is pressed.\");\n\n#define _CURSES_WINDOW_GETCH_METHODDEF    \\\n    {\"getch\", (PyCFunction)_curses_window_getch, METH_VARARGS, _curses_window_getch__doc__},\n\nstatic int\n_curses_window_getch_impl(PyCursesWindowObject *self, int group_right_1,\n                          int y, int x);\n\nstatic PyObject *\n_curses_window_getch(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_right_1 = 0;\n    int y = 0;\n    int x = 0;\n    int _return_value;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 0:\n            break;\n        case 2:\n            if (!PyArg_ParseTuple(args, \"ii:getch\", &y, &x)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.getch requires 0 to 2 arguments\");\n            goto exit;\n    }\n    _return_value = _curses_window_getch_impl(self, group_right_1, y, x);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_getkey__doc__,\n\"getkey([y, x])\\n\"\n\"Get a character (string) from terminal keyboard.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Y-coordinate.\\n\"\n\"  x\\n\"\n\"    X-coordinate.\\n\"\n\"\\n\"\n\"Returning a string instead of an integer, as getch() does.  Function keys,\\n\"\n\"keypad keys and other special keys return a multibyte string containing the\\n\"\n\"key name.  In no-delay mode, an exception is raised if there is no input.\");\n\n#define _CURSES_WINDOW_GETKEY_METHODDEF    \\\n    {\"getkey\", (PyCFunction)_curses_window_getkey, METH_VARARGS, _curses_window_getkey__doc__},\n\nstatic PyObject *\n_curses_window_getkey_impl(PyCursesWindowObject *self, int group_right_1,\n                           int y, int x);\n\nstatic PyObject *\n_curses_window_getkey(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_right_1 = 0;\n    int y = 0;\n    int x = 0;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 0:\n            break;\n        case 2:\n            if (!PyArg_ParseTuple(args, \"ii:getkey\", &y, &x)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.getkey requires 0 to 2 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_getkey_impl(self, group_right_1, y, x);\n\nexit:\n    return return_value;\n}\n\n#if defined(HAVE_NCURSESW)\n\nPyDoc_STRVAR(_curses_window_get_wch__doc__,\n\"get_wch([y, x])\\n\"\n\"Get a wide character from terminal keyboard.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Y-coordinate.\\n\"\n\"  x\\n\"\n\"    X-coordinate.\\n\"\n\"\\n\"\n\"Return a character for most keys, or an integer for function keys,\\n\"\n\"keypad keys, and other special keys.\");\n\n#define _CURSES_WINDOW_GET_WCH_METHODDEF    \\\n    {\"get_wch\", (PyCFunction)_curses_window_get_wch, METH_VARARGS, _curses_window_get_wch__doc__},\n\nstatic PyObject *\n_curses_window_get_wch_impl(PyCursesWindowObject *self, int group_right_1,\n                            int y, int x);\n\nstatic PyObject *\n_curses_window_get_wch(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_right_1 = 0;\n    int y = 0;\n    int x = 0;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 0:\n            break;\n        case 2:\n            if (!PyArg_ParseTuple(args, \"ii:get_wch\", &y, &x)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.get_wch requires 0 to 2 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_get_wch_impl(self, group_right_1, y, x);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_NCURSESW) */\n\nPyDoc_STRVAR(_curses_window_hline__doc__,\n\"hline([y, x,] ch, n, [attr=_curses.A_NORMAL])\\n\"\n\"Display a horizontal line.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Starting Y-coordinate.\\n\"\n\"  x\\n\"\n\"    Starting X-coordinate.\\n\"\n\"  ch\\n\"\n\"    Character to draw.\\n\"\n\"  n\\n\"\n\"    Line length.\\n\"\n\"  attr\\n\"\n\"    Attributes for the characters.\");\n\n#define _CURSES_WINDOW_HLINE_METHODDEF    \\\n    {\"hline\", (PyCFunction)_curses_window_hline, METH_VARARGS, _curses_window_hline__doc__},\n\nstatic PyObject *\n_curses_window_hline_impl(PyCursesWindowObject *self, int group_left_1,\n                          int y, int x, PyObject *ch, int n,\n                          int group_right_1, long attr);\n\nstatic PyObject *\n_curses_window_hline(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_left_1 = 0;\n    int y = 0;\n    int x = 0;\n    PyObject *ch;\n    int n;\n    int group_right_1 = 0;\n    long attr = A_NORMAL;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 2:\n            if (!PyArg_ParseTuple(args, \"Oi:hline\", &ch, &n)) {\n                goto exit;\n            }\n            break;\n        case 3:\n            if (!PyArg_ParseTuple(args, \"Oil:hline\", &ch, &n, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        case 4:\n            if (!PyArg_ParseTuple(args, \"iiOi:hline\", &y, &x, &ch, &n)) {\n                goto exit;\n            }\n            group_left_1 = 1;\n            break;\n        case 5:\n            if (!PyArg_ParseTuple(args, \"iiOil:hline\", &y, &x, &ch, &n, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            group_left_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.hline requires 2 to 5 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_hline_impl(self, group_left_1, y, x, ch, n, group_right_1, attr);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_insch__doc__,\n\"insch([y, x,] ch, [attr=_curses.A_NORMAL])\\n\"\n\"Insert a character before the current or specified position.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Y-coordinate.\\n\"\n\"  x\\n\"\n\"    X-coordinate.\\n\"\n\"  ch\\n\"\n\"    Character to insert.\\n\"\n\"  attr\\n\"\n\"    Attributes for the character.\\n\"\n\"\\n\"\n\"All characters to the right of the cursor are shifted one position right, with\\n\"\n\"the rightmost characters on the line being lost.\");\n\n#define _CURSES_WINDOW_INSCH_METHODDEF    \\\n    {\"insch\", (PyCFunction)_curses_window_insch, METH_VARARGS, _curses_window_insch__doc__},\n\nstatic PyObject *\n_curses_window_insch_impl(PyCursesWindowObject *self, int group_left_1,\n                          int y, int x, PyObject *ch, int group_right_1,\n                          long attr);\n\nstatic PyObject *\n_curses_window_insch(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_left_1 = 0;\n    int y = 0;\n    int x = 0;\n    PyObject *ch;\n    int group_right_1 = 0;\n    long attr = A_NORMAL;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 1:\n            if (!PyArg_ParseTuple(args, \"O:insch\", &ch)) {\n                goto exit;\n            }\n            break;\n        case 2:\n            if (!PyArg_ParseTuple(args, \"Ol:insch\", &ch, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        case 3:\n            if (!PyArg_ParseTuple(args, \"iiO:insch\", &y, &x, &ch)) {\n                goto exit;\n            }\n            group_left_1 = 1;\n            break;\n        case 4:\n            if (!PyArg_ParseTuple(args, \"iiOl:insch\", &y, &x, &ch, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            group_left_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.insch requires 1 to 4 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_insch_impl(self, group_left_1, y, x, ch, group_right_1, attr);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_inch__doc__,\n\"inch([y, x])\\n\"\n\"Return the character at the given position in the window.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Y-coordinate.\\n\"\n\"  x\\n\"\n\"    X-coordinate.\\n\"\n\"\\n\"\n\"The bottom 8 bits are the character proper, and upper bits are the attributes.\");\n\n#define _CURSES_WINDOW_INCH_METHODDEF    \\\n    {\"inch\", (PyCFunction)_curses_window_inch, METH_VARARGS, _curses_window_inch__doc__},\n\nstatic unsigned long\n_curses_window_inch_impl(PyCursesWindowObject *self, int group_right_1,\n                         int y, int x);\n\nstatic PyObject *\n_curses_window_inch(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_right_1 = 0;\n    int y = 0;\n    int x = 0;\n    unsigned long _return_value;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 0:\n            break;\n        case 2:\n            if (!PyArg_ParseTuple(args, \"ii:inch\", &y, &x)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.inch requires 0 to 2 arguments\");\n            goto exit;\n    }\n    _return_value = _curses_window_inch_impl(self, group_right_1, y, x);\n    if ((_return_value == (unsigned long)-1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromUnsignedLong(_return_value);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_insstr__doc__,\n\"insstr([y, x,] str, [attr])\\n\"\n\"Insert the string before the current or specified position.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Y-coordinate.\\n\"\n\"  x\\n\"\n\"    X-coordinate.\\n\"\n\"  str\\n\"\n\"    String to insert.\\n\"\n\"  attr\\n\"\n\"    Attributes for characters.\\n\"\n\"\\n\"\n\"Insert a character string (as many characters as will fit on the line)\\n\"\n\"before the character under the cursor.  All characters to the right of\\n\"\n\"the cursor are shifted right, with the rightmost characters on the line\\n\"\n\"being lost.  The cursor position does not change (after moving to y, x,\\n\"\n\"if specified).\");\n\n#define _CURSES_WINDOW_INSSTR_METHODDEF    \\\n    {\"insstr\", (PyCFunction)_curses_window_insstr, METH_VARARGS, _curses_window_insstr__doc__},\n\nstatic PyObject *\n_curses_window_insstr_impl(PyCursesWindowObject *self, int group_left_1,\n                           int y, int x, PyObject *str, int group_right_1,\n                           long attr);\n\nstatic PyObject *\n_curses_window_insstr(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_left_1 = 0;\n    int y = 0;\n    int x = 0;\n    PyObject *str;\n    int group_right_1 = 0;\n    long attr = 0;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 1:\n            if (!PyArg_ParseTuple(args, \"O:insstr\", &str)) {\n                goto exit;\n            }\n            break;\n        case 2:\n            if (!PyArg_ParseTuple(args, \"Ol:insstr\", &str, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        case 3:\n            if (!PyArg_ParseTuple(args, \"iiO:insstr\", &y, &x, &str)) {\n                goto exit;\n            }\n            group_left_1 = 1;\n            break;\n        case 4:\n            if (!PyArg_ParseTuple(args, \"iiOl:insstr\", &y, &x, &str, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            group_left_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.insstr requires 1 to 4 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_insstr_impl(self, group_left_1, y, x, str, group_right_1, attr);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_insnstr__doc__,\n\"insnstr([y, x,] str, n, [attr])\\n\"\n\"Insert at most n characters of the string.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Y-coordinate.\\n\"\n\"  x\\n\"\n\"    X-coordinate.\\n\"\n\"  str\\n\"\n\"    String to insert.\\n\"\n\"  n\\n\"\n\"    Maximal number of characters.\\n\"\n\"  attr\\n\"\n\"    Attributes for characters.\\n\"\n\"\\n\"\n\"Insert a character string (as many characters as will fit on the line)\\n\"\n\"before the character under the cursor, up to n characters.  If n is zero\\n\"\n\"or negative, the entire string is inserted.  All characters to the right\\n\"\n\"of the cursor are shifted right, with the rightmost characters on the line\\n\"\n\"being lost.  The cursor position does not change (after moving to y, x, if\\n\"\n\"specified).\");\n\n#define _CURSES_WINDOW_INSNSTR_METHODDEF    \\\n    {\"insnstr\", (PyCFunction)_curses_window_insnstr, METH_VARARGS, _curses_window_insnstr__doc__},\n\nstatic PyObject *\n_curses_window_insnstr_impl(PyCursesWindowObject *self, int group_left_1,\n                            int y, int x, PyObject *str, int n,\n                            int group_right_1, long attr);\n\nstatic PyObject *\n_curses_window_insnstr(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_left_1 = 0;\n    int y = 0;\n    int x = 0;\n    PyObject *str;\n    int n;\n    int group_right_1 = 0;\n    long attr = 0;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 2:\n            if (!PyArg_ParseTuple(args, \"Oi:insnstr\", &str, &n)) {\n                goto exit;\n            }\n            break;\n        case 3:\n            if (!PyArg_ParseTuple(args, \"Oil:insnstr\", &str, &n, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        case 4:\n            if (!PyArg_ParseTuple(args, \"iiOi:insnstr\", &y, &x, &str, &n)) {\n                goto exit;\n            }\n            group_left_1 = 1;\n            break;\n        case 5:\n            if (!PyArg_ParseTuple(args, \"iiOil:insnstr\", &y, &x, &str, &n, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            group_left_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.insnstr requires 2 to 5 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_insnstr_impl(self, group_left_1, y, x, str, n, group_right_1, attr);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_is_linetouched__doc__,\n\"is_linetouched($self, line, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the specified line was modified, otherwise return False.\\n\"\n\"\\n\"\n\"  line\\n\"\n\"    Line number.\\n\"\n\"\\n\"\n\"Raise a curses.error exception if line is not valid for the given window.\");\n\n#define _CURSES_WINDOW_IS_LINETOUCHED_METHODDEF    \\\n    {\"is_linetouched\", (PyCFunction)_curses_window_is_linetouched, METH_O, _curses_window_is_linetouched__doc__},\n\nstatic PyObject *\n_curses_window_is_linetouched_impl(PyCursesWindowObject *self, int line);\n\nstatic PyObject *\n_curses_window_is_linetouched(PyCursesWindowObject *self, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int line;\n\n    line = _PyLong_AsInt(arg);\n    if (line == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_window_is_linetouched_impl(self, line);\n\nexit:\n    return return_value;\n}\n\n#if defined(py_is_pad)\n\nPyDoc_STRVAR(_curses_window_noutrefresh__doc__,\n\"noutrefresh([pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol])\\n\"\n\"Mark for refresh but wait.\\n\"\n\"\\n\"\n\"This function updates the data structure representing the desired state of the\\n\"\n\"window, but does not force an update of the physical screen.  To accomplish\\n\"\n\"that, call doupdate().\");\n\n#define _CURSES_WINDOW_NOUTREFRESH_METHODDEF    \\\n    {\"noutrefresh\", (PyCFunction)_curses_window_noutrefresh, METH_VARARGS, _curses_window_noutrefresh__doc__},\n\nstatic PyObject *\n_curses_window_noutrefresh_impl(PyCursesWindowObject *self,\n                                int group_right_1, int pminrow, int pmincol,\n                                int sminrow, int smincol, int smaxrow,\n                                int smaxcol);\n\nstatic PyObject *\n_curses_window_noutrefresh(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_right_1 = 0;\n    int pminrow = 0;\n    int pmincol = 0;\n    int sminrow = 0;\n    int smincol = 0;\n    int smaxrow = 0;\n    int smaxcol = 0;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 0:\n            break;\n        case 6:\n            if (!PyArg_ParseTuple(args, \"iiiiii:noutrefresh\", &pminrow, &pmincol, &sminrow, &smincol, &smaxrow, &smaxcol)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.noutrefresh requires 0 to 6 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_noutrefresh_impl(self, group_right_1, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(py_is_pad) */\n\n#if !defined(py_is_pad)\n\nPyDoc_STRVAR(_curses_window_noutrefresh__doc__,\n\"noutrefresh($self, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Mark for refresh but wait.\\n\"\n\"\\n\"\n\"This function updates the data structure representing the desired state of the\\n\"\n\"window, but does not force an update of the physical screen.  To accomplish\\n\"\n\"that, call doupdate().\");\n\n#define _CURSES_WINDOW_NOUTREFRESH_METHODDEF    \\\n    {\"noutrefresh\", (PyCFunction)_curses_window_noutrefresh, METH_NOARGS, _curses_window_noutrefresh__doc__},\n\nstatic PyObject *\n_curses_window_noutrefresh_impl(PyCursesWindowObject *self);\n\nstatic PyObject *\n_curses_window_noutrefresh(PyCursesWindowObject *self, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_window_noutrefresh_impl(self);\n}\n\n#endif /* !defined(py_is_pad) */\n\nPyDoc_STRVAR(_curses_window_overlay__doc__,\n\"overlay(destwin, [sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol])\\n\"\n\"Overlay the window on top of destwin.\\n\"\n\"\\n\"\n\"The windows need not be the same size, only the overlapping region is copied.\\n\"\n\"This copy is non-destructive, which means that the current background\\n\"\n\"character does not overwrite the old contents of destwin.\\n\"\n\"\\n\"\n\"To get fine-grained control over the copied region, the second form of\\n\"\n\"overlay() can be used.  sminrow and smincol are the upper-left coordinates\\n\"\n\"of the source window, and the other variables mark a rectangle in the\\n\"\n\"destination window.\");\n\n#define _CURSES_WINDOW_OVERLAY_METHODDEF    \\\n    {\"overlay\", (PyCFunction)_curses_window_overlay, METH_VARARGS, _curses_window_overlay__doc__},\n\nstatic PyObject *\n_curses_window_overlay_impl(PyCursesWindowObject *self,\n                            PyCursesWindowObject *destwin, int group_right_1,\n                            int sminrow, int smincol, int dminrow,\n                            int dmincol, int dmaxrow, int dmaxcol);\n\nstatic PyObject *\n_curses_window_overlay(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    PyCursesWindowObject *destwin;\n    int group_right_1 = 0;\n    int sminrow = 0;\n    int smincol = 0;\n    int dminrow = 0;\n    int dmincol = 0;\n    int dmaxrow = 0;\n    int dmaxcol = 0;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 1:\n            if (!PyArg_ParseTuple(args, \"O!:overlay\", &PyCursesWindow_Type, &destwin)) {\n                goto exit;\n            }\n            break;\n        case 7:\n            if (!PyArg_ParseTuple(args, \"O!iiiiii:overlay\", &PyCursesWindow_Type, &destwin, &sminrow, &smincol, &dminrow, &dmincol, &dmaxrow, &dmaxcol)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.overlay requires 1 to 7 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_overlay_impl(self, destwin, group_right_1, sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_overwrite__doc__,\n\"overwrite(destwin, [sminrow, smincol, dminrow, dmincol, dmaxrow,\\n\"\n\"          dmaxcol])\\n\"\n\"Overwrite the window on top of destwin.\\n\"\n\"\\n\"\n\"The windows need not be the same size, in which case only the overlapping\\n\"\n\"region is copied.  This copy is destructive, which means that the current\\n\"\n\"background character overwrites the old contents of destwin.\\n\"\n\"\\n\"\n\"To get fine-grained control over the copied region, the second form of\\n\"\n\"overwrite() can be used. sminrow and smincol are the upper-left coordinates\\n\"\n\"of the source window, the other variables mark a rectangle in the destination\\n\"\n\"window.\");\n\n#define _CURSES_WINDOW_OVERWRITE_METHODDEF    \\\n    {\"overwrite\", (PyCFunction)_curses_window_overwrite, METH_VARARGS, _curses_window_overwrite__doc__},\n\nstatic PyObject *\n_curses_window_overwrite_impl(PyCursesWindowObject *self,\n                              PyCursesWindowObject *destwin,\n                              int group_right_1, int sminrow, int smincol,\n                              int dminrow, int dmincol, int dmaxrow,\n                              int dmaxcol);\n\nstatic PyObject *\n_curses_window_overwrite(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    PyCursesWindowObject *destwin;\n    int group_right_1 = 0;\n    int sminrow = 0;\n    int smincol = 0;\n    int dminrow = 0;\n    int dmincol = 0;\n    int dmaxrow = 0;\n    int dmaxcol = 0;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 1:\n            if (!PyArg_ParseTuple(args, \"O!:overwrite\", &PyCursesWindow_Type, &destwin)) {\n                goto exit;\n            }\n            break;\n        case 7:\n            if (!PyArg_ParseTuple(args, \"O!iiiiii:overwrite\", &PyCursesWindow_Type, &destwin, &sminrow, &smincol, &dminrow, &dmincol, &dmaxrow, &dmaxcol)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.overwrite requires 1 to 7 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_overwrite_impl(self, destwin, group_right_1, sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_putwin__doc__,\n\"putwin($self, file, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Write all data associated with the window into the provided file object.\\n\"\n\"\\n\"\n\"This information can be later retrieved using the getwin() function.\");\n\n#define _CURSES_WINDOW_PUTWIN_METHODDEF    \\\n    {\"putwin\", (PyCFunction)_curses_window_putwin, METH_O, _curses_window_putwin__doc__},\n\nPyDoc_STRVAR(_curses_window_redrawln__doc__,\n\"redrawln($self, beg, num, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Mark the specified lines corrupted.\\n\"\n\"\\n\"\n\"  beg\\n\"\n\"    Starting line number.\\n\"\n\"  num\\n\"\n\"    The number of lines.\\n\"\n\"\\n\"\n\"They should be completely redrawn on the next refresh() call.\");\n\n#define _CURSES_WINDOW_REDRAWLN_METHODDEF    \\\n    {\"redrawln\", _PyCFunction_CAST(_curses_window_redrawln), METH_FASTCALL, _curses_window_redrawln__doc__},\n\nstatic PyObject *\n_curses_window_redrawln_impl(PyCursesWindowObject *self, int beg, int num);\n\nstatic PyObject *\n_curses_window_redrawln(PyCursesWindowObject *self, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int beg;\n    int num;\n\n    if (!_PyArg_CheckPositional(\"redrawln\", nargs, 2, 2)) {\n        goto exit;\n    }\n    beg = _PyLong_AsInt(args[0]);\n    if (beg == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    num = _PyLong_AsInt(args[1]);\n    if (num == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_window_redrawln_impl(self, beg, num);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_refresh__doc__,\n\"refresh([pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol])\\n\"\n\"Update the display immediately.\\n\"\n\"\\n\"\n\"Synchronize actual screen with previous drawing/deleting methods.\\n\"\n\"The 6 optional arguments can only be specified when the window is a pad\\n\"\n\"created with newpad().  The additional parameters are needed to indicate\\n\"\n\"what part of the pad and screen are involved.  pminrow and pmincol specify\\n\"\n\"the upper left-hand corner of the rectangle to be displayed in the pad.\\n\"\n\"sminrow, smincol, smaxrow, and smaxcol specify the edges of the rectangle to\\n\"\n\"be displayed on the screen.  The lower right-hand corner of the rectangle to\\n\"\n\"be displayed in the pad is calculated from the screen coordinates, since the\\n\"\n\"rectangles must be the same size.  Both rectangles must be entirely contained\\n\"\n\"within their respective structures.  Negative values of pminrow, pmincol,\\n\"\n\"sminrow, or smincol are treated as if they were zero.\");\n\n#define _CURSES_WINDOW_REFRESH_METHODDEF    \\\n    {\"refresh\", (PyCFunction)_curses_window_refresh, METH_VARARGS, _curses_window_refresh__doc__},\n\nstatic PyObject *\n_curses_window_refresh_impl(PyCursesWindowObject *self, int group_right_1,\n                            int pminrow, int pmincol, int sminrow,\n                            int smincol, int smaxrow, int smaxcol);\n\nstatic PyObject *\n_curses_window_refresh(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_right_1 = 0;\n    int pminrow = 0;\n    int pmincol = 0;\n    int sminrow = 0;\n    int smincol = 0;\n    int smaxrow = 0;\n    int smaxcol = 0;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 0:\n            break;\n        case 6:\n            if (!PyArg_ParseTuple(args, \"iiiiii:refresh\", &pminrow, &pmincol, &sminrow, &smincol, &smaxrow, &smaxcol)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.refresh requires 0 to 6 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_refresh_impl(self, group_right_1, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_setscrreg__doc__,\n\"setscrreg($self, top, bottom, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Define a software scrolling region.\\n\"\n\"\\n\"\n\"  top\\n\"\n\"    First line number.\\n\"\n\"  bottom\\n\"\n\"    Last line number.\\n\"\n\"\\n\"\n\"All scrolling actions will take place in this region.\");\n\n#define _CURSES_WINDOW_SETSCRREG_METHODDEF    \\\n    {\"setscrreg\", _PyCFunction_CAST(_curses_window_setscrreg), METH_FASTCALL, _curses_window_setscrreg__doc__},\n\nstatic PyObject *\n_curses_window_setscrreg_impl(PyCursesWindowObject *self, int top,\n                              int bottom);\n\nstatic PyObject *\n_curses_window_setscrreg(PyCursesWindowObject *self, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int top;\n    int bottom;\n\n    if (!_PyArg_CheckPositional(\"setscrreg\", nargs, 2, 2)) {\n        goto exit;\n    }\n    top = _PyLong_AsInt(args[0]);\n    if (top == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    bottom = _PyLong_AsInt(args[1]);\n    if (bottom == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_window_setscrreg_impl(self, top, bottom);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_subwin__doc__,\n\"subwin([nlines=0, ncols=0,] begin_y, begin_x)\\n\"\n\"Create a sub-window (screen-relative coordinates).\\n\"\n\"\\n\"\n\"  nlines\\n\"\n\"    Height.\\n\"\n\"  ncols\\n\"\n\"    Width.\\n\"\n\"  begin_y\\n\"\n\"    Top side y-coordinate.\\n\"\n\"  begin_x\\n\"\n\"    Left side x-coordinate.\\n\"\n\"\\n\"\n\"By default, the sub-window will extend from the specified position to the\\n\"\n\"lower right corner of the window.\");\n\n#define _CURSES_WINDOW_SUBWIN_METHODDEF    \\\n    {\"subwin\", (PyCFunction)_curses_window_subwin, METH_VARARGS, _curses_window_subwin__doc__},\n\nstatic PyObject *\n_curses_window_subwin_impl(PyCursesWindowObject *self, int group_left_1,\n                           int nlines, int ncols, int begin_y, int begin_x);\n\nstatic PyObject *\n_curses_window_subwin(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_left_1 = 0;\n    int nlines = 0;\n    int ncols = 0;\n    int begin_y;\n    int begin_x;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 2:\n            if (!PyArg_ParseTuple(args, \"ii:subwin\", &begin_y, &begin_x)) {\n                goto exit;\n            }\n            break;\n        case 4:\n            if (!PyArg_ParseTuple(args, \"iiii:subwin\", &nlines, &ncols, &begin_y, &begin_x)) {\n                goto exit;\n            }\n            group_left_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.subwin requires 2 to 4 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_subwin_impl(self, group_left_1, nlines, ncols, begin_y, begin_x);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_scroll__doc__,\n\"scroll([lines=1])\\n\"\n\"Scroll the screen or scrolling region.\\n\"\n\"\\n\"\n\"  lines\\n\"\n\"    Number of lines to scroll.\\n\"\n\"\\n\"\n\"Scroll upward if the argument is positive and downward if it is negative.\");\n\n#define _CURSES_WINDOW_SCROLL_METHODDEF    \\\n    {\"scroll\", (PyCFunction)_curses_window_scroll, METH_VARARGS, _curses_window_scroll__doc__},\n\nstatic PyObject *\n_curses_window_scroll_impl(PyCursesWindowObject *self, int group_right_1,\n                           int lines);\n\nstatic PyObject *\n_curses_window_scroll(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_right_1 = 0;\n    int lines = 1;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 0:\n            break;\n        case 1:\n            if (!PyArg_ParseTuple(args, \"i:scroll\", &lines)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.scroll requires 0 to 1 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_scroll_impl(self, group_right_1, lines);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_touchline__doc__,\n\"touchline(start, count, [changed=True])\\n\"\n\"Pretend count lines have been changed, starting with line start.\\n\"\n\"\\n\"\n\"If changed is supplied, it specifies whether the affected lines are marked\\n\"\n\"as having been changed (changed=True) or unchanged (changed=False).\");\n\n#define _CURSES_WINDOW_TOUCHLINE_METHODDEF    \\\n    {\"touchline\", (PyCFunction)_curses_window_touchline, METH_VARARGS, _curses_window_touchline__doc__},\n\nstatic PyObject *\n_curses_window_touchline_impl(PyCursesWindowObject *self, int start,\n                              int count, int group_right_1, int changed);\n\nstatic PyObject *\n_curses_window_touchline(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int start;\n    int count;\n    int group_right_1 = 0;\n    int changed = 1;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 2:\n            if (!PyArg_ParseTuple(args, \"ii:touchline\", &start, &count)) {\n                goto exit;\n            }\n            break;\n        case 3:\n            if (!PyArg_ParseTuple(args, \"iip:touchline\", &start, &count, &changed)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.touchline requires 2 to 3 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_touchline_impl(self, start, count, group_right_1, changed);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_window_vline__doc__,\n\"vline([y, x,] ch, n, [attr=_curses.A_NORMAL])\\n\"\n\"Display a vertical line.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Starting Y-coordinate.\\n\"\n\"  x\\n\"\n\"    Starting X-coordinate.\\n\"\n\"  ch\\n\"\n\"    Character to draw.\\n\"\n\"  n\\n\"\n\"    Line length.\\n\"\n\"  attr\\n\"\n\"    Attributes for the character.\");\n\n#define _CURSES_WINDOW_VLINE_METHODDEF    \\\n    {\"vline\", (PyCFunction)_curses_window_vline, METH_VARARGS, _curses_window_vline__doc__},\n\nstatic PyObject *\n_curses_window_vline_impl(PyCursesWindowObject *self, int group_left_1,\n                          int y, int x, PyObject *ch, int n,\n                          int group_right_1, long attr);\n\nstatic PyObject *\n_curses_window_vline(PyCursesWindowObject *self, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int group_left_1 = 0;\n    int y = 0;\n    int x = 0;\n    PyObject *ch;\n    int n;\n    int group_right_1 = 0;\n    long attr = A_NORMAL;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 2:\n            if (!PyArg_ParseTuple(args, \"Oi:vline\", &ch, &n)) {\n                goto exit;\n            }\n            break;\n        case 3:\n            if (!PyArg_ParseTuple(args, \"Oil:vline\", &ch, &n, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        case 4:\n            if (!PyArg_ParseTuple(args, \"iiOi:vline\", &y, &x, &ch, &n)) {\n                goto exit;\n            }\n            group_left_1 = 1;\n            break;\n        case 5:\n            if (!PyArg_ParseTuple(args, \"iiOil:vline\", &y, &x, &ch, &n, &attr)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            group_left_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.window.vline requires 2 to 5 arguments\");\n            goto exit;\n    }\n    return_value = _curses_window_vline_impl(self, group_left_1, y, x, ch, n, group_right_1, attr);\n\nexit:\n    return return_value;\n}\n\n#if defined(HAVE_CURSES_FILTER)\n\nPyDoc_STRVAR(_curses_filter__doc__,\n\"filter($module, /)\\n\"\n\"--\\n\"\n\"\\n\");\n\n#define _CURSES_FILTER_METHODDEF    \\\n    {\"filter\", (PyCFunction)_curses_filter, METH_NOARGS, _curses_filter__doc__},\n\nstatic PyObject *\n_curses_filter_impl(PyObject *module);\n\nstatic PyObject *\n_curses_filter(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_filter_impl(module);\n}\n\n#endif /* defined(HAVE_CURSES_FILTER) */\n\nPyDoc_STRVAR(_curses_baudrate__doc__,\n\"baudrate($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the output speed of the terminal in bits per second.\");\n\n#define _CURSES_BAUDRATE_METHODDEF    \\\n    {\"baudrate\", (PyCFunction)_curses_baudrate, METH_NOARGS, _curses_baudrate__doc__},\n\nstatic PyObject *\n_curses_baudrate_impl(PyObject *module);\n\nstatic PyObject *\n_curses_baudrate(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_baudrate_impl(module);\n}\n\nPyDoc_STRVAR(_curses_beep__doc__,\n\"beep($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Emit a short attention sound.\");\n\n#define _CURSES_BEEP_METHODDEF    \\\n    {\"beep\", (PyCFunction)_curses_beep, METH_NOARGS, _curses_beep__doc__},\n\nstatic PyObject *\n_curses_beep_impl(PyObject *module);\n\nstatic PyObject *\n_curses_beep(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_beep_impl(module);\n}\n\nPyDoc_STRVAR(_curses_can_change_color__doc__,\n\"can_change_color($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the programmer can change the colors displayed by the terminal.\");\n\n#define _CURSES_CAN_CHANGE_COLOR_METHODDEF    \\\n    {\"can_change_color\", (PyCFunction)_curses_can_change_color, METH_NOARGS, _curses_can_change_color__doc__},\n\nstatic PyObject *\n_curses_can_change_color_impl(PyObject *module);\n\nstatic PyObject *\n_curses_can_change_color(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_can_change_color_impl(module);\n}\n\nPyDoc_STRVAR(_curses_cbreak__doc__,\n\"cbreak($module, flag=True, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Enter cbreak mode.\\n\"\n\"\\n\"\n\"  flag\\n\"\n\"    If false, the effect is the same as calling nocbreak().\\n\"\n\"\\n\"\n\"In cbreak mode (sometimes called \\\"rare\\\" mode) normal tty line buffering is\\n\"\n\"turned off and characters are available to be read one by one.  However,\\n\"\n\"unlike raw mode, special characters (interrupt, quit, suspend, and flow\\n\"\n\"control) retain their effects on the tty driver and calling program.\\n\"\n\"Calling first raw() then cbreak() leaves the terminal in cbreak mode.\");\n\n#define _CURSES_CBREAK_METHODDEF    \\\n    {\"cbreak\", _PyCFunction_CAST(_curses_cbreak), METH_FASTCALL, _curses_cbreak__doc__},\n\nstatic PyObject *\n_curses_cbreak_impl(PyObject *module, int flag);\n\nstatic PyObject *\n_curses_cbreak(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int flag = 1;\n\n    if (!_PyArg_CheckPositional(\"cbreak\", nargs, 0, 1)) {\n        goto exit;\n    }\n    if (nargs < 1) {\n        goto skip_optional;\n    }\n    flag = PyObject_IsTrue(args[0]);\n    if (flag < 0) {\n        goto exit;\n    }\nskip_optional:\n    return_value = _curses_cbreak_impl(module, flag);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_color_content__doc__,\n\"color_content($module, color_number, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the red, green, and blue (RGB) components of the specified color.\\n\"\n\"\\n\"\n\"  color_number\\n\"\n\"    The number of the color (0 - (COLORS-1)).\\n\"\n\"\\n\"\n\"A 3-tuple is returned, containing the R, G, B values for the given color,\\n\"\n\"which will be between 0 (no component) and 1000 (maximum amount of component).\");\n\n#define _CURSES_COLOR_CONTENT_METHODDEF    \\\n    {\"color_content\", (PyCFunction)_curses_color_content, METH_O, _curses_color_content__doc__},\n\nstatic PyObject *\n_curses_color_content_impl(PyObject *module, int color_number);\n\nstatic PyObject *\n_curses_color_content(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int color_number;\n\n    if (!color_converter(arg, &color_number)) {\n        goto exit;\n    }\n    return_value = _curses_color_content_impl(module, color_number);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_color_pair__doc__,\n\"color_pair($module, pair_number, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the attribute value for displaying text in the specified color.\\n\"\n\"\\n\"\n\"  pair_number\\n\"\n\"    The number of the color pair.\\n\"\n\"\\n\"\n\"This attribute value can be combined with A_STANDOUT, A_REVERSE, and the\\n\"\n\"other A_* attributes.  pair_number() is the counterpart to this function.\");\n\n#define _CURSES_COLOR_PAIR_METHODDEF    \\\n    {\"color_pair\", (PyCFunction)_curses_color_pair, METH_O, _curses_color_pair__doc__},\n\nstatic PyObject *\n_curses_color_pair_impl(PyObject *module, int pair_number);\n\nstatic PyObject *\n_curses_color_pair(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int pair_number;\n\n    pair_number = _PyLong_AsInt(arg);\n    if (pair_number == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_color_pair_impl(module, pair_number);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_curs_set__doc__,\n\"curs_set($module, visibility, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the cursor state.\\n\"\n\"\\n\"\n\"  visibility\\n\"\n\"    0 for invisible, 1 for normal visible, or 2 for very visible.\\n\"\n\"\\n\"\n\"If the terminal supports the visibility requested, the previous cursor\\n\"\n\"state is returned; otherwise, an exception is raised.  On many terminals,\\n\"\n\"the \\\"visible\\\" mode is an underline cursor and the \\\"very visible\\\" mode is\\n\"\n\"a block cursor.\");\n\n#define _CURSES_CURS_SET_METHODDEF    \\\n    {\"curs_set\", (PyCFunction)_curses_curs_set, METH_O, _curses_curs_set__doc__},\n\nstatic PyObject *\n_curses_curs_set_impl(PyObject *module, int visibility);\n\nstatic PyObject *\n_curses_curs_set(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int visibility;\n\n    visibility = _PyLong_AsInt(arg);\n    if (visibility == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_curs_set_impl(module, visibility);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_def_prog_mode__doc__,\n\"def_prog_mode($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Save the current terminal mode as the \\\"program\\\" mode.\\n\"\n\"\\n\"\n\"The \\\"program\\\" mode is the mode when the running program is using curses.\\n\"\n\"\\n\"\n\"Subsequent calls to reset_prog_mode() will restore this mode.\");\n\n#define _CURSES_DEF_PROG_MODE_METHODDEF    \\\n    {\"def_prog_mode\", (PyCFunction)_curses_def_prog_mode, METH_NOARGS, _curses_def_prog_mode__doc__},\n\nstatic PyObject *\n_curses_def_prog_mode_impl(PyObject *module);\n\nstatic PyObject *\n_curses_def_prog_mode(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_def_prog_mode_impl(module);\n}\n\nPyDoc_STRVAR(_curses_def_shell_mode__doc__,\n\"def_shell_mode($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Save the current terminal mode as the \\\"shell\\\" mode.\\n\"\n\"\\n\"\n\"The \\\"shell\\\" mode is the mode when the running program is not using curses.\\n\"\n\"\\n\"\n\"Subsequent calls to reset_shell_mode() will restore this mode.\");\n\n#define _CURSES_DEF_SHELL_MODE_METHODDEF    \\\n    {\"def_shell_mode\", (PyCFunction)_curses_def_shell_mode, METH_NOARGS, _curses_def_shell_mode__doc__},\n\nstatic PyObject *\n_curses_def_shell_mode_impl(PyObject *module);\n\nstatic PyObject *\n_curses_def_shell_mode(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_def_shell_mode_impl(module);\n}\n\nPyDoc_STRVAR(_curses_delay_output__doc__,\n\"delay_output($module, ms, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Insert a pause in output.\\n\"\n\"\\n\"\n\"  ms\\n\"\n\"    Duration in milliseconds.\");\n\n#define _CURSES_DELAY_OUTPUT_METHODDEF    \\\n    {\"delay_output\", (PyCFunction)_curses_delay_output, METH_O, _curses_delay_output__doc__},\n\nstatic PyObject *\n_curses_delay_output_impl(PyObject *module, int ms);\n\nstatic PyObject *\n_curses_delay_output(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int ms;\n\n    ms = _PyLong_AsInt(arg);\n    if (ms == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_delay_output_impl(module, ms);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_doupdate__doc__,\n\"doupdate($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Update the physical screen to match the virtual screen.\");\n\n#define _CURSES_DOUPDATE_METHODDEF    \\\n    {\"doupdate\", (PyCFunction)_curses_doupdate, METH_NOARGS, _curses_doupdate__doc__},\n\nstatic PyObject *\n_curses_doupdate_impl(PyObject *module);\n\nstatic PyObject *\n_curses_doupdate(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_doupdate_impl(module);\n}\n\nPyDoc_STRVAR(_curses_echo__doc__,\n\"echo($module, flag=True, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Enter echo mode.\\n\"\n\"\\n\"\n\"  flag\\n\"\n\"    If false, the effect is the same as calling noecho().\\n\"\n\"\\n\"\n\"In echo mode, each character input is echoed to the screen as it is entered.\");\n\n#define _CURSES_ECHO_METHODDEF    \\\n    {\"echo\", _PyCFunction_CAST(_curses_echo), METH_FASTCALL, _curses_echo__doc__},\n\nstatic PyObject *\n_curses_echo_impl(PyObject *module, int flag);\n\nstatic PyObject *\n_curses_echo(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int flag = 1;\n\n    if (!_PyArg_CheckPositional(\"echo\", nargs, 0, 1)) {\n        goto exit;\n    }\n    if (nargs < 1) {\n        goto skip_optional;\n    }\n    flag = PyObject_IsTrue(args[0]);\n    if (flag < 0) {\n        goto exit;\n    }\nskip_optional:\n    return_value = _curses_echo_impl(module, flag);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_endwin__doc__,\n\"endwin($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"De-initialize the library, and return terminal to normal status.\");\n\n#define _CURSES_ENDWIN_METHODDEF    \\\n    {\"endwin\", (PyCFunction)_curses_endwin, METH_NOARGS, _curses_endwin__doc__},\n\nstatic PyObject *\n_curses_endwin_impl(PyObject *module);\n\nstatic PyObject *\n_curses_endwin(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_endwin_impl(module);\n}\n\nPyDoc_STRVAR(_curses_erasechar__doc__,\n\"erasechar($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the user\\'s current erase character.\");\n\n#define _CURSES_ERASECHAR_METHODDEF    \\\n    {\"erasechar\", (PyCFunction)_curses_erasechar, METH_NOARGS, _curses_erasechar__doc__},\n\nstatic PyObject *\n_curses_erasechar_impl(PyObject *module);\n\nstatic PyObject *\n_curses_erasechar(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_erasechar_impl(module);\n}\n\nPyDoc_STRVAR(_curses_flash__doc__,\n\"flash($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Flash the screen.\\n\"\n\"\\n\"\n\"That is, change it to reverse-video and then change it back in a short interval.\");\n\n#define _CURSES_FLASH_METHODDEF    \\\n    {\"flash\", (PyCFunction)_curses_flash, METH_NOARGS, _curses_flash__doc__},\n\nstatic PyObject *\n_curses_flash_impl(PyObject *module);\n\nstatic PyObject *\n_curses_flash(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_flash_impl(module);\n}\n\nPyDoc_STRVAR(_curses_flushinp__doc__,\n\"flushinp($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Flush all input buffers.\\n\"\n\"\\n\"\n\"This throws away any typeahead that has been typed by the user and has not\\n\"\n\"yet been processed by the program.\");\n\n#define _CURSES_FLUSHINP_METHODDEF    \\\n    {\"flushinp\", (PyCFunction)_curses_flushinp, METH_NOARGS, _curses_flushinp__doc__},\n\nstatic PyObject *\n_curses_flushinp_impl(PyObject *module);\n\nstatic PyObject *\n_curses_flushinp(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_flushinp_impl(module);\n}\n\n#if defined(getsyx)\n\nPyDoc_STRVAR(_curses_getsyx__doc__,\n\"getsyx($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the current coordinates of the virtual screen cursor.\\n\"\n\"\\n\"\n\"Return a (y, x) tuple.  If leaveok is currently true, return (-1, -1).\");\n\n#define _CURSES_GETSYX_METHODDEF    \\\n    {\"getsyx\", (PyCFunction)_curses_getsyx, METH_NOARGS, _curses_getsyx__doc__},\n\nstatic PyObject *\n_curses_getsyx_impl(PyObject *module);\n\nstatic PyObject *\n_curses_getsyx(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_getsyx_impl(module);\n}\n\n#endif /* defined(getsyx) */\n\n#if defined(NCURSES_MOUSE_VERSION)\n\nPyDoc_STRVAR(_curses_getmouse__doc__,\n\"getmouse($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Retrieve the queued mouse event.\\n\"\n\"\\n\"\n\"After getch() returns KEY_MOUSE to signal a mouse event, this function\\n\"\n\"returns a 5-tuple (id, x, y, z, bstate).\");\n\n#define _CURSES_GETMOUSE_METHODDEF    \\\n    {\"getmouse\", (PyCFunction)_curses_getmouse, METH_NOARGS, _curses_getmouse__doc__},\n\nstatic PyObject *\n_curses_getmouse_impl(PyObject *module);\n\nstatic PyObject *\n_curses_getmouse(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_getmouse_impl(module);\n}\n\n#endif /* defined(NCURSES_MOUSE_VERSION) */\n\n#if defined(NCURSES_MOUSE_VERSION)\n\nPyDoc_STRVAR(_curses_ungetmouse__doc__,\n\"ungetmouse($module, id, x, y, z, bstate, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Push a KEY_MOUSE event onto the input queue.\\n\"\n\"\\n\"\n\"The following getmouse() will return the given state data.\");\n\n#define _CURSES_UNGETMOUSE_METHODDEF    \\\n    {\"ungetmouse\", _PyCFunction_CAST(_curses_ungetmouse), METH_FASTCALL, _curses_ungetmouse__doc__},\n\nstatic PyObject *\n_curses_ungetmouse_impl(PyObject *module, short id, int x, int y, int z,\n                        unsigned long bstate);\n\nstatic PyObject *\n_curses_ungetmouse(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    short id;\n    int x;\n    int y;\n    int z;\n    unsigned long bstate;\n\n    if (!_PyArg_CheckPositional(\"ungetmouse\", nargs, 5, 5)) {\n        goto exit;\n    }\n    {\n        long ival = PyLong_AsLong(args[0]);\n        if (ival == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        else if (ival < SHRT_MIN) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"signed short integer is less than minimum\");\n            goto exit;\n        }\n        else if (ival > SHRT_MAX) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"signed short integer is greater than maximum\");\n            goto exit;\n        }\n        else {\n            id = (short) ival;\n        }\n    }\n    x = _PyLong_AsInt(args[1]);\n    if (x == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    y = _PyLong_AsInt(args[2]);\n    if (y == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    z = _PyLong_AsInt(args[3]);\n    if (z == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!PyLong_Check(args[4])) {\n        _PyArg_BadArgument(\"ungetmouse\", \"argument 5\", \"int\", args[4]);\n        goto exit;\n    }\n    bstate = PyLong_AsUnsignedLongMask(args[4]);\n    return_value = _curses_ungetmouse_impl(module, id, x, y, z, bstate);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(NCURSES_MOUSE_VERSION) */\n\nPyDoc_STRVAR(_curses_getwin__doc__,\n\"getwin($module, file, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Read window related data stored in the file by an earlier putwin() call.\\n\"\n\"\\n\"\n\"The routine then creates and initializes a new window using that data,\\n\"\n\"returning the new window object.\");\n\n#define _CURSES_GETWIN_METHODDEF    \\\n    {\"getwin\", (PyCFunction)_curses_getwin, METH_O, _curses_getwin__doc__},\n\nPyDoc_STRVAR(_curses_halfdelay__doc__,\n\"halfdelay($module, tenths, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Enter half-delay mode.\\n\"\n\"\\n\"\n\"  tenths\\n\"\n\"    Maximal blocking delay in tenths of seconds (1 - 255).\\n\"\n\"\\n\"\n\"Use nocbreak() to leave half-delay mode.\");\n\n#define _CURSES_HALFDELAY_METHODDEF    \\\n    {\"halfdelay\", (PyCFunction)_curses_halfdelay, METH_O, _curses_halfdelay__doc__},\n\nstatic PyObject *\n_curses_halfdelay_impl(PyObject *module, unsigned char tenths);\n\nstatic PyObject *\n_curses_halfdelay(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    unsigned char tenths;\n\n    {\n        long ival = PyLong_AsLong(arg);\n        if (ival == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        else if (ival < 0) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"unsigned byte integer is less than minimum\");\n            goto exit;\n        }\n        else if (ival > UCHAR_MAX) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"unsigned byte integer is greater than maximum\");\n            goto exit;\n        }\n        else {\n            tenths = (unsigned char) ival;\n        }\n    }\n    return_value = _curses_halfdelay_impl(module, tenths);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_has_colors__doc__,\n\"has_colors($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the terminal can display colors; otherwise, return False.\");\n\n#define _CURSES_HAS_COLORS_METHODDEF    \\\n    {\"has_colors\", (PyCFunction)_curses_has_colors, METH_NOARGS, _curses_has_colors__doc__},\n\nstatic PyObject *\n_curses_has_colors_impl(PyObject *module);\n\nstatic PyObject *\n_curses_has_colors(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_has_colors_impl(module);\n}\n\nPyDoc_STRVAR(_curses_has_ic__doc__,\n\"has_ic($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the terminal has insert- and delete-character capabilities.\");\n\n#define _CURSES_HAS_IC_METHODDEF    \\\n    {\"has_ic\", (PyCFunction)_curses_has_ic, METH_NOARGS, _curses_has_ic__doc__},\n\nstatic PyObject *\n_curses_has_ic_impl(PyObject *module);\n\nstatic PyObject *\n_curses_has_ic(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_has_ic_impl(module);\n}\n\nPyDoc_STRVAR(_curses_has_il__doc__,\n\"has_il($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the terminal has insert- and delete-line capabilities.\");\n\n#define _CURSES_HAS_IL_METHODDEF    \\\n    {\"has_il\", (PyCFunction)_curses_has_il, METH_NOARGS, _curses_has_il__doc__},\n\nstatic PyObject *\n_curses_has_il_impl(PyObject *module);\n\nstatic PyObject *\n_curses_has_il(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_has_il_impl(module);\n}\n\n#if defined(HAVE_CURSES_HAS_KEY)\n\nPyDoc_STRVAR(_curses_has_key__doc__,\n\"has_key($module, key, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the current terminal type recognizes a key with that value.\\n\"\n\"\\n\"\n\"  key\\n\"\n\"    Key number.\");\n\n#define _CURSES_HAS_KEY_METHODDEF    \\\n    {\"has_key\", (PyCFunction)_curses_has_key, METH_O, _curses_has_key__doc__},\n\nstatic PyObject *\n_curses_has_key_impl(PyObject *module, int key);\n\nstatic PyObject *\n_curses_has_key(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int key;\n\n    key = _PyLong_AsInt(arg);\n    if (key == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_has_key_impl(module, key);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_CURSES_HAS_KEY) */\n\nPyDoc_STRVAR(_curses_init_color__doc__,\n\"init_color($module, color_number, r, g, b, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Change the definition of a color.\\n\"\n\"\\n\"\n\"  color_number\\n\"\n\"    The number of the color to be changed (0 - (COLORS-1)).\\n\"\n\"  r\\n\"\n\"    Red component (0 - 1000).\\n\"\n\"  g\\n\"\n\"    Green component (0 - 1000).\\n\"\n\"  b\\n\"\n\"    Blue component (0 - 1000).\\n\"\n\"\\n\"\n\"When init_color() is used, all occurrences of that color on the screen\\n\"\n\"immediately change to the new definition.  This function is a no-op on\\n\"\n\"most terminals; it is active only if can_change_color() returns true.\");\n\n#define _CURSES_INIT_COLOR_METHODDEF    \\\n    {\"init_color\", _PyCFunction_CAST(_curses_init_color), METH_FASTCALL, _curses_init_color__doc__},\n\nstatic PyObject *\n_curses_init_color_impl(PyObject *module, int color_number, short r, short g,\n                        short b);\n\nstatic PyObject *\n_curses_init_color(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int color_number;\n    short r;\n    short g;\n    short b;\n\n    if (!_PyArg_CheckPositional(\"init_color\", nargs, 4, 4)) {\n        goto exit;\n    }\n    if (!color_converter(args[0], &color_number)) {\n        goto exit;\n    }\n    if (!component_converter(args[1], &r)) {\n        goto exit;\n    }\n    if (!component_converter(args[2], &g)) {\n        goto exit;\n    }\n    if (!component_converter(args[3], &b)) {\n        goto exit;\n    }\n    return_value = _curses_init_color_impl(module, color_number, r, g, b);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_init_pair__doc__,\n\"init_pair($module, pair_number, fg, bg, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Change the definition of a color-pair.\\n\"\n\"\\n\"\n\"  pair_number\\n\"\n\"    The number of the color-pair to be changed (1 - (COLOR_PAIRS-1)).\\n\"\n\"  fg\\n\"\n\"    Foreground color number (-1 - (COLORS-1)).\\n\"\n\"  bg\\n\"\n\"    Background color number (-1 - (COLORS-1)).\\n\"\n\"\\n\"\n\"If the color-pair was previously initialized, the screen is refreshed and\\n\"\n\"all occurrences of that color-pair are changed to the new definition.\");\n\n#define _CURSES_INIT_PAIR_METHODDEF    \\\n    {\"init_pair\", _PyCFunction_CAST(_curses_init_pair), METH_FASTCALL, _curses_init_pair__doc__},\n\nstatic PyObject *\n_curses_init_pair_impl(PyObject *module, int pair_number, int fg, int bg);\n\nstatic PyObject *\n_curses_init_pair(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int pair_number;\n    int fg;\n    int bg;\n\n    if (!_PyArg_CheckPositional(\"init_pair\", nargs, 3, 3)) {\n        goto exit;\n    }\n    if (!pair_converter(args[0], &pair_number)) {\n        goto exit;\n    }\n    if (!color_allow_default_converter(args[1], &fg)) {\n        goto exit;\n    }\n    if (!color_allow_default_converter(args[2], &bg)) {\n        goto exit;\n    }\n    return_value = _curses_init_pair_impl(module, pair_number, fg, bg);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_initscr__doc__,\n\"initscr($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Initialize the library.\\n\"\n\"\\n\"\n\"Return a WindowObject which represents the whole screen.\");\n\n#define _CURSES_INITSCR_METHODDEF    \\\n    {\"initscr\", (PyCFunction)_curses_initscr, METH_NOARGS, _curses_initscr__doc__},\n\nstatic PyObject *\n_curses_initscr_impl(PyObject *module);\n\nstatic PyObject *\n_curses_initscr(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_initscr_impl(module);\n}\n\nPyDoc_STRVAR(_curses_setupterm__doc__,\n\"setupterm($module, /, term=None, fd=-1)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Initialize the terminal.\\n\"\n\"\\n\"\n\"  term\\n\"\n\"    Terminal name.\\n\"\n\"    If omitted, the value of the TERM environment variable will be used.\\n\"\n\"  fd\\n\"\n\"    File descriptor to which any initialization sequences will be sent.\\n\"\n\"    If not supplied, the file descriptor for sys.stdout will be used.\");\n\n#define _CURSES_SETUPTERM_METHODDEF    \\\n    {\"setupterm\", _PyCFunction_CAST(_curses_setupterm), METH_FASTCALL|METH_KEYWORDS, _curses_setupterm__doc__},\n\nstatic PyObject *\n_curses_setupterm_impl(PyObject *module, const char *term, int fd);\n\nstatic PyObject *\n_curses_setupterm(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(term), &_Py_ID(fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"term\", \"fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"setupterm\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;\n    const char *term = NULL;\n    int fd = -1;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[0]) {\n        if (args[0] == Py_None) {\n            term = NULL;\n        }\n        else if (PyUnicode_Check(args[0])) {\n            Py_ssize_t term_length;\n            term = PyUnicode_AsUTF8AndSize(args[0], &term_length);\n            if (term == NULL) {\n                goto exit;\n            }\n            if (strlen(term) != (size_t)term_length) {\n                PyErr_SetString(PyExc_ValueError, \"embedded null character\");\n                goto exit;\n            }\n        }\n        else {\n            _PyArg_BadArgument(\"setupterm\", \"argument 'term'\", \"str or None\", args[0]);\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\n    fd = _PyLong_AsInt(args[1]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional_pos:\n    return_value = _curses_setupterm_impl(module, term, fd);\n\nexit:\n    return return_value;\n}\n\n#if (defined(NCURSES_EXT_FUNCS) && NCURSES_EXT_FUNCS >= 20081102)\n\nPyDoc_STRVAR(_curses_get_escdelay__doc__,\n\"get_escdelay($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Gets the curses ESCDELAY setting.\\n\"\n\"\\n\"\n\"Gets the number of milliseconds to wait after reading an escape character,\\n\"\n\"to distinguish between an individual escape character entered on the\\n\"\n\"keyboard from escape sequences sent by cursor and function keys.\");\n\n#define _CURSES_GET_ESCDELAY_METHODDEF    \\\n    {\"get_escdelay\", (PyCFunction)_curses_get_escdelay, METH_NOARGS, _curses_get_escdelay__doc__},\n\nstatic PyObject *\n_curses_get_escdelay_impl(PyObject *module);\n\nstatic PyObject *\n_curses_get_escdelay(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_get_escdelay_impl(module);\n}\n\n#endif /* (defined(NCURSES_EXT_FUNCS) && NCURSES_EXT_FUNCS >= 20081102) */\n\n#if (defined(NCURSES_EXT_FUNCS) && NCURSES_EXT_FUNCS >= 20081102)\n\nPyDoc_STRVAR(_curses_set_escdelay__doc__,\n\"set_escdelay($module, ms, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Sets the curses ESCDELAY setting.\\n\"\n\"\\n\"\n\"  ms\\n\"\n\"    length of the delay in milliseconds.\\n\"\n\"\\n\"\n\"Sets the number of milliseconds to wait after reading an escape character,\\n\"\n\"to distinguish between an individual escape character entered on the\\n\"\n\"keyboard from escape sequences sent by cursor and function keys.\");\n\n#define _CURSES_SET_ESCDELAY_METHODDEF    \\\n    {\"set_escdelay\", (PyCFunction)_curses_set_escdelay, METH_O, _curses_set_escdelay__doc__},\n\nstatic PyObject *\n_curses_set_escdelay_impl(PyObject *module, int ms);\n\nstatic PyObject *\n_curses_set_escdelay(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int ms;\n\n    ms = _PyLong_AsInt(arg);\n    if (ms == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_set_escdelay_impl(module, ms);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(NCURSES_EXT_FUNCS) && NCURSES_EXT_FUNCS >= 20081102) */\n\n#if (defined(NCURSES_EXT_FUNCS) && NCURSES_EXT_FUNCS >= 20081102)\n\nPyDoc_STRVAR(_curses_get_tabsize__doc__,\n\"get_tabsize($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Gets the curses TABSIZE setting.\\n\"\n\"\\n\"\n\"Gets the number of columns used by the curses library when converting a tab\\n\"\n\"character to spaces as it adds the tab to a window.\");\n\n#define _CURSES_GET_TABSIZE_METHODDEF    \\\n    {\"get_tabsize\", (PyCFunction)_curses_get_tabsize, METH_NOARGS, _curses_get_tabsize__doc__},\n\nstatic PyObject *\n_curses_get_tabsize_impl(PyObject *module);\n\nstatic PyObject *\n_curses_get_tabsize(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_get_tabsize_impl(module);\n}\n\n#endif /* (defined(NCURSES_EXT_FUNCS) && NCURSES_EXT_FUNCS >= 20081102) */\n\n#if (defined(NCURSES_EXT_FUNCS) && NCURSES_EXT_FUNCS >= 20081102)\n\nPyDoc_STRVAR(_curses_set_tabsize__doc__,\n\"set_tabsize($module, size, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Sets the curses TABSIZE setting.\\n\"\n\"\\n\"\n\"  size\\n\"\n\"    rendered cell width of a tab character.\\n\"\n\"\\n\"\n\"Sets the number of columns used by the curses library when converting a tab\\n\"\n\"character to spaces as it adds the tab to a window.\");\n\n#define _CURSES_SET_TABSIZE_METHODDEF    \\\n    {\"set_tabsize\", (PyCFunction)_curses_set_tabsize, METH_O, _curses_set_tabsize__doc__},\n\nstatic PyObject *\n_curses_set_tabsize_impl(PyObject *module, int size);\n\nstatic PyObject *\n_curses_set_tabsize(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int size;\n\n    size = _PyLong_AsInt(arg);\n    if (size == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_set_tabsize_impl(module, size);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(NCURSES_EXT_FUNCS) && NCURSES_EXT_FUNCS >= 20081102) */\n\nPyDoc_STRVAR(_curses_intrflush__doc__,\n\"intrflush($module, flag, /)\\n\"\n\"--\\n\"\n\"\\n\");\n\n#define _CURSES_INTRFLUSH_METHODDEF    \\\n    {\"intrflush\", (PyCFunction)_curses_intrflush, METH_O, _curses_intrflush__doc__},\n\nstatic PyObject *\n_curses_intrflush_impl(PyObject *module, int flag);\n\nstatic PyObject *\n_curses_intrflush(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int flag;\n\n    flag = PyObject_IsTrue(arg);\n    if (flag < 0) {\n        goto exit;\n    }\n    return_value = _curses_intrflush_impl(module, flag);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_isendwin__doc__,\n\"isendwin($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if endwin() has been called.\");\n\n#define _CURSES_ISENDWIN_METHODDEF    \\\n    {\"isendwin\", (PyCFunction)_curses_isendwin, METH_NOARGS, _curses_isendwin__doc__},\n\nstatic PyObject *\n_curses_isendwin_impl(PyObject *module);\n\nstatic PyObject *\n_curses_isendwin(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_isendwin_impl(module);\n}\n\n#if defined(HAVE_CURSES_IS_TERM_RESIZED)\n\nPyDoc_STRVAR(_curses_is_term_resized__doc__,\n\"is_term_resized($module, nlines, ncols, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if resize_term() would modify the window structure, False otherwise.\\n\"\n\"\\n\"\n\"  nlines\\n\"\n\"    Height.\\n\"\n\"  ncols\\n\"\n\"    Width.\");\n\n#define _CURSES_IS_TERM_RESIZED_METHODDEF    \\\n    {\"is_term_resized\", _PyCFunction_CAST(_curses_is_term_resized), METH_FASTCALL, _curses_is_term_resized__doc__},\n\nstatic PyObject *\n_curses_is_term_resized_impl(PyObject *module, int nlines, int ncols);\n\nstatic PyObject *\n_curses_is_term_resized(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int nlines;\n    int ncols;\n\n    if (!_PyArg_CheckPositional(\"is_term_resized\", nargs, 2, 2)) {\n        goto exit;\n    }\n    nlines = _PyLong_AsInt(args[0]);\n    if (nlines == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    ncols = _PyLong_AsInt(args[1]);\n    if (ncols == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_is_term_resized_impl(module, nlines, ncols);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_CURSES_IS_TERM_RESIZED) */\n\nPyDoc_STRVAR(_curses_keyname__doc__,\n\"keyname($module, key, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the name of specified key.\\n\"\n\"\\n\"\n\"  key\\n\"\n\"    Key number.\");\n\n#define _CURSES_KEYNAME_METHODDEF    \\\n    {\"keyname\", (PyCFunction)_curses_keyname, METH_O, _curses_keyname__doc__},\n\nstatic PyObject *\n_curses_keyname_impl(PyObject *module, int key);\n\nstatic PyObject *\n_curses_keyname(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int key;\n\n    key = _PyLong_AsInt(arg);\n    if (key == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_keyname_impl(module, key);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_killchar__doc__,\n\"killchar($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the user\\'s current line kill character.\");\n\n#define _CURSES_KILLCHAR_METHODDEF    \\\n    {\"killchar\", (PyCFunction)_curses_killchar, METH_NOARGS, _curses_killchar__doc__},\n\nstatic PyObject *\n_curses_killchar_impl(PyObject *module);\n\nstatic PyObject *\n_curses_killchar(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_killchar_impl(module);\n}\n\nPyDoc_STRVAR(_curses_longname__doc__,\n\"longname($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the terminfo long name field describing the current terminal.\\n\"\n\"\\n\"\n\"The maximum length of a verbose description is 128 characters.  It is defined\\n\"\n\"only after the call to initscr().\");\n\n#define _CURSES_LONGNAME_METHODDEF    \\\n    {\"longname\", (PyCFunction)_curses_longname, METH_NOARGS, _curses_longname__doc__},\n\nstatic PyObject *\n_curses_longname_impl(PyObject *module);\n\nstatic PyObject *\n_curses_longname(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_longname_impl(module);\n}\n\nPyDoc_STRVAR(_curses_meta__doc__,\n\"meta($module, yes, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Enable/disable meta keys.\\n\"\n\"\\n\"\n\"If yes is True, allow 8-bit characters to be input.  If yes is False,\\n\"\n\"allow only 7-bit characters.\");\n\n#define _CURSES_META_METHODDEF    \\\n    {\"meta\", (PyCFunction)_curses_meta, METH_O, _curses_meta__doc__},\n\nstatic PyObject *\n_curses_meta_impl(PyObject *module, int yes);\n\nstatic PyObject *\n_curses_meta(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int yes;\n\n    yes = PyObject_IsTrue(arg);\n    if (yes < 0) {\n        goto exit;\n    }\n    return_value = _curses_meta_impl(module, yes);\n\nexit:\n    return return_value;\n}\n\n#if defined(NCURSES_MOUSE_VERSION)\n\nPyDoc_STRVAR(_curses_mouseinterval__doc__,\n\"mouseinterval($module, interval, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set and retrieve the maximum time between press and release in a click.\\n\"\n\"\\n\"\n\"  interval\\n\"\n\"    Time in milliseconds.\\n\"\n\"\\n\"\n\"Set the maximum time that can elapse between press and release events in\\n\"\n\"order for them to be recognized as a click, and return the previous interval\\n\"\n\"value.\");\n\n#define _CURSES_MOUSEINTERVAL_METHODDEF    \\\n    {\"mouseinterval\", (PyCFunction)_curses_mouseinterval, METH_O, _curses_mouseinterval__doc__},\n\nstatic PyObject *\n_curses_mouseinterval_impl(PyObject *module, int interval);\n\nstatic PyObject *\n_curses_mouseinterval(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int interval;\n\n    interval = _PyLong_AsInt(arg);\n    if (interval == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_mouseinterval_impl(module, interval);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(NCURSES_MOUSE_VERSION) */\n\n#if defined(NCURSES_MOUSE_VERSION)\n\nPyDoc_STRVAR(_curses_mousemask__doc__,\n\"mousemask($module, newmask, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the mouse events to be reported, and return a tuple (availmask, oldmask).\\n\"\n\"\\n\"\n\"Return a tuple (availmask, oldmask).  availmask indicates which of the\\n\"\n\"specified mouse events can be reported; on complete failure it returns 0.\\n\"\n\"oldmask is the previous value of the given window\\'s mouse event mask.\\n\"\n\"If this function is never called, no mouse events are ever reported.\");\n\n#define _CURSES_MOUSEMASK_METHODDEF    \\\n    {\"mousemask\", (PyCFunction)_curses_mousemask, METH_O, _curses_mousemask__doc__},\n\nstatic PyObject *\n_curses_mousemask_impl(PyObject *module, unsigned long newmask);\n\nstatic PyObject *\n_curses_mousemask(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    unsigned long newmask;\n\n    if (!PyLong_Check(arg)) {\n        _PyArg_BadArgument(\"mousemask\", \"argument\", \"int\", arg);\n        goto exit;\n    }\n    newmask = PyLong_AsUnsignedLongMask(arg);\n    return_value = _curses_mousemask_impl(module, newmask);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(NCURSES_MOUSE_VERSION) */\n\nPyDoc_STRVAR(_curses_napms__doc__,\n\"napms($module, ms, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Sleep for specified time.\\n\"\n\"\\n\"\n\"  ms\\n\"\n\"    Duration in milliseconds.\");\n\n#define _CURSES_NAPMS_METHODDEF    \\\n    {\"napms\", (PyCFunction)_curses_napms, METH_O, _curses_napms__doc__},\n\nstatic PyObject *\n_curses_napms_impl(PyObject *module, int ms);\n\nstatic PyObject *\n_curses_napms(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int ms;\n\n    ms = _PyLong_AsInt(arg);\n    if (ms == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_napms_impl(module, ms);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_newpad__doc__,\n\"newpad($module, nlines, ncols, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Create and return a pointer to a new pad data structure.\\n\"\n\"\\n\"\n\"  nlines\\n\"\n\"    Height.\\n\"\n\"  ncols\\n\"\n\"    Width.\");\n\n#define _CURSES_NEWPAD_METHODDEF    \\\n    {\"newpad\", _PyCFunction_CAST(_curses_newpad), METH_FASTCALL, _curses_newpad__doc__},\n\nstatic PyObject *\n_curses_newpad_impl(PyObject *module, int nlines, int ncols);\n\nstatic PyObject *\n_curses_newpad(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int nlines;\n    int ncols;\n\n    if (!_PyArg_CheckPositional(\"newpad\", nargs, 2, 2)) {\n        goto exit;\n    }\n    nlines = _PyLong_AsInt(args[0]);\n    if (nlines == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    ncols = _PyLong_AsInt(args[1]);\n    if (ncols == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_newpad_impl(module, nlines, ncols);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_newwin__doc__,\n\"newwin(nlines, ncols, [begin_y=0, begin_x=0])\\n\"\n\"Return a new window.\\n\"\n\"\\n\"\n\"  nlines\\n\"\n\"    Height.\\n\"\n\"  ncols\\n\"\n\"    Width.\\n\"\n\"  begin_y\\n\"\n\"    Top side y-coordinate.\\n\"\n\"  begin_x\\n\"\n\"    Left side x-coordinate.\\n\"\n\"\\n\"\n\"By default, the window will extend from the specified position to the lower\\n\"\n\"right corner of the screen.\");\n\n#define _CURSES_NEWWIN_METHODDEF    \\\n    {\"newwin\", (PyCFunction)_curses_newwin, METH_VARARGS, _curses_newwin__doc__},\n\nstatic PyObject *\n_curses_newwin_impl(PyObject *module, int nlines, int ncols,\n                    int group_right_1, int begin_y, int begin_x);\n\nstatic PyObject *\n_curses_newwin(PyObject *module, PyObject *args)\n{\n    PyObject *return_value = NULL;\n    int nlines;\n    int ncols;\n    int group_right_1 = 0;\n    int begin_y = 0;\n    int begin_x = 0;\n\n    switch (PyTuple_GET_SIZE(args)) {\n        case 2:\n            if (!PyArg_ParseTuple(args, \"ii:newwin\", &nlines, &ncols)) {\n                goto exit;\n            }\n            break;\n        case 4:\n            if (!PyArg_ParseTuple(args, \"iiii:newwin\", &nlines, &ncols, &begin_y, &begin_x)) {\n                goto exit;\n            }\n            group_right_1 = 1;\n            break;\n        default:\n            PyErr_SetString(PyExc_TypeError, \"_curses.newwin requires 2 to 4 arguments\");\n            goto exit;\n    }\n    return_value = _curses_newwin_impl(module, nlines, ncols, group_right_1, begin_y, begin_x);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_nl__doc__,\n\"nl($module, flag=True, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Enter newline mode.\\n\"\n\"\\n\"\n\"  flag\\n\"\n\"    If false, the effect is the same as calling nonl().\\n\"\n\"\\n\"\n\"This mode translates the return key into newline on input, and translates\\n\"\n\"newline into return and line-feed on output.  Newline mode is initially on.\");\n\n#define _CURSES_NL_METHODDEF    \\\n    {\"nl\", _PyCFunction_CAST(_curses_nl), METH_FASTCALL, _curses_nl__doc__},\n\nstatic PyObject *\n_curses_nl_impl(PyObject *module, int flag);\n\nstatic PyObject *\n_curses_nl(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int flag = 1;\n\n    if (!_PyArg_CheckPositional(\"nl\", nargs, 0, 1)) {\n        goto exit;\n    }\n    if (nargs < 1) {\n        goto skip_optional;\n    }\n    flag = PyObject_IsTrue(args[0]);\n    if (flag < 0) {\n        goto exit;\n    }\nskip_optional:\n    return_value = _curses_nl_impl(module, flag);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_nocbreak__doc__,\n\"nocbreak($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Leave cbreak mode.\\n\"\n\"\\n\"\n\"Return to normal \\\"cooked\\\" mode with line buffering.\");\n\n#define _CURSES_NOCBREAK_METHODDEF    \\\n    {\"nocbreak\", (PyCFunction)_curses_nocbreak, METH_NOARGS, _curses_nocbreak__doc__},\n\nstatic PyObject *\n_curses_nocbreak_impl(PyObject *module);\n\nstatic PyObject *\n_curses_nocbreak(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_nocbreak_impl(module);\n}\n\nPyDoc_STRVAR(_curses_noecho__doc__,\n\"noecho($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Leave echo mode.\\n\"\n\"\\n\"\n\"Echoing of input characters is turned off.\");\n\n#define _CURSES_NOECHO_METHODDEF    \\\n    {\"noecho\", (PyCFunction)_curses_noecho, METH_NOARGS, _curses_noecho__doc__},\n\nstatic PyObject *\n_curses_noecho_impl(PyObject *module);\n\nstatic PyObject *\n_curses_noecho(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_noecho_impl(module);\n}\n\nPyDoc_STRVAR(_curses_nonl__doc__,\n\"nonl($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Leave newline mode.\\n\"\n\"\\n\"\n\"Disable translation of return into newline on input, and disable low-level\\n\"\n\"translation of newline into newline/return on output.\");\n\n#define _CURSES_NONL_METHODDEF    \\\n    {\"nonl\", (PyCFunction)_curses_nonl, METH_NOARGS, _curses_nonl__doc__},\n\nstatic PyObject *\n_curses_nonl_impl(PyObject *module);\n\nstatic PyObject *\n_curses_nonl(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_nonl_impl(module);\n}\n\nPyDoc_STRVAR(_curses_noqiflush__doc__,\n\"noqiflush($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Disable queue flushing.\\n\"\n\"\\n\"\n\"When queue flushing is disabled, normal flush of input and output queues\\n\"\n\"associated with the INTR, QUIT and SUSP characters will not be done.\");\n\n#define _CURSES_NOQIFLUSH_METHODDEF    \\\n    {\"noqiflush\", (PyCFunction)_curses_noqiflush, METH_NOARGS, _curses_noqiflush__doc__},\n\nstatic PyObject *\n_curses_noqiflush_impl(PyObject *module);\n\nstatic PyObject *\n_curses_noqiflush(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_noqiflush_impl(module);\n}\n\nPyDoc_STRVAR(_curses_noraw__doc__,\n\"noraw($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Leave raw mode.\\n\"\n\"\\n\"\n\"Return to normal \\\"cooked\\\" mode with line buffering.\");\n\n#define _CURSES_NORAW_METHODDEF    \\\n    {\"noraw\", (PyCFunction)_curses_noraw, METH_NOARGS, _curses_noraw__doc__},\n\nstatic PyObject *\n_curses_noraw_impl(PyObject *module);\n\nstatic PyObject *\n_curses_noraw(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_noraw_impl(module);\n}\n\nPyDoc_STRVAR(_curses_pair_content__doc__,\n\"pair_content($module, pair_number, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a tuple (fg, bg) containing the colors for the requested color pair.\\n\"\n\"\\n\"\n\"  pair_number\\n\"\n\"    The number of the color pair (0 - (COLOR_PAIRS-1)).\");\n\n#define _CURSES_PAIR_CONTENT_METHODDEF    \\\n    {\"pair_content\", (PyCFunction)_curses_pair_content, METH_O, _curses_pair_content__doc__},\n\nstatic PyObject *\n_curses_pair_content_impl(PyObject *module, int pair_number);\n\nstatic PyObject *\n_curses_pair_content(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int pair_number;\n\n    if (!pair_converter(arg, &pair_number)) {\n        goto exit;\n    }\n    return_value = _curses_pair_content_impl(module, pair_number);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_pair_number__doc__,\n\"pair_number($module, attr, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the number of the color-pair set by the specified attribute value.\\n\"\n\"\\n\"\n\"color_pair() is the counterpart to this function.\");\n\n#define _CURSES_PAIR_NUMBER_METHODDEF    \\\n    {\"pair_number\", (PyCFunction)_curses_pair_number, METH_O, _curses_pair_number__doc__},\n\nstatic PyObject *\n_curses_pair_number_impl(PyObject *module, int attr);\n\nstatic PyObject *\n_curses_pair_number(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int attr;\n\n    attr = _PyLong_AsInt(arg);\n    if (attr == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_pair_number_impl(module, attr);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_putp__doc__,\n\"putp($module, string, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Emit the value of a specified terminfo capability for the current terminal.\\n\"\n\"\\n\"\n\"Note that the output of putp() always goes to standard output.\");\n\n#define _CURSES_PUTP_METHODDEF    \\\n    {\"putp\", (PyCFunction)_curses_putp, METH_O, _curses_putp__doc__},\n\nstatic PyObject *\n_curses_putp_impl(PyObject *module, const char *string);\n\nstatic PyObject *\n_curses_putp(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    const char *string;\n\n    if (!PyArg_Parse(arg, \"y:putp\", &string)) {\n        goto exit;\n    }\n    return_value = _curses_putp_impl(module, string);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_qiflush__doc__,\n\"qiflush($module, flag=True, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Enable queue flushing.\\n\"\n\"\\n\"\n\"  flag\\n\"\n\"    If false, the effect is the same as calling noqiflush().\\n\"\n\"\\n\"\n\"If queue flushing is enabled, all output in the display driver queue\\n\"\n\"will be flushed when the INTR, QUIT and SUSP characters are read.\");\n\n#define _CURSES_QIFLUSH_METHODDEF    \\\n    {\"qiflush\", _PyCFunction_CAST(_curses_qiflush), METH_FASTCALL, _curses_qiflush__doc__},\n\nstatic PyObject *\n_curses_qiflush_impl(PyObject *module, int flag);\n\nstatic PyObject *\n_curses_qiflush(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int flag = 1;\n\n    if (!_PyArg_CheckPositional(\"qiflush\", nargs, 0, 1)) {\n        goto exit;\n    }\n    if (nargs < 1) {\n        goto skip_optional;\n    }\n    flag = PyObject_IsTrue(args[0]);\n    if (flag < 0) {\n        goto exit;\n    }\nskip_optional:\n    return_value = _curses_qiflush_impl(module, flag);\n\nexit:\n    return return_value;\n}\n\n#if (defined(HAVE_CURSES_RESIZETERM) || defined(HAVE_CURSES_RESIZE_TERM))\n\nPyDoc_STRVAR(_curses_update_lines_cols__doc__,\n\"update_lines_cols($module, /)\\n\"\n\"--\\n\"\n\"\\n\");\n\n#define _CURSES_UPDATE_LINES_COLS_METHODDEF    \\\n    {\"update_lines_cols\", (PyCFunction)_curses_update_lines_cols, METH_NOARGS, _curses_update_lines_cols__doc__},\n\nstatic PyObject *\n_curses_update_lines_cols_impl(PyObject *module);\n\nstatic PyObject *\n_curses_update_lines_cols(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_update_lines_cols_impl(module);\n}\n\n#endif /* (defined(HAVE_CURSES_RESIZETERM) || defined(HAVE_CURSES_RESIZE_TERM)) */\n\nPyDoc_STRVAR(_curses_raw__doc__,\n\"raw($module, flag=True, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Enter raw mode.\\n\"\n\"\\n\"\n\"  flag\\n\"\n\"    If false, the effect is the same as calling noraw().\\n\"\n\"\\n\"\n\"In raw mode, normal line buffering and processing of interrupt, quit,\\n\"\n\"suspend, and flow control keys are turned off; characters are presented to\\n\"\n\"curses input functions one by one.\");\n\n#define _CURSES_RAW_METHODDEF    \\\n    {\"raw\", _PyCFunction_CAST(_curses_raw), METH_FASTCALL, _curses_raw__doc__},\n\nstatic PyObject *\n_curses_raw_impl(PyObject *module, int flag);\n\nstatic PyObject *\n_curses_raw(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int flag = 1;\n\n    if (!_PyArg_CheckPositional(\"raw\", nargs, 0, 1)) {\n        goto exit;\n    }\n    if (nargs < 1) {\n        goto skip_optional;\n    }\n    flag = PyObject_IsTrue(args[0]);\n    if (flag < 0) {\n        goto exit;\n    }\nskip_optional:\n    return_value = _curses_raw_impl(module, flag);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_reset_prog_mode__doc__,\n\"reset_prog_mode($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Restore the terminal to \\\"program\\\" mode, as previously saved by def_prog_mode().\");\n\n#define _CURSES_RESET_PROG_MODE_METHODDEF    \\\n    {\"reset_prog_mode\", (PyCFunction)_curses_reset_prog_mode, METH_NOARGS, _curses_reset_prog_mode__doc__},\n\nstatic PyObject *\n_curses_reset_prog_mode_impl(PyObject *module);\n\nstatic PyObject *\n_curses_reset_prog_mode(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_reset_prog_mode_impl(module);\n}\n\nPyDoc_STRVAR(_curses_reset_shell_mode__doc__,\n\"reset_shell_mode($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Restore the terminal to \\\"shell\\\" mode, as previously saved by def_shell_mode().\");\n\n#define _CURSES_RESET_SHELL_MODE_METHODDEF    \\\n    {\"reset_shell_mode\", (PyCFunction)_curses_reset_shell_mode, METH_NOARGS, _curses_reset_shell_mode__doc__},\n\nstatic PyObject *\n_curses_reset_shell_mode_impl(PyObject *module);\n\nstatic PyObject *\n_curses_reset_shell_mode(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_reset_shell_mode_impl(module);\n}\n\nPyDoc_STRVAR(_curses_resetty__doc__,\n\"resetty($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Restore terminal mode.\");\n\n#define _CURSES_RESETTY_METHODDEF    \\\n    {\"resetty\", (PyCFunction)_curses_resetty, METH_NOARGS, _curses_resetty__doc__},\n\nstatic PyObject *\n_curses_resetty_impl(PyObject *module);\n\nstatic PyObject *\n_curses_resetty(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_resetty_impl(module);\n}\n\n#if defined(HAVE_CURSES_RESIZETERM)\n\nPyDoc_STRVAR(_curses_resizeterm__doc__,\n\"resizeterm($module, nlines, ncols, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Resize the standard and current windows to the specified dimensions.\\n\"\n\"\\n\"\n\"  nlines\\n\"\n\"    Height.\\n\"\n\"  ncols\\n\"\n\"    Width.\\n\"\n\"\\n\"\n\"Adjusts other bookkeeping data used by the curses library that record the\\n\"\n\"window dimensions (in particular the SIGWINCH handler).\");\n\n#define _CURSES_RESIZETERM_METHODDEF    \\\n    {\"resizeterm\", _PyCFunction_CAST(_curses_resizeterm), METH_FASTCALL, _curses_resizeterm__doc__},\n\nstatic PyObject *\n_curses_resizeterm_impl(PyObject *module, int nlines, int ncols);\n\nstatic PyObject *\n_curses_resizeterm(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int nlines;\n    int ncols;\n\n    if (!_PyArg_CheckPositional(\"resizeterm\", nargs, 2, 2)) {\n        goto exit;\n    }\n    nlines = _PyLong_AsInt(args[0]);\n    if (nlines == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    ncols = _PyLong_AsInt(args[1]);\n    if (ncols == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_resizeterm_impl(module, nlines, ncols);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_CURSES_RESIZETERM) */\n\n#if defined(HAVE_CURSES_RESIZE_TERM)\n\nPyDoc_STRVAR(_curses_resize_term__doc__,\n\"resize_term($module, nlines, ncols, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Backend function used by resizeterm(), performing most of the work.\\n\"\n\"\\n\"\n\"  nlines\\n\"\n\"    Height.\\n\"\n\"  ncols\\n\"\n\"    Width.\\n\"\n\"\\n\"\n\"When resizing the windows, resize_term() blank-fills the areas that are\\n\"\n\"extended.  The calling application should fill in these areas with appropriate\\n\"\n\"data.  The resize_term() function attempts to resize all windows.  However,\\n\"\n\"due to the calling convention of pads, it is not possible to resize these\\n\"\n\"without additional interaction with the application.\");\n\n#define _CURSES_RESIZE_TERM_METHODDEF    \\\n    {\"resize_term\", _PyCFunction_CAST(_curses_resize_term), METH_FASTCALL, _curses_resize_term__doc__},\n\nstatic PyObject *\n_curses_resize_term_impl(PyObject *module, int nlines, int ncols);\n\nstatic PyObject *\n_curses_resize_term(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int nlines;\n    int ncols;\n\n    if (!_PyArg_CheckPositional(\"resize_term\", nargs, 2, 2)) {\n        goto exit;\n    }\n    nlines = _PyLong_AsInt(args[0]);\n    if (nlines == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    ncols = _PyLong_AsInt(args[1]);\n    if (ncols == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_resize_term_impl(module, nlines, ncols);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_CURSES_RESIZE_TERM) */\n\nPyDoc_STRVAR(_curses_savetty__doc__,\n\"savetty($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Save terminal mode.\");\n\n#define _CURSES_SAVETTY_METHODDEF    \\\n    {\"savetty\", (PyCFunction)_curses_savetty, METH_NOARGS, _curses_savetty__doc__},\n\nstatic PyObject *\n_curses_savetty_impl(PyObject *module);\n\nstatic PyObject *\n_curses_savetty(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_savetty_impl(module);\n}\n\n#if defined(getsyx)\n\nPyDoc_STRVAR(_curses_setsyx__doc__,\n\"setsyx($module, y, x, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the virtual screen cursor.\\n\"\n\"\\n\"\n\"  y\\n\"\n\"    Y-coordinate.\\n\"\n\"  x\\n\"\n\"    X-coordinate.\\n\"\n\"\\n\"\n\"If y and x are both -1, then leaveok is set.\");\n\n#define _CURSES_SETSYX_METHODDEF    \\\n    {\"setsyx\", _PyCFunction_CAST(_curses_setsyx), METH_FASTCALL, _curses_setsyx__doc__},\n\nstatic PyObject *\n_curses_setsyx_impl(PyObject *module, int y, int x);\n\nstatic PyObject *\n_curses_setsyx(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int y;\n    int x;\n\n    if (!_PyArg_CheckPositional(\"setsyx\", nargs, 2, 2)) {\n        goto exit;\n    }\n    y = _PyLong_AsInt(args[0]);\n    if (y == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    x = _PyLong_AsInt(args[1]);\n    if (x == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_setsyx_impl(module, y, x);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(getsyx) */\n\nPyDoc_STRVAR(_curses_start_color__doc__,\n\"start_color($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Initializes eight basic colors and global variables COLORS and COLOR_PAIRS.\\n\"\n\"\\n\"\n\"Must be called if the programmer wants to use colors, and before any other\\n\"\n\"color manipulation routine is called.  It is good practice to call this\\n\"\n\"routine right after initscr().\\n\"\n\"\\n\"\n\"It also restores the colors on the terminal to the values they had when the\\n\"\n\"terminal was just turned on.\");\n\n#define _CURSES_START_COLOR_METHODDEF    \\\n    {\"start_color\", (PyCFunction)_curses_start_color, METH_NOARGS, _curses_start_color__doc__},\n\nstatic PyObject *\n_curses_start_color_impl(PyObject *module);\n\nstatic PyObject *\n_curses_start_color(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_start_color_impl(module);\n}\n\nPyDoc_STRVAR(_curses_termattrs__doc__,\n\"termattrs($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a logical OR of all video attributes supported by the terminal.\");\n\n#define _CURSES_TERMATTRS_METHODDEF    \\\n    {\"termattrs\", (PyCFunction)_curses_termattrs, METH_NOARGS, _curses_termattrs__doc__},\n\nstatic PyObject *\n_curses_termattrs_impl(PyObject *module);\n\nstatic PyObject *\n_curses_termattrs(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_termattrs_impl(module);\n}\n\nPyDoc_STRVAR(_curses_termname__doc__,\n\"termname($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the value of the environment variable TERM, truncated to 14 characters.\");\n\n#define _CURSES_TERMNAME_METHODDEF    \\\n    {\"termname\", (PyCFunction)_curses_termname, METH_NOARGS, _curses_termname__doc__},\n\nstatic PyObject *\n_curses_termname_impl(PyObject *module);\n\nstatic PyObject *\n_curses_termname(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_termname_impl(module);\n}\n\nPyDoc_STRVAR(_curses_tigetflag__doc__,\n\"tigetflag($module, capname, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the value of the Boolean capability.\\n\"\n\"\\n\"\n\"  capname\\n\"\n\"    The terminfo capability name.\\n\"\n\"\\n\"\n\"The value -1 is returned if capname is not a Boolean capability, or 0 if\\n\"\n\"it is canceled or absent from the terminal description.\");\n\n#define _CURSES_TIGETFLAG_METHODDEF    \\\n    {\"tigetflag\", (PyCFunction)_curses_tigetflag, METH_O, _curses_tigetflag__doc__},\n\nstatic PyObject *\n_curses_tigetflag_impl(PyObject *module, const char *capname);\n\nstatic PyObject *\n_curses_tigetflag(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    const char *capname;\n\n    if (!PyUnicode_Check(arg)) {\n        _PyArg_BadArgument(\"tigetflag\", \"argument\", \"str\", arg);\n        goto exit;\n    }\n    Py_ssize_t capname_length;\n    capname = PyUnicode_AsUTF8AndSize(arg, &capname_length);\n    if (capname == NULL) {\n        goto exit;\n    }\n    if (strlen(capname) != (size_t)capname_length) {\n        PyErr_SetString(PyExc_ValueError, \"embedded null character\");\n        goto exit;\n    }\n    return_value = _curses_tigetflag_impl(module, capname);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_tigetnum__doc__,\n\"tigetnum($module, capname, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the value of the numeric capability.\\n\"\n\"\\n\"\n\"  capname\\n\"\n\"    The terminfo capability name.\\n\"\n\"\\n\"\n\"The value -2 is returned if capname is not a numeric capability, or -1 if\\n\"\n\"it is canceled or absent from the terminal description.\");\n\n#define _CURSES_TIGETNUM_METHODDEF    \\\n    {\"tigetnum\", (PyCFunction)_curses_tigetnum, METH_O, _curses_tigetnum__doc__},\n\nstatic PyObject *\n_curses_tigetnum_impl(PyObject *module, const char *capname);\n\nstatic PyObject *\n_curses_tigetnum(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    const char *capname;\n\n    if (!PyUnicode_Check(arg)) {\n        _PyArg_BadArgument(\"tigetnum\", \"argument\", \"str\", arg);\n        goto exit;\n    }\n    Py_ssize_t capname_length;\n    capname = PyUnicode_AsUTF8AndSize(arg, &capname_length);\n    if (capname == NULL) {\n        goto exit;\n    }\n    if (strlen(capname) != (size_t)capname_length) {\n        PyErr_SetString(PyExc_ValueError, \"embedded null character\");\n        goto exit;\n    }\n    return_value = _curses_tigetnum_impl(module, capname);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_tigetstr__doc__,\n\"tigetstr($module, capname, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the value of the string capability.\\n\"\n\"\\n\"\n\"  capname\\n\"\n\"    The terminfo capability name.\\n\"\n\"\\n\"\n\"None is returned if capname is not a string capability, or is canceled or\\n\"\n\"absent from the terminal description.\");\n\n#define _CURSES_TIGETSTR_METHODDEF    \\\n    {\"tigetstr\", (PyCFunction)_curses_tigetstr, METH_O, _curses_tigetstr__doc__},\n\nstatic PyObject *\n_curses_tigetstr_impl(PyObject *module, const char *capname);\n\nstatic PyObject *\n_curses_tigetstr(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    const char *capname;\n\n    if (!PyUnicode_Check(arg)) {\n        _PyArg_BadArgument(\"tigetstr\", \"argument\", \"str\", arg);\n        goto exit;\n    }\n    Py_ssize_t capname_length;\n    capname = PyUnicode_AsUTF8AndSize(arg, &capname_length);\n    if (capname == NULL) {\n        goto exit;\n    }\n    if (strlen(capname) != (size_t)capname_length) {\n        PyErr_SetString(PyExc_ValueError, \"embedded null character\");\n        goto exit;\n    }\n    return_value = _curses_tigetstr_impl(module, capname);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(_curses_tparm__doc__,\n\"tparm($module, str, i1=0, i2=0, i3=0, i4=0, i5=0, i6=0, i7=0, i8=0,\\n\"\n\"      i9=0, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Instantiate the specified byte string with the supplied parameters.\\n\"\n\"\\n\"\n\"  str\\n\"\n\"    Parameterized byte string obtained from the terminfo database.\");\n\n#define _CURSES_TPARM_METHODDEF    \\\n    {\"tparm\", _PyCFunction_CAST(_curses_tparm), METH_FASTCALL, _curses_tparm__doc__},\n\nstatic PyObject *\n_curses_tparm_impl(PyObject *module, const char *str, int i1, int i2, int i3,\n                   int i4, int i5, int i6, int i7, int i8, int i9);\n\nstatic PyObject *\n_curses_tparm(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    const char *str;\n    int i1 = 0;\n    int i2 = 0;\n    int i3 = 0;\n    int i4 = 0;\n    int i5 = 0;\n    int i6 = 0;\n    int i7 = 0;\n    int i8 = 0;\n    int i9 = 0;\n\n    if (!_PyArg_ParseStack(args, nargs, \"y|iiiiiiiii:tparm\",\n        &str, &i1, &i2, &i3, &i4, &i5, &i6, &i7, &i8, &i9)) {\n        goto exit;\n    }\n    return_value = _curses_tparm_impl(module, str, i1, i2, i3, i4, i5, i6, i7, i8, i9);\n\nexit:\n    return return_value;\n}\n\n#if defined(HAVE_CURSES_TYPEAHEAD)\n\nPyDoc_STRVAR(_curses_typeahead__doc__,\n\"typeahead($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Specify that the file descriptor fd be used for typeahead checking.\\n\"\n\"\\n\"\n\"  fd\\n\"\n\"    File descriptor.\\n\"\n\"\\n\"\n\"If fd is -1, then no typeahead checking is done.\");\n\n#define _CURSES_TYPEAHEAD_METHODDEF    \\\n    {\"typeahead\", (PyCFunction)_curses_typeahead, METH_O, _curses_typeahead__doc__},\n\nstatic PyObject *\n_curses_typeahead_impl(PyObject *module, int fd);\n\nstatic PyObject *\n_curses_typeahead(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n\n    fd = _PyLong_AsInt(arg);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _curses_typeahead_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_CURSES_TYPEAHEAD) */\n\nPyDoc_STRVAR(_curses_unctrl__doc__,\n\"unctrl($module, ch, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a string which is a printable representation of the character ch.\\n\"\n\"\\n\"\n\"Control characters are displayed as a caret followed by the character,\\n\"\n\"for example as ^C.  Printing characters are left as they are.\");\n\n#define _CURSES_UNCTRL_METHODDEF    \\\n    {\"unctrl\", (PyCFunction)_curses_unctrl, METH_O, _curses_unctrl__doc__},\n\nPyDoc_STRVAR(_curses_ungetch__doc__,\n\"ungetch($module, ch, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Push ch so the next getch() will return it.\");\n\n#define _CURSES_UNGETCH_METHODDEF    \\\n    {\"ungetch\", (PyCFunction)_curses_ungetch, METH_O, _curses_ungetch__doc__},\n\n#if defined(HAVE_NCURSESW)\n\nPyDoc_STRVAR(_curses_unget_wch__doc__,\n\"unget_wch($module, ch, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Push ch so the next get_wch() will return it.\");\n\n#define _CURSES_UNGET_WCH_METHODDEF    \\\n    {\"unget_wch\", (PyCFunction)_curses_unget_wch, METH_O, _curses_unget_wch__doc__},\n\n#endif /* defined(HAVE_NCURSESW) */\n\n#if defined(HAVE_CURSES_USE_ENV)\n\nPyDoc_STRVAR(_curses_use_env__doc__,\n\"use_env($module, flag, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Use environment variables LINES and COLUMNS.\\n\"\n\"\\n\"\n\"If used, this function should be called before initscr() or newterm() are\\n\"\n\"called.\\n\"\n\"\\n\"\n\"When flag is False, the values of lines and columns specified in the terminfo\\n\"\n\"database will be used, even if environment variables LINES and COLUMNS (used\\n\"\n\"by default) are set, or if curses is running in a window (in which case\\n\"\n\"default behavior would be to use the window size if LINES and COLUMNS are\\n\"\n\"not set).\");\n\n#define _CURSES_USE_ENV_METHODDEF    \\\n    {\"use_env\", (PyCFunction)_curses_use_env, METH_O, _curses_use_env__doc__},\n\nstatic PyObject *\n_curses_use_env_impl(PyObject *module, int flag);\n\nstatic PyObject *\n_curses_use_env(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int flag;\n\n    flag = PyObject_IsTrue(arg);\n    if (flag < 0) {\n        goto exit;\n    }\n    return_value = _curses_use_env_impl(module, flag);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_CURSES_USE_ENV) */\n\n#if !defined(STRICT_SYSV_CURSES)\n\nPyDoc_STRVAR(_curses_use_default_colors__doc__,\n\"use_default_colors($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Allow use of default values for colors on terminals supporting this feature.\\n\"\n\"\\n\"\n\"Use this to support transparency in your application.  The default color\\n\"\n\"is assigned to the color number -1.\");\n\n#define _CURSES_USE_DEFAULT_COLORS_METHODDEF    \\\n    {\"use_default_colors\", (PyCFunction)_curses_use_default_colors, METH_NOARGS, _curses_use_default_colors__doc__},\n\nstatic PyObject *\n_curses_use_default_colors_impl(PyObject *module);\n\nstatic PyObject *\n_curses_use_default_colors(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_use_default_colors_impl(module);\n}\n\n#endif /* !defined(STRICT_SYSV_CURSES) */\n\nPyDoc_STRVAR(_curses_has_extended_color_support__doc__,\n\"has_extended_color_support($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the module supports extended colors; otherwise, return False.\\n\"\n\"\\n\"\n\"Extended color support allows more than 256 color-pairs for terminals\\n\"\n\"that support more than 16 colors (e.g. xterm-256color).\");\n\n#define _CURSES_HAS_EXTENDED_COLOR_SUPPORT_METHODDEF    \\\n    {\"has_extended_color_support\", (PyCFunction)_curses_has_extended_color_support, METH_NOARGS, _curses_has_extended_color_support__doc__},\n\nstatic PyObject *\n_curses_has_extended_color_support_impl(PyObject *module);\n\nstatic PyObject *\n_curses_has_extended_color_support(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return _curses_has_extended_color_support_impl(module);\n}\n\n#ifndef _CURSES_WINDOW_ENCLOSE_METHODDEF\n    #define _CURSES_WINDOW_ENCLOSE_METHODDEF\n#endif /* !defined(_CURSES_WINDOW_ENCLOSE_METHODDEF) */\n\n#ifndef _CURSES_WINDOW_GET_WCH_METHODDEF\n    #define _CURSES_WINDOW_GET_WCH_METHODDEF\n#endif /* !defined(_CURSES_WINDOW_GET_WCH_METHODDEF) */\n\n#ifndef _CURSES_WINDOW_NOUTREFRESH_METHODDEF\n    #define _CURSES_WINDOW_NOUTREFRESH_METHODDEF\n#endif /* !defined(_CURSES_WINDOW_NOUTREFRESH_METHODDEF) */\n\n#ifndef _CURSES_FILTER_METHODDEF\n    #define _CURSES_FILTER_METHODDEF\n#endif /* !defined(_CURSES_FILTER_METHODDEF) */\n\n#ifndef _CURSES_GETSYX_METHODDEF\n    #define _CURSES_GETSYX_METHODDEF\n#endif /* !defined(_CURSES_GETSYX_METHODDEF) */\n\n#ifndef _CURSES_GETMOUSE_METHODDEF\n    #define _CURSES_GETMOUSE_METHODDEF\n#endif /* !defined(_CURSES_GETMOUSE_METHODDEF) */\n\n#ifndef _CURSES_UNGETMOUSE_METHODDEF\n    #define _CURSES_UNGETMOUSE_METHODDEF\n#endif /* !defined(_CURSES_UNGETMOUSE_METHODDEF) */\n\n#ifndef _CURSES_HAS_KEY_METHODDEF\n    #define _CURSES_HAS_KEY_METHODDEF\n#endif /* !defined(_CURSES_HAS_KEY_METHODDEF) */\n\n#ifndef _CURSES_GET_ESCDELAY_METHODDEF\n    #define _CURSES_GET_ESCDELAY_METHODDEF\n#endif /* !defined(_CURSES_GET_ESCDELAY_METHODDEF) */\n\n#ifndef _CURSES_SET_ESCDELAY_METHODDEF\n    #define _CURSES_SET_ESCDELAY_METHODDEF\n#endif /* !defined(_CURSES_SET_ESCDELAY_METHODDEF) */\n\n#ifndef _CURSES_GET_TABSIZE_METHODDEF\n    #define _CURSES_GET_TABSIZE_METHODDEF\n#endif /* !defined(_CURSES_GET_TABSIZE_METHODDEF) */\n\n#ifndef _CURSES_SET_TABSIZE_METHODDEF\n    #define _CURSES_SET_TABSIZE_METHODDEF\n#endif /* !defined(_CURSES_SET_TABSIZE_METHODDEF) */\n\n#ifndef _CURSES_IS_TERM_RESIZED_METHODDEF\n    #define _CURSES_IS_TERM_RESIZED_METHODDEF\n#endif /* !defined(_CURSES_IS_TERM_RESIZED_METHODDEF) */\n\n#ifndef _CURSES_MOUSEINTERVAL_METHODDEF\n    #define _CURSES_MOUSEINTERVAL_METHODDEF\n#endif /* !defined(_CURSES_MOUSEINTERVAL_METHODDEF) */\n\n#ifndef _CURSES_MOUSEMASK_METHODDEF\n    #define _CURSES_MOUSEMASK_METHODDEF\n#endif /* !defined(_CURSES_MOUSEMASK_METHODDEF) */\n\n#ifndef _CURSES_UPDATE_LINES_COLS_METHODDEF\n    #define _CURSES_UPDATE_LINES_COLS_METHODDEF\n#endif /* !defined(_CURSES_UPDATE_LINES_COLS_METHODDEF) */\n\n#ifndef _CURSES_RESIZETERM_METHODDEF\n    #define _CURSES_RESIZETERM_METHODDEF\n#endif /* !defined(_CURSES_RESIZETERM_METHODDEF) */\n\n#ifndef _CURSES_RESIZE_TERM_METHODDEF\n    #define _CURSES_RESIZE_TERM_METHODDEF\n#endif /* !defined(_CURSES_RESIZE_TERM_METHODDEF) */\n\n#ifndef _CURSES_SETSYX_METHODDEF\n    #define _CURSES_SETSYX_METHODDEF\n#endif /* !defined(_CURSES_SETSYX_METHODDEF) */\n\n#ifndef _CURSES_TYPEAHEAD_METHODDEF\n    #define _CURSES_TYPEAHEAD_METHODDEF\n#endif /* !defined(_CURSES_TYPEAHEAD_METHODDEF) */\n\n#ifndef _CURSES_UNGET_WCH_METHODDEF\n    #define _CURSES_UNGET_WCH_METHODDEF\n#endif /* !defined(_CURSES_UNGET_WCH_METHODDEF) */\n\n#ifndef _CURSES_USE_ENV_METHODDEF\n    #define _CURSES_USE_ENV_METHODDEF\n#endif /* !defined(_CURSES_USE_ENV_METHODDEF) */\n\n#ifndef _CURSES_USE_DEFAULT_COLORS_METHODDEF\n    #define _CURSES_USE_DEFAULT_COLORS_METHODDEF\n#endif /* !defined(_CURSES_USE_DEFAULT_COLORS_METHODDEF) */\n/*[clinic end generated code: output=27a2364193b503c1 input=a9049054013a1b77]*/\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value 'ch[7]'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1107, "startColumn": 5, "endLine": 1109, "endColumn": 40}, "contextRegion": {"startLine": 1107, "endLine": 1109, "snippet": {"text": "    wborder(self->win,\n            ch[0], ch[1], ch[2], ch[3],\n            ch[4], ch[5], ch[6], ch[7]);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/_cursesmodule.c.h", "uriBaseId": "PWD"}, "region": {"startLine": 440, "startColumn": 1, "endColumn": 22}, "contextRegion": {"startLine": 440, "snippet": {"text": "_curses_window_border(PyCursesWindowObject *self, PyObject *const *args, Py_ssize_t nargs)\n"}}}, "logicalLocations": [{"name": "_curses_window_border", "fullyQualifiedName": "_curses_window_border", "decoratedName": "_curses_window_border", "kind": "function"}], "message": {"text": "entry to '_curses_window_border'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/_cursesmodule.c.h", "uriBaseId": "PWD"}, "region": {"startLine": 455, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 455, "snippet": {"text": "    if (nargs < 1) {\n"}}}, "logicalLocations": [{"name": "_curses_window_border", "fullyQualifiedName": "_curses_window_border", "decoratedName": "_curses_window_border", "kind": "function"}], "message": {"text": "following 'false' branch (when 'nargs > 0')..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/_cursesmodule.c.h", "uriBaseId": "PWD"}, "region": {"startLine": 458, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 458, "snippet": {"text": "    ls = args[0];\n"}}}, "logicalLocations": [{"name": "_curses_window_border", "fullyQualifiedName": "_curses_window_border", "decoratedName": "_curses_window_border", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/_cursesmodule.c.h", "uriBaseId": "PWD"}, "region": {"startLine": 459, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 459, "snippet": {"text": "    if (nargs < 2) {\n"}}}, "logicalLocations": [{"name": "_curses_window_border", "fullyQualifiedName": "_curses_window_border", "decoratedName": "_curses_window_border", "kind": "function"}], "message": {"text": "following 'false' branch (when 'nargs != 1')..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/_cursesmodule.c.h", "uriBaseId": "PWD"}, "region": {"startLine": 462, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 462, "snippet": {"text": "    rs = args[1];\n"}}}, "logicalLocations": [{"name": "_curses_window_border", "fullyQualifiedName": "_curses_window_border", "decoratedName": "_curses_window_border", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/_cursesmodule.c.h", "uriBaseId": "PWD"}, "region": {"startLine": 463, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 463, "snippet": {"text": "    if (nargs < 3) {\n"}}}, "logicalLocations": [{"name": "_curses_window_border", "fullyQualifiedName": "_curses_window_border", "decoratedName": "_curses_window_border", "kind": "function"}], "message": {"text": "following 'true' branch (when 'nargs == 2')..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/_cursesmodule.c.h", "uriBaseId": "PWD"}, "region": {"startLine": 464, "startColumn": 9, "endColumn": 13}, "contextRegion": {"startLine": 464, "snippet": {"text": "        goto skip_optional;\n"}}}, "logicalLocations": [{"name": "_curses_window_border", "fullyQualifiedName": "_curses_window_border", "decoratedName": "_curses_window_border", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/_cursesmodule.c.h", "uriBaseId": "PWD"}, "region": {"startLine": 488, "startColumn": 20, "endColumn": 84}, "contextRegion": {"startLine": 488, "snippet": {"text": "    return_value = _curses_window_border_impl(self, ls, rs, ts, bs, tl, tr, bl, br);\n"}}}, "logicalLocations": [{"name": "_curses_window_border", "fullyQualifiedName": "_curses_window_border", "decoratedName": "_curses_window_border", "kind": "function"}], "message": {"text": "calling '_curses_window_border_impl' from '_curses_window_border'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1079, "startColumn": 1, "endColumn": 27}, "contextRegion": {"startLine": 1079, "snippet": {"text": "_curses_window_border_impl(PyCursesWindowObject *self, PyObject *ls,\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "entry to '_curses_window_border_impl'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1085, "startColumn": 12, "endColumn": 14}, "contextRegion": {"startLine": 1085, "snippet": {"text": "    chtype ch[8];\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1089, "startColumn": 14, "endColumn": 17}, "contextRegion": {"startLine": 1089, "snippet": {"text": "    for(i=0; i<8; i++)\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i != 8')..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1090, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 1090, "snippet": {"text": "        ch[i] = 0;\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1089, "startColumn": 14, "endColumn": 17}, "contextRegion": {"startLine": 1089, "snippet": {"text": "    for(i=0; i<8; i++)\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "following 'false' branch (when 'i == 8')..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1096, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1096, "snippet": {"text": "    CONVERTTOCHTYPE(ls, 0);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1098, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1098, "snippet": {"text": "    CONVERTTOCHTYPE(ts, 2);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "following 'false' branch (when 'ts' is NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1098, "startColumn": 27, "endColumn": 28}, "contextRegion": {"startLine": 1098, "snippet": {"text": "    CONVERTTOCHTYPE(ts, 2);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1099, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1099, "snippet": {"text": "    CONVERTTOCHTYPE(bs, 3);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "following 'false' branch (when 'bs' is NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1099, "startColumn": 27, "endColumn": 28}, "contextRegion": {"startLine": 1099, "snippet": {"text": "    CONVERTTOCHTYPE(bs, 3);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1100, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1100, "snippet": {"text": "    CONVERTTOCHTYPE(tl, 4);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "following 'false' branch (when 'tl' is NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1100, "startColumn": 27, "endColumn": 28}, "contextRegion": {"startLine": 1100, "snippet": {"text": "    CONVERTTOCHTYPE(tl, 4);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1101, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1101, "snippet": {"text": "    CONVERTTOCHTYPE(tr, 5);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "following 'false' branch (when 'tr' is NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1101, "startColumn": 27, "endColumn": 28}, "contextRegion": {"startLine": 1101, "snippet": {"text": "    CONVERTTOCHTYPE(tr, 5);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1102, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1102, "snippet": {"text": "    CONVERTTOCHTYPE(bl, 6);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "following 'false' branch (when 'bl' is NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1102, "startColumn": 27, "endColumn": 28}, "contextRegion": {"startLine": 1102, "snippet": {"text": "    CONVERTTOCHTYPE(bl, 6);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1103, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 1103, "snippet": {"text": "    CONVERTTOCHTYPE(br, 7);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "following 'false' branch (when 'br' is NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1103, "startColumn": 27, "endColumn": 28}, "contextRegion": {"startLine": 1103, "snippet": {"text": "    CONVERTTOCHTYPE(br, 7);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 1107, "startColumn": 5, "endLine": 1109, "endColumn": 40}, "contextRegion": {"startLine": 1107, "endLine": 1109, "snippet": {"text": "    wborder(self->win,\n            ch[0], ch[1], ch[2], ch[3],\n            ch[4], ch[5], ch[6], ch[7]);\n"}}}, "logicalLocations": [{"name": "_curses_window_border_impl", "fullyQualifiedName": "_curses_window_border_impl", "decoratedName": "_curses_window_border_impl", "kind": "function"}], "message": {"text": "use of uninitialized value 'ch[7]' here"}}, "kinds": ["danger"], "nestingLevel": 2}]}]}]}, {"ruleId": "-Wanalyzer-null-dereference", "taxa": [{"id": "476", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "dereference of NULL 'winobj'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3352, "startColumn": 23, "endColumn": 39}, "contextRegion": {"startLine": 3352, "snippet": {"text": "    screen_encoding = winobj->encoding;\n"}}}, "logicalLocations": [{"name": "_curses_initscr_impl", "fullyQualifiedName": "_curses_initscr_impl", "decoratedName": "_curses_initscr_impl", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3251, "startColumn": 1, "endColumn": 21}, "contextRegion": {"startLine": 3251, "snippet": {"text": "_curses_initscr_impl(PyObject *module)\n"}}}, "logicalLocations": [{"name": "_curses_initscr_impl", "fullyQualifiedName": "_curses_initscr_impl", "decoratedName": "_curses_initscr_impl", "kind": "function"}], "message": {"text": "entry to '_curses_initscr_impl'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3257, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3257, "snippet": {"text": "    if (initialised) {\n"}}}, "logicalLocations": [{"name": "_curses_initscr_impl", "fullyQualifiedName": "_curses_initscr_impl", "decoratedName": "_curses_initscr_impl", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3262, "startColumn": 5, "endColumn": 8}, "contextRegion": {"startLine": 3262, "snippet": {"text": "    win = initscr();\n"}}}, "logicalLocations": [{"name": "_curses_initscr_impl", "fullyQualifiedName": "_curses_initscr_impl", "decoratedName": "_curses_initscr_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3264, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 3264, "snippet": {"text": "    if (win == NULL) {\n"}}}, "logicalLocations": [{"name": "_curses_initscr_impl", "fullyQualifiedName": "_curses_initscr_impl", "decoratedName": "_curses_initscr_impl", "kind": "function"}], "message": {"text": "following 'false' branch (when 'win' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3269, "startColumn": 5, "endColumn": 16}, "contextRegion": {"startLine": 3269, "snippet": {"text": "    initialised = initialised_setupterm = TRUE;\n"}}}, "logicalLocations": [{"name": "_curses_initscr_impl", "fullyQualifiedName": "_curses_initscr_impl", "decoratedName": "_curses_initscr_impl", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3351, "startColumn": 38, "endColumn": 67}, "contextRegion": {"startLine": 3351, "snippet": {"text": "    winobj = (PyCursesWindowObject *)PyCursesWindow_New(win, NULL);\n"}}}, "logicalLocations": [{"name": "_curses_initscr_impl", "fullyQualifiedName": "_curses_initscr_impl", "decoratedName": "_curses_initscr_impl", "kind": "function"}], "message": {"text": "calling 'PyCursesWindow_New' from '_curses_initscr_impl'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 670, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 670, "snippet": {"text": "PyCursesWindow_New(WINDOW *win, const char *encoding)\n"}}}, "logicalLocations": [{"name": "PyCursesWindow_New", "fullyQualifiedName": "PyCursesWindow_New", "decoratedName": "PyCursesWindow_New", "kind": "function"}], "message": {"text": "entry to 'PyCursesWindow_New'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 674, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 674, "snippet": {"text": "    if (encoding == NULL) {\n"}}}, "logicalLocations": [{"name": "PyCursesWindow_New", "fullyQualifiedName": "PyCursesWindow_New", "decoratedName": "PyCursesWindow_New", "kind": "function"}], "message": {"text": "following 'true' branch (when 'encoding' is NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 684, "startColumn": 9, "endColumn": 14}, "contextRegion": {"startLine": 684, "snippet": {"text": "        const char *codeset = nl_langinfo(CODESET);\n"}}}, "logicalLocations": [{"name": "PyCursesWindow_New", "fullyQualifiedName": "PyCursesWindow_New", "decoratedName": "PyCursesWindow_New", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3351, "startColumn": 38, "endColumn": 67}, "contextRegion": {"startLine": 3351, "snippet": {"text": "    winobj = (PyCursesWindowObject *)PyCursesWindow_New(win, NULL);\n"}}}, "logicalLocations": [{"name": "_curses_initscr_impl", "fullyQualifiedName": "_curses_initscr_impl", "decoratedName": "_curses_initscr_impl", "kind": "function"}], "message": {"text": "return of NULL to '_curses_initscr_impl' from 'PyCursesWindow_New'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_cursesmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 3352, "startColumn": 23, "endColumn": 39}, "contextRegion": {"startLine": 3352, "snippet": {"text": "    screen_encoding = winobj->encoding;\n"}}}, "logicalLocations": [{"name": "_curses_initscr_impl", "fullyQualifiedName": "_curses_initscr_impl", "decoratedName": "_curses_initscr_impl", "kind": "function"}], "message": {"text": "dereference of NULL 'winobj'"}}, "kinds": ["danger"], "nestingLevel": 1}]}]}]}]}]}
