{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-use-of-uninitialized-value",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-use-of-uninitialized-value"},
                                         {"id": "-Wstringop-overflow=",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Warning-Options.html#index-Wno-stringop-overflow"}]}},
           "taxonomies": [{"name": "CWE",
                           "version": "4.7",
                           "organization": "MITRE",
                           "shortDescription": {"text": "The MITRE Common Weakness Enumeration"},
                           "taxa": [{"id": "457",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/457.html"}]}],
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}},
           "artifacts": [{"location": {"uri": "./Modules/expat/xmltok.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/*\n                            __  __            _\n                         ___\\ \\/ /_ __   __ _| |_\n                        / _ \\\\  /| '_ \\ / _` | __|\n                       |  __//  \\| |_) | (_| | |_\n                        \\___/_/\\_\\ .__/ \\__,_|\\__|\n                                 |_| XML parser\n\n   Copyright (c) 1997-2000 Thai Open Source Software Center Ltd\n   Copyright (c) 2000      Clark Cooper <coopercc@users.sourceforge.net>\n   Copyright (c) 2001-2003 Fred L. Drake, Jr. <fdrake@users.sourceforge.net>\n   Copyright (c) 2002      Greg Stein <gstein@users.sourceforge.net>\n   Copyright (c) 2002-2016 Karl Waclawek <karl@waclawek.net>\n   Copyright (c) 2005-2009 Steven Solie <steven@solie.ca>\n   Copyright (c) 2016-2024 Sebastian Pipping <sebastian@pipping.org>\n   Copyright (c) 2016      Pascal Cuoq <cuoq@trust-in-soft.com>\n   Copyright (c) 2016      Don Lewis <truckman@apache.org>\n   Copyright (c) 2017      Rhodri James <rhodri@wildebeest.org.uk>\n   Copyright (c) 2017      Alexander Bluhm <alexander.bluhm@gmx.net>\n   Copyright (c) 2017      Benbuck Nason <bnason@netflix.com>\n   Copyright (c) 2017      José Gutiérrez de la Concha <jose@zeroc.com>\n   Copyright (c) 2019      David Loffredo <loffredo@steptools.com>\n   Copyright (c) 2021      Donghee Na <donghee.na@python.org>\n   Copyright (c) 2022      Martin Ettl <ettl.martin78@googlemail.com>\n   Copyright (c) 2022      Sean McBride <sean@rogue-research.com>\n   Copyright (c) 2023      Hanno Böck <hanno@gentoo.org>\n   Licensed under the MIT license:\n\n   Permission is  hereby granted,  free of charge,  to any  person obtaining\n   a  copy  of  this  software   and  associated  documentation  files  (the\n   \"Software\"),  to  deal in  the  Software  without restriction,  including\n   without  limitation the  rights  to use,  copy,  modify, merge,  publish,\n   distribute, sublicense, and/or sell copies of the Software, and to permit\n   persons  to whom  the Software  is  furnished to  do so,  subject to  the\n   following conditions:\n\n   The above copyright  notice and this permission notice  shall be included\n   in all copies or substantial portions of the Software.\n\n   THE  SOFTWARE  IS  PROVIDED  \"AS  IS\",  WITHOUT  WARRANTY  OF  ANY  KIND,\n   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR\n   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n   USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#include \"expat_config.h\"\n\n#include <stddef.h>\n#include <string.h> /* memcpy */\n#include <stdbool.h>\n\n#ifdef _WIN32\n#  include \"winconfig.h\"\n#endif\n\n#include \"expat_external.h\"\n#include \"internal.h\"\n#include \"xmltok.h\"\n#include \"nametab.h\"\n\n#ifdef XML_DTD\n#  define IGNORE_SECTION_TOK_VTABLE , PREFIX(ignoreSectionTok)\n#else\n#  define IGNORE_SECTION_TOK_VTABLE /* as nothing */\n#endif\n\n#define VTABLE1                                                                \\\n  {PREFIX(prologTok), PREFIX(contentTok),                                      \\\n   PREFIX(cdataSectionTok) IGNORE_SECTION_TOK_VTABLE},                         \\\n      {PREFIX(attributeValueTok), PREFIX(entityValueTok)},                     \\\n      PREFIX(nameMatchesAscii), PREFIX(nameLength), PREFIX(skipS),             \\\n      PREFIX(getAtts), PREFIX(charRefNumber), PREFIX(predefinedEntityName),    \\\n      PREFIX(updatePosition), PREFIX(isPublicId)\n\n#define VTABLE VTABLE1, PREFIX(toUtf8), PREFIX(toUtf16)\n\n#define UCS2_GET_NAMING(pages, hi, lo)                                         \\\n  (namingBitmap[(pages[hi] << 3) + ((lo) >> 5)] & (1u << ((lo) & 0x1F)))\n\n/* A 2 byte UTF-8 representation splits the characters 11 bits between\n   the bottom 5 and 6 bits of the bytes.  We need 8 bits to index into\n   pages, 3 bits to add to that index and 5 bits to generate the mask.\n*/\n#define UTF8_GET_NAMING2(pages, byte)                                          \\\n  (namingBitmap[((pages)[(((byte)[0]) >> 2) & 7] << 3)                         \\\n                + ((((byte)[0]) & 3) << 1) + ((((byte)[1]) >> 5) & 1)]         \\\n   & (1u << (((byte)[1]) & 0x1F)))\n\n/* A 3 byte UTF-8 representation splits the characters 16 bits between\n   the bottom 4, 6 and 6 bits of the bytes.  We need 8 bits to index\n   into pages, 3 bits to add to that index and 5 bits to generate the\n   mask.\n*/\n#define UTF8_GET_NAMING3(pages, byte)                                          \\\n  (namingBitmap                                                                \\\n       [((pages)[((((byte)[0]) & 0xF) << 4) + ((((byte)[1]) >> 2) & 0xF)]      \\\n         << 3)                                                                 \\\n        + ((((byte)[1]) & 3) << 1) + ((((byte)[2]) >> 5) & 1)]                 \\\n   & (1u << (((byte)[2]) & 0x1F)))\n\n/* Detection of invalid UTF-8 sequences is based on Table 3.1B\n   of Unicode 3.2: https://www.unicode.org/unicode/reports/tr28/\n   with the additional restriction of not allowing the Unicode\n   code points 0xFFFF and 0xFFFE (sequences EF,BF,BF and EF,BF,BE).\n   Implementation details:\n     (A & 0x80) == 0     means A < 0x80\n   and\n     (A & 0xC0) == 0xC0  means A > 0xBF\n*/\n\n#define UTF8_INVALID2(p)                                                       \\\n  ((*p) < 0xC2 || ((p)[1] & 0x80) == 0 || ((p)[1] & 0xC0) == 0xC0)\n\n#define UTF8_INVALID3(p)                                                       \\\n  (((p)[2] & 0x80) == 0                                                        \\\n   || ((*p) == 0xEF && (p)[1] == 0xBF ? (p)[2] > 0xBD                          \\\n                                      : ((p)[2] & 0xC0) == 0xC0)               \\\n   || ((*p) == 0xE0                                                            \\\n           ? (p)[1] < 0xA0 || ((p)[1] & 0xC0) == 0xC0                          \\\n           : ((p)[1] & 0x80) == 0                                              \\\n                 || ((*p) == 0xED ? (p)[1] > 0x9F : ((p)[1] & 0xC0) == 0xC0)))\n\n#define UTF8_INVALID4(p)                                                       \\\n  (((p)[3] & 0x80) == 0 || ((p)[3] & 0xC0) == 0xC0 || ((p)[2] & 0x80) == 0     \\\n   || ((p)[2] & 0xC0) == 0xC0                                                  \\\n   || ((*p) == 0xF0                                                            \\\n           ? (p)[1] < 0x90 || ((p)[1] & 0xC0) == 0xC0                          \\\n           : ((p)[1] & 0x80) == 0                                              \\\n                 || ((*p) == 0xF4 ? (p)[1] > 0x8F : ((p)[1] & 0xC0) == 0xC0)))\n\nstatic int PTRFASTCALL\nisNever(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  UNUSED_P(p);\n  return 0;\n}\n\nstatic int PTRFASTCALL\nutf8_isName2(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return UTF8_GET_NAMING2(namePages, (const unsigned char *)p);\n}\n\nstatic int PTRFASTCALL\nutf8_isName3(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return UTF8_GET_NAMING3(namePages, (const unsigned char *)p);\n}\n\n#define utf8_isName4 isNever\n\nstatic int PTRFASTCALL\nutf8_isNmstrt2(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return UTF8_GET_NAMING2(nmstrtPages, (const unsigned char *)p);\n}\n\nstatic int PTRFASTCALL\nutf8_isNmstrt3(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return UTF8_GET_NAMING3(nmstrtPages, (const unsigned char *)p);\n}\n\n#define utf8_isNmstrt4 isNever\n\nstatic int PTRFASTCALL\nutf8_isInvalid2(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return UTF8_INVALID2((const unsigned char *)p);\n}\n\nstatic int PTRFASTCALL\nutf8_isInvalid3(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return UTF8_INVALID3((const unsigned char *)p);\n}\n\nstatic int PTRFASTCALL\nutf8_isInvalid4(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return UTF8_INVALID4((const unsigned char *)p);\n}\n\nstruct normal_encoding {\n  ENCODING enc;\n  unsigned char type[256];\n#ifdef XML_MIN_SIZE\n  int(PTRFASTCALL *byteType)(const ENCODING *, const char *);\n  int(PTRFASTCALL *isNameMin)(const ENCODING *, const char *);\n  int(PTRFASTCALL *isNmstrtMin)(const ENCODING *, const char *);\n  int(PTRFASTCALL *byteToAscii)(const ENCODING *, const char *);\n  int(PTRCALL *charMatches)(const ENCODING *, const char *, int);\n#endif /* XML_MIN_SIZE */\n  int(PTRFASTCALL *isName2)(const ENCODING *, const char *);\n  int(PTRFASTCALL *isName3)(const ENCODING *, const char *);\n  int(PTRFASTCALL *isName4)(const ENCODING *, const char *);\n  int(PTRFASTCALL *isNmstrt2)(const ENCODING *, const char *);\n  int(PTRFASTCALL *isNmstrt3)(const ENCODING *, const char *);\n  int(PTRFASTCALL *isNmstrt4)(const ENCODING *, const char *);\n  int(PTRFASTCALL *isInvalid2)(const ENCODING *, const char *);\n  int(PTRFASTCALL *isInvalid3)(const ENCODING *, const char *);\n  int(PTRFASTCALL *isInvalid4)(const ENCODING *, const char *);\n};\n\n#define AS_NORMAL_ENCODING(enc) ((const struct normal_encoding *)(enc))\n\n#ifdef XML_MIN_SIZE\n\n#  define STANDARD_VTABLE(E)                                                   \\\n    E##byteType, E##isNameMin, E##isNmstrtMin, E##byteToAscii, E##charMatches,\n\n#else\n\n#  define STANDARD_VTABLE(E) /* as nothing */\n\n#endif\n\n#define NORMAL_VTABLE(E)                                                       \\\n  E##isName2, E##isName3, E##isName4, E##isNmstrt2, E##isNmstrt3,              \\\n      E##isNmstrt4, E##isInvalid2, E##isInvalid3, E##isInvalid4\n\n#define NULL_VTABLE                                                            \\\n  /* isName2 */ NULL, /* isName3 */ NULL, /* isName4 */ NULL,                  \\\n      /* isNmstrt2 */ NULL, /* isNmstrt3 */ NULL, /* isNmstrt4 */ NULL,        \\\n      /* isInvalid2 */ NULL, /* isInvalid3 */ NULL, /* isInvalid4 */ NULL\n\nstatic int FASTCALL checkCharRefNumber(int result);\n\n#include \"xmltok_impl.h\"\n#include \"ascii.h\"\n\n#ifdef XML_MIN_SIZE\n#  define sb_isNameMin isNever\n#  define sb_isNmstrtMin isNever\n#endif\n\n#ifdef XML_MIN_SIZE\n#  define MINBPC(enc) ((enc)->minBytesPerChar)\n#else\n/* minimum bytes per character */\n#  define MINBPC(enc) 1\n#endif\n\n#define SB_BYTE_TYPE(enc, p)                                                   \\\n  (((const struct normal_encoding *)(enc))->type[(unsigned char)*(p)])\n\n#ifdef XML_MIN_SIZE\nstatic int PTRFASTCALL\nsb_byteType(const ENCODING *enc, const char *p) {\n  return SB_BYTE_TYPE(enc, p);\n}\n#  define BYTE_TYPE(enc, p) (AS_NORMAL_ENCODING(enc)->byteType(enc, p))\n#else\n#  define BYTE_TYPE(enc, p) SB_BYTE_TYPE(enc, p)\n#endif\n\n#ifdef XML_MIN_SIZE\n#  define BYTE_TO_ASCII(enc, p) (AS_NORMAL_ENCODING(enc)->byteToAscii(enc, p))\nstatic int PTRFASTCALL\nsb_byteToAscii(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return *p;\n}\n#else\n#  define BYTE_TO_ASCII(enc, p) (*(p))\n#endif\n\n#define IS_NAME_CHAR(enc, p, n) (AS_NORMAL_ENCODING(enc)->isName##n(enc, p))\n#define IS_NMSTRT_CHAR(enc, p, n) (AS_NORMAL_ENCODING(enc)->isNmstrt##n(enc, p))\n#ifdef XML_MIN_SIZE\n#  define IS_INVALID_CHAR(enc, p, n)                                           \\\n    (AS_NORMAL_ENCODING(enc)->isInvalid##n                                     \\\n     && AS_NORMAL_ENCODING(enc)->isInvalid##n(enc, p))\n#else\n#  define IS_INVALID_CHAR(enc, p, n)                                           \\\n    (AS_NORMAL_ENCODING(enc)->isInvalid##n(enc, p))\n#endif\n\n#ifdef XML_MIN_SIZE\n#  define IS_NAME_CHAR_MINBPC(enc, p)                                          \\\n    (AS_NORMAL_ENCODING(enc)->isNameMin(enc, p))\n#  define IS_NMSTRT_CHAR_MINBPC(enc, p)                                        \\\n    (AS_NORMAL_ENCODING(enc)->isNmstrtMin(enc, p))\n#else\n#  define IS_NAME_CHAR_MINBPC(enc, p) (0)\n#  define IS_NMSTRT_CHAR_MINBPC(enc, p) (0)\n#endif\n\n#ifdef XML_MIN_SIZE\n#  define CHAR_MATCHES(enc, p, c)                                              \\\n    (AS_NORMAL_ENCODING(enc)->charMatches(enc, p, c))\nstatic int PTRCALL\nsb_charMatches(const ENCODING *enc, const char *p, int c) {\n  UNUSED_P(enc);\n  return *p == c;\n}\n#else\n/* c is an ASCII character */\n#  define CHAR_MATCHES(enc, p, c) (*(p) == (c))\n#endif\n\n#define PREFIX(ident) normal_##ident\n#define XML_TOK_IMPL_C\n#include \"xmltok_impl.c\"\n#undef XML_TOK_IMPL_C\n\n#undef MINBPC\n#undef BYTE_TYPE\n#undef BYTE_TO_ASCII\n#undef CHAR_MATCHES\n#undef IS_NAME_CHAR\n#undef IS_NAME_CHAR_MINBPC\n#undef IS_NMSTRT_CHAR\n#undef IS_NMSTRT_CHAR_MINBPC\n#undef IS_INVALID_CHAR\n\nenum { /* UTF8_cvalN is value of masked first byte of N byte sequence */\n       UTF8_cval1 = 0x00,\n       UTF8_cval2 = 0xc0,\n       UTF8_cval3 = 0xe0,\n       UTF8_cval4 = 0xf0\n};\n\nvoid\n_INTERNAL_trim_to_complete_utf8_characters(const char *from,\n                                           const char **fromLimRef) {\n  const char *fromLim = *fromLimRef;\n  size_t walked = 0;\n  for (; fromLim > from; fromLim--, walked++) {\n    const unsigned char prev = (unsigned char)fromLim[-1];\n    if ((prev & 0xf8u)\n        == 0xf0u) { /* 4-byte character, lead by 0b11110xxx byte */\n      if (walked + 1 >= 4) {\n        fromLim += 4 - 1;\n        break;\n      } else {\n        walked = 0;\n      }\n    } else if ((prev & 0xf0u)\n               == 0xe0u) { /* 3-byte character, lead by 0b1110xxxx byte */\n      if (walked + 1 >= 3) {\n        fromLim += 3 - 1;\n        break;\n      } else {\n        walked = 0;\n      }\n    } else if ((prev & 0xe0u)\n               == 0xc0u) { /* 2-byte character, lead by 0b110xxxxx byte */\n      if (walked + 1 >= 2) {\n        fromLim += 2 - 1;\n        break;\n      } else {\n        walked = 0;\n      }\n    } else if ((prev & 0x80u)\n               == 0x00u) { /* 1-byte character, matching 0b0xxxxxxx */\n      break;\n    }\n  }\n  *fromLimRef = fromLim;\n}\n\nstatic enum XML_Convert_Result PTRCALL\nutf8_toUtf8(const ENCODING *enc, const char **fromP, const char *fromLim,\n            char **toP, const char *toLim) {\n  bool input_incomplete = false;\n  bool output_exhausted = false;\n\n  /* Avoid copying partial characters (due to limited space). */\n  const ptrdiff_t bytesAvailable = fromLim - *fromP;\n  const ptrdiff_t bytesStorable = toLim - *toP;\n  UNUSED_P(enc);\n  if (bytesAvailable > bytesStorable) {\n    fromLim = *fromP + bytesStorable;\n    output_exhausted = true;\n  }\n\n  /* Avoid copying partial characters (from incomplete input). */\n  {\n    const char *const fromLimBefore = fromLim;\n    _INTERNAL_trim_to_complete_utf8_characters(*fromP, &fromLim);\n    if (fromLim < fromLimBefore) {\n      input_incomplete = true;\n    }\n  }\n\n  {\n    const ptrdiff_t bytesToCopy = fromLim - *fromP;\n    memcpy(*toP, *fromP, bytesToCopy);\n    *fromP += bytesToCopy;\n    *toP += bytesToCopy;\n  }\n\n  if (output_exhausted) /* needs to go first */\n    return XML_CONVERT_OUTPUT_EXHAUSTED;\n  else if (input_incomplete)\n    return XML_CONVERT_INPUT_INCOMPLETE;\n  else\n    return XML_CONVERT_COMPLETED;\n}\n\nstatic enum XML_Convert_Result PTRCALL\nutf8_toUtf16(const ENCODING *enc, const char **fromP, const char *fromLim,\n             unsigned short **toP, const unsigned short *toLim) {\n  enum XML_Convert_Result res = XML_CONVERT_COMPLETED;\n  unsigned short *to = *toP;\n  const char *from = *fromP;\n  while (from < fromLim && to < toLim) {\n    switch (SB_BYTE_TYPE(enc, from)) {\n    case BT_LEAD2:\n      if (fromLim - from < 2) {\n        res = XML_CONVERT_INPUT_INCOMPLETE;\n        goto after;\n      }\n      *to++ = (unsigned short)(((from[0] & 0x1f) << 6) | (from[1] & 0x3f));\n      from += 2;\n      break;\n    case BT_LEAD3:\n      if (fromLim - from < 3) {\n        res = XML_CONVERT_INPUT_INCOMPLETE;\n        goto after;\n      }\n      *to++ = (unsigned short)(((from[0] & 0xf) << 12) | ((from[1] & 0x3f) << 6)\n                               | (from[2] & 0x3f));\n      from += 3;\n      break;\n    case BT_LEAD4: {\n      unsigned long n;\n      if (toLim - to < 2) {\n        res = XML_CONVERT_OUTPUT_EXHAUSTED;\n        goto after;\n      }\n      if (fromLim - from < 4) {\n        res = XML_CONVERT_INPUT_INCOMPLETE;\n        goto after;\n      }\n      n = ((from[0] & 0x7) << 18) | ((from[1] & 0x3f) << 12)\n          | ((from[2] & 0x3f) << 6) | (from[3] & 0x3f);\n      n -= 0x10000;\n      to[0] = (unsigned short)((n >> 10) | 0xD800);\n      to[1] = (unsigned short)((n & 0x3FF) | 0xDC00);\n      to += 2;\n      from += 4;\n    } break;\n    default:\n      *to++ = *from++;\n      break;\n    }\n  }\n  if (from < fromLim)\n    res = XML_CONVERT_OUTPUT_EXHAUSTED;\nafter:\n  *fromP = from;\n  *toP = to;\n  return res;\n}\n\n#ifdef XML_NS\nstatic const struct normal_encoding utf8_encoding_ns\n    = {{VTABLE1, utf8_toUtf8, utf8_toUtf16, 1, 1, 0},\n       {\n#  include \"asciitab.h\"\n#  include \"utf8tab.h\"\n       },\n       STANDARD_VTABLE(sb_) NORMAL_VTABLE(utf8_)};\n#endif\n\nstatic const struct normal_encoding utf8_encoding\n    = {{VTABLE1, utf8_toUtf8, utf8_toUtf16, 1, 1, 0},\n       {\n#define BT_COLON BT_NMSTRT\n#include \"asciitab.h\"\n#undef BT_COLON\n#include \"utf8tab.h\"\n       },\n       STANDARD_VTABLE(sb_) NORMAL_VTABLE(utf8_)};\n\n#ifdef XML_NS\n\nstatic const struct normal_encoding internal_utf8_encoding_ns\n    = {{VTABLE1, utf8_toUtf8, utf8_toUtf16, 1, 1, 0},\n       {\n#  include \"iasciitab.h\"\n#  include \"utf8tab.h\"\n       },\n       STANDARD_VTABLE(sb_) NORMAL_VTABLE(utf8_)};\n\n#endif\n\nstatic const struct normal_encoding internal_utf8_encoding\n    = {{VTABLE1, utf8_toUtf8, utf8_toUtf16, 1, 1, 0},\n       {\n#define BT_COLON BT_NMSTRT\n#include \"iasciitab.h\"\n#undef BT_COLON\n#include \"utf8tab.h\"\n       },\n       STANDARD_VTABLE(sb_) NORMAL_VTABLE(utf8_)};\n\nstatic enum XML_Convert_Result PTRCALL\nlatin1_toUtf8(const ENCODING *enc, const char **fromP, const char *fromLim,\n              char **toP, const char *toLim) {\n  UNUSED_P(enc);\n  for (;;) {\n    unsigned char c;\n    if (*fromP == fromLim)\n      return XML_CONVERT_COMPLETED;\n    c = (unsigned char)**fromP;\n    if (c & 0x80) {\n      if (toLim - *toP < 2)\n        return XML_CONVERT_OUTPUT_EXHAUSTED;\n      *(*toP)++ = (char)((c >> 6) | UTF8_cval2);\n      *(*toP)++ = (char)((c & 0x3f) | 0x80);\n      (*fromP)++;\n    } else {\n      if (*toP == toLim)\n        return XML_CONVERT_OUTPUT_EXHAUSTED;\n      *(*toP)++ = *(*fromP)++;\n    }\n  }\n}\n\nstatic enum XML_Convert_Result PTRCALL\nlatin1_toUtf16(const ENCODING *enc, const char **fromP, const char *fromLim,\n               unsigned short **toP, const unsigned short *toLim) {\n  UNUSED_P(enc);\n  while (*fromP < fromLim && *toP < toLim)\n    *(*toP)++ = (unsigned char)*(*fromP)++;\n\n  if ((*toP == toLim) && (*fromP < fromLim))\n    return XML_CONVERT_OUTPUT_EXHAUSTED;\n  else\n    return XML_CONVERT_COMPLETED;\n}\n\n#ifdef XML_NS\n\nstatic const struct normal_encoding latin1_encoding_ns\n    = {{VTABLE1, latin1_toUtf8, latin1_toUtf16, 1, 0, 0},\n       {\n#  include \"asciitab.h\"\n#  include \"latin1tab.h\"\n       },\n       STANDARD_VTABLE(sb_) NULL_VTABLE};\n\n#endif\n\nstatic const struct normal_encoding latin1_encoding\n    = {{VTABLE1, latin1_toUtf8, latin1_toUtf16, 1, 0, 0},\n       {\n#define BT_COLON BT_NMSTRT\n#include \"asciitab.h\"\n#undef BT_COLON\n#include \"latin1tab.h\"\n       },\n       STANDARD_VTABLE(sb_) NULL_VTABLE};\n\nstatic enum XML_Convert_Result PTRCALL\nascii_toUtf8(const ENCODING *enc, const char **fromP, const char *fromLim,\n             char **toP, const char *toLim) {\n  UNUSED_P(enc);\n  while (*fromP < fromLim && *toP < toLim)\n    *(*toP)++ = *(*fromP)++;\n\n  if ((*toP == toLim) && (*fromP < fromLim))\n    return XML_CONVERT_OUTPUT_EXHAUSTED;\n  else\n    return XML_CONVERT_COMPLETED;\n}\n\n#ifdef XML_NS\n\nstatic const struct normal_encoding ascii_encoding_ns\n    = {{VTABLE1, ascii_toUtf8, latin1_toUtf16, 1, 1, 0},\n       {\n#  include \"asciitab.h\"\n           /* BT_NONXML == 0 */\n       },\n       STANDARD_VTABLE(sb_) NULL_VTABLE};\n\n#endif\n\nstatic const struct normal_encoding ascii_encoding\n    = {{VTABLE1, ascii_toUtf8, latin1_toUtf16, 1, 1, 0},\n       {\n#define BT_COLON BT_NMSTRT\n#include \"asciitab.h\"\n#undef BT_COLON\n           /* BT_NONXML == 0 */\n       },\n       STANDARD_VTABLE(sb_) NULL_VTABLE};\n\nstatic int PTRFASTCALL\nunicode_byte_type(char hi, char lo) {\n  switch ((unsigned char)hi) {\n  /* 0xD800-0xDBFF first 16-bit code unit or high surrogate (W1) */\n  case 0xD8:\n  case 0xD9:\n  case 0xDA:\n  case 0xDB:\n    return BT_LEAD4;\n  /* 0xDC00-0xDFFF second 16-bit code unit or low surrogate (W2) */\n  case 0xDC:\n  case 0xDD:\n  case 0xDE:\n  case 0xDF:\n    return BT_TRAIL;\n  case 0xFF:\n    switch ((unsigned char)lo) {\n    case 0xFF: /* noncharacter-FFFF */\n    case 0xFE: /* noncharacter-FFFE */\n      return BT_NONXML;\n    }\n    break;\n  }\n  return BT_NONASCII;\n}\n\n#define DEFINE_UTF16_TO_UTF8(E)                                                \\\n  static enum XML_Convert_Result PTRCALL E##toUtf8(                            \\\n      const ENCODING *enc, const char **fromP, const char *fromLim,            \\\n      char **toP, const char *toLim) {                                         \\\n    const char *from = *fromP;                                                 \\\n    UNUSED_P(enc);                                                             \\\n    fromLim = from + (((fromLim - from) >> 1) << 1); /* shrink to even */      \\\n    for (; from < fromLim; from += 2) {                                        \\\n      int plane;                                                               \\\n      unsigned char lo2;                                                       \\\n      unsigned char lo = GET_LO(from);                                         \\\n      unsigned char hi = GET_HI(from);                                         \\\n      switch (hi) {                                                            \\\n      case 0:                                                                  \\\n        if (lo < 0x80) {                                                       \\\n          if (*toP == toLim) {                                                 \\\n            *fromP = from;                                                     \\\n            return XML_CONVERT_OUTPUT_EXHAUSTED;                               \\\n          }                                                                    \\\n          *(*toP)++ = lo;                                                      \\\n          break;                                                               \\\n        }                                                                      \\\n        /* fall through */                                                     \\\n      case 0x1:                                                                \\\n      case 0x2:                                                                \\\n      case 0x3:                                                                \\\n      case 0x4:                                                                \\\n      case 0x5:                                                                \\\n      case 0x6:                                                                \\\n      case 0x7:                                                                \\\n        if (toLim - *toP < 2) {                                                \\\n          *fromP = from;                                                       \\\n          return XML_CONVERT_OUTPUT_EXHAUSTED;                                 \\\n        }                                                                      \\\n        *(*toP)++ = ((lo >> 6) | (hi << 2) | UTF8_cval2);                      \\\n        *(*toP)++ = ((lo & 0x3f) | 0x80);                                      \\\n        break;                                                                 \\\n      default:                                                                 \\\n        if (toLim - *toP < 3) {                                                \\\n          *fromP = from;                                                       \\\n          return XML_CONVERT_OUTPUT_EXHAUSTED;                                 \\\n        }                                                                      \\\n        /* 16 bits divided 4, 6, 6 amongst 3 bytes */                          \\\n        *(*toP)++ = ((hi >> 4) | UTF8_cval3);                                  \\\n        *(*toP)++ = (((hi & 0xf) << 2) | (lo >> 6) | 0x80);                    \\\n        *(*toP)++ = ((lo & 0x3f) | 0x80);                                      \\\n        break;                                                                 \\\n      case 0xD8:                                                               \\\n      case 0xD9:                                                               \\\n      case 0xDA:                                                               \\\n      case 0xDB:                                                               \\\n        if (toLim - *toP < 4) {                                                \\\n          *fromP = from;                                                       \\\n          return XML_CONVERT_OUTPUT_EXHAUSTED;                                 \\\n        }                                                                      \\\n        if (fromLim - from < 4) {                                              \\\n          *fromP = from;                                                       \\\n          return XML_CONVERT_INPUT_INCOMPLETE;                                 \\\n        }                                                                      \\\n        plane = (((hi & 0x3) << 2) | ((lo >> 6) & 0x3)) + 1;                   \\\n        *(*toP)++ = (char)((plane >> 2) | UTF8_cval4);                         \\\n        *(*toP)++ = (((lo >> 2) & 0xF) | ((plane & 0x3) << 4) | 0x80);         \\\n        from += 2;                                                             \\\n        lo2 = GET_LO(from);                                                    \\\n        *(*toP)++ = (((lo & 0x3) << 4) | ((GET_HI(from) & 0x3) << 2)           \\\n                     | (lo2 >> 6) | 0x80);                                     \\\n        *(*toP)++ = ((lo2 & 0x3f) | 0x80);                                     \\\n        break;                                                                 \\\n      }                                                                        \\\n    }                                                                          \\\n    *fromP = from;                                                             \\\n    if (from < fromLim)                                                        \\\n      return XML_CONVERT_INPUT_INCOMPLETE;                                     \\\n    else                                                                       \\\n      return XML_CONVERT_COMPLETED;                                            \\\n  }\n\n#define DEFINE_UTF16_TO_UTF16(E)                                               \\\n  static enum XML_Convert_Result PTRCALL E##toUtf16(                           \\\n      const ENCODING *enc, const char **fromP, const char *fromLim,            \\\n      unsigned short **toP, const unsigned short *toLim) {                     \\\n    enum XML_Convert_Result res = XML_CONVERT_COMPLETED;                       \\\n    UNUSED_P(enc);                                                             \\\n    fromLim = *fromP + (((fromLim - *fromP) >> 1) << 1); /* shrink to even */  \\\n    /* Avoid copying first half only of surrogate */                           \\\n    if (fromLim - *fromP > ((toLim - *toP) << 1)                               \\\n        && (GET_HI(fromLim - 2) & 0xF8) == 0xD8) {                             \\\n      fromLim -= 2;                                                            \\\n      res = XML_CONVERT_INPUT_INCOMPLETE;                                      \\\n    }                                                                          \\\n    for (; *fromP < fromLim && *toP < toLim; *fromP += 2)                      \\\n      *(*toP)++ = (GET_HI(*fromP) << 8) | GET_LO(*fromP);                      \\\n    if ((*toP == toLim) && (*fromP < fromLim))                                 \\\n      return XML_CONVERT_OUTPUT_EXHAUSTED;                                     \\\n    else                                                                       \\\n      return res;                                                              \\\n  }\n\n#define GET_LO(ptr) ((unsigned char)(ptr)[0])\n#define GET_HI(ptr) ((unsigned char)(ptr)[1])\n\nDEFINE_UTF16_TO_UTF8(little2_)\nDEFINE_UTF16_TO_UTF16(little2_)\n\n#undef GET_LO\n#undef GET_HI\n\n#define GET_LO(ptr) ((unsigned char)(ptr)[1])\n#define GET_HI(ptr) ((unsigned char)(ptr)[0])\n\nDEFINE_UTF16_TO_UTF8(big2_)\nDEFINE_UTF16_TO_UTF16(big2_)\n\n#undef GET_LO\n#undef GET_HI\n\n#define LITTLE2_BYTE_TYPE(enc, p)                                              \\\n  ((p)[1] == 0 ? SB_BYTE_TYPE(enc, p) : unicode_byte_type((p)[1], (p)[0]))\n#define LITTLE2_BYTE_TO_ASCII(p) ((p)[1] == 0 ? (p)[0] : -1)\n#define LITTLE2_CHAR_MATCHES(p, c) ((p)[1] == 0 && (p)[0] == (c))\n#define LITTLE2_IS_NAME_CHAR_MINBPC(p)                                         \\\n  UCS2_GET_NAMING(namePages, (unsigned char)p[1], (unsigned char)p[0])\n#define LITTLE2_IS_NMSTRT_CHAR_MINBPC(p)                                       \\\n  UCS2_GET_NAMING(nmstrtPages, (unsigned char)p[1], (unsigned char)p[0])\n\n#ifdef XML_MIN_SIZE\n\nstatic int PTRFASTCALL\nlittle2_byteType(const ENCODING *enc, const char *p) {\n  return LITTLE2_BYTE_TYPE(enc, p);\n}\n\nstatic int PTRFASTCALL\nlittle2_byteToAscii(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return LITTLE2_BYTE_TO_ASCII(p);\n}\n\nstatic int PTRCALL\nlittle2_charMatches(const ENCODING *enc, const char *p, int c) {\n  UNUSED_P(enc);\n  return LITTLE2_CHAR_MATCHES(p, c);\n}\n\nstatic int PTRFASTCALL\nlittle2_isNameMin(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return LITTLE2_IS_NAME_CHAR_MINBPC(p);\n}\n\nstatic int PTRFASTCALL\nlittle2_isNmstrtMin(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return LITTLE2_IS_NMSTRT_CHAR_MINBPC(p);\n}\n\n#  undef VTABLE\n#  define VTABLE VTABLE1, little2_toUtf8, little2_toUtf16\n\n#else /* not XML_MIN_SIZE */\n\n#  undef PREFIX\n#  define PREFIX(ident) little2_##ident\n#  define MINBPC(enc) 2\n/* CHAR_MATCHES is guaranteed to have MINBPC bytes available. */\n#  define BYTE_TYPE(enc, p) LITTLE2_BYTE_TYPE(enc, p)\n#  define BYTE_TO_ASCII(enc, p) LITTLE2_BYTE_TO_ASCII(p)\n#  define CHAR_MATCHES(enc, p, c) LITTLE2_CHAR_MATCHES(p, c)\n#  define IS_NAME_CHAR(enc, p, n) 0\n#  define IS_NAME_CHAR_MINBPC(enc, p) LITTLE2_IS_NAME_CHAR_MINBPC(p)\n#  define IS_NMSTRT_CHAR(enc, p, n) (0)\n#  define IS_NMSTRT_CHAR_MINBPC(enc, p) LITTLE2_IS_NMSTRT_CHAR_MINBPC(p)\n\n#  define XML_TOK_IMPL_C\n#  include \"xmltok_impl.c\"\n#  undef XML_TOK_IMPL_C\n\n#  undef MINBPC\n#  undef BYTE_TYPE\n#  undef BYTE_TO_ASCII\n#  undef CHAR_MATCHES\n#  undef IS_NAME_CHAR\n#  undef IS_NAME_CHAR_MINBPC\n#  undef IS_NMSTRT_CHAR\n#  undef IS_NMSTRT_CHAR_MINBPC\n#  undef IS_INVALID_CHAR\n\n#endif /* not XML_MIN_SIZE */\n\n#ifdef XML_NS\n\nstatic const struct normal_encoding little2_encoding_ns\n    = {{VTABLE, 2, 0,\n#  if BYTEORDER == 1234\n        1\n#  else\n        0\n#  endif\n       },\n       {\n#  include \"asciitab.h\"\n#  include \"latin1tab.h\"\n       },\n       STANDARD_VTABLE(little2_) NULL_VTABLE};\n\n#endif\n\nstatic const struct normal_encoding little2_encoding\n    = {{VTABLE, 2, 0,\n#if BYTEORDER == 1234\n        1\n#else\n        0\n#endif\n       },\n       {\n#define BT_COLON BT_NMSTRT\n#include \"asciitab.h\"\n#undef BT_COLON\n#include \"latin1tab.h\"\n       },\n       STANDARD_VTABLE(little2_) NULL_VTABLE};\n\n#if BYTEORDER != 4321\n\n#  ifdef XML_NS\n\nstatic const struct normal_encoding internal_little2_encoding_ns\n    = {{VTABLE, 2, 0, 1},\n       {\n#    include \"iasciitab.h\"\n#    include \"latin1tab.h\"\n       },\n       STANDARD_VTABLE(little2_) NULL_VTABLE};\n\n#  endif\n\nstatic const struct normal_encoding internal_little2_encoding\n    = {{VTABLE, 2, 0, 1},\n       {\n#  define BT_COLON BT_NMSTRT\n#  include \"iasciitab.h\"\n#  undef BT_COLON\n#  include \"latin1tab.h\"\n       },\n       STANDARD_VTABLE(little2_) NULL_VTABLE};\n\n#endif\n\n#define BIG2_BYTE_TYPE(enc, p)                                                 \\\n  ((p)[0] == 0 ? SB_BYTE_TYPE(enc, p + 1) : unicode_byte_type((p)[0], (p)[1]))\n#define BIG2_BYTE_TO_ASCII(p) ((p)[0] == 0 ? (p)[1] : -1)\n#define BIG2_CHAR_MATCHES(p, c) ((p)[0] == 0 && (p)[1] == (c))\n#define BIG2_IS_NAME_CHAR_MINBPC(p)                                            \\\n  UCS2_GET_NAMING(namePages, (unsigned char)p[0], (unsigned char)p[1])\n#define BIG2_IS_NMSTRT_CHAR_MINBPC(p)                                          \\\n  UCS2_GET_NAMING(nmstrtPages, (unsigned char)p[0], (unsigned char)p[1])\n\n#ifdef XML_MIN_SIZE\n\nstatic int PTRFASTCALL\nbig2_byteType(const ENCODING *enc, const char *p) {\n  return BIG2_BYTE_TYPE(enc, p);\n}\n\nstatic int PTRFASTCALL\nbig2_byteToAscii(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return BIG2_BYTE_TO_ASCII(p);\n}\n\nstatic int PTRCALL\nbig2_charMatches(const ENCODING *enc, const char *p, int c) {\n  UNUSED_P(enc);\n  return BIG2_CHAR_MATCHES(p, c);\n}\n\nstatic int PTRFASTCALL\nbig2_isNameMin(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return BIG2_IS_NAME_CHAR_MINBPC(p);\n}\n\nstatic int PTRFASTCALL\nbig2_isNmstrtMin(const ENCODING *enc, const char *p) {\n  UNUSED_P(enc);\n  return BIG2_IS_NMSTRT_CHAR_MINBPC(p);\n}\n\n#  undef VTABLE\n#  define VTABLE VTABLE1, big2_toUtf8, big2_toUtf16\n\n#else /* not XML_MIN_SIZE */\n\n#  undef PREFIX\n#  define PREFIX(ident) big2_##ident\n#  define MINBPC(enc) 2\n/* CHAR_MATCHES is guaranteed to have MINBPC bytes available. */\n#  define BYTE_TYPE(enc, p) BIG2_BYTE_TYPE(enc, p)\n#  define BYTE_TO_ASCII(enc, p) BIG2_BYTE_TO_ASCII(p)\n#  define CHAR_MATCHES(enc, p, c) BIG2_CHAR_MATCHES(p, c)\n#  define IS_NAME_CHAR(enc, p, n) 0\n#  define IS_NAME_CHAR_MINBPC(enc, p) BIG2_IS_NAME_CHAR_MINBPC(p)\n#  define IS_NMSTRT_CHAR(enc, p, n) (0)\n#  define IS_NMSTRT_CHAR_MINBPC(enc, p) BIG2_IS_NMSTRT_CHAR_MINBPC(p)\n\n#  define XML_TOK_IMPL_C\n#  include \"xmltok_impl.c\"\n#  undef XML_TOK_IMPL_C\n\n#  undef MINBPC\n#  undef BYTE_TYPE\n#  undef BYTE_TO_ASCII\n#  undef CHAR_MATCHES\n#  undef IS_NAME_CHAR\n#  undef IS_NAME_CHAR_MINBPC\n#  undef IS_NMSTRT_CHAR\n#  undef IS_NMSTRT_CHAR_MINBPC\n#  undef IS_INVALID_CHAR\n\n#endif /* not XML_MIN_SIZE */\n\n#ifdef XML_NS\n\nstatic const struct normal_encoding big2_encoding_ns\n    = {{VTABLE, 2, 0,\n#  if BYTEORDER == 4321\n        1\n#  else\n        0\n#  endif\n       },\n       {\n#  include \"asciitab.h\"\n#  include \"latin1tab.h\"\n       },\n       STANDARD_VTABLE(big2_) NULL_VTABLE};\n\n#endif\n\nstatic const struct normal_encoding big2_encoding\n    = {{VTABLE, 2, 0,\n#if BYTEORDER == 4321\n        1\n#else\n        0\n#endif\n       },\n       {\n#define BT_COLON BT_NMSTRT\n#include \"asciitab.h\"\n#undef BT_COLON\n#include \"latin1tab.h\"\n       },\n       STANDARD_VTABLE(big2_) NULL_VTABLE};\n\n#if BYTEORDER != 1234\n\n#  ifdef XML_NS\n\nstatic const struct normal_encoding internal_big2_encoding_ns\n    = {{VTABLE, 2, 0, 1},\n       {\n#    include \"iasciitab.h\"\n#    include \"latin1tab.h\"\n       },\n       STANDARD_VTABLE(big2_) NULL_VTABLE};\n\n#  endif\n\nstatic const struct normal_encoding internal_big2_encoding\n    = {{VTABLE, 2, 0, 1},\n       {\n#  define BT_COLON BT_NMSTRT\n#  include \"iasciitab.h\"\n#  undef BT_COLON\n#  include \"latin1tab.h\"\n       },\n       STANDARD_VTABLE(big2_) NULL_VTABLE};\n\n#endif\n\n#undef PREFIX\n\nstatic int FASTCALL\nstreqci(const char *s1, const char *s2) {\n  for (;;) {\n    char c1 = *s1++;\n    char c2 = *s2++;\n    if (ASCII_a <= c1 && c1 <= ASCII_z)\n      c1 += ASCII_A - ASCII_a;\n    if (ASCII_a <= c2 && c2 <= ASCII_z)\n      /* The following line will never get executed.  streqci() is\n       * only called from two places, both of which guarantee to put\n       * upper-case strings into s2.\n       */\n      c2 += ASCII_A - ASCII_a; /* LCOV_EXCL_LINE */\n    if (c1 != c2)\n      return 0;\n    if (! c1)\n      break;\n  }\n  return 1;\n}\n\nstatic void PTRCALL\ninitUpdatePosition(const ENCODING *enc, const char *ptr, const char *end,\n                   POSITION *pos) {\n  UNUSED_P(enc);\n  normal_updatePosition(&utf8_encoding.enc, ptr, end, pos);\n}\n\nstatic int\ntoAscii(const ENCODING *enc, const char *ptr, const char *end) {\n  char buf[1];\n  char *p = buf;\n  XmlUtf8Convert(enc, &ptr, end, &p, p + 1);\n  if (p == buf)\n    return -1;\n  else\n    return buf[0];\n}\n\nstatic int FASTCALL\nisSpace(int c) {\n  switch (c) {\n  case 0x20:\n  case 0xD:\n  case 0xA:\n  case 0x9:\n    return 1;\n  }\n  return 0;\n}\n\n/* Return 1 if there's just optional white space or there's an S\n   followed by name=val.\n*/\nstatic int\nparsePseudoAttribute(const ENCODING *enc, const char *ptr, const char *end,\n                     const char **namePtr, const char **nameEndPtr,\n                     const char **valPtr, const char **nextTokPtr) {\n  int c;\n  char open;\n  if (ptr == end) {\n    *namePtr = NULL;\n    return 1;\n  }\n  if (! isSpace(toAscii(enc, ptr, end))) {\n    *nextTokPtr = ptr;\n    return 0;\n  }\n  do {\n    ptr += enc->minBytesPerChar;\n  } while (isSpace(toAscii(enc, ptr, end)));\n  if (ptr == end) {\n    *namePtr = NULL;\n    return 1;\n  }\n  *namePtr = ptr;\n  for (;;) {\n    c = toAscii(enc, ptr, end);\n    if (c == -1) {\n      *nextTokPtr = ptr;\n      return 0;\n    }\n    if (c == ASCII_EQUALS) {\n      *nameEndPtr = ptr;\n      break;\n    }\n    if (isSpace(c)) {\n      *nameEndPtr = ptr;\n      do {\n        ptr += enc->minBytesPerChar;\n      } while (isSpace(c = toAscii(enc, ptr, end)));\n      if (c != ASCII_EQUALS) {\n        *nextTokPtr = ptr;\n        return 0;\n      }\n      break;\n    }\n    ptr += enc->minBytesPerChar;\n  }\n  if (ptr == *namePtr) {\n    *nextTokPtr = ptr;\n    return 0;\n  }\n  ptr += enc->minBytesPerChar;\n  c = toAscii(enc, ptr, end);\n  while (isSpace(c)) {\n    ptr += enc->minBytesPerChar;\n    c = toAscii(enc, ptr, end);\n  }\n  if (c != ASCII_QUOT && c != ASCII_APOS) {\n    *nextTokPtr = ptr;\n    return 0;\n  }\n  open = (char)c;\n  ptr += enc->minBytesPerChar;\n  *valPtr = ptr;\n  for (;; ptr += enc->minBytesPerChar) {\n    c = toAscii(enc, ptr, end);\n    if (c == open)\n      break;\n    if (! (ASCII_a <= c && c <= ASCII_z) && ! (ASCII_A <= c && c <= ASCII_Z)\n        && ! (ASCII_0 <= c && c <= ASCII_9) && c != ASCII_PERIOD\n        && c != ASCII_MINUS && c != ASCII_UNDERSCORE) {\n      *nextTokPtr = ptr;\n      return 0;\n    }\n  }\n  *nextTokPtr = ptr + enc->minBytesPerChar;\n  return 1;\n}\n\nstatic const char KW_version[]\n    = {ASCII_v, ASCII_e, ASCII_r, ASCII_s, ASCII_i, ASCII_o, ASCII_n, '\\0'};\n\nstatic const char KW_encoding[] = {ASCII_e, ASCII_n, ASCII_c, ASCII_o, ASCII_d,\n                                   ASCII_i, ASCII_n, ASCII_g, '\\0'};\n\nstatic const char KW_standalone[]\n    = {ASCII_s, ASCII_t, ASCII_a, ASCII_n, ASCII_d, ASCII_a,\n       ASCII_l, ASCII_o, ASCII_n, ASCII_e, '\\0'};\n\nstatic const char KW_yes[] = {ASCII_y, ASCII_e, ASCII_s, '\\0'};\n\nstatic const char KW_no[] = {ASCII_n, ASCII_o, '\\0'};\n\nstatic int\ndoParseXmlDecl(const ENCODING *(*encodingFinder)(const ENCODING *, const char *,\n                                                 const char *),\n               int isGeneralTextEntity, const ENCODING *enc, const char *ptr,\n               const char *end, const char **badPtr, const char **versionPtr,\n               const char **versionEndPtr, const char **encodingName,\n               const ENCODING **encoding, int *standalone) {\n  const char *val = NULL;\n  const char *name = NULL;\n  const char *nameEnd = NULL;\n  ptr += 5 * enc->minBytesPerChar;\n  end -= 2 * enc->minBytesPerChar;\n  if (! parsePseudoAttribute(enc, ptr, end, &name, &nameEnd, &val, &ptr)\n      || ! name) {\n    *badPtr = ptr;\n    return 0;\n  }\n  if (! XmlNameMatchesAscii(enc, name, nameEnd, KW_version)) {\n    if (! isGeneralTextEntity) {\n      *badPtr = name;\n      return 0;\n    }\n  } else {\n    if (versionPtr)\n      *versionPtr = val;\n    if (versionEndPtr)\n      *versionEndPtr = ptr;\n    if (! parsePseudoAttribute(enc, ptr, end, &name, &nameEnd, &val, &ptr)) {\n      *badPtr = ptr;\n      return 0;\n    }\n    if (! name) {\n      if (isGeneralTextEntity) {\n        /* a TextDecl must have an EncodingDecl */\n        *badPtr = ptr;\n        return 0;\n      }\n      return 1;\n    }\n  }\n  if (XmlNameMatchesAscii(enc, name, nameEnd, KW_encoding)) {\n    int c = toAscii(enc, val, end);\n    if (! (ASCII_a <= c && c <= ASCII_z) && ! (ASCII_A <= c && c <= ASCII_Z)) {\n      *badPtr = val;\n      return 0;\n    }\n    if (encodingName)\n      *encodingName = val;\n    if (encoding)\n      *encoding = encodingFinder(enc, val, ptr - enc->minBytesPerChar);\n    if (! parsePseudoAttribute(enc, ptr, end, &name, &nameEnd, &val, &ptr)) {\n      *badPtr = ptr;\n      return 0;\n    }\n    if (! name)\n      return 1;\n  }\n  if (! XmlNameMatchesAscii(enc, name, nameEnd, KW_standalone)\n      || isGeneralTextEntity) {\n    *badPtr = name;\n    return 0;\n  }\n  if (XmlNameMatchesAscii(enc, val, ptr - enc->minBytesPerChar, KW_yes)) {\n    if (standalone)\n      *standalone = 1;\n  } else if (XmlNameMatchesAscii(enc, val, ptr - enc->minBytesPerChar, KW_no)) {\n    if (standalone)\n      *standalone = 0;\n  } else {\n    *badPtr = val;\n    return 0;\n  }\n  while (isSpace(toAscii(enc, ptr, end)))\n    ptr += enc->minBytesPerChar;\n  if (ptr != end) {\n    *badPtr = ptr;\n    return 0;\n  }\n  return 1;\n}\n\nstatic int FASTCALL\ncheckCharRefNumber(int result) {\n  switch (result >> 8) {\n  case 0xD8:\n  case 0xD9:\n  case 0xDA:\n  case 0xDB:\n  case 0xDC:\n  case 0xDD:\n  case 0xDE:\n  case 0xDF:\n    return -1;\n  case 0:\n    if (latin1_encoding.type[result] == BT_NONXML)\n      return -1;\n    break;\n  case 0xFF:\n    if (result == 0xFFFE || result == 0xFFFF)\n      return -1;\n    break;\n  }\n  return result;\n}\n\nint FASTCALL\nXmlUtf8Encode(int c, char *buf) {\n  enum {\n    /* minN is minimum legal resulting value for N byte sequence */\n    min2 = 0x80,\n    min3 = 0x800,\n    min4 = 0x10000\n  };\n\n  if (c < 0)\n    return 0; /* LCOV_EXCL_LINE: this case is always eliminated beforehand */\n  if (c < min2) {\n    buf[0] = (char)(c | UTF8_cval1);\n    return 1;\n  }\n  if (c < min3) {\n    buf[0] = (char)((c >> 6) | UTF8_cval2);\n    buf[1] = (char)((c & 0x3f) | 0x80);\n    return 2;\n  }\n  if (c < min4) {\n    buf[0] = (char)((c >> 12) | UTF8_cval3);\n    buf[1] = (char)(((c >> 6) & 0x3f) | 0x80);\n    buf[2] = (char)((c & 0x3f) | 0x80);\n    return 3;\n  }\n  if (c < 0x110000) {\n    buf[0] = (char)((c >> 18) | UTF8_cval4);\n    buf[1] = (char)(((c >> 12) & 0x3f) | 0x80);\n    buf[2] = (char)(((c >> 6) & 0x3f) | 0x80);\n    buf[3] = (char)((c & 0x3f) | 0x80);\n    return 4;\n  }\n  return 0; /* LCOV_EXCL_LINE: this case too is eliminated before calling */\n}\n\nint FASTCALL\nXmlUtf16Encode(int charNum, unsigned short *buf) {\n  if (charNum < 0)\n    return 0;\n  if (charNum < 0x10000) {\n    buf[0] = (unsigned short)charNum;\n    return 1;\n  }\n  if (charNum < 0x110000) {\n    charNum -= 0x10000;\n    buf[0] = (unsigned short)((charNum >> 10) + 0xD800);\n    buf[1] = (unsigned short)((charNum & 0x3FF) + 0xDC00);\n    return 2;\n  }\n  return 0;\n}\n\nstruct unknown_encoding {\n  struct normal_encoding normal;\n  CONVERTER convert;\n  void *userData;\n  unsigned short utf16[256];\n  char utf8[256][4];\n};\n\n#define AS_UNKNOWN_ENCODING(enc) ((const struct unknown_encoding *)(enc))\n\nint\nXmlSizeOfUnknownEncoding(void) {\n  return sizeof(struct unknown_encoding);\n}\n\nstatic int PTRFASTCALL\nunknown_isName(const ENCODING *enc, const char *p) {\n  const struct unknown_encoding *uenc = AS_UNKNOWN_ENCODING(enc);\n  int c = uenc->convert(uenc->userData, p);\n  if (c & ~0xFFFF)\n    return 0;\n  return UCS2_GET_NAMING(namePages, c >> 8, c & 0xFF);\n}\n\nstatic int PTRFASTCALL\nunknown_isNmstrt(const ENCODING *enc, const char *p) {\n  const struct unknown_encoding *uenc = AS_UNKNOWN_ENCODING(enc);\n  int c = uenc->convert(uenc->userData, p);\n  if (c & ~0xFFFF)\n    return 0;\n  return UCS2_GET_NAMING(nmstrtPages, c >> 8, c & 0xFF);\n}\n\nstatic int PTRFASTCALL\nunknown_isInvalid(const ENCODING *enc, const char *p) {\n  const struct unknown_encoding *uenc = AS_UNKNOWN_ENCODING(enc);\n  int c = uenc->convert(uenc->userData, p);\n  return (c & ~0xFFFF) || checkCharRefNumber(c) < 0;\n}\n\nstatic enum XML_Convert_Result PTRCALL\nunknown_toUtf8(const ENCODING *enc, const char **fromP, const char *fromLim,\n               char **toP, const char *toLim) {\n  const struct unknown_encoding *uenc = AS_UNKNOWN_ENCODING(enc);\n  char buf[XML_UTF8_ENCODE_MAX];\n  for (;;) {\n    const char *utf8;\n    int n;\n    if (*fromP == fromLim)\n      return XML_CONVERT_COMPLETED;\n    utf8 = uenc->utf8[(unsigned char)**fromP];\n    n = *utf8++;\n    if (n == 0) {\n      int c = uenc->convert(uenc->userData, *fromP);\n      n = XmlUtf8Encode(c, buf);\n      if (n > toLim - *toP)\n        return XML_CONVERT_OUTPUT_EXHAUSTED;\n      utf8 = buf;\n      *fromP += (AS_NORMAL_ENCODING(enc)->type[(unsigned char)**fromP]\n                 - (BT_LEAD2 - 2));\n    } else {\n      if (n > toLim - *toP)\n        return XML_CONVERT_OUTPUT_EXHAUSTED;\n      (*fromP)++;\n    }\n    memcpy(*toP, utf8, n);\n    *toP += n;\n  }\n}\n\nstatic enum XML_Convert_Result PTRCALL\nunknown_toUtf16(const ENCODING *enc, const char **fromP, const char *fromLim,\n                unsigned short **toP, const unsigned short *toLim) {\n  const struct unknown_encoding *uenc = AS_UNKNOWN_ENCODING(enc);\n  while (*fromP < fromLim && *toP < toLim) {\n    unsigned short c = uenc->utf16[(unsigned char)**fromP];\n    if (c == 0) {\n      c = (unsigned short)uenc->convert(uenc->userData, *fromP);\n      *fromP += (AS_NORMAL_ENCODING(enc)->type[(unsigned char)**fromP]\n                 - (BT_LEAD2 - 2));\n    } else\n      (*fromP)++;\n    *(*toP)++ = c;\n  }\n\n  if ((*toP == toLim) && (*fromP < fromLim))\n    return XML_CONVERT_OUTPUT_EXHAUSTED;\n  else\n    return XML_CONVERT_COMPLETED;\n}\n\nENCODING *\nXmlInitUnknownEncoding(void *mem, int *table, CONVERTER convert,\n                       void *userData) {\n  int i;\n  struct unknown_encoding *e = (struct unknown_encoding *)mem;\n  memcpy(mem, &latin1_encoding, sizeof(struct normal_encoding));\n  for (i = 0; i < 128; i++)\n    if (latin1_encoding.type[i] != BT_OTHER\n        && latin1_encoding.type[i] != BT_NONXML && table[i] != i)\n      return 0;\n  for (i = 0; i < 256; i++) {\n    int c = table[i];\n    if (c == -1) {\n      e->normal.type[i] = BT_MALFORM;\n      /* This shouldn't really get used. */\n      e->utf16[i] = 0xFFFF;\n      e->utf8[i][0] = 1;\n      e->utf8[i][1] = 0;\n    } else if (c < 0) {\n      if (c < -4)\n        return 0;\n      /* Multi-byte sequences need a converter function */\n      if (! convert)\n        return 0;\n      e->normal.type[i] = (unsigned char)(BT_LEAD2 - (c + 2));\n      e->utf8[i][0] = 0;\n      e->utf16[i] = 0;\n    } else if (c < 0x80) {\n      if (latin1_encoding.type[c] != BT_OTHER\n          && latin1_encoding.type[c] != BT_NONXML && c != i)\n        return 0;\n      e->normal.type[i] = latin1_encoding.type[c];\n      e->utf8[i][0] = 1;\n      e->utf8[i][1] = (char)c;\n      e->utf16[i] = (unsigned short)(c == 0 ? 0xFFFF : c);\n    } else if (checkCharRefNumber(c) < 0) {\n      e->normal.type[i] = BT_NONXML;\n      /* This shouldn't really get used. */\n      e->utf16[i] = 0xFFFF;\n      e->utf8[i][0] = 1;\n      e->utf8[i][1] = 0;\n    } else {\n      if (c > 0xFFFF)\n        return 0;\n      if (UCS2_GET_NAMING(nmstrtPages, c >> 8, c & 0xff))\n        e->normal.type[i] = BT_NMSTRT;\n      else if (UCS2_GET_NAMING(namePages, c >> 8, c & 0xff))\n        e->normal.type[i] = BT_NAME;\n      else\n        e->normal.type[i] = BT_OTHER;\n      e->utf8[i][0] = (char)XmlUtf8Encode(c, e->utf8[i] + 1);\n      e->utf16[i] = (unsigned short)c;\n    }\n  }\n  e->userData = userData;\n  e->convert = convert;\n  if (convert) {\n    e->normal.isName2 = unknown_isName;\n    e->normal.isName3 = unknown_isName;\n    e->normal.isName4 = unknown_isName;\n    e->normal.isNmstrt2 = unknown_isNmstrt;\n    e->normal.isNmstrt3 = unknown_isNmstrt;\n    e->normal.isNmstrt4 = unknown_isNmstrt;\n    e->normal.isInvalid2 = unknown_isInvalid;\n    e->normal.isInvalid3 = unknown_isInvalid;\n    e->normal.isInvalid4 = unknown_isInvalid;\n  }\n  e->normal.enc.utf8Convert = unknown_toUtf8;\n  e->normal.enc.utf16Convert = unknown_toUtf16;\n  return &(e->normal.enc);\n}\n\n/* If this enumeration is changed, getEncodingIndex and encodings\nmust also be changed. */\nenum {\n  UNKNOWN_ENC = -1,\n  ISO_8859_1_ENC = 0,\n  US_ASCII_ENC,\n  UTF_8_ENC,\n  UTF_16_ENC,\n  UTF_16BE_ENC,\n  UTF_16LE_ENC,\n  /* must match encodingNames up to here */\n  NO_ENC\n};\n\nstatic const char KW_ISO_8859_1[]\n    = {ASCII_I, ASCII_S, ASCII_O,     ASCII_MINUS, ASCII_8, ASCII_8,\n       ASCII_5, ASCII_9, ASCII_MINUS, ASCII_1,     '\\0'};\nstatic const char KW_US_ASCII[]\n    = {ASCII_U, ASCII_S, ASCII_MINUS, ASCII_A, ASCII_S,\n       ASCII_C, ASCII_I, ASCII_I,     '\\0'};\nstatic const char KW_UTF_8[]\n    = {ASCII_U, ASCII_T, ASCII_F, ASCII_MINUS, ASCII_8, '\\0'};\nstatic const char KW_UTF_16[]\n    = {ASCII_U, ASCII_T, ASCII_F, ASCII_MINUS, ASCII_1, ASCII_6, '\\0'};\nstatic const char KW_UTF_16BE[]\n    = {ASCII_U, ASCII_T, ASCII_F, ASCII_MINUS, ASCII_1,\n       ASCII_6, ASCII_B, ASCII_E, '\\0'};\nstatic const char KW_UTF_16LE[]\n    = {ASCII_U, ASCII_T, ASCII_F, ASCII_MINUS, ASCII_1,\n       ASCII_6, ASCII_L, ASCII_E, '\\0'};\n\nstatic int FASTCALL\ngetEncodingIndex(const char *name) {\n  static const char *const encodingNames[] = {\n      KW_ISO_8859_1, KW_US_ASCII, KW_UTF_8, KW_UTF_16, KW_UTF_16BE, KW_UTF_16LE,\n  };\n  int i;\n  if (name == NULL)\n    return NO_ENC;\n  for (i = 0; i < (int)(sizeof(encodingNames) / sizeof(encodingNames[0])); i++)\n    if (streqci(name, encodingNames[i]))\n      return i;\n  return UNKNOWN_ENC;\n}\n\n/* For binary compatibility, we store the index of the encoding\n   specified at initialization in the isUtf16 member.\n*/\n\n#define INIT_ENC_INDEX(enc) ((int)(enc)->initEnc.isUtf16)\n#define SET_INIT_ENC_INDEX(enc, i) ((enc)->initEnc.isUtf16 = (char)i)\n\n/* This is what detects the encoding.  encodingTable maps from\n   encoding indices to encodings; INIT_ENC_INDEX(enc) is the index of\n   the external (protocol) specified encoding; state is\n   XML_CONTENT_STATE if we're parsing an external text entity, and\n   XML_PROLOG_STATE otherwise.\n*/\n\nstatic int\ninitScan(const ENCODING *const *encodingTable, const INIT_ENCODING *enc,\n         int state, const char *ptr, const char *end, const char **nextTokPtr) {\n  const ENCODING **encPtr;\n\n  if (ptr >= end)\n    return XML_TOK_NONE;\n  encPtr = enc->encPtr;\n  if (ptr + 1 == end) {\n    /* only a single byte available for auto-detection */\n#ifndef XML_DTD /* FIXME */\n    /* a well-formed document entity must have more than one byte */\n    if (state != XML_CONTENT_STATE)\n      return XML_TOK_PARTIAL;\n#endif\n    /* so we're parsing an external text entity... */\n    /* if UTF-16 was externally specified, then we need at least 2 bytes */\n    switch (INIT_ENC_INDEX(enc)) {\n    case UTF_16_ENC:\n    case UTF_16LE_ENC:\n    case UTF_16BE_ENC:\n      return XML_TOK_PARTIAL;\n    }\n    switch ((unsigned char)*ptr) {\n    case 0xFE:\n    case 0xFF:\n    case 0xEF: /* possibly first byte of UTF-8 BOM */\n      if (INIT_ENC_INDEX(enc) == ISO_8859_1_ENC && state == XML_CONTENT_STATE)\n        break;\n      /* fall through */\n    case 0x00:\n    case 0x3C:\n      return XML_TOK_PARTIAL;\n    }\n  } else {\n    switch (((unsigned char)ptr[0] << 8) | (unsigned char)ptr[1]) {\n    case 0xFEFF:\n      if (INIT_ENC_INDEX(enc) == ISO_8859_1_ENC && state == XML_CONTENT_STATE)\n        break;\n      *nextTokPtr = ptr + 2;\n      *encPtr = encodingTable[UTF_16BE_ENC];\n      return XML_TOK_BOM;\n    /* 00 3C is handled in the default case */\n    case 0x3C00:\n      if ((INIT_ENC_INDEX(enc) == UTF_16BE_ENC\n           || INIT_ENC_INDEX(enc) == UTF_16_ENC)\n          && state == XML_CONTENT_STATE)\n        break;\n      *encPtr = encodingTable[UTF_16LE_ENC];\n      return XmlTok(*encPtr, state, ptr, end, nextTokPtr);\n    case 0xFFFE:\n      if (INIT_ENC_INDEX(enc) == ISO_8859_1_ENC && state == XML_CONTENT_STATE)\n        break;\n      *nextTokPtr = ptr + 2;\n      *encPtr = encodingTable[UTF_16LE_ENC];\n      return XML_TOK_BOM;\n    case 0xEFBB:\n      /* Maybe a UTF-8 BOM (EF BB BF) */\n      /* If there's an explicitly specified (external) encoding\n         of ISO-8859-1 or some flavour of UTF-16\n         and this is an external text entity,\n         don't look for the BOM,\n         because it might be a legal data.\n      */\n      if (state == XML_CONTENT_STATE) {\n        int e = INIT_ENC_INDEX(enc);\n        if (e == ISO_8859_1_ENC || e == UTF_16BE_ENC || e == UTF_16LE_ENC\n            || e == UTF_16_ENC)\n          break;\n      }\n      if (ptr + 2 == end)\n        return XML_TOK_PARTIAL;\n      if ((unsigned char)ptr[2] == 0xBF) {\n        *nextTokPtr = ptr + 3;\n        *encPtr = encodingTable[UTF_8_ENC];\n        return XML_TOK_BOM;\n      }\n      break;\n    default:\n      if (ptr[0] == '\\0') {\n        /* 0 isn't a legal data character. Furthermore a document\n           entity can only start with ASCII characters.  So the only\n           way this can fail to be big-endian UTF-16 if it it's an\n           external parsed general entity that's labelled as\n           UTF-16LE.\n        */\n        if (state == XML_CONTENT_STATE && INIT_ENC_INDEX(enc) == UTF_16LE_ENC)\n          break;\n        *encPtr = encodingTable[UTF_16BE_ENC];\n        return XmlTok(*encPtr, state, ptr, end, nextTokPtr);\n      } else if (ptr[1] == '\\0') {\n        /* We could recover here in the case:\n            - parsing an external entity\n            - second byte is 0\n            - no externally specified encoding\n            - no encoding declaration\n           by assuming UTF-16LE.  But we don't, because this would mean when\n           presented just with a single byte, we couldn't reliably determine\n           whether we needed further bytes.\n        */\n        if (state == XML_CONTENT_STATE)\n          break;\n        *encPtr = encodingTable[UTF_16LE_ENC];\n        return XmlTok(*encPtr, state, ptr, end, nextTokPtr);\n      }\n      break;\n    }\n  }\n  *encPtr = encodingTable[INIT_ENC_INDEX(enc)];\n  return XmlTok(*encPtr, state, ptr, end, nextTokPtr);\n}\n\n#define NS(x) x\n#define ns(x) x\n#define XML_TOK_NS_C\n#include \"xmltok_ns.c\"\n#undef XML_TOK_NS_C\n#undef NS\n#undef ns\n\n#ifdef XML_NS\n\n#  define NS(x) x##NS\n#  define ns(x) x##_ns\n\n#  define XML_TOK_NS_C\n#  include \"xmltok_ns.c\"\n#  undef XML_TOK_NS_C\n\n#  undef NS\n#  undef ns\n\nENCODING *\nXmlInitUnknownEncodingNS(void *mem, int *table, CONVERTER convert,\n                         void *userData) {\n  ENCODING *enc = XmlInitUnknownEncoding(mem, table, convert, userData);\n  if (enc)\n    ((struct normal_encoding *)enc)->type[ASCII_COLON] = BT_COLON;\n  return enc;\n}\n\n#endif /* XML_NS */\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-use-of-uninitialized-value",
                        "taxa": [{"id": "457",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/enode": 25552,
                                       "gcc/analyzer/saved_diagnostic/snode": 663,
                                       "gcc/analyzer/saved_diagnostic/idx": 0},
                        "level": "warning",
                        "message": {"text": "use of uninitialized value 'utf8'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 1374,
                                                                       "startColumn": 5,
                                                                       "endColumn": 26},
                                                            "contextRegion": {"startLine": 1374,
                                                                              "snippet": {"text": "    memcpy(*toP, utf8, n);\n"}}},
                                       "logicalLocations": [{"name": "unknown_toUtf8",
                                                             "fullyQualifiedName": "unknown_toUtf8",
                                                             "decoratedName": "unknown_toUtf8",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_REGION_CREATION"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1353,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 1353,
                                                                                                                           "snippet": {"text": "  char buf[XML_UTF8_ENCODE_MAX];\n"}}},
                                                                                    "logicalLocations": [{"name": "unknown_toUtf8",
                                                                                                          "fullyQualifiedName": "unknown_toUtf8",
                                                                                                          "decoratedName": "unknown_toUtf8",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "region created on stack here"}},
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_REGION_CREATION"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1353,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 1353,
                                                                                                                           "snippet": {"text": "  char buf[XML_UTF8_ENCODE_MAX];\n"}}},
                                                                                    "logicalLocations": [{"name": "unknown_toUtf8",
                                                                                                          "fullyQualifiedName": "unknown_toUtf8",
                                                                                                          "decoratedName": "unknown_toUtf8",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "capacity: 4 bytes"}},
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 653,
                                                                                                                                 "dst_idx": 654,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1357,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1357,
                                                                                                                           "snippet": {"text": "    if (*fromP == fromLim)\n"}}},
                                                                                    "logicalLocations": [{"name": "unknown_toUtf8",
                                                                                                          "fullyQualifiedName": "unknown_toUtf8",
                                                                                                          "decoratedName": "unknown_toUtf8",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 653,
                                                                                                                                 "dst_idx": 654,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1359,
                                                                                                                    "startColumn": 38,
                                                                                                                    "endColumn": 45},
                                                                                                         "contextRegion": {"startLine": 1359,
                                                                                                                           "snippet": {"text": "    utf8 = uenc->utf8[(unsigned char)**fromP];\n"}}},
                                                                                    "logicalLocations": [{"name": "unknown_toUtf8",
                                                                                                          "fullyQualifiedName": "unknown_toUtf8",
                                                                                                          "decoratedName": "unknown_toUtf8",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 654,
                                                                                                                                 "dst_idx": 655,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1361,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1361,
                                                                                                                           "snippet": {"text": "    if (n == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "unknown_toUtf8",
                                                                                                          "fullyQualifiedName": "unknown_toUtf8",
                                                                                                          "decoratedName": "unknown_toUtf8",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'n == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 654,
                                                                                                                                 "dst_idx": 655,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1362,
                                                                                                                    "startColumn": 15,
                                                                                                                    "endColumn": 28},
                                                                                                         "contextRegion": {"startLine": 1362,
                                                                                                                           "snippet": {"text": "      int c = uenc->convert(uenc->userData, *fromP);\n"}}},
                                                                                    "logicalLocations": [{"name": "unknown_toUtf8",
                                                                                                          "fullyQualifiedName": "unknown_toUtf8",
                                                                                                          "decoratedName": "unknown_toUtf8",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 657,
                                                                                                                                 "dst_idx": 658,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1364,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 1364,
                                                                                                                           "snippet": {"text": "      if (n > toLim - *toP)\n"}}},
                                                                                    "logicalLocations": [{"name": "unknown_toUtf8",
                                                                                                          "fullyQualifiedName": "unknown_toUtf8",
                                                                                                          "decoratedName": "unknown_toUtf8",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 657,
                                                                                                                                 "dst_idx": 658,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1367,
                                                                                                                    "startColumn": 7,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1367,
                                                                                                                           "snippet": {"text": "      *fromP += (AS_NORMAL_ENCODING(enc)->type[(unsigned char)**fromP]\n"}}},
                                                                                    "logicalLocations": [{"name": "unknown_toUtf8",
                                                                                                          "fullyQualifiedName": "unknown_toUtf8",
                                                                                                          "decoratedName": "unknown_toUtf8",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 661,
                                                                                                                                 "dst_idx": 663,
                                                                                                                                 "desc": "false (flags FALSE_VALUE)"}},
                                                                       "location": {"logicalLocations": [{"name": "unknown_toUtf8",
                                                                                                          "fullyQualifiedName": "unknown_toUtf8",
                                                                                                          "decoratedName": "unknown_toUtf8",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 661,
                                                                                                                                 "dst_idx": 663,
                                                                                                                                 "desc": "false (flags FALSE_VALUE)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1374,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 26},
                                                                                                         "contextRegion": {"startLine": 1374,
                                                                                                                           "snippet": {"text": "    memcpy(*toP, utf8, n);\n"}}},
                                                                                    "logicalLocations": [{"name": "unknown_toUtf8",
                                                                                                          "fullyQualifiedName": "unknown_toUtf8",
                                                                                                          "decoratedName": "unknown_toUtf8",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1374,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 26},
                                                                                                         "contextRegion": {"startLine": 1374,
                                                                                                                           "snippet": {"text": "    memcpy(*toP, utf8, n);\n"}}},
                                                                                    "logicalLocations": [{"name": "unknown_toUtf8",
                                                                                                          "fullyQualifiedName": "unknown_toUtf8",
                                                                                                          "decoratedName": "unknown_toUtf8",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "use of uninitialized value 'utf8' here"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 11}]}]}]},
                       {"ruleId": "-Wstringop-overflow=",
                        "level": "warning",
                        "message": {"text": "'memcpy' writing 2 or more bytes into a region of size 1 overflows the destination"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 392,
                                                                       "startColumn": 5,
                                                                       "endColumn": 38},
                                                            "contextRegion": {"startLine": 392,
                                                                              "snippet": {"text": "    memcpy(*toP, *fromP, bytesToCopy);\n"}}},
                                       "logicalLocations": [{"name": "doParseXmlDecl",
                                                             "fullyQualifiedName": "doParseXmlDecl",
                                                             "decoratedName": "doParseXmlDecl",
                                                             "kind": "function"}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 1036,
                                                                              "startColumn": 8,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 1036,
                                                                                     "snippet": {"text": "  char buf[1];\n"}}},
                                              "message": {"text": "destination object 'buf' of size 1"}}]},
                       {"ruleId": "-Wstringop-overflow=",
                        "level": "warning",
                        "message": {"text": "'memcpy' writing 2 or more bytes into a region of size 1 overflows the destination"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 392,
                                                                       "startColumn": 5,
                                                                       "endColumn": 38},
                                                            "contextRegion": {"startLine": 392,
                                                                              "snippet": {"text": "    memcpy(*toP, *fromP, bytesToCopy);\n"}}},
                                       "logicalLocations": [{"name": "parsePseudoAttribute",
                                                             "fullyQualifiedName": "parsePseudoAttribute",
                                                             "decoratedName": "parsePseudoAttribute",
                                                             "kind": "function"}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 1036,
                                                                              "startColumn": 8,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 1036,
                                                                                     "snippet": {"text": "  char buf[1];\n"}}},
                                              "message": {"text": "destination object 'buf' of size 1"}}]},
                       {"ruleId": "-Wstringop-overflow=",
                        "level": "warning",
                        "message": {"text": "'memcpy' writing 2 or more bytes into a region of size 1 overflows the destination"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 392,
                                                                       "startColumn": 5,
                                                                       "endColumn": 38},
                                                            "contextRegion": {"startLine": 392,
                                                                              "snippet": {"text": "    memcpy(*toP, *fromP, bytesToCopy);\n"}}},
                                       "logicalLocations": [{"name": "parsePseudoAttribute",
                                                             "fullyQualifiedName": "parsePseudoAttribute",
                                                             "decoratedName": "parsePseudoAttribute",
                                                             "kind": "function"}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 1036,
                                                                              "startColumn": 8,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 1036,
                                                                                     "snippet": {"text": "  char buf[1];\n"}}},
                                              "message": {"text": "destination object 'buf' of size 1"}}]},
                       {"ruleId": "-Wstringop-overflow=",
                        "level": "warning",
                        "message": {"text": "'memcpy' writing 2 or more bytes into a region of size 1 overflows the destination"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 392,
                                                                       "startColumn": 5,
                                                                       "endColumn": 38},
                                                            "contextRegion": {"startLine": 392,
                                                                              "snippet": {"text": "    memcpy(*toP, *fromP, bytesToCopy);\n"}}},
                                       "logicalLocations": [{"name": "parsePseudoAttribute",
                                                             "fullyQualifiedName": "parsePseudoAttribute",
                                                             "decoratedName": "parsePseudoAttribute",
                                                             "kind": "function"}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 1036,
                                                                              "startColumn": 8,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 1036,
                                                                                     "snippet": {"text": "  char buf[1];\n"}}},
                                              "message": {"text": "destination object 'buf' of size 1"}}]},
                       {"ruleId": "-Wstringop-overflow=",
                        "level": "warning",
                        "message": {"text": "'memcpy' writing 2 or more bytes into a region of size 1 overflows the destination"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 392,
                                                                       "startColumn": 5,
                                                                       "endColumn": 38},
                                                            "contextRegion": {"startLine": 392,
                                                                              "snippet": {"text": "    memcpy(*toP, *fromP, bytesToCopy);\n"}}},
                                       "logicalLocations": [{"name": "parsePseudoAttribute",
                                                             "fullyQualifiedName": "parsePseudoAttribute",
                                                             "decoratedName": "parsePseudoAttribute",
                                                             "kind": "function"}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 1036,
                                                                              "startColumn": 8,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 1036,
                                                                                     "snippet": {"text": "  char buf[1];\n"}}},
                                              "message": {"text": "destination object 'buf' of size 1"}}]},
                       {"ruleId": "-Wstringop-overflow=",
                        "level": "warning",
                        "message": {"text": "'memcpy' writing 2 or more bytes into a region of size 1 overflows the destination"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 392,
                                                                       "startColumn": 5,
                                                                       "endColumn": 38},
                                                            "contextRegion": {"startLine": 392,
                                                                              "snippet": {"text": "    memcpy(*toP, *fromP, bytesToCopy);\n"}}},
                                       "logicalLocations": [{"name": "parsePseudoAttribute",
                                                             "fullyQualifiedName": "parsePseudoAttribute",
                                                             "decoratedName": "parsePseudoAttribute",
                                                             "kind": "function"}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 1036,
                                                                              "startColumn": 8,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 1036,
                                                                                     "snippet": {"text": "  char buf[1];\n"}}},
                                              "message": {"text": "destination object 'buf' of size 1"}}]},
                       {"ruleId": "-Wstringop-overflow=",
                        "level": "warning",
                        "message": {"text": "'memcpy' writing 2 or more bytes into a region of size 1 overflows the destination"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 392,
                                                                       "startColumn": 5,
                                                                       "endColumn": 38},
                                                            "contextRegion": {"startLine": 392,
                                                                              "snippet": {"text": "    memcpy(*toP, *fromP, bytesToCopy);\n"}}},
                                       "logicalLocations": [{"name": "parsePseudoAttribute",
                                                             "fullyQualifiedName": "parsePseudoAttribute",
                                                             "decoratedName": "parsePseudoAttribute",
                                                             "kind": "function"}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 1036,
                                                                              "startColumn": 8,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 1036,
                                                                                     "snippet": {"text": "  char buf[1];\n"}}},
                                              "message": {"text": "destination object 'buf' of size 1"}}]},
                       {"ruleId": "-Wstringop-overflow=",
                        "level": "warning",
                        "message": {"text": "'memcpy' writing 2 or more bytes into a region of size 1 overflows the destination"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 392,
                                                                       "startColumn": 5,
                                                                       "endColumn": 38},
                                                            "contextRegion": {"startLine": 392,
                                                                              "snippet": {"text": "    memcpy(*toP, *fromP, bytesToCopy);\n"}}},
                                       "logicalLocations": [{"name": "parsePseudoAttribute",
                                                             "fullyQualifiedName": "parsePseudoAttribute",
                                                             "decoratedName": "parsePseudoAttribute",
                                                             "kind": "function"}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 1036,
                                                                              "startColumn": 8,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 1036,
                                                                                     "snippet": {"text": "  char buf[1];\n"}}},
                                              "message": {"text": "destination object 'buf' of size 1"}}]},
                       {"ruleId": "-Wstringop-overflow=",
                        "level": "warning",
                        "message": {"text": "'memcpy' writing 2 or more bytes into a region of size 1 overflows the destination"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 392,
                                                                       "startColumn": 5,
                                                                       "endColumn": 38},
                                                            "contextRegion": {"startLine": 392,
                                                                              "snippet": {"text": "    memcpy(*toP, *fromP, bytesToCopy);\n"}}},
                                       "logicalLocations": [{"name": "parsePseudoAttribute",
                                                             "fullyQualifiedName": "parsePseudoAttribute",
                                                             "decoratedName": "parsePseudoAttribute",
                                                             "kind": "function"}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/expat/xmltok.c",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 1036,
                                                                              "startColumn": 8,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 1036,
                                                                                     "snippet": {"text": "  char buf[1];\n"}}},
                                              "message": {"text": "destination object 'buf' of size 1"}}]}]}]}
