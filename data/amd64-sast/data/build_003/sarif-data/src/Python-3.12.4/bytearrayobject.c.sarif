{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-out-of-bounds",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-out-of-bounds"}]}},
           "taxonomies": [{"name": "CWE",
                           "version": "4.7",
                           "organization": "MITRE",
                           "shortDescription": {"text": "The MITRE Common Weakness Enumeration"},
                           "taxa": [{"id": "787",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/787.html"}]}],
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}},
           "artifacts": [{"location": {"uri": "Objects/stringlib/transmogrify.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#if STRINGLIB_IS_UNICODE\n# error \"transmogrify.h only compatible with byte-wise strings\"\n#endif\n\n/* the more complicated methods.  parts of these should be pulled out into the\n   shared code in bytes_methods.c to cut down on duplicate code bloat.  */\n\n/*[clinic input]\nclass B \"PyObject *\" \"&PyType_Type\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=2935558188d97c76]*/\n\n#include \"clinic/transmogrify.h.h\"\n\nstatic inline PyObject *\nreturn_self(PyObject *self)\n{\n#if !STRINGLIB_MUTABLE\n    if (STRINGLIB_CHECK_EXACT(self)) {\n        return Py_NewRef(self);\n    }\n#endif\n    return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));\n}\n\n/*[clinic input]\nB.expandtabs as stringlib_expandtabs\n\n    tabsize: int = 8\n\nReturn a copy where all tab characters are expanded using spaces.\n\nIf tabsize is not given, a tab size of 8 characters is assumed.\n[clinic start generated code]*/\n\nstatic PyObject *\nstringlib_expandtabs_impl(PyObject *self, int tabsize)\n/*[clinic end generated code: output=069cb7fae72e4c2b input=3c6d3b12aa3ccbea]*/\n{\n    const char *e, *p;\n    char *q;\n    Py_ssize_t i, j;\n    PyObject *u;\n\n    /* First pass: determine size of output string */\n    i = j = 0;\n    e = STRINGLIB_STR(self) + STRINGLIB_LEN(self);\n    for (p = STRINGLIB_STR(self); p < e; p++) {\n        if (*p == '\\t') {\n            if (tabsize > 0) {\n                Py_ssize_t incr = tabsize - (j % tabsize);\n                if (j > PY_SSIZE_T_MAX - incr)\n                    goto overflow;\n                j += incr;\n            }\n        }\n        else {\n            if (j > PY_SSIZE_T_MAX - 1)\n                goto overflow;\n            j++;\n            if (*p == '\\n' || *p == '\\r') {\n                if (i > PY_SSIZE_T_MAX - j)\n                    goto overflow;\n                i += j;\n                j = 0;\n            }\n        }\n    }\n\n    if (i > PY_SSIZE_T_MAX - j)\n        goto overflow;\n\n    /* Second pass: create output string and fill it */\n    u = STRINGLIB_NEW(NULL, i + j);\n    if (!u)\n        return NULL;\n\n    j = 0;\n    q = STRINGLIB_STR(u);\n\n    for (p = STRINGLIB_STR(self); p < e; p++) {\n        if (*p == '\\t') {\n            if (tabsize > 0) {\n                i = tabsize - (j % tabsize);\n                j += i;\n                while (i--)\n                    *q++ = ' ';\n            }\n        }\n        else {\n            j++;\n            *q++ = *p;\n            if (*p == '\\n' || *p == '\\r')\n                j = 0;\n        }\n    }\n\n    return u;\n  overflow:\n    PyErr_SetString(PyExc_OverflowError, \"result too long\");\n    return NULL;\n}\n\nstatic inline PyObject *\npad(PyObject *self, Py_ssize_t left, Py_ssize_t right, char fill)\n{\n    PyObject *u;\n\n    if (left < 0)\n        left = 0;\n    if (right < 0)\n        right = 0;\n\n    if (left == 0 && right == 0) {\n        return return_self(self);\n    }\n\n    u = STRINGLIB_NEW(NULL, left + STRINGLIB_LEN(self) + right);\n    if (u) {\n        if (left)\n            memset(STRINGLIB_STR(u), fill, left);\n        memcpy(STRINGLIB_STR(u) + left,\n               STRINGLIB_STR(self),\n               STRINGLIB_LEN(self));\n        if (right)\n            memset(STRINGLIB_STR(u) + left + STRINGLIB_LEN(self),\n                   fill, right);\n    }\n\n    return u;\n}\n\n/*[clinic input]\nB.ljust as stringlib_ljust\n\n    width: Py_ssize_t\n    fillchar: char = b' '\n    /\n\nReturn a left-justified string of length width.\n\nPadding is done using the specified fill character.\n[clinic start generated code]*/\n\nstatic PyObject *\nstringlib_ljust_impl(PyObject *self, Py_ssize_t width, char fillchar)\n/*[clinic end generated code: output=c79ca173c5ff8337 input=eff2d014bc7d80df]*/\n{\n    if (STRINGLIB_LEN(self) >= width) {\n        return return_self(self);\n    }\n\n    return pad(self, 0, width - STRINGLIB_LEN(self), fillchar);\n}\n\n\n/*[clinic input]\nB.rjust as stringlib_rjust\n\n    width: Py_ssize_t\n    fillchar: char = b' '\n    /\n\nReturn a right-justified string of length width.\n\nPadding is done using the specified fill character.\n[clinic start generated code]*/\n\nstatic PyObject *\nstringlib_rjust_impl(PyObject *self, Py_ssize_t width, char fillchar)\n/*[clinic end generated code: output=7df5d728a5439570 input=218b0bd31308955d]*/\n{\n    if (STRINGLIB_LEN(self) >= width) {\n        return return_self(self);\n    }\n\n    return pad(self, width - STRINGLIB_LEN(self), 0, fillchar);\n}\n\n\n/*[clinic input]\nB.center as stringlib_center\n\n    width: Py_ssize_t\n    fillchar: char = b' '\n    /\n\nReturn a centered string of length width.\n\nPadding is done using the specified fill character.\n[clinic start generated code]*/\n\nstatic PyObject *\nstringlib_center_impl(PyObject *self, Py_ssize_t width, char fillchar)\n/*[clinic end generated code: output=d8da2e055288b4c2 input=3776fd278765d89b]*/\n{\n    Py_ssize_t marg, left;\n\n    if (STRINGLIB_LEN(self) >= width) {\n        return return_self(self);\n    }\n\n    marg = width - STRINGLIB_LEN(self);\n    left = marg / 2 + (marg & width & 1);\n\n    return pad(self, left, marg - left, fillchar);\n}\n\n/*[clinic input]\nB.zfill as stringlib_zfill\n\n    width: Py_ssize_t\n    /\n\nPad a numeric string with zeros on the left, to fill a field of the given width.\n\nThe original string is never truncated.\n[clinic start generated code]*/\n\nstatic PyObject *\nstringlib_zfill_impl(PyObject *self, Py_ssize_t width)\n/*[clinic end generated code: output=0b3c684a7f1b2319 input=2da6d7b8e9bcb19a]*/\n{\n    Py_ssize_t fill;\n    PyObject *s;\n    char *p;\n\n    if (STRINGLIB_LEN(self) >= width) {\n        return return_self(self);\n    }\n\n    fill = width - STRINGLIB_LEN(self);\n\n    s = pad(self, fill, 0, '0');\n\n    if (s == NULL)\n        return NULL;\n\n    p = STRINGLIB_STR(s);\n    if (p[fill] == '+' || p[fill] == '-') {\n        /* move sign to beginning of string */\n        p[0] = p[fill];\n        p[fill] = '0';\n    }\n\n    return s;\n}\n\n\n/* find and count characters and substrings */\n\n#define findchar(target, target_len, c)                         \\\n  ((char *)memchr((const void *)(target), c, target_len))\n\n\nstatic Py_ssize_t\ncountchar(const char *target, Py_ssize_t target_len, char c,\n          Py_ssize_t maxcount)\n{\n    Py_ssize_t count = 0;\n    const char *start = target;\n    const char *end = target + target_len;\n\n    while ((start = findchar(start, end - start, c)) != NULL) {\n        count++;\n        if (count >= maxcount)\n            break;\n        start += 1;\n    }\n    return count;\n}\n\n\n/* Algorithms for different cases of string replacement */\n\n/* len(self)>=1, from=\"\", len(to)>=1, maxcount>=1 */\nstatic PyObject *\nstringlib_replace_interleave(PyObject *self,\n                             const char *to_s, Py_ssize_t to_len,\n                             Py_ssize_t maxcount)\n{\n    const char *self_s;\n    char *result_s;\n    Py_ssize_t self_len, result_len;\n    Py_ssize_t count, i;\n    PyObject *result;\n\n    self_len = STRINGLIB_LEN(self);\n\n    /* 1 at the end plus 1 after every character;\n       count = min(maxcount, self_len + 1) */\n    if (maxcount <= self_len) {\n        count = maxcount;\n    }\n    else {\n        /* Can't overflow: self_len + 1 <= maxcount <= PY_SSIZE_T_MAX. */\n        count = self_len + 1;\n    }\n\n    /* Check for overflow */\n    /*   result_len = count * to_len + self_len; */\n    assert(count > 0);\n    if (to_len > (PY_SSIZE_T_MAX - self_len) / count) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"replace bytes is too long\");\n        return NULL;\n    }\n    result_len = count * to_len + self_len;\n    result = STRINGLIB_NEW(NULL, result_len);\n    if (result == NULL) {\n        return NULL;\n    }\n\n    self_s = STRINGLIB_STR(self);\n    result_s = STRINGLIB_STR(result);\n\n    if (to_len > 1) {\n        /* Lay the first one down (guaranteed this will occur) */\n        memcpy(result_s, to_s, to_len);\n        result_s += to_len;\n        count -= 1;\n\n        for (i = 0; i < count; i++) {\n            *result_s++ = *self_s++;\n            memcpy(result_s, to_s, to_len);\n            result_s += to_len;\n        }\n    }\n    else {\n        result_s[0] = to_s[0];\n        result_s += to_len;\n        count -= 1;\n        for (i = 0; i < count; i++) {\n            *result_s++ = *self_s++;\n            result_s[0] = to_s[0];\n            result_s += to_len;\n        }\n    }\n\n    /* Copy the rest of the original string */\n    memcpy(result_s, self_s, self_len - i);\n\n    return result;\n}\n\n/* Special case for deleting a single character */\n/* len(self)>=1, len(from)==1, to=\"\", maxcount>=1 */\nstatic PyObject *\nstringlib_replace_delete_single_character(PyObject *self,\n                                          char from_c, Py_ssize_t maxcount)\n{\n    const char *self_s, *start, *next, *end;\n    char *result_s;\n    Py_ssize_t self_len, result_len;\n    Py_ssize_t count;\n    PyObject *result;\n\n    self_len = STRINGLIB_LEN(self);\n    self_s = STRINGLIB_STR(self);\n\n    count = countchar(self_s, self_len, from_c, maxcount);\n    if (count == 0) {\n        return return_self(self);\n    }\n\n    result_len = self_len - count;  /* from_len == 1 */\n    assert(result_len>=0);\n\n    result = STRINGLIB_NEW(NULL, result_len);\n    if (result == NULL) {\n        return NULL;\n    }\n    result_s = STRINGLIB_STR(result);\n\n    start = self_s;\n    end = self_s + self_len;\n    while (count-- > 0) {\n        next = findchar(start, end - start, from_c);\n        if (next == NULL)\n            break;\n        memcpy(result_s, start, next - start);\n        result_s += (next - start);\n        start = next + 1;\n    }\n    memcpy(result_s, start, end - start);\n\n    return result;\n}\n\n/* len(self)>=1, len(from)>=2, to=\"\", maxcount>=1 */\n\nstatic PyObject *\nstringlib_replace_delete_substring(PyObject *self,\n                                   const char *from_s, Py_ssize_t from_len,\n                                   Py_ssize_t maxcount)\n{\n    const char *self_s, *start, *next, *end;\n    char *result_s;\n    Py_ssize_t self_len, result_len;\n    Py_ssize_t count, offset;\n    PyObject *result;\n\n    self_len = STRINGLIB_LEN(self);\n    self_s = STRINGLIB_STR(self);\n\n    count = stringlib_count(self_s, self_len,\n                            from_s, from_len,\n                            maxcount);\n\n    if (count == 0) {\n        /* no matches */\n        return return_self(self);\n    }\n\n    result_len = self_len - (count * from_len);\n    assert (result_len>=0);\n\n    result = STRINGLIB_NEW(NULL, result_len);\n    if (result == NULL) {\n        return NULL;\n    }\n    result_s = STRINGLIB_STR(result);\n\n    start = self_s;\n    end = self_s + self_len;\n    while (count-- > 0) {\n        offset = stringlib_find(start, end - start,\n                                from_s, from_len,\n                                0);\n        if (offset == -1)\n            break;\n        next = start + offset;\n\n        memcpy(result_s, start, next - start);\n\n        result_s += (next - start);\n        start = next + from_len;\n    }\n    memcpy(result_s, start, end - start);\n    return result;\n}\n\n/* len(self)>=1, len(from)==len(to)==1, maxcount>=1 */\nstatic PyObject *\nstringlib_replace_single_character_in_place(PyObject *self,\n                                            char from_c, char to_c,\n                                            Py_ssize_t maxcount)\n{\n    const char *self_s, *end;\n    char *result_s, *start, *next;\n    Py_ssize_t self_len;\n    PyObject *result;\n\n    /* The result string will be the same size */\n    self_s = STRINGLIB_STR(self);\n    self_len = STRINGLIB_LEN(self);\n\n    next = findchar(self_s, self_len, from_c);\n\n    if (next == NULL) {\n        /* No matches; return the original bytes */\n        return return_self(self);\n    }\n\n    /* Need to make a new bytes */\n    result = STRINGLIB_NEW(NULL, self_len);\n    if (result == NULL) {\n        return NULL;\n    }\n    result_s = STRINGLIB_STR(result);\n    memcpy(result_s, self_s, self_len);\n\n    /* change everything in-place, starting with this one */\n    start =  result_s + (next - self_s);\n    *start = to_c;\n    start++;\n    end = result_s + self_len;\n\n    while (--maxcount > 0) {\n        next = findchar(start, end - start, from_c);\n        if (next == NULL)\n            break;\n        *next = to_c;\n        start = next + 1;\n    }\n\n    return result;\n}\n\n/* len(self)>=1, len(from)==len(to)>=2, maxcount>=1 */\nstatic PyObject *\nstringlib_replace_substring_in_place(PyObject *self,\n                                     const char *from_s, Py_ssize_t from_len,\n                                     const char *to_s, Py_ssize_t to_len,\n                                     Py_ssize_t maxcount)\n{\n    const char *self_s, *end;\n    char *result_s, *start;\n    Py_ssize_t self_len, offset;\n    PyObject *result;\n\n    /* The result bytes will be the same size */\n\n    self_s = STRINGLIB_STR(self);\n    self_len = STRINGLIB_LEN(self);\n\n    offset = stringlib_find(self_s, self_len,\n                            from_s, from_len,\n                            0);\n    if (offset == -1) {\n        /* No matches; return the original bytes */\n        return return_self(self);\n    }\n\n    /* Need to make a new bytes */\n    result = STRINGLIB_NEW(NULL, self_len);\n    if (result == NULL) {\n        return NULL;\n    }\n    result_s = STRINGLIB_STR(result);\n    memcpy(result_s, self_s, self_len);\n\n    /* change everything in-place, starting with this one */\n    start =  result_s + offset;\n    memcpy(start, to_s, from_len);\n    start += from_len;\n    end = result_s + self_len;\n\n    while ( --maxcount > 0) {\n        offset = stringlib_find(start, end - start,\n                                from_s, from_len,\n                                0);\n        if (offset == -1)\n            break;\n        memcpy(start + offset, to_s, from_len);\n        start += offset + from_len;\n    }\n\n    return result;\n}\n\n/* len(self)>=1, len(from)==1, len(to)>=2, maxcount>=1 */\nstatic PyObject *\nstringlib_replace_single_character(PyObject *self,\n                                   char from_c,\n                                   const char *to_s, Py_ssize_t to_len,\n                                   Py_ssize_t maxcount)\n{\n    const char *self_s, *start, *next, *end;\n    char *result_s;\n    Py_ssize_t self_len, result_len;\n    Py_ssize_t count;\n    PyObject *result;\n\n    self_s = STRINGLIB_STR(self);\n    self_len = STRINGLIB_LEN(self);\n\n    count = countchar(self_s, self_len, from_c, maxcount);\n    if (count == 0) {\n        /* no matches, return unchanged */\n        return return_self(self);\n    }\n\n    /* use the difference between current and new, hence the \"-1\" */\n    /*   result_len = self_len + count * (to_len-1)  */\n    assert(count > 0);\n    if (to_len - 1 > (PY_SSIZE_T_MAX - self_len) / count) {\n        PyErr_SetString(PyExc_OverflowError, \"replace bytes is too long\");\n        return NULL;\n    }\n    result_len = self_len + count * (to_len - 1);\n\n    result = STRINGLIB_NEW(NULL, result_len);\n    if (result == NULL) {\n        return NULL;\n    }\n    result_s = STRINGLIB_STR(result);\n\n    start = self_s;\n    end = self_s + self_len;\n    while (count-- > 0) {\n        next = findchar(start, end - start, from_c);\n        if (next == NULL)\n            break;\n\n        if (next == start) {\n            /* replace with the 'to' */\n            memcpy(result_s, to_s, to_len);\n            result_s += to_len;\n            start += 1;\n        } else {\n            /* copy the unchanged old then the 'to' */\n            memcpy(result_s, start, next - start);\n            result_s += (next - start);\n            memcpy(result_s, to_s, to_len);\n            result_s += to_len;\n            start = next + 1;\n        }\n    }\n    /* Copy the remainder of the remaining bytes */\n    memcpy(result_s, start, end - start);\n\n    return result;\n}\n\n/* len(self)>=1, len(from)>=2, len(to)>=2, maxcount>=1 */\nstatic PyObject *\nstringlib_replace_substring(PyObject *self,\n                            const char *from_s, Py_ssize_t from_len,\n                            const char *to_s, Py_ssize_t to_len,\n                            Py_ssize_t maxcount)\n{\n    const char *self_s, *start, *next, *end;\n    char *result_s;\n    Py_ssize_t self_len, result_len;\n    Py_ssize_t count, offset;\n    PyObject *result;\n\n    self_s = STRINGLIB_STR(self);\n    self_len = STRINGLIB_LEN(self);\n\n    count = stringlib_count(self_s, self_len,\n                            from_s, from_len,\n                            maxcount);\n\n    if (count == 0) {\n        /* no matches, return unchanged */\n        return return_self(self);\n    }\n\n    /* Check for overflow */\n    /*    result_len = self_len + count * (to_len-from_len) */\n    assert(count > 0);\n    if (to_len - from_len > (PY_SSIZE_T_MAX - self_len) / count) {\n        PyErr_SetString(PyExc_OverflowError, \"replace bytes is too long\");\n        return NULL;\n    }\n    result_len = self_len + count * (to_len - from_len);\n\n    result = STRINGLIB_NEW(NULL, result_len);\n    if (result == NULL) {\n        return NULL;\n    }\n    result_s = STRINGLIB_STR(result);\n\n    start = self_s;\n    end = self_s + self_len;\n    while (count-- > 0) {\n        offset = stringlib_find(start, end - start,\n                                from_s, from_len,\n                                0);\n        if (offset == -1)\n            break;\n        next = start + offset;\n        if (next == start) {\n            /* replace with the 'to' */\n            memcpy(result_s, to_s, to_len);\n            result_s += to_len;\n            start += from_len;\n        } else {\n            /* copy the unchanged old then the 'to' */\n            memcpy(result_s, start, next - start);\n            result_s += (next - start);\n            memcpy(result_s, to_s, to_len);\n            result_s += to_len;\n            start = next + from_len;\n        }\n    }\n    /* Copy the remainder of the remaining bytes */\n    memcpy(result_s, start, end - start);\n\n    return result;\n}\n\n\nstatic PyObject *\nstringlib_replace(PyObject *self,\n                  const char *from_s, Py_ssize_t from_len,\n                  const char *to_s, Py_ssize_t to_len,\n                  Py_ssize_t maxcount)\n{\n    if (STRINGLIB_LEN(self) < from_len) {\n        /* nothing to do; return the original bytes */\n        return return_self(self);\n    }\n    if (maxcount < 0) {\n        maxcount = PY_SSIZE_T_MAX;\n    } else if (maxcount == 0) {\n        /* nothing to do; return the original bytes */\n        return return_self(self);\n    }\n\n    /* Handle zero-length special cases */\n    if (from_len == 0) {\n        if (to_len == 0) {\n            /* nothing to do; return the original bytes */\n            return return_self(self);\n        }\n        /* insert the 'to' bytes everywhere.    */\n        /*    >>> b\"Python\".replace(b\"\", b\".\")  */\n        /*    b'.P.y.t.h.o.n.'                  */\n        return stringlib_replace_interleave(self, to_s, to_len, maxcount);\n    }\n\n    if (to_len == 0) {\n        /* delete all occurrences of 'from' bytes */\n        if (from_len == 1) {\n            return stringlib_replace_delete_single_character(\n                self, from_s[0], maxcount);\n        } else {\n            return stringlib_replace_delete_substring(\n                self, from_s, from_len, maxcount);\n        }\n    }\n\n    /* Handle special case where both bytes have the same length */\n\n    if (from_len == to_len) {\n        if (from_len == 1) {\n            return stringlib_replace_single_character_in_place(\n                self, from_s[0], to_s[0], maxcount);\n        } else {\n            return stringlib_replace_substring_in_place(\n                self, from_s, from_len, to_s, to_len, maxcount);\n        }\n    }\n\n    /* Otherwise use the more generic algorithms */\n    if (from_len == 1) {\n        return stringlib_replace_single_character(\n            self, from_s[0], to_s, to_len, maxcount);\n    } else {\n        /* len('from')>=2, len('to')>=1 */\n        return stringlib_replace_substring(\n            self, from_s, from_len, to_s, to_len, maxcount);\n    }\n}\n\n#undef findchar\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/object.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_OBJECT_H\n#define Py_OBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Object and type object interface */\n\n/*\nObjects are structures allocated on the heap.  Special rules apply to\nthe use of objects to ensure they are properly garbage-collected.\nObjects are never allocated statically or on the stack; they must be\naccessed through special macros and functions only.  (Type objects are\nexceptions to the first rule; the standard types are represented by\nstatically initialized type objects, although work on type/class unification\nfor Python 2.2 made it possible to have heap-allocated type objects too).\n\nAn object has a 'reference count' that is increased or decreased when a\npointer to the object is copied or deleted; when the reference count\nreaches zero there are no references to the object left and it can be\nremoved from the heap.\n\nAn object has a 'type' that determines what it represents and what kind\nof data it contains.  An object's type is fixed when it is created.\nTypes themselves are represented as objects; an object contains a\npointer to the corresponding type object.  The type itself has a type\npointer pointing to the object representing the type 'type', which\ncontains a pointer to itself!.\n\nObjects do not float around in memory; once allocated an object keeps\nthe same size and address.  Objects that must hold variable-size data\ncan contain pointers to variable-size parts of the object.  Not all\nobjects of the same type have the same size; but the size cannot change\nafter allocation.  (These restrictions are made so a reference to an\nobject can be simply a pointer -- moving an object would require\nupdating all the pointers, and changing an object's size would require\nmoving it if there was another object right next to it.)\n\nObjects are always accessed through pointers of the type 'PyObject *'.\nThe type 'PyObject' is a structure that only contains the reference count\nand the type pointer.  The actual memory allocated for an object\ncontains other data that can only be accessed after casting the pointer\nto a pointer to a longer structure type.  This longer type must start\nwith the reference count and type fields; the macro PyObject_HEAD should be\nused for this (to accommodate for future changes).  The implementation\nof a particular object type can cast the object pointer to the proper\ntype and back.\n\nA standard interface exists for objects that contain an array of items\nwhose size is determined when the object is allocated.\n*/\n\n#include \"pystats.h\"\n\n/* Py_DEBUG implies Py_REF_DEBUG. */\n#if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)\n#  define Py_REF_DEBUG\n#endif\n\n#if defined(Py_LIMITED_API) && defined(Py_TRACE_REFS)\n#  error Py_LIMITED_API is incompatible with Py_TRACE_REFS\n#endif\n\n#ifdef Py_TRACE_REFS\n/* Define pointers to support a doubly-linked list of all live heap objects. */\n#define _PyObject_HEAD_EXTRA            \\\n    PyObject *_ob_next;           \\\n    PyObject *_ob_prev;\n\n#define _PyObject_EXTRA_INIT _Py_NULL, _Py_NULL,\n\n#else\n#  define _PyObject_HEAD_EXTRA\n#  define _PyObject_EXTRA_INIT\n#endif\n\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   PyObject ob_base;\n\n/*\nImmortalization:\n\nThe following indicates the immortalization strategy depending on the amount\nof available bits in the reference count field. All strategies are backwards\ncompatible but the specific reference count value or immortalization check\nmight change depending on the specializations for the underlying system.\n\nProper deallocation of immortal instances requires distinguishing between\nstatically allocated immortal instances vs those promoted by the runtime to be\nimmortal. The latter should be the only instances that require\ncleanup during runtime finalization.\n*/\n\n#if SIZEOF_VOID_P > 4\n/*\nIn 64+ bit systems, an object will be marked as immortal by setting all of the\nlower 32 bits of the reference count field, which is equal to: 0xFFFFFFFF\n\nUsing the lower 32 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases will use saturated arithmetic, taking advantage of\nhaving all the lower 32 bits set, which will avoid the reference count to go\nbeyond the refcount limit. Immortality checks for reference count decreases will\nbe done by checking the bit sign flag in the lower 32 bits.\n*/\n#define _Py_IMMORTAL_REFCNT UINT_MAX\n\n#else\n/*\nIn 32 bit systems, an object will be marked as immortal by setting all of the\nlower 30 bits of the reference count field, which is equal to: 0x3FFFFFFF\n\nUsing the lower 30 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases and decreases will first go through an immortality\ncheck by comparing the reference count field to the immortality reference count.\n*/\n#define _Py_IMMORTAL_REFCNT (UINT_MAX >> 2)\n#endif\n\n// Make all internal uses of PyObject_HEAD_INIT immortal while preserving the\n// C-API expectation that the refcnt will be set to 1.\n#ifdef Py_BUILD_CORE\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        _PyObject_EXTRA_INIT        \\\n        { _Py_IMMORTAL_REFCNT },    \\\n        (type)                      \\\n    },\n#else\n#define PyObject_HEAD_INIT(type) \\\n    {                            \\\n        _PyObject_EXTRA_INIT     \\\n        { 1 },                   \\\n        (type)                   \\\n    },\n#endif /* Py_BUILD_CORE */\n\n#define PyVarObject_HEAD_INIT(type, size) \\\n    {                                     \\\n        PyObject_HEAD_INIT(type)          \\\n        (size)                            \\\n    },\n\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD      PyVarObject ob_base;\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\nstruct _object {\n    _PyObject_HEAD_EXTRA\n\n#if (defined(__GNUC__) || defined(__clang__)) \\\n        && !(defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L)\n    // On C99 and older, anonymous union is a GCC and clang extension\n    __extension__\n#endif\n#ifdef _MSC_VER\n    // Ignore MSC warning C4201: \"nonstandard extension used:\n    // nameless struct/union\"\n    __pragma(warning(push))\n    __pragma(warning(disable: 4201))\n#endif\n    union {\n       Py_ssize_t ob_refcnt;\n#if SIZEOF_VOID_P > 4\n       PY_UINT32_T ob_refcnt_split[2];\n#endif\n    };\n#ifdef _MSC_VER\n    __pragma(warning(pop))\n#endif\n\n    PyTypeObject *ob_type;\n};\n\n/* Cast argument to PyObject* type. */\n#define _PyObject_CAST(op) _Py_CAST(PyObject*, (op))\n\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n/* Cast argument to PyVarObject* type. */\n#define _PyVarObject_CAST(op) _Py_CAST(PyVarObject*, (op))\n\n\n// Test if the 'x' object is the 'y' object, the same as \"x is y\" in Python.\nPyAPI_FUNC(int) Py_Is(PyObject *x, PyObject *y);\n#define Py_Is(x, y) ((x) == (y))\n\n\nstatic inline Py_ssize_t Py_REFCNT(PyObject *ob) {\n    return ob->ob_refcnt;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_REFCNT(ob) Py_REFCNT(_PyObject_CAST(ob))\n#endif\n\n\n// bpo-39573: The Py_SET_TYPE() function must be used to set an object type.\nstatic inline PyTypeObject* Py_TYPE(PyObject *ob) {\n    return ob->ob_type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_TYPE(ob) Py_TYPE(_PyObject_CAST(ob))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyLong_Type;\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n\n// bpo-39573: The Py_SET_SIZE() function must be used to set an object size.\nstatic inline Py_ssize_t Py_SIZE(PyObject *ob) {\n    assert(ob->ob_type != &PyLong_Type);\n    assert(ob->ob_type != &PyBool_Type);\n    return  _PyVarObject_CAST(ob)->ob_size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SIZE(ob) Py_SIZE(_PyObject_CAST(ob))\n#endif\n\nstatic inline Py_ALWAYS_INLINE int _Py_IsImmortal(PyObject *op)\n{\n#if SIZEOF_VOID_P > 4\n    return _Py_CAST(PY_INT32_T, op->ob_refcnt) < 0;\n#else\n    return op->ob_refcnt == _Py_IMMORTAL_REFCNT;\n#endif\n}\n#define _Py_IsImmortal(op) _Py_IsImmortal(_PyObject_CAST(op))\n\nstatic inline int Py_IS_TYPE(PyObject *ob, PyTypeObject *type) {\n    return Py_TYPE(ob) == type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_IS_TYPE(ob, type) Py_IS_TYPE(_PyObject_CAST(ob), (type))\n#endif\n\n\nstatic inline void Py_SET_REFCNT(PyObject *ob, Py_ssize_t refcnt) {\n    // This immortal check is for code that is unaware of immortal objects.\n    // The runtime tracks these objects and we should avoid as much\n    // as possible having extensions inadvertently change the refcnt\n    // of an immortalized object.\n    if (_Py_IsImmortal(ob)) {\n        return;\n    }\n    ob->ob_refcnt = refcnt;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_REFCNT(ob, refcnt) Py_SET_REFCNT(_PyObject_CAST(ob), (refcnt))\n#endif\n\n\nstatic inline void Py_SET_TYPE(PyObject *ob, PyTypeObject *type) {\n    ob->ob_type = type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_TYPE(ob, type) Py_SET_TYPE(_PyObject_CAST(ob), type)\n#endif\n\nstatic inline void Py_SET_SIZE(PyVarObject *ob, Py_ssize_t size) {\n    assert(ob->ob_base.ob_type != &PyLong_Type);\n    assert(ob->ob_base.ob_type != &PyBool_Type);\n    ob->ob_size = size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_SIZE(ob, size) Py_SET_SIZE(_PyVarObject_CAST(ob), (size))\n#endif\n\n\n/*\nType objects contain a string containing the type name (to help somewhat\nin debugging), the allocation parameters (see PyObject_New() and\nPyObject_NewVar()),\nand methods for accessing objects of the type.  Methods are optional, a\nnil pointer meaning that particular kind of access is not available for\nthis type.  The Py_DECREF() macro uses the tp_dealloc method without\nchecking for a nil pointer; it should always be implemented except if\nthe implementation can guarantee that the reference count will never\nreach zero (e.g., for statically allocated type objects).\n\nNB: the methods for certain type groups are now contained in separate\nmethod blocks.\n*/\n\ntypedef PyObject * (*unaryfunc)(PyObject *);\ntypedef PyObject * (*binaryfunc)(PyObject *, PyObject *);\ntypedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);\ntypedef int (*inquiry)(PyObject *);\ntypedef Py_ssize_t (*lenfunc)(PyObject *);\ntypedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);\ntypedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);\ntypedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);\ntypedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);\ntypedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);\n\ntypedef int (*objobjproc)(PyObject *, PyObject *);\ntypedef int (*visitproc)(PyObject *, void *);\ntypedef int (*traverseproc)(PyObject *, visitproc, void *);\n\n\ntypedef void (*freefunc)(void *);\ntypedef void (*destructor)(PyObject *);\ntypedef PyObject *(*getattrfunc)(PyObject *, char *);\ntypedef PyObject *(*getattrofunc)(PyObject *, PyObject *);\ntypedef int (*setattrfunc)(PyObject *, char *, PyObject *);\ntypedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*reprfunc)(PyObject *);\ntypedef Py_hash_t (*hashfunc)(PyObject *);\ntypedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);\ntypedef PyObject *(*getiterfunc) (PyObject *);\ntypedef PyObject *(*iternextfunc) (PyObject *);\ntypedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*initproc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*newfunc)(PyTypeObject *, PyObject *, PyObject *);\ntypedef PyObject *(*allocfunc)(PyTypeObject *, Py_ssize_t);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030c0000 // 3.12\ntypedef PyObject *(*vectorcallfunc)(PyObject *callable, PyObject *const *args,\n                                    size_t nargsf, PyObject *kwnames);\n#endif\n\ntypedef struct{\n    int slot;    /* slot id, see below */\n    void *pfunc; /* function pointer */\n} PyType_Slot;\n\ntypedef struct{\n    const char* name;\n    int basicsize;\n    int itemsize;\n    unsigned int flags;\n    PyType_Slot *slots; /* terminated by slot==0. */\n} PyType_Spec;\n\nPyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000\nPyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);\nPyAPI_FUNC(PyObject *) PyType_GetModule(PyTypeObject *);\nPyAPI_FUNC(void *) PyType_GetModuleState(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000\nPyAPI_FUNC(PyObject *) PyType_GetName(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GetQualName(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\nPyAPI_FUNC(PyObject *) PyType_FromMetaclass(PyTypeObject*, PyObject*, PyType_Spec*, PyObject*);\nPyAPI_FUNC(void *) PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls);\nPyAPI_FUNC(Py_ssize_t) PyType_GetTypeDataSize(PyTypeObject *cls);\n#endif\n\n/* Generic type check */\nPyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);\n\nstatic inline int PyObject_TypeCheck(PyObject *ob, PyTypeObject *type) {\n    return Py_IS_TYPE(ob, type) || PyType_IsSubtype(Py_TYPE(ob), type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyObject_TypeCheck(ob, type) PyObject_TypeCheck(_PyObject_CAST(ob), (type))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */\nPyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */\nPyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */\n\nPyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);\n\nPyAPI_FUNC(int) PyType_Ready(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,\n                                               PyObject *, PyObject *);\nPyAPI_FUNC(unsigned int) PyType_ClearCache(void);\nPyAPI_FUNC(void) PyType_Modified(PyTypeObject *);\n\n/* Generic operations on objects */\nPyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);\nPyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);\nPyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);\nPyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);\n#endif\nPyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);\nPyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);\nPyAPI_FUNC(int) PyObject_IsTrue(PyObject *);\nPyAPI_FUNC(int) PyObject_Not(PyObject *);\nPyAPI_FUNC(int) PyCallable_Check(PyObject *);\nPyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);\n\n/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a\n   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),\n   returning the names of the current locals.  In this case, if there are\n   no current locals, NULL is returned, and PyErr_Occurred() is false.\n*/\nPyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);\n\n/* Pickle support. */\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyObject_GetState(PyObject *);\n#endif\n\n\n/* Helpers for printing recursive container types */\nPyAPI_FUNC(int) Py_ReprEnter(PyObject *);\nPyAPI_FUNC(void) Py_ReprLeave(PyObject *);\n\n/* Flag bits for printing: */\n#define Py_PRINT_RAW    1       /* No string quotes etc. */\n\n/*\nType flags (tp_flags)\n\nThese flags are used to change expected features and behavior for a\nparticular type.\n\nArbitration of the flag bit positions will need to be coordinated among\nall extension writers who publicly release their extensions (this will\nbe fewer than you might expect!).\n\nMost flags were removed as of Python 3.0 to make room for new flags.  (Some\nflags are not for backwards compatibility but to indicate the presence of an\noptional feature; these flags remain of course.)\n\nType definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.\n\nCode can use PyType_HasFeature(type_ob, flag_value) to test whether the\ngiven type object has a specified feature.\n*/\n\n#ifndef Py_LIMITED_API\n\n/* Track types initialized using _PyStaticType_InitBuiltin(). */\n#define _Py_TPFLAGS_STATIC_BUILTIN (1 << 1)\n\n/* Placement of weakref pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_weaklistoffset.\n */\n#define Py_TPFLAGS_MANAGED_WEAKREF (1 << 3)\n\n/* Placement of dict (and values) pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_dictoffset.\n */\n#define Py_TPFLAGS_MANAGED_DICT (1 << 4)\n\n#define Py_TPFLAGS_PREHEADER (Py_TPFLAGS_MANAGED_WEAKREF | Py_TPFLAGS_MANAGED_DICT)\n\n/* Set if instances of the type object are treated as sequences for pattern matching */\n#define Py_TPFLAGS_SEQUENCE (1 << 5)\n/* Set if instances of the type object are treated as mappings for pattern matching */\n#define Py_TPFLAGS_MAPPING (1 << 6)\n#endif\n\n/* Disallow creating instances of the type: set tp_new to NULL and don't create\n * the \"__new__\" key in the type dictionary. */\n#define Py_TPFLAGS_DISALLOW_INSTANTIATION (1UL << 7)\n\n/* Set if the type object is immutable: type attributes cannot be set nor deleted */\n#define Py_TPFLAGS_IMMUTABLETYPE (1UL << 8)\n\n/* Set if the type object is dynamically allocated */\n#define Py_TPFLAGS_HEAPTYPE (1UL << 9)\n\n/* Set if the type allows subclassing */\n#define Py_TPFLAGS_BASETYPE (1UL << 10)\n\n/* Set if the type implements the vectorcall protocol (PEP 590) */\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\n#define Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)\n#ifndef Py_LIMITED_API\n// Backwards compatibility alias for API that was provisional in Python 3.8\n#define _Py_TPFLAGS_HAVE_VECTORCALL Py_TPFLAGS_HAVE_VECTORCALL\n#endif\n#endif\n\n/* Set if the type is 'ready' -- fully initialized */\n#define Py_TPFLAGS_READY (1UL << 12)\n\n/* Set while the type is being 'readied', to prevent recursive ready calls */\n#define Py_TPFLAGS_READYING (1UL << 13)\n\n/* Objects support garbage collection (see objimpl.h) */\n#define Py_TPFLAGS_HAVE_GC (1UL << 14)\n\n/* These two bits are preserved for Stackless Python, next after this is 17 */\n#ifdef STACKLESS\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)\n#else\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0\n#endif\n\n/* Objects behave like an unbound method */\n#define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)\n\n/* Object has up-to-date type attribute cache */\n#define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)\n\n/* Type is abstract and cannot be instantiated */\n#define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)\n\n// This undocumented flag gives certain built-ins their unique pattern-matching\n// behavior, which allows a single positional subpattern to match against the\n// subject itself (rather than a mapped attribute on it):\n#define _Py_TPFLAGS_MATCH_SELF (1UL << 22)\n\n/* Items (ob_size*tp_itemsize) are found at the end of an instance's memory */\n#define Py_TPFLAGS_ITEMS_AT_END (1UL << 23)\n\n/* These flags are used to determine if a type is a subclass. */\n#define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)\n#define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)\n#define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)\n#define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)\n#define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)\n#define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)\n#define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)\n#define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)\n\n#define Py_TPFLAGS_DEFAULT  ( \\\n                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \\\n                0)\n\n/* NOTE: Some of the following flags reuse lower bits (removed as part of the\n * Python 3.0 transition). */\n\n/* The following flags are kept for compatibility; in previous\n * versions they indicated presence of newer tp_* fields on the\n * type struct.\n * Starting with 3.8, binary compatibility of C extensions across\n * feature releases of Python is not supported anymore (except when\n * using the stable ABI, in which all classes are created dynamically,\n * using the interpreter's memory layout.)\n * Note that older extensions using the stable ABI set these flags,\n * so the bits must not be repurposed.\n */\n#define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)\n#define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)\n\n\n/*\nThe macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement\nreference counts.  Py_DECREF calls the object's deallocator function when\nthe refcount falls to 0; for\nobjects that don't contain references to other objects or heap memory\nthis can be the standard function free().  Both macros can be used\nwherever a void expression is allowed.  The argument must not be a\nNULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.\nThe macro _Py_NewReference(op) initialize reference counts to 1, and\nin special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional\nbookkeeping appropriate to the special build.\n\nWe assume that the reference count field can never overflow; this can\nbe proven when the size of the field is the same as the pointer size, so\nwe ignore the possibility.  Provided a C int is at least 32 bits (which\nis implicitly assumed in many parts of this code), that's enough for\nabout 2**31 references to an object.\n\nXXX The following became out of date in Python 2.2, but I'm not sure\nXXX what the full truth is now.  Certainly, heap-allocated type objects\nXXX can and should be deallocated.\nType objects should never be deallocated; the type pointer in an object\nis not considered to be a reference to the type object, to save\ncomplications in the deallocation function.  (This is actually a\ndecision that's up to the implementer of each new type so if you want,\nyou can count such references to the type object.)\n*/\n\n#if defined(Py_REF_DEBUG) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,\n                                      PyObject *op);\nPyAPI_FUNC(void) _Py_INCREF_IncRefTotal(void);\nPyAPI_FUNC(void) _Py_DECREF_DecRefTotal(void);\n#endif  // Py_REF_DEBUG && !Py_LIMITED_API\n\nPyAPI_FUNC(void) _Py_Dealloc(PyObject *);\n\n/*\nThese are provided as conveniences to Python runtime embedders, so that\nthey can have object code that is not dependent on Python compilation flags.\n*/\nPyAPI_FUNC(void) Py_IncRef(PyObject *);\nPyAPI_FUNC(void) Py_DecRef(PyObject *);\n\n// Similar to Py_IncRef() and Py_DecRef() but the argument must be non-NULL.\n// Private functions used by Py_INCREF() and Py_DECREF().\nPyAPI_FUNC(void) _Py_IncRef(PyObject *);\nPyAPI_FUNC(void) _Py_DecRef(PyObject *);\n\nstatic inline Py_ALWAYS_INLINE void Py_INCREF(PyObject *op)\n{\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n    // Stable ABI implements Py_INCREF() as a function call on limited C API\n    // version 3.12 and newer, and on Python built in debug mode. _Py_IncRef()\n    // was added to Python 3.10.0a7, use Py_IncRef() on older Python versions.\n    // Py_IncRef() accepts NULL whereas _Py_IncRef() doesn't.\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_IncRef(op);\n#  else\n    Py_IncRef(op);\n#  endif\n#else\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n#if SIZEOF_VOID_P > 4\n    // Portable saturated add, branching on the carry flag and set low bits\n    PY_UINT32_T cur_refcnt = op->ob_refcnt_split[PY_BIG_ENDIAN];\n    PY_UINT32_T new_refcnt = cur_refcnt + 1;\n    if (new_refcnt == 0) {\n        return;\n    }\n    op->ob_refcnt_split[PY_BIG_ENDIAN] = new_refcnt;\n#else\n    // Explicitly check immortality against the immortal value\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    op->ob_refcnt++;\n#endif\n    _Py_INCREF_STAT_INC();\n#ifdef Py_REF_DEBUG\n    _Py_INCREF_IncRefTotal();\n#endif\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_INCREF(op) Py_INCREF(_PyObject_CAST(op))\n#endif\n\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n// Stable ABI implements Py_DECREF() as a function call on limited C API\n// version 3.12 and newer, and on Python built in debug mode. _Py_DecRef() was\n// added to Python 3.10.0a7, use Py_DecRef() on older Python versions.\n// Py_DecRef() accepts NULL whereas _Py_IncRef() doesn't.\nstatic inline void Py_DECREF(PyObject *op) {\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_DecRef(op);\n#  else\n    Py_DecRef(op);\n#  endif\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    if (op->ob_refcnt <= 0) {\n        _Py_NegativeRefcount(filename, lineno, op);\n    }\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#else\nstatic inline Py_ALWAYS_INLINE void Py_DECREF(PyObject *op)\n{\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n#endif\n\n\n/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear\n * and tp_dealloc implementations.\n *\n * Note that \"the obvious\" code can be deadly:\n *\n *     Py_XDECREF(op);\n *     op = NULL;\n *\n * Typically, `op` is something like self->containee, and `self` is done\n * using its `containee` member.  In the code sequence above, suppose\n * `containee` is non-NULL with a refcount of 1.  Its refcount falls to\n * 0 on the first line, which can trigger an arbitrary amount of code,\n * possibly including finalizers (like __del__ methods or weakref callbacks)\n * coded in Python, which in turn can release the GIL and allow other threads\n * to run, etc.  Such code may even invoke methods of `self` again, or cause\n * cyclic gc to trigger, but-- oops! --self->containee still points to the\n * object being torn down, and it may be in an insane state while being torn\n * down.  This has in fact been a rich historic source of miserable (rare &\n * hard-to-diagnose) segfaulting (and other) bugs.\n *\n * The safe way is:\n *\n *      Py_CLEAR(op);\n *\n * That arranges to set `op` to NULL _before_ decref'ing, so that any code\n * triggered as a side-effect of `op` getting torn down no longer believes\n * `op` points to a valid object.\n *\n * There are cases where it's safe to use the naive code, but they're brittle.\n * For example, if `op` points to a Python integer, you know that destroying\n * one of those can't cause problems -- but in part that relies on that\n * Python integers aren't currently weakly referencable.  Best practice is\n * to use Py_CLEAR() even if you can't think of a reason for why you need to.\n *\n * gh-98724: Use a temporary variable to only evaluate the macro argument once,\n * to avoid the duplication of side effects if the argument has side effects.\n *\n * gh-99701: If the PyObject* type is used with casting arguments to PyObject*,\n * the code can be miscompiled with strict aliasing because of type punning.\n * With strict aliasing, a compiler considers that two pointers of different\n * types cannot read or write the same memory which enables optimization\n * opportunities.\n *\n * If available, use _Py_TYPEOF() to use the 'op' type for temporary variables,\n * and so avoid type punning. Otherwise, use memcpy() which causes type erasure\n * and so prevents the compiler to reuse an old cached 'op' value after\n * Py_CLEAR().\n */\n#ifdef _Py_TYPEOF\n#define Py_CLEAR(op) \\\n    do { \\\n        _Py_TYPEOF(op)* _tmp_op_ptr = &(op); \\\n        _Py_TYPEOF(op) _tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            *_tmp_op_ptr = _Py_NULL; \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#else\n#define Py_CLEAR(op) \\\n    do { \\\n        PyObject **_tmp_op_ptr = _Py_CAST(PyObject**, &(op)); \\\n        PyObject *_tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            PyObject *_null_ptr = _Py_NULL; \\\n            memcpy(_tmp_op_ptr, &_null_ptr, sizeof(PyObject*)); \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#endif\n\n\n/* Function to use in case the object pointer can be NULL: */\nstatic inline void Py_XINCREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_INCREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XINCREF(op) Py_XINCREF(_PyObject_CAST(op))\n#endif\n\nstatic inline void Py_XDECREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_DECREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XDECREF(op) Py_XDECREF(_PyObject_CAST(op))\n#endif\n\n// Create a new strong reference to an object:\n// increment the reference count of the object and return the object.\nPyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);\n\n// Similar to Py_NewRef(), but the object can be NULL.\nPyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);\n\nstatic inline PyObject* _Py_NewRef(PyObject *obj)\n{\n    Py_INCREF(obj);\n    return obj;\n}\n\nstatic inline PyObject* _Py_XNewRef(PyObject *obj)\n{\n    Py_XINCREF(obj);\n    return obj;\n}\n\n// Py_NewRef() and Py_XNewRef() are exported as functions for the stable ABI.\n// Names overridden with macros by static inline functions for best\n// performances.\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_NewRef(obj) _Py_NewRef(_PyObject_CAST(obj))\n#  define Py_XNewRef(obj) _Py_XNewRef(_PyObject_CAST(obj))\n#else\n#  define Py_NewRef(obj) _Py_NewRef(obj)\n#  define Py_XNewRef(obj) _Py_XNewRef(obj)\n#endif\n\n\n/*\n_Py_NoneStruct is an object of undefined type which can be used in contexts\nwhere NULL (nil) is not suitable (since NULL often means 'error').\n\nDon't forget to apply Py_INCREF() when returning this value!!!\n*/\nPyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n#define Py_None (&_Py_NoneStruct)\n\n// Test if an object is the None singleton, the same as \"x is None\" in Python.\nPyAPI_FUNC(int) Py_IsNone(PyObject *x);\n#define Py_IsNone(x) Py_Is((x), Py_None)\n\n/* Macro for returning Py_None from a function */\n#define Py_RETURN_NONE return Py_None\n\n/*\nPy_NotImplemented is a singleton used to signal that an operation is\nnot implemented for a given type combination.\n*/\nPyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */\n#define Py_NotImplemented (&_Py_NotImplementedStruct)\n\n/* Macro for returning Py_NotImplemented from a function */\n#define Py_RETURN_NOTIMPLEMENTED return Py_NotImplemented\n\n/* Rich comparison opcodes */\n#define Py_LT 0\n#define Py_LE 1\n#define Py_EQ 2\n#define Py_NE 3\n#define Py_GT 4\n#define Py_GE 5\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000\n/* Result of calling PyIter_Send */\ntypedef enum {\n    PYGEN_RETURN = 0,\n    PYGEN_ERROR = -1,\n    PYGEN_NEXT = 1,\n} PySendResult;\n#endif\n\n/*\n * Macro for implementing rich comparisons\n *\n * Needs to be a macro because any C-comparable type can be used.\n */\n#define Py_RETURN_RICHCOMPARE(val1, val2, op)                               \\\n    do {                                                                    \\\n        switch (op) {                                                       \\\n        case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        default:                                                            \\\n            Py_UNREACHABLE();                                               \\\n        }                                                                   \\\n    } while (0)\n\n\n/*\nMore conventions\n================\n\nArgument Checking\n-----------------\n\nFunctions that take objects as arguments normally don't check for nil\narguments, but they do check the type of the argument, and return an\nerror if the function doesn't apply to the type.\n\nFailure Modes\n-------------\n\nFunctions may fail for a variety of reasons, including running out of\nmemory.  This is communicated to the caller in two ways: an error string\nis set (see errors.h), and the function result differs: functions that\nnormally return a pointer return NULL for failure, functions returning\nan integer return -1 (which could be a legal return value too!), and\nother functions return 0 for success and -1 for failure.\nCallers should always check for errors before using the result.  If\nan error was set, the caller must either explicitly clear it, or pass\nthe error on to its caller.\n\nReference Counts\n----------------\n\nIt takes a while to get used to the proper usage of reference counts.\n\nFunctions that create an object set the reference count to 1; such new\nobjects must be stored somewhere or destroyed again with Py_DECREF().\nSome functions that 'store' objects, such as PyTuple_SetItem() and\nPyList_SetItem(),\ndon't increment the reference count of the object, since the most\nfrequent use is to store a fresh object.  Functions that 'retrieve'\nobjects, such as PyTuple_GetItem() and PyDict_GetItemString(), also\ndon't increment\nthe reference count, since most frequently the object is only looked at\nquickly.  Thus, to retrieve an object and store it again, the caller\nmust call Py_INCREF() explicitly.\n\nNOTE: functions that 'consume' a reference count, like\nPyList_SetItem(), consume the reference even if the object wasn't\nsuccessfully stored, to simplify error handling.\n\nIt seems attractive to make other functions that take an object as\nargument consume a reference count; however, this may quickly get\nconfusing (even the current practice is already confusing).  Consider\nit carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at\ntimes.\n*/\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_OBJECT_H\n#  include \"cpython/object.h\"\n#  undef Py_CPYTHON_OBJECT_H\n#endif\n\n\nstatic inline int\nPyType_HasFeature(PyTypeObject *type, unsigned long feature)\n{\n    unsigned long flags;\n#ifdef Py_LIMITED_API\n    // PyTypeObject is opaque in the limited C API\n    flags = PyType_GetFlags(type);\n#else\n    flags = type->tp_flags;\n#endif\n    return ((flags & feature) != 0);\n}\n\n#define PyType_FastSubclass(type, flag) PyType_HasFeature((type), (flag))\n\nstatic inline int PyType_Check(PyObject *op) {\n    return PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_Check(op) PyType_Check(_PyObject_CAST(op))\n#endif\n\n#define _PyType_CAST(op) \\\n    (assert(PyType_Check(op)), _Py_CAST(PyTypeObject*, (op)))\n\nstatic inline int PyType_CheckExact(PyObject *op) {\n    return Py_IS_TYPE(op, &PyType_Type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_CheckExact(op) PyType_CheckExact(_PyObject_CAST(op))\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif   // !Py_OBJECT_H\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "Objects/bytearrayobject.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/* PyByteArray (bytearray) implementation */\n\n#define PY_SSIZE_T_CLEAN\n#include \"Python.h\"\n#include \"pycore_abstract.h\"      // _PyIndex_Check()\n#include \"pycore_bytes_methods.h\"\n#include \"pycore_bytesobject.h\"\n#include \"pycore_object.h\"        // _PyObject_GC_UNTRACK()\n#include \"pycore_strhex.h\"        // _Py_strhex_with_sep()\n#include \"pycore_long.h\"          // _PyLong_FromUnsignedChar()\n#include \"bytesobject.h\"\n\n/*[clinic input]\nclass bytearray \"PyByteArrayObject *\" \"&PyByteArray_Type\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=5535b77c37a119e0]*/\n\n/* For PyByteArray_AS_STRING(). */\nchar _PyByteArray_empty_string[] = \"\";\n\n/* Helpers */\n\nstatic int\n_getbytevalue(PyObject* arg, int *value)\n{\n    int overflow;\n    long face_value = PyLong_AsLongAndOverflow(arg, &overflow);\n\n    if (face_value == -1 && PyErr_Occurred()) {\n        *value = -1;\n        return 0;\n    }\n    if (face_value < 0 || face_value >= 256) {\n        /* this includes an overflow in converting to C long */\n        PyErr_SetString(PyExc_ValueError, \"byte must be in range(0, 256)\");\n        *value = -1;\n        return 0;\n    }\n\n    *value = face_value;\n    return 1;\n}\n\nstatic int\nbytearray_getbuffer(PyByteArrayObject *obj, Py_buffer *view, int flags)\n{\n    void *ptr;\n    if (view == NULL) {\n        PyErr_SetString(PyExc_BufferError,\n            \"bytearray_getbuffer: view==NULL argument is obsolete\");\n        return -1;\n    }\n    ptr = (void *) PyByteArray_AS_STRING(obj);\n    /* cannot fail if view != NULL and readonly == 0 */\n    (void)PyBuffer_FillInfo(view, (PyObject*)obj, ptr, Py_SIZE(obj), 0, flags);\n    obj->ob_exports++;\n    return 0;\n}\n\nstatic void\nbytearray_releasebuffer(PyByteArrayObject *obj, Py_buffer *view)\n{\n    obj->ob_exports--;\n    assert(obj->ob_exports >= 0);\n}\n\nstatic int\n_canresize(PyByteArrayObject *self)\n{\n    if (self->ob_exports > 0) {\n        PyErr_SetString(PyExc_BufferError,\n                \"Existing exports of data: object cannot be re-sized\");\n        return 0;\n    }\n    return 1;\n}\n\n#include \"clinic/bytearrayobject.c.h\"\n\n/* Direct API functions */\n\nPyObject *\nPyByteArray_FromObject(PyObject *input)\n{\n    return PyObject_CallOneArg((PyObject *)&PyByteArray_Type, input);\n}\n\nstatic PyObject *\n_PyByteArray_FromBufferObject(PyObject *obj)\n{\n    PyObject *result;\n    Py_buffer view;\n\n    if (PyObject_GetBuffer(obj, &view, PyBUF_FULL_RO) < 0) {\n        return NULL;\n    }\n    result = PyByteArray_FromStringAndSize(NULL, view.len);\n    if (result != NULL &&\n        PyBuffer_ToContiguous(PyByteArray_AS_STRING(result),\n                              &view, view.len, 'C') < 0)\n    {\n        Py_CLEAR(result);\n    }\n    PyBuffer_Release(&view);\n    return result;\n}\n\nPyObject *\nPyByteArray_FromStringAndSize(const char *bytes, Py_ssize_t size)\n{\n    PyByteArrayObject *new;\n    Py_ssize_t alloc;\n\n    if (size < 0) {\n        PyErr_SetString(PyExc_SystemError,\n            \"Negative size passed to PyByteArray_FromStringAndSize\");\n        return NULL;\n    }\n\n    /* Prevent buffer overflow when setting alloc to size+1. */\n    if (size == PY_SSIZE_T_MAX) {\n        return PyErr_NoMemory();\n    }\n\n    new = PyObject_New(PyByteArrayObject, &PyByteArray_Type);\n    if (new == NULL)\n        return NULL;\n\n    if (size == 0) {\n        new->ob_bytes = NULL;\n        alloc = 0;\n    }\n    else {\n        alloc = size + 1;\n        new->ob_bytes = PyObject_Malloc(alloc);\n        if (new->ob_bytes == NULL) {\n            Py_DECREF(new);\n            return PyErr_NoMemory();\n        }\n        if (bytes != NULL && size > 0)\n            memcpy(new->ob_bytes, bytes, size);\n        new->ob_bytes[size] = '\\0';  /* Trailing null byte */\n    }\n    Py_SET_SIZE(new, size);\n    new->ob_alloc = alloc;\n    new->ob_start = new->ob_bytes;\n    new->ob_exports = 0;\n\n    return (PyObject *)new;\n}\n\nPy_ssize_t\nPyByteArray_Size(PyObject *self)\n{\n    assert(self != NULL);\n    assert(PyByteArray_Check(self));\n\n    return PyByteArray_GET_SIZE(self);\n}\n\nchar  *\nPyByteArray_AsString(PyObject *self)\n{\n    assert(self != NULL);\n    assert(PyByteArray_Check(self));\n\n    return PyByteArray_AS_STRING(self);\n}\n\nint\nPyByteArray_Resize(PyObject *self, Py_ssize_t requested_size)\n{\n    void *sval;\n    PyByteArrayObject *obj = ((PyByteArrayObject *)self);\n    /* All computations are done unsigned to avoid integer overflows\n       (see issue #22335). */\n    size_t alloc = (size_t) obj->ob_alloc;\n    size_t logical_offset = (size_t) (obj->ob_start - obj->ob_bytes);\n    size_t size = (size_t) requested_size;\n\n    assert(self != NULL);\n    assert(PyByteArray_Check(self));\n    assert(logical_offset <= alloc);\n    assert(requested_size >= 0);\n\n    if (requested_size == Py_SIZE(self)) {\n        return 0;\n    }\n    if (!_canresize(obj)) {\n        return -1;\n    }\n\n    if (size + logical_offset + 1 <= alloc) {\n        /* Current buffer is large enough to host the requested size,\n           decide on a strategy. */\n        if (size < alloc / 2) {\n            /* Major downsize; resize down to exact size */\n            alloc = size + 1;\n        }\n        else {\n            /* Minor downsize; quick exit */\n            Py_SET_SIZE(self, size);\n            PyByteArray_AS_STRING(self)[size] = '\\0'; /* Trailing null */\n            return 0;\n        }\n    }\n    else {\n        /* Need growing, decide on a strategy */\n        if (size <= alloc * 1.125) {\n            /* Moderate upsize; overallocate similar to list_resize() */\n            alloc = size + (size >> 3) + (size < 9 ? 3 : 6);\n        }\n        else {\n            /* Major upsize; resize up to exact size */\n            alloc = size + 1;\n        }\n    }\n    if (alloc > PY_SSIZE_T_MAX) {\n        PyErr_NoMemory();\n        return -1;\n    }\n\n    if (logical_offset > 0) {\n        sval = PyObject_Malloc(alloc);\n        if (sval == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        memcpy(sval, PyByteArray_AS_STRING(self),\n               Py_MIN((size_t)requested_size, (size_t)Py_SIZE(self)));\n        PyObject_Free(obj->ob_bytes);\n    }\n    else {\n        sval = PyObject_Realloc(obj->ob_bytes, alloc);\n        if (sval == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n    }\n\n    obj->ob_bytes = obj->ob_start = sval;\n    Py_SET_SIZE(self, size);\n    obj->ob_alloc = alloc;\n    obj->ob_bytes[size] = '\\0'; /* Trailing null byte */\n\n    return 0;\n}\n\nPyObject *\nPyByteArray_Concat(PyObject *a, PyObject *b)\n{\n    Py_buffer va, vb;\n    PyByteArrayObject *result = NULL;\n\n    va.len = -1;\n    vb.len = -1;\n    if (PyObject_GetBuffer(a, &va, PyBUF_SIMPLE) != 0 ||\n        PyObject_GetBuffer(b, &vb, PyBUF_SIMPLE) != 0) {\n            PyErr_Format(PyExc_TypeError, \"can't concat %.100s to %.100s\",\n                         Py_TYPE(b)->tp_name, Py_TYPE(a)->tp_name);\n            goto done;\n    }\n\n    if (va.len > PY_SSIZE_T_MAX - vb.len) {\n        PyErr_NoMemory();\n        goto done;\n    }\n\n    result = (PyByteArrayObject *) \\\n        PyByteArray_FromStringAndSize(NULL, va.len + vb.len);\n    // result->ob_bytes is NULL if result is an empty bytearray:\n    // if va.len + vb.len equals zero.\n    if (result != NULL && result->ob_bytes != NULL) {\n        memcpy(result->ob_bytes, va.buf, va.len);\n        memcpy(result->ob_bytes + va.len, vb.buf, vb.len);\n    }\n\n  done:\n    if (va.len != -1)\n        PyBuffer_Release(&va);\n    if (vb.len != -1)\n        PyBuffer_Release(&vb);\n    return (PyObject *)result;\n}\n\n/* Functions stuffed into the type object */\n\nstatic Py_ssize_t\nbytearray_length(PyByteArrayObject *self)\n{\n    return Py_SIZE(self);\n}\n\nstatic PyObject *\nbytearray_iconcat(PyByteArrayObject *self, PyObject *other)\n{\n    Py_ssize_t size;\n    Py_buffer vo;\n\n    if (PyObject_GetBuffer(other, &vo, PyBUF_SIMPLE) != 0) {\n        PyErr_Format(PyExc_TypeError, \"can't concat %.100s to %.100s\",\n                     Py_TYPE(other)->tp_name, Py_TYPE(self)->tp_name);\n        return NULL;\n    }\n\n    size = Py_SIZE(self);\n    if (size > PY_SSIZE_T_MAX - vo.len) {\n        PyBuffer_Release(&vo);\n        return PyErr_NoMemory();\n    }\n    if (PyByteArray_Resize((PyObject *)self, size + vo.len) < 0) {\n        PyBuffer_Release(&vo);\n        return NULL;\n    }\n    memcpy(PyByteArray_AS_STRING(self) + size, vo.buf, vo.len);\n    PyBuffer_Release(&vo);\n    return Py_NewRef(self);\n}\n\nstatic PyObject *\nbytearray_repeat(PyByteArrayObject *self, Py_ssize_t count)\n{\n    if (count < 0)\n        count = 0;\n    const Py_ssize_t mysize = Py_SIZE(self);\n    if (count > 0 && mysize > PY_SSIZE_T_MAX / count)\n        return PyErr_NoMemory();\n    Py_ssize_t size = mysize * count;\n    PyByteArrayObject* result = (PyByteArrayObject *)PyByteArray_FromStringAndSize(NULL, size);\n    const char* buf = PyByteArray_AS_STRING(self);\n    if (result != NULL && size != 0) {\n        _PyBytes_Repeat(result->ob_bytes, size, buf, mysize);\n    }\n    return (PyObject *)result;\n}\n\nstatic PyObject *\nbytearray_irepeat(PyByteArrayObject *self, Py_ssize_t count)\n{\n    if (count < 0)\n        count = 0;\n    else if (count == 1) {\n        return Py_NewRef(self);\n    }\n\n    const Py_ssize_t mysize = Py_SIZE(self);\n    if (count > 0 && mysize > PY_SSIZE_T_MAX / count)\n        return PyErr_NoMemory();\n    const Py_ssize_t size = mysize * count;\n    if (PyByteArray_Resize((PyObject *)self, size) < 0)\n        return NULL;\n\n    char* buf = PyByteArray_AS_STRING(self);\n    _PyBytes_Repeat(buf, size, buf, mysize);\n\n    return Py_NewRef(self);\n}\n\nstatic PyObject *\nbytearray_getitem(PyByteArrayObject *self, Py_ssize_t i)\n{\n    if (i < 0 || i >= Py_SIZE(self)) {\n        PyErr_SetString(PyExc_IndexError, \"bytearray index out of range\");\n        return NULL;\n    }\n    return _PyLong_FromUnsignedChar((unsigned char)(self->ob_start[i]));\n}\n\nstatic PyObject *\nbytearray_subscript(PyByteArrayObject *self, PyObject *index)\n{\n    if (_PyIndex_Check(index)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(index, PyExc_IndexError);\n\n        if (i == -1 && PyErr_Occurred())\n            return NULL;\n\n        if (i < 0)\n            i += PyByteArray_GET_SIZE(self);\n\n        if (i < 0 || i >= Py_SIZE(self)) {\n            PyErr_SetString(PyExc_IndexError, \"bytearray index out of range\");\n            return NULL;\n        }\n        return _PyLong_FromUnsignedChar((unsigned char)(self->ob_start[i]));\n    }\n    else if (PySlice_Check(index)) {\n        Py_ssize_t start, stop, step, slicelength, i;\n        size_t cur;\n        if (PySlice_Unpack(index, &start, &stop, &step) < 0) {\n            return NULL;\n        }\n        slicelength = PySlice_AdjustIndices(PyByteArray_GET_SIZE(self),\n                                            &start, &stop, step);\n\n        if (slicelength <= 0)\n            return PyByteArray_FromStringAndSize(\"\", 0);\n        else if (step == 1) {\n            return PyByteArray_FromStringAndSize(\n                PyByteArray_AS_STRING(self) + start, slicelength);\n        }\n        else {\n            char *source_buf = PyByteArray_AS_STRING(self);\n            char *result_buf;\n            PyObject *result;\n\n            result = PyByteArray_FromStringAndSize(NULL, slicelength);\n            if (result == NULL)\n                return NULL;\n\n            result_buf = PyByteArray_AS_STRING(result);\n            for (cur = start, i = 0; i < slicelength;\n                 cur += step, i++) {\n                     result_buf[i] = source_buf[cur];\n            }\n            return result;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"bytearray indices must be integers or slices, not %.200s\",\n                     Py_TYPE(index)->tp_name);\n        return NULL;\n    }\n}\n\nstatic int\nbytearray_setslice_linear(PyByteArrayObject *self,\n                          Py_ssize_t lo, Py_ssize_t hi,\n                          char *bytes, Py_ssize_t bytes_len)\n{\n    Py_ssize_t avail = hi - lo;\n    char *buf = PyByteArray_AS_STRING(self);\n    Py_ssize_t growth = bytes_len - avail;\n    int res = 0;\n    assert(avail >= 0);\n\n    if (growth < 0) {\n        if (!_canresize(self))\n            return -1;\n\n        if (lo == 0) {\n            /* Shrink the buffer by advancing its logical start */\n            self->ob_start -= growth;\n            /*\n              0   lo               hi             old_size\n              |   |<----avail----->|<-----tail------>|\n              |      |<-bytes_len->|<-----tail------>|\n              0    new_lo         new_hi          new_size\n            */\n        }\n        else {\n            /*\n              0   lo               hi               old_size\n              |   |<----avail----->|<-----tomove------>|\n              |   |<-bytes_len->|<-----tomove------>|\n              0   lo         new_hi              new_size\n            */\n            memmove(buf + lo + bytes_len, buf + hi,\n                    Py_SIZE(self) - hi);\n        }\n        if (PyByteArray_Resize((PyObject *)self,\n                               Py_SIZE(self) + growth) < 0) {\n            /* Issue #19578: Handling the memory allocation failure here is\n               tricky here because the bytearray object has already been\n               modified. Depending on growth and lo, the behaviour is\n               different.\n\n               If growth < 0 and lo != 0, the operation is completed, but a\n               MemoryError is still raised and the memory block is not\n               shrunk. Otherwise, the bytearray is restored in its previous\n               state and a MemoryError is raised. */\n            if (lo == 0) {\n                self->ob_start += growth;\n                return -1;\n            }\n            /* memmove() removed bytes, the bytearray object cannot be\n               restored in its previous state. */\n            Py_SET_SIZE(self, Py_SIZE(self) + growth);\n            res = -1;\n        }\n        buf = PyByteArray_AS_STRING(self);\n    }\n    else if (growth > 0) {\n        if (Py_SIZE(self) > (Py_ssize_t)PY_SSIZE_T_MAX - growth) {\n            PyErr_NoMemory();\n            return -1;\n        }\n\n        if (PyByteArray_Resize((PyObject *)self,\n                               Py_SIZE(self) + growth) < 0) {\n            return -1;\n        }\n        buf = PyByteArray_AS_STRING(self);\n        /* Make the place for the additional bytes */\n        /*\n          0   lo        hi               old_size\n          |   |<-avail->|<-----tomove------>|\n          |   |<---bytes_len-->|<-----tomove------>|\n          0   lo            new_hi              new_size\n         */\n        memmove(buf + lo + bytes_len, buf + hi,\n                Py_SIZE(self) - lo - bytes_len);\n    }\n\n    if (bytes_len > 0)\n        memcpy(buf + lo, bytes, bytes_len);\n    return res;\n}\n\nstatic int\nbytearray_setslice(PyByteArrayObject *self, Py_ssize_t lo, Py_ssize_t hi,\n               PyObject *values)\n{\n    Py_ssize_t needed;\n    void *bytes;\n    Py_buffer vbytes;\n    int res = 0;\n\n    vbytes.len = -1;\n    if (values == (PyObject *)self) {\n        /* Make a copy and call this function recursively */\n        int err;\n        values = PyByteArray_FromStringAndSize(PyByteArray_AS_STRING(values),\n                                               PyByteArray_GET_SIZE(values));\n        if (values == NULL)\n            return -1;\n        err = bytearray_setslice(self, lo, hi, values);\n        Py_DECREF(values);\n        return err;\n    }\n    if (values == NULL) {\n        /* del b[lo:hi] */\n        bytes = NULL;\n        needed = 0;\n    }\n    else {\n        if (PyObject_GetBuffer(values, &vbytes, PyBUF_SIMPLE) != 0) {\n            PyErr_Format(PyExc_TypeError,\n                         \"can't set bytearray slice from %.100s\",\n                         Py_TYPE(values)->tp_name);\n            return -1;\n        }\n        needed = vbytes.len;\n        bytes = vbytes.buf;\n    }\n\n    if (lo < 0)\n        lo = 0;\n    if (hi < lo)\n        hi = lo;\n    if (hi > Py_SIZE(self))\n        hi = Py_SIZE(self);\n\n    res = bytearray_setslice_linear(self, lo, hi, bytes, needed);\n    if (vbytes.len != -1)\n        PyBuffer_Release(&vbytes);\n    return res;\n}\n\nstatic int\nbytearray_setitem(PyByteArrayObject *self, Py_ssize_t i, PyObject *value)\n{\n    int ival = -1;\n\n    // GH-91153: We need to do this *before* the size check, in case value has a\n    // nasty __index__ method that changes the size of the bytearray:\n    if (value && !_getbytevalue(value, &ival)) {\n        return -1;\n    }\n\n    if (i < 0) {\n        i += Py_SIZE(self);\n    }\n\n    if (i < 0 || i >= Py_SIZE(self)) {\n        PyErr_SetString(PyExc_IndexError, \"bytearray index out of range\");\n        return -1;\n    }\n\n    if (value == NULL) {\n        return bytearray_setslice(self, i, i+1, NULL);\n    }\n\n    assert(0 <= ival && ival < 256);\n    PyByteArray_AS_STRING(self)[i] = ival;\n    return 0;\n}\n\nstatic int\nbytearray_ass_subscript(PyByteArrayObject *self, PyObject *index, PyObject *values)\n{\n    Py_ssize_t start, stop, step, slicelen, needed;\n    char *buf, *bytes;\n    buf = PyByteArray_AS_STRING(self);\n\n    if (_PyIndex_Check(index)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(index, PyExc_IndexError);\n\n        if (i == -1 && PyErr_Occurred()) {\n            return -1;\n        }\n\n        int ival = -1;\n\n        // GH-91153: We need to do this *before* the size check, in case values\n        // has a nasty __index__ method that changes the size of the bytearray:\n        if (values && !_getbytevalue(values, &ival)) {\n            return -1;\n        }\n\n        if (i < 0) {\n            i += PyByteArray_GET_SIZE(self);\n        }\n\n        if (i < 0 || i >= Py_SIZE(self)) {\n            PyErr_SetString(PyExc_IndexError, \"bytearray index out of range\");\n            return -1;\n        }\n\n        if (values == NULL) {\n            /* Fall through to slice assignment */\n            start = i;\n            stop = i + 1;\n            step = 1;\n            slicelen = 1;\n        }\n        else {\n            assert(0 <= ival && ival < 256);\n            buf[i] = (char)ival;\n            return 0;\n        }\n    }\n    else if (PySlice_Check(index)) {\n        if (PySlice_Unpack(index, &start, &stop, &step) < 0) {\n            return -1;\n        }\n        slicelen = PySlice_AdjustIndices(PyByteArray_GET_SIZE(self), &start,\n                                         &stop, step);\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"bytearray indices must be integers or slices, not %.200s\",\n                      Py_TYPE(index)->tp_name);\n        return -1;\n    }\n\n    if (values == NULL) {\n        bytes = NULL;\n        needed = 0;\n    }\n    else if (values == (PyObject *)self || !PyByteArray_Check(values)) {\n        int err;\n        if (PyNumber_Check(values) || PyUnicode_Check(values)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"can assign only bytes, buffers, or iterables \"\n                            \"of ints in range(0, 256)\");\n            return -1;\n        }\n        /* Make a copy and call this function recursively */\n        values = PyByteArray_FromObject(values);\n        if (values == NULL)\n            return -1;\n        err = bytearray_ass_subscript(self, index, values);\n        Py_DECREF(values);\n        return err;\n    }\n    else {\n        assert(PyByteArray_Check(values));\n        bytes = PyByteArray_AS_STRING(values);\n        needed = Py_SIZE(values);\n    }\n    /* Make sure b[5:2] = ... inserts before 5, not before 2. */\n    if ((step < 0 && start < stop) ||\n        (step > 0 && start > stop))\n        stop = start;\n    if (step == 1) {\n        return bytearray_setslice_linear(self, start, stop, bytes, needed);\n    }\n    else {\n        if (needed == 0) {\n            /* Delete slice */\n            size_t cur;\n            Py_ssize_t i;\n\n            if (!_canresize(self))\n                return -1;\n\n            if (slicelen == 0)\n                /* Nothing to do here. */\n                return 0;\n\n            if (step < 0) {\n                stop = start + 1;\n                start = stop + step * (slicelen - 1) - 1;\n                step = -step;\n            }\n            for (cur = start, i = 0;\n                 i < slicelen; cur += step, i++) {\n                Py_ssize_t lim = step - 1;\n\n                if (cur + step >= (size_t)PyByteArray_GET_SIZE(self))\n                    lim = PyByteArray_GET_SIZE(self) - cur - 1;\n\n                memmove(buf + cur - i,\n                        buf + cur + 1, lim);\n            }\n            /* Move the tail of the bytes, in one chunk */\n            cur = start + (size_t)slicelen*step;\n            if (cur < (size_t)PyByteArray_GET_SIZE(self)) {\n                memmove(buf + cur - slicelen,\n                        buf + cur,\n                        PyByteArray_GET_SIZE(self) - cur);\n            }\n            if (PyByteArray_Resize((PyObject *)self,\n                               PyByteArray_GET_SIZE(self) - slicelen) < 0)\n                return -1;\n\n            return 0;\n        }\n        else {\n            /* Assign slice */\n            Py_ssize_t i;\n            size_t cur;\n\n            if (needed != slicelen) {\n                PyErr_Format(PyExc_ValueError,\n                             \"attempt to assign bytes of size %zd \"\n                             \"to extended slice of size %zd\",\n                             needed, slicelen);\n                return -1;\n            }\n            for (cur = start, i = 0; i < slicelen; cur += step, i++)\n                buf[cur] = bytes[i];\n            return 0;\n        }\n    }\n}\n\n/*[clinic input]\nbytearray.__init__\n\n    source as arg: object = NULL\n    encoding: str = NULL\n    errors: str = NULL\n\n[clinic start generated code]*/\n\nstatic int\nbytearray___init___impl(PyByteArrayObject *self, PyObject *arg,\n                        const char *encoding, const char *errors)\n/*[clinic end generated code: output=4ce1304649c2f8b3 input=1141a7122eefd7b9]*/\n{\n    Py_ssize_t count;\n    PyObject *it;\n    PyObject *(*iternext)(PyObject *);\n\n    if (Py_SIZE(self) != 0) {\n        /* Empty previous contents (yes, do this first of all!) */\n        if (PyByteArray_Resize((PyObject *)self, 0) < 0)\n            return -1;\n    }\n\n    /* Make a quick exit if no first argument */\n    if (arg == NULL) {\n        if (encoding != NULL || errors != NULL) {\n            PyErr_SetString(PyExc_TypeError,\n                            encoding != NULL ?\n                            \"encoding without a string argument\" :\n                            \"errors without a string argument\");\n            return -1;\n        }\n        return 0;\n    }\n\n    if (PyUnicode_Check(arg)) {\n        /* Encode via the codec registry */\n        PyObject *encoded, *new;\n        if (encoding == NULL) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"string argument without an encoding\");\n            return -1;\n        }\n        encoded = PyUnicode_AsEncodedString(arg, encoding, errors);\n        if (encoded == NULL)\n            return -1;\n        assert(PyBytes_Check(encoded));\n        new = bytearray_iconcat(self, encoded);\n        Py_DECREF(encoded);\n        if (new == NULL)\n            return -1;\n        Py_DECREF(new);\n        return 0;\n    }\n\n    /* If it's not unicode, there can't be encoding or errors */\n    if (encoding != NULL || errors != NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        encoding != NULL ?\n                        \"encoding without a string argument\" :\n                        \"errors without a string argument\");\n        return -1;\n    }\n\n    /* Is it an int? */\n    if (_PyIndex_Check(arg)) {\n        count = PyNumber_AsSsize_t(arg, PyExc_OverflowError);\n        if (count == -1 && PyErr_Occurred()) {\n            if (!PyErr_ExceptionMatches(PyExc_TypeError))\n                return -1;\n            PyErr_Clear();  /* fall through */\n        }\n        else {\n            if (count < 0) {\n                PyErr_SetString(PyExc_ValueError, \"negative count\");\n                return -1;\n            }\n            if (count > 0) {\n                if (PyByteArray_Resize((PyObject *)self, count))\n                    return -1;\n                memset(PyByteArray_AS_STRING(self), 0, count);\n            }\n            return 0;\n        }\n    }\n\n    /* Use the buffer API */\n    if (PyObject_CheckBuffer(arg)) {\n        Py_ssize_t size;\n        Py_buffer view;\n        if (PyObject_GetBuffer(arg, &view, PyBUF_FULL_RO) < 0)\n            return -1;\n        size = view.len;\n        if (PyByteArray_Resize((PyObject *)self, size) < 0) goto fail;\n        if (PyBuffer_ToContiguous(PyByteArray_AS_STRING(self),\n            &view, size, 'C') < 0)\n            goto fail;\n        PyBuffer_Release(&view);\n        return 0;\n    fail:\n        PyBuffer_Release(&view);\n        return -1;\n    }\n\n    if (PyList_CheckExact(arg) || PyTuple_CheckExact(arg)) {\n        Py_ssize_t size = PySequence_Fast_GET_SIZE(arg);\n        if (PyByteArray_Resize((PyObject *)self, size) < 0) {\n            return -1;\n        }\n        PyObject **items = PySequence_Fast_ITEMS(arg);\n        char *s = PyByteArray_AS_STRING(self);\n        for (Py_ssize_t i = 0; i < size; i++) {\n            int value;\n            if (!PyLong_CheckExact(items[i])) {\n                /* Resize to 0 and go through slowpath */\n                if (Py_SIZE(self) != 0) {\n                   if (PyByteArray_Resize((PyObject *)self, 0) < 0) {\n                       return -1;\n                   }\n                }\n                goto slowpath;\n            }\n            int rc = _getbytevalue(items[i], &value);\n            if (!rc) {\n                return -1;\n            }\n            s[i] = value;\n        }\n        return 0;\n    }\nslowpath:\n    /* Get the iterator */\n    it = PyObject_GetIter(arg);\n    if (it == NULL) {\n        if (PyErr_ExceptionMatches(PyExc_TypeError)) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot convert '%.200s' object to bytearray\",\n                         Py_TYPE(arg)->tp_name);\n        }\n        return -1;\n    }\n    iternext = *Py_TYPE(it)->tp_iternext;\n\n    /* Run the iterator to exhaustion */\n    for (;;) {\n        PyObject *item;\n        int rc, value;\n\n        /* Get the next item */\n        item = iternext(it);\n        if (item == NULL) {\n            if (PyErr_Occurred()) {\n                if (!PyErr_ExceptionMatches(PyExc_StopIteration))\n                    goto error;\n                PyErr_Clear();\n            }\n            break;\n        }\n\n        /* Interpret it as an int (__index__) */\n        rc = _getbytevalue(item, &value);\n        Py_DECREF(item);\n        if (!rc)\n            goto error;\n\n        /* Append the byte */\n        if (Py_SIZE(self) + 1 < self->ob_alloc) {\n            Py_SET_SIZE(self, Py_SIZE(self) + 1);\n            PyByteArray_AS_STRING(self)[Py_SIZE(self)] = '\\0';\n        }\n        else if (PyByteArray_Resize((PyObject *)self, Py_SIZE(self)+1) < 0)\n            goto error;\n        PyByteArray_AS_STRING(self)[Py_SIZE(self)-1] = value;\n    }\n\n    /* Clean up and return success */\n    Py_DECREF(it);\n    return 0;\n\n error:\n    /* Error handling when it != NULL */\n    Py_DECREF(it);\n    return -1;\n}\n\n/* Mostly copied from string_repr, but without the\n   \"smart quote\" functionality. */\nstatic PyObject *\nbytearray_repr(PyByteArrayObject *self)\n{\n    const char *className = _PyType_Name(Py_TYPE(self));\n    const char *quote_prefix = \"(b\";\n    const char *quote_postfix = \")\";\n    Py_ssize_t length = Py_SIZE(self);\n    /* 6 == strlen(quote_prefix) + 2 + strlen(quote_postfix) + 1 */\n    Py_ssize_t newsize;\n    PyObject *v;\n    Py_ssize_t i;\n    char *bytes;\n    char c;\n    char *p;\n    int quote;\n    char *test, *start;\n    char *buffer;\n\n    newsize = strlen(className);\n    if (length > (PY_SSIZE_T_MAX - 6 - newsize) / 4) {\n        PyErr_SetString(PyExc_OverflowError,\n            \"bytearray object is too large to make repr\");\n        return NULL;\n    }\n\n    newsize += 6 + length * 4;\n    buffer = PyObject_Malloc(newsize);\n    if (buffer == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    /* Figure out which quote to use; single is preferred */\n    quote = '\\'';\n    start = PyByteArray_AS_STRING(self);\n    for (test = start; test < start+length; ++test) {\n        if (*test == '\"') {\n            quote = '\\''; /* back to single */\n            break;\n        }\n        else if (*test == '\\'')\n            quote = '\"';\n    }\n\n    p = buffer;\n    while (*className)\n        *p++ = *className++;\n    while (*quote_prefix)\n        *p++ = *quote_prefix++;\n    *p++ = quote;\n\n    bytes = PyByteArray_AS_STRING(self);\n    for (i = 0; i < length; i++) {\n        /* There's at least enough room for a hex escape\n           and a closing quote. */\n        assert(newsize - (p - buffer) >= 5);\n        c = bytes[i];\n        if (c == '\\'' || c == '\\\\')\n            *p++ = '\\\\', *p++ = c;\n        else if (c == '\\t')\n            *p++ = '\\\\', *p++ = 't';\n        else if (c == '\\n')\n            *p++ = '\\\\', *p++ = 'n';\n        else if (c == '\\r')\n            *p++ = '\\\\', *p++ = 'r';\n        else if (c == 0)\n            *p++ = '\\\\', *p++ = 'x', *p++ = '0', *p++ = '0';\n        else if (c < ' ' || c >= 0x7f) {\n            *p++ = '\\\\';\n            *p++ = 'x';\n            *p++ = Py_hexdigits[(c & 0xf0) >> 4];\n            *p++ = Py_hexdigits[c & 0xf];\n        }\n        else\n            *p++ = c;\n    }\n    assert(newsize - (p - buffer) >= 1);\n    *p++ = quote;\n    while (*quote_postfix) {\n       *p++ = *quote_postfix++;\n    }\n\n    v = PyUnicode_FromStringAndSize(buffer, p - buffer);\n    PyObject_Free(buffer);\n    return v;\n}\n\nstatic PyObject *\nbytearray_str(PyObject *op)\n{\n    if (_Py_GetConfig()->bytes_warning) {\n        if (PyErr_WarnEx(PyExc_BytesWarning,\n                         \"str() on a bytearray instance\", 1)) {\n                return NULL;\n        }\n    }\n    return bytearray_repr((PyByteArrayObject*)op);\n}\n\nstatic PyObject *\nbytearray_richcompare(PyObject *self, PyObject *other, int op)\n{\n    Py_ssize_t self_size, other_size;\n    Py_buffer self_bytes, other_bytes;\n    int cmp;\n\n    if (!PyObject_CheckBuffer(self) || !PyObject_CheckBuffer(other)) {\n        if (PyUnicode_Check(self) || PyUnicode_Check(other)) {\n            if (_Py_GetConfig()->bytes_warning && (op == Py_EQ || op == Py_NE)) {\n                if (PyErr_WarnEx(PyExc_BytesWarning,\n                                \"Comparison between bytearray and string\", 1))\n                    return NULL;\n            }\n        }\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n\n    /* Bytearrays can be compared to anything that supports the buffer API. */\n    if (PyObject_GetBuffer(self, &self_bytes, PyBUF_SIMPLE) != 0) {\n        PyErr_Clear();\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n    self_size = self_bytes.len;\n\n    if (PyObject_GetBuffer(other, &other_bytes, PyBUF_SIMPLE) != 0) {\n        PyErr_Clear();\n        PyBuffer_Release(&self_bytes);\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n    other_size = other_bytes.len;\n\n    if (self_size != other_size && (op == Py_EQ || op == Py_NE)) {\n        /* Shortcut: if the lengths differ, the objects differ */\n        PyBuffer_Release(&self_bytes);\n        PyBuffer_Release(&other_bytes);\n        return PyBool_FromLong((op == Py_NE));\n    }\n    else {\n        cmp = memcmp(self_bytes.buf, other_bytes.buf,\n                     Py_MIN(self_size, other_size));\n        /* In ISO C, memcmp() guarantees to use unsigned bytes! */\n\n        PyBuffer_Release(&self_bytes);\n        PyBuffer_Release(&other_bytes);\n\n        if (cmp != 0) {\n            Py_RETURN_RICHCOMPARE(cmp, 0, op);\n        }\n\n        Py_RETURN_RICHCOMPARE(self_size, other_size, op);\n    }\n\n}\n\nstatic void\nbytearray_dealloc(PyByteArrayObject *self)\n{\n    if (self->ob_exports > 0) {\n        PyErr_SetString(PyExc_SystemError,\n                        \"deallocated bytearray object has exported buffers\");\n        PyErr_Print();\n    }\n    if (self->ob_bytes != 0) {\n        PyObject_Free(self->ob_bytes);\n    }\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\n\n/* -------------------------------------------------------------------- */\n/* Methods */\n\n#define STRINGLIB_IS_UNICODE 0\n#define FASTSEARCH fastsearch\n#define STRINGLIB(F) stringlib_##F\n#define STRINGLIB_CHAR char\n#define STRINGLIB_SIZEOF_CHAR 1\n#define STRINGLIB_LEN PyByteArray_GET_SIZE\n#define STRINGLIB_STR PyByteArray_AS_STRING\n#define STRINGLIB_NEW PyByteArray_FromStringAndSize\n#define STRINGLIB_ISSPACE Py_ISSPACE\n#define STRINGLIB_ISLINEBREAK(x) ((x == '\\n') || (x == '\\r'))\n#define STRINGLIB_CHECK_EXACT PyByteArray_CheckExact\n#define STRINGLIB_FAST_MEMCHR memchr\n#define STRINGLIB_MUTABLE 1\n\n#include \"stringlib/fastsearch.h\"\n#include \"stringlib/count.h\"\n#include \"stringlib/find.h\"\n#include \"stringlib/join.h\"\n#include \"stringlib/partition.h\"\n#include \"stringlib/split.h\"\n#include \"stringlib/ctype.h\"\n#include \"stringlib/transmogrify.h\"\n\n\nstatic PyObject *\nbytearray_find(PyByteArrayObject *self, PyObject *args)\n{\n    return _Py_bytes_find(PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self), args);\n}\n\nstatic PyObject *\nbytearray_count(PyByteArrayObject *self, PyObject *args)\n{\n    return _Py_bytes_count(PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self), args);\n}\n\n/*[clinic input]\nbytearray.clear\n\nRemove all items from the bytearray.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_clear_impl(PyByteArrayObject *self)\n/*[clinic end generated code: output=85c2fe6aede0956c input=ed6edae9de447ac4]*/\n{\n    if (PyByteArray_Resize((PyObject *)self, 0) < 0)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nbytearray.copy\n\nReturn a copy of B.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_copy_impl(PyByteArrayObject *self)\n/*[clinic end generated code: output=68cfbcfed484c132 input=6597b0c01bccaa9e]*/\n{\n    return PyByteArray_FromStringAndSize(PyByteArray_AS_STRING((PyObject *)self),\n                                         PyByteArray_GET_SIZE(self));\n}\n\nstatic PyObject *\nbytearray_index(PyByteArrayObject *self, PyObject *args)\n{\n    return _Py_bytes_index(PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self), args);\n}\n\nstatic PyObject *\nbytearray_rfind(PyByteArrayObject *self, PyObject *args)\n{\n    return _Py_bytes_rfind(PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self), args);\n}\n\nstatic PyObject *\nbytearray_rindex(PyByteArrayObject *self, PyObject *args)\n{\n    return _Py_bytes_rindex(PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self), args);\n}\n\nstatic int\nbytearray_contains(PyObject *self, PyObject *arg)\n{\n    return _Py_bytes_contains(PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self), arg);\n}\n\nstatic PyObject *\nbytearray_startswith(PyByteArrayObject *self, PyObject *args)\n{\n    return _Py_bytes_startswith(PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self), args);\n}\n\nstatic PyObject *\nbytearray_endswith(PyByteArrayObject *self, PyObject *args)\n{\n    return _Py_bytes_endswith(PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self), args);\n}\n\n/*[clinic input]\nbytearray.removeprefix as bytearray_removeprefix\n\n    prefix: Py_buffer\n    /\n\nReturn a bytearray with the given prefix string removed if present.\n\nIf the bytearray starts with the prefix string, return\nbytearray[len(prefix):].  Otherwise, return a copy of the original\nbytearray.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_removeprefix_impl(PyByteArrayObject *self, Py_buffer *prefix)\n/*[clinic end generated code: output=6cabc585e7f502e0 input=968aada38aedd262]*/\n{\n    const char *self_start = PyByteArray_AS_STRING(self);\n    Py_ssize_t self_len = PyByteArray_GET_SIZE(self);\n    const char *prefix_start = prefix->buf;\n    Py_ssize_t prefix_len = prefix->len;\n\n    if (self_len >= prefix_len\n        && memcmp(self_start, prefix_start, prefix_len) == 0)\n    {\n        return PyByteArray_FromStringAndSize(self_start + prefix_len,\n                                             self_len - prefix_len);\n    }\n\n    return PyByteArray_FromStringAndSize(self_start, self_len);\n}\n\n/*[clinic input]\nbytearray.removesuffix as bytearray_removesuffix\n\n    suffix: Py_buffer\n    /\n\nReturn a bytearray with the given suffix string removed if present.\n\nIf the bytearray ends with the suffix string and that suffix is not\nempty, return bytearray[:-len(suffix)].  Otherwise, return a copy of\nthe original bytearray.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_removesuffix_impl(PyByteArrayObject *self, Py_buffer *suffix)\n/*[clinic end generated code: output=2bc8cfb79de793d3 input=c1827e810b2f6b99]*/\n{\n    const char *self_start = PyByteArray_AS_STRING(self);\n    Py_ssize_t self_len = PyByteArray_GET_SIZE(self);\n    const char *suffix_start = suffix->buf;\n    Py_ssize_t suffix_len = suffix->len;\n\n    if (self_len >= suffix_len\n        && memcmp(self_start + self_len - suffix_len,\n                  suffix_start, suffix_len) == 0)\n    {\n        return PyByteArray_FromStringAndSize(self_start,\n                                             self_len - suffix_len);\n    }\n\n    return PyByteArray_FromStringAndSize(self_start, self_len);\n}\n\n\n/*[clinic input]\nbytearray.translate\n\n    table: object\n        Translation table, which must be a bytes object of length 256.\n    /\n    delete as deletechars: object(c_default=\"NULL\") = b''\n\nReturn a copy with each character mapped by the given translation table.\n\nAll characters occurring in the optional argument delete are removed.\nThe remaining characters are mapped through the given translation table.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_translate_impl(PyByteArrayObject *self, PyObject *table,\n                         PyObject *deletechars)\n/*[clinic end generated code: output=b6a8f01c2a74e446 input=cfff956d4d127a9b]*/\n{\n    char *input, *output;\n    const char *table_chars;\n    Py_ssize_t i, c;\n    PyObject *input_obj = (PyObject*)self;\n    const char *output_start;\n    Py_ssize_t inlen;\n    PyObject *result = NULL;\n    int trans_table[256];\n    Py_buffer vtable, vdel;\n\n    if (table == Py_None) {\n        table_chars = NULL;\n        table = NULL;\n    } else if (PyObject_GetBuffer(table, &vtable, PyBUF_SIMPLE) != 0) {\n        return NULL;\n    } else {\n        if (vtable.len != 256) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"translation table must be 256 characters long\");\n            PyBuffer_Release(&vtable);\n            return NULL;\n        }\n        table_chars = (const char*)vtable.buf;\n    }\n\n    if (deletechars != NULL) {\n        if (PyObject_GetBuffer(deletechars, &vdel, PyBUF_SIMPLE) != 0) {\n            if (table != NULL)\n                PyBuffer_Release(&vtable);\n            return NULL;\n        }\n    }\n    else {\n        vdel.buf = NULL;\n        vdel.len = 0;\n    }\n\n    inlen = PyByteArray_GET_SIZE(input_obj);\n    result = PyByteArray_FromStringAndSize((char *)NULL, inlen);\n    if (result == NULL)\n        goto done;\n    output_start = output = PyByteArray_AS_STRING(result);\n    input = PyByteArray_AS_STRING(input_obj);\n\n    if (vdel.len == 0 && table_chars != NULL) {\n        /* If no deletions are required, use faster code */\n        for (i = inlen; --i >= 0; ) {\n            c = Py_CHARMASK(*input++);\n            *output++ = table_chars[c];\n        }\n        goto done;\n    }\n\n    if (table_chars == NULL) {\n        for (i = 0; i < 256; i++)\n            trans_table[i] = Py_CHARMASK(i);\n    } else {\n        for (i = 0; i < 256; i++)\n            trans_table[i] = Py_CHARMASK(table_chars[i]);\n    }\n\n    for (i = 0; i < vdel.len; i++)\n        trans_table[(int) Py_CHARMASK( ((unsigned char*)vdel.buf)[i] )] = -1;\n\n    for (i = inlen; --i >= 0; ) {\n        c = Py_CHARMASK(*input++);\n        if (trans_table[c] != -1)\n            *output++ = (char)trans_table[c];\n    }\n    /* Fix the size of the resulting bytearray */\n    if (inlen > 0)\n        if (PyByteArray_Resize(result, output - output_start) < 0) {\n            Py_CLEAR(result);\n            goto done;\n        }\n\ndone:\n    if (table != NULL)\n        PyBuffer_Release(&vtable);\n    if (deletechars != NULL)\n        PyBuffer_Release(&vdel);\n    return result;\n}\n\n\n/*[clinic input]\n\n@staticmethod\nbytearray.maketrans\n\n    frm: Py_buffer\n    to: Py_buffer\n    /\n\nReturn a translation table useable for the bytes or bytearray translate method.\n\nThe returned table will be one where each byte in frm is mapped to the byte at\nthe same position in to.\n\nThe bytes objects frm and to must be of the same length.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_maketrans_impl(Py_buffer *frm, Py_buffer *to)\n/*[clinic end generated code: output=1df267d99f56b15e input=5925a81d2fbbf151]*/\n{\n    return _Py_bytes_maketrans(frm, to);\n}\n\n\n/*[clinic input]\nbytearray.replace\n\n    old: Py_buffer\n    new: Py_buffer\n    count: Py_ssize_t = -1\n        Maximum number of occurrences to replace.\n        -1 (the default value) means replace all occurrences.\n    /\n\nReturn a copy with all occurrences of substring old replaced by new.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_replace_impl(PyByteArrayObject *self, Py_buffer *old,\n                       Py_buffer *new, Py_ssize_t count)\n/*[clinic end generated code: output=d39884c4dc59412a input=aa379d988637c7fb]*/\n{\n    return stringlib_replace((PyObject *)self,\n                             (const char *)old->buf, old->len,\n                             (const char *)new->buf, new->len, count);\n}\n\n/*[clinic input]\nbytearray.split\n\n    sep: object = None\n        The delimiter according which to split the bytearray.\n        None (the default value) means split on ASCII whitespace characters\n        (space, tab, return, newline, formfeed, vertical tab).\n    maxsplit: Py_ssize_t = -1\n        Maximum number of splits to do.\n        -1 (the default value) means no limit.\n\nReturn a list of the sections in the bytearray, using sep as the delimiter.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_split_impl(PyByteArrayObject *self, PyObject *sep,\n                     Py_ssize_t maxsplit)\n/*[clinic end generated code: output=833e2cf385d9a04d input=24f82669f41bf523]*/\n{\n    Py_ssize_t len = PyByteArray_GET_SIZE(self), n;\n    const char *s = PyByteArray_AS_STRING(self), *sub;\n    PyObject *list;\n    Py_buffer vsub;\n\n    if (maxsplit < 0)\n        maxsplit = PY_SSIZE_T_MAX;\n\n    if (sep == Py_None)\n        return stringlib_split_whitespace((PyObject*) self, s, len, maxsplit);\n\n    if (PyObject_GetBuffer(sep, &vsub, PyBUF_SIMPLE) != 0)\n        return NULL;\n    sub = vsub.buf;\n    n = vsub.len;\n\n    list = stringlib_split(\n        (PyObject*) self, s, len, sub, n, maxsplit\n        );\n    PyBuffer_Release(&vsub);\n    return list;\n}\n\n/*[clinic input]\nbytearray.partition\n\n    sep: object\n    /\n\nPartition the bytearray into three parts using the given separator.\n\nThis will search for the separator sep in the bytearray. If the separator is\nfound, returns a 3-tuple containing the part before the separator, the\nseparator itself, and the part after it as new bytearray objects.\n\nIf the separator is not found, returns a 3-tuple containing the copy of the\noriginal bytearray object and two empty bytearray objects.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_partition(PyByteArrayObject *self, PyObject *sep)\n/*[clinic end generated code: output=45d2525ddd35f957 input=8f644749ee4fc83a]*/\n{\n    PyObject *bytesep, *result;\n\n    bytesep = _PyByteArray_FromBufferObject(sep);\n    if (! bytesep)\n        return NULL;\n\n    result = stringlib_partition(\n            (PyObject*) self,\n            PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self),\n            bytesep,\n            PyByteArray_AS_STRING(bytesep), PyByteArray_GET_SIZE(bytesep)\n            );\n\n    Py_DECREF(bytesep);\n    return result;\n}\n\n/*[clinic input]\nbytearray.rpartition\n\n    sep: object\n    /\n\nPartition the bytearray into three parts using the given separator.\n\nThis will search for the separator sep in the bytearray, starting at the end.\nIf the separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it as new bytearray\nobjects.\n\nIf the separator is not found, returns a 3-tuple containing two empty bytearray\nobjects and the copy of the original bytearray object.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_rpartition(PyByteArrayObject *self, PyObject *sep)\n/*[clinic end generated code: output=440de3c9426115e8 input=7e3df3e6cb8fa0ac]*/\n{\n    PyObject *bytesep, *result;\n\n    bytesep = _PyByteArray_FromBufferObject(sep);\n    if (! bytesep)\n        return NULL;\n\n    result = stringlib_rpartition(\n            (PyObject*) self,\n            PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self),\n            bytesep,\n            PyByteArray_AS_STRING(bytesep), PyByteArray_GET_SIZE(bytesep)\n            );\n\n    Py_DECREF(bytesep);\n    return result;\n}\n\n/*[clinic input]\nbytearray.rsplit = bytearray.split\n\nReturn a list of the sections in the bytearray, using sep as the delimiter.\n\nSplitting is done starting at the end of the bytearray and working to the front.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_rsplit_impl(PyByteArrayObject *self, PyObject *sep,\n                      Py_ssize_t maxsplit)\n/*[clinic end generated code: output=a55e0b5a03cb6190 input=a68286e4dd692ffe]*/\n{\n    Py_ssize_t len = PyByteArray_GET_SIZE(self), n;\n    const char *s = PyByteArray_AS_STRING(self), *sub;\n    PyObject *list;\n    Py_buffer vsub;\n\n    if (maxsplit < 0)\n        maxsplit = PY_SSIZE_T_MAX;\n\n    if (sep == Py_None)\n        return stringlib_rsplit_whitespace((PyObject*) self, s, len, maxsplit);\n\n    if (PyObject_GetBuffer(sep, &vsub, PyBUF_SIMPLE) != 0)\n        return NULL;\n    sub = vsub.buf;\n    n = vsub.len;\n\n    list = stringlib_rsplit(\n        (PyObject*) self, s, len, sub, n, maxsplit\n        );\n    PyBuffer_Release(&vsub);\n    return list;\n}\n\n/*[clinic input]\nbytearray.reverse\n\nReverse the order of the values in B in place.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_reverse_impl(PyByteArrayObject *self)\n/*[clinic end generated code: output=9f7616f29ab309d3 input=543356319fc78557]*/\n{\n    char swap, *head, *tail;\n    Py_ssize_t i, j, n = Py_SIZE(self);\n\n    j = n / 2;\n    head = PyByteArray_AS_STRING(self);\n    tail = head + n - 1;\n    for (i = 0; i < j; i++) {\n        swap = *head;\n        *head++ = *tail;\n        *tail-- = swap;\n    }\n\n    Py_RETURN_NONE;\n}\n\n\n/*[python input]\nclass bytesvalue_converter(CConverter):\n    type = 'int'\n    converter = '_getbytevalue'\n[python start generated code]*/\n/*[python end generated code: output=da39a3ee5e6b4b0d input=29c2e7c26c212812]*/\n\n\n/*[clinic input]\nbytearray.insert\n\n    index: Py_ssize_t\n        The index where the value is to be inserted.\n    item: bytesvalue\n        The item to be inserted.\n    /\n\nInsert a single item into the bytearray before the given index.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_insert_impl(PyByteArrayObject *self, Py_ssize_t index, int item)\n/*[clinic end generated code: output=76c775a70e7b07b7 input=b2b5d07e9de6c070]*/\n{\n    Py_ssize_t n = Py_SIZE(self);\n    char *buf;\n\n    if (n == PY_SSIZE_T_MAX) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"cannot add more objects to bytearray\");\n        return NULL;\n    }\n    if (PyByteArray_Resize((PyObject *)self, n + 1) < 0)\n        return NULL;\n    buf = PyByteArray_AS_STRING(self);\n\n    if (index < 0) {\n        index += n;\n        if (index < 0)\n            index = 0;\n    }\n    if (index > n)\n        index = n;\n    memmove(buf + index + 1, buf + index, n - index);\n    buf[index] = item;\n\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nbytearray.append\n\n    item: bytesvalue\n        The item to be appended.\n    /\n\nAppend a single item to the end of the bytearray.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_append_impl(PyByteArrayObject *self, int item)\n/*[clinic end generated code: output=a154e19ed1886cb6 input=20d6bec3d1340593]*/\n{\n    Py_ssize_t n = Py_SIZE(self);\n\n    if (n == PY_SSIZE_T_MAX) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"cannot add more objects to bytearray\");\n        return NULL;\n    }\n    if (PyByteArray_Resize((PyObject *)self, n + 1) < 0)\n        return NULL;\n\n    PyByteArray_AS_STRING(self)[n] = item;\n\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nbytearray.extend\n\n    iterable_of_ints: object\n        The iterable of items to append.\n    /\n\nAppend all the items from the iterator or sequence to the end of the bytearray.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_extend(PyByteArrayObject *self, PyObject *iterable_of_ints)\n/*[clinic end generated code: output=98155dbe249170b1 input=c617b3a93249ba28]*/\n{\n    PyObject *it, *item, *bytearray_obj;\n    Py_ssize_t buf_size = 0, len = 0;\n    int value;\n    char *buf;\n\n    /* bytearray_setslice code only accepts something supporting PEP 3118. */\n    if (PyObject_CheckBuffer(iterable_of_ints)) {\n        if (bytearray_setslice(self, Py_SIZE(self), Py_SIZE(self), iterable_of_ints) == -1)\n            return NULL;\n\n        Py_RETURN_NONE;\n    }\n\n    it = PyObject_GetIter(iterable_of_ints);\n    if (it == NULL) {\n        if (PyErr_ExceptionMatches(PyExc_TypeError)) {\n            PyErr_Format(PyExc_TypeError,\n                         \"can't extend bytearray with %.100s\",\n                         Py_TYPE(iterable_of_ints)->tp_name);\n        }\n        return NULL;\n    }\n\n    /* Try to determine the length of the argument. 32 is arbitrary. */\n    buf_size = PyObject_LengthHint(iterable_of_ints, 32);\n    if (buf_size == -1) {\n        Py_DECREF(it);\n        return NULL;\n    }\n\n    bytearray_obj = PyByteArray_FromStringAndSize(NULL, buf_size);\n    if (bytearray_obj == NULL) {\n        Py_DECREF(it);\n        return NULL;\n    }\n    buf = PyByteArray_AS_STRING(bytearray_obj);\n\n    while ((item = PyIter_Next(it)) != NULL) {\n        if (! _getbytevalue(item, &value)) {\n            Py_DECREF(item);\n            Py_DECREF(it);\n            Py_DECREF(bytearray_obj);\n            return NULL;\n        }\n        buf[len++] = value;\n        Py_DECREF(item);\n\n        if (len >= buf_size) {\n            Py_ssize_t addition;\n            if (len == PY_SSIZE_T_MAX) {\n                Py_DECREF(it);\n                Py_DECREF(bytearray_obj);\n                return PyErr_NoMemory();\n            }\n            addition = len >> 1;\n            if (addition > PY_SSIZE_T_MAX - len - 1)\n                buf_size = PY_SSIZE_T_MAX;\n            else\n                buf_size = len + addition + 1;\n            if (PyByteArray_Resize((PyObject *)bytearray_obj, buf_size) < 0) {\n                Py_DECREF(it);\n                Py_DECREF(bytearray_obj);\n                return NULL;\n            }\n            /* Recompute the `buf' pointer, since the resizing operation may\n               have invalidated it. */\n            buf = PyByteArray_AS_STRING(bytearray_obj);\n        }\n    }\n    Py_DECREF(it);\n\n    if (PyErr_Occurred()) {\n        Py_DECREF(bytearray_obj);\n        return NULL;\n    }\n\n    /* Resize down to exact size. */\n    if (PyByteArray_Resize((PyObject *)bytearray_obj, len) < 0) {\n        Py_DECREF(bytearray_obj);\n        return NULL;\n    }\n\n    if (bytearray_setslice(self, Py_SIZE(self), Py_SIZE(self), bytearray_obj) == -1) {\n        Py_DECREF(bytearray_obj);\n        return NULL;\n    }\n    Py_DECREF(bytearray_obj);\n\n    assert(!PyErr_Occurred());\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nbytearray.pop\n\n    index: Py_ssize_t = -1\n        The index from where to remove the item.\n        -1 (the default value) means remove the last item.\n    /\n\nRemove and return a single item from B.\n\nIf no index argument is given, will pop the last item.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_pop_impl(PyByteArrayObject *self, Py_ssize_t index)\n/*[clinic end generated code: output=e0ccd401f8021da8 input=3591df2d06c0d237]*/\n{\n    int value;\n    Py_ssize_t n = Py_SIZE(self);\n    char *buf;\n\n    if (n == 0) {\n        PyErr_SetString(PyExc_IndexError,\n                        \"pop from empty bytearray\");\n        return NULL;\n    }\n    if (index < 0)\n        index += Py_SIZE(self);\n    if (index < 0 || index >= Py_SIZE(self)) {\n        PyErr_SetString(PyExc_IndexError, \"pop index out of range\");\n        return NULL;\n    }\n    if (!_canresize(self))\n        return NULL;\n\n    buf = PyByteArray_AS_STRING(self);\n    value = buf[index];\n    memmove(buf + index, buf + index + 1, n - index);\n    if (PyByteArray_Resize((PyObject *)self, n - 1) < 0)\n        return NULL;\n\n    return _PyLong_FromUnsignedChar((unsigned char)value);\n}\n\n/*[clinic input]\nbytearray.remove\n\n    value: bytesvalue\n        The value to remove.\n    /\n\nRemove the first occurrence of a value in the bytearray.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_remove_impl(PyByteArrayObject *self, int value)\n/*[clinic end generated code: output=d659e37866709c13 input=121831240cd51ddf]*/\n{\n    Py_ssize_t where, n = Py_SIZE(self);\n    char *buf = PyByteArray_AS_STRING(self);\n\n    where = stringlib_find_char(buf, n, value);\n    if (where < 0) {\n        PyErr_SetString(PyExc_ValueError, \"value not found in bytearray\");\n        return NULL;\n    }\n    if (!_canresize(self))\n        return NULL;\n\n    memmove(buf + where, buf + where + 1, n - where);\n    if (PyByteArray_Resize((PyObject *)self, n - 1) < 0)\n        return NULL;\n\n    Py_RETURN_NONE;\n}\n\n#define LEFTSTRIP 0\n#define RIGHTSTRIP 1\n#define BOTHSTRIP 2\n\nstatic PyObject*\nbytearray_strip_impl_helper(PyByteArrayObject* self, PyObject* bytes, int striptype)\n{\n    Py_ssize_t mysize, byteslen;\n    const char* myptr;\n    const char* bytesptr;\n    Py_buffer vbytes;\n\n    if (bytes == Py_None) {\n        bytesptr = \"\\t\\n\\r\\f\\v \";\n        byteslen = 6;\n    }\n    else {\n        if (PyObject_GetBuffer(bytes, &vbytes, PyBUF_SIMPLE) != 0)\n            return NULL;\n        bytesptr = (const char*)vbytes.buf;\n        byteslen = vbytes.len;\n    }\n    myptr = PyByteArray_AS_STRING(self);\n    mysize = Py_SIZE(self);\n\n    Py_ssize_t left = 0;\n    if (striptype != RIGHTSTRIP) {\n        while (left < mysize && memchr(bytesptr, (unsigned char)myptr[left], byteslen))\n            left++;\n    }\n    Py_ssize_t right = mysize;\n    if (striptype != LEFTSTRIP) {\n        do {\n            right--;\n        } while (right >= left && memchr(bytesptr, (unsigned char)myptr[right], byteslen));\n        right++;\n    }\n    if (bytes != Py_None)\n        PyBuffer_Release(&vbytes);\n    return PyByteArray_FromStringAndSize(myptr + left, right - left);\n}\n\n/*[clinic input]\nbytearray.strip\n\n    bytes: object = None\n    /\n\nStrip leading and trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading and trailing ASCII whitespace.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_strip_impl(PyByteArrayObject *self, PyObject *bytes)\n/*[clinic end generated code: output=760412661a34ad5a input=ef7bb59b09c21d62]*/\n{\n    return bytearray_strip_impl_helper(self, bytes, BOTHSTRIP);\n}\n\n/*[clinic input]\nbytearray.lstrip\n\n    bytes: object = None\n    /\n\nStrip leading bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading ASCII whitespace.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_lstrip_impl(PyByteArrayObject *self, PyObject *bytes)\n/*[clinic end generated code: output=d005c9d0ab909e66 input=80843f975dd7c480]*/\n{\n    return bytearray_strip_impl_helper(self, bytes, LEFTSTRIP);\n}\n\n/*[clinic input]\nbytearray.rstrip\n\n    bytes: object = None\n    /\n\nStrip trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip trailing ASCII whitespace.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_rstrip_impl(PyByteArrayObject *self, PyObject *bytes)\n/*[clinic end generated code: output=030e2fbd2f7276bd input=e728b994954cfd91]*/\n{\n    return bytearray_strip_impl_helper(self, bytes, RIGHTSTRIP);\n}\n\n/*[clinic input]\nbytearray.decode\n\n    encoding: str(c_default=\"NULL\") = 'utf-8'\n        The encoding with which to decode the bytearray.\n    errors: str(c_default=\"NULL\") = 'strict'\n        The error handling scheme to use for the handling of decoding errors.\n        The default is 'strict' meaning that decoding errors raise a\n        UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n        as well as any other name registered with codecs.register_error that\n        can handle UnicodeDecodeErrors.\n\nDecode the bytearray using the codec registered for encoding.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_decode_impl(PyByteArrayObject *self, const char *encoding,\n                      const char *errors)\n/*[clinic end generated code: output=f57d43f4a00b42c5 input=f28d8f903020257b]*/\n{\n    if (encoding == NULL)\n        encoding = PyUnicode_GetDefaultEncoding();\n    return PyUnicode_FromEncodedObject((PyObject*)self, encoding, errors);\n}\n\nPyDoc_STRVAR(alloc_doc,\n\"B.__alloc__() -> int\\n\\\n\\n\\\nReturn the number of bytes actually allocated.\");\n\nstatic PyObject *\nbytearray_alloc(PyByteArrayObject *self, PyObject *Py_UNUSED(ignored))\n{\n    return PyLong_FromSsize_t(self->ob_alloc);\n}\n\n/*[clinic input]\nbytearray.join\n\n    iterable_of_bytes: object\n    /\n\nConcatenate any number of bytes/bytearray objects.\n\nThe bytearray whose method is called is inserted in between each pair.\n\nThe result is returned as a new bytearray object.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_join(PyByteArrayObject *self, PyObject *iterable_of_bytes)\n/*[clinic end generated code: output=a8516370bf68ae08 input=aba6b1f9b30fcb8e]*/\n{\n    self->ob_exports++; // this protects `self` from being cleared/resized if `iterable_of_bytes` is a custom iterator\n    PyObject* ret = stringlib_bytes_join((PyObject*)self, iterable_of_bytes);\n    self->ob_exports--; // unexport `self`\n    return ret;\n}\n\n/*[clinic input]\nbytearray.splitlines\n\n    keepends: bool = False\n\nReturn a list of the lines in the bytearray, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_splitlines_impl(PyByteArrayObject *self, int keepends)\n/*[clinic end generated code: output=4223c94b895f6ad9 input=66b2dcdea8d093bf]*/\n{\n    return stringlib_splitlines(\n        (PyObject*) self, PyByteArray_AS_STRING(self),\n        PyByteArray_GET_SIZE(self), keepends\n        );\n}\n\n/*[clinic input]\n@classmethod\nbytearray.fromhex\n\n    string: unicode\n    /\n\nCreate a bytearray object from a string of hexadecimal numbers.\n\nSpaces between two numbers are accepted.\nExample: bytearray.fromhex('B9 01EF') -> bytearray(b'\\\\xb9\\\\x01\\\\xef')\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_fromhex_impl(PyTypeObject *type, PyObject *string)\n/*[clinic end generated code: output=8f0f0b6d30fb3ba0 input=f033a16d1fb21f48]*/\n{\n    PyObject *result = _PyBytes_FromHex(string, type == &PyByteArray_Type);\n    if (type != &PyByteArray_Type && result != NULL) {\n        Py_SETREF(result, PyObject_CallOneArg((PyObject *)type, result));\n    }\n    return result;\n}\n\n/*[clinic input]\nbytearray.hex\n\n    sep: object = NULL\n        An optional single character or byte to separate hex bytes.\n    bytes_per_sep: int = 1\n        How many bytes between separators.  Positive values count from the\n        right, negative values count from the left.\n\nCreate a string of hexadecimal numbers from a bytearray object.\n\nExample:\n>>> value = bytearray([0xb9, 0x01, 0xef])\n>>> value.hex()\n'b901ef'\n>>> value.hex(':')\n'b9:01:ef'\n>>> value.hex(':', 2)\n'b9:01ef'\n>>> value.hex(':', -2)\n'b901:ef'\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_hex_impl(PyByteArrayObject *self, PyObject *sep, int bytes_per_sep)\n/*[clinic end generated code: output=29c4e5ef72c565a0 input=808667e49bcccb54]*/\n{\n    char* argbuf = PyByteArray_AS_STRING(self);\n    Py_ssize_t arglen = PyByteArray_GET_SIZE(self);\n    return _Py_strhex_with_sep(argbuf, arglen, sep, bytes_per_sep);\n}\n\nstatic PyObject *\n_common_reduce(PyByteArrayObject *self, int proto)\n{\n    PyObject *state;\n    const char *buf;\n\n    state = _PyObject_GetState((PyObject *)self);\n    if (state == NULL) {\n        return NULL;\n    }\n\n    if (!Py_SIZE(self)) {\n        return Py_BuildValue(\"(O()N)\", Py_TYPE(self), state);\n    }\n    buf = PyByteArray_AS_STRING(self);\n    if (proto < 3) {\n        /* use str based reduction for backwards compatibility with Python 2.x */\n        PyObject *latin1 = PyUnicode_DecodeLatin1(buf, Py_SIZE(self), NULL);\n        return Py_BuildValue(\"(O(Ns)N)\", Py_TYPE(self), latin1, \"latin-1\", state);\n    }\n    else {\n        /* use more efficient byte based reduction */\n        return Py_BuildValue(\"(O(y#)N)\", Py_TYPE(self), buf, Py_SIZE(self), state);\n    }\n}\n\n/*[clinic input]\nbytearray.__reduce__ as bytearray_reduce\n\nReturn state information for pickling.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_reduce_impl(PyByteArrayObject *self)\n/*[clinic end generated code: output=52bf304086464cab input=44b5737ada62dd3f]*/\n{\n    return _common_reduce(self, 2);\n}\n\n/*[clinic input]\nbytearray.__reduce_ex__ as bytearray_reduce_ex\n\n    proto: int = 0\n    /\n\nReturn state information for pickling.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_reduce_ex_impl(PyByteArrayObject *self, int proto)\n/*[clinic end generated code: output=52eac33377197520 input=f129bc1a1aa151ee]*/\n{\n    return _common_reduce(self, proto);\n}\n\n/*[clinic input]\nbytearray.__sizeof__ as bytearray_sizeof\n\nReturns the size of the bytearray object in memory, in bytes.\n[clinic start generated code]*/\n\nstatic PyObject *\nbytearray_sizeof_impl(PyByteArrayObject *self)\n/*[clinic end generated code: output=738abdd17951c427 input=e27320fd98a4bc5a]*/\n{\n    size_t res = _PyObject_SIZE(Py_TYPE(self));\n    res += (size_t)self->ob_alloc * sizeof(char);\n    return PyLong_FromSize_t(res);\n}\n\nstatic PySequenceMethods bytearray_as_sequence = {\n    (lenfunc)bytearray_length,              /* sq_length */\n    (binaryfunc)PyByteArray_Concat,         /* sq_concat */\n    (ssizeargfunc)bytearray_repeat,         /* sq_repeat */\n    (ssizeargfunc)bytearray_getitem,        /* sq_item */\n    0,                                      /* sq_slice */\n    (ssizeobjargproc)bytearray_setitem,     /* sq_ass_item */\n    0,                                      /* sq_ass_slice */\n    (objobjproc)bytearray_contains,         /* sq_contains */\n    (binaryfunc)bytearray_iconcat,          /* sq_inplace_concat */\n    (ssizeargfunc)bytearray_irepeat,        /* sq_inplace_repeat */\n};\n\nstatic PyMappingMethods bytearray_as_mapping = {\n    (lenfunc)bytearray_length,\n    (binaryfunc)bytearray_subscript,\n    (objobjargproc)bytearray_ass_subscript,\n};\n\nstatic PyBufferProcs bytearray_as_buffer = {\n    (getbufferproc)bytearray_getbuffer,\n    (releasebufferproc)bytearray_releasebuffer,\n};\n\nstatic PyMethodDef\nbytearray_methods[] = {\n    {\"__alloc__\", (PyCFunction)bytearray_alloc, METH_NOARGS, alloc_doc},\n    BYTEARRAY_REDUCE_METHODDEF\n    BYTEARRAY_REDUCE_EX_METHODDEF\n    BYTEARRAY_SIZEOF_METHODDEF\n    BYTEARRAY_APPEND_METHODDEF\n    {\"capitalize\", stringlib_capitalize, METH_NOARGS,\n     _Py_capitalize__doc__},\n    STRINGLIB_CENTER_METHODDEF\n    BYTEARRAY_CLEAR_METHODDEF\n    BYTEARRAY_COPY_METHODDEF\n    {\"count\", (PyCFunction)bytearray_count, METH_VARARGS,\n     _Py_count__doc__},\n    BYTEARRAY_DECODE_METHODDEF\n    {\"endswith\", (PyCFunction)bytearray_endswith, METH_VARARGS,\n     _Py_endswith__doc__},\n    STRINGLIB_EXPANDTABS_METHODDEF\n    BYTEARRAY_EXTEND_METHODDEF\n    {\"find\", (PyCFunction)bytearray_find, METH_VARARGS,\n     _Py_find__doc__},\n    BYTEARRAY_FROMHEX_METHODDEF\n    BYTEARRAY_HEX_METHODDEF\n    {\"index\", (PyCFunction)bytearray_index, METH_VARARGS, _Py_index__doc__},\n    BYTEARRAY_INSERT_METHODDEF\n    {\"isalnum\", stringlib_isalnum, METH_NOARGS,\n     _Py_isalnum__doc__},\n    {\"isalpha\", stringlib_isalpha, METH_NOARGS,\n     _Py_isalpha__doc__},\n    {\"isascii\", stringlib_isascii, METH_NOARGS,\n     _Py_isascii__doc__},\n    {\"isdigit\", stringlib_isdigit, METH_NOARGS,\n     _Py_isdigit__doc__},\n    {\"islower\", stringlib_islower, METH_NOARGS,\n     _Py_islower__doc__},\n    {\"isspace\", stringlib_isspace, METH_NOARGS,\n     _Py_isspace__doc__},\n    {\"istitle\", stringlib_istitle, METH_NOARGS,\n     _Py_istitle__doc__},\n    {\"isupper\", stringlib_isupper, METH_NOARGS,\n     _Py_isupper__doc__},\n    BYTEARRAY_JOIN_METHODDEF\n    STRINGLIB_LJUST_METHODDEF\n    {\"lower\", stringlib_lower, METH_NOARGS, _Py_lower__doc__},\n    BYTEARRAY_LSTRIP_METHODDEF\n    BYTEARRAY_MAKETRANS_METHODDEF\n    BYTEARRAY_PARTITION_METHODDEF\n    BYTEARRAY_POP_METHODDEF\n    BYTEARRAY_REMOVE_METHODDEF\n    BYTEARRAY_REPLACE_METHODDEF\n    BYTEARRAY_REMOVEPREFIX_METHODDEF\n    BYTEARRAY_REMOVESUFFIX_METHODDEF\n    BYTEARRAY_REVERSE_METHODDEF\n    {\"rfind\", (PyCFunction)bytearray_rfind, METH_VARARGS, _Py_rfind__doc__},\n    {\"rindex\", (PyCFunction)bytearray_rindex, METH_VARARGS, _Py_rindex__doc__},\n    STRINGLIB_RJUST_METHODDEF\n    BYTEARRAY_RPARTITION_METHODDEF\n    BYTEARRAY_RSPLIT_METHODDEF\n    BYTEARRAY_RSTRIP_METHODDEF\n    BYTEARRAY_SPLIT_METHODDEF\n    BYTEARRAY_SPLITLINES_METHODDEF\n    {\"startswith\", (PyCFunction)bytearray_startswith, METH_VARARGS ,\n     _Py_startswith__doc__},\n    BYTEARRAY_STRIP_METHODDEF\n    {\"swapcase\", stringlib_swapcase, METH_NOARGS,\n     _Py_swapcase__doc__},\n    {\"title\", stringlib_title, METH_NOARGS, _Py_title__doc__},\n    BYTEARRAY_TRANSLATE_METHODDEF\n    {\"upper\", stringlib_upper, METH_NOARGS, _Py_upper__doc__},\n    STRINGLIB_ZFILL_METHODDEF\n    {NULL}\n};\n\nstatic PyObject *\nbytearray_mod(PyObject *v, PyObject *w)\n{\n    if (!PyByteArray_Check(v))\n        Py_RETURN_NOTIMPLEMENTED;\n    return _PyBytes_FormatEx(PyByteArray_AS_STRING(v), PyByteArray_GET_SIZE(v), w, 1);\n}\n\nstatic PyNumberMethods bytearray_as_number = {\n    0,              /*nb_add*/\n    0,              /*nb_subtract*/\n    0,              /*nb_multiply*/\n    bytearray_mod,  /*nb_remainder*/\n};\n\nPyDoc_STRVAR(bytearray_doc,\n\"bytearray(iterable_of_ints) -> bytearray\\n\\\nbytearray(string, encoding[, errors]) -> bytearray\\n\\\nbytearray(bytes_or_buffer) -> mutable copy of bytes_or_buffer\\n\\\nbytearray(int) -> bytes array of size given by the parameter initialized with null bytes\\n\\\nbytearray() -> empty bytes array\\n\\\n\\n\\\nConstruct a mutable bytearray object from:\\n\\\n  - an iterable yielding integers in range(256)\\n\\\n  - a text string encoded using the specified encoding\\n\\\n  - a bytes or a buffer object\\n\\\n  - any object implementing the buffer API.\\n\\\n  - an integer\");\n\n\nstatic PyObject *bytearray_iter(PyObject *seq);\n\nPyTypeObject PyByteArray_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"bytearray\",\n    sizeof(PyByteArrayObject),\n    0,\n    (destructor)bytearray_dealloc,       /* tp_dealloc */\n    0,                                  /* tp_vectorcall_offset */\n    0,                                  /* tp_getattr */\n    0,                                  /* tp_setattr */\n    0,                                  /* tp_as_async */\n    (reprfunc)bytearray_repr,           /* tp_repr */\n    &bytearray_as_number,               /* tp_as_number */\n    &bytearray_as_sequence,             /* tp_as_sequence */\n    &bytearray_as_mapping,              /* tp_as_mapping */\n    0,                                  /* tp_hash */\n    0,                                  /* tp_call */\n    bytearray_str,                      /* tp_str */\n    PyObject_GenericGetAttr,            /* tp_getattro */\n    0,                                  /* tp_setattro */\n    &bytearray_as_buffer,               /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n        _Py_TPFLAGS_MATCH_SELF,       /* tp_flags */\n    bytearray_doc,                      /* tp_doc */\n    0,                                  /* tp_traverse */\n    0,                                  /* tp_clear */\n    (richcmpfunc)bytearray_richcompare, /* tp_richcompare */\n    0,                                  /* tp_weaklistoffset */\n    bytearray_iter,                     /* tp_iter */\n    0,                                  /* tp_iternext */\n    bytearray_methods,                  /* tp_methods */\n    0,                                  /* tp_members */\n    0,                                  /* tp_getset */\n    0,                                  /* tp_base */\n    0,                                  /* tp_dict */\n    0,                                  /* tp_descr_get */\n    0,                                  /* tp_descr_set */\n    0,                                  /* tp_dictoffset */\n    (initproc)bytearray___init__,       /* tp_init */\n    PyType_GenericAlloc,                /* tp_alloc */\n    PyType_GenericNew,                  /* tp_new */\n    PyObject_Del,                       /* tp_free */\n};\n\n/*********************** Bytearray Iterator ****************************/\n\ntypedef struct {\n    PyObject_HEAD\n    Py_ssize_t it_index;\n    PyByteArrayObject *it_seq; /* Set to NULL when iterator is exhausted */\n} bytesiterobject;\n\nstatic void\nbytearrayiter_dealloc(bytesiterobject *it)\n{\n    _PyObject_GC_UNTRACK(it);\n    Py_XDECREF(it->it_seq);\n    PyObject_GC_Del(it);\n}\n\nstatic int\nbytearrayiter_traverse(bytesiterobject *it, visitproc visit, void *arg)\n{\n    Py_VISIT(it->it_seq);\n    return 0;\n}\n\nstatic PyObject *\nbytearrayiter_next(bytesiterobject *it)\n{\n    PyByteArrayObject *seq;\n\n    assert(it != NULL);\n    seq = it->it_seq;\n    if (seq == NULL)\n        return NULL;\n    assert(PyByteArray_Check(seq));\n\n    if (it->it_index < PyByteArray_GET_SIZE(seq)) {\n        return _PyLong_FromUnsignedChar(\n            (unsigned char)PyByteArray_AS_STRING(seq)[it->it_index++]);\n    }\n\n    it->it_seq = NULL;\n    Py_DECREF(seq);\n    return NULL;\n}\n\nstatic PyObject *\nbytearrayiter_length_hint(bytesiterobject *it, PyObject *Py_UNUSED(ignored))\n{\n    Py_ssize_t len = 0;\n    if (it->it_seq) {\n        len = PyByteArray_GET_SIZE(it->it_seq) - it->it_index;\n        if (len < 0) {\n            len = 0;\n        }\n    }\n    return PyLong_FromSsize_t(len);\n}\n\nPyDoc_STRVAR(length_hint_doc,\n    \"Private method returning an estimate of len(list(it)).\");\n\nstatic PyObject *\nbytearrayiter_reduce(bytesiterobject *it, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *iter = _PyEval_GetBuiltin(&_Py_ID(iter));\n\n    /* _PyEval_GetBuiltin can invoke arbitrary code,\n     * call must be before access of iterator pointers.\n     * see issue #101765 */\n\n    if (it->it_seq != NULL) {\n        return Py_BuildValue(\"N(O)n\", iter, it->it_seq, it->it_index);\n    } else {\n        return Py_BuildValue(\"N(())\", iter);\n    }\n}\n\nstatic PyObject *\nbytearrayiter_setstate(bytesiterobject *it, PyObject *state)\n{\n    Py_ssize_t index = PyLong_AsSsize_t(state);\n    if (index == -1 && PyErr_Occurred())\n        return NULL;\n    if (it->it_seq != NULL) {\n        if (index < 0)\n            index = 0;\n        else if (index > PyByteArray_GET_SIZE(it->it_seq))\n            index = PyByteArray_GET_SIZE(it->it_seq); /* iterator exhausted */\n        it->it_index = index;\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(setstate_doc, \"Set state information for unpickling.\");\n\nstatic PyMethodDef bytearrayiter_methods[] = {\n    {\"__length_hint__\", (PyCFunction)bytearrayiter_length_hint, METH_NOARGS,\n     length_hint_doc},\n     {\"__reduce__\",      (PyCFunction)bytearrayiter_reduce, METH_NOARGS,\n     bytearray_reduce__doc__},\n    {\"__setstate__\",    (PyCFunction)bytearrayiter_setstate, METH_O,\n     setstate_doc},\n    {NULL, NULL} /* sentinel */\n};\n\nPyTypeObject PyByteArrayIter_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"bytearray_iterator\",              /* tp_name */\n    sizeof(bytesiterobject),           /* tp_basicsize */\n    0,                                 /* tp_itemsize */\n    /* methods */\n    (destructor)bytearrayiter_dealloc, /* tp_dealloc */\n    0,                                 /* tp_vectorcall_offset */\n    0,                                 /* tp_getattr */\n    0,                                 /* tp_setattr */\n    0,                                 /* tp_as_async */\n    0,                                 /* tp_repr */\n    0,                                 /* tp_as_number */\n    0,                                 /* tp_as_sequence */\n    0,                                 /* tp_as_mapping */\n    0,                                 /* tp_hash */\n    0,                                 /* tp_call */\n    0,                                 /* tp_str */\n    PyObject_GenericGetAttr,           /* tp_getattro */\n    0,                                 /* tp_setattro */\n    0,                                 /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    0,                                 /* tp_doc */\n    (traverseproc)bytearrayiter_traverse,  /* tp_traverse */\n    0,                                 /* tp_clear */\n    0,                                 /* tp_richcompare */\n    0,                                 /* tp_weaklistoffset */\n    PyObject_SelfIter,                 /* tp_iter */\n    (iternextfunc)bytearrayiter_next,  /* tp_iternext */\n    bytearrayiter_methods,             /* tp_methods */\n    0,\n};\n\nstatic PyObject *\nbytearray_iter(PyObject *seq)\n{\n    bytesiterobject *it;\n\n    if (!PyByteArray_Check(seq)) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n    it = PyObject_GC_New(bytesiterobject, &PyByteArrayIter_Type);\n    if (it == NULL)\n        return NULL;\n    it->it_index = 0;\n    it->it_seq = (PyByteArrayObject *)Py_NewRef(seq);\n    _PyObject_GC_TRACK(it);\n    return (PyObject *)it;\n}\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/cpython/bytearrayobject.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_CPYTHON_BYTEARRAYOBJECT_H\n#  error \"this header file must not be included directly\"\n#endif\n\n/* Object layout */\ntypedef struct {\n    PyObject_VAR_HEAD\n    Py_ssize_t ob_alloc;   /* How many bytes allocated in ob_bytes */\n    char *ob_bytes;        /* Physical backing buffer */\n    char *ob_start;        /* Logical start inside ob_bytes */\n    Py_ssize_t ob_exports; /* How many buffer exports */\n} PyByteArrayObject;\n\nPyAPI_DATA(char) _PyByteArray_empty_string[];\n\n/* Macros and static inline functions, trading safety for speed */\n#define _PyByteArray_CAST(op) \\\n    (assert(PyByteArray_Check(op)), _Py_CAST(PyByteArrayObject*, op))\n\nstatic inline char* PyByteArray_AS_STRING(PyObject *op)\n{\n    PyByteArrayObject *self = _PyByteArray_CAST(op);\n    if (Py_SIZE(self)) {\n        return self->ob_start;\n    }\n    return _PyByteArray_empty_string;\n}\n#define PyByteArray_AS_STRING(self) PyByteArray_AS_STRING(_PyObject_CAST(self))\n\nstatic inline Py_ssize_t PyByteArray_GET_SIZE(PyObject *op) {\n    PyByteArrayObject *self = _PyByteArray_CAST(op);\n    return Py_SIZE(self);\n}\n#define PyByteArray_GET_SIZE(self) PyByteArray_GET_SIZE(_PyObject_CAST(self))\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-out-of-bounds",
                        "taxa": [{"id": "787",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/enode": 30982,
                                       "gcc/analyzer/saved_diagnostic/snode": 642,
                                       "gcc/analyzer/saved_diagnostic/idx": 4,
                                       "gcc/analyzer/out_of_bounds/dir": "write",
                                       "gcc/analyzer/out_of_bounds/model": {"store": {"root region": {"(*INIT_VAL(self_13(D)))": {"escaped": true,
                                                                                                                                  "touched": true,
                                                                                                                                  "map": {"bytes 0-15": "UNKNOWN(struct PyObject)"}},
                                                                                                      "(*INIT_VAL(from_s_18(D)))": {"escaped": true,
                                                                                                                                    "touched": true,
                                                                                                                                    "map": {"byte 0": "UNKNOWN(const char)"}},
                                                                                                      "(*INIT_VAL(to_s_19(D)))": {"escaped": true,
                                                                                                                                  "touched": true,
                                                                                                                                  "map": {"byte 0": "UNKNOWN(const char)"}},
                                                                                                      "(*CONJURED(new_19 = _PyObject_New (&PyByteArray_Type);, new_19))": {"escaped": false,
                                                                                                                                                                           "touched": false,
                                                                                                                                                                           "map": {"bytes 16-23": "UNKNOWN(Py_ssize_t)",
                                                                                                                                                                                   "bytes 24-31": "(Py_ssize_t)0",
                                                                                                                                                                                   "bytes 32-39": "(char *)0B",
                                                                                                                                                                                   "bytes 40-47": "(char *)0B",
                                                                                                                                                                                   "bytes 48-55": "(Py_ssize_t)0"}}},
                                                                                      "::": {"PyByteArray_Type": {"escaped": true,
                                                                                                                  "touched": true,
                                                                                                                  "map": {"bytes 0-415": "UNKNOWN(struct PyTypeObject)"}}},
                                                                                      "frame: 'stringlib_replace'@1": {"maxcount_9": {"escaped": false,
                                                                                                                                      "touched": false,
                                                                                                                                      "map": {"bytes 0-7": "UNKNOWN(Py_ssize_t)"}},
                                                                                                                       "_33": {"escaped": false,
                                                                                                                               "touched": false,
                                                                                                                               "map": {"bytes 0-7": "CONJURED(_33 = stringlib_replace_interleave (self_13(D), to_s_19(D), to_len_17(D), maxcount_9);, _33)"}}},
                                                                                      "frame: 'stringlib_replace_interleave'@2": {"to_s_40(D)": {"escaped": false,
                                                                                                                                                 "touched": false,
                                                                                                                                                 "map": {"bytes 0-7": "INIT_VAL(to_s_19(D))"}},
                                                                                                                                  "_39": {"escaped": false,
                                                                                                                                          "touched": false,
                                                                                                                                          "map": {"bytes 0-7": "INIT_VAL(CAST_REG('struct PyVarObject', (*INIT_VAL(self_13(D)))).ob_size)"}},
                                                                                                                                  "count_20": {"escaped": false,
                                                                                                                                               "touched": false,
                                                                                                                                               "map": {"bytes 0-7": "UNKNOWN(Py_ssize_t)"}},
                                                                                                                                  "result_37": {"escaped": false,
                                                                                                                                                "touched": false,
                                                                                                                                                "map": {"bytes 0-7": "CONJURED(new_19 = _PyObject_New (&PyByteArray_Type);, new_19)"}},
                                                                                                                                  "_63": {"escaped": false,
                                                                                                                                          "touched": false,
                                                                                                                                          "map": {"bytes 0-7": "UNKNOWN(char *)"}},
                                                                                                                                  "_60": {"escaped": false,
                                                                                                                                          "touched": false,
                                                                                                                                          "map": {"bytes 0-7": "&_PyByteArray_empty_string"}},
                                                                                                                                  "to_len.181_5": {"escaped": false,
                                                                                                                                                   "touched": false,
                                                                                                                                                   "map": {"bytes 0-7": "INIT_VAL(to_len_17(D))"}}},
                                                                                      "called_unknown_fn": true},
                                                                            "constraints": {"ecs": [{"svals": ["(void *)0B"],
                                                                                                     "constant": "'0B'"},
                                                                                                    {"svals": ["(Py_ssize_t)0",
                                                                                                               "INIT_VAL(from_len_15(D))"],
                                                                                                     "constant": "'0'"},
                                                                                                    {"svals": ["(Py_ssize_t)1"],
                                                                                                     "constant": "'1'"},
                                                                                                    {"svals": ["INIT_VAL(CAST_REG('struct PyVarObject', (*INIT_VAL(self_13(D)))).ob_size)"]},
                                                                                                    {"svals": ["INIT_VAL(maxcount_16(D))"]},
                                                                                                    {"svals": ["INIT_VAL(to_len_17(D))"]},
                                                                                                    {"svals": ["INIT_VAL(self_13(D))"]},
                                                                                                    {"svals": ["CONJURED(new_19 = _PyObject_New (&PyByteArray_Type);, new_19)"]},
                                                                                                    {"svals": ["&_PyByteArray_empty_string"]},
                                                                                                    {"svals": ["INIT_VAL(to_s_19(D))"]}],
                                                                                            "constraints": [{"lhs": 1,
                                                                                                             "op": "<=",
                                                                                                             "rhs": 3},
                                                                                                            {"lhs": 2,
                                                                                                             "op": "<",
                                                                                                             "rhs": 5},
                                                                                                            {"lhs": 4,
                                                                                                             "op": "!=",
                                                                                                             "rhs": 1},
                                                                                                            {"lhs": 5,
                                                                                                             "op": "!=",
                                                                                                             "rhs": 1},
                                                                                                            {"lhs": 6,
                                                                                                             "op": "!=",
                                                                                                             "rhs": 0},
                                                                                                            {"lhs": 7,
                                                                                                             "op": "!=",
                                                                                                             "rhs": 0},
                                                                                                            {"lhs": 8,
                                                                                                             "op": "!=",
                                                                                                             "rhs": 0},
                                                                                                            {"lhs": 9,
                                                                                                             "op": "!=",
                                                                                                             "rhs": 0}],
                                                                                            "bounded_ranges_constraints": []},
                                                                            "current_frame": "frame: 'stringlib_replace_interleave'@2",
                                                                            "dynamic_extents": {}},
                                       "gcc/analyzer/out_of_bounds/region": "SIZED_REG(CAST_REG(, _PyByteArray_empty_string), CAST(long unsigned int, INIT_VAL(to_len_17(D))))",
                                       "gcc/analyzer/out_of_bounds/diag_arg": "_PyByteArray_empty_string",
                                       "gcc/analyzer/out_of_bounds/sval_hint": "UNKNOWN()",
                                       "gcc/analyzer/out_of_bounds/region_creation_event_id": null,
                                       "gcc/analyzer/symbolic_past_the_end/offset": "0",
                                       "gcc/analyzer/symbolic_past_the_end/num_bytes": "to_len_17(D)",
                                       "gcc/analyzer/symbolic_past_the_end/capacity": "1"},
                        "level": "warning",
                        "message": {"text": "buffer overflow"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 319,
                                                                       "startColumn": 9,
                                                                       "endColumn": 39},
                                                            "contextRegion": {"startLine": 319,
                                                                              "snippet": {"text": "        memcpy(result_s, to_s, to_len);\n"}}},
                                       "logicalLocations": [{"name": "stringlib_replace_interleave",
                                                             "fullyQualifiedName": "stringlib_replace_interleave",
                                                             "decoratedName": "stringlib_replace_interleave",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 677,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 677,
                                                                                                                           "snippet": {"text": "stringlib_replace(PyObject *self,\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace",
                                                                                                          "fullyQualifiedName": "stringlib_replace",
                                                                                                          "decoratedName": "stringlib_replace",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'stringlib_replace'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 461,
                                                                                                                                 "dst_idx": 466,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 682,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 682,
                                                                                                                           "snippet": {"text": "    if (STRINGLIB_LEN(self) < from_len) {\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace",
                                                                                                          "fullyQualifiedName": "stringlib_replace",
                                                                                                          "decoratedName": "stringlib_replace",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 461,
                                                                                                                                 "dst_idx": 466,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 686,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 686,
                                                                                                                           "snippet": {"text": "    if (maxcount < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace",
                                                                                                          "fullyQualifiedName": "stringlib_replace",
                                                                                                          "decoratedName": "stringlib_replace",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 472,
                                                                                                                                 "dst_idx": 473,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 694,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 694,
                                                                                                                           "snippet": {"text": "    if (from_len == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace",
                                                                                                          "fullyQualifiedName": "stringlib_replace",
                                                                                                          "decoratedName": "stringlib_replace",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'from_len == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 472,
                                                                                                                                 "dst_idx": 473,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 695,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 695,
                                                                                                                           "snippet": {"text": "        if (to_len == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace",
                                                                                                          "fullyQualifiedName": "stringlib_replace",
                                                                                                          "decoratedName": "stringlib_replace",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 473,
                                                                                                                                 "dst_idx": 478,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 695,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 695,
                                                                                                                           "snippet": {"text": "        if (to_len == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace",
                                                                                                          "fullyQualifiedName": "stringlib_replace",
                                                                                                          "decoratedName": "stringlib_replace",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'to_len != 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 473,
                                                                                                                                 "dst_idx": 478,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 702,
                                                                                                                    "startColumn": 16,
                                                                                                                    "endColumn": 74},
                                                                                                         "contextRegion": {"startLine": 702,
                                                                                                                           "snippet": {"text": "        return stringlib_replace_interleave(self, to_s, to_len, maxcount);\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace",
                                                                                                          "fullyQualifiedName": "stringlib_replace",
                                                                                                          "decoratedName": "stringlib_replace",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 478,
                                                                                                                                 "dst_idx": 629,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 702,
                                                                                                                    "startColumn": 16,
                                                                                                                    "endColumn": 74},
                                                                                                         "contextRegion": {"startLine": 702,
                                                                                                                           "snippet": {"text": "        return stringlib_replace_interleave(self, to_s, to_len, maxcount);\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace",
                                                                                                          "fullyQualifiedName": "stringlib_replace",
                                                                                                          "decoratedName": "stringlib_replace",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'stringlib_replace_interleave' from 'stringlib_replace'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 278,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 29},
                                                                                                         "contextRegion": {"startLine": 278,
                                                                                                                           "snippet": {"text": "stringlib_replace_interleave(PyObject *self,\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace_interleave",
                                                                                                          "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                          "decoratedName": "stringlib_replace_interleave",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'stringlib_replace_interleave'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 632,
                                                                                                                                 "dst_idx": 635,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 303,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 303,
                                                                                                                           "snippet": {"text": "    if (to_len > (PY_SSIZE_T_MAX - self_len) / count) {\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace_interleave",
                                                                                                          "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                          "decoratedName": "stringlib_replace_interleave",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 632,
                                                                                                                                 "dst_idx": 635,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 308,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 32},
                                                                                                         "contextRegion": {"startLine": 308,
                                                                                                                           "snippet": {"text": "    result_len = count * to_len + self_len;\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace_interleave",
                                                                                                          "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                          "decoratedName": "stringlib_replace_interleave",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 635,
                                                                                                                                 "dst_idx": 2168,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 309,
                                                                                                                    "startColumn": 14,
                                                                                                                    "endColumn": 45},
                                                                                                         "contextRegion": {"startLine": 309,
                                                                                                                           "snippet": {"text": "    result = STRINGLIB_NEW(NULL, result_len);\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace_interleave",
                                                                                                          "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                          "decoratedName": "stringlib_replace_interleave",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'PyByteArray_FromStringAndSize' from 'stringlib_replace_interleave'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytearrayobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 109,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 30},
                                                                                                         "contextRegion": {"startLine": 109,
                                                                                                                           "snippet": {"text": "PyByteArray_FromStringAndSize(const char *bytes, Py_ssize_t size)\n"}}},
                                                                                    "logicalLocations": [{"name": "PyByteArray_FromStringAndSize",
                                                                                                          "fullyQualifiedName": "PyByteArray_FromStringAndSize",
                                                                                                          "decoratedName": "PyByteArray_FromStringAndSize",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'PyByteArray_FromStringAndSize'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2169,
                                                                                                                                 "dst_idx": 2172,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytearrayobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 114,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 114,
                                                                                                                           "snippet": {"text": "    if (size < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyByteArray_FromStringAndSize",
                                                                                                          "fullyQualifiedName": "PyByteArray_FromStringAndSize",
                                                                                                          "decoratedName": "PyByteArray_FromStringAndSize",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'size >= 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2169,
                                                                                                                                 "dst_idx": 2172,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytearrayobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 121,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 121,
                                                                                                                           "snippet": {"text": "    if (size == PY_SSIZE_T_MAX) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyByteArray_FromStringAndSize",
                                                                                                          "fullyQualifiedName": "PyByteArray_FromStringAndSize",
                                                                                                          "decoratedName": "PyByteArray_FromStringAndSize",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2172,
                                                                                                                                 "dst_idx": 2174,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytearrayobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 121,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 121,
                                                                                                                           "snippet": {"text": "    if (size == PY_SSIZE_T_MAX) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyByteArray_FromStringAndSize",
                                                                                                          "fullyQualifiedName": "PyByteArray_FromStringAndSize",
                                                                                                          "decoratedName": "PyByteArray_FromStringAndSize",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'size != 9223372036854775807')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2172,
                                                                                                                                 "dst_idx": 2174,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytearrayobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 125,
                                                                                                                    "startColumn": 11,
                                                                                                                    "endColumn": 12},
                                                                                                         "contextRegion": {"startLine": 125,
                                                                                                                           "snippet": {"text": "    new = PyObject_New(PyByteArrayObject, &PyByteArray_Type);\n"}}},
                                                                                    "logicalLocations": [{"name": "PyByteArray_FromStringAndSize",
                                                                                                          "fullyQualifiedName": "PyByteArray_FromStringAndSize",
                                                                                                          "decoratedName": "PyByteArray_FromStringAndSize",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2174,
                                                                                                                                 "dst_idx": 2175,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytearrayobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 126,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 126,
                                                                                                                           "snippet": {"text": "    if (new == NULL)\n"}}},
                                                                                    "logicalLocations": [{"name": "PyByteArray_FromStringAndSize",
                                                                                                          "fullyQualifiedName": "PyByteArray_FromStringAndSize",
                                                                                                          "decoratedName": "PyByteArray_FromStringAndSize",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'new' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2174,
                                                                                                                                 "dst_idx": 2175,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytearrayobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 129,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 129,
                                                                                                                           "snippet": {"text": "    if (size == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyByteArray_FromStringAndSize",
                                                                                                          "fullyQualifiedName": "PyByteArray_FromStringAndSize",
                                                                                                          "decoratedName": "PyByteArray_FromStringAndSize",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2175,
                                                                                                                                 "dst_idx": 2176,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytearrayobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 129,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 129,
                                                                                                                           "snippet": {"text": "    if (size == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyByteArray_FromStringAndSize",
                                                                                                          "fullyQualifiedName": "PyByteArray_FromStringAndSize",
                                                                                                          "decoratedName": "PyByteArray_FromStringAndSize",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'size == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2175,
                                                                                                                                 "dst_idx": 2176,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/bytearrayobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 130,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 26},
                                                                                                         "contextRegion": {"startLine": 130,
                                                                                                                           "snippet": {"text": "        new->ob_bytes = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "PyByteArray_FromStringAndSize",
                                                                                                          "fullyQualifiedName": "PyByteArray_FromStringAndSize",
                                                                                                          "decoratedName": "PyByteArray_FromStringAndSize",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 2187,
                                                                                                                                 "dst_idx": 636,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 309,
                                                                                                                    "startColumn": 14,
                                                                                                                    "endColumn": 45},
                                                                                                         "contextRegion": {"startLine": 309,
                                                                                                                           "snippet": {"text": "    result = STRINGLIB_NEW(NULL, result_len);\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace_interleave",
                                                                                                          "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                          "decoratedName": "stringlib_replace_interleave",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'stringlib_replace_interleave' from 'PyByteArray_FromStringAndSize'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 22},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(23)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 636,
                                                                                                                                 "dst_idx": 637,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 310,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 310,
                                                                                                                           "snippet": {"text": "    if (result == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace_interleave",
                                                                                                          "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                          "decoratedName": "stringlib_replace_interleave",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'result' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 23},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(24)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 314,
                                                                                                                    "startColumn": 14,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 314,
                                                                                                                           "snippet": {"text": "    self_s = STRINGLIB_STR(self);\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace_interleave",
                                                                                                          "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                          "decoratedName": "stringlib_replace_interleave",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'PyByteArray_AS_STRING' from 'stringlib_replace_interleave'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 24},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(25)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/bytearrayobject.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 23,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 23,
                                                                                                                           "snippet": {"text": "    if (Py_SIZE(self)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyByteArray_AS_STRING",
                                                                                                          "fullyQualifiedName": "PyByteArray_AS_STRING",
                                                                                                          "decoratedName": "PyByteArray_AS_STRING",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'Py_SIZE' from 'PyByteArray_AS_STRING'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 25},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(26)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "stringlib_replace_interleave",
                                                                                                                                     "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                                                     "decoratedName": "stringlib_replace_interleave",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 2,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 636,
                                                                                                                                 "dst_idx": 637,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 233,
                                                                                                                    "startColumn": 13,
                                                                                                                    "endColumn": 43},
                                                                                                         "contextRegion": {"startLine": 233,
                                                                                                                           "snippet": {"text": "    return  _PyVarObject_CAST(ob)->ob_size;\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_SIZE",
                                                                                                          "fullyQualifiedName": "Py_SIZE",
                                                                                                          "decoratedName": "Py_SIZE",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 26},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(27)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 315,
                                                                                                                    "startColumn": 16,
                                                                                                                    "endColumn": 17},
                                                                                                         "contextRegion": {"startLine": 315,
                                                                                                                           "snippet": {"text": "    result_s = STRINGLIB_STR(result);\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace_interleave",
                                                                                                          "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                          "decoratedName": "stringlib_replace_interleave",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'PyByteArray_AS_STRING' from 'stringlib_replace_interleave'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 27},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(28)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "stringlib_replace_interleave",
                                                                                                                                     "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                                                     "decoratedName": "stringlib_replace_interleave",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 2,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 639,
                                                                                                                                 "dst_idx": 641,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/bytearrayobject.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 23,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 23,
                                                                                                                           "snippet": {"text": "    if (Py_SIZE(self)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyByteArray_AS_STRING",
                                                                                                          "fullyQualifiedName": "PyByteArray_AS_STRING",
                                                                                                          "decoratedName": "PyByteArray_AS_STRING",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 28},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(29)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 639,
                                                                                                                                 "dst_idx": 641,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 317,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 317,
                                                                                                                           "snippet": {"text": "    if (to_len > 1) {\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace_interleave",
                                                                                                          "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                          "decoratedName": "stringlib_replace_interleave",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 29},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(30)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 641,
                                                                                                                                 "dst_idx": 642,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 317,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 317,
                                                                                                                           "snippet": {"text": "    if (to_len > 1) {\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace_interleave",
                                                                                                          "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                          "decoratedName": "stringlib_replace_interleave",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'to_len > 1')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 30},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(31)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 641,
                                                                                                                                 "dst_idx": 642,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 319,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 319,
                                                                                                                           "snippet": {"text": "        memcpy(result_s, to_s, to_len);\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace_interleave",
                                                                                                          "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                          "decoratedName": "stringlib_replace_interleave",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 31},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(32)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 319,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 319,
                                                                                                                           "snippet": {"text": "        memcpy(result_s, to_s, to_len);\n"}}},
                                                                                    "logicalLocations": [{"name": "stringlib_replace_interleave",
                                                                                                          "fullyQualifiedName": "stringlib_replace_interleave",
                                                                                                          "decoratedName": "stringlib_replace_interleave",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "write of 'to_len' bytes at offset '0' exceeds '_PyByteArray_empty_string'"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 32}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/stringlib/transmogrify.h",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 319,
                                                                              "startColumn": 9,
                                                                              "endColumn": 39},
                                                                   "contextRegion": {"startLine": 319,
                                                                                     "snippet": {"text": "        memcpy(result_s, to_s, to_len);\n"}}},
                                              "message": {"text": "valid subscripts for '_PyByteArray_empty_string' are '[0]' to '[0]'"}},
                                             {"message": {"text": "Diagram visualizing the predicted out-of-bounds access",
                                                          "markdown": "    \n                           write of 'to_len' bytes                        \n    \n                                                              \n                                                              \n                           v                                   v\n    \n                         [0]                                            \n       after valid range   \n    '_PyByteArray_empty_string' (type: 'char[1]')                       \n    \n    \n                                                              \n                            \n                  capacity: 1 byte            overflow of 'to_len - 1' bytes\n                            \n"}}]}]}]}
