{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-null-dereference",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-dereference"}]}},
           "taxonomies": [{"name": "CWE",
                           "version": "4.7",
                           "organization": "MITRE",
                           "shortDescription": {"text": "The MITRE Common Weakness Enumeration"},
                           "taxa": [{"id": "476",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}],
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}},
           "artifacts": [{"location": {"uri": "./Modules/_operator.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#include \"Python.h\"\n#include \"pycore_moduleobject.h\"  // _PyModule_GetState()\n#include \"structmember.h\"         // PyMemberDef\n#include \"pycore_runtime.h\"       // _Py_ID()\n#include \"clinic/_operator.c.h\"\n\ntypedef struct {\n    PyObject *itemgetter_type;\n    PyObject *attrgetter_type;\n    PyObject *methodcaller_type;\n} _operator_state;\n\nstatic inline _operator_state*\nget_operator_state(PyObject *module)\n{\n    void *state = _PyModule_GetState(module);\n    assert(state != NULL);\n    return (_operator_state *)state;\n}\n\n/*[clinic input]\nmodule _operator\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=672ecf48487521e7]*/\n\nPyDoc_STRVAR(operator_doc,\n\"Operator interface.\\n\\\n\\n\\\nThis module exports a set of functions implemented in C corresponding\\n\\\nto the intrinsic operators of Python.  For example, operator.add(x, y)\\n\\\nis equivalent to the expression x+y.  The function names are those\\n\\\nused for special methods; variants without leading and trailing\\n\\\n'__' are also provided for convenience.\");\n\n\n/*[clinic input]\n_operator.truth -> bool\n\n    a: object\n    /\n\nReturn True if a is true, False otherwise.\n[clinic start generated code]*/\n\nstatic int\n_operator_truth_impl(PyObject *module, PyObject *a)\n/*[clinic end generated code: output=eaf87767234fa5d7 input=bc74a4cd90235875]*/\n{\n    return PyObject_IsTrue(a);\n}\n\n/*[clinic input]\n_operator.add\n\n    a: object\n    b: object\n    /\n\nSame as a + b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_add_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=8292984204f45164 input=5efe3bff856ac215]*/\n{\n    return PyNumber_Add(a, b);\n}\n\n/*[clinic input]\n_operator.sub = _operator.add\n\nSame as a - b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_sub_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=4adfc3b888c1ee2e input=6494c6b100b8e795]*/\n{\n    return PyNumber_Subtract(a, b);\n}\n\n/*[clinic input]\n_operator.mul = _operator.add\n\nSame as a * b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_mul_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=d24d66f55a01944c input=2368615b4358b70d]*/\n{\n    return PyNumber_Multiply(a, b);\n}\n\n/*[clinic input]\n_operator.matmul = _operator.add\n\nSame as a @ b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_matmul_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=a20d917eb35d0101 input=9ab304e37fb42dd4]*/\n{\n    return PyNumber_MatrixMultiply(a, b);\n}\n\n/*[clinic input]\n_operator.floordiv = _operator.add\n\nSame as a // b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_floordiv_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=df26b71a60589f99 input=bb2e88ba446c612c]*/\n{\n    return PyNumber_FloorDivide(a, b);\n}\n\n/*[clinic input]\n_operator.truediv = _operator.add\n\nSame as a / b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_truediv_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=0e6a959944d77719 input=ecbb947673f4eb1f]*/\n{\n    return PyNumber_TrueDivide(a, b);\n}\n\n/*[clinic input]\n_operator.mod = _operator.add\n\nSame as a % b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_mod_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=9519822f0bbec166 input=102e19b422342ac1]*/\n{\n    return PyNumber_Remainder(a, b);\n}\n\n/*[clinic input]\n_operator.neg\n\n    a: object\n    /\n\nSame as -a.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_neg(PyObject *module, PyObject *a)\n/*[clinic end generated code: output=36e08ecfc6a1c08c input=84f09bdcf27c96ec]*/\n{\n    return PyNumber_Negative(a);\n}\n\n/*[clinic input]\n_operator.pos = _operator.neg\n\nSame as +a.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_pos(PyObject *module, PyObject *a)\n/*[clinic end generated code: output=dad7a126221dd091 input=b6445b63fddb8772]*/\n{\n    return PyNumber_Positive(a);\n}\n\n/*[clinic input]\n_operator.abs = _operator.neg\n\nSame as abs(a).\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_abs(PyObject *module, PyObject *a)\n/*[clinic end generated code: output=1389a93ba053ea3e input=341d07ba86f58039]*/\n{\n    return PyNumber_Absolute(a);\n}\n\n/*[clinic input]\n_operator.inv = _operator.neg\n\nSame as ~a.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_inv(PyObject *module, PyObject *a)\n/*[clinic end generated code: output=a56875ba075ee06d input=b01a4677739f6eb2]*/\n{\n    return PyNumber_Invert(a);\n}\n\n/*[clinic input]\n_operator.invert = _operator.neg\n\nSame as ~a.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_invert(PyObject *module, PyObject *a)\n/*[clinic end generated code: output=406b5aa030545fcc input=7f2d607176672e55]*/\n{\n    return PyNumber_Invert(a);\n}\n\n/*[clinic input]\n_operator.lshift = _operator.add\n\nSame as a << b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_lshift_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=37f7e52c41435bd8 input=746e8a160cbbc9eb]*/\n{\n    return PyNumber_Lshift(a, b);\n}\n\n/*[clinic input]\n_operator.rshift = _operator.add\n\nSame as a >> b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_rshift_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=4593c7ef30ec2ee3 input=d2c85bb5a64504c2]*/\n{\n    return PyNumber_Rshift(a, b);\n}\n\n/*[clinic input]\n_operator.not_ = _operator.truth\n\nSame as not a.\n[clinic start generated code]*/\n\nstatic int\n_operator_not__impl(PyObject *module, PyObject *a)\n/*[clinic end generated code: output=743f9c24a09759ef input=854156d50804d9b8]*/\n{\n    return PyObject_Not(a);\n}\n\n/*[clinic input]\n_operator.and_ = _operator.add\n\nSame as a & b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_and__impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=93c4fe88f7b76d9e input=4f3057c90ec4c99f]*/\n{\n    return PyNumber_And(a, b);\n}\n\n/*[clinic input]\n_operator.xor = _operator.add\n\nSame as a ^ b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_xor_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=b24cd8b79fde0004 input=3c5cfa7253d808dd]*/\n{\n    return PyNumber_Xor(a, b);\n}\n\n/*[clinic input]\n_operator.or_ = _operator.add\n\nSame as a | b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_or__impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=58024867b8d90461 input=b40c6c44f7c79c09]*/\n{\n    return PyNumber_Or(a, b);\n}\n\n/*[clinic input]\n_operator.iadd = _operator.add\n\nSame as a += b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_iadd_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=07dc627832526eb5 input=d22a91c07ac69227]*/\n{\n    return PyNumber_InPlaceAdd(a, b);\n}\n\n/*[clinic input]\n_operator.isub = _operator.add\n\nSame as a -= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_isub_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=4513467d23b5e0b1 input=4591b00d0a0ccafd]*/\n{\n    return PyNumber_InPlaceSubtract(a, b);\n}\n\n/*[clinic input]\n_operator.imul = _operator.add\n\nSame as a *= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_imul_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=5e87dacd19a71eab input=0e01fb8631e1b76f]*/\n{\n    return PyNumber_InPlaceMultiply(a, b);\n}\n\n/*[clinic input]\n_operator.imatmul = _operator.add\n\nSame as a @= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_imatmul_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=d603cbdf716ce519 input=bb614026372cd542]*/\n{\n    return PyNumber_InPlaceMatrixMultiply(a, b);\n}\n\n/*[clinic input]\n_operator.ifloordiv = _operator.add\n\nSame as a //= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_ifloordiv_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=535336048c681794 input=9df3b5021cff4ca1]*/\n{\n    return PyNumber_InPlaceFloorDivide(a, b);\n}\n\n/*[clinic input]\n_operator.itruediv = _operator.add\n\nSame as a /= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_itruediv_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=28017fbd3563952f input=9a1ee01608f5f590]*/\n{\n    return PyNumber_InPlaceTrueDivide(a, b);\n}\n\n/*[clinic input]\n_operator.imod = _operator.add\n\nSame as a %= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_imod_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=f7c540ae0fc70904 input=d0c384a3ce38e1dd]*/\n{\n    return PyNumber_InPlaceRemainder(a, b);\n}\n\n/*[clinic input]\n_operator.ilshift = _operator.add\n\nSame as a <<= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_ilshift_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=e73a8fee1ac18749 input=e21b6b310f54572e]*/\n{\n    return PyNumber_InPlaceLshift(a, b);\n}\n\n/*[clinic input]\n_operator.irshift = _operator.add\n\nSame as a >>= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_irshift_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=97f2af6b5ff2ed81 input=6778dbd0f6e1ec16]*/\n{\n    return PyNumber_InPlaceRshift(a, b);\n}\n\n/*[clinic input]\n_operator.iand = _operator.add\n\nSame as a &= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_iand_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=4599e9d40cbf7d00 input=71dfd8e70c156a7b]*/\n{\n    return PyNumber_InPlaceAnd(a, b);\n}\n\n/*[clinic input]\n_operator.ixor = _operator.add\n\nSame as a ^= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_ixor_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=5ff881766872be03 input=695c32bec0604d86]*/\n{\n    return PyNumber_InPlaceXor(a, b);\n}\n\n/*[clinic input]\n_operator.ior = _operator.add\n\nSame as a |= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_ior_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=48aac319445bf759 input=8f01d03eda9920cf]*/\n{\n    return PyNumber_InPlaceOr(a, b);\n}\n\n/*[clinic input]\n_operator.concat = _operator.add\n\nSame as a + b, for a and b sequences.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_concat_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=80028390942c5f11 input=8544ccd5341a3658]*/\n{\n    return PySequence_Concat(a, b);\n}\n\n/*[clinic input]\n_operator.iconcat = _operator.add\n\nSame as a += b, for a and b sequences.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_iconcat_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=3ea0a162ebb2e26d input=8f5fe5722fcd837e]*/\n{\n    return PySequence_InPlaceConcat(a, b);\n}\n\n/*[clinic input]\n_operator.contains -> bool\n\n    a: object\n    b: object\n    /\n\nSame as b in a (note reversed operands).\n[clinic start generated code]*/\n\nstatic int\n_operator_contains_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=413b4dbe82b6ffc1 input=9122a69b505fde13]*/\n{\n    return PySequence_Contains(a, b);\n}\n\n/*[clinic input]\n_operator.indexOf -> Py_ssize_t\n\n    a: object\n    b: object\n    /\n\nReturn the first index of b in a.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\n_operator_indexOf_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=c6226d8e0fb60fa6 input=8be2e43b6a6fffe3]*/\n{\n    return PySequence_Index(a, b);\n}\n\n/*[clinic input]\n_operator.countOf = _operator.indexOf\n\nReturn the number of items in a which are, or which equal, b.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\n_operator_countOf_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=9e1623197daf3382 input=93ea57f170f3f0bb]*/\n{\n    return PySequence_Count(a, b);\n}\n\n/*[clinic input]\n_operator.getitem\n\n    a: object\n    b: object\n    /\n\nSame as a[b].\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_getitem_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=6c8d8101a676e594 input=6682797320e48845]*/\n{\n    return PyObject_GetItem(a, b);\n}\n\n/*[clinic input]\n_operator.setitem\n\n    a: object\n    b: object\n    c: object\n    /\n\nSame as a[b] = c.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_setitem_impl(PyObject *module, PyObject *a, PyObject *b,\n                       PyObject *c)\n/*[clinic end generated code: output=1324f9061ae99e25 input=ceaf453c4d3a58df]*/\n{\n    if (-1 == PyObject_SetItem(a, b, c))\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n_operator.delitem = _operator.getitem\n\nSame as del a[b].\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_delitem_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=db18f61506295799 input=991bec56a0d3ec7f]*/\n{\n    if (-1 == PyObject_DelItem(a, b))\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n_operator.eq\n\n    a: object\n    b: object\n    /\n\nSame as a == b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_eq_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=8d7d46ed4135677c input=586fca687a95a83f]*/\n{\n    return PyObject_RichCompare(a, b, Py_EQ);\n}\n\n/*[clinic input]\n_operator.ne = _operator.eq\n\nSame as a != b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_ne_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=c99bd0c3a4c01297 input=5d88f23d35e9abac]*/\n{\n    return PyObject_RichCompare(a, b, Py_NE);\n}\n\n/*[clinic input]\n_operator.lt = _operator.eq\n\nSame as a < b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_lt_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=082d7c45c440e535 input=34a59ad6d39d3a2b]*/\n{\n    return PyObject_RichCompare(a, b, Py_LT);\n}\n\n/*[clinic input]\n_operator.le = _operator.eq\n\nSame as a <= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_le_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=00970a2923d0ae17 input=b812a7860a0bef44]*/\n{\n    return PyObject_RichCompare(a, b, Py_LE);\n}\n\n/*[clinic input]\n_operator.gt = _operator.eq\n\nSame as a > b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_gt_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=8d373349ecf25641 input=9bdb45b995ada35b]*/\n{\n    return PyObject_RichCompare(a, b, Py_GT);\n}\n\n/*[clinic input]\n_operator.ge = _operator.eq\n\nSame as a >= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_ge_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=7ce3882256d4b137 input=cf1dc4a5ca9c35f5]*/\n{\n    return PyObject_RichCompare(a, b, Py_GE);\n}\n\n/*[clinic input]\n_operator.pow = _operator.add\n\nSame as a ** b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_pow_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=09e668ad50036120 input=690b40f097ab1637]*/\n{\n    return PyNumber_Power(a, b, Py_None);\n}\n\n/*[clinic input]\n_operator.ipow = _operator.add\n\nSame as a **= b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_ipow_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=7189ff4d4367c808 input=f00623899d07499a]*/\n{\n    return PyNumber_InPlacePower(a, b, Py_None);\n}\n\n/*[clinic input]\n_operator.index\n\n    a: object\n    /\n\nSame as a.__index__()\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_index(PyObject *module, PyObject *a)\n/*[clinic end generated code: output=d972b0764ac305fc input=6f54d50ea64a579c]*/\n{\n    return PyNumber_Index(a);\n}\n\n/*[clinic input]\n_operator.is_ = _operator.add\n\nSame as a is b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_is__impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=bcd47a402e482e1d input=5fa9b97df03c427f]*/\n{\n    PyObject *result = Py_Is(a, b) ? Py_True : Py_False;\n    return Py_NewRef(result);\n}\n\n/*[clinic input]\n_operator.is_not = _operator.add\n\nSame as a is not b.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator_is_not_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=491a1f2f81f6c7f9 input=5a93f7e1a93535f1]*/\n{\n    PyObject *result;\n    result = (a != b) ? Py_True : Py_False;\n    return Py_NewRef(result);\n}\n\n/* compare_digest **********************************************************/\n\n/*\n * timing safe compare\n *\n * Returns 1 if the strings are equal.\n * In case of len(a) != len(b) the function tries to keep the timing\n * dependent on the length of b. CPU cache locality may still alter timing\n * a bit.\n */\nstatic int\n_tscmp(const unsigned char *a, const unsigned char *b,\n        Py_ssize_t len_a, Py_ssize_t len_b)\n{\n    /* The volatile type declarations make sure that the compiler has no\n     * chance to optimize and fold the code in any way that may change\n     * the timing.\n     */\n    volatile Py_ssize_t length;\n    volatile const unsigned char *left;\n    volatile const unsigned char *right;\n    Py_ssize_t i;\n    volatile unsigned char result;\n\n    /* loop count depends on length of b */\n    length = len_b;\n    left = NULL;\n    right = b;\n\n    /* don't use else here to keep the amount of CPU instructions constant,\n     * volatile forces re-evaluation\n     *  */\n    if (len_a == length) {\n        left = *((volatile const unsigned char**)&a);\n        result = 0;\n    }\n    if (len_a != length) {\n        left = b;\n        result = 1;\n    }\n\n    for (i=0; i < length; i++) {\n        result |= *left++ ^ *right++;\n    }\n\n    return (result == 0);\n}\n\n/*[clinic input]\n_operator.length_hint -> Py_ssize_t\n\n    obj: object\n    default: Py_ssize_t = 0\n    /\n\nReturn an estimate of the number of items in obj.\n\nThis is useful for presizing containers when building from an iterable.\n\nIf the object supports len(), the result will be exact.\nOtherwise, it may over- or under-estimate by an arbitrary amount.\nThe result will be an integer >= 0.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\n_operator_length_hint_impl(PyObject *module, PyObject *obj,\n                           Py_ssize_t default_value)\n/*[clinic end generated code: output=01d469edc1d612ad input=65ed29f04401e96a]*/\n{\n    return PyObject_LengthHint(obj, default_value);\n}\n\n/* NOTE: Keep in sync with _hashopenssl.c implementation. */\n\n/*[clinic input]\n_operator._compare_digest = _operator.eq\n\nReturn 'a == b'.\n\nThis function uses an approach designed to prevent\ntiming analysis, making it appropriate for cryptography.\n\na and b must both be of the same type: either str (ASCII only),\nor any bytes-like object.\n\nNote: If a and b are of different lengths, or if an error occurs,\na timing attack could theoretically reveal information about the\ntypes and lengths of a and b--but not their values.\n[clinic start generated code]*/\n\nstatic PyObject *\n_operator__compare_digest_impl(PyObject *module, PyObject *a, PyObject *b)\n/*[clinic end generated code: output=11d452bdd3a23cbc input=9ac7e2c4e30bc356]*/\n{\n    int rc;\n\n    /* ASCII unicode string */\n    if(PyUnicode_Check(a) && PyUnicode_Check(b)) {\n        if (PyUnicode_READY(a) == -1 || PyUnicode_READY(b) == -1) {\n            return NULL;\n        }\n        if (!PyUnicode_IS_ASCII(a) || !PyUnicode_IS_ASCII(b)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"comparing strings with non-ASCII characters is \"\n                            \"not supported\");\n            return NULL;\n        }\n\n        rc = _tscmp(PyUnicode_DATA(a),\n                    PyUnicode_DATA(b),\n                    PyUnicode_GET_LENGTH(a),\n                    PyUnicode_GET_LENGTH(b));\n    }\n    /* fallback to buffer interface for bytes, bytearray and other */\n    else {\n        Py_buffer view_a;\n        Py_buffer view_b;\n\n        if (PyObject_CheckBuffer(a) == 0 && PyObject_CheckBuffer(b) == 0) {\n            PyErr_Format(PyExc_TypeError,\n                         \"unsupported operand types(s) or combination of types: \"\n                         \"'%.100s' and '%.100s'\",\n                         Py_TYPE(a)->tp_name, Py_TYPE(b)->tp_name);\n            return NULL;\n        }\n\n        if (PyObject_GetBuffer(a, &view_a, PyBUF_SIMPLE) == -1) {\n            return NULL;\n        }\n        if (view_a.ndim > 1) {\n            PyErr_SetString(PyExc_BufferError,\n                            \"Buffer must be single dimension\");\n            PyBuffer_Release(&view_a);\n            return NULL;\n        }\n\n        if (PyObject_GetBuffer(b, &view_b, PyBUF_SIMPLE) == -1) {\n            PyBuffer_Release(&view_a);\n            return NULL;\n        }\n        if (view_b.ndim > 1) {\n            PyErr_SetString(PyExc_BufferError,\n                            \"Buffer must be single dimension\");\n            PyBuffer_Release(&view_a);\n            PyBuffer_Release(&view_b);\n            return NULL;\n        }\n\n        rc = _tscmp((const unsigned char*)view_a.buf,\n                    (const unsigned char*)view_b.buf,\n                    view_a.len,\n                    view_b.len);\n\n        PyBuffer_Release(&view_a);\n        PyBuffer_Release(&view_b);\n    }\n\n    return PyBool_FromLong(rc);\n}\n\nPyDoc_STRVAR(_operator_call__doc__,\n\"call($module, obj, /, *args, **kwargs)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Same as obj(*args, **kwargs).\");\n\n#define _OPERATOR_CALL_METHODDEF    \\\n    {\"call\", _PyCFunction_CAST(_operator_call), METH_FASTCALL | METH_KEYWORDS, _operator_call__doc__},\n\nstatic PyObject *\n_operator_call(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    if (!_PyArg_CheckPositional(\"call\", nargs, 1, PY_SSIZE_T_MAX)) {\n        return NULL;\n    }\n    return PyObject_Vectorcall(\n            args[0],\n            &args[1], (PyVectorcall_NARGS(nargs) - 1) | PY_VECTORCALL_ARGUMENTS_OFFSET,\n            kwnames);\n}\n\n/* operator methods **********************************************************/\n\nstatic struct PyMethodDef operator_methods[] = {\n\n    _OPERATOR_TRUTH_METHODDEF\n    _OPERATOR_CONTAINS_METHODDEF\n    _OPERATOR_INDEXOF_METHODDEF\n    _OPERATOR_COUNTOF_METHODDEF\n    _OPERATOR_IS__METHODDEF\n    _OPERATOR_IS_NOT_METHODDEF\n    _OPERATOR_INDEX_METHODDEF\n    _OPERATOR_ADD_METHODDEF\n    _OPERATOR_SUB_METHODDEF\n    _OPERATOR_MUL_METHODDEF\n    _OPERATOR_MATMUL_METHODDEF\n    _OPERATOR_FLOORDIV_METHODDEF\n    _OPERATOR_TRUEDIV_METHODDEF\n    _OPERATOR_MOD_METHODDEF\n    _OPERATOR_NEG_METHODDEF\n    _OPERATOR_POS_METHODDEF\n    _OPERATOR_ABS_METHODDEF\n    _OPERATOR_INV_METHODDEF\n    _OPERATOR_INVERT_METHODDEF\n    _OPERATOR_LSHIFT_METHODDEF\n    _OPERATOR_RSHIFT_METHODDEF\n    _OPERATOR_NOT__METHODDEF\n    _OPERATOR_AND__METHODDEF\n    _OPERATOR_XOR_METHODDEF\n    _OPERATOR_OR__METHODDEF\n    _OPERATOR_IADD_METHODDEF\n    _OPERATOR_ISUB_METHODDEF\n    _OPERATOR_IMUL_METHODDEF\n    _OPERATOR_IMATMUL_METHODDEF\n    _OPERATOR_IFLOORDIV_METHODDEF\n    _OPERATOR_ITRUEDIV_METHODDEF\n    _OPERATOR_IMOD_METHODDEF\n    _OPERATOR_ILSHIFT_METHODDEF\n    _OPERATOR_IRSHIFT_METHODDEF\n    _OPERATOR_IAND_METHODDEF\n    _OPERATOR_IXOR_METHODDEF\n    _OPERATOR_IOR_METHODDEF\n    _OPERATOR_CONCAT_METHODDEF\n    _OPERATOR_ICONCAT_METHODDEF\n    _OPERATOR_GETITEM_METHODDEF\n    _OPERATOR_SETITEM_METHODDEF\n    _OPERATOR_DELITEM_METHODDEF\n    _OPERATOR_POW_METHODDEF\n    _OPERATOR_IPOW_METHODDEF\n    _OPERATOR_EQ_METHODDEF\n    _OPERATOR_NE_METHODDEF\n    _OPERATOR_LT_METHODDEF\n    _OPERATOR_LE_METHODDEF\n    _OPERATOR_GT_METHODDEF\n    _OPERATOR_GE_METHODDEF\n    _OPERATOR__COMPARE_DIGEST_METHODDEF\n    _OPERATOR_LENGTH_HINT_METHODDEF\n    _OPERATOR_CALL_METHODDEF\n    {NULL,              NULL}           /* sentinel */\n\n};\n\n/* itemgetter object **********************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    Py_ssize_t nitems;\n    PyObject *item;\n    Py_ssize_t index; // -1 unless *item* is a single non-negative integer index\n    vectorcallfunc vectorcall;\n} itemgetterobject;\n\n// Forward declarations\nstatic PyObject *\nitemgetter_vectorcall(PyObject *, PyObject *const *, size_t, PyObject *);\nstatic PyObject *\nitemgetter_call_impl(itemgetterobject *, PyObject *);\n\n/* AC 3.5: treats first argument as an iterable, otherwise uses *args */\nstatic PyObject *\nitemgetter_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    itemgetterobject *ig;\n    PyObject *item;\n    Py_ssize_t nitems;\n    Py_ssize_t index;\n\n    if (!_PyArg_NoKeywords(\"itemgetter\", kwds))\n        return NULL;\n\n    nitems = PyTuple_GET_SIZE(args);\n    if (nitems <= 1) {\n        if (!PyArg_UnpackTuple(args, \"itemgetter\", 1, 1, &item))\n            return NULL;\n    } else {\n        item = args;\n    }\n    _operator_state *state = _PyType_GetModuleState(type);\n    /* create itemgetterobject structure */\n    ig = PyObject_GC_New(itemgetterobject, (PyTypeObject *) state->itemgetter_type);\n    if (ig == NULL) {\n        return NULL;\n    }\n\n    ig->item = Py_NewRef(item);\n    ig->nitems = nitems;\n    ig->index = -1;\n    if (PyLong_CheckExact(item)) {\n        index = PyLong_AsSsize_t(item);\n        if (index < 0) {\n            /* If we get here, then either the index conversion failed\n             * due to being out of range, or the index was a negative\n             * integer.  Either way, we clear any possible exception\n             * and fall back to the slow path, where ig->index is -1.\n             */\n            PyErr_Clear();\n        }\n        else {\n            ig->index = index;\n        }\n    }\n\n    ig->vectorcall = (vectorcallfunc)itemgetter_vectorcall;\n    PyObject_GC_Track(ig);\n    return (PyObject *)ig;\n}\n\nstatic int\nitemgetter_clear(itemgetterobject *ig)\n{\n    Py_CLEAR(ig->item);\n    return 0;\n}\n\nstatic void\nitemgetter_dealloc(itemgetterobject *ig)\n{\n    PyTypeObject *tp = Py_TYPE(ig);\n    PyObject_GC_UnTrack(ig);\n    (void)itemgetter_clear(ig);\n    tp->tp_free(ig);\n    Py_DECREF(tp);\n}\n\nstatic int\nitemgetter_traverse(itemgetterobject *ig, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(ig));\n    Py_VISIT(ig->item);\n    return 0;\n}\n\nstatic PyObject *\nitemgetter_call(itemgetterobject *ig, PyObject *args, PyObject *kw)\n{\n    assert(PyTuple_CheckExact(args));\n    if (!_PyArg_NoKeywords(\"itemgetter\", kw))\n        return NULL;\n    if (!_PyArg_CheckPositional(\"itemgetter\", PyTuple_GET_SIZE(args), 1, 1))\n        return NULL;\n    return itemgetter_call_impl(ig, PyTuple_GET_ITEM(args, 0));\n}\n\nstatic PyObject *\nitemgetter_vectorcall(PyObject *ig, PyObject *const *args,\n                      size_t nargsf, PyObject *kwnames)\n{\n    if (!_PyArg_NoKwnames(\"itemgetter\", kwnames)) {\n        return NULL;\n    }\n    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);\n    if (!_PyArg_CheckPositional(\"itemgetter\", nargs, 1, 1)) {\n        return NULL;\n    }\n    return itemgetter_call_impl((itemgetterobject *)ig, args[0]);\n}\n\nstatic PyObject *\nitemgetter_call_impl(itemgetterobject *ig, PyObject *obj)\n{\n    PyObject *result;\n    Py_ssize_t i, nitems=ig->nitems;\n    if (nitems == 1) {\n        if (ig->index >= 0\n            && PyTuple_CheckExact(obj)\n            && ig->index < PyTuple_GET_SIZE(obj))\n        {\n            result = PyTuple_GET_ITEM(obj, ig->index);\n            return Py_NewRef(result);\n        }\n        return PyObject_GetItem(obj, ig->item);\n    }\n\n    assert(PyTuple_Check(ig->item));\n    assert(PyTuple_GET_SIZE(ig->item) == nitems);\n\n    result = PyTuple_New(nitems);\n    if (result == NULL)\n        return NULL;\n\n    for (i=0 ; i < nitems ; i++) {\n        PyObject *item, *val;\n        item = PyTuple_GET_ITEM(ig->item, i);\n        val = PyObject_GetItem(obj, item);\n        if (val == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        PyTuple_SET_ITEM(result, i, val);\n    }\n    return result;\n}\n\nstatic PyObject *\nitemgetter_repr(itemgetterobject *ig)\n{\n    PyObject *repr;\n    const char *reprfmt;\n\n    int status = Py_ReprEnter((PyObject *)ig);\n    if (status != 0) {\n        if (status < 0)\n            return NULL;\n        return PyUnicode_FromFormat(\"%s(...)\", Py_TYPE(ig)->tp_name);\n    }\n\n    reprfmt = ig->nitems == 1 ? \"%s(%R)\" : \"%s%R\";\n    repr = PyUnicode_FromFormat(reprfmt, Py_TYPE(ig)->tp_name, ig->item);\n    Py_ReprLeave((PyObject *)ig);\n    return repr;\n}\n\nstatic PyObject *\nitemgetter_reduce(itemgetterobject *ig, PyObject *Py_UNUSED(ignored))\n{\n    if (ig->nitems == 1)\n        return Py_BuildValue(\"O(O)\", Py_TYPE(ig), ig->item);\n    return PyTuple_Pack(2, Py_TYPE(ig), ig->item);\n}\n\nPyDoc_STRVAR(reduce_doc, \"Return state information for pickling\");\n\nstatic PyMethodDef itemgetter_methods[] = {\n    {\"__reduce__\", (PyCFunction)itemgetter_reduce, METH_NOARGS,\n     reduce_doc},\n    {NULL}\n};\n\nstatic PyMemberDef itemgetter_members[] = {\n    {\"__vectorcalloffset__\", T_PYSSIZET, offsetof(itemgetterobject, vectorcall), READONLY},\n    {NULL} /* Sentinel */\n};\n\nPyDoc_STRVAR(itemgetter_doc,\n\"itemgetter(item, /, *items)\\n--\\n\\n\\\nReturn a callable object that fetches the given item(s) from its operand.\\n\\\nAfter f = itemgetter(2), the call f(r) returns r[2].\\n\\\nAfter g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])\");\n\nstatic PyType_Slot itemgetter_type_slots[] = {\n    {Py_tp_doc, (void *)itemgetter_doc},\n    {Py_tp_dealloc, itemgetter_dealloc},\n    {Py_tp_call, itemgetter_call},\n    {Py_tp_traverse, itemgetter_traverse},\n    {Py_tp_clear, itemgetter_clear},\n    {Py_tp_methods, itemgetter_methods},\n    {Py_tp_members, itemgetter_members},\n    {Py_tp_new, itemgetter_new},\n    {Py_tp_getattro, PyObject_GenericGetAttr},\n    {Py_tp_repr, itemgetter_repr},\n    {0, 0}\n};\n\nstatic PyType_Spec itemgetter_type_spec = {\n    .name = \"operator.itemgetter\",\n    .basicsize = sizeof(itemgetterobject),\n    .itemsize = 0,\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n              Py_TPFLAGS_IMMUTABLETYPE | Py_TPFLAGS_HAVE_VECTORCALL),\n    .slots = itemgetter_type_slots,\n};\n\n/* attrgetter object **********************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    Py_ssize_t nattrs;\n    PyObject *attr;\n    vectorcallfunc vectorcall;\n} attrgetterobject;\n\n// Forward declarations\nstatic PyObject *\nattrgetter_vectorcall(PyObject *, PyObject *const *, size_t, PyObject *);\nstatic PyObject *\nattrgetter_call_impl(attrgetterobject *, PyObject *);\n\n/* AC 3.5: treats first argument as an iterable, otherwise uses *args */\nstatic PyObject *\nattrgetter_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    attrgetterobject *ag;\n    PyObject *attr;\n    Py_ssize_t nattrs, idx, char_idx;\n\n    if (!_PyArg_NoKeywords(\"attrgetter\", kwds))\n        return NULL;\n\n    nattrs = PyTuple_GET_SIZE(args);\n    if (nattrs <= 1) {\n        if (!PyArg_UnpackTuple(args, \"attrgetter\", 1, 1, &attr))\n            return NULL;\n    }\n\n    attr = PyTuple_New(nattrs);\n    if (attr == NULL)\n        return NULL;\n\n    /* prepare attr while checking args */\n    for (idx = 0; idx < nattrs; ++idx) {\n        PyObject *item = PyTuple_GET_ITEM(args, idx);\n        int dot_count;\n\n        if (!PyUnicode_Check(item)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"attribute name must be a string\");\n            Py_DECREF(attr);\n            return NULL;\n        }\n        if (PyUnicode_READY(item)) {\n            Py_DECREF(attr);\n            return NULL;\n        }\n        Py_ssize_t item_len = PyUnicode_GET_LENGTH(item);\n        int kind = PyUnicode_KIND(item);\n        const void *data = PyUnicode_DATA(item);\n\n        /* check whether the string is dotted */\n        dot_count = 0;\n        for (char_idx = 0; char_idx < item_len; ++char_idx) {\n            if (PyUnicode_READ(kind, data, char_idx) == '.')\n                ++dot_count;\n        }\n\n        if (dot_count == 0) {\n            Py_INCREF(item);\n            PyUnicode_InternInPlace(&item);\n            PyTuple_SET_ITEM(attr, idx, item);\n        } else { /* make it a tuple of non-dotted attrnames */\n            PyObject *attr_chain = PyTuple_New(dot_count + 1);\n            PyObject *attr_chain_item;\n            Py_ssize_t unibuff_from = 0;\n            Py_ssize_t unibuff_till = 0;\n            Py_ssize_t attr_chain_idx = 0;\n\n            if (attr_chain == NULL) {\n                Py_DECREF(attr);\n                return NULL;\n            }\n\n            for (; dot_count > 0; --dot_count) {\n                while (PyUnicode_READ(kind, data, unibuff_till) != '.') {\n                    ++unibuff_till;\n                }\n                attr_chain_item = PyUnicode_Substring(item,\n                                      unibuff_from,\n                                      unibuff_till);\n                if (attr_chain_item == NULL) {\n                    Py_DECREF(attr_chain);\n                    Py_DECREF(attr);\n                    return NULL;\n                }\n                PyUnicode_InternInPlace(&attr_chain_item);\n                PyTuple_SET_ITEM(attr_chain, attr_chain_idx, attr_chain_item);\n                ++attr_chain_idx;\n                unibuff_till = unibuff_from = unibuff_till + 1;\n            }\n\n            /* now add the last dotless name */\n            attr_chain_item = PyUnicode_Substring(item,\n                                                  unibuff_from, item_len);\n            if (attr_chain_item == NULL) {\n                Py_DECREF(attr_chain);\n                Py_DECREF(attr);\n                return NULL;\n            }\n            PyUnicode_InternInPlace(&attr_chain_item);\n            PyTuple_SET_ITEM(attr_chain, attr_chain_idx, attr_chain_item);\n\n            PyTuple_SET_ITEM(attr, idx, attr_chain);\n        }\n    }\n\n    _operator_state *state = _PyType_GetModuleState(type);\n    /* create attrgetterobject structure */\n    ag = PyObject_GC_New(attrgetterobject, (PyTypeObject *)state->attrgetter_type);\n    if (ag == NULL) {\n        Py_DECREF(attr);\n        return NULL;\n    }\n\n    ag->attr = attr;\n    ag->nattrs = nattrs;\n    ag->vectorcall = (vectorcallfunc)attrgetter_vectorcall;\n\n    PyObject_GC_Track(ag);\n    return (PyObject *)ag;\n}\n\nstatic int\nattrgetter_clear(attrgetterobject *ag)\n{\n    Py_CLEAR(ag->attr);\n    return 0;\n}\n\nstatic void\nattrgetter_dealloc(attrgetterobject *ag)\n{\n    PyTypeObject *tp = Py_TYPE(ag);\n    PyObject_GC_UnTrack(ag);\n    (void)attrgetter_clear(ag);\n    tp->tp_free(ag);\n    Py_DECREF(tp);\n}\n\nstatic int\nattrgetter_traverse(attrgetterobject *ag, visitproc visit, void *arg)\n{\n    Py_VISIT(ag->attr);\n    Py_VISIT(Py_TYPE(ag));\n    return 0;\n}\n\nstatic PyObject *\ndotted_getattr(PyObject *obj, PyObject *attr)\n{\n    PyObject *newobj;\n\n    /* attr is either a tuple or instance of str.\n       Ensured by the setup code of attrgetter_new */\n    if (PyTuple_CheckExact(attr)) { /* chained getattr */\n        Py_ssize_t name_idx = 0, name_count;\n        PyObject *attr_name;\n\n        name_count = PyTuple_GET_SIZE(attr);\n        Py_INCREF(obj);\n        for (name_idx = 0; name_idx < name_count; ++name_idx) {\n            attr_name = PyTuple_GET_ITEM(attr, name_idx);\n            newobj = PyObject_GetAttr(obj, attr_name);\n            Py_DECREF(obj);\n            if (newobj == NULL) {\n                return NULL;\n            }\n            /* here */\n            obj = newobj;\n        }\n    } else { /* single getattr */\n        newobj = PyObject_GetAttr(obj, attr);\n        if (newobj == NULL)\n            return NULL;\n        obj = newobj;\n    }\n\n    return obj;\n}\n\nstatic PyObject *\nattrgetter_call(attrgetterobject *ag, PyObject *args, PyObject *kw)\n{\n    if (!_PyArg_NoKeywords(\"attrgetter\", kw))\n        return NULL;\n    if (!_PyArg_CheckPositional(\"attrgetter\", PyTuple_GET_SIZE(args), 1, 1))\n        return NULL;\n    return attrgetter_call_impl(ag, PyTuple_GET_ITEM(args, 0));\n}\n\nstatic PyObject *\nattrgetter_vectorcall(PyObject *ag, PyObject *const *args, size_t nargsf, PyObject *kwnames)\n{\n    if (!_PyArg_NoKwnames(\"attrgetter\", kwnames)) {\n        return NULL;\n    }\n    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);\n    if (!_PyArg_CheckPositional(\"attrgetter\", nargs, 1, 1)) {\n        return NULL;\n    }\n    return attrgetter_call_impl((attrgetterobject *)ag, args[0]);\n}\n\nstatic PyObject *\nattrgetter_call_impl(attrgetterobject *ag, PyObject *obj)\n{\n    PyObject *result;\n    Py_ssize_t i, nattrs=ag->nattrs;\n\n    if (ag->nattrs == 1) {\n        /* ag->attr is always a tuple */\n        return dotted_getattr(obj, PyTuple_GET_ITEM(ag->attr, 0));\n    }\n\n    assert(PyTuple_Check(ag->attr));\n    assert(PyTuple_GET_SIZE(ag->attr) == nattrs);\n\n    result = PyTuple_New(nattrs);\n    if (result == NULL)\n        return NULL;\n\n    for (i=0 ; i < nattrs ; i++) {\n        PyObject *attr, *val;\n        attr = PyTuple_GET_ITEM(ag->attr, i);\n        val = dotted_getattr(obj, attr);\n        if (val == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        PyTuple_SET_ITEM(result, i, val);\n    }\n    return result;\n}\n\nstatic PyObject *\ndotjoinattr(PyObject *attr, PyObject **attrsep)\n{\n    if (PyTuple_CheckExact(attr)) {\n        if (*attrsep == NULL) {\n            *attrsep = PyUnicode_FromString(\".\");\n            if (*attrsep == NULL)\n                return NULL;\n        }\n        return PyUnicode_Join(*attrsep, attr);\n    } else {\n        return Py_NewRef(attr);\n    }\n}\n\nstatic PyObject *\nattrgetter_args(attrgetterobject *ag)\n{\n    Py_ssize_t i;\n    PyObject *attrsep = NULL;\n    PyObject *attrstrings = PyTuple_New(ag->nattrs);\n    if (attrstrings == NULL)\n        return NULL;\n\n    for (i = 0; i < ag->nattrs; ++i) {\n        PyObject *attr = PyTuple_GET_ITEM(ag->attr, i);\n        PyObject *attrstr = dotjoinattr(attr, &attrsep);\n        if (attrstr == NULL) {\n            Py_XDECREF(attrsep);\n            Py_DECREF(attrstrings);\n            return NULL;\n        }\n        PyTuple_SET_ITEM(attrstrings, i, attrstr);\n    }\n    Py_XDECREF(attrsep);\n    return attrstrings;\n}\n\nstatic PyObject *\nattrgetter_repr(attrgetterobject *ag)\n{\n    PyObject *repr = NULL;\n    int status = Py_ReprEnter((PyObject *)ag);\n    if (status != 0) {\n        if (status < 0)\n            return NULL;\n        return PyUnicode_FromFormat(\"%s(...)\", Py_TYPE(ag)->tp_name);\n    }\n\n    if (ag->nattrs == 1) {\n        PyObject *attrsep = NULL;\n        PyObject *attr = dotjoinattr(PyTuple_GET_ITEM(ag->attr, 0), &attrsep);\n        if (attr != NULL) {\n            repr = PyUnicode_FromFormat(\"%s(%R)\", Py_TYPE(ag)->tp_name, attr);\n            Py_DECREF(attr);\n        }\n        Py_XDECREF(attrsep);\n    }\n    else {\n        PyObject *attrstrings = attrgetter_args(ag);\n        if (attrstrings != NULL) {\n            repr = PyUnicode_FromFormat(\"%s%R\",\n                                        Py_TYPE(ag)->tp_name, attrstrings);\n            Py_DECREF(attrstrings);\n        }\n    }\n    Py_ReprLeave((PyObject *)ag);\n    return repr;\n}\n\nstatic PyObject *\nattrgetter_reduce(attrgetterobject *ag, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *attrstrings = attrgetter_args(ag);\n    if (attrstrings == NULL)\n        return NULL;\n\n    return Py_BuildValue(\"ON\", Py_TYPE(ag), attrstrings);\n}\n\nstatic PyMethodDef attrgetter_methods[] = {\n    {\"__reduce__\", (PyCFunction)attrgetter_reduce, METH_NOARGS,\n     reduce_doc},\n    {NULL}\n};\n\nstatic PyMemberDef attrgetter_members[] = {\n    {\"__vectorcalloffset__\", T_PYSSIZET, offsetof(attrgetterobject, vectorcall), READONLY},\n    {NULL} /* Sentinel*/\n};\n\nPyDoc_STRVAR(attrgetter_doc,\n\"attrgetter(attr, /, *attrs)\\n--\\n\\n\\\nReturn a callable object that fetches the given attribute(s) from its operand.\\n\\\nAfter f = attrgetter('name'), the call f(r) returns r.name.\\n\\\nAfter g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\\n\\\nAfter h = attrgetter('name.first', 'name.last'), the call h(r) returns\\n\\\n(r.name.first, r.name.last).\");\n\nstatic PyType_Slot attrgetter_type_slots[] = {\n    {Py_tp_doc, (void *)attrgetter_doc},\n    {Py_tp_dealloc, attrgetter_dealloc},\n    {Py_tp_call, attrgetter_call},\n    {Py_tp_traverse, attrgetter_traverse},\n    {Py_tp_clear, attrgetter_clear},\n    {Py_tp_methods, attrgetter_methods},\n    {Py_tp_members, attrgetter_members},\n    {Py_tp_new, attrgetter_new},\n    {Py_tp_getattro, PyObject_GenericGetAttr},\n    {Py_tp_repr, attrgetter_repr},\n    {0, 0}\n};\n\nstatic PyType_Spec attrgetter_type_spec = {\n    .name = \"operator.attrgetter\",\n    .basicsize = sizeof(attrgetterobject),\n    .itemsize = 0,\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n              Py_TPFLAGS_IMMUTABLETYPE | Py_TPFLAGS_HAVE_VECTORCALL),\n    .slots = attrgetter_type_slots,\n};\n\n\n/* methodcaller object **********************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *name;\n    PyObject *args;\n    PyObject *kwds;\n} methodcallerobject;\n\n/* AC 3.5: variable number of arguments, not currently support by AC */\nstatic PyObject *\nmethodcaller_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    methodcallerobject *mc;\n    PyObject *name;\n\n    if (PyTuple_GET_SIZE(args) < 1) {\n        PyErr_SetString(PyExc_TypeError, \"methodcaller needs at least \"\n                        \"one argument, the method name\");\n        return NULL;\n    }\n\n    name = PyTuple_GET_ITEM(args, 0);\n    if (!PyUnicode_Check(name)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"method name must be a string\");\n        return NULL;\n    }\n\n    _operator_state *state = _PyType_GetModuleState(type);\n    /* create methodcallerobject structure */\n    mc = PyObject_GC_New(methodcallerobject, (PyTypeObject *)state->methodcaller_type);\n    if (mc == NULL) {\n        return NULL;\n    }\n\n    name = PyTuple_GET_ITEM(args, 0);\n    Py_INCREF(name);\n    PyUnicode_InternInPlace(&name);\n    mc->name = name;\n\n    mc->kwds = Py_XNewRef(kwds);\n\n    mc->args = PyTuple_GetSlice(args, 1, PyTuple_GET_SIZE(args));\n    if (mc->args == NULL) {\n        Py_DECREF(mc);\n        return NULL;\n    }\n\n    PyObject_GC_Track(mc);\n    return (PyObject *)mc;\n}\n\nstatic int\nmethodcaller_clear(methodcallerobject *mc)\n{\n    Py_CLEAR(mc->name);\n    Py_CLEAR(mc->args);\n    Py_CLEAR(mc->kwds);\n    return 0;\n}\n\nstatic void\nmethodcaller_dealloc(methodcallerobject *mc)\n{\n    PyTypeObject *tp = Py_TYPE(mc);\n    PyObject_GC_UnTrack(mc);\n    (void)methodcaller_clear(mc);\n    tp->tp_free(mc);\n    Py_DECREF(tp);\n}\n\nstatic int\nmethodcaller_traverse(methodcallerobject *mc, visitproc visit, void *arg)\n{\n    Py_VISIT(mc->name);\n    Py_VISIT(mc->args);\n    Py_VISIT(mc->kwds);\n    Py_VISIT(Py_TYPE(mc));\n    return 0;\n}\n\nstatic PyObject *\nmethodcaller_call(methodcallerobject *mc, PyObject *args, PyObject *kw)\n{\n    PyObject *method, *obj, *result;\n\n    if (!_PyArg_NoKeywords(\"methodcaller\", kw))\n        return NULL;\n    if (!_PyArg_CheckPositional(\"methodcaller\", PyTuple_GET_SIZE(args), 1, 1))\n        return NULL;\n    obj = PyTuple_GET_ITEM(args, 0);\n    method = PyObject_GetAttr(obj, mc->name);\n    if (method == NULL)\n        return NULL;\n    result = PyObject_Call(method, mc->args, mc->kwds);\n    Py_DECREF(method);\n    return result;\n}\n\nstatic PyObject *\nmethodcaller_repr(methodcallerobject *mc)\n{\n    PyObject *argreprs, *repr = NULL, *sep, *joinedargreprs;\n    Py_ssize_t numtotalargs, numposargs, numkwdargs, i;\n    int status = Py_ReprEnter((PyObject *)mc);\n    if (status != 0) {\n        if (status < 0)\n            return NULL;\n        return PyUnicode_FromFormat(\"%s(...)\", Py_TYPE(mc)->tp_name);\n    }\n\n    numkwdargs = mc->kwds != NULL ? PyDict_GET_SIZE(mc->kwds) : 0;\n    numposargs = PyTuple_GET_SIZE(mc->args);\n    numtotalargs = numposargs + numkwdargs;\n\n    if (numtotalargs == 0) {\n        repr = PyUnicode_FromFormat(\"%s(%R)\", Py_TYPE(mc)->tp_name, mc->name);\n        Py_ReprLeave((PyObject *)mc);\n        return repr;\n    }\n\n    argreprs = PyTuple_New(numtotalargs);\n    if (argreprs == NULL) {\n        Py_ReprLeave((PyObject *)mc);\n        return NULL;\n    }\n\n    for (i = 0; i < numposargs; ++i) {\n        PyObject *onerepr = PyObject_Repr(PyTuple_GET_ITEM(mc->args, i));\n        if (onerepr == NULL)\n            goto done;\n        PyTuple_SET_ITEM(argreprs, i, onerepr);\n    }\n\n    if (numkwdargs != 0) {\n        PyObject *key, *value;\n        Py_ssize_t pos = 0;\n        while (PyDict_Next(mc->kwds, &pos, &key, &value)) {\n            PyObject *onerepr = PyUnicode_FromFormat(\"%U=%R\", key, value);\n            if (onerepr == NULL)\n                goto done;\n            if (i >= numtotalargs) {\n                i = -1;\n                Py_DECREF(onerepr);\n                break;\n            }\n            PyTuple_SET_ITEM(argreprs, i, onerepr);\n            ++i;\n        }\n        if (i != numtotalargs) {\n            PyErr_SetString(PyExc_RuntimeError,\n                            \"keywords dict changed size during iteration\");\n            goto done;\n        }\n    }\n\n    sep = PyUnicode_FromString(\", \");\n    if (sep == NULL)\n        goto done;\n\n    joinedargreprs = PyUnicode_Join(sep, argreprs);\n    Py_DECREF(sep);\n    if (joinedargreprs == NULL)\n        goto done;\n\n    repr = PyUnicode_FromFormat(\"%s(%R, %U)\", Py_TYPE(mc)->tp_name,\n                                mc->name, joinedargreprs);\n    Py_DECREF(joinedargreprs);\n\ndone:\n    Py_DECREF(argreprs);\n    Py_ReprLeave((PyObject *)mc);\n    return repr;\n}\n\nstatic PyObject *\nmethodcaller_reduce(methodcallerobject *mc, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *newargs;\n    if (!mc->kwds || PyDict_GET_SIZE(mc->kwds) == 0) {\n        Py_ssize_t i;\n        Py_ssize_t callargcount = PyTuple_GET_SIZE(mc->args);\n        newargs = PyTuple_New(1 + callargcount);\n        if (newargs == NULL)\n            return NULL;\n        PyTuple_SET_ITEM(newargs, 0, Py_NewRef(mc->name));\n        for (i = 0; i < callargcount; ++i) {\n            PyObject *arg = PyTuple_GET_ITEM(mc->args, i);\n            PyTuple_SET_ITEM(newargs, i + 1, Py_NewRef(arg));\n        }\n        return Py_BuildValue(\"ON\", Py_TYPE(mc), newargs);\n    }\n    else {\n        PyObject *partial;\n        PyObject *constructor;\n        PyObject *newargs[2];\n\n        partial = _PyImport_GetModuleAttrString(\"functools\", \"partial\");\n        if (!partial)\n            return NULL;\n\n        newargs[0] = (PyObject *)Py_TYPE(mc);\n        newargs[1] = mc->name;\n        constructor = PyObject_VectorcallDict(partial, newargs, 2, mc->kwds);\n\n        Py_DECREF(partial);\n        return Py_BuildValue(\"NO\", constructor, mc->args);\n    }\n}\n\nstatic PyMethodDef methodcaller_methods[] = {\n    {\"__reduce__\", (PyCFunction)methodcaller_reduce, METH_NOARGS,\n     reduce_doc},\n    {NULL}\n};\nPyDoc_STRVAR(methodcaller_doc,\n\"methodcaller(name, /, *args, **kwargs)\\n--\\n\\n\\\nReturn a callable object that calls the given method on its operand.\\n\\\nAfter f = methodcaller('name'), the call f(r) returns r.name().\\n\\\nAfter g = methodcaller('name', 'date', foo=1), the call g(r) returns\\n\\\nr.name('date', foo=1).\");\n\nstatic PyType_Slot methodcaller_type_slots[] = {\n    {Py_tp_doc, (void *)methodcaller_doc},\n    {Py_tp_dealloc, methodcaller_dealloc},\n    {Py_tp_call, methodcaller_call},\n    {Py_tp_traverse, methodcaller_traverse},\n    {Py_tp_clear, methodcaller_clear},\n    {Py_tp_methods, methodcaller_methods},\n    {Py_tp_new, methodcaller_new},\n    {Py_tp_getattro, PyObject_GenericGetAttr},\n    {Py_tp_repr, methodcaller_repr},\n    {0, 0}\n};\n\nstatic PyType_Spec methodcaller_type_spec = {\n    .name = \"operator.methodcaller\",\n    .basicsize = sizeof(methodcallerobject),\n    .itemsize = 0,\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n              Py_TPFLAGS_IMMUTABLETYPE),\n    .slots = methodcaller_type_slots,\n};\n\nstatic int\noperator_exec(PyObject *module)\n{\n    _operator_state *state = get_operator_state(module);\n    state->attrgetter_type = PyType_FromModuleAndSpec(module, &attrgetter_type_spec, NULL);\n    if (state->attrgetter_type == NULL) {\n        return -1;\n    }\n    if (PyModule_AddType(module, (PyTypeObject *)state->attrgetter_type) < 0) {\n        return -1;\n    }\n\n    state->itemgetter_type = PyType_FromModuleAndSpec(module, &itemgetter_type_spec, NULL);\n    if (state->itemgetter_type == NULL) {\n        return -1;\n    }\n    if (PyModule_AddType(module, (PyTypeObject *)state->itemgetter_type) < 0) {\n        return -1;\n    }\n\n    state->methodcaller_type = PyType_FromModuleAndSpec(module, &methodcaller_type_spec, NULL);\n    if (state->methodcaller_type == NULL) {\n        return -1;\n    }\n    if (PyModule_AddType(module, (PyTypeObject *)state->methodcaller_type) < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n\n\nstatic struct PyModuleDef_Slot operator_slots[] = {\n    {Py_mod_exec, operator_exec},\n    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},\n    {0, NULL}\n};\n\nstatic int\noperator_traverse(PyObject *module, visitproc visit, void *arg)\n{\n    _operator_state *state = get_operator_state(module);\n    Py_VISIT(state->attrgetter_type);\n    Py_VISIT(state->itemgetter_type);\n    Py_VISIT(state->methodcaller_type);\n    return 0;\n}\n\nstatic int\noperator_clear(PyObject *module)\n{\n    _operator_state *state = get_operator_state(module);\n    Py_CLEAR(state->attrgetter_type);\n    Py_CLEAR(state->itemgetter_type);\n    Py_CLEAR(state->methodcaller_type);\n    return 0;\n}\n\nstatic void\noperator_free(void *module)\n{\n    operator_clear((PyObject *)module);\n}\n\nstatic struct PyModuleDef operatormodule = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = \"_operator\",\n    .m_doc = operator_doc,\n    .m_size = sizeof(_operator_state),\n    .m_methods = operator_methods,\n    .m_slots = operator_slots,\n    .m_traverse = operator_traverse,\n    .m_clear = operator_clear,\n    .m_free = operator_free,\n};\n\nPyMODINIT_FUNC\nPyInit__operator(void)\n{\n    return PyModuleDef_Init(&operatormodule);\n}\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-null-dereference",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 6516,
                                       "gcc/analyzer/saved_diagnostic/snode": 575,
                                       "gcc/analyzer/saved_diagnostic/sval": "(const volatile unsigned char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 2},
                        "level": "warning",
                        "message": {"text": "dereference of NULL 'left'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_operator.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 770,
                                                                       "startColumn": 19,
                                                                       "endColumn": 26},
                                                            "contextRegion": {"startLine": 770,
                                                                              "snippet": {"text": "        result |= *left++ ^ *right++;\n"}}},
                                       "logicalLocations": [{"name": "_tscmp",
                                                             "fullyQualifiedName": "_tscmp",
                                                             "decoratedName": "_tscmp",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 570,
                                                                                                                                 "dst_idx": 572,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_operator.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 760,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 760,
                                                                                                                           "snippet": {"text": "    if (len_a == length) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_tscmp",
                                                                                                          "fullyQualifiedName": "_tscmp",
                                                                                                          "decoratedName": "_tscmp",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 570,
                                                                                                                                 "dst_idx": 572,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_operator.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 764,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 24},
                                                                                                         "contextRegion": {"startLine": 764,
                                                                                                                           "snippet": {"text": "    if (len_a != length) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_tscmp",
                                                                                                          "fullyQualifiedName": "_tscmp",
                                                                                                          "decoratedName": "_tscmp",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 572,
                                                                                                                                 "dst_idx": 574,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_operator.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 764,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 764,
                                                                                                                           "snippet": {"text": "    if (len_a != length) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_tscmp",
                                                                                                          "fullyQualifiedName": "_tscmp",
                                                                                                          "decoratedName": "_tscmp",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 572,
                                                                                                                                 "dst_idx": 574,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"logicalLocations": [{"name": "_tscmp",
                                                                                                          "fullyQualifiedName": "_tscmp",
                                                                                                          "decoratedName": "_tscmp",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 576,
                                                                                                                                 "dst_idx": 575,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_operator.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 769,
                                                                                                                    "startColumn": 15,
                                                                                                                    "endColumn": 25},
                                                                                                         "contextRegion": {"startLine": 769,
                                                                                                                           "snippet": {"text": "    for (i=0; i < length; i++) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_tscmp",
                                                                                                          "fullyQualifiedName": "_tscmp",
                                                                                                          "decoratedName": "_tscmp",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 576,
                                                                                                                                 "dst_idx": 575,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_operator.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 770,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 26},
                                                                                                         "contextRegion": {"startLine": 770,
                                                                                                                           "snippet": {"text": "        result |= *left++ ^ *right++;\n"}}},
                                                                                    "logicalLocations": [{"name": "_tscmp",
                                                                                                          "fullyQualifiedName": "_tscmp",
                                                                                                          "decoratedName": "_tscmp",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_operator.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 770,
                                                                                                                    "startColumn": 19,
                                                                                                                    "endColumn": 26},
                                                                                                         "contextRegion": {"startLine": 770,
                                                                                                                           "snippet": {"text": "        result |= *left++ ^ *right++;\n"}}},
                                                                                    "logicalLocations": [{"name": "_tscmp",
                                                                                                          "fullyQualifiedName": "_tscmp",
                                                                                                          "decoratedName": "_tscmp",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "dereference of NULL 'left'"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 7}]}]}]}]}]}
