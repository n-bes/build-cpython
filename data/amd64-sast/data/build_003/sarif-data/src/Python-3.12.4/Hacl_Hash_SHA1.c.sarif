{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-possible-null-argument",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-possible-null-argument"},
                                         {"id": "-Wanalyzer-possible-null-dereference",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-possible-null-dereference"}]}},
           "taxonomies": [{"name": "CWE",
                           "version": "4.7",
                           "organization": "MITRE",
                           "shortDescription": {"text": "The MITRE Common Weakness Enumeration"},
                           "taxa": [{"id": "690",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/690.html"}]}],
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}},
           "artifacts": [{"location": {"uri": "./Modules/_hacl/Hacl_Hash_SHA1.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/* MIT License\n *\n * Copyright (c) 2016-2022 INRIA, CMU and Microsoft Corporation\n * Copyright (c) 2022-2023 HACL* Contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n#include \"internal/Hacl_Hash_SHA1.h\"\n\nstatic uint32_t _h0[5U] = { 0x67452301U, 0xefcdab89U, 0x98badcfeU, 0x10325476U, 0xc3d2e1f0U };\n\nvoid Hacl_Hash_SHA1_init(uint32_t *s)\n{\n  KRML_MAYBE_FOR5(i, 0U, 5U, 1U, s[i] = _h0[i];);\n}\n\nstatic void update(uint32_t *h, uint8_t *l)\n{\n  uint32_t ha = h[0U];\n  uint32_t hb = h[1U];\n  uint32_t hc = h[2U];\n  uint32_t hd = h[3U];\n  uint32_t he = h[4U];\n  uint32_t _w[80U] = { 0U };\n  for (uint32_t i = 0U; i < 80U; i++)\n  {\n    uint32_t v;\n    if (i < 16U)\n    {\n      uint8_t *b = l + i * 4U;\n      uint32_t u = load32_be(b);\n      v = u;\n    }\n    else\n    {\n      uint32_t wmit3 = _w[i - 3U];\n      uint32_t wmit8 = _w[i - 8U];\n      uint32_t wmit14 = _w[i - 14U];\n      uint32_t wmit16 = _w[i - 16U];\n      v = (wmit3 ^ (wmit8 ^ (wmit14 ^ wmit16))) << 1U | (wmit3 ^ (wmit8 ^ (wmit14 ^ wmit16))) >> 31U;\n    }\n    _w[i] = v;\n  }\n  for (uint32_t i = 0U; i < 80U; i++)\n  {\n    uint32_t _a = h[0U];\n    uint32_t _b = h[1U];\n    uint32_t _c = h[2U];\n    uint32_t _d = h[3U];\n    uint32_t _e = h[4U];\n    uint32_t wmit = _w[i];\n    uint32_t ite0;\n    if (i < 20U)\n    {\n      ite0 = (_b & _c) ^ (~_b & _d);\n    }\n    else if (39U < i && i < 60U)\n    {\n      ite0 = (_b & _c) ^ ((_b & _d) ^ (_c & _d));\n    }\n    else\n    {\n      ite0 = _b ^ (_c ^ _d);\n    }\n    uint32_t ite;\n    if (i < 20U)\n    {\n      ite = 0x5a827999U;\n    }\n    else if (i < 40U)\n    {\n      ite = 0x6ed9eba1U;\n    }\n    else if (i < 60U)\n    {\n      ite = 0x8f1bbcdcU;\n    }\n    else\n    {\n      ite = 0xca62c1d6U;\n    }\n    uint32_t _T = (_a << 5U | _a >> 27U) + ite0 + _e + ite + wmit;\n    h[0U] = _T;\n    h[1U] = _a;\n    h[2U] = _b << 30U | _b >> 2U;\n    h[3U] = _c;\n    h[4U] = _d;\n  }\n  for (uint32_t i = 0U; i < 80U; i++)\n  {\n    _w[i] = 0U;\n  }\n  uint32_t sta = h[0U];\n  uint32_t stb = h[1U];\n  uint32_t stc = h[2U];\n  uint32_t std = h[3U];\n  uint32_t ste = h[4U];\n  h[0U] = sta + ha;\n  h[1U] = stb + hb;\n  h[2U] = stc + hc;\n  h[3U] = std + hd;\n  h[4U] = ste + he;\n}\n\nstatic void pad(uint64_t len, uint8_t *dst)\n{\n  uint8_t *dst1 = dst;\n  dst1[0U] = 0x80U;\n  uint8_t *dst2 = dst + 1U;\n  for (uint32_t i = 0U; i < (128U - (9U + (uint32_t)(len % (uint64_t)64U))) % 64U; i++)\n  {\n    dst2[i] = 0U;\n  }\n  uint8_t *dst3 = dst + 1U + (128U - (9U + (uint32_t)(len % (uint64_t)64U))) % 64U;\n  store64_be(dst3, len << 3U);\n}\n\nvoid Hacl_Hash_SHA1_finish(uint32_t *s, uint8_t *dst)\n{\n  KRML_MAYBE_FOR5(i, 0U, 5U, 1U, store32_be(dst + i * 4U, s[i]););\n}\n\nvoid Hacl_Hash_SHA1_update_multi(uint32_t *s, uint8_t *blocks, uint32_t n_blocks)\n{\n  for (uint32_t i = 0U; i < n_blocks; i++)\n  {\n    uint32_t sz = 64U;\n    uint8_t *block = blocks + sz * i;\n    update(s, block);\n  }\n}\n\nvoid\nHacl_Hash_SHA1_update_last(uint32_t *s, uint64_t prev_len, uint8_t *input, uint32_t input_len)\n{\n  uint32_t blocks_n = input_len / 64U;\n  uint32_t blocks_len = blocks_n * 64U;\n  uint8_t *blocks = input;\n  uint32_t rest_len = input_len - blocks_len;\n  uint8_t *rest = input + blocks_len;\n  Hacl_Hash_SHA1_update_multi(s, blocks, blocks_n);\n  uint64_t total_input_len = prev_len + (uint64_t)input_len;\n  uint32_t pad_len = 1U + (128U - (9U + (uint32_t)(total_input_len % (uint64_t)64U))) % 64U + 8U;\n  uint32_t tmp_len = rest_len + pad_len;\n  uint8_t tmp_twoblocks[128U] = { 0U };\n  uint8_t *tmp = tmp_twoblocks;\n  uint8_t *tmp_rest = tmp;\n  uint8_t *tmp_pad = tmp + rest_len;\n  memcpy(tmp_rest, rest, rest_len * sizeof (uint8_t));\n  pad(total_input_len, tmp_pad);\n  Hacl_Hash_SHA1_update_multi(s, tmp, tmp_len / 64U);\n}\n\nvoid Hacl_Hash_SHA1_hash_oneshot(uint8_t *output, uint8_t *input, uint32_t input_len)\n{\n  uint32_t s[5U] = { 0x67452301U, 0xefcdab89U, 0x98badcfeU, 0x10325476U, 0xc3d2e1f0U };\n  uint32_t blocks_n0 = input_len / 64U;\n  uint32_t blocks_n1;\n  if (input_len % 64U == 0U && blocks_n0 > 0U)\n  {\n    blocks_n1 = blocks_n0 - 1U;\n  }\n  else\n  {\n    blocks_n1 = blocks_n0;\n  }\n  uint32_t blocks_len0 = blocks_n1 * 64U;\n  uint8_t *blocks0 = input;\n  uint32_t rest_len0 = input_len - blocks_len0;\n  uint8_t *rest0 = input + blocks_len0;\n  uint32_t blocks_n = blocks_n1;\n  uint32_t blocks_len = blocks_len0;\n  uint8_t *blocks = blocks0;\n  uint32_t rest_len = rest_len0;\n  uint8_t *rest = rest0;\n  Hacl_Hash_SHA1_update_multi(s, blocks, blocks_n);\n  Hacl_Hash_SHA1_update_last(s, (uint64_t)blocks_len, rest, rest_len);\n  Hacl_Hash_SHA1_finish(s, output);\n}\n\nHacl_Streaming_MD_state_32 *Hacl_Hash_SHA1_malloc(void)\n{\n  uint8_t *buf = (uint8_t *)KRML_HOST_CALLOC(64U, sizeof (uint8_t));\n  uint32_t *block_state = (uint32_t *)KRML_HOST_CALLOC(5U, sizeof (uint32_t));\n  Hacl_Streaming_MD_state_32\n  s = { .block_state = block_state, .buf = buf, .total_len = (uint64_t)0U };\n  Hacl_Streaming_MD_state_32\n  *p = (Hacl_Streaming_MD_state_32 *)KRML_HOST_MALLOC(sizeof (Hacl_Streaming_MD_state_32));\n  p[0U] = s;\n  Hacl_Hash_SHA1_init(block_state);\n  return p;\n}\n\nvoid Hacl_Hash_SHA1_reset(Hacl_Streaming_MD_state_32 *state)\n{\n  Hacl_Streaming_MD_state_32 scrut = *state;\n  uint8_t *buf = scrut.buf;\n  uint32_t *block_state = scrut.block_state;\n  Hacl_Hash_SHA1_init(block_state);\n  Hacl_Streaming_MD_state_32\n  tmp = { .block_state = block_state, .buf = buf, .total_len = (uint64_t)0U };\n  state[0U] = tmp;\n}\n\n/**\n0 = success, 1 = max length exceeded\n*/\nHacl_Streaming_Types_error_code\nHacl_Hash_SHA1_update(Hacl_Streaming_MD_state_32 *state, uint8_t *chunk, uint32_t chunk_len)\n{\n  Hacl_Streaming_MD_state_32 s = *state;\n  uint64_t total_len = s.total_len;\n  if ((uint64_t)chunk_len > 2305843009213693951ULL - total_len)\n  {\n    return Hacl_Streaming_Types_MaximumLengthExceeded;\n  }\n  uint32_t sz;\n  if (total_len % (uint64_t)64U == 0ULL && total_len > 0ULL)\n  {\n    sz = 64U;\n  }\n  else\n  {\n    sz = (uint32_t)(total_len % (uint64_t)64U);\n  }\n  if (chunk_len <= 64U - sz)\n  {\n    Hacl_Streaming_MD_state_32 s1 = *state;\n    uint32_t *block_state1 = s1.block_state;\n    uint8_t *buf = s1.buf;\n    uint64_t total_len1 = s1.total_len;\n    uint32_t sz1;\n    if (total_len1 % (uint64_t)64U == 0ULL && total_len1 > 0ULL)\n    {\n      sz1 = 64U;\n    }\n    else\n    {\n      sz1 = (uint32_t)(total_len1 % (uint64_t)64U);\n    }\n    uint8_t *buf2 = buf + sz1;\n    memcpy(buf2, chunk, chunk_len * sizeof (uint8_t));\n    uint64_t total_len2 = total_len1 + (uint64_t)chunk_len;\n    *state\n    =\n      (\n        (Hacl_Streaming_MD_state_32){\n          .block_state = block_state1,\n          .buf = buf,\n          .total_len = total_len2\n        }\n      );\n  }\n  else if (sz == 0U)\n  {\n    Hacl_Streaming_MD_state_32 s1 = *state;\n    uint32_t *block_state1 = s1.block_state;\n    uint8_t *buf = s1.buf;\n    uint64_t total_len1 = s1.total_len;\n    uint32_t sz1;\n    if (total_len1 % (uint64_t)64U == 0ULL && total_len1 > 0ULL)\n    {\n      sz1 = 64U;\n    }\n    else\n    {\n      sz1 = (uint32_t)(total_len1 % (uint64_t)64U);\n    }\n    if (!(sz1 == 0U))\n    {\n      Hacl_Hash_SHA1_update_multi(block_state1, buf, 1U);\n    }\n    uint32_t ite;\n    if ((uint64_t)chunk_len % (uint64_t)64U == 0ULL && (uint64_t)chunk_len > 0ULL)\n    {\n      ite = 64U;\n    }\n    else\n    {\n      ite = (uint32_t)((uint64_t)chunk_len % (uint64_t)64U);\n    }\n    uint32_t n_blocks = (chunk_len - ite) / 64U;\n    uint32_t data1_len = n_blocks * 64U;\n    uint32_t data2_len = chunk_len - data1_len;\n    uint8_t *data1 = chunk;\n    uint8_t *data2 = chunk + data1_len;\n    Hacl_Hash_SHA1_update_multi(block_state1, data1, data1_len / 64U);\n    uint8_t *dst = buf;\n    memcpy(dst, data2, data2_len * sizeof (uint8_t));\n    *state\n    =\n      (\n        (Hacl_Streaming_MD_state_32){\n          .block_state = block_state1,\n          .buf = buf,\n          .total_len = total_len1 + (uint64_t)chunk_len\n        }\n      );\n  }\n  else\n  {\n    uint32_t diff = 64U - sz;\n    uint8_t *chunk1 = chunk;\n    uint8_t *chunk2 = chunk + diff;\n    Hacl_Streaming_MD_state_32 s1 = *state;\n    uint32_t *block_state10 = s1.block_state;\n    uint8_t *buf0 = s1.buf;\n    uint64_t total_len10 = s1.total_len;\n    uint32_t sz10;\n    if (total_len10 % (uint64_t)64U == 0ULL && total_len10 > 0ULL)\n    {\n      sz10 = 64U;\n    }\n    else\n    {\n      sz10 = (uint32_t)(total_len10 % (uint64_t)64U);\n    }\n    uint8_t *buf2 = buf0 + sz10;\n    memcpy(buf2, chunk1, diff * sizeof (uint8_t));\n    uint64_t total_len2 = total_len10 + (uint64_t)diff;\n    *state\n    =\n      (\n        (Hacl_Streaming_MD_state_32){\n          .block_state = block_state10,\n          .buf = buf0,\n          .total_len = total_len2\n        }\n      );\n    Hacl_Streaming_MD_state_32 s10 = *state;\n    uint32_t *block_state1 = s10.block_state;\n    uint8_t *buf = s10.buf;\n    uint64_t total_len1 = s10.total_len;\n    uint32_t sz1;\n    if (total_len1 % (uint64_t)64U == 0ULL && total_len1 > 0ULL)\n    {\n      sz1 = 64U;\n    }\n    else\n    {\n      sz1 = (uint32_t)(total_len1 % (uint64_t)64U);\n    }\n    if (!(sz1 == 0U))\n    {\n      Hacl_Hash_SHA1_update_multi(block_state1, buf, 1U);\n    }\n    uint32_t ite;\n    if\n    ((uint64_t)(chunk_len - diff) % (uint64_t)64U == 0ULL && (uint64_t)(chunk_len - diff) > 0ULL)\n    {\n      ite = 64U;\n    }\n    else\n    {\n      ite = (uint32_t)((uint64_t)(chunk_len - diff) % (uint64_t)64U);\n    }\n    uint32_t n_blocks = (chunk_len - diff - ite) / 64U;\n    uint32_t data1_len = n_blocks * 64U;\n    uint32_t data2_len = chunk_len - diff - data1_len;\n    uint8_t *data1 = chunk2;\n    uint8_t *data2 = chunk2 + data1_len;\n    Hacl_Hash_SHA1_update_multi(block_state1, data1, data1_len / 64U);\n    uint8_t *dst = buf;\n    memcpy(dst, data2, data2_len * sizeof (uint8_t));\n    *state\n    =\n      (\n        (Hacl_Streaming_MD_state_32){\n          .block_state = block_state1,\n          .buf = buf,\n          .total_len = total_len1 + (uint64_t)(chunk_len - diff)\n        }\n      );\n  }\n  return Hacl_Streaming_Types_Success;\n}\n\nvoid Hacl_Hash_SHA1_digest(Hacl_Streaming_MD_state_32 *state, uint8_t *output)\n{\n  Hacl_Streaming_MD_state_32 scrut = *state;\n  uint32_t *block_state = scrut.block_state;\n  uint8_t *buf_ = scrut.buf;\n  uint64_t total_len = scrut.total_len;\n  uint32_t r;\n  if (total_len % (uint64_t)64U == 0ULL && total_len > 0ULL)\n  {\n    r = 64U;\n  }\n  else\n  {\n    r = (uint32_t)(total_len % (uint64_t)64U);\n  }\n  uint8_t *buf_1 = buf_;\n  uint32_t tmp_block_state[5U] = { 0U };\n  memcpy(tmp_block_state, block_state, 5U * sizeof (uint32_t));\n  uint32_t ite;\n  if (r % 64U == 0U && r > 0U)\n  {\n    ite = 64U;\n  }\n  else\n  {\n    ite = r % 64U;\n  }\n  uint8_t *buf_last = buf_1 + r - ite;\n  uint8_t *buf_multi = buf_1;\n  Hacl_Hash_SHA1_update_multi(tmp_block_state, buf_multi, 0U);\n  uint64_t prev_len_last = total_len - (uint64_t)r;\n  Hacl_Hash_SHA1_update_last(tmp_block_state, prev_len_last, buf_last, r);\n  Hacl_Hash_SHA1_finish(tmp_block_state, output);\n}\n\nvoid Hacl_Hash_SHA1_free(Hacl_Streaming_MD_state_32 *state)\n{\n  Hacl_Streaming_MD_state_32 scrut = *state;\n  uint8_t *buf = scrut.buf;\n  uint32_t *block_state = scrut.block_state;\n  KRML_HOST_FREE(block_state);\n  KRML_HOST_FREE(buf);\n  KRML_HOST_FREE(state);\n}\n\nHacl_Streaming_MD_state_32 *Hacl_Hash_SHA1_copy(Hacl_Streaming_MD_state_32 *state)\n{\n  Hacl_Streaming_MD_state_32 scrut = *state;\n  uint32_t *block_state0 = scrut.block_state;\n  uint8_t *buf0 = scrut.buf;\n  uint64_t total_len0 = scrut.total_len;\n  uint8_t *buf = (uint8_t *)KRML_HOST_CALLOC(64U, sizeof (uint8_t));\n  memcpy(buf, buf0, 64U * sizeof (uint8_t));\n  uint32_t *block_state = (uint32_t *)KRML_HOST_CALLOC(5U, sizeof (uint32_t));\n  memcpy(block_state, block_state0, 5U * sizeof (uint32_t));\n  Hacl_Streaming_MD_state_32\n  s = { .block_state = block_state, .buf = buf, .total_len = total_len0 };\n  Hacl_Streaming_MD_state_32\n  *p = (Hacl_Streaming_MD_state_32 *)KRML_HOST_MALLOC(sizeof (Hacl_Streaming_MD_state_32));\n  p[0U] = s;\n  return p;\n}\n\nvoid Hacl_Hash_SHA1_hash(uint8_t *output, uint8_t *input, uint32_t input_len)\n{\n  Hacl_Hash_SHA1_hash_oneshot(output, input, input_len);\n}\n\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-possible-null-argument",
                        "taxa": [{"id": "690",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 1326,
                                       "gcc/analyzer/saved_diagnostic/snode": 5,
                                       "gcc/analyzer/saved_diagnostic/sval": "&HEAP_ALLOCATED_REGION(861)",
                                       "gcc/analyzer/saved_diagnostic/state": "unchecked ({free})",
                                       "gcc/analyzer/saved_diagnostic/idx": 0},
                        "level": "warning",
                        "message": {"text": "use of possibly-NULL 'buf' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_hacl/Hacl_Hash_SHA1.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 448,
                                                                       "startColumn": 3,
                                                                       "endColumn": 44},
                                                            "contextRegion": {"startLine": 448,
                                                                              "snippet": {"text": "  memcpy(buf, buf0, 64U * sizeof (uint8_t));\n"}}},
                                       "logicalLocations": [{"name": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                             "fullyQualifiedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                             "decoratedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_hacl/Hacl_Hash_SHA1.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 447,
                                                                                                                    "startColumn": 29,
                                                                                                                    "endColumn": 68},
                                                                                                         "contextRegion": {"startLine": 447,
                                                                                                                           "snippet": {"text": "  uint8_t *buf = (uint8_t *)KRML_HOST_CALLOC(64U, sizeof (uint8_t));\n"}}},
                                                                                    "logicalLocations": [{"name": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "fullyQualifiedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "decoratedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "this call could return NULL"}},
                                                                       "kinds": ["acquire",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_hacl/Hacl_Hash_SHA1.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 448,
                                                                                                                    "startColumn": 3,
                                                                                                                    "endColumn": 44},
                                                                                                         "contextRegion": {"startLine": 448,
                                                                                                                           "snippet": {"text": "  memcpy(buf, buf0, 64U * sizeof (uint8_t));\n"}}},
                                                                                    "logicalLocations": [{"name": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "fullyQualifiedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "decoratedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('buf') from (1) could be NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2}]}]}],
                        "relatedLocations": [{"message": {"text": "argument 1 of '__builtin_memcpy' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-possible-null-argument",
                        "taxa": [{"id": "690",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 1328,
                                       "gcc/analyzer/saved_diagnostic/snode": 5,
                                       "gcc/analyzer/saved_diagnostic/sval": "&HEAP_ALLOCATED_REGION(874)",
                                       "gcc/analyzer/saved_diagnostic/state": "unchecked ({free})",
                                       "gcc/analyzer/saved_diagnostic/idx": 1},
                        "level": "warning",
                        "message": {"text": "use of possibly-NULL 'block_state' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_hacl/Hacl_Hash_SHA1.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 450,
                                                                       "startColumn": 3,
                                                                       "endColumn": 60},
                                                            "contextRegion": {"startLine": 450,
                                                                              "snippet": {"text": "  memcpy(block_state, block_state0, 5U * sizeof (uint32_t));\n"}}},
                                       "logicalLocations": [{"name": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                             "fullyQualifiedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                             "decoratedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_hacl/Hacl_Hash_SHA1.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 449,
                                                                                                                    "startColumn": 39,
                                                                                                                    "endColumn": 78},
                                                                                                         "contextRegion": {"startLine": 449,
                                                                                                                           "snippet": {"text": "  uint32_t *block_state = (uint32_t *)KRML_HOST_CALLOC(5U, sizeof (uint32_t));\n"}}},
                                                                                    "logicalLocations": [{"name": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "fullyQualifiedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "decoratedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "this call could return NULL"}},
                                                                       "kinds": ["acquire",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_hacl/Hacl_Hash_SHA1.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 450,
                                                                                                                    "startColumn": 3,
                                                                                                                    "endColumn": 60},
                                                                                                         "contextRegion": {"startLine": 450,
                                                                                                                           "snippet": {"text": "  memcpy(block_state, block_state0, 5U * sizeof (uint32_t));\n"}}},
                                                                                    "logicalLocations": [{"name": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "fullyQualifiedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "decoratedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('block_state') from (1) could be NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2}]}]}],
                        "relatedLocations": [{"message": {"text": "argument 1 of '__builtin_memcpy' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-possible-null-dereference",
                        "taxa": [{"id": "690",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 1330,
                                       "gcc/analyzer/saved_diagnostic/snode": 5,
                                       "gcc/analyzer/saved_diagnostic/sval": "&HEAP_ALLOCATED_REGION(887)",
                                       "gcc/analyzer/saved_diagnostic/state": "unchecked ({free})",
                                       "gcc/analyzer/saved_diagnostic/idx": 2},
                        "level": "warning",
                        "message": {"text": "dereference of possibly-NULL 'p'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_hacl/Hacl_Hash_SHA1.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 455,
                                                                       "startColumn": 3,
                                                                       "endColumn": 12},
                                                            "contextRegion": {"startLine": 455,
                                                                              "snippet": {"text": "  p[0U] = s;\n"}}},
                                       "logicalLocations": [{"name": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                             "fullyQualifiedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                             "decoratedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_hacl/Hacl_Hash_SHA1.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 454,
                                                                                                                    "startColumn": 38,
                                                                                                                    "endColumn": 91},
                                                                                                         "contextRegion": {"startLine": 454,
                                                                                                                           "snippet": {"text": "  *p = (Hacl_Streaming_MD_state_32 *)KRML_HOST_MALLOC(sizeof (Hacl_Streaming_MD_state_32));\n"}}},
                                                                                    "logicalLocations": [{"name": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "fullyQualifiedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "decoratedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "this call could return NULL"}},
                                                                       "kinds": ["acquire",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_hacl/Hacl_Hash_SHA1.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 455,
                                                                                                                    "startColumn": 3,
                                                                                                                    "endColumn": 12},
                                                                                                         "contextRegion": {"startLine": 455,
                                                                                                                           "snippet": {"text": "  p[0U] = s;\n"}}},
                                                                                    "logicalLocations": [{"name": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "fullyQualifiedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "decoratedName": "python_hashlib_Hacl_Hash_SHA1_copy",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'p' could be NULL: unchecked value from (1)"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2}]}]}]}]}]}
