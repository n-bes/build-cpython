{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-null-dereference",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-dereference"}]}},
           "taxonomies": [{"name": "CWE",
                           "version": "4.7",
                           "organization": "MITRE",
                           "shortDescription": {"text": "The MITRE Common Weakness Enumeration"},
                           "taxa": [{"id": "476",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}],
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}},
           "artifacts": [{"location": {"uri": "./Include/object.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_OBJECT_H\n#define Py_OBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Object and type object interface */\n\n/*\nObjects are structures allocated on the heap.  Special rules apply to\nthe use of objects to ensure they are properly garbage-collected.\nObjects are never allocated statically or on the stack; they must be\naccessed through special macros and functions only.  (Type objects are\nexceptions to the first rule; the standard types are represented by\nstatically initialized type objects, although work on type/class unification\nfor Python 2.2 made it possible to have heap-allocated type objects too).\n\nAn object has a 'reference count' that is increased or decreased when a\npointer to the object is copied or deleted; when the reference count\nreaches zero there are no references to the object left and it can be\nremoved from the heap.\n\nAn object has a 'type' that determines what it represents and what kind\nof data it contains.  An object's type is fixed when it is created.\nTypes themselves are represented as objects; an object contains a\npointer to the corresponding type object.  The type itself has a type\npointer pointing to the object representing the type 'type', which\ncontains a pointer to itself!.\n\nObjects do not float around in memory; once allocated an object keeps\nthe same size and address.  Objects that must hold variable-size data\ncan contain pointers to variable-size parts of the object.  Not all\nobjects of the same type have the same size; but the size cannot change\nafter allocation.  (These restrictions are made so a reference to an\nobject can be simply a pointer -- moving an object would require\nupdating all the pointers, and changing an object's size would require\nmoving it if there was another object right next to it.)\n\nObjects are always accessed through pointers of the type 'PyObject *'.\nThe type 'PyObject' is a structure that only contains the reference count\nand the type pointer.  The actual memory allocated for an object\ncontains other data that can only be accessed after casting the pointer\nto a pointer to a longer structure type.  This longer type must start\nwith the reference count and type fields; the macro PyObject_HEAD should be\nused for this (to accommodate for future changes).  The implementation\nof a particular object type can cast the object pointer to the proper\ntype and back.\n\nA standard interface exists for objects that contain an array of items\nwhose size is determined when the object is allocated.\n*/\n\n#include \"pystats.h\"\n\n/* Py_DEBUG implies Py_REF_DEBUG. */\n#if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)\n#  define Py_REF_DEBUG\n#endif\n\n#if defined(Py_LIMITED_API) && defined(Py_TRACE_REFS)\n#  error Py_LIMITED_API is incompatible with Py_TRACE_REFS\n#endif\n\n#ifdef Py_TRACE_REFS\n/* Define pointers to support a doubly-linked list of all live heap objects. */\n#define _PyObject_HEAD_EXTRA            \\\n    PyObject *_ob_next;           \\\n    PyObject *_ob_prev;\n\n#define _PyObject_EXTRA_INIT _Py_NULL, _Py_NULL,\n\n#else\n#  define _PyObject_HEAD_EXTRA\n#  define _PyObject_EXTRA_INIT\n#endif\n\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   PyObject ob_base;\n\n/*\nImmortalization:\n\nThe following indicates the immortalization strategy depending on the amount\nof available bits in the reference count field. All strategies are backwards\ncompatible but the specific reference count value or immortalization check\nmight change depending on the specializations for the underlying system.\n\nProper deallocation of immortal instances requires distinguishing between\nstatically allocated immortal instances vs those promoted by the runtime to be\nimmortal. The latter should be the only instances that require\ncleanup during runtime finalization.\n*/\n\n#if SIZEOF_VOID_P > 4\n/*\nIn 64+ bit systems, an object will be marked as immortal by setting all of the\nlower 32 bits of the reference count field, which is equal to: 0xFFFFFFFF\n\nUsing the lower 32 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases will use saturated arithmetic, taking advantage of\nhaving all the lower 32 bits set, which will avoid the reference count to go\nbeyond the refcount limit. Immortality checks for reference count decreases will\nbe done by checking the bit sign flag in the lower 32 bits.\n*/\n#define _Py_IMMORTAL_REFCNT UINT_MAX\n\n#else\n/*\nIn 32 bit systems, an object will be marked as immortal by setting all of the\nlower 30 bits of the reference count field, which is equal to: 0x3FFFFFFF\n\nUsing the lower 30 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases and decreases will first go through an immortality\ncheck by comparing the reference count field to the immortality reference count.\n*/\n#define _Py_IMMORTAL_REFCNT (UINT_MAX >> 2)\n#endif\n\n// Make all internal uses of PyObject_HEAD_INIT immortal while preserving the\n// C-API expectation that the refcnt will be set to 1.\n#ifdef Py_BUILD_CORE\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        _PyObject_EXTRA_INIT        \\\n        { _Py_IMMORTAL_REFCNT },    \\\n        (type)                      \\\n    },\n#else\n#define PyObject_HEAD_INIT(type) \\\n    {                            \\\n        _PyObject_EXTRA_INIT     \\\n        { 1 },                   \\\n        (type)                   \\\n    },\n#endif /* Py_BUILD_CORE */\n\n#define PyVarObject_HEAD_INIT(type, size) \\\n    {                                     \\\n        PyObject_HEAD_INIT(type)          \\\n        (size)                            \\\n    },\n\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD      PyVarObject ob_base;\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\nstruct _object {\n    _PyObject_HEAD_EXTRA\n\n#if (defined(__GNUC__) || defined(__clang__)) \\\n        && !(defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L)\n    // On C99 and older, anonymous union is a GCC and clang extension\n    __extension__\n#endif\n#ifdef _MSC_VER\n    // Ignore MSC warning C4201: \"nonstandard extension used:\n    // nameless struct/union\"\n    __pragma(warning(push))\n    __pragma(warning(disable: 4201))\n#endif\n    union {\n       Py_ssize_t ob_refcnt;\n#if SIZEOF_VOID_P > 4\n       PY_UINT32_T ob_refcnt_split[2];\n#endif\n    };\n#ifdef _MSC_VER\n    __pragma(warning(pop))\n#endif\n\n    PyTypeObject *ob_type;\n};\n\n/* Cast argument to PyObject* type. */\n#define _PyObject_CAST(op) _Py_CAST(PyObject*, (op))\n\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n/* Cast argument to PyVarObject* type. */\n#define _PyVarObject_CAST(op) _Py_CAST(PyVarObject*, (op))\n\n\n// Test if the 'x' object is the 'y' object, the same as \"x is y\" in Python.\nPyAPI_FUNC(int) Py_Is(PyObject *x, PyObject *y);\n#define Py_Is(x, y) ((x) == (y))\n\n\nstatic inline Py_ssize_t Py_REFCNT(PyObject *ob) {\n    return ob->ob_refcnt;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_REFCNT(ob) Py_REFCNT(_PyObject_CAST(ob))\n#endif\n\n\n// bpo-39573: The Py_SET_TYPE() function must be used to set an object type.\nstatic inline PyTypeObject* Py_TYPE(PyObject *ob) {\n    return ob->ob_type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_TYPE(ob) Py_TYPE(_PyObject_CAST(ob))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyLong_Type;\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n\n// bpo-39573: The Py_SET_SIZE() function must be used to set an object size.\nstatic inline Py_ssize_t Py_SIZE(PyObject *ob) {\n    assert(ob->ob_type != &PyLong_Type);\n    assert(ob->ob_type != &PyBool_Type);\n    return  _PyVarObject_CAST(ob)->ob_size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SIZE(ob) Py_SIZE(_PyObject_CAST(ob))\n#endif\n\nstatic inline Py_ALWAYS_INLINE int _Py_IsImmortal(PyObject *op)\n{\n#if SIZEOF_VOID_P > 4\n    return _Py_CAST(PY_INT32_T, op->ob_refcnt) < 0;\n#else\n    return op->ob_refcnt == _Py_IMMORTAL_REFCNT;\n#endif\n}\n#define _Py_IsImmortal(op) _Py_IsImmortal(_PyObject_CAST(op))\n\nstatic inline int Py_IS_TYPE(PyObject *ob, PyTypeObject *type) {\n    return Py_TYPE(ob) == type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_IS_TYPE(ob, type) Py_IS_TYPE(_PyObject_CAST(ob), (type))\n#endif\n\n\nstatic inline void Py_SET_REFCNT(PyObject *ob, Py_ssize_t refcnt) {\n    // This immortal check is for code that is unaware of immortal objects.\n    // The runtime tracks these objects and we should avoid as much\n    // as possible having extensions inadvertently change the refcnt\n    // of an immortalized object.\n    if (_Py_IsImmortal(ob)) {\n        return;\n    }\n    ob->ob_refcnt = refcnt;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_REFCNT(ob, refcnt) Py_SET_REFCNT(_PyObject_CAST(ob), (refcnt))\n#endif\n\n\nstatic inline void Py_SET_TYPE(PyObject *ob, PyTypeObject *type) {\n    ob->ob_type = type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_TYPE(ob, type) Py_SET_TYPE(_PyObject_CAST(ob), type)\n#endif\n\nstatic inline void Py_SET_SIZE(PyVarObject *ob, Py_ssize_t size) {\n    assert(ob->ob_base.ob_type != &PyLong_Type);\n    assert(ob->ob_base.ob_type != &PyBool_Type);\n    ob->ob_size = size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_SIZE(ob, size) Py_SET_SIZE(_PyVarObject_CAST(ob), (size))\n#endif\n\n\n/*\nType objects contain a string containing the type name (to help somewhat\nin debugging), the allocation parameters (see PyObject_New() and\nPyObject_NewVar()),\nand methods for accessing objects of the type.  Methods are optional, a\nnil pointer meaning that particular kind of access is not available for\nthis type.  The Py_DECREF() macro uses the tp_dealloc method without\nchecking for a nil pointer; it should always be implemented except if\nthe implementation can guarantee that the reference count will never\nreach zero (e.g., for statically allocated type objects).\n\nNB: the methods for certain type groups are now contained in separate\nmethod blocks.\n*/\n\ntypedef PyObject * (*unaryfunc)(PyObject *);\ntypedef PyObject * (*binaryfunc)(PyObject *, PyObject *);\ntypedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);\ntypedef int (*inquiry)(PyObject *);\ntypedef Py_ssize_t (*lenfunc)(PyObject *);\ntypedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);\ntypedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);\ntypedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);\ntypedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);\ntypedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);\n\ntypedef int (*objobjproc)(PyObject *, PyObject *);\ntypedef int (*visitproc)(PyObject *, void *);\ntypedef int (*traverseproc)(PyObject *, visitproc, void *);\n\n\ntypedef void (*freefunc)(void *);\ntypedef void (*destructor)(PyObject *);\ntypedef PyObject *(*getattrfunc)(PyObject *, char *);\ntypedef PyObject *(*getattrofunc)(PyObject *, PyObject *);\ntypedef int (*setattrfunc)(PyObject *, char *, PyObject *);\ntypedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*reprfunc)(PyObject *);\ntypedef Py_hash_t (*hashfunc)(PyObject *);\ntypedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);\ntypedef PyObject *(*getiterfunc) (PyObject *);\ntypedef PyObject *(*iternextfunc) (PyObject *);\ntypedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*initproc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*newfunc)(PyTypeObject *, PyObject *, PyObject *);\ntypedef PyObject *(*allocfunc)(PyTypeObject *, Py_ssize_t);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030c0000 // 3.12\ntypedef PyObject *(*vectorcallfunc)(PyObject *callable, PyObject *const *args,\n                                    size_t nargsf, PyObject *kwnames);\n#endif\n\ntypedef struct{\n    int slot;    /* slot id, see below */\n    void *pfunc; /* function pointer */\n} PyType_Slot;\n\ntypedef struct{\n    const char* name;\n    int basicsize;\n    int itemsize;\n    unsigned int flags;\n    PyType_Slot *slots; /* terminated by slot==0. */\n} PyType_Spec;\n\nPyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000\nPyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);\nPyAPI_FUNC(PyObject *) PyType_GetModule(PyTypeObject *);\nPyAPI_FUNC(void *) PyType_GetModuleState(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000\nPyAPI_FUNC(PyObject *) PyType_GetName(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GetQualName(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\nPyAPI_FUNC(PyObject *) PyType_FromMetaclass(PyTypeObject*, PyObject*, PyType_Spec*, PyObject*);\nPyAPI_FUNC(void *) PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls);\nPyAPI_FUNC(Py_ssize_t) PyType_GetTypeDataSize(PyTypeObject *cls);\n#endif\n\n/* Generic type check */\nPyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);\n\nstatic inline int PyObject_TypeCheck(PyObject *ob, PyTypeObject *type) {\n    return Py_IS_TYPE(ob, type) || PyType_IsSubtype(Py_TYPE(ob), type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyObject_TypeCheck(ob, type) PyObject_TypeCheck(_PyObject_CAST(ob), (type))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */\nPyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */\nPyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */\n\nPyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);\n\nPyAPI_FUNC(int) PyType_Ready(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,\n                                               PyObject *, PyObject *);\nPyAPI_FUNC(unsigned int) PyType_ClearCache(void);\nPyAPI_FUNC(void) PyType_Modified(PyTypeObject *);\n\n/* Generic operations on objects */\nPyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);\nPyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);\nPyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);\nPyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);\n#endif\nPyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);\nPyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);\nPyAPI_FUNC(int) PyObject_IsTrue(PyObject *);\nPyAPI_FUNC(int) PyObject_Not(PyObject *);\nPyAPI_FUNC(int) PyCallable_Check(PyObject *);\nPyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);\n\n/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a\n   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),\n   returning the names of the current locals.  In this case, if there are\n   no current locals, NULL is returned, and PyErr_Occurred() is false.\n*/\nPyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);\n\n/* Pickle support. */\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyObject_GetState(PyObject *);\n#endif\n\n\n/* Helpers for printing recursive container types */\nPyAPI_FUNC(int) Py_ReprEnter(PyObject *);\nPyAPI_FUNC(void) Py_ReprLeave(PyObject *);\n\n/* Flag bits for printing: */\n#define Py_PRINT_RAW    1       /* No string quotes etc. */\n\n/*\nType flags (tp_flags)\n\nThese flags are used to change expected features and behavior for a\nparticular type.\n\nArbitration of the flag bit positions will need to be coordinated among\nall extension writers who publicly release their extensions (this will\nbe fewer than you might expect!).\n\nMost flags were removed as of Python 3.0 to make room for new flags.  (Some\nflags are not for backwards compatibility but to indicate the presence of an\noptional feature; these flags remain of course.)\n\nType definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.\n\nCode can use PyType_HasFeature(type_ob, flag_value) to test whether the\ngiven type object has a specified feature.\n*/\n\n#ifndef Py_LIMITED_API\n\n/* Track types initialized using _PyStaticType_InitBuiltin(). */\n#define _Py_TPFLAGS_STATIC_BUILTIN (1 << 1)\n\n/* Placement of weakref pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_weaklistoffset.\n */\n#define Py_TPFLAGS_MANAGED_WEAKREF (1 << 3)\n\n/* Placement of dict (and values) pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_dictoffset.\n */\n#define Py_TPFLAGS_MANAGED_DICT (1 << 4)\n\n#define Py_TPFLAGS_PREHEADER (Py_TPFLAGS_MANAGED_WEAKREF | Py_TPFLAGS_MANAGED_DICT)\n\n/* Set if instances of the type object are treated as sequences for pattern matching */\n#define Py_TPFLAGS_SEQUENCE (1 << 5)\n/* Set if instances of the type object are treated as mappings for pattern matching */\n#define Py_TPFLAGS_MAPPING (1 << 6)\n#endif\n\n/* Disallow creating instances of the type: set tp_new to NULL and don't create\n * the \"__new__\" key in the type dictionary. */\n#define Py_TPFLAGS_DISALLOW_INSTANTIATION (1UL << 7)\n\n/* Set if the type object is immutable: type attributes cannot be set nor deleted */\n#define Py_TPFLAGS_IMMUTABLETYPE (1UL << 8)\n\n/* Set if the type object is dynamically allocated */\n#define Py_TPFLAGS_HEAPTYPE (1UL << 9)\n\n/* Set if the type allows subclassing */\n#define Py_TPFLAGS_BASETYPE (1UL << 10)\n\n/* Set if the type implements the vectorcall protocol (PEP 590) */\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\n#define Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)\n#ifndef Py_LIMITED_API\n// Backwards compatibility alias for API that was provisional in Python 3.8\n#define _Py_TPFLAGS_HAVE_VECTORCALL Py_TPFLAGS_HAVE_VECTORCALL\n#endif\n#endif\n\n/* Set if the type is 'ready' -- fully initialized */\n#define Py_TPFLAGS_READY (1UL << 12)\n\n/* Set while the type is being 'readied', to prevent recursive ready calls */\n#define Py_TPFLAGS_READYING (1UL << 13)\n\n/* Objects support garbage collection (see objimpl.h) */\n#define Py_TPFLAGS_HAVE_GC (1UL << 14)\n\n/* These two bits are preserved for Stackless Python, next after this is 17 */\n#ifdef STACKLESS\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)\n#else\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0\n#endif\n\n/* Objects behave like an unbound method */\n#define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)\n\n/* Object has up-to-date type attribute cache */\n#define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)\n\n/* Type is abstract and cannot be instantiated */\n#define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)\n\n// This undocumented flag gives certain built-ins their unique pattern-matching\n// behavior, which allows a single positional subpattern to match against the\n// subject itself (rather than a mapped attribute on it):\n#define _Py_TPFLAGS_MATCH_SELF (1UL << 22)\n\n/* Items (ob_size*tp_itemsize) are found at the end of an instance's memory */\n#define Py_TPFLAGS_ITEMS_AT_END (1UL << 23)\n\n/* These flags are used to determine if a type is a subclass. */\n#define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)\n#define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)\n#define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)\n#define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)\n#define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)\n#define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)\n#define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)\n#define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)\n\n#define Py_TPFLAGS_DEFAULT  ( \\\n                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \\\n                0)\n\n/* NOTE: Some of the following flags reuse lower bits (removed as part of the\n * Python 3.0 transition). */\n\n/* The following flags are kept for compatibility; in previous\n * versions they indicated presence of newer tp_* fields on the\n * type struct.\n * Starting with 3.8, binary compatibility of C extensions across\n * feature releases of Python is not supported anymore (except when\n * using the stable ABI, in which all classes are created dynamically,\n * using the interpreter's memory layout.)\n * Note that older extensions using the stable ABI set these flags,\n * so the bits must not be repurposed.\n */\n#define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)\n#define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)\n\n\n/*\nThe macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement\nreference counts.  Py_DECREF calls the object's deallocator function when\nthe refcount falls to 0; for\nobjects that don't contain references to other objects or heap memory\nthis can be the standard function free().  Both macros can be used\nwherever a void expression is allowed.  The argument must not be a\nNULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.\nThe macro _Py_NewReference(op) initialize reference counts to 1, and\nin special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional\nbookkeeping appropriate to the special build.\n\nWe assume that the reference count field can never overflow; this can\nbe proven when the size of the field is the same as the pointer size, so\nwe ignore the possibility.  Provided a C int is at least 32 bits (which\nis implicitly assumed in many parts of this code), that's enough for\nabout 2**31 references to an object.\n\nXXX The following became out of date in Python 2.2, but I'm not sure\nXXX what the full truth is now.  Certainly, heap-allocated type objects\nXXX can and should be deallocated.\nType objects should never be deallocated; the type pointer in an object\nis not considered to be a reference to the type object, to save\ncomplications in the deallocation function.  (This is actually a\ndecision that's up to the implementer of each new type so if you want,\nyou can count such references to the type object.)\n*/\n\n#if defined(Py_REF_DEBUG) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,\n                                      PyObject *op);\nPyAPI_FUNC(void) _Py_INCREF_IncRefTotal(void);\nPyAPI_FUNC(void) _Py_DECREF_DecRefTotal(void);\n#endif  // Py_REF_DEBUG && !Py_LIMITED_API\n\nPyAPI_FUNC(void) _Py_Dealloc(PyObject *);\n\n/*\nThese are provided as conveniences to Python runtime embedders, so that\nthey can have object code that is not dependent on Python compilation flags.\n*/\nPyAPI_FUNC(void) Py_IncRef(PyObject *);\nPyAPI_FUNC(void) Py_DecRef(PyObject *);\n\n// Similar to Py_IncRef() and Py_DecRef() but the argument must be non-NULL.\n// Private functions used by Py_INCREF() and Py_DECREF().\nPyAPI_FUNC(void) _Py_IncRef(PyObject *);\nPyAPI_FUNC(void) _Py_DecRef(PyObject *);\n\nstatic inline Py_ALWAYS_INLINE void Py_INCREF(PyObject *op)\n{\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n    // Stable ABI implements Py_INCREF() as a function call on limited C API\n    // version 3.12 and newer, and on Python built in debug mode. _Py_IncRef()\n    // was added to Python 3.10.0a7, use Py_IncRef() on older Python versions.\n    // Py_IncRef() accepts NULL whereas _Py_IncRef() doesn't.\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_IncRef(op);\n#  else\n    Py_IncRef(op);\n#  endif\n#else\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n#if SIZEOF_VOID_P > 4\n    // Portable saturated add, branching on the carry flag and set low bits\n    PY_UINT32_T cur_refcnt = op->ob_refcnt_split[PY_BIG_ENDIAN];\n    PY_UINT32_T new_refcnt = cur_refcnt + 1;\n    if (new_refcnt == 0) {\n        return;\n    }\n    op->ob_refcnt_split[PY_BIG_ENDIAN] = new_refcnt;\n#else\n    // Explicitly check immortality against the immortal value\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    op->ob_refcnt++;\n#endif\n    _Py_INCREF_STAT_INC();\n#ifdef Py_REF_DEBUG\n    _Py_INCREF_IncRefTotal();\n#endif\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_INCREF(op) Py_INCREF(_PyObject_CAST(op))\n#endif\n\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n// Stable ABI implements Py_DECREF() as a function call on limited C API\n// version 3.12 and newer, and on Python built in debug mode. _Py_DecRef() was\n// added to Python 3.10.0a7, use Py_DecRef() on older Python versions.\n// Py_DecRef() accepts NULL whereas _Py_IncRef() doesn't.\nstatic inline void Py_DECREF(PyObject *op) {\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_DecRef(op);\n#  else\n    Py_DecRef(op);\n#  endif\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    if (op->ob_refcnt <= 0) {\n        _Py_NegativeRefcount(filename, lineno, op);\n    }\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#else\nstatic inline Py_ALWAYS_INLINE void Py_DECREF(PyObject *op)\n{\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n#endif\n\n\n/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear\n * and tp_dealloc implementations.\n *\n * Note that \"the obvious\" code can be deadly:\n *\n *     Py_XDECREF(op);\n *     op = NULL;\n *\n * Typically, `op` is something like self->containee, and `self` is done\n * using its `containee` member.  In the code sequence above, suppose\n * `containee` is non-NULL with a refcount of 1.  Its refcount falls to\n * 0 on the first line, which can trigger an arbitrary amount of code,\n * possibly including finalizers (like __del__ methods or weakref callbacks)\n * coded in Python, which in turn can release the GIL and allow other threads\n * to run, etc.  Such code may even invoke methods of `self` again, or cause\n * cyclic gc to trigger, but-- oops! --self->containee still points to the\n * object being torn down, and it may be in an insane state while being torn\n * down.  This has in fact been a rich historic source of miserable (rare &\n * hard-to-diagnose) segfaulting (and other) bugs.\n *\n * The safe way is:\n *\n *      Py_CLEAR(op);\n *\n * That arranges to set `op` to NULL _before_ decref'ing, so that any code\n * triggered as a side-effect of `op` getting torn down no longer believes\n * `op` points to a valid object.\n *\n * There are cases where it's safe to use the naive code, but they're brittle.\n * For example, if `op` points to a Python integer, you know that destroying\n * one of those can't cause problems -- but in part that relies on that\n * Python integers aren't currently weakly referencable.  Best practice is\n * to use Py_CLEAR() even if you can't think of a reason for why you need to.\n *\n * gh-98724: Use a temporary variable to only evaluate the macro argument once,\n * to avoid the duplication of side effects if the argument has side effects.\n *\n * gh-99701: If the PyObject* type is used with casting arguments to PyObject*,\n * the code can be miscompiled with strict aliasing because of type punning.\n * With strict aliasing, a compiler considers that two pointers of different\n * types cannot read or write the same memory which enables optimization\n * opportunities.\n *\n * If available, use _Py_TYPEOF() to use the 'op' type for temporary variables,\n * and so avoid type punning. Otherwise, use memcpy() which causes type erasure\n * and so prevents the compiler to reuse an old cached 'op' value after\n * Py_CLEAR().\n */\n#ifdef _Py_TYPEOF\n#define Py_CLEAR(op) \\\n    do { \\\n        _Py_TYPEOF(op)* _tmp_op_ptr = &(op); \\\n        _Py_TYPEOF(op) _tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            *_tmp_op_ptr = _Py_NULL; \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#else\n#define Py_CLEAR(op) \\\n    do { \\\n        PyObject **_tmp_op_ptr = _Py_CAST(PyObject**, &(op)); \\\n        PyObject *_tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            PyObject *_null_ptr = _Py_NULL; \\\n            memcpy(_tmp_op_ptr, &_null_ptr, sizeof(PyObject*)); \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#endif\n\n\n/* Function to use in case the object pointer can be NULL: */\nstatic inline void Py_XINCREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_INCREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XINCREF(op) Py_XINCREF(_PyObject_CAST(op))\n#endif\n\nstatic inline void Py_XDECREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_DECREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XDECREF(op) Py_XDECREF(_PyObject_CAST(op))\n#endif\n\n// Create a new strong reference to an object:\n// increment the reference count of the object and return the object.\nPyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);\n\n// Similar to Py_NewRef(), but the object can be NULL.\nPyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);\n\nstatic inline PyObject* _Py_NewRef(PyObject *obj)\n{\n    Py_INCREF(obj);\n    return obj;\n}\n\nstatic inline PyObject* _Py_XNewRef(PyObject *obj)\n{\n    Py_XINCREF(obj);\n    return obj;\n}\n\n// Py_NewRef() and Py_XNewRef() are exported as functions for the stable ABI.\n// Names overridden with macros by static inline functions for best\n// performances.\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_NewRef(obj) _Py_NewRef(_PyObject_CAST(obj))\n#  define Py_XNewRef(obj) _Py_XNewRef(_PyObject_CAST(obj))\n#else\n#  define Py_NewRef(obj) _Py_NewRef(obj)\n#  define Py_XNewRef(obj) _Py_XNewRef(obj)\n#endif\n\n\n/*\n_Py_NoneStruct is an object of undefined type which can be used in contexts\nwhere NULL (nil) is not suitable (since NULL often means 'error').\n\nDon't forget to apply Py_INCREF() when returning this value!!!\n*/\nPyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n#define Py_None (&_Py_NoneStruct)\n\n// Test if an object is the None singleton, the same as \"x is None\" in Python.\nPyAPI_FUNC(int) Py_IsNone(PyObject *x);\n#define Py_IsNone(x) Py_Is((x), Py_None)\n\n/* Macro for returning Py_None from a function */\n#define Py_RETURN_NONE return Py_None\n\n/*\nPy_NotImplemented is a singleton used to signal that an operation is\nnot implemented for a given type combination.\n*/\nPyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */\n#define Py_NotImplemented (&_Py_NotImplementedStruct)\n\n/* Macro for returning Py_NotImplemented from a function */\n#define Py_RETURN_NOTIMPLEMENTED return Py_NotImplemented\n\n/* Rich comparison opcodes */\n#define Py_LT 0\n#define Py_LE 1\n#define Py_EQ 2\n#define Py_NE 3\n#define Py_GT 4\n#define Py_GE 5\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000\n/* Result of calling PyIter_Send */\ntypedef enum {\n    PYGEN_RETURN = 0,\n    PYGEN_ERROR = -1,\n    PYGEN_NEXT = 1,\n} PySendResult;\n#endif\n\n/*\n * Macro for implementing rich comparisons\n *\n * Needs to be a macro because any C-comparable type can be used.\n */\n#define Py_RETURN_RICHCOMPARE(val1, val2, op)                               \\\n    do {                                                                    \\\n        switch (op) {                                                       \\\n        case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        default:                                                            \\\n            Py_UNREACHABLE();                                               \\\n        }                                                                   \\\n    } while (0)\n\n\n/*\nMore conventions\n================\n\nArgument Checking\n-----------------\n\nFunctions that take objects as arguments normally don't check for nil\narguments, but they do check the type of the argument, and return an\nerror if the function doesn't apply to the type.\n\nFailure Modes\n-------------\n\nFunctions may fail for a variety of reasons, including running out of\nmemory.  This is communicated to the caller in two ways: an error string\nis set (see errors.h), and the function result differs: functions that\nnormally return a pointer return NULL for failure, functions returning\nan integer return -1 (which could be a legal return value too!), and\nother functions return 0 for success and -1 for failure.\nCallers should always check for errors before using the result.  If\nan error was set, the caller must either explicitly clear it, or pass\nthe error on to its caller.\n\nReference Counts\n----------------\n\nIt takes a while to get used to the proper usage of reference counts.\n\nFunctions that create an object set the reference count to 1; such new\nobjects must be stored somewhere or destroyed again with Py_DECREF().\nSome functions that 'store' objects, such as PyTuple_SetItem() and\nPyList_SetItem(),\ndon't increment the reference count of the object, since the most\nfrequent use is to store a fresh object.  Functions that 'retrieve'\nobjects, such as PyTuple_GetItem() and PyDict_GetItemString(), also\ndon't increment\nthe reference count, since most frequently the object is only looked at\nquickly.  Thus, to retrieve an object and store it again, the caller\nmust call Py_INCREF() explicitly.\n\nNOTE: functions that 'consume' a reference count, like\nPyList_SetItem(), consume the reference even if the object wasn't\nsuccessfully stored, to simplify error handling.\n\nIt seems attractive to make other functions that take an object as\nargument consume a reference count; however, this may quickly get\nconfusing (even the current practice is already confusing).  Consider\nit carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at\ntimes.\n*/\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_OBJECT_H\n#  include \"cpython/object.h\"\n#  undef Py_CPYTHON_OBJECT_H\n#endif\n\n\nstatic inline int\nPyType_HasFeature(PyTypeObject *type, unsigned long feature)\n{\n    unsigned long flags;\n#ifdef Py_LIMITED_API\n    // PyTypeObject is opaque in the limited C API\n    flags = PyType_GetFlags(type);\n#else\n    flags = type->tp_flags;\n#endif\n    return ((flags & feature) != 0);\n}\n\n#define PyType_FastSubclass(type, flag) PyType_HasFeature((type), (flag))\n\nstatic inline int PyType_Check(PyObject *op) {\n    return PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_Check(op) PyType_Check(_PyObject_CAST(op))\n#endif\n\n#define _PyType_CAST(op) \\\n    (assert(PyType_Check(op)), _Py_CAST(PyTypeObject*, (op)))\n\nstatic inline int PyType_CheckExact(PyObject *op) {\n    return Py_IS_TYPE(op, &PyType_Type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_CheckExact(op) PyType_CheckExact(_PyObject_CAST(op))\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif   // !Py_OBJECT_H\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Modules/_sre/sre.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/*\n * Secret Labs' Regular Expression Engine\n *\n * regular expression matching engine\n *\n * partial history:\n * 1999-10-24 fl   created (based on existing template matcher code)\n * 2000-03-06 fl   first alpha, sort of\n * 2000-08-01 fl   fixes for 1.6b1\n * 2000-08-07 fl   use PyOS_CheckStack() if available\n * 2000-09-20 fl   added expand method\n * 2001-03-20 fl   lots of fixes for 2.1b2\n * 2001-04-15 fl   export copyright as Python attribute, not global\n * 2001-04-28 fl   added __copy__ methods (work in progress)\n * 2001-05-14 fl   fixes for 1.5.2 compatibility\n * 2001-07-01 fl   added BIGCHARSET support (from Martin von Loewis)\n * 2001-10-18 fl   fixed group reset issue (from Matthew Mueller)\n * 2001-10-20 fl   added split primitive; re-enable unicode for 1.6/2.0/2.1\n * 2001-10-21 fl   added sub/subn primitive\n * 2001-10-24 fl   added finditer primitive (for 2.2 only)\n * 2001-12-07 fl   fixed memory leak in sub/subn (Guido van Rossum)\n * 2002-11-09 fl   fixed empty sub/subn return type\n * 2003-04-18 mvl  fully support 4-byte codes\n * 2003-10-17 gn   implemented non recursive scheme\n * 2013-02-04 mrab added fullmatch primitive\n *\n * Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.\n *\n * This version of the SRE library can be redistributed under CNRI's\n * Python 1.6 license.  For any other use, please contact Secret Labs\n * AB (info@pythonware.com).\n *\n * Portions of this engine have been developed in cooperation with\n * CNRI.  Hewlett-Packard provided funding for 1.6 integration and\n * other compatibility work.\n */\n\nstatic const char copyright[] =\n    \" SRE 2.2.2 Copyright (c) 1997-2002 by Secret Labs AB \";\n\n#define PY_SSIZE_T_CLEAN\n\n#include \"Python.h\"\n#include \"pycore_long.h\"          // _PyLong_GetZero()\n#include \"pycore_moduleobject.h\"  // _PyModule_GetState()\n#include \"structmember.h\"         // PyMemberDef\n\n#include \"sre.h\"\n\n#define SRE_CODE_BITS (8 * sizeof(SRE_CODE))\n\n#include <ctype.h>\n\n/* defining this one enables tracing */\n#undef VERBOSE\n\n/* -------------------------------------------------------------------- */\n\n#if defined(_MSC_VER)\n#pragma optimize(\"agtw\", on) /* doesn't seem to make much difference... */\n#pragma warning(disable: 4710) /* who cares if functions are not inlined ;-) */\n/* fastest possible local call under MSVC */\n#define LOCAL(type) static __inline type __fastcall\n#else\n#define LOCAL(type) static inline type\n#endif\n\n/* error codes */\n#define SRE_ERROR_ILLEGAL -1 /* illegal opcode */\n#define SRE_ERROR_STATE -2 /* illegal state */\n#define SRE_ERROR_RECURSION_LIMIT -3 /* runaway recursion */\n#define SRE_ERROR_MEMORY -9 /* out of memory */\n#define SRE_ERROR_INTERRUPTED -10 /* signal handler raised exception */\n\n#if defined(VERBOSE)\n#define TRACE(v) printf v\n#else\n#define TRACE(v)\n#endif\n\n/* -------------------------------------------------------------------- */\n/* search engine state */\n\n#define SRE_IS_DIGIT(ch)\\\n    ((ch) <= '9' && Py_ISDIGIT(ch))\n#define SRE_IS_SPACE(ch)\\\n    ((ch) <= ' ' && Py_ISSPACE(ch))\n#define SRE_IS_LINEBREAK(ch)\\\n    ((ch) == '\\n')\n#define SRE_IS_WORD(ch)\\\n    ((ch) <= 'z' && (Py_ISALNUM(ch) || (ch) == '_'))\n\nstatic unsigned int sre_lower_ascii(unsigned int ch)\n{\n    return ((ch) < 128 ? Py_TOLOWER(ch) : ch);\n}\n\n/* locale-specific character predicates */\n/* !(c & ~N) == (c < N+1) for any unsigned c, this avoids\n * warnings when c's type supports only numbers < N+1 */\n#define SRE_LOC_IS_ALNUM(ch) (!((ch) & ~255) ? isalnum((ch)) : 0)\n#define SRE_LOC_IS_WORD(ch) (SRE_LOC_IS_ALNUM((ch)) || (ch) == '_')\n\nstatic unsigned int sre_lower_locale(unsigned int ch)\n{\n    return ((ch) < 256 ? (unsigned int)tolower((ch)) : ch);\n}\n\nstatic unsigned int sre_upper_locale(unsigned int ch)\n{\n    return ((ch) < 256 ? (unsigned int)toupper((ch)) : ch);\n}\n\n/* unicode-specific character predicates */\n\n#define SRE_UNI_IS_DIGIT(ch) Py_UNICODE_ISDECIMAL(ch)\n#define SRE_UNI_IS_SPACE(ch) Py_UNICODE_ISSPACE(ch)\n#define SRE_UNI_IS_LINEBREAK(ch) Py_UNICODE_ISLINEBREAK(ch)\n#define SRE_UNI_IS_ALNUM(ch) Py_UNICODE_ISALNUM(ch)\n#define SRE_UNI_IS_WORD(ch) (SRE_UNI_IS_ALNUM(ch) || (ch) == '_')\n\nstatic unsigned int sre_lower_unicode(unsigned int ch)\n{\n    return (unsigned int) Py_UNICODE_TOLOWER(ch);\n}\n\nstatic unsigned int sre_upper_unicode(unsigned int ch)\n{\n    return (unsigned int) Py_UNICODE_TOUPPER(ch);\n}\n\nLOCAL(int)\nsre_category(SRE_CODE category, unsigned int ch)\n{\n    switch (category) {\n\n    case SRE_CATEGORY_DIGIT:\n        return SRE_IS_DIGIT(ch);\n    case SRE_CATEGORY_NOT_DIGIT:\n        return !SRE_IS_DIGIT(ch);\n    case SRE_CATEGORY_SPACE:\n        return SRE_IS_SPACE(ch);\n    case SRE_CATEGORY_NOT_SPACE:\n        return !SRE_IS_SPACE(ch);\n    case SRE_CATEGORY_WORD:\n        return SRE_IS_WORD(ch);\n    case SRE_CATEGORY_NOT_WORD:\n        return !SRE_IS_WORD(ch);\n    case SRE_CATEGORY_LINEBREAK:\n        return SRE_IS_LINEBREAK(ch);\n    case SRE_CATEGORY_NOT_LINEBREAK:\n        return !SRE_IS_LINEBREAK(ch);\n\n    case SRE_CATEGORY_LOC_WORD:\n        return SRE_LOC_IS_WORD(ch);\n    case SRE_CATEGORY_LOC_NOT_WORD:\n        return !SRE_LOC_IS_WORD(ch);\n\n    case SRE_CATEGORY_UNI_DIGIT:\n        return SRE_UNI_IS_DIGIT(ch);\n    case SRE_CATEGORY_UNI_NOT_DIGIT:\n        return !SRE_UNI_IS_DIGIT(ch);\n    case SRE_CATEGORY_UNI_SPACE:\n        return SRE_UNI_IS_SPACE(ch);\n    case SRE_CATEGORY_UNI_NOT_SPACE:\n        return !SRE_UNI_IS_SPACE(ch);\n    case SRE_CATEGORY_UNI_WORD:\n        return SRE_UNI_IS_WORD(ch);\n    case SRE_CATEGORY_UNI_NOT_WORD:\n        return !SRE_UNI_IS_WORD(ch);\n    case SRE_CATEGORY_UNI_LINEBREAK:\n        return SRE_UNI_IS_LINEBREAK(ch);\n    case SRE_CATEGORY_UNI_NOT_LINEBREAK:\n        return !SRE_UNI_IS_LINEBREAK(ch);\n    }\n    return 0;\n}\n\nLOCAL(int)\nchar_loc_ignore(SRE_CODE pattern, SRE_CODE ch)\n{\n    return ch == pattern\n        || (SRE_CODE) sre_lower_locale(ch) == pattern\n        || (SRE_CODE) sre_upper_locale(ch) == pattern;\n}\n\n\n/* helpers */\n\nstatic void\ndata_stack_dealloc(SRE_STATE* state)\n{\n    if (state->data_stack) {\n        PyMem_Free(state->data_stack);\n        state->data_stack = NULL;\n    }\n    state->data_stack_size = state->data_stack_base = 0;\n}\n\nstatic int\ndata_stack_grow(SRE_STATE* state, Py_ssize_t size)\n{\n    Py_ssize_t minsize, cursize;\n    minsize = state->data_stack_base+size;\n    cursize = state->data_stack_size;\n    if (cursize < minsize) {\n        void* stack;\n        cursize = minsize+minsize/4+1024;\n        TRACE((\"allocate/grow stack %zd\\n\", cursize));\n        stack = PyMem_Realloc(state->data_stack, cursize);\n        if (!stack) {\n            data_stack_dealloc(state);\n            return SRE_ERROR_MEMORY;\n        }\n        state->data_stack = (char *)stack;\n        state->data_stack_size = cursize;\n    }\n    return 0;\n}\n\n/* generate 8-bit version */\n\n#define SRE_CHAR Py_UCS1\n#define SIZEOF_SRE_CHAR 1\n#define SRE(F) sre_ucs1_##F\n#include \"sre_lib.h\"\n\n/* generate 16-bit unicode version */\n\n#define SRE_CHAR Py_UCS2\n#define SIZEOF_SRE_CHAR 2\n#define SRE(F) sre_ucs2_##F\n#include \"sre_lib.h\"\n\n/* generate 32-bit unicode version */\n\n#define SRE_CHAR Py_UCS4\n#define SIZEOF_SRE_CHAR 4\n#define SRE(F) sre_ucs4_##F\n#include \"sre_lib.h\"\n\n/* -------------------------------------------------------------------- */\n/* factories and destructors */\n\n/* module state */\ntypedef struct {\n    PyTypeObject *Pattern_Type;\n    PyTypeObject *Match_Type;\n    PyTypeObject *Scanner_Type;\n    PyTypeObject *Template_Type;\n    PyObject *compile_template;  // reference to re._compile_template\n} _sremodulestate;\n\nstatic _sremodulestate *\nget_sre_module_state(PyObject *m)\n{\n    _sremodulestate *state = (_sremodulestate *)_PyModule_GetState(m);\n    assert(state);\n    return state;\n}\n\nstatic struct PyModuleDef sremodule;\n#define get_sre_module_state_by_class(cls) \\\n    (get_sre_module_state(PyType_GetModule(cls)))\n\n/* see sre.h for object declarations */\nstatic PyObject*pattern_new_match(_sremodulestate *, PatternObject*, SRE_STATE*, Py_ssize_t);\nstatic PyObject *pattern_scanner(_sremodulestate *, PatternObject *, PyObject *, Py_ssize_t, Py_ssize_t);\n\n/*[clinic input]\nmodule _sre\nclass _sre.SRE_Pattern \"PatternObject *\" \"get_sre_module_state_by_class(tp)->Pattern_Type\"\nclass _sre.SRE_Match \"MatchObject *\" \"get_sre_module_state_by_class(tp)->Match_Type\"\nclass _sre.SRE_Scanner \"ScannerObject *\" \"get_sre_module_state_by_class(tp)->Scanner_Type\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=fe2966e32b66a231]*/\n\n/*[clinic input]\n_sre.getcodesize -> int\n[clinic start generated code]*/\n\nstatic int\n_sre_getcodesize_impl(PyObject *module)\n/*[clinic end generated code: output=e0db7ce34a6dd7b1 input=bd6f6ecf4916bb2b]*/\n{\n    return sizeof(SRE_CODE);\n}\n\n/*[clinic input]\n_sre.ascii_iscased -> bool\n\n    character: int\n    /\n\n[clinic start generated code]*/\n\nstatic int\n_sre_ascii_iscased_impl(PyObject *module, int character)\n/*[clinic end generated code: output=4f454b630fbd19a2 input=9f0bd952812c7ed3]*/\n{\n    unsigned int ch = (unsigned int)character;\n    return ch < 128 && Py_ISALPHA(ch);\n}\n\n/*[clinic input]\n_sre.unicode_iscased -> bool\n\n    character: int\n    /\n\n[clinic start generated code]*/\n\nstatic int\n_sre_unicode_iscased_impl(PyObject *module, int character)\n/*[clinic end generated code: output=9c5ddee0dc2bc258 input=51e42c3b8dddb78e]*/\n{\n    unsigned int ch = (unsigned int)character;\n    return ch != sre_lower_unicode(ch) || ch != sre_upper_unicode(ch);\n}\n\n/*[clinic input]\n_sre.ascii_tolower -> int\n\n    character: int\n    /\n\n[clinic start generated code]*/\n\nstatic int\n_sre_ascii_tolower_impl(PyObject *module, int character)\n/*[clinic end generated code: output=228294ed6ff2a612 input=272c609b5b61f136]*/\n{\n    return sre_lower_ascii(character);\n}\n\n/*[clinic input]\n_sre.unicode_tolower -> int\n\n    character: int\n    /\n\n[clinic start generated code]*/\n\nstatic int\n_sre_unicode_tolower_impl(PyObject *module, int character)\n/*[clinic end generated code: output=6422272d7d7fee65 input=91d708c5f3c2045a]*/\n{\n    return sre_lower_unicode(character);\n}\n\nLOCAL(void)\nstate_reset(SRE_STATE* state)\n{\n    /* state->mark will be set to 0 in SRE_OP_MARK dynamically. */\n    /*memset(state->mark, 0, sizeof(*state->mark) * SRE_MARK_SIZE);*/\n\n    state->lastmark = -1;\n    state->lastindex = -1;\n\n    state->repeat = NULL;\n\n    data_stack_dealloc(state);\n}\n\nstatic const void*\ngetstring(PyObject* string, Py_ssize_t* p_length,\n          int* p_isbytes, int* p_charsize,\n          Py_buffer *view)\n{\n    /* given a python object, return a data pointer, a length (in\n       characters), and a character size.  return NULL if the object\n       is not a string (or not compatible) */\n\n    /* Unicode objects do not support the buffer API. So, get the data\n       directly instead. */\n    if (PyUnicode_Check(string)) {\n        if (PyUnicode_READY(string) == -1)\n            return NULL;\n        *p_length = PyUnicode_GET_LENGTH(string);\n        *p_charsize = PyUnicode_KIND(string);\n        *p_isbytes = 0;\n        return PyUnicode_DATA(string);\n    }\n\n    /* get pointer to byte string buffer */\n    if (PyObject_GetBuffer(string, view, PyBUF_SIMPLE) != 0) {\n        PyErr_Format(PyExc_TypeError, \"expected string or bytes-like \"\n                     \"object, got '%.200s'\", Py_TYPE(string)->tp_name);\n        return NULL;\n    }\n\n    *p_length = view->len;\n    *p_charsize = 1;\n    *p_isbytes = 1;\n\n    if (view->buf == NULL) {\n        PyErr_SetString(PyExc_ValueError, \"Buffer is NULL\");\n        PyBuffer_Release(view);\n        view->buf = NULL;\n        return NULL;\n    }\n    return view->buf;\n}\n\nLOCAL(PyObject*)\nstate_init(SRE_STATE* state, PatternObject* pattern, PyObject* string,\n           Py_ssize_t start, Py_ssize_t end)\n{\n    /* prepare state object */\n\n    Py_ssize_t length;\n    int isbytes, charsize;\n    const void* ptr;\n\n    memset(state, 0, sizeof(SRE_STATE));\n\n    state->mark = PyMem_New(const void *, pattern->groups * 2);\n    if (!state->mark) {\n        PyErr_NoMemory();\n        goto err;\n    }\n    state->lastmark = -1;\n    state->lastindex = -1;\n\n    state->buffer.buf = NULL;\n    ptr = getstring(string, &length, &isbytes, &charsize, &state->buffer);\n    if (!ptr)\n        goto err;\n\n    if (isbytes && pattern->isbytes == 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"cannot use a string pattern on a bytes-like object\");\n        goto err;\n    }\n    if (!isbytes && pattern->isbytes > 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"cannot use a bytes pattern on a string-like object\");\n        goto err;\n    }\n\n    /* adjust boundaries */\n    if (start < 0)\n        start = 0;\n    else if (start > length)\n        start = length;\n\n    if (end < 0)\n        end = 0;\n    else if (end > length)\n        end = length;\n\n    state->isbytes = isbytes;\n    state->charsize = charsize;\n    state->match_all = 0;\n    state->must_advance = 0;\n\n    state->beginning = ptr;\n\n    state->start = (void*) ((char*) ptr + start * state->charsize);\n    state->end = (void*) ((char*) ptr + end * state->charsize);\n\n    state->string = Py_NewRef(string);\n    state->pos = start;\n    state->endpos = end;\n\n    return string;\n  err:\n    /* We add an explicit cast here because MSVC has a bug when\n       compiling C code where it believes that `const void**` cannot be\n       safely casted to `void*`, see bpo-39943 for details. */\n    PyMem_Free((void*) state->mark);\n    state->mark = NULL;\n    if (state->buffer.buf)\n        PyBuffer_Release(&state->buffer);\n    return NULL;\n}\n\nLOCAL(void)\nstate_fini(SRE_STATE* state)\n{\n    if (state->buffer.buf)\n        PyBuffer_Release(&state->buffer);\n    Py_XDECREF(state->string);\n    data_stack_dealloc(state);\n    /* See above PyMem_Del for why we explicitly cast here. */\n    PyMem_Free((void*) state->mark);\n    state->mark = NULL;\n}\n\n/* calculate offset from start of string */\n#define STATE_OFFSET(state, member)\\\n    (((char*)(member) - (char*)(state)->beginning) / (state)->charsize)\n\nLOCAL(PyObject*)\ngetslice(int isbytes, const void *ptr,\n         PyObject* string, Py_ssize_t start, Py_ssize_t end)\n{\n    if (isbytes) {\n        if (PyBytes_CheckExact(string) &&\n            start == 0 && end == PyBytes_GET_SIZE(string)) {\n            return Py_NewRef(string);\n        }\n        return PyBytes_FromStringAndSize(\n                (const char *)ptr + start, end - start);\n    }\n    else {\n        return PyUnicode_Substring(string, start, end);\n    }\n}\n\nLOCAL(PyObject*)\nstate_getslice(SRE_STATE* state, Py_ssize_t index, PyObject* string, int empty)\n{\n    Py_ssize_t i, j;\n\n    index = (index - 1) * 2;\n\n    if (string == Py_None || index >= state->lastmark || !state->mark[index] || !state->mark[index+1]) {\n        if (empty)\n            /* want empty string */\n            i = j = 0;\n        else {\n            Py_RETURN_NONE;\n        }\n    } else {\n        i = STATE_OFFSET(state, state->mark[index]);\n        j = STATE_OFFSET(state, state->mark[index+1]);\n\n        /* check wrong span */\n        if (i > j) {\n            PyErr_SetString(PyExc_SystemError,\n                            \"The span of capturing group is wrong,\"\n                            \" please report a bug for the re module.\");\n            return NULL;\n        }\n    }\n\n    return getslice(state->isbytes, state->beginning, string, i, j);\n}\n\nstatic void\npattern_error(Py_ssize_t status)\n{\n    switch (status) {\n    case SRE_ERROR_RECURSION_LIMIT:\n        /* This error code seems to be unused. */\n        PyErr_SetString(\n            PyExc_RecursionError,\n            \"maximum recursion limit exceeded\"\n            );\n        break;\n    case SRE_ERROR_MEMORY:\n        PyErr_NoMemory();\n        break;\n    case SRE_ERROR_INTERRUPTED:\n    /* An exception has already been raised, so let it fly */\n        break;\n    default:\n        /* other error codes indicate compiler/engine bugs */\n        PyErr_SetString(\n            PyExc_RuntimeError,\n            \"internal error in regular expression engine\"\n            );\n    }\n}\n\nstatic int\npattern_traverse(PatternObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(self));\n    Py_VISIT(self->groupindex);\n    Py_VISIT(self->indexgroup);\n    Py_VISIT(self->pattern);\n    return 0;\n}\n\nstatic int\npattern_clear(PatternObject *self)\n{\n    Py_CLEAR(self->groupindex);\n    Py_CLEAR(self->indexgroup);\n    Py_CLEAR(self->pattern);\n    return 0;\n}\n\nstatic void\npattern_dealloc(PatternObject* self)\n{\n    PyTypeObject *tp = Py_TYPE(self);\n\n    PyObject_GC_UnTrack(self);\n    if (self->weakreflist != NULL) {\n        PyObject_ClearWeakRefs((PyObject *) self);\n    }\n    (void)pattern_clear(self);\n    tp->tp_free(self);\n    Py_DECREF(tp);\n}\n\nLOCAL(Py_ssize_t)\nsre_match(SRE_STATE* state, SRE_CODE* pattern)\n{\n    if (state->charsize == 1)\n        return sre_ucs1_match(state, pattern, 1);\n    if (state->charsize == 2)\n        return sre_ucs2_match(state, pattern, 1);\n    assert(state->charsize == 4);\n    return sre_ucs4_match(state, pattern, 1);\n}\n\nLOCAL(Py_ssize_t)\nsre_search(SRE_STATE* state, SRE_CODE* pattern)\n{\n    if (state->charsize == 1)\n        return sre_ucs1_search(state, pattern);\n    if (state->charsize == 2)\n        return sre_ucs2_search(state, pattern);\n    assert(state->charsize == 4);\n    return sre_ucs4_search(state, pattern);\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.match\n\n    cls: defining_class\n    /\n    string: object\n    pos: Py_ssize_t = 0\n    endpos: Py_ssize_t(c_default=\"PY_SSIZE_T_MAX\") = sys.maxsize\n\nMatches zero or more characters at the beginning of the string.\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Pattern_match_impl(PatternObject *self, PyTypeObject *cls,\n                            PyObject *string, Py_ssize_t pos,\n                            Py_ssize_t endpos)\n/*[clinic end generated code: output=ec6208ea58a0cca0 input=4bdb9c3e564d13ac]*/\n{\n    _sremodulestate *module_state = get_sre_module_state_by_class(cls);\n    SRE_STATE state;\n    Py_ssize_t status;\n    PyObject *match;\n\n    if (!state_init(&state, (PatternObject *)self, string, pos, endpos))\n        return NULL;\n\n    state.ptr = state.start;\n\n    TRACE((\"|%p|%p|MATCH\\n\", PatternObject_GetCode(self), state.ptr));\n\n    status = sre_match(&state, PatternObject_GetCode(self));\n\n    TRACE((\"|%p|%p|END\\n\", PatternObject_GetCode(self), state.ptr));\n    if (PyErr_Occurred()) {\n        state_fini(&state);\n        return NULL;\n    }\n\n    match = pattern_new_match(module_state, self, &state, status);\n    state_fini(&state);\n    return match;\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.fullmatch\n\n    cls: defining_class\n    /\n    string: object\n    pos: Py_ssize_t = 0\n    endpos: Py_ssize_t(c_default=\"PY_SSIZE_T_MAX\") = sys.maxsize\n\nMatches against all of the string.\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Pattern_fullmatch_impl(PatternObject *self, PyTypeObject *cls,\n                                PyObject *string, Py_ssize_t pos,\n                                Py_ssize_t endpos)\n/*[clinic end generated code: output=625b75b027ef94da input=50981172ab0fcfdd]*/\n{\n    _sremodulestate *module_state = get_sre_module_state_by_class(cls);\n    SRE_STATE state;\n    Py_ssize_t status;\n    PyObject *match;\n\n    if (!state_init(&state, self, string, pos, endpos))\n        return NULL;\n\n    state.ptr = state.start;\n\n    TRACE((\"|%p|%p|FULLMATCH\\n\", PatternObject_GetCode(self), state.ptr));\n\n    state.match_all = 1;\n    status = sre_match(&state, PatternObject_GetCode(self));\n\n    TRACE((\"|%p|%p|END\\n\", PatternObject_GetCode(self), state.ptr));\n    if (PyErr_Occurred()) {\n        state_fini(&state);\n        return NULL;\n    }\n\n    match = pattern_new_match(module_state, self, &state, status);\n    state_fini(&state);\n    return match;\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.search\n\n    cls: defining_class\n    /\n    string: object\n    pos: Py_ssize_t = 0\n    endpos: Py_ssize_t(c_default=\"PY_SSIZE_T_MAX\") = sys.maxsize\n\nScan through string looking for a match, and return a corresponding match object instance.\n\nReturn None if no position in the string matches.\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Pattern_search_impl(PatternObject *self, PyTypeObject *cls,\n                             PyObject *string, Py_ssize_t pos,\n                             Py_ssize_t endpos)\n/*[clinic end generated code: output=bd7f2d9d583e1463 input=afa9afb66a74a4b3]*/\n{\n    _sremodulestate *module_state = get_sre_module_state_by_class(cls);\n    SRE_STATE state;\n    Py_ssize_t status;\n    PyObject *match;\n\n    if (!state_init(&state, self, string, pos, endpos))\n        return NULL;\n\n    TRACE((\"|%p|%p|SEARCH\\n\", PatternObject_GetCode(self), state.ptr));\n\n    status = sre_search(&state, PatternObject_GetCode(self));\n\n    TRACE((\"|%p|%p|END\\n\", PatternObject_GetCode(self), state.ptr));\n\n    if (PyErr_Occurred()) {\n        state_fini(&state);\n        return NULL;\n    }\n\n    match = pattern_new_match(module_state, self, &state, status);\n    state_fini(&state);\n    return match;\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.findall\n\n    string: object\n    pos: Py_ssize_t = 0\n    endpos: Py_ssize_t(c_default=\"PY_SSIZE_T_MAX\") = sys.maxsize\n\nReturn a list of all non-overlapping matches of pattern in string.\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Pattern_findall_impl(PatternObject *self, PyObject *string,\n                              Py_ssize_t pos, Py_ssize_t endpos)\n/*[clinic end generated code: output=f4966baceea60aca input=5b6a4ee799741563]*/\n{\n    SRE_STATE state;\n    PyObject* list;\n    Py_ssize_t status;\n    Py_ssize_t i, b, e;\n\n    if (!state_init(&state, self, string, pos, endpos))\n        return NULL;\n\n    list = PyList_New(0);\n    if (!list) {\n        state_fini(&state);\n        return NULL;\n    }\n\n    while (state.start <= state.end) {\n\n        PyObject* item;\n\n        state_reset(&state);\n\n        state.ptr = state.start;\n\n        status = sre_search(&state, PatternObject_GetCode(self));\n        if (PyErr_Occurred())\n            goto error;\n\n        if (status <= 0) {\n            if (status == 0)\n                break;\n            pattern_error(status);\n            goto error;\n        }\n\n        /* don't bother to build a match object */\n        switch (self->groups) {\n        case 0:\n            b = STATE_OFFSET(&state, state.start);\n            e = STATE_OFFSET(&state, state.ptr);\n            item = getslice(state.isbytes, state.beginning,\n                            string, b, e);\n            if (!item)\n                goto error;\n            break;\n        case 1:\n            item = state_getslice(&state, 1, string, 1);\n            if (!item)\n                goto error;\n            break;\n        default:\n            item = PyTuple_New(self->groups);\n            if (!item)\n                goto error;\n            for (i = 0; i < self->groups; i++) {\n                PyObject* o = state_getslice(&state, i+1, string, 1);\n                if (!o) {\n                    Py_DECREF(item);\n                    goto error;\n                }\n                PyTuple_SET_ITEM(item, i, o);\n            }\n            break;\n        }\n\n        status = PyList_Append(list, item);\n        Py_DECREF(item);\n        if (status < 0)\n            goto error;\n\n        state.must_advance = (state.ptr == state.start);\n        state.start = state.ptr;\n    }\n\n    state_fini(&state);\n    return list;\n\nerror:\n    Py_DECREF(list);\n    state_fini(&state);\n    return NULL;\n\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.finditer\n\n    cls: defining_class\n    /\n    string: object\n    pos: Py_ssize_t = 0\n    endpos: Py_ssize_t(c_default=\"PY_SSIZE_T_MAX\") = sys.maxsize\n\nReturn an iterator over all non-overlapping matches for the RE pattern in string.\n\nFor each match, the iterator returns a match object.\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Pattern_finditer_impl(PatternObject *self, PyTypeObject *cls,\n                               PyObject *string, Py_ssize_t pos,\n                               Py_ssize_t endpos)\n/*[clinic end generated code: output=1791dbf3618ade56 input=812e332a4848cbaf]*/\n{\n    _sremodulestate *module_state = get_sre_module_state_by_class(cls);\n    PyObject* scanner;\n    PyObject* search;\n    PyObject* iterator;\n\n    scanner = pattern_scanner(module_state, self, string, pos, endpos);\n    if (!scanner)\n        return NULL;\n\n    search = PyObject_GetAttrString(scanner, \"search\");\n    Py_DECREF(scanner);\n    if (!search)\n        return NULL;\n\n    iterator = PyCallIter_New(search, Py_None);\n    Py_DECREF(search);\n\n    return iterator;\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.scanner\n\n    cls: defining_class\n    /\n    string: object\n    pos: Py_ssize_t = 0\n    endpos: Py_ssize_t(c_default=\"PY_SSIZE_T_MAX\") = sys.maxsize\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Pattern_scanner_impl(PatternObject *self, PyTypeObject *cls,\n                              PyObject *string, Py_ssize_t pos,\n                              Py_ssize_t endpos)\n/*[clinic end generated code: output=f70cd506112f1bd9 input=2e487e5151bcee4c]*/\n{\n    _sremodulestate *module_state = get_sre_module_state_by_class(cls);\n\n    return pattern_scanner(module_state, self, string, pos, endpos);\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.split\n\n    string: object\n    maxsplit: Py_ssize_t = 0\n\nSplit string by the occurrences of pattern.\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Pattern_split_impl(PatternObject *self, PyObject *string,\n                            Py_ssize_t maxsplit)\n/*[clinic end generated code: output=7ac66f381c45e0be input=1eeeb10dafc9947a]*/\n{\n    SRE_STATE state;\n    PyObject* list;\n    PyObject* item;\n    Py_ssize_t status;\n    Py_ssize_t n;\n    Py_ssize_t i;\n    const void* last;\n\n    assert(self->codesize != 0);\n\n    if (!state_init(&state, self, string, 0, PY_SSIZE_T_MAX))\n        return NULL;\n\n    list = PyList_New(0);\n    if (!list) {\n        state_fini(&state);\n        return NULL;\n    }\n\n    n = 0;\n    last = state.start;\n\n    while (!maxsplit || n < maxsplit) {\n\n        state_reset(&state);\n\n        state.ptr = state.start;\n\n        status = sre_search(&state, PatternObject_GetCode(self));\n        if (PyErr_Occurred())\n            goto error;\n\n        if (status <= 0) {\n            if (status == 0)\n                break;\n            pattern_error(status);\n            goto error;\n        }\n\n        /* get segment before this match */\n        item = getslice(state.isbytes, state.beginning,\n            string, STATE_OFFSET(&state, last),\n            STATE_OFFSET(&state, state.start)\n            );\n        if (!item)\n            goto error;\n        status = PyList_Append(list, item);\n        Py_DECREF(item);\n        if (status < 0)\n            goto error;\n\n        /* add groups (if any) */\n        for (i = 0; i < self->groups; i++) {\n            item = state_getslice(&state, i+1, string, 0);\n            if (!item)\n                goto error;\n            status = PyList_Append(list, item);\n            Py_DECREF(item);\n            if (status < 0)\n                goto error;\n        }\n\n        n = n + 1;\n        state.must_advance = (state.ptr == state.start);\n        last = state.start = state.ptr;\n\n    }\n\n    /* get segment following last match (even if empty) */\n    item = getslice(state.isbytes, state.beginning,\n        string, STATE_OFFSET(&state, last), state.endpos\n        );\n    if (!item)\n        goto error;\n    status = PyList_Append(list, item);\n    Py_DECREF(item);\n    if (status < 0)\n        goto error;\n\n    state_fini(&state);\n    return list;\n\nerror:\n    Py_DECREF(list);\n    state_fini(&state);\n    return NULL;\n\n}\n\nstatic PyObject *\ncompile_template(_sremodulestate *module_state,\n                 PatternObject *pattern, PyObject *template)\n{\n    /* delegate to Python code */\n    PyObject *func = module_state->compile_template;\n    if (func == NULL) {\n        func = _PyImport_GetModuleAttrString(\"re\", \"_compile_template\");\n        if (func == NULL) {\n            return NULL;\n        }\n        Py_XSETREF(module_state->compile_template, func);\n    }\n\n    PyObject *args[] = {(PyObject *)pattern, template};\n    PyObject *result = PyObject_Vectorcall(func, args, 2, NULL);\n\n    if (result == NULL && PyErr_ExceptionMatches(PyExc_TypeError)) {\n        /* If the replacement string is unhashable (e.g. bytearray),\n         * convert it to the basic type (str or bytes) and repeat. */\n        if (PyUnicode_Check(template) && !PyUnicode_CheckExact(template)) {\n            PyErr_Clear();\n            template = _PyUnicode_Copy(template);\n        }\n        else if (PyObject_CheckBuffer(template) && !PyBytes_CheckExact(template)) {\n            PyErr_Clear();\n            template = PyBytes_FromObject(template);\n        }\n        else {\n            return NULL;\n        }\n        if (template == NULL) {\n            return NULL;\n        }\n        args[1] = template;\n        result = PyObject_Vectorcall(func, args, 2, NULL);\n        Py_DECREF(template);\n    }\n\n    if (result != NULL && Py_TYPE(result) != module_state->Template_Type) {\n        PyErr_Format(PyExc_RuntimeError,\n                    \"the result of compiling a replacement string is %.200s\",\n                    Py_TYPE(result)->tp_name);\n        Py_DECREF(result);\n        return NULL;\n    }\n    return result;\n}\n\nstatic PyObject *expand_template(TemplateObject *, MatchObject *); /* Forward */\n\nstatic PyObject*\npattern_subx(_sremodulestate* module_state,\n             PatternObject* self,\n             PyObject* ptemplate,\n             PyObject* string,\n             Py_ssize_t count,\n             Py_ssize_t subn)\n{\n    SRE_STATE state;\n    PyObject* list;\n    PyObject* joiner;\n    PyObject* item;\n    PyObject* filter;\n    PyObject* match;\n    const void* ptr;\n    Py_ssize_t status;\n    Py_ssize_t n;\n    Py_ssize_t i, b, e;\n    int isbytes, charsize;\n    enum {LITERAL, TEMPLATE, CALLABLE} filter_type;\n    Py_buffer view;\n\n    if (PyCallable_Check(ptemplate)) {\n        /* sub/subn takes either a function or a template */\n        filter = Py_NewRef(ptemplate);\n        filter_type = CALLABLE;\n    } else {\n        /* if not callable, check if it's a literal string */\n        int literal;\n        view.buf = NULL;\n        ptr = getstring(ptemplate, &n, &isbytes, &charsize, &view);\n        if (ptr) {\n            if (charsize == 1)\n                literal = memchr(ptr, '\\\\', n) == NULL;\n            else\n                literal = PyUnicode_FindChar(ptemplate, '\\\\', 0, n, 1) == -1;\n        } else {\n            PyErr_Clear();\n            literal = 0;\n        }\n        if (view.buf)\n            PyBuffer_Release(&view);\n        if (literal) {\n            filter = Py_NewRef(ptemplate);\n            filter_type = LITERAL;\n        } else {\n            /* not a literal; hand it over to the template compiler */\n            filter = compile_template(module_state, self, ptemplate);\n            if (!filter)\n                return NULL;\n\n            assert(Py_TYPE(filter) == module_state->Template_Type);\n            if (Py_SIZE(filter) == 0) {\n                Py_SETREF(filter,\n                          Py_NewRef(((TemplateObject *)filter)->literal));\n                filter_type = LITERAL;\n            }\n            else {\n                filter_type = TEMPLATE;\n            }\n        }\n    }\n\n    if (!state_init(&state, self, string, 0, PY_SSIZE_T_MAX)) {\n        Py_DECREF(filter);\n        return NULL;\n    }\n\n    list = PyList_New(0);\n    if (!list) {\n        Py_DECREF(filter);\n        state_fini(&state);\n        return NULL;\n    }\n\n    n = i = 0;\n\n    while (!count || n < count) {\n\n        state_reset(&state);\n\n        state.ptr = state.start;\n\n        status = sre_search(&state, PatternObject_GetCode(self));\n        if (PyErr_Occurred())\n            goto error;\n\n        if (status <= 0) {\n            if (status == 0)\n                break;\n            pattern_error(status);\n            goto error;\n        }\n\n        b = STATE_OFFSET(&state, state.start);\n        e = STATE_OFFSET(&state, state.ptr);\n\n        if (i < b) {\n            /* get segment before this match */\n            item = getslice(state.isbytes, state.beginning,\n                string, i, b);\n            if (!item)\n                goto error;\n            status = PyList_Append(list, item);\n            Py_DECREF(item);\n            if (status < 0)\n                goto error;\n\n        }\n\n        if (filter_type != LITERAL) {\n            /* pass match object through filter */\n            match = pattern_new_match(module_state, self, &state, 1);\n            if (!match)\n                goto error;\n            if (filter_type == TEMPLATE) {\n                item = expand_template((TemplateObject *)filter,\n                                       (MatchObject *)match);\n            }\n            else {\n                assert(filter_type == CALLABLE);\n                item = PyObject_CallOneArg(filter, match);\n            }\n            Py_DECREF(match);\n            if (!item)\n                goto error;\n        } else {\n            /* filter is literal string */\n            item = Py_NewRef(filter);\n        }\n\n        /* add to list */\n        if (item != Py_None) {\n            status = PyList_Append(list, item);\n            Py_DECREF(item);\n            if (status < 0)\n                goto error;\n        }\n\n        i = e;\n        n = n + 1;\n        state.must_advance = (state.ptr == state.start);\n        state.start = state.ptr;\n    }\n\n    /* get segment following last match */\n    if (i < state.endpos) {\n        item = getslice(state.isbytes, state.beginning,\n                        string, i, state.endpos);\n        if (!item)\n            goto error;\n        status = PyList_Append(list, item);\n        Py_DECREF(item);\n        if (status < 0)\n            goto error;\n    }\n\n    state_fini(&state);\n\n    Py_DECREF(filter);\n\n    /* convert list to single string (also removes list) */\n    joiner = getslice(state.isbytes, state.beginning, string, 0, 0);\n    if (!joiner) {\n        Py_DECREF(list);\n        return NULL;\n    }\n    if (PyList_GET_SIZE(list) == 0) {\n        Py_DECREF(list);\n        item = joiner;\n    }\n    else {\n        if (state.isbytes)\n            item = _PyBytes_Join(joiner, list);\n        else\n            item = PyUnicode_Join(joiner, list);\n        Py_DECREF(joiner);\n        Py_DECREF(list);\n        if (!item)\n            return NULL;\n    }\n\n    if (subn)\n        return Py_BuildValue(\"Nn\", item, n);\n\n    return item;\n\nerror:\n    Py_DECREF(list);\n    state_fini(&state);\n    Py_DECREF(filter);\n    return NULL;\n\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.sub\n\n    cls: defining_class\n    /\n    repl: object\n    string: object\n    count: Py_ssize_t = 0\n\nReturn the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl.\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Pattern_sub_impl(PatternObject *self, PyTypeObject *cls,\n                          PyObject *repl, PyObject *string, Py_ssize_t count)\n/*[clinic end generated code: output=4be141ab04bca60d input=d8d1d4ac2311a07c]*/\n{\n    _sremodulestate *module_state = get_sre_module_state_by_class(cls);\n\n    return pattern_subx(module_state, self, repl, string, count, 0);\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.subn\n\n    cls: defining_class\n    /\n    repl: object\n    string: object\n    count: Py_ssize_t = 0\n\nReturn the tuple (new_string, number_of_subs_made) found by replacing the leftmost non-overlapping occurrences of pattern with the replacement repl.\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Pattern_subn_impl(PatternObject *self, PyTypeObject *cls,\n                           PyObject *repl, PyObject *string,\n                           Py_ssize_t count)\n/*[clinic end generated code: output=da02fd85258b1e1f input=8b78a65b8302e58d]*/\n{\n    _sremodulestate *module_state = get_sre_module_state_by_class(cls);\n\n    return pattern_subx(module_state, self, repl, string, count, 1);\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.__copy__\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Pattern___copy___impl(PatternObject *self)\n/*[clinic end generated code: output=85dedc2db1bd8694 input=a730a59d863bc9f5]*/\n{\n    return Py_NewRef(self);\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.__deepcopy__\n\n    memo: object\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Pattern___deepcopy__(PatternObject *self, PyObject *memo)\n/*[clinic end generated code: output=2ad25679c1f1204a input=a465b1602f997bed]*/\n{\n    return Py_NewRef(self);\n}\n\nstatic PyObject *\npattern_repr(PatternObject *obj)\n{\n    static const struct {\n        const char *name;\n        int value;\n    } flag_names[] = {\n        {\"re.TEMPLATE\", SRE_FLAG_TEMPLATE},\n        {\"re.IGNORECASE\", SRE_FLAG_IGNORECASE},\n        {\"re.LOCALE\", SRE_FLAG_LOCALE},\n        {\"re.MULTILINE\", SRE_FLAG_MULTILINE},\n        {\"re.DOTALL\", SRE_FLAG_DOTALL},\n        {\"re.UNICODE\", SRE_FLAG_UNICODE},\n        {\"re.VERBOSE\", SRE_FLAG_VERBOSE},\n        {\"re.DEBUG\", SRE_FLAG_DEBUG},\n        {\"re.ASCII\", SRE_FLAG_ASCII},\n    };\n    PyObject *result = NULL;\n    PyObject *flag_items;\n    size_t i;\n    int flags = obj->flags;\n\n    /* Omit re.UNICODE for valid string patterns. */\n    if (obj->isbytes == 0 &&\n        (flags & (SRE_FLAG_LOCALE|SRE_FLAG_UNICODE|SRE_FLAG_ASCII)) ==\n         SRE_FLAG_UNICODE)\n        flags &= ~SRE_FLAG_UNICODE;\n\n    flag_items = PyList_New(0);\n    if (!flag_items)\n        return NULL;\n\n    for (i = 0; i < Py_ARRAY_LENGTH(flag_names); i++) {\n        if (flags & flag_names[i].value) {\n            PyObject *item = PyUnicode_FromString(flag_names[i].name);\n            if (!item)\n                goto done;\n\n            if (PyList_Append(flag_items, item) < 0) {\n                Py_DECREF(item);\n                goto done;\n            }\n            Py_DECREF(item);\n            flags &= ~flag_names[i].value;\n        }\n    }\n    if (flags) {\n        PyObject *item = PyUnicode_FromFormat(\"0x%x\", flags);\n        if (!item)\n            goto done;\n\n        if (PyList_Append(flag_items, item) < 0) {\n            Py_DECREF(item);\n            goto done;\n        }\n        Py_DECREF(item);\n    }\n\n    if (PyList_Size(flag_items) > 0) {\n        PyObject *flags_result;\n        PyObject *sep = PyUnicode_FromString(\"|\");\n        if (!sep)\n            goto done;\n        flags_result = PyUnicode_Join(sep, flag_items);\n        Py_DECREF(sep);\n        if (!flags_result)\n            goto done;\n        result = PyUnicode_FromFormat(\"re.compile(%.200R, %S)\",\n                                      obj->pattern, flags_result);\n        Py_DECREF(flags_result);\n    }\n    else {\n        result = PyUnicode_FromFormat(\"re.compile(%.200R)\", obj->pattern);\n    }\n\ndone:\n    Py_DECREF(flag_items);\n    return result;\n}\n\nPyDoc_STRVAR(pattern_doc, \"Compiled regular expression object.\");\n\n/* PatternObject's 'groupindex' method. */\nstatic PyObject *\npattern_groupindex(PatternObject *self, void *Py_UNUSED(ignored))\n{\n    if (self->groupindex == NULL)\n        return PyDict_New();\n    return PyDictProxy_New(self->groupindex);\n}\n\nstatic int _validate(PatternObject *self); /* Forward */\n\n/*[clinic input]\n_sre.compile\n\n    pattern: object\n    flags: int\n    code: object(subclass_of='&PyList_Type')\n    groups: Py_ssize_t\n    groupindex: object(subclass_of='&PyDict_Type')\n    indexgroup: object(subclass_of='&PyTuple_Type')\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_compile_impl(PyObject *module, PyObject *pattern, int flags,\n                  PyObject *code, Py_ssize_t groups, PyObject *groupindex,\n                  PyObject *indexgroup)\n/*[clinic end generated code: output=ef9c2b3693776404 input=0a68476dbbe5db30]*/\n{\n    /* \"compile\" pattern descriptor to pattern object */\n\n    _sremodulestate *module_state = get_sre_module_state(module);\n    PatternObject* self;\n    Py_ssize_t i, n;\n\n    n = PyList_GET_SIZE(code);\n    /* coverity[ampersand_in_size] */\n    self = PyObject_GC_NewVar(PatternObject, module_state->Pattern_Type, n);\n    if (!self)\n        return NULL;\n    self->weakreflist = NULL;\n    self->pattern = NULL;\n    self->groupindex = NULL;\n    self->indexgroup = NULL;\n\n    self->codesize = n;\n\n    for (i = 0; i < n; i++) {\n        PyObject *o = PyList_GET_ITEM(code, i);\n        unsigned long value = PyLong_AsUnsignedLong(o);\n        if (value == (unsigned long)-1 && PyErr_Occurred()) {\n            break;\n        }\n        self->code[i] = (SRE_CODE) value;\n        if ((unsigned long) self->code[i] != value) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"regular expression code size limit exceeded\");\n            break;\n        }\n    }\n    PyObject_GC_Track(self);\n\n    if (PyErr_Occurred()) {\n        Py_DECREF(self);\n        return NULL;\n    }\n\n    if (pattern == Py_None) {\n        self->isbytes = -1;\n    }\n    else {\n        Py_ssize_t p_length;\n        int charsize;\n        Py_buffer view;\n        view.buf = NULL;\n        if (!getstring(pattern, &p_length, &self->isbytes,\n                       &charsize, &view)) {\n            Py_DECREF(self);\n            return NULL;\n        }\n        if (view.buf)\n            PyBuffer_Release(&view);\n    }\n\n    self->pattern = Py_NewRef(pattern);\n\n    self->flags = flags;\n\n    self->groups = groups;\n\n    if (PyDict_GET_SIZE(groupindex) > 0) {\n        self->groupindex = Py_NewRef(groupindex);\n        if (PyTuple_GET_SIZE(indexgroup) > 0) {\n            self->indexgroup = Py_NewRef(indexgroup);\n        }\n    }\n\n    if (!_validate(self)) {\n        Py_DECREF(self);\n        return NULL;\n    }\n\n    return (PyObject*) self;\n}\n\n/*[clinic input]\n_sre.template\n\n    pattern: object\n    template: object(subclass_of=\"&PyList_Type\")\n        A list containing interleaved literal strings (str or bytes) and group\n        indices (int), as returned by re._parser.parse_template():\n            [literal1, group1, ..., literalN, groupN]\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_template_impl(PyObject *module, PyObject *pattern, PyObject *template)\n/*[clinic end generated code: output=d51290e596ebca86 input=af55380b27f02942]*/\n{\n    /* template is a list containing interleaved literal strings (str or bytes)\n     * and group indices (int), as returned by _parser.parse_template:\n     * [literal1, group1, literal2, ..., literalN].\n     */\n    _sremodulestate *module_state = get_sre_module_state(module);\n    TemplateObject *self = NULL;\n    Py_ssize_t n = PyList_GET_SIZE(template);\n    if ((n & 1) == 0 || n < 1) {\n        goto bad_template;\n    }\n    n /= 2;\n    self = PyObject_GC_NewVar(TemplateObject, module_state->Template_Type, n);\n    if (!self)\n        return NULL;\n    self->chunks = 1 + 2*n;\n    self->literal = Py_NewRef(PyList_GET_ITEM(template, 0));\n    for (Py_ssize_t i = 0; i < n; i++) {\n        Py_ssize_t index = PyLong_AsSsize_t(PyList_GET_ITEM(template, 2*i+1));\n        if (index == -1 && PyErr_Occurred()) {\n            Py_SET_SIZE(self, i);\n            Py_DECREF(self);\n            return NULL;\n        }\n        if (index < 0) {\n            Py_SET_SIZE(self, i);\n            goto bad_template;\n        }\n        self->items[i].index = index;\n\n        PyObject *literal = PyList_GET_ITEM(template, 2*i+2);\n        // Skip empty literals.\n        if ((PyUnicode_Check(literal) && !PyUnicode_GET_LENGTH(literal)) ||\n            (PyBytes_Check(literal) && !PyBytes_GET_SIZE(literal)))\n        {\n            literal = NULL;\n            self->chunks--;\n        }\n        self->items[i].literal = Py_XNewRef(literal);\n    }\n    return (PyObject*) self;\n\nbad_template:\n    PyErr_SetString(PyExc_TypeError, \"invalid template\");\n    Py_XDECREF(self);\n    return NULL;\n}\n\n/* -------------------------------------------------------------------- */\n/* Code validation */\n\n/* To learn more about this code, have a look at the _compile() function in\n   Lib/sre_compile.py.  The validation functions below checks the code array\n   for conformance with the code patterns generated there.\n\n   The nice thing about the generated code is that it is position-independent:\n   all jumps are relative jumps forward.  Also, jumps don't cross each other:\n   the target of a later jump is always earlier than the target of an earlier\n   jump.  IOW, this is okay:\n\n   J---------J-------T--------T\n    \\         \\_____/        /\n     \\______________________/\n\n   but this is not:\n\n   J---------J-------T--------T\n    \\_________\\_____/        /\n               \\____________/\n\n   It also helps that SRE_CODE is always an unsigned type.\n*/\n\n/* Defining this one enables tracing of the validator */\n#undef VVERBOSE\n\n/* Trace macro for the validator */\n#if defined(VVERBOSE)\n#define VTRACE(v) printf v\n#else\n#define VTRACE(v) do {} while(0)  /* do nothing */\n#endif\n\n/* Report failure */\n#define FAIL do { VTRACE((\"FAIL: %d\\n\", __LINE__)); return -1; } while (0)\n\n/* Extract opcode, argument, or skip count from code array */\n#define GET_OP                                          \\\n    do {                                                \\\n        VTRACE((\"%p: \", code));                         \\\n        if (code >= end) FAIL;                          \\\n        op = *code++;                                   \\\n        VTRACE((\"%lu (op)\\n\", (unsigned long)op));      \\\n    } while (0)\n#define GET_ARG                                         \\\n    do {                                                \\\n        VTRACE((\"%p= \", code));                         \\\n        if (code >= end) FAIL;                          \\\n        arg = *code++;                                  \\\n        VTRACE((\"%lu (arg)\\n\", (unsigned long)arg));    \\\n    } while (0)\n#define GET_SKIP_ADJ(adj)                               \\\n    do {                                                \\\n        VTRACE((\"%p= \", code));                         \\\n        if (code >= end) FAIL;                          \\\n        skip = *code;                                   \\\n        VTRACE((\"%lu (skip to %p)\\n\",                   \\\n               (unsigned long)skip, code+skip));        \\\n        if (skip-adj > (uintptr_t)(end - code))         \\\n            FAIL;                                       \\\n        code++;                                         \\\n    } while (0)\n#define GET_SKIP GET_SKIP_ADJ(0)\n\nstatic int\n_validate_charset(SRE_CODE *code, SRE_CODE *end)\n{\n    /* Some variables are manipulated by the macros above */\n    SRE_CODE op;\n    SRE_CODE arg;\n    SRE_CODE offset;\n    int i;\n\n    while (code < end) {\n        GET_OP;\n        switch (op) {\n\n        case SRE_OP_NEGATE:\n            break;\n\n        case SRE_OP_LITERAL:\n            GET_ARG;\n            break;\n\n        case SRE_OP_RANGE:\n        case SRE_OP_RANGE_UNI_IGNORE:\n            GET_ARG;\n            GET_ARG;\n            break;\n\n        case SRE_OP_CHARSET:\n            offset = 256/SRE_CODE_BITS; /* 256-bit bitmap */\n            if (offset > (uintptr_t)(end - code))\n                FAIL;\n            code += offset;\n            break;\n\n        case SRE_OP_BIGCHARSET:\n            GET_ARG; /* Number of blocks */\n            offset = 256/sizeof(SRE_CODE); /* 256-byte table */\n            if (offset > (uintptr_t)(end - code))\n                FAIL;\n            /* Make sure that each byte points to a valid block */\n            for (i = 0; i < 256; i++) {\n                if (((unsigned char *)code)[i] >= arg)\n                    FAIL;\n            }\n            code += offset;\n            offset = arg * (256/SRE_CODE_BITS); /* 256-bit bitmap times arg */\n            if (offset > (uintptr_t)(end - code))\n                FAIL;\n            code += offset;\n            break;\n\n        case SRE_OP_CATEGORY:\n            GET_ARG;\n            switch (arg) {\n            case SRE_CATEGORY_DIGIT:\n            case SRE_CATEGORY_NOT_DIGIT:\n            case SRE_CATEGORY_SPACE:\n            case SRE_CATEGORY_NOT_SPACE:\n            case SRE_CATEGORY_WORD:\n            case SRE_CATEGORY_NOT_WORD:\n            case SRE_CATEGORY_LINEBREAK:\n            case SRE_CATEGORY_NOT_LINEBREAK:\n            case SRE_CATEGORY_LOC_WORD:\n            case SRE_CATEGORY_LOC_NOT_WORD:\n            case SRE_CATEGORY_UNI_DIGIT:\n            case SRE_CATEGORY_UNI_NOT_DIGIT:\n            case SRE_CATEGORY_UNI_SPACE:\n            case SRE_CATEGORY_UNI_NOT_SPACE:\n            case SRE_CATEGORY_UNI_WORD:\n            case SRE_CATEGORY_UNI_NOT_WORD:\n            case SRE_CATEGORY_UNI_LINEBREAK:\n            case SRE_CATEGORY_UNI_NOT_LINEBREAK:\n                break;\n            default:\n                FAIL;\n            }\n            break;\n\n        default:\n            FAIL;\n\n        }\n    }\n\n    return 0;\n}\n\n/* Returns 0 on success, -1 on failure, and 1 if the last op is JUMP. */\nstatic int\n_validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)\n{\n    /* Some variables are manipulated by the macros above */\n    SRE_CODE op;\n    SRE_CODE arg;\n    SRE_CODE skip;\n\n    VTRACE((\"code=%p, end=%p\\n\", code, end));\n\n    if (code > end)\n        FAIL;\n\n    while (code < end) {\n        GET_OP;\n        switch (op) {\n\n        case SRE_OP_MARK:\n            /* We don't check whether marks are properly nested; the\n               sre_match() code is robust even if they don't, and the worst\n               you can get is nonsensical match results. */\n            GET_ARG;\n            if (arg > 2 * (size_t)groups + 1) {\n                VTRACE((\"arg=%d, groups=%d\\n\", (int)arg, (int)groups));\n                FAIL;\n            }\n            break;\n\n        case SRE_OP_LITERAL:\n        case SRE_OP_NOT_LITERAL:\n        case SRE_OP_LITERAL_IGNORE:\n        case SRE_OP_NOT_LITERAL_IGNORE:\n        case SRE_OP_LITERAL_UNI_IGNORE:\n        case SRE_OP_NOT_LITERAL_UNI_IGNORE:\n        case SRE_OP_LITERAL_LOC_IGNORE:\n        case SRE_OP_NOT_LITERAL_LOC_IGNORE:\n            GET_ARG;\n            /* The arg is just a character, nothing to check */\n            break;\n\n        case SRE_OP_SUCCESS:\n        case SRE_OP_FAILURE:\n            /* Nothing to check; these normally end the matching process */\n            break;\n\n        case SRE_OP_AT:\n            GET_ARG;\n            switch (arg) {\n            case SRE_AT_BEGINNING:\n            case SRE_AT_BEGINNING_STRING:\n            case SRE_AT_BEGINNING_LINE:\n            case SRE_AT_END:\n            case SRE_AT_END_LINE:\n            case SRE_AT_END_STRING:\n            case SRE_AT_BOUNDARY:\n            case SRE_AT_NON_BOUNDARY:\n            case SRE_AT_LOC_BOUNDARY:\n            case SRE_AT_LOC_NON_BOUNDARY:\n            case SRE_AT_UNI_BOUNDARY:\n            case SRE_AT_UNI_NON_BOUNDARY:\n                break;\n            default:\n                FAIL;\n            }\n            break;\n\n        case SRE_OP_ANY:\n        case SRE_OP_ANY_ALL:\n            /* These have no operands */\n            break;\n\n        case SRE_OP_IN:\n        case SRE_OP_IN_IGNORE:\n        case SRE_OP_IN_UNI_IGNORE:\n        case SRE_OP_IN_LOC_IGNORE:\n            GET_SKIP;\n            /* Stop 1 before the end; we check the FAILURE below */\n            if (_validate_charset(code, code+skip-2))\n                FAIL;\n            if (code[skip-2] != SRE_OP_FAILURE)\n                FAIL;\n            code += skip-1;\n            break;\n\n        case SRE_OP_INFO:\n            {\n                /* A minimal info field is\n                   <INFO> <1=skip> <2=flags> <3=min> <4=max>;\n                   If SRE_INFO_PREFIX or SRE_INFO_CHARSET is in the flags,\n                   more follows. */\n                SRE_CODE flags, i;\n                SRE_CODE *newcode;\n                GET_SKIP;\n                newcode = code+skip-1;\n                GET_ARG; flags = arg;\n                GET_ARG;\n                GET_ARG;\n                /* Check that only valid flags are present */\n                if ((flags & ~(SRE_INFO_PREFIX |\n                               SRE_INFO_LITERAL |\n                               SRE_INFO_CHARSET)) != 0)\n                    FAIL;\n                /* PREFIX and CHARSET are mutually exclusive */\n                if ((flags & SRE_INFO_PREFIX) &&\n                    (flags & SRE_INFO_CHARSET))\n                    FAIL;\n                /* LITERAL implies PREFIX */\n                if ((flags & SRE_INFO_LITERAL) &&\n                    !(flags & SRE_INFO_PREFIX))\n                    FAIL;\n                /* Validate the prefix */\n                if (flags & SRE_INFO_PREFIX) {\n                    SRE_CODE prefix_len;\n                    GET_ARG; prefix_len = arg;\n                    GET_ARG;\n                    /* Here comes the prefix string */\n                    if (prefix_len > (uintptr_t)(newcode - code))\n                        FAIL;\n                    code += prefix_len;\n                    /* And here comes the overlap table */\n                    if (prefix_len > (uintptr_t)(newcode - code))\n                        FAIL;\n                    /* Each overlap value should be < prefix_len */\n                    for (i = 0; i < prefix_len; i++) {\n                        if (code[i] >= prefix_len)\n                            FAIL;\n                    }\n                    code += prefix_len;\n                }\n                /* Validate the charset */\n                if (flags & SRE_INFO_CHARSET) {\n                    if (_validate_charset(code, newcode-1))\n                        FAIL;\n                    if (newcode[-1] != SRE_OP_FAILURE)\n                        FAIL;\n                    code = newcode;\n                }\n                else if (code != newcode) {\n                  VTRACE((\"code=%p, newcode=%p\\n\", code, newcode));\n                    FAIL;\n                }\n            }\n            break;\n\n        case SRE_OP_BRANCH:\n            {\n                SRE_CODE *target = NULL;\n                for (;;) {\n                    GET_SKIP;\n                    if (skip == 0)\n                        break;\n                    /* Stop 2 before the end; we check the JUMP below */\n                    if (_validate_inner(code, code+skip-3, groups))\n                        FAIL;\n                    code += skip-3;\n                    /* Check that it ends with a JUMP, and that each JUMP\n                       has the same target */\n                    GET_OP;\n                    if (op != SRE_OP_JUMP)\n                        FAIL;\n                    GET_SKIP;\n                    if (target == NULL)\n                        target = code+skip-1;\n                    else if (code+skip-1 != target)\n                        FAIL;\n                }\n                if (code != target)\n                    FAIL;\n            }\n            break;\n\n        case SRE_OP_REPEAT_ONE:\n        case SRE_OP_MIN_REPEAT_ONE:\n        case SRE_OP_POSSESSIVE_REPEAT_ONE:\n            {\n                SRE_CODE min, max;\n                GET_SKIP;\n                GET_ARG; min = arg;\n                GET_ARG; max = arg;\n                if (min > max)\n                    FAIL;\n                if (max > SRE_MAXREPEAT)\n                    FAIL;\n                if (_validate_inner(code, code+skip-4, groups))\n                    FAIL;\n                code += skip-4;\n                GET_OP;\n                if (op != SRE_OP_SUCCESS)\n                    FAIL;\n            }\n            break;\n\n        case SRE_OP_REPEAT:\n        case SRE_OP_POSSESSIVE_REPEAT:\n            {\n                SRE_CODE op1 = op, min, max;\n                GET_SKIP;\n                GET_ARG; min = arg;\n                GET_ARG; max = arg;\n                if (min > max)\n                    FAIL;\n                if (max > SRE_MAXREPEAT)\n                    FAIL;\n                if (_validate_inner(code, code+skip-3, groups))\n                    FAIL;\n                code += skip-3;\n                GET_OP;\n                if (op1 == SRE_OP_POSSESSIVE_REPEAT) {\n                    if (op != SRE_OP_SUCCESS)\n                        FAIL;\n                }\n                else {\n                    if (op != SRE_OP_MAX_UNTIL && op != SRE_OP_MIN_UNTIL)\n                        FAIL;\n                }\n            }\n            break;\n\n        case SRE_OP_ATOMIC_GROUP:\n            {\n                GET_SKIP;\n                if (_validate_inner(code, code+skip-2, groups))\n                    FAIL;\n                code += skip-2;\n                GET_OP;\n                if (op != SRE_OP_SUCCESS)\n                    FAIL;\n            }\n            break;\n\n        case SRE_OP_GROUPREF:\n        case SRE_OP_GROUPREF_IGNORE:\n        case SRE_OP_GROUPREF_UNI_IGNORE:\n        case SRE_OP_GROUPREF_LOC_IGNORE:\n            GET_ARG;\n            if (arg >= (size_t)groups)\n                FAIL;\n            break;\n\n        case SRE_OP_GROUPREF_EXISTS:\n            /* The regex syntax for this is: '(?(group)then|else)', where\n               'group' is either an integer group number or a group name,\n               'then' and 'else' are sub-regexes, and 'else' is optional. */\n            GET_ARG;\n            if (arg >= (size_t)groups)\n                FAIL;\n            GET_SKIP_ADJ(1);\n            code--; /* The skip is relative to the first arg! */\n            /* There are two possibilities here: if there is both a 'then'\n               part and an 'else' part, the generated code looks like:\n\n               GROUPREF_EXISTS\n               <group>\n               <skipyes>\n               ...then part...\n               JUMP\n               <skipno>\n               (<skipyes> jumps here)\n               ...else part...\n               (<skipno> jumps here)\n\n               If there is only a 'then' part, it looks like:\n\n               GROUPREF_EXISTS\n               <group>\n               <skip>\n               ...then part...\n               (<skip> jumps here)\n\n               There is no direct way to decide which it is, and we don't want\n               to allow arbitrary jumps anywhere in the code; so we just look\n               for a JUMP opcode preceding our skip target.\n            */\n            VTRACE((\"then part:\\n\"));\n            int rc = _validate_inner(code+1, code+skip-1, groups);\n            if (rc == 1) {\n                VTRACE((\"else part:\\n\"));\n                code += skip-2; /* Position after JUMP, at <skipno> */\n                GET_SKIP;\n                rc = _validate_inner(code, code+skip-1, groups);\n            }\n            if (rc)\n                FAIL;\n            code += skip-1;\n            break;\n\n        case SRE_OP_ASSERT:\n        case SRE_OP_ASSERT_NOT:\n            GET_SKIP;\n            GET_ARG; /* 0 for lookahead, width for lookbehind */\n            code--; /* Back up over arg to simplify math below */\n            /* Stop 1 before the end; we check the SUCCESS below */\n            if (_validate_inner(code+1, code+skip-2, groups))\n                FAIL;\n            code += skip-2;\n            GET_OP;\n            if (op != SRE_OP_SUCCESS)\n                FAIL;\n            break;\n\n        case SRE_OP_JUMP:\n            if (code + 1 != end)\n                FAIL;\n            VTRACE((\"JUMP: %d\\n\", __LINE__));\n            return 1;\n\n        default:\n            FAIL;\n\n        }\n    }\n\n    VTRACE((\"okay\\n\"));\n    return 0;\n}\n\nstatic int\n_validate_outer(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)\n{\n    if (groups < 0 || (size_t)groups > SRE_MAXGROUPS ||\n        code >= end || end[-1] != SRE_OP_SUCCESS)\n        FAIL;\n    return _validate_inner(code, end-1, groups);\n}\n\nstatic int\n_validate(PatternObject *self)\n{\n    if (_validate_outer(self->code, self->code+self->codesize, self->groups))\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"invalid SRE code\");\n        return 0;\n    }\n    else\n        VTRACE((\"Success!\\n\"));\n    return 1;\n}\n\n/* -------------------------------------------------------------------- */\n/* match methods */\n\nstatic int\nmatch_traverse(MatchObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(self));\n    Py_VISIT(self->string);\n    Py_VISIT(self->regs);\n    Py_VISIT(self->pattern);\n    return 0;\n}\n\nstatic int\nmatch_clear(MatchObject *self)\n{\n    Py_CLEAR(self->string);\n    Py_CLEAR(self->regs);\n    Py_CLEAR(self->pattern);\n    return 0;\n}\n\nstatic void\nmatch_dealloc(MatchObject* self)\n{\n    PyTypeObject *tp = Py_TYPE(self);\n\n    PyObject_GC_UnTrack(self);\n    (void)match_clear(self);\n    tp->tp_free(self);\n    Py_DECREF(tp);\n}\n\nstatic PyObject*\nmatch_getslice_by_index(MatchObject* self, Py_ssize_t index, PyObject* def)\n{\n    Py_ssize_t length;\n    int isbytes, charsize;\n    Py_buffer view;\n    PyObject *result;\n    const void* ptr;\n    Py_ssize_t i, j;\n\n    assert(0 <= index && index < self->groups);\n    index *= 2;\n\n    if (self->string == Py_None || self->mark[index] < 0) {\n        /* return default value if the string or group is undefined */\n        return Py_NewRef(def);\n    }\n\n    ptr = getstring(self->string, &length, &isbytes, &charsize, &view);\n    if (ptr == NULL)\n        return NULL;\n\n    i = self->mark[index];\n    j = self->mark[index+1];\n    i = Py_MIN(i, length);\n    j = Py_MIN(j, length);\n    result = getslice(isbytes, ptr, self->string, i, j);\n    if (isbytes && view.buf != NULL)\n        PyBuffer_Release(&view);\n    return result;\n}\n\nstatic Py_ssize_t\nmatch_getindex(MatchObject* self, PyObject* index)\n{\n    Py_ssize_t i;\n\n    if (index == NULL)\n        /* Default value */\n        return 0;\n\n    if (PyIndex_Check(index)) {\n        i = PyNumber_AsSsize_t(index, NULL);\n    }\n    else {\n        i = -1;\n\n        if (self->pattern->groupindex) {\n            index = PyDict_GetItemWithError(self->pattern->groupindex, index);\n            if (index && PyLong_Check(index)) {\n                i = PyLong_AsSsize_t(index);\n            }\n        }\n    }\n    if (i < 0 || i >= self->groups) {\n        /* raise IndexError if we were given a bad group number */\n        if (!PyErr_Occurred()) {\n            PyErr_SetString(PyExc_IndexError, \"no such group\");\n        }\n        return -1;\n    }\n\n    return i;\n}\n\nstatic PyObject*\nmatch_getslice(MatchObject* self, PyObject* index, PyObject* def)\n{\n    Py_ssize_t i = match_getindex(self, index);\n\n    if (i < 0) {\n        return NULL;\n    }\n\n    return match_getslice_by_index(self, i, def);\n}\n\n/*[clinic input]\n_sre.SRE_Match.expand\n\n    template: object\n\nReturn the string obtained by doing backslash substitution on the string template, as done by the sub() method.\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Match_expand_impl(MatchObject *self, PyObject *template)\n/*[clinic end generated code: output=931b58ccc323c3a1 input=4bfdb22c2f8b146a]*/\n{\n    _sremodulestate *module_state = get_sre_module_state_by_class(Py_TYPE(self));\n    PyObject *filter = compile_template(module_state, self->pattern, template);\n    if (filter == NULL) {\n        return NULL;\n    }\n    PyObject *result = expand_template((TemplateObject *)filter, self);\n    Py_DECREF(filter);\n    return result;\n}\n\nstatic PyObject*\nmatch_group(MatchObject* self, PyObject* args)\n{\n    PyObject* result;\n    Py_ssize_t i, size;\n\n    size = PyTuple_GET_SIZE(args);\n\n    switch (size) {\n    case 0:\n        result = match_getslice(self, _PyLong_GetZero(), Py_None);\n        break;\n    case 1:\n        result = match_getslice(self, PyTuple_GET_ITEM(args, 0), Py_None);\n        break;\n    default:\n        /* fetch multiple items */\n        result = PyTuple_New(size);\n        if (!result)\n            return NULL;\n        for (i = 0; i < size; i++) {\n            PyObject* item = match_getslice(\n                self, PyTuple_GET_ITEM(args, i), Py_None\n                );\n            if (!item) {\n                Py_DECREF(result);\n                return NULL;\n            }\n            PyTuple_SET_ITEM(result, i, item);\n        }\n        break;\n    }\n    return result;\n}\n\nstatic PyObject*\nmatch_getitem(MatchObject* self, PyObject* name)\n{\n    return match_getslice(self, name, Py_None);\n}\n\n/*[clinic input]\n_sre.SRE_Match.groups\n\n    default: object = None\n        Is used for groups that did not participate in the match.\n\nReturn a tuple containing all the subgroups of the match, from 1.\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Match_groups_impl(MatchObject *self, PyObject *default_value)\n/*[clinic end generated code: output=daf8e2641537238a input=bb069ef55dabca91]*/\n{\n    PyObject* result;\n    Py_ssize_t index;\n\n    result = PyTuple_New(self->groups-1);\n    if (!result)\n        return NULL;\n\n    for (index = 1; index < self->groups; index++) {\n        PyObject* item;\n        item = match_getslice_by_index(self, index, default_value);\n        if (!item) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        PyTuple_SET_ITEM(result, index-1, item);\n    }\n\n    return result;\n}\n\n/*[clinic input]\n_sre.SRE_Match.groupdict\n\n    default: object = None\n        Is used for groups that did not participate in the match.\n\nReturn a dictionary containing all the named subgroups of the match, keyed by the subgroup name.\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Match_groupdict_impl(MatchObject *self, PyObject *default_value)\n/*[clinic end generated code: output=29917c9073e41757 input=0ded7960b23780aa]*/\n{\n    PyObject *result;\n    PyObject *key;\n    PyObject *value;\n    Py_ssize_t pos = 0;\n    Py_hash_t hash;\n\n    result = PyDict_New();\n    if (!result || !self->pattern->groupindex)\n        return result;\n\n    while (_PyDict_Next(self->pattern->groupindex, &pos, &key, &value, &hash)) {\n        int status;\n        Py_INCREF(key);\n        value = match_getslice(self, key, default_value);\n        if (!value) {\n            Py_DECREF(key);\n            goto failed;\n        }\n        status = _PyDict_SetItem_KnownHash(result, key, value, hash);\n        Py_DECREF(value);\n        Py_DECREF(key);\n        if (status < 0)\n            goto failed;\n    }\n\n    return result;\n\nfailed:\n    Py_DECREF(result);\n    return NULL;\n}\n\n/*[clinic input]\n_sre.SRE_Match.start -> Py_ssize_t\n\n    group: object(c_default=\"NULL\") = 0\n    /\n\nReturn index of the start of the substring matched by group.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\n_sre_SRE_Match_start_impl(MatchObject *self, PyObject *group)\n/*[clinic end generated code: output=3f6e7f9df2fb5201 input=ced8e4ed4b33ee6c]*/\n{\n    Py_ssize_t index = match_getindex(self, group);\n\n    if (index < 0) {\n        return -1;\n    }\n\n    /* mark is -1 if group is undefined */\n    return self->mark[index*2];\n}\n\n/*[clinic input]\n_sre.SRE_Match.end -> Py_ssize_t\n\n    group: object(c_default=\"NULL\") = 0\n    /\n\nReturn index of the end of the substring matched by group.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\n_sre_SRE_Match_end_impl(MatchObject *self, PyObject *group)\n/*[clinic end generated code: output=f4240b09911f7692 input=1b799560c7f3d7e6]*/\n{\n    Py_ssize_t index = match_getindex(self, group);\n\n    if (index < 0) {\n        return -1;\n    }\n\n    /* mark is -1 if group is undefined */\n    return self->mark[index*2+1];\n}\n\nLOCAL(PyObject*)\n_pair(Py_ssize_t i1, Py_ssize_t i2)\n{\n    PyObject* pair;\n    PyObject* item;\n\n    pair = PyTuple_New(2);\n    if (!pair)\n        return NULL;\n\n    item = PyLong_FromSsize_t(i1);\n    if (!item)\n        goto error;\n    PyTuple_SET_ITEM(pair, 0, item);\n\n    item = PyLong_FromSsize_t(i2);\n    if (!item)\n        goto error;\n    PyTuple_SET_ITEM(pair, 1, item);\n\n    return pair;\n\n  error:\n    Py_DECREF(pair);\n    return NULL;\n}\n\n/*[clinic input]\n_sre.SRE_Match.span\n\n    group: object(c_default=\"NULL\") = 0\n    /\n\nFor match object m, return the 2-tuple (m.start(group), m.end(group)).\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Match_span_impl(MatchObject *self, PyObject *group)\n/*[clinic end generated code: output=f02ae40594d14fe6 input=8fa6014e982d71d4]*/\n{\n    Py_ssize_t index = match_getindex(self, group);\n\n    if (index < 0) {\n        return NULL;\n    }\n\n    /* marks are -1 if group is undefined */\n    return _pair(self->mark[index*2], self->mark[index*2+1]);\n}\n\nstatic PyObject*\nmatch_regs(MatchObject* self)\n{\n    PyObject* regs;\n    PyObject* item;\n    Py_ssize_t index;\n\n    regs = PyTuple_New(self->groups);\n    if (!regs)\n        return NULL;\n\n    for (index = 0; index < self->groups; index++) {\n        item = _pair(self->mark[index*2], self->mark[index*2+1]);\n        if (!item) {\n            Py_DECREF(regs);\n            return NULL;\n        }\n        PyTuple_SET_ITEM(regs, index, item);\n    }\n\n    self->regs = Py_NewRef(regs);\n\n    return regs;\n}\n\n/*[clinic input]\n_sre.SRE_Match.__copy__\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Match___copy___impl(MatchObject *self)\n/*[clinic end generated code: output=a779c5fc8b5b4eb4 input=3bb4d30b6baddb5b]*/\n{\n    return Py_NewRef(self);\n}\n\n/*[clinic input]\n_sre.SRE_Match.__deepcopy__\n\n    memo: object\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Match___deepcopy__(MatchObject *self, PyObject *memo)\n/*[clinic end generated code: output=ba7cb46d655e4ee2 input=779d12a31c2c325e]*/\n{\n    return Py_NewRef(self);\n}\n\nPyDoc_STRVAR(match_doc,\n\"The result of re.match() and re.search().\\n\\\nMatch objects always have a boolean value of True.\");\n\nPyDoc_STRVAR(match_group_doc,\n\"group([group1, ...]) -> str or tuple.\\n\\\n    Return subgroup(s) of the match by indices or names.\\n\\\n    For 0 returns the entire match.\");\n\nstatic PyObject *\nmatch_lastindex_get(MatchObject *self, void *Py_UNUSED(ignored))\n{\n    if (self->lastindex >= 0)\n        return PyLong_FromSsize_t(self->lastindex);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nmatch_lastgroup_get(MatchObject *self, void *Py_UNUSED(ignored))\n{\n    if (self->pattern->indexgroup &&\n        self->lastindex >= 0 &&\n        self->lastindex < PyTuple_GET_SIZE(self->pattern->indexgroup))\n    {\n        PyObject *result = PyTuple_GET_ITEM(self->pattern->indexgroup,\n                                            self->lastindex);\n        return Py_NewRef(result);\n    }\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nmatch_regs_get(MatchObject *self, void *Py_UNUSED(ignored))\n{\n    if (self->regs) {\n        return Py_NewRef(self->regs);\n    } else\n        return match_regs(self);\n}\n\nstatic PyObject *\nmatch_repr(MatchObject *self)\n{\n    PyObject *result;\n    PyObject *group0 = match_getslice_by_index(self, 0, Py_None);\n    if (group0 == NULL)\n        return NULL;\n    result = PyUnicode_FromFormat(\n            \"<%s object; span=(%zd, %zd), match=%.50R>\",\n            Py_TYPE(self)->tp_name,\n            self->mark[0], self->mark[1], group0);\n    Py_DECREF(group0);\n    return result;\n}\n\n\nstatic PyObject*\npattern_new_match(_sremodulestate* module_state,\n                  PatternObject* pattern,\n                  SRE_STATE* state,\n                  Py_ssize_t status)\n{\n    /* create match object (from state object) */\n\n    MatchObject* match;\n    Py_ssize_t i, j;\n    char* base;\n    int n;\n\n    if (status > 0) {\n\n        /* create match object (with room for extra group marks) */\n        /* coverity[ampersand_in_size] */\n        match = PyObject_GC_NewVar(MatchObject,\n                                   module_state->Match_Type,\n                                   2*(pattern->groups+1));\n        if (!match)\n            return NULL;\n\n        match->pattern = (PatternObject*)Py_NewRef(pattern);\n\n        match->string = Py_NewRef(state->string);\n\n        match->regs = NULL;\n        match->groups = pattern->groups+1;\n\n        /* fill in group slices */\n\n        base = (char*) state->beginning;\n        n = state->charsize;\n\n        match->mark[0] = ((char*) state->start - base) / n;\n        match->mark[1] = ((char*) state->ptr - base) / n;\n\n        for (i = j = 0; i < pattern->groups; i++, j+=2)\n            if (j+1 <= state->lastmark && state->mark[j] && state->mark[j+1]) {\n                match->mark[j+2] = ((char*) state->mark[j] - base) / n;\n                match->mark[j+3] = ((char*) state->mark[j+1] - base) / n;\n\n                /* check wrong span */\n                if (match->mark[j+2] > match->mark[j+3]) {\n                    PyErr_SetString(PyExc_SystemError,\n                                    \"The span of capturing group is wrong,\"\n                                    \" please report a bug for the re module.\");\n                    Py_DECREF(match);\n                    return NULL;\n                }\n            } else\n                match->mark[j+2] = match->mark[j+3] = -1; /* undefined */\n\n        match->pos = state->pos;\n        match->endpos = state->endpos;\n\n        match->lastindex = state->lastindex;\n\n        PyObject_GC_Track(match);\n        return (PyObject*) match;\n\n    } else if (status == 0) {\n\n        /* no match */\n        Py_RETURN_NONE;\n\n    }\n\n    /* internal error */\n    pattern_error(status);\n    return NULL;\n}\n\n\n/* -------------------------------------------------------------------- */\n/* scanner methods (experimental) */\n\nstatic int\nscanner_traverse(ScannerObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(self));\n    Py_VISIT(self->pattern);\n    return 0;\n}\n\nstatic int\nscanner_clear(ScannerObject *self)\n{\n    Py_CLEAR(self->pattern);\n    return 0;\n}\n\nstatic void\nscanner_dealloc(ScannerObject* self)\n{\n    PyTypeObject *tp = Py_TYPE(self);\n\n    PyObject_GC_UnTrack(self);\n    state_fini(&self->state);\n    (void)scanner_clear(self);\n    tp->tp_free(self);\n    Py_DECREF(tp);\n}\n\nstatic int\nscanner_begin(ScannerObject* self)\n{\n    if (self->executing) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"regular expression scanner already executing\");\n        return 0;\n    }\n    self->executing = 1;\n    return 1;\n}\n\nstatic void\nscanner_end(ScannerObject* self)\n{\n    assert(self->executing);\n    self->executing = 0;\n}\n\n/*[clinic input]\n_sre.SRE_Scanner.match\n\n    cls: defining_class\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Scanner_match_impl(ScannerObject *self, PyTypeObject *cls)\n/*[clinic end generated code: output=6e22c149dc0f0325 input=b5146e1f30278cb7]*/\n{\n    _sremodulestate *module_state = get_sre_module_state_by_class(cls);\n    SRE_STATE* state = &self->state;\n    PyObject* match;\n    Py_ssize_t status;\n\n    if (!scanner_begin(self)) {\n        return NULL;\n    }\n    if (state->start == NULL) {\n        scanner_end(self);\n        Py_RETURN_NONE;\n    }\n\n    state_reset(state);\n\n    state->ptr = state->start;\n\n    status = sre_match(state, PatternObject_GetCode(self->pattern));\n    if (PyErr_Occurred()) {\n        scanner_end(self);\n        return NULL;\n    }\n\n    match = pattern_new_match(module_state, (PatternObject*) self->pattern,\n                              state, status);\n\n    if (status == 0)\n        state->start = NULL;\n    else {\n        state->must_advance = (state->ptr == state->start);\n        state->start = state->ptr;\n    }\n\n    scanner_end(self);\n    return match;\n}\n\n\n/*[clinic input]\n_sre.SRE_Scanner.search\n\n    cls: defining_class\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_sre_SRE_Scanner_search_impl(ScannerObject *self, PyTypeObject *cls)\n/*[clinic end generated code: output=23e8fc78013f9161 input=056c2d37171d0bf2]*/\n{\n    _sremodulestate *module_state = get_sre_module_state_by_class(cls);\n    SRE_STATE* state = &self->state;\n    PyObject* match;\n    Py_ssize_t status;\n\n    if (!scanner_begin(self)) {\n        return NULL;\n    }\n    if (state->start == NULL) {\n        scanner_end(self);\n        Py_RETURN_NONE;\n    }\n\n    state_reset(state);\n\n    state->ptr = state->start;\n\n    status = sre_search(state, PatternObject_GetCode(self->pattern));\n    if (PyErr_Occurred()) {\n        scanner_end(self);\n        return NULL;\n    }\n\n    match = pattern_new_match(module_state, (PatternObject*) self->pattern,\n                              state, status);\n\n    if (status == 0)\n        state->start = NULL;\n    else {\n        state->must_advance = (state->ptr == state->start);\n        state->start = state->ptr;\n    }\n\n    scanner_end(self);\n    return match;\n}\n\nstatic PyObject *\npattern_scanner(_sremodulestate *module_state,\n                PatternObject *self,\n                PyObject *string,\n                Py_ssize_t pos,\n                Py_ssize_t endpos)\n{\n    ScannerObject* scanner;\n\n    /* create scanner object */\n    scanner = PyObject_GC_New(ScannerObject, module_state->Scanner_Type);\n    if (!scanner)\n        return NULL;\n    scanner->pattern = NULL;\n    scanner->executing = 0;\n\n    /* create search state object */\n    if (!state_init(&scanner->state, self, string, pos, endpos)) {\n        Py_DECREF(scanner);\n        return NULL;\n    }\n\n    scanner->pattern = Py_NewRef(self);\n\n    PyObject_GC_Track(scanner);\n    return (PyObject*) scanner;\n}\n\n/* -------------------------------------------------------------------- */\n/* template methods */\n\nstatic int\ntemplate_traverse(TemplateObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(self));\n    Py_VISIT(self->literal);\n    for (Py_ssize_t i = 0, n = Py_SIZE(self); i < n; i++) {\n        Py_VISIT(self->items[i].literal);\n    }\n    return 0;\n}\n\nstatic int\ntemplate_clear(TemplateObject *self)\n{\n    Py_CLEAR(self->literal);\n    for (Py_ssize_t i = 0, n = Py_SIZE(self); i < n; i++) {\n        Py_CLEAR(self->items[i].literal);\n    }\n    return 0;\n}\n\nstatic void\ntemplate_dealloc(TemplateObject *self)\n{\n    PyTypeObject *tp = Py_TYPE(self);\n\n    PyObject_GC_UnTrack(self);\n    (void)template_clear(self);\n    tp->tp_free(self);\n    Py_DECREF(tp);\n}\n\nstatic PyObject *\nexpand_template(TemplateObject *self, MatchObject *match)\n{\n    if (Py_SIZE(self) == 0) {\n        return Py_NewRef(self->literal);\n    }\n\n    PyObject *result = NULL;\n    Py_ssize_t count = 0;  // the number of non-empty chunks\n    /* For small number of strings use a buffer allocated on the stack,\n     * otherwise use a list object. */\n    PyObject *buffer[10];\n    PyObject **out = buffer;\n    PyObject *list = NULL;\n    if (self->chunks > (int)Py_ARRAY_LENGTH(buffer) ||\n        !PyUnicode_Check(self->literal))\n    {\n        list = PyList_New(self->chunks);\n        if (!list) {\n            return NULL;\n        }\n        out = &PyList_GET_ITEM(list, 0);\n    }\n\n    out[count++] = Py_NewRef(self->literal);\n    for (Py_ssize_t i = 0; i < Py_SIZE(self); i++) {\n        Py_ssize_t index = self->items[i].index;\n        if (index >= match->groups) {\n            PyErr_SetString(PyExc_IndexError, \"no such group\");\n            goto cleanup;\n        }\n        PyObject *item = match_getslice_by_index(match, index, Py_None);\n        if (item == NULL) {\n            goto cleanup;\n        }\n        if (item != Py_None) {\n            out[count++] = Py_NewRef(item);\n        }\n        Py_DECREF(item);\n\n        PyObject *literal = self->items[i].literal;\n        if (literal != NULL) {\n            out[count++] = Py_NewRef(literal);\n        }\n    }\n\n    if (PyUnicode_Check(self->literal)) {\n        result = _PyUnicode_JoinArray(&_Py_STR(empty), out, count);\n    }\n    else {\n        Py_SET_SIZE(list, count);\n        result = _PyBytes_Join((PyObject *)&_Py_SINGLETON(bytes_empty), list);\n    }\n\ncleanup:\n    if (list) {\n        Py_DECREF(list);\n    }\n    else {\n        for (Py_ssize_t i = 0; i < count; i++) {\n            Py_DECREF(out[i]);\n        }\n    }\n    return result;\n}\n\n\nstatic Py_hash_t\npattern_hash(PatternObject *self)\n{\n    Py_hash_t hash, hash2;\n\n    hash = PyObject_Hash(self->pattern);\n    if (hash == -1) {\n        return -1;\n    }\n\n    hash2 = _Py_HashBytes(self->code, sizeof(self->code[0]) * self->codesize);\n    hash ^= hash2;\n\n    hash ^= self->flags;\n    hash ^= self->isbytes;\n    hash ^= self->codesize;\n\n    if (hash == -1) {\n        hash = -2;\n    }\n    return hash;\n}\n\nstatic PyObject*\npattern_richcompare(PyObject *lefto, PyObject *righto, int op)\n{\n    PyTypeObject *tp = Py_TYPE(lefto);\n    _sremodulestate *module_state = get_sre_module_state_by_class(tp);\n    PatternObject *left, *right;\n    int cmp;\n\n    if (op != Py_EQ && op != Py_NE) {\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n\n    if (!Py_IS_TYPE(righto, module_state->Pattern_Type))\n    {\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n\n    if (lefto == righto) {\n        /* a pattern is equal to itself */\n        return PyBool_FromLong(op == Py_EQ);\n    }\n\n    left = (PatternObject *)lefto;\n    right = (PatternObject *)righto;\n\n    cmp = (left->flags == right->flags\n           && left->isbytes == right->isbytes\n           && left->codesize == right->codesize);\n    if (cmp) {\n        /* Compare the code and the pattern because the same pattern can\n           produce different codes depending on the locale used to compile the\n           pattern when the re.LOCALE flag is used. Don't compare groups,\n           indexgroup nor groupindex: they are derivated from the pattern. */\n        cmp = (memcmp(left->code, right->code,\n                      sizeof(left->code[0]) * left->codesize) == 0);\n    }\n    if (cmp) {\n        cmp = PyObject_RichCompareBool(left->pattern, right->pattern,\n                                       Py_EQ);\n        if (cmp < 0) {\n            return NULL;\n        }\n    }\n    if (op == Py_NE) {\n        cmp = !cmp;\n    }\n    return PyBool_FromLong(cmp);\n}\n\n#include \"clinic/sre.c.h\"\n\nstatic PyMethodDef pattern_methods[] = {\n    _SRE_SRE_PATTERN_MATCH_METHODDEF\n    _SRE_SRE_PATTERN_FULLMATCH_METHODDEF\n    _SRE_SRE_PATTERN_SEARCH_METHODDEF\n    _SRE_SRE_PATTERN_SUB_METHODDEF\n    _SRE_SRE_PATTERN_SUBN_METHODDEF\n    _SRE_SRE_PATTERN_FINDALL_METHODDEF\n    _SRE_SRE_PATTERN_SPLIT_METHODDEF\n    _SRE_SRE_PATTERN_FINDITER_METHODDEF\n    _SRE_SRE_PATTERN_SCANNER_METHODDEF\n    _SRE_SRE_PATTERN___COPY___METHODDEF\n    _SRE_SRE_PATTERN___DEEPCOPY___METHODDEF\n    {\"__class_getitem__\", Py_GenericAlias, METH_O|METH_CLASS,\n     PyDoc_STR(\"See PEP 585\")},\n    {NULL, NULL}\n};\n\nstatic PyGetSetDef pattern_getset[] = {\n    {\"groupindex\", (getter)pattern_groupindex, (setter)NULL,\n      \"A dictionary mapping group names to group numbers.\"},\n    {NULL}  /* Sentinel */\n};\n\n#define PAT_OFF(x) offsetof(PatternObject, x)\nstatic PyMemberDef pattern_members[] = {\n    {\"pattern\",    T_OBJECT,    PAT_OFF(pattern),       READONLY,\n     \"The pattern string from which the RE object was compiled.\"},\n    {\"flags\",      T_INT,       PAT_OFF(flags),         READONLY,\n     \"The regex matching flags.\"},\n    {\"groups\",     T_PYSSIZET,  PAT_OFF(groups),        READONLY,\n     \"The number of capturing groups in the pattern.\"},\n    {\"__weaklistoffset__\", T_PYSSIZET, offsetof(PatternObject, weakreflist), READONLY},\n    {NULL}  /* Sentinel */\n};\n\nstatic PyType_Slot pattern_slots[] = {\n    {Py_tp_dealloc, (destructor)pattern_dealloc},\n    {Py_tp_repr, (reprfunc)pattern_repr},\n    {Py_tp_hash, (hashfunc)pattern_hash},\n    {Py_tp_doc, (void *)pattern_doc},\n    {Py_tp_richcompare, pattern_richcompare},\n    {Py_tp_methods, pattern_methods},\n    {Py_tp_members, pattern_members},\n    {Py_tp_getset, pattern_getset},\n    {Py_tp_traverse, pattern_traverse},\n    {Py_tp_clear, pattern_clear},\n    {0, NULL},\n};\n\nstatic PyType_Spec pattern_spec = {\n    .name = \"re.Pattern\",\n    .basicsize = sizeof(PatternObject),\n    .itemsize = sizeof(SRE_CODE),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE |\n              Py_TPFLAGS_DISALLOW_INSTANTIATION | Py_TPFLAGS_HAVE_GC),\n    .slots = pattern_slots,\n};\n\nstatic PyMethodDef match_methods[] = {\n    {\"group\", (PyCFunction) match_group, METH_VARARGS, match_group_doc},\n    _SRE_SRE_MATCH_START_METHODDEF\n    _SRE_SRE_MATCH_END_METHODDEF\n    _SRE_SRE_MATCH_SPAN_METHODDEF\n    _SRE_SRE_MATCH_GROUPS_METHODDEF\n    _SRE_SRE_MATCH_GROUPDICT_METHODDEF\n    _SRE_SRE_MATCH_EXPAND_METHODDEF\n    _SRE_SRE_MATCH___COPY___METHODDEF\n    _SRE_SRE_MATCH___DEEPCOPY___METHODDEF\n    {\"__class_getitem__\", Py_GenericAlias, METH_O|METH_CLASS,\n     PyDoc_STR(\"See PEP 585\")},\n    {NULL, NULL}\n};\n\nstatic PyGetSetDef match_getset[] = {\n    {\"lastindex\", (getter)match_lastindex_get, (setter)NULL,\n     \"The integer index of the last matched capturing group.\"},\n    {\"lastgroup\", (getter)match_lastgroup_get, (setter)NULL,\n     \"The name of the last matched capturing group.\"},\n    {\"regs\",      (getter)match_regs_get,      (setter)NULL},\n    {NULL}\n};\n\n#define MATCH_OFF(x) offsetof(MatchObject, x)\nstatic PyMemberDef match_members[] = {\n    {\"string\",  T_OBJECT,   MATCH_OFF(string),  READONLY,\n     \"The string passed to match() or search().\"},\n    {\"re\",      T_OBJECT,   MATCH_OFF(pattern), READONLY,\n     \"The regular expression object.\"},\n    {\"pos\",     T_PYSSIZET, MATCH_OFF(pos),     READONLY,\n     \"The index into the string at which the RE engine started looking for a match.\"},\n    {\"endpos\",  T_PYSSIZET, MATCH_OFF(endpos),  READONLY,\n     \"The index into the string beyond which the RE engine will not go.\"},\n    {NULL}\n};\n\n/* FIXME: implement setattr(\"string\", None) as a special case (to\n   detach the associated string, if any */\nstatic PyType_Slot match_slots[] = {\n    {Py_tp_dealloc, match_dealloc},\n    {Py_tp_repr, match_repr},\n    {Py_tp_doc, (void *)match_doc},\n    {Py_tp_methods, match_methods},\n    {Py_tp_members, match_members},\n    {Py_tp_getset, match_getset},\n    {Py_tp_traverse, match_traverse},\n    {Py_tp_clear, match_clear},\n\n    /* As mapping.\n     *\n     * Match objects do not support length or assignment, but do support\n     * __getitem__.\n     */\n    {Py_mp_subscript, match_getitem},\n\n    {0, NULL},\n};\n\nstatic PyType_Spec match_spec = {\n    .name = \"re.Match\",\n    .basicsize = sizeof(MatchObject),\n    .itemsize = sizeof(Py_ssize_t),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE |\n              Py_TPFLAGS_DISALLOW_INSTANTIATION | Py_TPFLAGS_HAVE_GC),\n    .slots = match_slots,\n};\n\nstatic PyMethodDef scanner_methods[] = {\n    _SRE_SRE_SCANNER_MATCH_METHODDEF\n    _SRE_SRE_SCANNER_SEARCH_METHODDEF\n    {NULL, NULL}\n};\n\n#define SCAN_OFF(x) offsetof(ScannerObject, x)\nstatic PyMemberDef scanner_members[] = {\n    {\"pattern\", T_OBJECT, SCAN_OFF(pattern), READONLY},\n    {NULL}  /* Sentinel */\n};\n\nstatic PyType_Slot scanner_slots[] = {\n    {Py_tp_dealloc, scanner_dealloc},\n    {Py_tp_methods, scanner_methods},\n    {Py_tp_members, scanner_members},\n    {Py_tp_traverse, scanner_traverse},\n    {Py_tp_clear, scanner_clear},\n    {0, NULL},\n};\n\nstatic PyType_Spec scanner_spec = {\n    .name = \"_sre.SRE_Scanner\",\n    .basicsize = sizeof(ScannerObject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE |\n              Py_TPFLAGS_DISALLOW_INSTANTIATION | Py_TPFLAGS_HAVE_GC),\n    .slots = scanner_slots,\n};\n\nstatic PyType_Slot template_slots[] = {\n    {Py_tp_dealloc, template_dealloc},\n    {Py_tp_traverse, template_traverse},\n    {Py_tp_clear, template_clear},\n    {0, NULL},\n};\n\nstatic PyType_Spec template_spec = {\n    .name = \"_sre.SRE_Template\",\n    .basicsize = sizeof(TemplateObject),\n    .itemsize = sizeof(((TemplateObject *)0)->items[0]),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE |\n              Py_TPFLAGS_DISALLOW_INSTANTIATION | Py_TPFLAGS_HAVE_GC),\n    .slots = template_slots,\n};\n\nstatic PyMethodDef _functions[] = {\n    _SRE_COMPILE_METHODDEF\n    _SRE_TEMPLATE_METHODDEF\n    _SRE_GETCODESIZE_METHODDEF\n    _SRE_ASCII_ISCASED_METHODDEF\n    _SRE_UNICODE_ISCASED_METHODDEF\n    _SRE_ASCII_TOLOWER_METHODDEF\n    _SRE_UNICODE_TOLOWER_METHODDEF\n    {NULL, NULL}\n};\n\nstatic int\nsre_traverse(PyObject *module, visitproc visit, void *arg)\n{\n    _sremodulestate *state = get_sre_module_state(module);\n\n    Py_VISIT(state->Pattern_Type);\n    Py_VISIT(state->Match_Type);\n    Py_VISIT(state->Scanner_Type);\n    Py_VISIT(state->Template_Type);\n    Py_VISIT(state->compile_template);\n\n    return 0;\n}\n\nstatic int\nsre_clear(PyObject *module)\n{\n    _sremodulestate *state = get_sre_module_state(module);\n\n    Py_CLEAR(state->Pattern_Type);\n    Py_CLEAR(state->Match_Type);\n    Py_CLEAR(state->Scanner_Type);\n    Py_CLEAR(state->Template_Type);\n    Py_CLEAR(state->compile_template);\n\n    return 0;\n}\n\nstatic void\nsre_free(void *module)\n{\n    sre_clear((PyObject *)module);\n}\n\n#define CREATE_TYPE(m, type, spec)                                  \\\ndo {                                                                \\\n    type = (PyTypeObject *)PyType_FromModuleAndSpec(m, spec, NULL); \\\n    if (type == NULL) {                                             \\\n        goto error;                                                 \\\n    }                                                               \\\n} while (0)\n\n#define ADD_ULONG_CONSTANT(module, name, value)           \\\n    do {                                                  \\\n        PyObject *o = PyLong_FromUnsignedLong(value);     \\\n        if (!o)                                           \\\n            goto error;                                   \\\n        int res = PyModule_AddObjectRef(module, name, o); \\\n        Py_DECREF(o);                                     \\\n        if (res < 0) {                                    \\\n            goto error;                                   \\\n        }                                                 \\\n} while (0)\n\nstatic int\nsre_exec(PyObject *m)\n{\n    _sremodulestate *state;\n\n    /* Create heap types */\n    state = get_sre_module_state(m);\n    CREATE_TYPE(m, state->Pattern_Type, &pattern_spec);\n    CREATE_TYPE(m, state->Match_Type, &match_spec);\n    CREATE_TYPE(m, state->Scanner_Type, &scanner_spec);\n    CREATE_TYPE(m, state->Template_Type, &template_spec);\n\n    if (PyModule_AddIntConstant(m, \"MAGIC\", SRE_MAGIC) < 0) {\n        goto error;\n    }\n\n    if (PyModule_AddIntConstant(m, \"CODESIZE\", sizeof(SRE_CODE)) < 0) {\n        goto error;\n    }\n\n    ADD_ULONG_CONSTANT(m, \"MAXREPEAT\", SRE_MAXREPEAT);\n    ADD_ULONG_CONSTANT(m, \"MAXGROUPS\", SRE_MAXGROUPS);\n\n    if (PyModule_AddStringConstant(m, \"copyright\", copyright) < 0) {\n        goto error;\n    }\n\n    return 0;\n\nerror:\n    return -1;\n}\n\nstatic PyModuleDef_Slot sre_slots[] = {\n    {Py_mod_exec, sre_exec},\n    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},\n    {0, NULL},\n};\n\nstatic struct PyModuleDef sremodule = {\n    .m_base = PyModuleDef_HEAD_INIT,\n    .m_name = \"_sre\",\n    .m_size = sizeof(_sremodulestate),\n    .m_methods = _functions,\n    .m_slots = sre_slots,\n    .m_traverse = sre_traverse,\n    .m_free = sre_free,\n    .m_clear = sre_clear,\n};\n\nPyMODINIT_FUNC\nPyInit__sre(void)\n{\n    return PyModuleDef_Init(&sremodule);\n}\n\n/* vim:ts=4:sw=4:et\n*/\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-null-dereference",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 1542,
                                       "gcc/analyzer/saved_diagnostic/snode": 50,
                                       "gcc/analyzer/saved_diagnostic/sval": "(struct PyObject *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 0},
                        "level": "warning",
                        "message": {"text": "dereference of NULL 'list'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 282,
                                                                       "startColumn": 5,
                                                                       "endColumn": 23},
                                                            "contextRegion": {"startLine": 282,
                                                                              "snippet": {"text": "    ob->ob_size = size;\n"}}},
                                       "logicalLocations": [{"name": "expand_template.part.0",
                                                             "fullyQualifiedName": "expand_template.part.0",
                                                             "decoratedName": "expand_template.part.0",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_sre/sre.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2816,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 16},
                                                                                                         "contextRegion": {"startLine": 2816,
                                                                                                                           "snippet": {"text": "expand_template(TemplateObject *self, MatchObject *match)\n"}}},
                                                                                    "logicalLocations": [{"name": "expand_template.part.0",
                                                                                                          "fullyQualifiedName": "expand_template.part.0",
                                                                                                          "decoratedName": "expand_template.part.0",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'expand_template.part.0'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 22,
                                                                                                                                 "dst_idx": 23,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_sre/sre.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2829,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 2829,
                                                                                                                           "snippet": {"text": "    if (self->chunks > (int)Py_ARRAY_LENGTH(buffer) ||\n"}}},
                                                                                    "logicalLocations": [{"name": "expand_template.part.0",
                                                                                                          "fullyQualifiedName": "expand_template.part.0",
                                                                                                          "decoratedName": "expand_template.part.0",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 22,
                                                                                                                                 "dst_idx": 23,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_sre/sre.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2830,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 2830,
                                                                                                                           "snippet": {"text": "        !PyUnicode_Check(self->literal))\n"}}},
                                                                                    "logicalLocations": [{"name": "expand_template.part.0",
                                                                                                          "fullyQualifiedName": "expand_template.part.0",
                                                                                                          "decoratedName": "expand_template.part.0",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 23,
                                                                                                                                 "dst_idx": 27,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_sre/sre.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2829,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endLine": 2830,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 2829,
                                                                                                                           "endLine": 2830,
                                                                                                                           "snippet": {"text": "    if (self->chunks > (int)Py_ARRAY_LENGTH(buffer) ||\n        !PyUnicode_Check(self->literal))\n"}}},
                                                                                    "logicalLocations": [{"name": "expand_template.part.0",
                                                                                                          "fullyQualifiedName": "expand_template.part.0",
                                                                                                          "decoratedName": "expand_template.part.0",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 23,
                                                                                                                                 "dst_idx": 27,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_sre/sre.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2839,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 21},
                                                                                                         "contextRegion": {"startLine": 2839,
                                                                                                                           "snippet": {"text": "    out[count++] = Py_NewRef(self->literal);\n"}}},
                                                                                    "logicalLocations": [{"name": "expand_template.part.0",
                                                                                                          "fullyQualifiedName": "expand_template.part.0",
                                                                                                          "decoratedName": "expand_template.part.0",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 48,
                                                                                                                                 "dst_idx": 50,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_sre/sre.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2861,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 2861,
                                                                                                                           "snippet": {"text": "    if (PyUnicode_Check(self->literal)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "expand_template.part.0",
                                                                                                          "fullyQualifiedName": "expand_template.part.0",
                                                                                                          "decoratedName": "expand_template.part.0",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_sre/sre.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2865,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 2865,
                                                                                                                           "snippet": {"text": "        Py_SET_SIZE(list, count);\n"}}},
                                                                                    "logicalLocations": [{"name": "expand_template.part.0",
                                                                                                          "fullyQualifiedName": "expand_template.part.0",
                                                                                                          "decoratedName": "expand_template.part.0",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'Py_SET_SIZE' from 'expand_template.part.0'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "expand_template.part.0",
                                                                                                                                     "fullyQualifiedName": "expand_template.part.0",
                                                                                                                                     "decoratedName": "expand_template.part.0",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 1,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 48,
                                                                                                                                 "dst_idx": 50,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 282,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 23},
                                                                                                         "contextRegion": {"startLine": 282,
                                                                                                                           "snippet": {"text": "    ob->ob_size = size;\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_SET_SIZE",
                                                                                                          "fullyQualifiedName": "Py_SET_SIZE",
                                                                                                          "decoratedName": "Py_SET_SIZE",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "expand_template.part.0",
                                                                                                                                     "fullyQualifiedName": "expand_template.part.0",
                                                                                                                                     "decoratedName": "expand_template.part.0",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 1},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 282,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 23},
                                                                                                         "contextRegion": {"startLine": 282,
                                                                                                                           "snippet": {"text": "    ob->ob_size = size;\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_SET_SIZE",
                                                                                                          "fullyQualifiedName": "Py_SET_SIZE",
                                                                                                          "decoratedName": "Py_SET_SIZE",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "dereference of NULL 'list'"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 9}]}]}]}]}]}
