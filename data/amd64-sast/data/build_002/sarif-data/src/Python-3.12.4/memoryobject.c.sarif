{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-null-dereference",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-dereference"}]}},
           "taxonomies": [{"name": "CWE",
                           "version": "4.7",
                           "organization": "MITRE",
                           "shortDescription": {"text": "The MITRE Common Weakness Enumeration"},
                           "taxa": [{"id": "476",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}],
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}},
           "artifacts": [{"location": {"uri": "./Include/internal/pycore_abstract.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_INTERNAL_ABSTRACT_H\n#define Py_INTERNAL_ABSTRACT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_BUILD_CORE\n#  error \"this header requires Py_BUILD_CORE define\"\n#endif\n\n// Fast inlined version of PyIndex_Check()\nstatic inline int\n_PyIndex_Check(PyObject *obj)\n{\n    PyNumberMethods *tp_as_number = Py_TYPE(obj)->tp_as_number;\n    return (tp_as_number != NULL && tp_as_number->nb_index != NULL);\n}\n\nPyObject *_PyNumber_PowerNoMod(PyObject *lhs, PyObject *rhs);\nPyObject *_PyNumber_InPlacePowerNoMod(PyObject *lhs, PyObject *rhs);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_INTERNAL_ABSTRACT_H */\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "Objects/memoryobject.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/*\n * Memoryview object implementation\n * --------------------------------\n *\n *   This implementation is a complete rewrite contributed by Stefan Krah in\n *   Python 3.3.  Substantial credit goes to Antoine Pitrou (who had already\n *   fortified and rewritten the previous implementation) and Nick Coghlan\n *   (who came up with the idea of the ManagedBuffer) for analyzing the complex\n *   ownership rules.\n *\n */\n\n#include \"Python.h\"\n#include \"pycore_abstract.h\"      // _PyIndex_Check()\n#include \"pycore_object.h\"        // _PyObject_GC_UNTRACK()\n#include \"pycore_strhex.h\"        // _Py_strhex_with_sep()\n#include <stddef.h>               // offsetof()\n\n/*[clinic input]\nclass memoryview \"PyMemoryViewObject *\" \"&PyMemoryView_Type\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=e2e49d2192835219]*/\n\n#include \"clinic/memoryobject.c.h\"\n\n/****************************************************************************/\n/*                           ManagedBuffer Object                           */\n/****************************************************************************/\n\n/*\n   ManagedBuffer Object:\n   ---------------------\n\n     The purpose of this object is to facilitate the handling of chained\n     memoryviews that have the same underlying exporting object. PEP-3118\n     allows the underlying object to change while a view is exported. This\n     could lead to unexpected results when constructing a new memoryview\n     from an existing memoryview.\n\n     Rather than repeatedly redirecting buffer requests to the original base\n     object, all chained memoryviews use a single buffer snapshot. This\n     snapshot is generated by the constructor _PyManagedBuffer_FromObject().\n\n   Ownership rules:\n   ----------------\n\n     The master buffer inside a managed buffer is filled in by the original\n     base object. shape, strides, suboffsets and format are read-only for\n     all consumers.\n\n     A memoryview's buffer is a private copy of the exporter's buffer. shape,\n     strides and suboffsets belong to the memoryview and are thus writable.\n\n     If a memoryview itself exports several buffers via memory_getbuf(), all\n     buffer copies share shape, strides and suboffsets. In this case, the\n     arrays are NOT writable.\n\n   Reference count assumptions:\n   ----------------------------\n\n     The 'obj' member of a Py_buffer must either be NULL or refer to the\n     exporting base object. In the Python codebase, all getbufferprocs\n     return a new reference to view.obj (example: bytes_buffer_getbuffer()).\n\n     PyBuffer_Release() decrements view.obj (if non-NULL), so the\n     releasebufferprocs must NOT decrement view.obj.\n*/\n\n\nstatic inline _PyManagedBufferObject *\nmbuf_alloc(void)\n{\n    _PyManagedBufferObject *mbuf;\n\n    mbuf = (_PyManagedBufferObject *)\n        PyObject_GC_New(_PyManagedBufferObject, &_PyManagedBuffer_Type);\n    if (mbuf == NULL)\n        return NULL;\n    mbuf->flags = 0;\n    mbuf->exports = 0;\n    mbuf->master.obj = NULL;\n    _PyObject_GC_TRACK(mbuf);\n\n    return mbuf;\n}\n\nstatic PyObject *\n_PyManagedBuffer_FromObject(PyObject *base, int flags)\n{\n    _PyManagedBufferObject *mbuf;\n\n    mbuf = mbuf_alloc();\n    if (mbuf == NULL)\n        return NULL;\n\n    if (PyObject_GetBuffer(base, &mbuf->master, flags) < 0) {\n        mbuf->master.obj = NULL;\n        Py_DECREF(mbuf);\n        return NULL;\n    }\n\n    return (PyObject *)mbuf;\n}\n\nstatic void\nmbuf_release(_PyManagedBufferObject *self)\n{\n    if (self->flags&_Py_MANAGED_BUFFER_RELEASED)\n        return;\n\n    /* NOTE: at this point self->exports can still be > 0 if this function\n       is called from mbuf_clear() to break up a reference cycle. */\n    self->flags |= _Py_MANAGED_BUFFER_RELEASED;\n\n    /* PyBuffer_Release() decrements master->obj and sets it to NULL. */\n    _PyObject_GC_UNTRACK(self);\n    PyBuffer_Release(&self->master);\n}\n\nstatic void\nmbuf_dealloc(_PyManagedBufferObject *self)\n{\n    assert(self->exports == 0);\n    mbuf_release(self);\n    if (self->flags&_Py_MANAGED_BUFFER_FREE_FORMAT)\n        PyMem_Free(self->master.format);\n    PyObject_GC_Del(self);\n}\n\nstatic int\nmbuf_traverse(_PyManagedBufferObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->master.obj);\n    return 0;\n}\n\nstatic int\nmbuf_clear(_PyManagedBufferObject *self)\n{\n    assert(self->exports >= 0);\n    mbuf_release(self);\n    return 0;\n}\n\nPyTypeObject _PyManagedBuffer_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"managedbuffer\",\n    sizeof(_PyManagedBufferObject),\n    0,\n    (destructor)mbuf_dealloc,                /* tp_dealloc */\n    0,                                       /* tp_vectorcall_offset */\n    0,                                       /* tp_getattr */\n    0,                                       /* tp_setattr */\n    0,                                       /* tp_as_async */\n    0,                                       /* tp_repr */\n    0,                                       /* tp_as_number */\n    0,                                       /* tp_as_sequence */\n    0,                                       /* tp_as_mapping */\n    0,                                       /* tp_hash */\n    0,                                       /* tp_call */\n    0,                                       /* tp_str */\n    PyObject_GenericGetAttr,                 /* tp_getattro */\n    0,                                       /* tp_setattro */\n    0,                                       /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    0,                                       /* tp_doc */\n    (traverseproc)mbuf_traverse,             /* tp_traverse */\n    (inquiry)mbuf_clear                      /* tp_clear */\n};\n\n\n/****************************************************************************/\n/*                             MemoryView Object                            */\n/****************************************************************************/\n\n/* In the process of breaking reference cycles mbuf_release() can be\n   called before memory_release(). */\n#define BASE_INACCESSIBLE(mv) \\\n    (((PyMemoryViewObject *)mv)->flags&_Py_MEMORYVIEW_RELEASED || \\\n     ((PyMemoryViewObject *)mv)->mbuf->flags&_Py_MANAGED_BUFFER_RELEASED)\n\n#define CHECK_RELEASED(mv) \\\n    if (BASE_INACCESSIBLE(mv)) {                                  \\\n        PyErr_SetString(PyExc_ValueError,                         \\\n            \"operation forbidden on released memoryview object\"); \\\n        return NULL;                                              \\\n    }\n\n#define CHECK_RELEASED_INT(mv) \\\n    if (BASE_INACCESSIBLE(mv)) {                                  \\\n        PyErr_SetString(PyExc_ValueError,                         \\\n            \"operation forbidden on released memoryview object\"); \\\n        return -1;                                                \\\n    }\n\n#define CHECK_RESTRICTED(mv) \\\n    if (((PyMemoryViewObject *)(mv))->flags & _Py_MEMORYVIEW_RESTRICTED) { \\\n        PyErr_SetString(PyExc_ValueError,                                  \\\n            \"cannot create new view on restricted memoryview\");            \\\n        return NULL;                                                       \\\n    }\n\n#define CHECK_RESTRICTED_INT(mv) \\\n    if (((PyMemoryViewObject *)(mv))->flags & _Py_MEMORYVIEW_RESTRICTED) { \\\n        PyErr_SetString(PyExc_ValueError,                                  \\\n            \"cannot create new view on restricted memoryview\");            \\\n        return -1;                                                       \\\n    }\n\n/* See gh-92888. These macros signal that we need to check the memoryview\n   again due to possible read after frees. */\n#define CHECK_RELEASED_AGAIN(mv) CHECK_RELEASED(mv)\n#define CHECK_RELEASED_INT_AGAIN(mv) CHECK_RELEASED_INT(mv)\n\n#define CHECK_LIST_OR_TUPLE(v) \\\n    if (!PyList_Check(v) && !PyTuple_Check(v)) { \\\n        PyErr_SetString(PyExc_TypeError,         \\\n            #v \" must be a list or a tuple\");    \\\n        return NULL;                             \\\n    }\n\n#define VIEW_ADDR(mv) (&((PyMemoryViewObject *)mv)->view)\n\n/* Check for the presence of suboffsets in the first dimension. */\n#define HAVE_PTR(suboffsets, dim) (suboffsets && suboffsets[dim] >= 0)\n/* Adjust ptr if suboffsets are present. */\n#define ADJUST_PTR(ptr, suboffsets, dim) \\\n    (HAVE_PTR(suboffsets, dim) ? *((char**)ptr) + suboffsets[dim] : ptr)\n\n/* Memoryview buffer properties */\n#define MV_C_CONTIGUOUS(flags) (flags&(_Py_MEMORYVIEW_SCALAR|_Py_MEMORYVIEW_C))\n#define MV_F_CONTIGUOUS(flags) \\\n    (flags&(_Py_MEMORYVIEW_SCALAR|_Py_MEMORYVIEW_FORTRAN))\n#define MV_ANY_CONTIGUOUS(flags) \\\n    (flags&(_Py_MEMORYVIEW_SCALAR|_Py_MEMORYVIEW_C|_Py_MEMORYVIEW_FORTRAN))\n\n/* Fast contiguity test. Caller must ensure suboffsets==NULL and ndim==1. */\n#define MV_CONTIGUOUS_NDIM1(view) \\\n    ((view)->shape[0] == 1 || (view)->strides[0] == (view)->itemsize)\n\n/* getbuffer() requests */\n#define REQ_INDIRECT(flags) ((flags&PyBUF_INDIRECT) == PyBUF_INDIRECT)\n#define REQ_C_CONTIGUOUS(flags) ((flags&PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS)\n#define REQ_F_CONTIGUOUS(flags) ((flags&PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS)\n#define REQ_ANY_CONTIGUOUS(flags) ((flags&PyBUF_ANY_CONTIGUOUS) == PyBUF_ANY_CONTIGUOUS)\n#define REQ_STRIDES(flags) ((flags&PyBUF_STRIDES) == PyBUF_STRIDES)\n#define REQ_SHAPE(flags) ((flags&PyBUF_ND) == PyBUF_ND)\n#define REQ_WRITABLE(flags) (flags&PyBUF_WRITABLE)\n#define REQ_FORMAT(flags) (flags&PyBUF_FORMAT)\n\n\n/**************************************************************************/\n/*                       Copy memoryview buffers                          */\n/**************************************************************************/\n\n/* The functions in this section take a source and a destination buffer\n   with the same logical structure: format, itemsize, ndim and shape\n   are identical, with ndim > 0.\n\n   NOTE: All buffers are assumed to have PyBUF_FULL information, which\n   is the case for memoryviews! */\n\n\n/* Assumptions: ndim >= 1. The macro tests for a corner case that should\n   perhaps be explicitly forbidden in the PEP. */\n#define HAVE_SUBOFFSETS_IN_LAST_DIM(view) \\\n    (view->suboffsets && view->suboffsets[dest->ndim-1] >= 0)\n\nstatic inline int\nlast_dim_is_contiguous(const Py_buffer *dest, const Py_buffer *src)\n{\n    assert(dest->ndim > 0 && src->ndim > 0);\n    return (!HAVE_SUBOFFSETS_IN_LAST_DIM(dest) &&\n            !HAVE_SUBOFFSETS_IN_LAST_DIM(src) &&\n            dest->strides[dest->ndim-1] == dest->itemsize &&\n            src->strides[src->ndim-1] == src->itemsize);\n}\n\n/* This is not a general function for determining format equivalence.\n   It is used in copy_single() and copy_buffer() to weed out non-matching\n   formats. Skipping the '@' character is specifically used in slice\n   assignments, where the lvalue is already known to have a single character\n   format. This is a performance hack that could be rewritten (if properly\n   benchmarked). */\nstatic inline int\nequiv_format(const Py_buffer *dest, const Py_buffer *src)\n{\n    const char *dfmt, *sfmt;\n\n    assert(dest->format && src->format);\n    dfmt = dest->format[0] == '@' ? dest->format+1 : dest->format;\n    sfmt = src->format[0] == '@' ? src->format+1 : src->format;\n\n    if (strcmp(dfmt, sfmt) != 0 ||\n        dest->itemsize != src->itemsize) {\n        return 0;\n    }\n\n    return 1;\n}\n\n/* Two shapes are equivalent if they are either equal or identical up\n   to a zero element at the same position. For example, in NumPy arrays\n   the shapes [1, 0, 5] and [1, 0, 7] are equivalent. */\nstatic inline int\nequiv_shape(const Py_buffer *dest, const Py_buffer *src)\n{\n    int i;\n\n    if (dest->ndim != src->ndim)\n        return 0;\n\n    for (i = 0; i < dest->ndim; i++) {\n        if (dest->shape[i] != src->shape[i])\n            return 0;\n        if (dest->shape[i] == 0)\n            break;\n    }\n\n    return 1;\n}\n\n/* Check that the logical structure of the destination and source buffers\n   is identical. */\nstatic int\nequiv_structure(const Py_buffer *dest, const Py_buffer *src)\n{\n    if (!equiv_format(dest, src) ||\n        !equiv_shape(dest, src)) {\n        PyErr_SetString(PyExc_ValueError,\n            \"memoryview assignment: lvalue and rvalue have different \"\n            \"structures\");\n        return 0;\n    }\n\n    return 1;\n}\n\n/* Base case for recursive multi-dimensional copying. Contiguous arrays are\n   copied with very little overhead. Assumptions: ndim == 1, mem == NULL or\n   sizeof(mem) == shape[0] * itemsize. */\nstatic void\ncopy_base(const Py_ssize_t *shape, Py_ssize_t itemsize,\n          char *dptr, const Py_ssize_t *dstrides, const Py_ssize_t *dsuboffsets,\n          char *sptr, const Py_ssize_t *sstrides, const Py_ssize_t *ssuboffsets,\n          char *mem)\n{\n    if (mem == NULL) { /* contiguous */\n        Py_ssize_t size = shape[0] * itemsize;\n        if (dptr + size < sptr || sptr + size < dptr)\n            memcpy(dptr, sptr, size); /* no overlapping */\n        else\n            memmove(dptr, sptr, size);\n    }\n    else {\n        char *p;\n        Py_ssize_t i;\n        for (i=0, p=mem; i < shape[0]; p+=itemsize, sptr+=sstrides[0], i++) {\n            char *xsptr = ADJUST_PTR(sptr, ssuboffsets, 0);\n            memcpy(p, xsptr, itemsize);\n        }\n        for (i=0, p=mem; i < shape[0]; p+=itemsize, dptr+=dstrides[0], i++) {\n            char *xdptr = ADJUST_PTR(dptr, dsuboffsets, 0);\n            memcpy(xdptr, p, itemsize);\n        }\n    }\n\n}\n\n/* Recursively copy a source buffer to a destination buffer. The two buffers\n   have the same ndim, shape and itemsize. */\nstatic void\ncopy_rec(const Py_ssize_t *shape, Py_ssize_t ndim, Py_ssize_t itemsize,\n         char *dptr, const Py_ssize_t *dstrides, const Py_ssize_t *dsuboffsets,\n         char *sptr, const Py_ssize_t *sstrides, const Py_ssize_t *ssuboffsets,\n         char *mem)\n{\n    Py_ssize_t i;\n\n    assert(ndim >= 1);\n\n    if (ndim == 1) {\n        copy_base(shape, itemsize,\n                  dptr, dstrides, dsuboffsets,\n                  sptr, sstrides, ssuboffsets,\n                  mem);\n        return;\n    }\n\n    for (i = 0; i < shape[0]; dptr+=dstrides[0], sptr+=sstrides[0], i++) {\n        char *xdptr = ADJUST_PTR(dptr, dsuboffsets, 0);\n        char *xsptr = ADJUST_PTR(sptr, ssuboffsets, 0);\n\n        copy_rec(shape+1, ndim-1, itemsize,\n                 xdptr, dstrides+1, dsuboffsets ? dsuboffsets+1 : NULL,\n                 xsptr, sstrides+1, ssuboffsets ? ssuboffsets+1 : NULL,\n                 mem);\n    }\n}\n\n/* Faster copying of one-dimensional arrays. */\nstatic int\ncopy_single(PyMemoryViewObject *self, const Py_buffer *dest, const Py_buffer *src)\n{\n    CHECK_RELEASED_INT_AGAIN(self);\n    char *mem = NULL;\n\n    assert(dest->ndim == 1);\n\n    if (!equiv_structure(dest, src))\n        return -1;\n\n    if (!last_dim_is_contiguous(dest, src)) {\n        mem = PyMem_Malloc(dest->shape[0] * dest->itemsize);\n        if (mem == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n    }\n\n    copy_base(dest->shape, dest->itemsize,\n              dest->buf, dest->strides, dest->suboffsets,\n              src->buf, src->strides, src->suboffsets,\n              mem);\n\n    if (mem)\n        PyMem_Free(mem);\n\n    return 0;\n}\n\n/* Recursively copy src to dest. Both buffers must have the same basic\n   structure. Copying is atomic, the function never fails with a partial\n   copy. */\nstatic int\ncopy_buffer(const Py_buffer *dest, const Py_buffer *src)\n{\n    char *mem = NULL;\n\n    assert(dest->ndim > 0);\n\n    if (!equiv_structure(dest, src))\n        return -1;\n\n    if (!last_dim_is_contiguous(dest, src)) {\n        mem = PyMem_Malloc(dest->shape[dest->ndim-1] * dest->itemsize);\n        if (mem == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n    }\n\n    copy_rec(dest->shape, dest->ndim, dest->itemsize,\n             dest->buf, dest->strides, dest->suboffsets,\n             src->buf, src->strides, src->suboffsets,\n             mem);\n\n    if (mem)\n        PyMem_Free(mem);\n\n    return 0;\n}\n\n/* Initialize strides for a C-contiguous array. */\nstatic inline void\ninit_strides_from_shape(Py_buffer *view)\n{\n    Py_ssize_t i;\n\n    assert(view->ndim > 0);\n\n    view->strides[view->ndim-1] = view->itemsize;\n    for (i = view->ndim-2; i >= 0; i--)\n        view->strides[i] = view->strides[i+1] * view->shape[i+1];\n}\n\n/* Initialize strides for a Fortran-contiguous array. */\nstatic inline void\ninit_fortran_strides_from_shape(Py_buffer *view)\n{\n    Py_ssize_t i;\n\n    assert(view->ndim > 0);\n\n    view->strides[0] = view->itemsize;\n    for (i = 1; i < view->ndim; i++)\n        view->strides[i] = view->strides[i-1] * view->shape[i-1];\n}\n\n/* Copy src to a contiguous representation. order is one of 'C', 'F' (Fortran)\n   or 'A' (Any). Assumptions: src has PyBUF_FULL information, src->ndim >= 1,\n   len(mem) == src->len. */\nstatic int\nbuffer_to_contiguous(char *mem, const Py_buffer *src, char order)\n{\n    Py_buffer dest;\n    Py_ssize_t *strides;\n    int ret;\n\n    assert(src->ndim >= 1);\n    assert(src->shape != NULL);\n    assert(src->strides != NULL);\n\n    strides = PyMem_Malloc(src->ndim * (sizeof *src->strides));\n    if (strides == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n\n    /* initialize dest */\n    dest = *src;\n    dest.buf = mem;\n    /* shape is constant and shared: the logical representation of the\n       array is unaltered. */\n\n    /* The physical representation determined by strides (and possibly\n       suboffsets) may change. */\n    dest.strides = strides;\n    if (order == 'C' || order == 'A') {\n        init_strides_from_shape(&dest);\n    }\n    else {\n        init_fortran_strides_from_shape(&dest);\n    }\n\n    dest.suboffsets = NULL;\n\n    ret = copy_buffer(&dest, src);\n\n    PyMem_Free(strides);\n    return ret;\n}\n\n\n/****************************************************************************/\n/*                               Constructors                               */\n/****************************************************************************/\n\n/* Initialize values that are shared with the managed buffer. */\nstatic inline void\ninit_shared_values(Py_buffer *dest, const Py_buffer *src)\n{\n    dest->obj = src->obj;\n    dest->buf = src->buf;\n    dest->len = src->len;\n    dest->itemsize = src->itemsize;\n    dest->readonly = src->readonly;\n    dest->format = src->format ? src->format : \"B\";\n    dest->internal = src->internal;\n}\n\n/* Copy shape and strides. Reconstruct missing values. */\nstatic void\ninit_shape_strides(Py_buffer *dest, const Py_buffer *src)\n{\n    Py_ssize_t i;\n\n    if (src->ndim == 0) {\n        dest->shape = NULL;\n        dest->strides = NULL;\n        return;\n    }\n    if (src->ndim == 1) {\n        dest->shape[0] = src->shape ? src->shape[0] : src->len / src->itemsize;\n        dest->strides[0] = src->strides ? src->strides[0] : src->itemsize;\n        return;\n    }\n\n    for (i = 0; i < src->ndim; i++)\n        dest->shape[i] = src->shape[i];\n    if (src->strides) {\n        for (i = 0; i < src->ndim; i++)\n            dest->strides[i] = src->strides[i];\n    }\n    else {\n        init_strides_from_shape(dest);\n    }\n}\n\nstatic inline void\ninit_suboffsets(Py_buffer *dest, const Py_buffer *src)\n{\n    Py_ssize_t i;\n\n    if (src->suboffsets == NULL) {\n        dest->suboffsets = NULL;\n        return;\n    }\n    for (i = 0; i < src->ndim; i++)\n        dest->suboffsets[i] = src->suboffsets[i];\n}\n\n/* len = product(shape) * itemsize */\nstatic inline void\ninit_len(Py_buffer *view)\n{\n    Py_ssize_t i, len;\n\n    len = 1;\n    for (i = 0; i < view->ndim; i++)\n        len *= view->shape[i];\n    len *= view->itemsize;\n\n    view->len = len;\n}\n\n/* Initialize memoryview buffer properties. */\nstatic void\ninit_flags(PyMemoryViewObject *mv)\n{\n    const Py_buffer *view = &mv->view;\n    int flags = 0;\n\n    switch (view->ndim) {\n    case 0:\n        flags |= (_Py_MEMORYVIEW_SCALAR|_Py_MEMORYVIEW_C|\n                  _Py_MEMORYVIEW_FORTRAN);\n        break;\n    case 1:\n        if (MV_CONTIGUOUS_NDIM1(view))\n            flags |= (_Py_MEMORYVIEW_C|_Py_MEMORYVIEW_FORTRAN);\n        break;\n    default:\n        if (PyBuffer_IsContiguous(view, 'C'))\n            flags |= _Py_MEMORYVIEW_C;\n        if (PyBuffer_IsContiguous(view, 'F'))\n            flags |= _Py_MEMORYVIEW_FORTRAN;\n        break;\n    }\n\n    if (view->suboffsets) {\n        flags |= _Py_MEMORYVIEW_PIL;\n        flags &= ~(_Py_MEMORYVIEW_C|_Py_MEMORYVIEW_FORTRAN);\n    }\n\n    mv->flags = flags;\n}\n\n/* Allocate a new memoryview and perform basic initialization. New memoryviews\n   are exclusively created through the mbuf_add functions. */\nstatic inline PyMemoryViewObject *\nmemory_alloc(int ndim)\n{\n    PyMemoryViewObject *mv;\n\n    mv = (PyMemoryViewObject *)\n        PyObject_GC_NewVar(PyMemoryViewObject, &PyMemoryView_Type, 3*ndim);\n    if (mv == NULL)\n        return NULL;\n\n    mv->mbuf = NULL;\n    mv->hash = -1;\n    mv->flags = 0;\n    mv->exports = 0;\n    mv->view.ndim = ndim;\n    mv->view.shape = mv->ob_array;\n    mv->view.strides = mv->ob_array + ndim;\n    mv->view.suboffsets = mv->ob_array + 2 * ndim;\n    mv->weakreflist = NULL;\n\n    _PyObject_GC_TRACK(mv);\n    return mv;\n}\n\n/*\n   Return a new memoryview that is registered with mbuf. If src is NULL,\n   use mbuf->master as the underlying buffer. Otherwise, use src.\n\n   The new memoryview has full buffer information: shape and strides\n   are always present, suboffsets as needed. Arrays are copied to\n   the memoryview's ob_array field.\n */\nstatic PyObject *\nmbuf_add_view(_PyManagedBufferObject *mbuf, const Py_buffer *src)\n{\n    PyMemoryViewObject *mv;\n    Py_buffer *dest;\n\n    if (src == NULL)\n        src = &mbuf->master;\n\n    if (src->ndim > PyBUF_MAX_NDIM) {\n        PyErr_SetString(PyExc_ValueError,\n            \"memoryview: number of dimensions must not exceed \"\n            Py_STRINGIFY(PyBUF_MAX_NDIM));\n        return NULL;\n    }\n\n    mv = memory_alloc(src->ndim);\n    if (mv == NULL)\n        return NULL;\n\n    dest = &mv->view;\n    init_shared_values(dest, src);\n    init_shape_strides(dest, src);\n    init_suboffsets(dest, src);\n    init_flags(mv);\n\n    mv->mbuf = (_PyManagedBufferObject*)Py_NewRef(mbuf);\n    mbuf->exports++;\n\n    return (PyObject *)mv;\n}\n\n/* Register an incomplete view: shape, strides, suboffsets and flags still\n   need to be initialized. Use 'ndim' instead of src->ndim to determine the\n   size of the memoryview's ob_array.\n\n   Assumption: ndim <= PyBUF_MAX_NDIM. */\nstatic PyObject *\nmbuf_add_incomplete_view(_PyManagedBufferObject *mbuf, const Py_buffer *src,\n                         int ndim)\n{\n    PyMemoryViewObject *mv;\n    Py_buffer *dest;\n\n    if (src == NULL)\n        src = &mbuf->master;\n\n    assert(ndim <= PyBUF_MAX_NDIM);\n\n    mv = memory_alloc(ndim);\n    if (mv == NULL)\n        return NULL;\n\n    dest = &mv->view;\n    init_shared_values(dest, src);\n\n    mv->mbuf = (_PyManagedBufferObject*)Py_NewRef(mbuf);\n    mbuf->exports++;\n\n    return (PyObject *)mv;\n}\n\n/* Expose a raw memory area as a view of contiguous bytes. flags can be\n   PyBUF_READ or PyBUF_WRITE. view->format is set to \"B\" (unsigned bytes).\n   The memoryview has complete buffer information. */\nPyObject *\nPyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)\n{\n    _PyManagedBufferObject *mbuf;\n    PyObject *mv;\n    int readonly;\n\n    assert(mem != NULL);\n    assert(flags == PyBUF_READ || flags == PyBUF_WRITE);\n\n    mbuf = mbuf_alloc();\n    if (mbuf == NULL)\n        return NULL;\n\n    readonly = (flags == PyBUF_WRITE) ? 0 : 1;\n    (void)PyBuffer_FillInfo(&mbuf->master, NULL, mem, size, readonly,\n                            PyBUF_FULL_RO);\n\n    mv = mbuf_add_view(mbuf, NULL);\n    Py_DECREF(mbuf);\n\n    return mv;\n}\n\n/* Create a memoryview from a given Py_buffer. For simple byte views,\n   PyMemoryView_FromMemory() should be used instead.\n   This function is the only entry point that can create a master buffer\n   without full information. Because of this fact init_shape_strides()\n   must be able to reconstruct missing values.  */\nPyObject *\nPyMemoryView_FromBuffer(const Py_buffer *info)\n{\n    _PyManagedBufferObject *mbuf;\n    PyObject *mv;\n\n    if (info->buf == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n            \"PyMemoryView_FromBuffer(): info->buf must not be NULL\");\n        return NULL;\n    }\n\n    mbuf = mbuf_alloc();\n    if (mbuf == NULL)\n        return NULL;\n\n    /* info->obj is either NULL or a borrowed reference. This reference\n       should not be decremented in PyBuffer_Release(). */\n    mbuf->master = *info;\n    mbuf->master.obj = NULL;\n\n    mv = mbuf_add_view(mbuf, NULL);\n    Py_DECREF(mbuf);\n\n    return mv;\n}\n\n/* Create a memoryview from an object that implements the buffer protocol,\n   using the given flags.\n   If the object is a memoryview, the new memoryview must be registered\n   with the same managed buffer. Otherwise, a new managed buffer is created. */\nstatic PyObject *\nPyMemoryView_FromObjectAndFlags(PyObject *v, int flags)\n{\n    _PyManagedBufferObject *mbuf;\n\n    if (PyMemoryView_Check(v)) {\n        PyMemoryViewObject *mv = (PyMemoryViewObject *)v;\n        CHECK_RELEASED(mv);\n        CHECK_RESTRICTED(mv);\n        return mbuf_add_view(mv->mbuf, &mv->view);\n    }\n    else if (PyObject_CheckBuffer(v)) {\n        PyObject *ret;\n        mbuf = (_PyManagedBufferObject *)_PyManagedBuffer_FromObject(v, flags);\n        if (mbuf == NULL)\n            return NULL;\n        ret = mbuf_add_view(mbuf, NULL);\n        Py_DECREF(mbuf);\n        return ret;\n    }\n\n    PyErr_Format(PyExc_TypeError,\n        \"memoryview: a bytes-like object is required, not '%.200s'\",\n        Py_TYPE(v)->tp_name);\n    return NULL;\n}\n\n/* Create a memoryview from an object that implements the buffer protocol,\n   using the given flags.\n   If the object is a memoryview, the new memoryview must be registered\n   with the same managed buffer. Otherwise, a new managed buffer is created. */\nPyObject *\n_PyMemoryView_FromBufferProc(PyObject *v, int flags, getbufferproc bufferproc)\n{\n    _PyManagedBufferObject *mbuf = mbuf_alloc();\n    if (mbuf == NULL)\n        return NULL;\n\n    int res = bufferproc(v, &mbuf->master, flags);\n    if (res < 0) {\n        mbuf->master.obj = NULL;\n        Py_DECREF(mbuf);\n        return NULL;\n    }\n\n    PyObject *ret = mbuf_add_view(mbuf, NULL);\n    Py_DECREF(mbuf);\n    return ret;\n}\n\n/* Create a memoryview from an object that implements the buffer protocol.\n   If the object is a memoryview, the new memoryview must be registered\n   with the same managed buffer. Otherwise, a new managed buffer is created. */\nPyObject *\nPyMemoryView_FromObject(PyObject *v)\n{\n    return PyMemoryView_FromObjectAndFlags(v, PyBUF_FULL_RO);\n}\n\n/* Copy the format string from a base object that might vanish. */\nstatic int\nmbuf_copy_format(_PyManagedBufferObject *mbuf, const char *fmt)\n{\n    if (fmt != NULL) {\n        char *cp = PyMem_Malloc(strlen(fmt)+1);\n        if (cp == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        mbuf->master.format = strcpy(cp, fmt);\n        mbuf->flags |= _Py_MANAGED_BUFFER_FREE_FORMAT;\n    }\n\n    return 0;\n}\n\n/*\n   Return a memoryview that is based on a contiguous copy of src.\n   Assumptions: src has PyBUF_FULL_RO information, src->ndim > 0.\n\n   Ownership rules:\n     1) As usual, the returned memoryview has a private copy\n        of src->shape, src->strides and src->suboffsets.\n     2) src->format is copied to the master buffer and released\n        in mbuf_dealloc(). The releasebufferproc of the bytes\n        object is NULL, so it does not matter that mbuf_release()\n        passes the altered format pointer to PyBuffer_Release().\n*/\nstatic PyObject *\nmemory_from_contiguous_copy(const Py_buffer *src, char order)\n{\n    _PyManagedBufferObject *mbuf;\n    PyMemoryViewObject *mv;\n    PyObject *bytes;\n    Py_buffer *dest;\n    int i;\n\n    assert(src->ndim > 0);\n    assert(src->shape != NULL);\n\n    bytes = PyBytes_FromStringAndSize(NULL, src->len);\n    if (bytes == NULL)\n        return NULL;\n\n    mbuf = (_PyManagedBufferObject *)_PyManagedBuffer_FromObject(bytes, PyBUF_FULL_RO);\n    Py_DECREF(bytes);\n    if (mbuf == NULL)\n        return NULL;\n\n    if (mbuf_copy_format(mbuf, src->format) < 0) {\n        Py_DECREF(mbuf);\n        return NULL;\n    }\n\n    mv = (PyMemoryViewObject *)mbuf_add_incomplete_view(mbuf, NULL, src->ndim);\n    Py_DECREF(mbuf);\n    if (mv == NULL)\n        return NULL;\n\n    dest = &mv->view;\n\n    /* shared values are initialized correctly except for itemsize */\n    dest->itemsize = src->itemsize;\n\n    /* shape and strides */\n    for (i = 0; i < src->ndim; i++) {\n        dest->shape[i] = src->shape[i];\n    }\n    if (order == 'C' || order == 'A') {\n        init_strides_from_shape(dest);\n    }\n    else {\n        init_fortran_strides_from_shape(dest);\n    }\n    /* suboffsets */\n    dest->suboffsets = NULL;\n\n    /* flags */\n    init_flags(mv);\n\n    if (copy_buffer(dest, src) < 0) {\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    return (PyObject *)mv;\n}\n\n/*\n   Return a new memoryview object based on a contiguous exporter with\n   buffertype={PyBUF_READ, PyBUF_WRITE} and order={'C', 'F'ortran, or 'A'ny}.\n   The logical structure of the input and output buffers is the same\n   (i.e. tolist(input) == tolist(output)), but the physical layout in\n   memory can be explicitly chosen.\n\n   As usual, if buffertype=PyBUF_WRITE, the exporter's buffer must be writable,\n   otherwise it may be writable or read-only.\n\n   If the exporter is already contiguous with the desired target order,\n   the memoryview will be directly based on the exporter.\n\n   Otherwise, if the buffertype is PyBUF_READ, the memoryview will be\n   based on a new bytes object. If order={'C', 'A'ny}, use 'C' order,\n   'F'ortran order otherwise.\n*/\nPyObject *\nPyMemoryView_GetContiguous(PyObject *obj, int buffertype, char order)\n{\n    PyMemoryViewObject *mv;\n    PyObject *ret;\n    Py_buffer *view;\n\n    assert(buffertype == PyBUF_READ || buffertype == PyBUF_WRITE);\n    assert(order == 'C' || order == 'F' || order == 'A');\n\n    mv = (PyMemoryViewObject *)PyMemoryView_FromObject(obj);\n    if (mv == NULL)\n        return NULL;\n\n    view = &mv->view;\n    if (buffertype == PyBUF_WRITE && view->readonly) {\n        PyErr_SetString(PyExc_BufferError,\n            \"underlying buffer is not writable\");\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (PyBuffer_IsContiguous(view, order))\n        return (PyObject *)mv;\n\n    if (buffertype == PyBUF_WRITE) {\n        PyErr_SetString(PyExc_BufferError,\n            \"writable contiguous buffer requested \"\n            \"for a non-contiguous object.\");\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    ret = memory_from_contiguous_copy(view, order);\n    Py_DECREF(mv);\n    return ret;\n}\n\n\n/*[clinic input]\n@classmethod\nmemoryview.__new__\n\n    object: object\n\nCreate a new memoryview object which references the given object.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_impl(PyTypeObject *type, PyObject *object)\n/*[clinic end generated code: output=7de78e184ed66db8 input=f04429eb0bdf8c6e]*/\n{\n    return PyMemoryView_FromObject(object);\n}\n\n\n/*[clinic input]\n@classmethod\nmemoryview._from_flags\n\n    object: object\n    flags: int\n\nCreate a new memoryview object which references the given object.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview__from_flags_impl(PyTypeObject *type, PyObject *object, int flags)\n/*[clinic end generated code: output=bf71f9906c266ee2 input=f5f82fd0e744356b]*/\n{\n    return PyMemoryView_FromObjectAndFlags(object, flags);\n}\n\n\n/****************************************************************************/\n/*                         Previously in abstract.c                         */\n/****************************************************************************/\n\ntypedef struct {\n    Py_buffer view;\n    Py_ssize_t array[1];\n} Py_buffer_full;\n\nint\nPyBuffer_ToContiguous(void *buf, const Py_buffer *src, Py_ssize_t len, char order)\n{\n    Py_buffer_full *fb = NULL;\n    int ret;\n\n    assert(order == 'C' || order == 'F' || order == 'A');\n\n    if (len != src->len) {\n        PyErr_SetString(PyExc_ValueError,\n            \"PyBuffer_ToContiguous: len != view->len\");\n        return -1;\n    }\n\n    if (PyBuffer_IsContiguous(src, order)) {\n        memcpy((char *)buf, src->buf, len);\n        return 0;\n    }\n\n    /* buffer_to_contiguous() assumes PyBUF_FULL */\n    fb = PyMem_Malloc(sizeof *fb + 3 * src->ndim * (sizeof *fb->array));\n    if (fb == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    fb->view.ndim = src->ndim;\n    fb->view.shape = fb->array;\n    fb->view.strides = fb->array + src->ndim;\n    fb->view.suboffsets = fb->array + 2 * src->ndim;\n\n    init_shared_values(&fb->view, src);\n    init_shape_strides(&fb->view, src);\n    init_suboffsets(&fb->view, src);\n\n    src = &fb->view;\n\n    ret = buffer_to_contiguous(buf, src, order);\n    PyMem_Free(fb);\n    return ret;\n}\n\n\n/****************************************************************************/\n/*                           Release/GC management                          */\n/****************************************************************************/\n\n/* Inform the managed buffer that this particular memoryview will not access\n   the underlying buffer again. If no other memoryviews are registered with\n   the managed buffer, the underlying buffer is released instantly and\n   marked as inaccessible for both the memoryview and the managed buffer.\n\n   This function fails if the memoryview itself has exported buffers. */\nstatic int\n_memory_release(PyMemoryViewObject *self)\n{\n    if (self->flags & _Py_MEMORYVIEW_RELEASED)\n        return 0;\n\n    if (self->exports == 0) {\n        self->flags |= _Py_MEMORYVIEW_RELEASED;\n        assert(self->mbuf->exports > 0);\n        if (--self->mbuf->exports == 0)\n            mbuf_release(self->mbuf);\n        return 0;\n    }\n    if (self->exports > 0) {\n        PyErr_Format(PyExc_BufferError,\n            \"memoryview has %zd exported buffer%s\", self->exports,\n            self->exports==1 ? \"\" : \"s\");\n        return -1;\n    }\n\n    PyErr_SetString(PyExc_SystemError,\n                    \"_memory_release(): negative export count\");\n    return -1;\n}\n\n/*[clinic input]\nmemoryview.release\n\nRelease the underlying buffer exposed by the memoryview object.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_release_impl(PyMemoryViewObject *self)\n/*[clinic end generated code: output=d0b7e3ba95b7fcb9 input=bc71d1d51f4a52f0]*/\n{\n    if (_memory_release(self) < 0)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\nstatic void\nmemory_dealloc(PyMemoryViewObject *self)\n{\n    assert(self->exports == 0);\n    _PyObject_GC_UNTRACK(self);\n    (void)_memory_release(self);\n    Py_CLEAR(self->mbuf);\n    if (self->weakreflist != NULL)\n        PyObject_ClearWeakRefs((PyObject *) self);\n    PyObject_GC_Del(self);\n}\n\nstatic int\nmemory_traverse(PyMemoryViewObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->mbuf);\n    return 0;\n}\n\nstatic int\nmemory_clear(PyMemoryViewObject *self)\n{\n    (void)_memory_release(self);\n    Py_CLEAR(self->mbuf);\n    return 0;\n}\n\nstatic PyObject *\nmemory_enter(PyObject *self, PyObject *args)\n{\n    CHECK_RELEASED(self);\n    return Py_NewRef(self);\n}\n\nstatic PyObject *\nmemory_exit(PyObject *self, PyObject *args)\n{\n    return memoryview_release_impl((PyMemoryViewObject *)self);\n}\n\n\n/****************************************************************************/\n/*                         Casting format and shape                         */\n/****************************************************************************/\n\n#define IS_BYTE_FORMAT(f) (f == 'b' || f == 'B' || f == 'c')\n\nstatic inline Py_ssize_t\nget_native_fmtchar(char *result, const char *fmt)\n{\n    Py_ssize_t size = -1;\n\n    if (fmt[0] == '@') fmt++;\n\n    switch (fmt[0]) {\n    case 'c': case 'b': case 'B': size = sizeof(char); break;\n    case 'h': case 'H': size = sizeof(short); break;\n    case 'i': case 'I': size = sizeof(int); break;\n    case 'l': case 'L': size = sizeof(long); break;\n    case 'q': case 'Q': size = sizeof(long long); break;\n    case 'n': case 'N': size = sizeof(Py_ssize_t); break;\n    case 'f': size = sizeof(float); break;\n    case 'd': size = sizeof(double); break;\n    case 'e': size = sizeof(float) / 2; break;\n    case '?': size = sizeof(_Bool); break;\n    case 'P': size = sizeof(void *); break;\n    }\n\n    if (size > 0 && fmt[1] == '\\0') {\n        *result = fmt[0];\n        return size;\n    }\n\n    return -1;\n}\n\nstatic inline const char *\nget_native_fmtstr(const char *fmt)\n{\n    int at = 0;\n\n    if (fmt[0] == '@') {\n        at = 1;\n        fmt++;\n    }\n    if (fmt[0] == '\\0' || fmt[1] != '\\0') {\n        return NULL;\n    }\n\n#define RETURN(s) do { return at ? \"@\" s : s; } while (0)\n\n    switch (fmt[0]) {\n    case 'c': RETURN(\"c\");\n    case 'b': RETURN(\"b\");\n    case 'B': RETURN(\"B\");\n    case 'h': RETURN(\"h\");\n    case 'H': RETURN(\"H\");\n    case 'i': RETURN(\"i\");\n    case 'I': RETURN(\"I\");\n    case 'l': RETURN(\"l\");\n    case 'L': RETURN(\"L\");\n    case 'q': RETURN(\"q\");\n    case 'Q': RETURN(\"Q\");\n    case 'n': RETURN(\"n\");\n    case 'N': RETURN(\"N\");\n    case 'f': RETURN(\"f\");\n    case 'd': RETURN(\"d\");\n    case 'e': RETURN(\"e\");\n    case '?': RETURN(\"?\");\n    case 'P': RETURN(\"P\");\n    }\n\n    return NULL;\n}\n\n\n/* Cast a memoryview's data type to 'format'. The input array must be\n   C-contiguous. At least one of input-format, output-format must have\n   byte size. The output array is 1-D, with the same byte length as the\n   input array. Thus, view->len must be a multiple of the new itemsize. */\nstatic int\ncast_to_1D(PyMemoryViewObject *mv, PyObject *format)\n{\n    Py_buffer *view = &mv->view;\n    PyObject *asciifmt;\n    char srcchar, destchar;\n    Py_ssize_t itemsize;\n    int ret = -1;\n\n    assert(view->ndim >= 1);\n    assert(Py_SIZE(mv) == 3*view->ndim);\n    assert(view->shape == mv->ob_array);\n    assert(view->strides == mv->ob_array + view->ndim);\n    assert(view->suboffsets == mv->ob_array + 2*view->ndim);\n\n    asciifmt = PyUnicode_AsASCIIString(format);\n    if (asciifmt == NULL)\n        return ret;\n\n    itemsize = get_native_fmtchar(&destchar, PyBytes_AS_STRING(asciifmt));\n    if (itemsize < 0) {\n        PyErr_SetString(PyExc_ValueError,\n            \"memoryview: destination format must be a native single \"\n            \"character format prefixed with an optional '@'\");\n        goto out;\n    }\n\n    if ((get_native_fmtchar(&srcchar, view->format) < 0 ||\n         !IS_BYTE_FORMAT(srcchar)) && !IS_BYTE_FORMAT(destchar)) {\n        PyErr_SetString(PyExc_TypeError,\n            \"memoryview: cannot cast between two non-byte formats\");\n        goto out;\n    }\n    if (view->len % itemsize) {\n        PyErr_SetString(PyExc_TypeError,\n            \"memoryview: length is not a multiple of itemsize\");\n        goto out;\n    }\n\n    view->format = (char *)get_native_fmtstr(PyBytes_AS_STRING(asciifmt));\n    if (view->format == NULL) {\n        /* NOT_REACHED: get_native_fmtchar() already validates the format. */\n        PyErr_SetString(PyExc_RuntimeError,\n            \"memoryview: internal error\");\n        goto out;\n    }\n    view->itemsize = itemsize;\n\n    view->ndim = 1;\n    view->shape[0] = view->len / view->itemsize;\n    view->strides[0] = view->itemsize;\n    view->suboffsets = NULL;\n\n    init_flags(mv);\n\n    ret = 0;\n\nout:\n    Py_DECREF(asciifmt);\n    return ret;\n}\n\n/* The memoryview must have space for 3*len(seq) elements. */\nstatic Py_ssize_t\ncopy_shape(Py_ssize_t *shape, const PyObject *seq, Py_ssize_t ndim,\n           Py_ssize_t itemsize)\n{\n    Py_ssize_t x, i;\n    Py_ssize_t len = itemsize;\n\n    for (i = 0; i < ndim; i++) {\n        PyObject *tmp = PySequence_Fast_GET_ITEM(seq, i);\n        if (!PyLong_Check(tmp)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"memoryview.cast(): elements of shape must be integers\");\n            return -1;\n        }\n        x = PyLong_AsSsize_t(tmp);\n        if (x == -1 && PyErr_Occurred()) {\n            return -1;\n        }\n        if (x <= 0) {\n            /* In general elements of shape may be 0, but not for casting. */\n            PyErr_Format(PyExc_ValueError,\n                \"memoryview.cast(): elements of shape must be integers > 0\");\n            return -1;\n        }\n        if (x > PY_SSIZE_T_MAX / len) {\n            PyErr_Format(PyExc_ValueError,\n                \"memoryview.cast(): product(shape) > SSIZE_MAX\");\n            return -1;\n        }\n        len *= x;\n        shape[i] = x;\n    }\n\n    return len;\n}\n\n/* Cast a 1-D array to a new shape. The result array will be C-contiguous.\n   If the result array does not have exactly the same byte length as the\n   input array, raise ValueError. */\nstatic int\ncast_to_ND(PyMemoryViewObject *mv, const PyObject *shape, int ndim)\n{\n    Py_buffer *view = &mv->view;\n    Py_ssize_t len;\n\n    assert(view->ndim == 1); /* ndim from cast_to_1D() */\n    assert(Py_SIZE(mv) == 3*(ndim==0?1:ndim)); /* ndim of result array */\n    assert(view->shape == mv->ob_array);\n    assert(view->strides == mv->ob_array + (ndim==0?1:ndim));\n    assert(view->suboffsets == NULL);\n\n    view->ndim = ndim;\n    if (view->ndim == 0) {\n        view->shape = NULL;\n        view->strides = NULL;\n        len = view->itemsize;\n    }\n    else {\n        len = copy_shape(view->shape, shape, ndim, view->itemsize);\n        if (len < 0)\n            return -1;\n        init_strides_from_shape(view);\n    }\n\n    if (view->len != len) {\n        PyErr_SetString(PyExc_TypeError,\n            \"memoryview: product(shape) * itemsize != buffer size\");\n        return -1;\n    }\n\n    init_flags(mv);\n\n    return 0;\n}\n\nstatic int\nzero_in_shape(PyMemoryViewObject *mv)\n{\n    Py_buffer *view = &mv->view;\n    Py_ssize_t i;\n\n    for (i = 0; i < view->ndim; i++)\n        if (view->shape[i] == 0)\n            return 1;\n\n    return 0;\n}\n\n/*\n   Cast a copy of 'self' to a different view. The input view must\n   be C-contiguous. The function always casts the input view to a\n   1-D output according to 'format'. At least one of input-format,\n   output-format must have byte size.\n\n   If 'shape' is given, the 1-D view from the previous step will\n   be cast to a C-contiguous view with new shape and strides.\n\n   All casts must result in views that will have the exact byte\n   size of the original input. Otherwise, an error is raised.\n*/\n/*[clinic input]\nmemoryview.cast\n\n    format: unicode\n    shape: object = NULL\n\nCast a memoryview to a new format or shape.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_cast_impl(PyMemoryViewObject *self, PyObject *format,\n                     PyObject *shape)\n/*[clinic end generated code: output=bae520b3a389cbab input=138936cc9041b1a3]*/\n{\n    PyMemoryViewObject *mv = NULL;\n    Py_ssize_t ndim = 1;\n\n    CHECK_RELEASED(self);\n    CHECK_RESTRICTED(self);\n\n    if (!MV_C_CONTIGUOUS(self->flags)) {\n        PyErr_SetString(PyExc_TypeError,\n            \"memoryview: casts are restricted to C-contiguous views\");\n        return NULL;\n    }\n    if ((shape || self->view.ndim != 1) && zero_in_shape(self)) {\n        PyErr_SetString(PyExc_TypeError,\n            \"memoryview: cannot cast view with zeros in shape or strides\");\n        return NULL;\n    }\n    if (shape) {\n        CHECK_LIST_OR_TUPLE(shape)\n        ndim = PySequence_Fast_GET_SIZE(shape);\n        if (ndim > PyBUF_MAX_NDIM) {\n            PyErr_SetString(PyExc_ValueError,\n                \"memoryview: number of dimensions must not exceed \"\n                Py_STRINGIFY(PyBUF_MAX_NDIM));\n            return NULL;\n        }\n        if (self->view.ndim != 1 && ndim != 1) {\n            PyErr_SetString(PyExc_TypeError,\n                \"memoryview: cast must be 1D -> ND or ND -> 1D\");\n            return NULL;\n        }\n    }\n\n    mv = (PyMemoryViewObject *)\n        mbuf_add_incomplete_view(self->mbuf, &self->view, ndim==0 ? 1 : (int)ndim);\n    if (mv == NULL)\n        return NULL;\n\n    if (cast_to_1D(mv, format) < 0)\n        goto error;\n    if (shape && cast_to_ND(mv, shape, (int)ndim) < 0)\n        goto error;\n\n    return (PyObject *)mv;\n\nerror:\n    Py_DECREF(mv);\n    return NULL;\n}\n\n/*[clinic input]\nmemoryview.toreadonly\n\nReturn a readonly version of the memoryview.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_toreadonly_impl(PyMemoryViewObject *self)\n/*[clinic end generated code: output=2c7e056f04c99e62 input=dc06d20f19ba236f]*/\n{\n    CHECK_RELEASED(self);\n    CHECK_RESTRICTED(self);\n    /* Even if self is already readonly, we still need to create a new\n     * object for .release() to work correctly.\n     */\n    self = (PyMemoryViewObject *) mbuf_add_view(self->mbuf, &self->view);\n    if (self != NULL) {\n        self->view.readonly = 1;\n    };\n    return (PyObject *) self;\n}\n\n\n/**************************************************************************/\n/*                               getbuffer                                */\n/**************************************************************************/\n\nstatic int\nmemory_getbuf(PyMemoryViewObject *self, Py_buffer *view, int flags)\n{\n    Py_buffer *base = &self->view;\n    int baseflags = self->flags;\n\n    CHECK_RELEASED_INT(self);\n    CHECK_RESTRICTED_INT(self);\n\n    /* start with complete information */\n    *view = *base;\n    view->obj = NULL;\n\n    if (REQ_WRITABLE(flags) && base->readonly) {\n        PyErr_SetString(PyExc_BufferError,\n            \"memoryview: underlying buffer is not writable\");\n        return -1;\n    }\n    if (!REQ_FORMAT(flags)) {\n        /* NULL indicates that the buffer's data type has been cast to 'B'.\n           view->itemsize is the _previous_ itemsize. If shape is present,\n           the equality product(shape) * itemsize = len still holds at this\n           point. The equality calcsize(format) = itemsize does _not_ hold\n           from here on! */\n        view->format = NULL;\n    }\n\n    if (REQ_C_CONTIGUOUS(flags) && !MV_C_CONTIGUOUS(baseflags)) {\n        PyErr_SetString(PyExc_BufferError,\n            \"memoryview: underlying buffer is not C-contiguous\");\n        return -1;\n    }\n    if (REQ_F_CONTIGUOUS(flags) && !MV_F_CONTIGUOUS(baseflags)) {\n        PyErr_SetString(PyExc_BufferError,\n            \"memoryview: underlying buffer is not Fortran contiguous\");\n        return -1;\n    }\n    if (REQ_ANY_CONTIGUOUS(flags) && !MV_ANY_CONTIGUOUS(baseflags)) {\n        PyErr_SetString(PyExc_BufferError,\n            \"memoryview: underlying buffer is not contiguous\");\n        return -1;\n    }\n    if (!REQ_INDIRECT(flags) && (baseflags & _Py_MEMORYVIEW_PIL)) {\n        PyErr_SetString(PyExc_BufferError,\n            \"memoryview: underlying buffer requires suboffsets\");\n        return -1;\n    }\n    if (!REQ_STRIDES(flags)) {\n        if (!MV_C_CONTIGUOUS(baseflags)) {\n            PyErr_SetString(PyExc_BufferError,\n                \"memoryview: underlying buffer is not C-contiguous\");\n            return -1;\n        }\n        view->strides = NULL;\n    }\n    if (!REQ_SHAPE(flags)) {\n        /* PyBUF_SIMPLE or PyBUF_WRITABLE: at this point buf is C-contiguous,\n           so base->buf = ndbuf->data. */\n        if (view->format != NULL) {\n            /* PyBUF_SIMPLE|PyBUF_FORMAT and PyBUF_WRITABLE|PyBUF_FORMAT do\n               not make sense. */\n            PyErr_Format(PyExc_BufferError,\n                \"memoryview: cannot cast to unsigned bytes if the format flag \"\n                \"is present\");\n            return -1;\n        }\n        /* product(shape) * itemsize = len and calcsize(format) = itemsize\n           do _not_ hold from here on! */\n        view->ndim = 1;\n        view->shape = NULL;\n    }\n\n\n    view->obj = Py_NewRef(self);\n    self->exports++;\n\n    return 0;\n}\n\nstatic void\nmemory_releasebuf(PyMemoryViewObject *self, Py_buffer *view)\n{\n    self->exports--;\n    return;\n    /* PyBuffer_Release() decrements view->obj after this function returns. */\n}\n\n/* Buffer methods */\nstatic PyBufferProcs memory_as_buffer = {\n    (getbufferproc)memory_getbuf,         /* bf_getbuffer */\n    (releasebufferproc)memory_releasebuf, /* bf_releasebuffer */\n};\n\n\n/****************************************************************************/\n/*           Optimized pack/unpack for all native format specifiers         */\n/****************************************************************************/\n\n/*\n  Fix exceptions:\n     1) Include format string in the error message.\n     2) OverflowError -> ValueError.\n     3) The error message from PyNumber_Index() is not ideal.\n*/\nstatic int\ntype_error_int(const char *fmt)\n{\n    PyErr_Format(PyExc_TypeError,\n        \"memoryview: invalid type for format '%s'\", fmt);\n    return -1;\n}\n\nstatic int\nvalue_error_int(const char *fmt)\n{\n    PyErr_Format(PyExc_ValueError,\n        \"memoryview: invalid value for format '%s'\", fmt);\n    return -1;\n}\n\nstatic int\nfix_error_int(const char *fmt)\n{\n    assert(PyErr_Occurred());\n    if (PyErr_ExceptionMatches(PyExc_TypeError)) {\n        PyErr_Clear();\n        return type_error_int(fmt);\n    }\n    else if (PyErr_ExceptionMatches(PyExc_OverflowError) ||\n             PyErr_ExceptionMatches(PyExc_ValueError)) {\n        PyErr_Clear();\n        return value_error_int(fmt);\n    }\n\n    return -1;\n}\n\n/* Accept integer objects or objects with an __index__() method. */\nstatic long\npylong_as_ld(PyObject *item)\n{\n    PyObject *tmp;\n    long ld;\n\n    tmp = _PyNumber_Index(item);\n    if (tmp == NULL)\n        return -1;\n\n    ld = PyLong_AsLong(tmp);\n    Py_DECREF(tmp);\n    return ld;\n}\n\nstatic unsigned long\npylong_as_lu(PyObject *item)\n{\n    PyObject *tmp;\n    unsigned long lu;\n\n    tmp = _PyNumber_Index(item);\n    if (tmp == NULL)\n        return (unsigned long)-1;\n\n    lu = PyLong_AsUnsignedLong(tmp);\n    Py_DECREF(tmp);\n    return lu;\n}\n\nstatic long long\npylong_as_lld(PyObject *item)\n{\n    PyObject *tmp;\n    long long lld;\n\n    tmp = _PyNumber_Index(item);\n    if (tmp == NULL)\n        return -1;\n\n    lld = PyLong_AsLongLong(tmp);\n    Py_DECREF(tmp);\n    return lld;\n}\n\nstatic unsigned long long\npylong_as_llu(PyObject *item)\n{\n    PyObject *tmp;\n    unsigned long long llu;\n\n    tmp = _PyNumber_Index(item);\n    if (tmp == NULL)\n        return (unsigned long long)-1;\n\n    llu = PyLong_AsUnsignedLongLong(tmp);\n    Py_DECREF(tmp);\n    return llu;\n}\n\nstatic Py_ssize_t\npylong_as_zd(PyObject *item)\n{\n    PyObject *tmp;\n    Py_ssize_t zd;\n\n    tmp = _PyNumber_Index(item);\n    if (tmp == NULL)\n        return -1;\n\n    zd = PyLong_AsSsize_t(tmp);\n    Py_DECREF(tmp);\n    return zd;\n}\n\nstatic size_t\npylong_as_zu(PyObject *item)\n{\n    PyObject *tmp;\n    size_t zu;\n\n    tmp = _PyNumber_Index(item);\n    if (tmp == NULL)\n        return (size_t)-1;\n\n    zu = PyLong_AsSize_t(tmp);\n    Py_DECREF(tmp);\n    return zu;\n}\n\n/* Timings with the ndarray from _testbuffer.c indicate that using the\n   struct module is around 15x slower than the two functions below. */\n\n#define UNPACK_SINGLE(dest, ptr, type) \\\n    do {                                   \\\n        type x;                            \\\n        memcpy((char *)&x, ptr, sizeof x); \\\n        dest = x;                          \\\n    } while (0)\n\n/* Unpack a single item. 'fmt' can be any native format character in struct\n   module syntax. This function is very sensitive to small changes. With this\n   layout gcc automatically generates a fast jump table. */\nstatic inline PyObject *\nunpack_single(PyMemoryViewObject *self, const char *ptr, const char *fmt)\n{\n    unsigned long long llu;\n    unsigned long lu;\n    size_t zu;\n    long long lld;\n    long ld;\n    Py_ssize_t zd;\n    double d;\n    unsigned char uc;\n    void *p;\n\n    CHECK_RELEASED_AGAIN(self);\n\n#if PY_LITTLE_ENDIAN\n    int endian = 1;\n#else\n    int endian = 0;\n#endif\n\n    switch (fmt[0]) {\n\n    /* signed integers and fast path for 'B' */\n    case 'B': uc = *((const unsigned char *)ptr); goto convert_uc;\n    case 'b': ld =   *((const signed char *)ptr); goto convert_ld;\n    case 'h': UNPACK_SINGLE(ld, ptr, short); goto convert_ld;\n    case 'i': UNPACK_SINGLE(ld, ptr, int); goto convert_ld;\n    case 'l': UNPACK_SINGLE(ld, ptr, long); goto convert_ld;\n\n    /* boolean */\n    case '?': UNPACK_SINGLE(ld, ptr, _Bool); goto convert_bool;\n\n    /* unsigned integers */\n    case 'H': UNPACK_SINGLE(lu, ptr, unsigned short); goto convert_lu;\n    case 'I': UNPACK_SINGLE(lu, ptr, unsigned int); goto convert_lu;\n    case 'L': UNPACK_SINGLE(lu, ptr, unsigned long); goto convert_lu;\n\n    /* native 64-bit */\n    case 'q': UNPACK_SINGLE(lld, ptr, long long); goto convert_lld;\n    case 'Q': UNPACK_SINGLE(llu, ptr, unsigned long long); goto convert_llu;\n\n    /* ssize_t and size_t */\n    case 'n': UNPACK_SINGLE(zd, ptr, Py_ssize_t); goto convert_zd;\n    case 'N': UNPACK_SINGLE(zu, ptr, size_t); goto convert_zu;\n\n    /* floats */\n    case 'f': UNPACK_SINGLE(d, ptr, float); goto convert_double;\n    case 'd': UNPACK_SINGLE(d, ptr, double); goto convert_double;\n    case 'e': d = PyFloat_Unpack2(ptr, endian); goto convert_double;\n\n    /* bytes object */\n    case 'c': goto convert_bytes;\n\n    /* pointer */\n    case 'P': UNPACK_SINGLE(p, ptr, void *); goto convert_pointer;\n\n    /* default */\n    default: goto err_format;\n    }\n\nconvert_uc:\n    /* PyLong_FromUnsignedLong() is slower */\n    return PyLong_FromLong(uc);\nconvert_ld:\n    return PyLong_FromLong(ld);\nconvert_lu:\n    return PyLong_FromUnsignedLong(lu);\nconvert_lld:\n    return PyLong_FromLongLong(lld);\nconvert_llu:\n    return PyLong_FromUnsignedLongLong(llu);\nconvert_zd:\n    return PyLong_FromSsize_t(zd);\nconvert_zu:\n    return PyLong_FromSize_t(zu);\nconvert_double:\n    return PyFloat_FromDouble(d);\nconvert_bool:\n    return PyBool_FromLong(ld);\nconvert_bytes:\n    return PyBytes_FromStringAndSize(ptr, 1);\nconvert_pointer:\n    return PyLong_FromVoidPtr(p);\nerr_format:\n    PyErr_Format(PyExc_NotImplementedError,\n        \"memoryview: format %s not supported\", fmt);\n    return NULL;\n}\n\n#define PACK_SINGLE(ptr, src, type) \\\n    do {                                     \\\n        type x;                              \\\n        x = (type)src;                       \\\n        memcpy(ptr, (char *)&x, sizeof x);   \\\n    } while (0)\n\n/* Pack a single item. 'fmt' can be any native format character in\n   struct module syntax. */\nstatic int\npack_single(PyMemoryViewObject *self, char *ptr, PyObject *item, const char *fmt)\n{\n    unsigned long long llu;\n    unsigned long lu;\n    size_t zu;\n    long long lld;\n    long ld;\n    Py_ssize_t zd;\n    double d;\n    void *p;\n\n#if PY_LITTLE_ENDIAN\n    int endian = 1;\n#else\n    int endian = 0;\n#endif\n    switch (fmt[0]) {\n    /* signed integers */\n    case 'b': case 'h': case 'i': case 'l':\n        ld = pylong_as_ld(item);\n        if (ld == -1 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        switch (fmt[0]) {\n        case 'b':\n            if (ld < SCHAR_MIN || ld > SCHAR_MAX) goto err_range;\n            *((signed char *)ptr) = (signed char)ld; break;\n        case 'h':\n            if (ld < SHRT_MIN || ld > SHRT_MAX) goto err_range;\n            PACK_SINGLE(ptr, ld, short); break;\n        case 'i':\n            if (ld < INT_MIN || ld > INT_MAX) goto err_range;\n            PACK_SINGLE(ptr, ld, int); break;\n        default: /* 'l' */\n            PACK_SINGLE(ptr, ld, long); break;\n        }\n        break;\n\n    /* unsigned integers */\n    case 'B': case 'H': case 'I': case 'L':\n        lu = pylong_as_lu(item);\n        if (lu == (unsigned long)-1 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        switch (fmt[0]) {\n        case 'B':\n            if (lu > UCHAR_MAX) goto err_range;\n            *((unsigned char *)ptr) = (unsigned char)lu; break;\n        case 'H':\n            if (lu > USHRT_MAX) goto err_range;\n            PACK_SINGLE(ptr, lu, unsigned short); break;\n        case 'I':\n            if (lu > UINT_MAX) goto err_range;\n            PACK_SINGLE(ptr, lu, unsigned int); break;\n        default: /* 'L' */\n            PACK_SINGLE(ptr, lu, unsigned long); break;\n        }\n        break;\n\n    /* native 64-bit */\n    case 'q':\n        lld = pylong_as_lld(item);\n        if (lld == -1 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        PACK_SINGLE(ptr, lld, long long);\n        break;\n    case 'Q':\n        llu = pylong_as_llu(item);\n        if (llu == (unsigned long long)-1 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        PACK_SINGLE(ptr, llu, unsigned long long);\n        break;\n\n    /* ssize_t and size_t */\n    case 'n':\n        zd = pylong_as_zd(item);\n        if (zd == -1 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        PACK_SINGLE(ptr, zd, Py_ssize_t);\n        break;\n    case 'N':\n        zu = pylong_as_zu(item);\n        if (zu == (size_t)-1 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        PACK_SINGLE(ptr, zu, size_t);\n        break;\n\n    /* floats */\n    case 'f': case 'd': case 'e':\n        d = PyFloat_AsDouble(item);\n        if (d == -1.0 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        if (fmt[0] == 'f') {\n            PACK_SINGLE(ptr, d, float);\n        }\n        else if (fmt[0] == 'd') {\n            PACK_SINGLE(ptr, d, double);\n        }\n        else {\n            if (PyFloat_Pack2(d, ptr, endian) < 0) {\n                goto err_occurred;\n            }\n        }\n        break;\n\n    /* bool */\n    case '?':\n        ld = PyObject_IsTrue(item);\n        if (ld < 0)\n            return -1; /* preserve original error */\n        CHECK_RELEASED_INT_AGAIN(self);\n        PACK_SINGLE(ptr, ld, _Bool);\n        break;\n\n    /* bytes object */\n    case 'c':\n        if (!PyBytes_Check(item))\n            return type_error_int(fmt);\n        if (PyBytes_GET_SIZE(item) != 1)\n            return value_error_int(fmt);\n        *ptr = PyBytes_AS_STRING(item)[0];\n        break;\n\n    /* pointer */\n    case 'P':\n        p = PyLong_AsVoidPtr(item);\n        if (p == NULL && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        PACK_SINGLE(ptr, p, void *);\n        break;\n\n    /* default */\n    default: goto err_format;\n    }\n\n    return 0;\n\nerr_occurred:\n    return fix_error_int(fmt);\nerr_range:\n    return value_error_int(fmt);\nerr_format:\n    PyErr_Format(PyExc_NotImplementedError,\n        \"memoryview: format %s not supported\", fmt);\n    return -1;\n}\n\n\n/****************************************************************************/\n/*                       unpack using the struct module                     */\n/****************************************************************************/\n\n/* For reasonable performance it is necessary to cache all objects required\n   for unpacking. An unpacker can handle the format passed to unpack_from().\n   Invariant: All pointer fields of the struct should either be NULL or valid\n   pointers. */\nstruct unpacker {\n    PyObject *unpack_from; /* Struct.unpack_from(format) */\n    PyObject *mview;       /* cached memoryview */\n    char *item;            /* buffer for mview */\n    Py_ssize_t itemsize;   /* len(item) */\n};\n\nstatic struct unpacker *\nunpacker_new(void)\n{\n    struct unpacker *x = PyMem_Malloc(sizeof *x);\n\n    if (x == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    x->unpack_from = NULL;\n    x->mview = NULL;\n    x->item = NULL;\n    x->itemsize = 0;\n\n    return x;\n}\n\nstatic void\nunpacker_free(struct unpacker *x)\n{\n    if (x) {\n        Py_XDECREF(x->unpack_from);\n        Py_XDECREF(x->mview);\n        PyMem_Free(x->item);\n        PyMem_Free(x);\n    }\n}\n\n/* Return a new unpacker for the given format. */\nstatic struct unpacker *\nstruct_get_unpacker(const char *fmt, Py_ssize_t itemsize)\n{\n    PyObject *Struct = NULL;    /* XXX cache it in globals? */\n    PyObject *structobj = NULL;\n    PyObject *format = NULL;\n    struct unpacker *x = NULL;\n\n    Struct = _PyImport_GetModuleAttrString(\"struct\", \"Struct\");\n    if (Struct == NULL)\n        return NULL;\n\n    x = unpacker_new();\n    if (x == NULL)\n        goto error;\n\n    format = PyBytes_FromString(fmt);\n    if (format == NULL)\n        goto error;\n\n    structobj = PyObject_CallOneArg(Struct, format);\n    if (structobj == NULL)\n        goto error;\n\n    x->unpack_from = PyObject_GetAttrString(structobj, \"unpack_from\");\n    if (x->unpack_from == NULL)\n        goto error;\n\n    x->item = PyMem_Malloc(itemsize);\n    if (x->item == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n    x->itemsize = itemsize;\n\n    x->mview = PyMemoryView_FromMemory(x->item, itemsize, PyBUF_WRITE);\n    if (x->mview == NULL)\n        goto error;\n\n\nout:\n    Py_XDECREF(Struct);\n    Py_XDECREF(format);\n    Py_XDECREF(structobj);\n    return x;\n\nerror:\n    unpacker_free(x);\n    x = NULL;\n    goto out;\n}\n\n/* unpack a single item */\nstatic PyObject *\nstruct_unpack_single(const char *ptr, struct unpacker *x)\n{\n    PyObject *v;\n\n    memcpy(x->item, ptr, x->itemsize);\n    v = PyObject_CallOneArg(x->unpack_from, x->mview);\n    if (v == NULL)\n        return NULL;\n\n    if (PyTuple_GET_SIZE(v) == 1) {\n        PyObject *res = Py_NewRef(PyTuple_GET_ITEM(v, 0));\n        Py_DECREF(v);\n        return res;\n    }\n\n    return v;\n}\n\n\n/****************************************************************************/\n/*                              Representations                             */\n/****************************************************************************/\n\n/* allow explicit form of native format */\nstatic inline const char *\nadjust_fmt(const Py_buffer *view)\n{\n    const char *fmt;\n\n    fmt = (view->format[0] == '@') ? view->format+1 : view->format;\n    if (fmt[0] && fmt[1] == '\\0')\n        return fmt;\n\n    PyErr_Format(PyExc_NotImplementedError,\n        \"memoryview: unsupported format %s\", view->format);\n    return NULL;\n}\n\n/* Base case for multi-dimensional unpacking. Assumption: ndim == 1. */\nstatic PyObject *\ntolist_base(PyMemoryViewObject *self, const char *ptr, const Py_ssize_t *shape,\n            const Py_ssize_t *strides, const Py_ssize_t *suboffsets,\n            const char *fmt)\n{\n    PyObject *lst, *item;\n    Py_ssize_t i;\n\n    lst = PyList_New(shape[0]);\n    if (lst == NULL)\n        return NULL;\n\n    for (i = 0; i < shape[0]; ptr+=strides[0], i++) {\n        const char *xptr = ADJUST_PTR(ptr, suboffsets, 0);\n        item = unpack_single(self, xptr, fmt);\n        if (item == NULL) {\n            Py_DECREF(lst);\n            return NULL;\n        }\n        PyList_SET_ITEM(lst, i, item);\n    }\n\n    return lst;\n}\n\n/* Unpack a multi-dimensional array into a nested list.\n   Assumption: ndim >= 1. */\nstatic PyObject *\ntolist_rec(PyMemoryViewObject *self, const char *ptr, Py_ssize_t ndim, const Py_ssize_t *shape,\n           const Py_ssize_t *strides, const Py_ssize_t *suboffsets,\n           const char *fmt)\n{\n    PyObject *lst, *item;\n    Py_ssize_t i;\n\n    assert(ndim >= 1);\n    assert(shape != NULL);\n    assert(strides != NULL);\n\n    if (ndim == 1)\n        return tolist_base(self, ptr, shape, strides, suboffsets, fmt);\n\n    lst = PyList_New(shape[0]);\n    if (lst == NULL)\n        return NULL;\n\n    for (i = 0; i < shape[0]; ptr+=strides[0], i++) {\n        const char *xptr = ADJUST_PTR(ptr, suboffsets, 0);\n        item = tolist_rec(self, xptr, ndim-1, shape+1,\n                          strides+1, suboffsets ? suboffsets+1 : NULL,\n                          fmt);\n        if (item == NULL) {\n            Py_DECREF(lst);\n            return NULL;\n        }\n        PyList_SET_ITEM(lst, i, item);\n    }\n\n    return lst;\n}\n\n/* Return a list representation of the memoryview. Currently only buffers\n   with native format strings are supported. */\n/*[clinic input]\nmemoryview.tolist\n\nReturn the data in the buffer as a list of elements.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_tolist_impl(PyMemoryViewObject *self)\n/*[clinic end generated code: output=a6cda89214fd5a1b input=21e7d0c1860b211a]*/\n{\n    const Py_buffer *view = &self->view;\n    const char *fmt;\n\n    CHECK_RELEASED(self);\n\n    fmt = adjust_fmt(view);\n    if (fmt == NULL)\n        return NULL;\n    if (view->ndim == 0) {\n        return unpack_single(self, view->buf, fmt);\n    }\n    else if (view->ndim == 1) {\n        return tolist_base(self, view->buf, view->shape,\n                           view->strides, view->suboffsets,\n                           fmt);\n    }\n    else {\n        return tolist_rec(self, view->buf, view->ndim, view->shape,\n                          view->strides, view->suboffsets,\n                          fmt);\n    }\n}\n\n/*[clinic input]\nmemoryview.tobytes\n\n    order: str(accept={str, NoneType}, c_default=\"NULL\") = 'C'\n\nReturn the data in the buffer as a byte string.\n\nOrder can be {'C', 'F', 'A'}. When order is 'C' or 'F', the data of the\noriginal array is converted to C or Fortran order. For contiguous views,\n'A' returns an exact copy of the physical memory. In particular, in-memory\nFortran order is preserved. For non-contiguous views, the data is converted\nto C first. order=None is the same as order='C'.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_tobytes_impl(PyMemoryViewObject *self, const char *order)\n/*[clinic end generated code: output=1288b62560a32a23 input=0efa3ddaeda573a8]*/\n{\n    Py_buffer *src = VIEW_ADDR(self);\n    char ord = 'C';\n    PyObject *bytes;\n\n    CHECK_RELEASED(self);\n\n    if (order) {\n        if (strcmp(order, \"F\") == 0) {\n            ord = 'F';\n        }\n        else if (strcmp(order, \"A\") == 0) {\n            ord = 'A';\n        }\n        else if (strcmp(order, \"C\") != 0) {\n            PyErr_SetString(PyExc_ValueError,\n                \"order must be 'C', 'F' or 'A'\");\n            return NULL;\n        }\n    }\n\n    bytes = PyBytes_FromStringAndSize(NULL, src->len);\n    if (bytes == NULL)\n        return NULL;\n\n    if (PyBuffer_ToContiguous(PyBytes_AS_STRING(bytes), src, src->len, ord) < 0) {\n        Py_DECREF(bytes);\n        return NULL;\n    }\n\n    return bytes;\n}\n\n/*[clinic input]\nmemoryview.hex\n\n    sep: object = NULL\n        An optional single character or byte to separate hex bytes.\n    bytes_per_sep: int = 1\n        How many bytes between separators.  Positive values count from the\n        right, negative values count from the left.\n\nReturn the data in the buffer as a str of hexadecimal numbers.\n\nExample:\n>>> value = memoryview(b'\\xb9\\x01\\xef')\n>>> value.hex()\n'b901ef'\n>>> value.hex(':')\n'b9:01:ef'\n>>> value.hex(':', 2)\n'b9:01ef'\n>>> value.hex(':', -2)\n'b901:ef'\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_hex_impl(PyMemoryViewObject *self, PyObject *sep,\n                    int bytes_per_sep)\n/*[clinic end generated code: output=430ca760f94f3ca7 input=539f6a3a5fb56946]*/\n{\n    Py_buffer *src = VIEW_ADDR(self);\n    PyObject *bytes;\n    PyObject *ret;\n\n    CHECK_RELEASED(self);\n\n    if (MV_C_CONTIGUOUS(self->flags)) {\n        return _Py_strhex_with_sep(src->buf, src->len, sep, bytes_per_sep);\n    }\n\n    bytes = PyBytes_FromStringAndSize(NULL, src->len);\n    if (bytes == NULL)\n        return NULL;\n\n    if (PyBuffer_ToContiguous(PyBytes_AS_STRING(bytes), src, src->len, 'C') < 0) {\n        Py_DECREF(bytes);\n        return NULL;\n    }\n\n    ret = _Py_strhex_with_sep(\n            PyBytes_AS_STRING(bytes), PyBytes_GET_SIZE(bytes),\n            sep, bytes_per_sep);\n    Py_DECREF(bytes);\n\n    return ret;\n}\n\nstatic PyObject *\nmemory_repr(PyMemoryViewObject *self)\n{\n    if (self->flags & _Py_MEMORYVIEW_RELEASED)\n        return PyUnicode_FromFormat(\"<released memory at %p>\", self);\n    else\n        return PyUnicode_FromFormat(\"<memory at %p>\", self);\n}\n\n\n/**************************************************************************/\n/*                          Indexing and slicing                          */\n/**************************************************************************/\n\nstatic char *\nlookup_dimension(const Py_buffer *view, char *ptr, int dim, Py_ssize_t index)\n{\n    Py_ssize_t nitems; /* items in the given dimension */\n\n    assert(view->shape);\n    assert(view->strides);\n\n    nitems = view->shape[dim];\n    if (index < 0) {\n        index += nitems;\n    }\n    if (index < 0 || index >= nitems) {\n        PyErr_Format(PyExc_IndexError,\n                     \"index out of bounds on dimension %d\", dim + 1);\n        return NULL;\n    }\n\n    ptr += view->strides[dim] * index;\n\n    ptr = ADJUST_PTR(ptr, view->suboffsets, dim);\n\n    return ptr;\n}\n\n/* Get the pointer to the item at index. */\nstatic char *\nptr_from_index(const Py_buffer *view, Py_ssize_t index)\n{\n    char *ptr = (char *)view->buf;\n    return lookup_dimension(view, ptr, 0, index);\n}\n\n/* Get the pointer to the item at tuple. */\nstatic char *\nptr_from_tuple(const Py_buffer *view, PyObject *tup)\n{\n    char *ptr = (char *)view->buf;\n    Py_ssize_t dim, nindices = PyTuple_GET_SIZE(tup);\n\n    if (nindices > view->ndim) {\n        PyErr_Format(PyExc_TypeError,\n                     \"cannot index %zd-dimension view with %zd-element tuple\",\n                     view->ndim, nindices);\n        return NULL;\n    }\n\n    for (dim = 0; dim < nindices; dim++) {\n        Py_ssize_t index;\n        index = PyNumber_AsSsize_t(PyTuple_GET_ITEM(tup, dim),\n                                   PyExc_IndexError);\n        if (index == -1 && PyErr_Occurred())\n            return NULL;\n        ptr = lookup_dimension(view, ptr, (int)dim, index);\n        if (ptr == NULL)\n            return NULL;\n    }\n    return ptr;\n}\n\n/* Return the item at index. In a one-dimensional view, this is an object\n   with the type specified by view->format. Otherwise, the item is a sub-view.\n   The function is used in memory_subscript() and memory_as_sequence. */\nstatic PyObject *\nmemory_item(PyMemoryViewObject *self, Py_ssize_t index)\n{\n    Py_buffer *view = &(self->view);\n    const char *fmt;\n\n    CHECK_RELEASED(self);\n\n    fmt = adjust_fmt(view);\n    if (fmt == NULL)\n        return NULL;\n\n    if (view->ndim == 0) {\n        PyErr_SetString(PyExc_TypeError, \"invalid indexing of 0-dim memory\");\n        return NULL;\n    }\n    if (view->ndim == 1) {\n        char *ptr = ptr_from_index(view, index);\n        if (ptr == NULL)\n            return NULL;\n        return unpack_single(self, ptr, fmt);\n    }\n\n    PyErr_SetString(PyExc_NotImplementedError,\n        \"multi-dimensional sub-views are not implemented\");\n    return NULL;\n}\n\n/* Return the item at position *key* (a tuple of indices). */\nstatic PyObject *\nmemory_item_multi(PyMemoryViewObject *self, PyObject *tup)\n{\n    Py_buffer *view = &(self->view);\n    const char *fmt;\n    Py_ssize_t nindices = PyTuple_GET_SIZE(tup);\n    char *ptr;\n\n    CHECK_RELEASED(self);\n\n    fmt = adjust_fmt(view);\n    if (fmt == NULL)\n        return NULL;\n\n    if (nindices < view->ndim) {\n        PyErr_SetString(PyExc_NotImplementedError,\n                        \"sub-views are not implemented\");\n        return NULL;\n    }\n    ptr = ptr_from_tuple(view, tup);\n    if (ptr == NULL)\n        return NULL;\n    return unpack_single(self, ptr, fmt);\n}\n\nstatic inline int\ninit_slice(Py_buffer *base, PyObject *key, int dim)\n{\n    Py_ssize_t start, stop, step, slicelength;\n\n    if (PySlice_Unpack(key, &start, &stop, &step) < 0) {\n        return -1;\n    }\n    slicelength = PySlice_AdjustIndices(base->shape[dim], &start, &stop, step);\n\n\n    if (base->suboffsets == NULL || dim == 0) {\n    adjust_buf:\n        base->buf = (char *)base->buf + base->strides[dim] * start;\n    }\n    else {\n        Py_ssize_t n = dim-1;\n        while (n >= 0 && base->suboffsets[n] < 0)\n            n--;\n        if (n < 0)\n            goto adjust_buf; /* all suboffsets are negative */\n        base->suboffsets[n] = base->suboffsets[n] + base->strides[dim] * start;\n    }\n    base->shape[dim] = slicelength;\n    base->strides[dim] = base->strides[dim] * step;\n\n    return 0;\n}\n\nstatic int\nis_multislice(PyObject *key)\n{\n    Py_ssize_t size, i;\n\n    if (!PyTuple_Check(key))\n        return 0;\n    size = PyTuple_GET_SIZE(key);\n    if (size == 0)\n        return 0;\n\n    for (i = 0; i < size; i++) {\n        PyObject *x = PyTuple_GET_ITEM(key, i);\n        if (!PySlice_Check(x))\n            return 0;\n    }\n    return 1;\n}\n\nstatic Py_ssize_t\nis_multiindex(PyObject *key)\n{\n    Py_ssize_t size, i;\n\n    if (!PyTuple_Check(key))\n        return 0;\n    size = PyTuple_GET_SIZE(key);\n    for (i = 0; i < size; i++) {\n        PyObject *x = PyTuple_GET_ITEM(key, i);\n        if (!_PyIndex_Check(x)) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\n/* mv[obj] returns an object holding the data for one element if obj\n   fully indexes the memoryview or another memoryview object if it\n   does not.\n\n   0-d memoryview objects can be referenced using mv[...] or mv[()]\n   but not with anything else. */\nstatic PyObject *\nmemory_subscript(PyMemoryViewObject *self, PyObject *key)\n{\n    Py_buffer *view;\n    view = &(self->view);\n\n    CHECK_RELEASED(self);\n\n    if (view->ndim == 0) {\n        if (PyTuple_Check(key) && PyTuple_GET_SIZE(key) == 0) {\n            const char *fmt = adjust_fmt(view);\n            if (fmt == NULL)\n                return NULL;\n            return unpack_single(self, view->buf, fmt);\n        }\n        else if (key == Py_Ellipsis) {\n            return Py_NewRef(self);\n        }\n        else {\n            PyErr_SetString(PyExc_TypeError,\n                \"invalid indexing of 0-dim memory\");\n            return NULL;\n        }\n    }\n\n    if (_PyIndex_Check(key)) {\n        Py_ssize_t index;\n        index = PyNumber_AsSsize_t(key, PyExc_IndexError);\n        if (index == -1 && PyErr_Occurred())\n            return NULL;\n        return memory_item(self, index);\n    }\n    else if (PySlice_Check(key)) {\n        CHECK_RESTRICTED(self);\n        PyMemoryViewObject *sliced;\n\n        sliced = (PyMemoryViewObject *)mbuf_add_view(self->mbuf, view);\n        if (sliced == NULL)\n            return NULL;\n\n        if (init_slice(&sliced->view, key, 0) < 0) {\n            Py_DECREF(sliced);\n            return NULL;\n        }\n        init_len(&sliced->view);\n        init_flags(sliced);\n\n        return (PyObject *)sliced;\n    }\n    else if (is_multiindex(key)) {\n        return memory_item_multi(self, key);\n    }\n    else if (is_multislice(key)) {\n        PyErr_SetString(PyExc_NotImplementedError,\n            \"multi-dimensional slicing is not implemented\");\n        return NULL;\n    }\n\n    PyErr_SetString(PyExc_TypeError, \"memoryview: invalid slice key\");\n    return NULL;\n}\n\nstatic int\nmemory_ass_sub(PyMemoryViewObject *self, PyObject *key, PyObject *value)\n{\n    Py_buffer *view = &(self->view);\n    Py_buffer src;\n    const char *fmt;\n    char *ptr;\n\n    CHECK_RELEASED_INT(self);\n\n    fmt = adjust_fmt(view);\n    if (fmt == NULL)\n        return -1;\n\n    if (view->readonly) {\n        PyErr_SetString(PyExc_TypeError, \"cannot modify read-only memory\");\n        return -1;\n    }\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError, \"cannot delete memory\");\n        return -1;\n    }\n    if (view->ndim == 0) {\n        if (key == Py_Ellipsis ||\n            (PyTuple_Check(key) && PyTuple_GET_SIZE(key)==0)) {\n            ptr = (char *)view->buf;\n            return pack_single(self, ptr, value, fmt);\n        }\n        else {\n            PyErr_SetString(PyExc_TypeError,\n                \"invalid indexing of 0-dim memory\");\n            return -1;\n        }\n    }\n\n    if (_PyIndex_Check(key)) {\n        Py_ssize_t index;\n        if (1 < view->ndim) {\n            PyErr_SetString(PyExc_NotImplementedError,\n                            \"sub-views are not implemented\");\n            return -1;\n        }\n        index = PyNumber_AsSsize_t(key, PyExc_IndexError);\n        if (index == -1 && PyErr_Occurred())\n            return -1;\n        ptr = ptr_from_index(view, index);\n        if (ptr == NULL)\n            return -1;\n        return pack_single(self, ptr, value, fmt);\n    }\n    /* one-dimensional: fast path */\n    if (PySlice_Check(key) && view->ndim == 1) {\n        Py_buffer dest; /* sliced view */\n        Py_ssize_t arrays[3];\n        int ret = -1;\n\n        /* rvalue must be an exporter */\n        if (PyObject_GetBuffer(value, &src, PyBUF_FULL_RO) < 0)\n            return ret;\n\n        dest = *view;\n        dest.shape = &arrays[0]; dest.shape[0] = view->shape[0];\n        dest.strides = &arrays[1]; dest.strides[0] = view->strides[0];\n        if (view->suboffsets) {\n            dest.suboffsets = &arrays[2]; dest.suboffsets[0] = view->suboffsets[0];\n        }\n\n        if (init_slice(&dest, key, 0) < 0)\n            goto end_block;\n        dest.len = dest.shape[0] * dest.itemsize;\n\n        ret = copy_single(self, &dest, &src);\n\n    end_block:\n        PyBuffer_Release(&src);\n        return ret;\n    }\n    if (is_multiindex(key)) {\n        char *ptr;\n        if (PyTuple_GET_SIZE(key) < view->ndim) {\n            PyErr_SetString(PyExc_NotImplementedError,\n                            \"sub-views are not implemented\");\n            return -1;\n        }\n        ptr = ptr_from_tuple(view, key);\n        if (ptr == NULL)\n            return -1;\n        return pack_single(self, ptr, value, fmt);\n    }\n    if (PySlice_Check(key) || is_multislice(key)) {\n        /* Call memory_subscript() to produce a sliced lvalue, then copy\n           rvalue into lvalue. This is already implemented in _testbuffer.c. */\n        PyErr_SetString(PyExc_NotImplementedError,\n            \"memoryview slice assignments are currently restricted \"\n            \"to ndim = 1\");\n        return -1;\n    }\n\n    PyErr_SetString(PyExc_TypeError, \"memoryview: invalid slice key\");\n    return -1;\n}\n\nstatic Py_ssize_t\nmemory_length(PyMemoryViewObject *self)\n{\n    CHECK_RELEASED_INT(self);\n    if (self->view.ndim == 0) {\n        PyErr_SetString(PyExc_TypeError, \"0-dim memory has no length\");\n        return -1;\n    }\n    return self->view.shape[0];\n}\n\n/* As mapping */\nstatic PyMappingMethods memory_as_mapping = {\n    (lenfunc)memory_length,               /* mp_length */\n    (binaryfunc)memory_subscript,         /* mp_subscript */\n    (objobjargproc)memory_ass_sub,        /* mp_ass_subscript */\n};\n\n/* As sequence */\nstatic PySequenceMethods memory_as_sequence = {\n        (lenfunc)memory_length,           /* sq_length */\n        0,                                /* sq_concat */\n        0,                                /* sq_repeat */\n        (ssizeargfunc)memory_item,        /* sq_item */\n};\n\n\n/**************************************************************************/\n/*                             Comparisons                                */\n/**************************************************************************/\n\n#define MV_COMPARE_EX -1       /* exception */\n#define MV_COMPARE_NOT_IMPL -2 /* not implemented */\n\n/* Translate a StructError to \"not equal\". Preserve other exceptions. */\nstatic int\nfix_struct_error_int(void)\n{\n    assert(PyErr_Occurred());\n    /* XXX Cannot get at StructError directly? */\n    if (PyErr_ExceptionMatches(PyExc_ImportError) ||\n        PyErr_ExceptionMatches(PyExc_MemoryError)) {\n        return MV_COMPARE_EX;\n    }\n    /* StructError: invalid or unknown format -> not equal */\n    PyErr_Clear();\n    return 0;\n}\n\n/* Unpack and compare single items of p and q using the struct module. */\nstatic int\nstruct_unpack_cmp(const char *p, const char *q,\n                  struct unpacker *unpack_p, struct unpacker *unpack_q)\n{\n    PyObject *v, *w;\n    int ret;\n\n    /* At this point any exception from the struct module should not be\n       StructError, since both formats have been accepted already. */\n    v = struct_unpack_single(p, unpack_p);\n    if (v == NULL)\n        return MV_COMPARE_EX;\n\n    w = struct_unpack_single(q, unpack_q);\n    if (w == NULL) {\n        Py_DECREF(v);\n        return MV_COMPARE_EX;\n    }\n\n    /* MV_COMPARE_EX == -1: exceptions are preserved */\n    ret = PyObject_RichCompareBool(v, w, Py_EQ);\n    Py_DECREF(v);\n    Py_DECREF(w);\n\n    return ret;\n}\n\n/* Unpack and compare single items of p and q. If both p and q have the same\n   single element native format, the comparison uses a fast path (gcc creates\n   a jump table and converts memcpy into simple assignments on x86/x64).\n\n   Otherwise, the comparison is delegated to the struct module, which is\n   30-60x slower. */\n#define CMP_SINGLE(p, q, type) \\\n    do {                                 \\\n        type x;                          \\\n        type y;                          \\\n        memcpy((char *)&x, p, sizeof x); \\\n        memcpy((char *)&y, q, sizeof y); \\\n        equal = (x == y);                \\\n    } while (0)\n\nstatic inline int\nunpack_cmp(const char *p, const char *q, char fmt,\n           struct unpacker *unpack_p, struct unpacker *unpack_q)\n{\n    int equal;\n\n    switch (fmt) {\n\n    /* signed integers and fast path for 'B' */\n    case 'B': return *((const unsigned char *)p) == *((const unsigned char *)q);\n    case 'b': return *((const signed char *)p) == *((const signed char *)q);\n    case 'h': CMP_SINGLE(p, q, short); return equal;\n    case 'i': CMP_SINGLE(p, q, int); return equal;\n    case 'l': CMP_SINGLE(p, q, long); return equal;\n\n    /* boolean */\n    case '?': CMP_SINGLE(p, q, _Bool); return equal;\n\n    /* unsigned integers */\n    case 'H': CMP_SINGLE(p, q, unsigned short); return equal;\n    case 'I': CMP_SINGLE(p, q, unsigned int); return equal;\n    case 'L': CMP_SINGLE(p, q, unsigned long); return equal;\n\n    /* native 64-bit */\n    case 'q': CMP_SINGLE(p, q, long long); return equal;\n    case 'Q': CMP_SINGLE(p, q, unsigned long long); return equal;\n\n    /* ssize_t and size_t */\n    case 'n': CMP_SINGLE(p, q, Py_ssize_t); return equal;\n    case 'N': CMP_SINGLE(p, q, size_t); return equal;\n\n    /* floats */\n    /* XXX DBL_EPSILON? */\n    case 'f': CMP_SINGLE(p, q, float); return equal;\n    case 'd': CMP_SINGLE(p, q, double); return equal;\n    case 'e': {\n#if PY_LITTLE_ENDIAN\n        int endian = 1;\n#else\n        int endian = 0;\n#endif\n        /* Note: PyFloat_Unpack2 should never fail */\n        double u = PyFloat_Unpack2(p, endian);\n        double v = PyFloat_Unpack2(q, endian);\n        return (u == v);\n    }\n\n    /* bytes object */\n    case 'c': return *p == *q;\n\n    /* pointer */\n    case 'P': CMP_SINGLE(p, q, void *); return equal;\n\n    /* use the struct module */\n    case '_':\n        assert(unpack_p);\n        assert(unpack_q);\n        return struct_unpack_cmp(p, q, unpack_p, unpack_q);\n    }\n\n    /* NOT REACHED */\n    PyErr_SetString(PyExc_RuntimeError,\n        \"memoryview: internal error in richcompare\");\n    return MV_COMPARE_EX;\n}\n\n/* Base case for recursive array comparisons. Assumption: ndim == 1. */\nstatic int\ncmp_base(const char *p, const char *q, const Py_ssize_t *shape,\n         const Py_ssize_t *pstrides, const Py_ssize_t *psuboffsets,\n         const Py_ssize_t *qstrides, const Py_ssize_t *qsuboffsets,\n         char fmt, struct unpacker *unpack_p, struct unpacker *unpack_q)\n{\n    Py_ssize_t i;\n    int equal;\n\n    for (i = 0; i < shape[0]; p+=pstrides[0], q+=qstrides[0], i++) {\n        const char *xp = ADJUST_PTR(p, psuboffsets, 0);\n        const char *xq = ADJUST_PTR(q, qsuboffsets, 0);\n        equal = unpack_cmp(xp, xq, fmt, unpack_p, unpack_q);\n        if (equal <= 0)\n            return equal;\n    }\n\n    return 1;\n}\n\n/* Recursively compare two multi-dimensional arrays that have the same\n   logical structure. Assumption: ndim >= 1. */\nstatic int\ncmp_rec(const char *p, const char *q,\n        Py_ssize_t ndim, const Py_ssize_t *shape,\n        const Py_ssize_t *pstrides, const Py_ssize_t *psuboffsets,\n        const Py_ssize_t *qstrides, const Py_ssize_t *qsuboffsets,\n        char fmt, struct unpacker *unpack_p, struct unpacker *unpack_q)\n{\n    Py_ssize_t i;\n    int equal;\n\n    assert(ndim >= 1);\n    assert(shape != NULL);\n    assert(pstrides != NULL);\n    assert(qstrides != NULL);\n\n    if (ndim == 1) {\n        return cmp_base(p, q, shape,\n                        pstrides, psuboffsets,\n                        qstrides, qsuboffsets,\n                        fmt, unpack_p, unpack_q);\n    }\n\n    for (i = 0; i < shape[0]; p+=pstrides[0], q+=qstrides[0], i++) {\n        const char *xp = ADJUST_PTR(p, psuboffsets, 0);\n        const char *xq = ADJUST_PTR(q, qsuboffsets, 0);\n        equal = cmp_rec(xp, xq, ndim-1, shape+1,\n                        pstrides+1, psuboffsets ? psuboffsets+1 : NULL,\n                        qstrides+1, qsuboffsets ? qsuboffsets+1 : NULL,\n                        fmt, unpack_p, unpack_q);\n        if (equal <= 0)\n            return equal;\n    }\n\n    return 1;\n}\n\nstatic PyObject *\nmemory_richcompare(PyObject *v, PyObject *w, int op)\n{\n    PyObject *res;\n    Py_buffer wbuf, *vv;\n    Py_buffer *ww = NULL;\n    struct unpacker *unpack_v = NULL;\n    struct unpacker *unpack_w = NULL;\n    char vfmt, wfmt;\n    int equal = MV_COMPARE_NOT_IMPL;\n\n    if (op != Py_EQ && op != Py_NE)\n        goto result; /* Py_NotImplemented */\n\n    assert(PyMemoryView_Check(v));\n    if (BASE_INACCESSIBLE(v)) {\n        equal = (v == w);\n        goto result;\n    }\n    vv = VIEW_ADDR(v);\n\n    if (PyMemoryView_Check(w)) {\n        if (BASE_INACCESSIBLE(w)) {\n            equal = (v == w);\n            goto result;\n        }\n        ww = VIEW_ADDR(w);\n    }\n    else {\n        if (PyObject_GetBuffer(w, &wbuf, PyBUF_FULL_RO) < 0) {\n            PyErr_Clear();\n            goto result; /* Py_NotImplemented */\n        }\n        ww = &wbuf;\n    }\n\n    if (!equiv_shape(vv, ww)) {\n        PyErr_Clear();\n        equal = 0;\n        goto result;\n    }\n\n    /* Use fast unpacking for identical primitive C type formats. */\n    if (get_native_fmtchar(&vfmt, vv->format) < 0)\n        vfmt = '_';\n    if (get_native_fmtchar(&wfmt, ww->format) < 0)\n        wfmt = '_';\n    if (vfmt == '_' || wfmt == '_' || vfmt != wfmt) {\n        /* Use struct module unpacking. NOTE: Even for equal format strings,\n           memcmp() cannot be used for item comparison since it would give\n           incorrect results in the case of NaNs or uninitialized padding\n           bytes. */\n        vfmt = '_';\n        unpack_v = struct_get_unpacker(vv->format, vv->itemsize);\n        if (unpack_v == NULL) {\n            equal = fix_struct_error_int();\n            goto result;\n        }\n        unpack_w = struct_get_unpacker(ww->format, ww->itemsize);\n        if (unpack_w == NULL) {\n            equal = fix_struct_error_int();\n            goto result;\n        }\n    }\n\n    if (vv->ndim == 0) {\n        equal = unpack_cmp(vv->buf, ww->buf,\n                           vfmt, unpack_v, unpack_w);\n    }\n    else if (vv->ndim == 1) {\n        equal = cmp_base(vv->buf, ww->buf, vv->shape,\n                         vv->strides, vv->suboffsets,\n                         ww->strides, ww->suboffsets,\n                         vfmt, unpack_v, unpack_w);\n    }\n    else {\n        equal = cmp_rec(vv->buf, ww->buf, vv->ndim, vv->shape,\n                        vv->strides, vv->suboffsets,\n                        ww->strides, ww->suboffsets,\n                        vfmt, unpack_v, unpack_w);\n    }\n\nresult:\n    if (equal < 0) {\n        if (equal == MV_COMPARE_NOT_IMPL)\n            res = Py_NotImplemented;\n        else /* exception */\n            res = NULL;\n    }\n    else if ((equal && op == Py_EQ) || (!equal && op == Py_NE))\n        res = Py_True;\n    else\n        res = Py_False;\n\n    if (ww == &wbuf)\n        PyBuffer_Release(ww);\n\n    unpacker_free(unpack_v);\n    unpacker_free(unpack_w);\n\n    return Py_XNewRef(res);\n}\n\n/**************************************************************************/\n/*                                Hash                                    */\n/**************************************************************************/\n\nstatic Py_hash_t\nmemory_hash(PyMemoryViewObject *self)\n{\n    if (self->hash == -1) {\n        Py_buffer *view = &self->view;\n        char *mem = view->buf;\n        Py_ssize_t ret;\n        char fmt;\n\n        CHECK_RELEASED_INT(self);\n\n        if (!view->readonly) {\n            PyErr_SetString(PyExc_ValueError,\n                \"cannot hash writable memoryview object\");\n            return -1;\n        }\n        ret = get_native_fmtchar(&fmt, view->format);\n        if (ret < 0 || !IS_BYTE_FORMAT(fmt)) {\n            PyErr_SetString(PyExc_ValueError,\n                \"memoryview: hashing is restricted to formats 'B', 'b' or 'c'\");\n            return -1;\n        }\n        if (view->obj != NULL && PyObject_Hash(view->obj) == -1) {\n            /* Keep the original error message */\n            return -1;\n        }\n\n        if (!MV_C_CONTIGUOUS(self->flags)) {\n            mem = PyMem_Malloc(view->len);\n            if (mem == NULL) {\n                PyErr_NoMemory();\n                return -1;\n            }\n            if (buffer_to_contiguous(mem, view, 'C') < 0) {\n                PyMem_Free(mem);\n                return -1;\n            }\n        }\n\n        /* Can't fail */\n        self->hash = _Py_HashBytes(mem, view->len);\n\n        if (mem != view->buf)\n            PyMem_Free(mem);\n    }\n\n    return self->hash;\n}\n\n\n/**************************************************************************/\n/*                                 getters                                */\n/**************************************************************************/\n\nstatic PyObject *\n_IntTupleFromSsizet(int len, Py_ssize_t *vals)\n{\n    int i;\n    PyObject *o;\n    PyObject *intTuple;\n\n    if (vals == NULL)\n        return PyTuple_New(0);\n\n    intTuple = PyTuple_New(len);\n    if (!intTuple)\n        return NULL;\n    for (i=0; i<len; i++) {\n        o = PyLong_FromSsize_t(vals[i]);\n        if (!o) {\n            Py_DECREF(intTuple);\n            return NULL;\n        }\n        PyTuple_SET_ITEM(intTuple, i, o);\n    }\n    return intTuple;\n}\n\nstatic PyObject *\nmemory_obj_get(PyMemoryViewObject *self, void *Py_UNUSED(ignored))\n{\n    Py_buffer *view = &self->view;\n\n    CHECK_RELEASED(self);\n    if (view->obj == NULL) {\n        Py_RETURN_NONE;\n    }\n    return Py_NewRef(view->obj);\n}\n\nstatic PyObject *\nmemory_nbytes_get(PyMemoryViewObject *self, void *Py_UNUSED(ignored))\n{\n    CHECK_RELEASED(self);\n    return PyLong_FromSsize_t(self->view.len);\n}\n\nstatic PyObject *\nmemory_format_get(PyMemoryViewObject *self, void *Py_UNUSED(ignored))\n{\n    CHECK_RELEASED(self);\n    return PyUnicode_FromString(self->view.format);\n}\n\nstatic PyObject *\nmemory_itemsize_get(PyMemoryViewObject *self, void *Py_UNUSED(ignored))\n{\n    CHECK_RELEASED(self);\n    return PyLong_FromSsize_t(self->view.itemsize);\n}\n\nstatic PyObject *\nmemory_shape_get(PyMemoryViewObject *self, void *Py_UNUSED(ignored))\n{\n    CHECK_RELEASED(self);\n    return _IntTupleFromSsizet(self->view.ndim, self->view.shape);\n}\n\nstatic PyObject *\nmemory_strides_get(PyMemoryViewObject *self, void *Py_UNUSED(ignored))\n{\n    CHECK_RELEASED(self);\n    return _IntTupleFromSsizet(self->view.ndim, self->view.strides);\n}\n\nstatic PyObject *\nmemory_suboffsets_get(PyMemoryViewObject *self, void *Py_UNUSED(ignored))\n{\n    CHECK_RELEASED(self);\n    return _IntTupleFromSsizet(self->view.ndim, self->view.suboffsets);\n}\n\nstatic PyObject *\nmemory_readonly_get(PyMemoryViewObject *self, void *Py_UNUSED(ignored))\n{\n    CHECK_RELEASED(self);\n    return PyBool_FromLong(self->view.readonly);\n}\n\nstatic PyObject *\nmemory_ndim_get(PyMemoryViewObject *self, void *Py_UNUSED(ignored))\n{\n    CHECK_RELEASED(self);\n    return PyLong_FromLong(self->view.ndim);\n}\n\nstatic PyObject *\nmemory_c_contiguous(PyMemoryViewObject *self, PyObject *dummy)\n{\n    CHECK_RELEASED(self);\n    return PyBool_FromLong(MV_C_CONTIGUOUS(self->flags));\n}\n\nstatic PyObject *\nmemory_f_contiguous(PyMemoryViewObject *self, PyObject *dummy)\n{\n    CHECK_RELEASED(self);\n    return PyBool_FromLong(MV_F_CONTIGUOUS(self->flags));\n}\n\nstatic PyObject *\nmemory_contiguous(PyMemoryViewObject *self, PyObject *dummy)\n{\n    CHECK_RELEASED(self);\n    return PyBool_FromLong(MV_ANY_CONTIGUOUS(self->flags));\n}\n\nPyDoc_STRVAR(memory_obj_doc,\n             \"The underlying object of the memoryview.\");\nPyDoc_STRVAR(memory_nbytes_doc,\n             \"The amount of space in bytes that the array would use in\\n\"\n             \" a contiguous representation.\");\nPyDoc_STRVAR(memory_readonly_doc,\n             \"A bool indicating whether the memory is read only.\");\nPyDoc_STRVAR(memory_itemsize_doc,\n             \"The size in bytes of each element of the memoryview.\");\nPyDoc_STRVAR(memory_format_doc,\n             \"A string containing the format (in struct module style)\\n\"\n             \" for each element in the view.\");\nPyDoc_STRVAR(memory_ndim_doc,\n             \"An integer indicating how many dimensions of a multi-dimensional\\n\"\n             \" array the memory represents.\");\nPyDoc_STRVAR(memory_shape_doc,\n             \"A tuple of ndim integers giving the shape of the memory\\n\"\n             \" as an N-dimensional array.\");\nPyDoc_STRVAR(memory_strides_doc,\n             \"A tuple of ndim integers giving the size in bytes to access\\n\"\n             \" each element for each dimension of the array.\");\nPyDoc_STRVAR(memory_suboffsets_doc,\n             \"A tuple of integers used internally for PIL-style arrays.\");\nPyDoc_STRVAR(memory_c_contiguous_doc,\n             \"A bool indicating whether the memory is C contiguous.\");\nPyDoc_STRVAR(memory_f_contiguous_doc,\n             \"A bool indicating whether the memory is Fortran contiguous.\");\nPyDoc_STRVAR(memory_contiguous_doc,\n             \"A bool indicating whether the memory is contiguous.\");\n\n\nstatic PyGetSetDef memory_getsetlist[] = {\n    {\"obj\",             (getter)memory_obj_get,        NULL, memory_obj_doc},\n    {\"nbytes\",          (getter)memory_nbytes_get,     NULL, memory_nbytes_doc},\n    {\"readonly\",        (getter)memory_readonly_get,   NULL, memory_readonly_doc},\n    {\"itemsize\",        (getter)memory_itemsize_get,   NULL, memory_itemsize_doc},\n    {\"format\",          (getter)memory_format_get,     NULL, memory_format_doc},\n    {\"ndim\",            (getter)memory_ndim_get,       NULL, memory_ndim_doc},\n    {\"shape\",           (getter)memory_shape_get,      NULL, memory_shape_doc},\n    {\"strides\",         (getter)memory_strides_get,    NULL, memory_strides_doc},\n    {\"suboffsets\",      (getter)memory_suboffsets_get, NULL, memory_suboffsets_doc},\n    {\"c_contiguous\",    (getter)memory_c_contiguous,   NULL, memory_c_contiguous_doc},\n    {\"f_contiguous\",    (getter)memory_f_contiguous,   NULL, memory_f_contiguous_doc},\n    {\"contiguous\",      (getter)memory_contiguous,     NULL, memory_contiguous_doc},\n    {NULL, NULL, NULL, NULL},\n};\n\n\nstatic PyMethodDef memory_methods[] = {\n    MEMORYVIEW_RELEASE_METHODDEF\n    MEMORYVIEW_TOBYTES_METHODDEF\n    MEMORYVIEW_HEX_METHODDEF\n    MEMORYVIEW_TOLIST_METHODDEF\n    MEMORYVIEW_CAST_METHODDEF\n    MEMORYVIEW_TOREADONLY_METHODDEF\n    MEMORYVIEW__FROM_FLAGS_METHODDEF\n    {\"__enter__\",   memory_enter, METH_NOARGS, NULL},\n    {\"__exit__\",    memory_exit, METH_VARARGS, NULL},\n    {NULL,          NULL}\n};\n\n/**************************************************************************/\n/*                          Memoryview Iterator                           */\n/**************************************************************************/\n\nPyTypeObject _PyMemoryIter_Type;\n\ntypedef struct {\n    PyObject_HEAD\n    Py_ssize_t it_index;\n    PyMemoryViewObject *it_seq; // Set to NULL when iterator is exhausted\n    Py_ssize_t it_length;\n    const char *it_fmt;\n} memoryiterobject;\n\nstatic void\nmemoryiter_dealloc(memoryiterobject *it)\n{\n    _PyObject_GC_UNTRACK(it);\n    Py_XDECREF(it->it_seq);\n    PyObject_GC_Del(it);\n}\n\nstatic int\nmemoryiter_traverse(memoryiterobject *it, visitproc visit, void *arg)\n{\n    Py_VISIT(it->it_seq);\n    return 0;\n}\n\nstatic PyObject *\nmemoryiter_next(memoryiterobject *it)\n{\n    PyMemoryViewObject *seq;\n    seq = it->it_seq;\n    if (seq == NULL) {\n        return NULL;\n    }\n\n    if (it->it_index < it->it_length) {\n        CHECK_RELEASED(seq);\n        Py_buffer *view = &(seq->view);\n        char *ptr = (char *)seq->view.buf;\n\n        ptr += view->strides[0] * it->it_index++;\n        ptr = ADJUST_PTR(ptr, view->suboffsets, 0);\n        if (ptr == NULL) {\n            return NULL;\n        }\n        return unpack_single(seq, ptr, it->it_fmt);\n    }\n\n    it->it_seq = NULL;\n    Py_DECREF(seq);\n    return NULL;\n}\n\nstatic PyObject *\nmemory_iter(PyObject *seq)\n{\n    if (!PyMemoryView_Check(seq)) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n    PyMemoryViewObject *obj = (PyMemoryViewObject *)seq;\n    int ndims = obj->view.ndim;\n    if (ndims == 0) {\n        PyErr_SetString(PyExc_TypeError, \"invalid indexing of 0-dim memory\");\n        return NULL;\n    }\n    if (ndims != 1) {\n        PyErr_SetString(PyExc_NotImplementedError,\n            \"multi-dimensional sub-views are not implemented\");\n        return NULL;\n    }\n\n    const char *fmt = adjust_fmt(&obj->view);\n    if (fmt == NULL) {\n        return NULL;\n    }\n\n    memoryiterobject *it;\n    it = PyObject_GC_New(memoryiterobject, &_PyMemoryIter_Type);\n    if (it == NULL) {\n        return NULL;\n    }\n    it->it_fmt = fmt;\n    it->it_length = memory_length(obj);\n    it->it_index = 0;\n    it->it_seq = (PyMemoryViewObject*)Py_NewRef(obj);\n    _PyObject_GC_TRACK(it);\n    return (PyObject *)it;\n}\n\nPyTypeObject _PyMemoryIter_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    .tp_name = \"memory_iterator\",\n    .tp_basicsize = sizeof(memoryiterobject),\n    // methods\n    .tp_dealloc = (destructor)memoryiter_dealloc,\n    .tp_getattro = PyObject_GenericGetAttr,\n    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,\n    .tp_traverse = (traverseproc)memoryiter_traverse,\n    .tp_iter = PyObject_SelfIter,\n    .tp_iternext = (iternextfunc)memoryiter_next,\n};\n\nPyTypeObject PyMemoryView_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"memoryview\",                             /* tp_name */\n    offsetof(PyMemoryViewObject, ob_array),   /* tp_basicsize */\n    sizeof(Py_ssize_t),                       /* tp_itemsize */\n    (destructor)memory_dealloc,               /* tp_dealloc */\n    0,                                        /* tp_vectorcall_offset */\n    0,                                        /* tp_getattr */\n    0,                                        /* tp_setattr */\n    0,                                        /* tp_as_async */\n    (reprfunc)memory_repr,                    /* tp_repr */\n    0,                                        /* tp_as_number */\n    &memory_as_sequence,                      /* tp_as_sequence */\n    &memory_as_mapping,                       /* tp_as_mapping */\n    (hashfunc)memory_hash,                    /* tp_hash */\n    0,                                        /* tp_call */\n    0,                                        /* tp_str */\n    PyObject_GenericGetAttr,                  /* tp_getattro */\n    0,                                        /* tp_setattro */\n    &memory_as_buffer,                        /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n       Py_TPFLAGS_SEQUENCE,                   /* tp_flags */\n    memoryview__doc__,                        /* tp_doc */\n    (traverseproc)memory_traverse,            /* tp_traverse */\n    (inquiry)memory_clear,                    /* tp_clear */\n    memory_richcompare,                       /* tp_richcompare */\n    offsetof(PyMemoryViewObject, weakreflist),/* tp_weaklistoffset */\n    memory_iter,                              /* tp_iter */\n    0,                                        /* tp_iternext */\n    memory_methods,                           /* tp_methods */\n    0,                                        /* tp_members */\n    memory_getsetlist,                        /* tp_getset */\n    0,                                        /* tp_base */\n    0,                                        /* tp_dict */\n    0,                                        /* tp_descr_get */\n    0,                                        /* tp_descr_set */\n    0,                                        /* tp_dictoffset */\n    0,                                        /* tp_init */\n    0,                                        /* tp_alloc */\n    memoryview,                               /* tp_new */\n};\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/object.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_OBJECT_H\n#define Py_OBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Object and type object interface */\n\n/*\nObjects are structures allocated on the heap.  Special rules apply to\nthe use of objects to ensure they are properly garbage-collected.\nObjects are never allocated statically or on the stack; they must be\naccessed through special macros and functions only.  (Type objects are\nexceptions to the first rule; the standard types are represented by\nstatically initialized type objects, although work on type/class unification\nfor Python 2.2 made it possible to have heap-allocated type objects too).\n\nAn object has a 'reference count' that is increased or decreased when a\npointer to the object is copied or deleted; when the reference count\nreaches zero there are no references to the object left and it can be\nremoved from the heap.\n\nAn object has a 'type' that determines what it represents and what kind\nof data it contains.  An object's type is fixed when it is created.\nTypes themselves are represented as objects; an object contains a\npointer to the corresponding type object.  The type itself has a type\npointer pointing to the object representing the type 'type', which\ncontains a pointer to itself!.\n\nObjects do not float around in memory; once allocated an object keeps\nthe same size and address.  Objects that must hold variable-size data\ncan contain pointers to variable-size parts of the object.  Not all\nobjects of the same type have the same size; but the size cannot change\nafter allocation.  (These restrictions are made so a reference to an\nobject can be simply a pointer -- moving an object would require\nupdating all the pointers, and changing an object's size would require\nmoving it if there was another object right next to it.)\n\nObjects are always accessed through pointers of the type 'PyObject *'.\nThe type 'PyObject' is a structure that only contains the reference count\nand the type pointer.  The actual memory allocated for an object\ncontains other data that can only be accessed after casting the pointer\nto a pointer to a longer structure type.  This longer type must start\nwith the reference count and type fields; the macro PyObject_HEAD should be\nused for this (to accommodate for future changes).  The implementation\nof a particular object type can cast the object pointer to the proper\ntype and back.\n\nA standard interface exists for objects that contain an array of items\nwhose size is determined when the object is allocated.\n*/\n\n#include \"pystats.h\"\n\n/* Py_DEBUG implies Py_REF_DEBUG. */\n#if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)\n#  define Py_REF_DEBUG\n#endif\n\n#if defined(Py_LIMITED_API) && defined(Py_TRACE_REFS)\n#  error Py_LIMITED_API is incompatible with Py_TRACE_REFS\n#endif\n\n#ifdef Py_TRACE_REFS\n/* Define pointers to support a doubly-linked list of all live heap objects. */\n#define _PyObject_HEAD_EXTRA            \\\n    PyObject *_ob_next;           \\\n    PyObject *_ob_prev;\n\n#define _PyObject_EXTRA_INIT _Py_NULL, _Py_NULL,\n\n#else\n#  define _PyObject_HEAD_EXTRA\n#  define _PyObject_EXTRA_INIT\n#endif\n\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   PyObject ob_base;\n\n/*\nImmortalization:\n\nThe following indicates the immortalization strategy depending on the amount\nof available bits in the reference count field. All strategies are backwards\ncompatible but the specific reference count value or immortalization check\nmight change depending on the specializations for the underlying system.\n\nProper deallocation of immortal instances requires distinguishing between\nstatically allocated immortal instances vs those promoted by the runtime to be\nimmortal. The latter should be the only instances that require\ncleanup during runtime finalization.\n*/\n\n#if SIZEOF_VOID_P > 4\n/*\nIn 64+ bit systems, an object will be marked as immortal by setting all of the\nlower 32 bits of the reference count field, which is equal to: 0xFFFFFFFF\n\nUsing the lower 32 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases will use saturated arithmetic, taking advantage of\nhaving all the lower 32 bits set, which will avoid the reference count to go\nbeyond the refcount limit. Immortality checks for reference count decreases will\nbe done by checking the bit sign flag in the lower 32 bits.\n*/\n#define _Py_IMMORTAL_REFCNT UINT_MAX\n\n#else\n/*\nIn 32 bit systems, an object will be marked as immortal by setting all of the\nlower 30 bits of the reference count field, which is equal to: 0x3FFFFFFF\n\nUsing the lower 30 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases and decreases will first go through an immortality\ncheck by comparing the reference count field to the immortality reference count.\n*/\n#define _Py_IMMORTAL_REFCNT (UINT_MAX >> 2)\n#endif\n\n// Make all internal uses of PyObject_HEAD_INIT immortal while preserving the\n// C-API expectation that the refcnt will be set to 1.\n#ifdef Py_BUILD_CORE\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        _PyObject_EXTRA_INIT        \\\n        { _Py_IMMORTAL_REFCNT },    \\\n        (type)                      \\\n    },\n#else\n#define PyObject_HEAD_INIT(type) \\\n    {                            \\\n        _PyObject_EXTRA_INIT     \\\n        { 1 },                   \\\n        (type)                   \\\n    },\n#endif /* Py_BUILD_CORE */\n\n#define PyVarObject_HEAD_INIT(type, size) \\\n    {                                     \\\n        PyObject_HEAD_INIT(type)          \\\n        (size)                            \\\n    },\n\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD      PyVarObject ob_base;\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\nstruct _object {\n    _PyObject_HEAD_EXTRA\n\n#if (defined(__GNUC__) || defined(__clang__)) \\\n        && !(defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L)\n    // On C99 and older, anonymous union is a GCC and clang extension\n    __extension__\n#endif\n#ifdef _MSC_VER\n    // Ignore MSC warning C4201: \"nonstandard extension used:\n    // nameless struct/union\"\n    __pragma(warning(push))\n    __pragma(warning(disable: 4201))\n#endif\n    union {\n       Py_ssize_t ob_refcnt;\n#if SIZEOF_VOID_P > 4\n       PY_UINT32_T ob_refcnt_split[2];\n#endif\n    };\n#ifdef _MSC_VER\n    __pragma(warning(pop))\n#endif\n\n    PyTypeObject *ob_type;\n};\n\n/* Cast argument to PyObject* type. */\n#define _PyObject_CAST(op) _Py_CAST(PyObject*, (op))\n\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n/* Cast argument to PyVarObject* type. */\n#define _PyVarObject_CAST(op) _Py_CAST(PyVarObject*, (op))\n\n\n// Test if the 'x' object is the 'y' object, the same as \"x is y\" in Python.\nPyAPI_FUNC(int) Py_Is(PyObject *x, PyObject *y);\n#define Py_Is(x, y) ((x) == (y))\n\n\nstatic inline Py_ssize_t Py_REFCNT(PyObject *ob) {\n    return ob->ob_refcnt;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_REFCNT(ob) Py_REFCNT(_PyObject_CAST(ob))\n#endif\n\n\n// bpo-39573: The Py_SET_TYPE() function must be used to set an object type.\nstatic inline PyTypeObject* Py_TYPE(PyObject *ob) {\n    return ob->ob_type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_TYPE(ob) Py_TYPE(_PyObject_CAST(ob))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyLong_Type;\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n\n// bpo-39573: The Py_SET_SIZE() function must be used to set an object size.\nstatic inline Py_ssize_t Py_SIZE(PyObject *ob) {\n    assert(ob->ob_type != &PyLong_Type);\n    assert(ob->ob_type != &PyBool_Type);\n    return  _PyVarObject_CAST(ob)->ob_size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SIZE(ob) Py_SIZE(_PyObject_CAST(ob))\n#endif\n\nstatic inline Py_ALWAYS_INLINE int _Py_IsImmortal(PyObject *op)\n{\n#if SIZEOF_VOID_P > 4\n    return _Py_CAST(PY_INT32_T, op->ob_refcnt) < 0;\n#else\n    return op->ob_refcnt == _Py_IMMORTAL_REFCNT;\n#endif\n}\n#define _Py_IsImmortal(op) _Py_IsImmortal(_PyObject_CAST(op))\n\nstatic inline int Py_IS_TYPE(PyObject *ob, PyTypeObject *type) {\n    return Py_TYPE(ob) == type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_IS_TYPE(ob, type) Py_IS_TYPE(_PyObject_CAST(ob), (type))\n#endif\n\n\nstatic inline void Py_SET_REFCNT(PyObject *ob, Py_ssize_t refcnt) {\n    // This immortal check is for code that is unaware of immortal objects.\n    // The runtime tracks these objects and we should avoid as much\n    // as possible having extensions inadvertently change the refcnt\n    // of an immortalized object.\n    if (_Py_IsImmortal(ob)) {\n        return;\n    }\n    ob->ob_refcnt = refcnt;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_REFCNT(ob, refcnt) Py_SET_REFCNT(_PyObject_CAST(ob), (refcnt))\n#endif\n\n\nstatic inline void Py_SET_TYPE(PyObject *ob, PyTypeObject *type) {\n    ob->ob_type = type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_TYPE(ob, type) Py_SET_TYPE(_PyObject_CAST(ob), type)\n#endif\n\nstatic inline void Py_SET_SIZE(PyVarObject *ob, Py_ssize_t size) {\n    assert(ob->ob_base.ob_type != &PyLong_Type);\n    assert(ob->ob_base.ob_type != &PyBool_Type);\n    ob->ob_size = size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_SIZE(ob, size) Py_SET_SIZE(_PyVarObject_CAST(ob), (size))\n#endif\n\n\n/*\nType objects contain a string containing the type name (to help somewhat\nin debugging), the allocation parameters (see PyObject_New() and\nPyObject_NewVar()),\nand methods for accessing objects of the type.  Methods are optional, a\nnil pointer meaning that particular kind of access is not available for\nthis type.  The Py_DECREF() macro uses the tp_dealloc method without\nchecking for a nil pointer; it should always be implemented except if\nthe implementation can guarantee that the reference count will never\nreach zero (e.g., for statically allocated type objects).\n\nNB: the methods for certain type groups are now contained in separate\nmethod blocks.\n*/\n\ntypedef PyObject * (*unaryfunc)(PyObject *);\ntypedef PyObject * (*binaryfunc)(PyObject *, PyObject *);\ntypedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);\ntypedef int (*inquiry)(PyObject *);\ntypedef Py_ssize_t (*lenfunc)(PyObject *);\ntypedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);\ntypedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);\ntypedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);\ntypedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);\ntypedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);\n\ntypedef int (*objobjproc)(PyObject *, PyObject *);\ntypedef int (*visitproc)(PyObject *, void *);\ntypedef int (*traverseproc)(PyObject *, visitproc, void *);\n\n\ntypedef void (*freefunc)(void *);\ntypedef void (*destructor)(PyObject *);\ntypedef PyObject *(*getattrfunc)(PyObject *, char *);\ntypedef PyObject *(*getattrofunc)(PyObject *, PyObject *);\ntypedef int (*setattrfunc)(PyObject *, char *, PyObject *);\ntypedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*reprfunc)(PyObject *);\ntypedef Py_hash_t (*hashfunc)(PyObject *);\ntypedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);\ntypedef PyObject *(*getiterfunc) (PyObject *);\ntypedef PyObject *(*iternextfunc) (PyObject *);\ntypedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*initproc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*newfunc)(PyTypeObject *, PyObject *, PyObject *);\ntypedef PyObject *(*allocfunc)(PyTypeObject *, Py_ssize_t);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030c0000 // 3.12\ntypedef PyObject *(*vectorcallfunc)(PyObject *callable, PyObject *const *args,\n                                    size_t nargsf, PyObject *kwnames);\n#endif\n\ntypedef struct{\n    int slot;    /* slot id, see below */\n    void *pfunc; /* function pointer */\n} PyType_Slot;\n\ntypedef struct{\n    const char* name;\n    int basicsize;\n    int itemsize;\n    unsigned int flags;\n    PyType_Slot *slots; /* terminated by slot==0. */\n} PyType_Spec;\n\nPyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000\nPyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);\nPyAPI_FUNC(PyObject *) PyType_GetModule(PyTypeObject *);\nPyAPI_FUNC(void *) PyType_GetModuleState(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000\nPyAPI_FUNC(PyObject *) PyType_GetName(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GetQualName(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\nPyAPI_FUNC(PyObject *) PyType_FromMetaclass(PyTypeObject*, PyObject*, PyType_Spec*, PyObject*);\nPyAPI_FUNC(void *) PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls);\nPyAPI_FUNC(Py_ssize_t) PyType_GetTypeDataSize(PyTypeObject *cls);\n#endif\n\n/* Generic type check */\nPyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);\n\nstatic inline int PyObject_TypeCheck(PyObject *ob, PyTypeObject *type) {\n    return Py_IS_TYPE(ob, type) || PyType_IsSubtype(Py_TYPE(ob), type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyObject_TypeCheck(ob, type) PyObject_TypeCheck(_PyObject_CAST(ob), (type))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */\nPyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */\nPyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */\n\nPyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);\n\nPyAPI_FUNC(int) PyType_Ready(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,\n                                               PyObject *, PyObject *);\nPyAPI_FUNC(unsigned int) PyType_ClearCache(void);\nPyAPI_FUNC(void) PyType_Modified(PyTypeObject *);\n\n/* Generic operations on objects */\nPyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);\nPyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);\nPyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);\nPyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);\n#endif\nPyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);\nPyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);\nPyAPI_FUNC(int) PyObject_IsTrue(PyObject *);\nPyAPI_FUNC(int) PyObject_Not(PyObject *);\nPyAPI_FUNC(int) PyCallable_Check(PyObject *);\nPyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);\n\n/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a\n   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),\n   returning the names of the current locals.  In this case, if there are\n   no current locals, NULL is returned, and PyErr_Occurred() is false.\n*/\nPyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);\n\n/* Pickle support. */\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyObject_GetState(PyObject *);\n#endif\n\n\n/* Helpers for printing recursive container types */\nPyAPI_FUNC(int) Py_ReprEnter(PyObject *);\nPyAPI_FUNC(void) Py_ReprLeave(PyObject *);\n\n/* Flag bits for printing: */\n#define Py_PRINT_RAW    1       /* No string quotes etc. */\n\n/*\nType flags (tp_flags)\n\nThese flags are used to change expected features and behavior for a\nparticular type.\n\nArbitration of the flag bit positions will need to be coordinated among\nall extension writers who publicly release their extensions (this will\nbe fewer than you might expect!).\n\nMost flags were removed as of Python 3.0 to make room for new flags.  (Some\nflags are not for backwards compatibility but to indicate the presence of an\noptional feature; these flags remain of course.)\n\nType definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.\n\nCode can use PyType_HasFeature(type_ob, flag_value) to test whether the\ngiven type object has a specified feature.\n*/\n\n#ifndef Py_LIMITED_API\n\n/* Track types initialized using _PyStaticType_InitBuiltin(). */\n#define _Py_TPFLAGS_STATIC_BUILTIN (1 << 1)\n\n/* Placement of weakref pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_weaklistoffset.\n */\n#define Py_TPFLAGS_MANAGED_WEAKREF (1 << 3)\n\n/* Placement of dict (and values) pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_dictoffset.\n */\n#define Py_TPFLAGS_MANAGED_DICT (1 << 4)\n\n#define Py_TPFLAGS_PREHEADER (Py_TPFLAGS_MANAGED_WEAKREF | Py_TPFLAGS_MANAGED_DICT)\n\n/* Set if instances of the type object are treated as sequences for pattern matching */\n#define Py_TPFLAGS_SEQUENCE (1 << 5)\n/* Set if instances of the type object are treated as mappings for pattern matching */\n#define Py_TPFLAGS_MAPPING (1 << 6)\n#endif\n\n/* Disallow creating instances of the type: set tp_new to NULL and don't create\n * the \"__new__\" key in the type dictionary. */\n#define Py_TPFLAGS_DISALLOW_INSTANTIATION (1UL << 7)\n\n/* Set if the type object is immutable: type attributes cannot be set nor deleted */\n#define Py_TPFLAGS_IMMUTABLETYPE (1UL << 8)\n\n/* Set if the type object is dynamically allocated */\n#define Py_TPFLAGS_HEAPTYPE (1UL << 9)\n\n/* Set if the type allows subclassing */\n#define Py_TPFLAGS_BASETYPE (1UL << 10)\n\n/* Set if the type implements the vectorcall protocol (PEP 590) */\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\n#define Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)\n#ifndef Py_LIMITED_API\n// Backwards compatibility alias for API that was provisional in Python 3.8\n#define _Py_TPFLAGS_HAVE_VECTORCALL Py_TPFLAGS_HAVE_VECTORCALL\n#endif\n#endif\n\n/* Set if the type is 'ready' -- fully initialized */\n#define Py_TPFLAGS_READY (1UL << 12)\n\n/* Set while the type is being 'readied', to prevent recursive ready calls */\n#define Py_TPFLAGS_READYING (1UL << 13)\n\n/* Objects support garbage collection (see objimpl.h) */\n#define Py_TPFLAGS_HAVE_GC (1UL << 14)\n\n/* These two bits are preserved for Stackless Python, next after this is 17 */\n#ifdef STACKLESS\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)\n#else\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0\n#endif\n\n/* Objects behave like an unbound method */\n#define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)\n\n/* Object has up-to-date type attribute cache */\n#define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)\n\n/* Type is abstract and cannot be instantiated */\n#define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)\n\n// This undocumented flag gives certain built-ins their unique pattern-matching\n// behavior, which allows a single positional subpattern to match against the\n// subject itself (rather than a mapped attribute on it):\n#define _Py_TPFLAGS_MATCH_SELF (1UL << 22)\n\n/* Items (ob_size*tp_itemsize) are found at the end of an instance's memory */\n#define Py_TPFLAGS_ITEMS_AT_END (1UL << 23)\n\n/* These flags are used to determine if a type is a subclass. */\n#define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)\n#define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)\n#define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)\n#define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)\n#define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)\n#define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)\n#define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)\n#define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)\n\n#define Py_TPFLAGS_DEFAULT  ( \\\n                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \\\n                0)\n\n/* NOTE: Some of the following flags reuse lower bits (removed as part of the\n * Python 3.0 transition). */\n\n/* The following flags are kept for compatibility; in previous\n * versions they indicated presence of newer tp_* fields on the\n * type struct.\n * Starting with 3.8, binary compatibility of C extensions across\n * feature releases of Python is not supported anymore (except when\n * using the stable ABI, in which all classes are created dynamically,\n * using the interpreter's memory layout.)\n * Note that older extensions using the stable ABI set these flags,\n * so the bits must not be repurposed.\n */\n#define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)\n#define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)\n\n\n/*\nThe macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement\nreference counts.  Py_DECREF calls the object's deallocator function when\nthe refcount falls to 0; for\nobjects that don't contain references to other objects or heap memory\nthis can be the standard function free().  Both macros can be used\nwherever a void expression is allowed.  The argument must not be a\nNULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.\nThe macro _Py_NewReference(op) initialize reference counts to 1, and\nin special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional\nbookkeeping appropriate to the special build.\n\nWe assume that the reference count field can never overflow; this can\nbe proven when the size of the field is the same as the pointer size, so\nwe ignore the possibility.  Provided a C int is at least 32 bits (which\nis implicitly assumed in many parts of this code), that's enough for\nabout 2**31 references to an object.\n\nXXX The following became out of date in Python 2.2, but I'm not sure\nXXX what the full truth is now.  Certainly, heap-allocated type objects\nXXX can and should be deallocated.\nType objects should never be deallocated; the type pointer in an object\nis not considered to be a reference to the type object, to save\ncomplications in the deallocation function.  (This is actually a\ndecision that's up to the implementer of each new type so if you want,\nyou can count such references to the type object.)\n*/\n\n#if defined(Py_REF_DEBUG) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,\n                                      PyObject *op);\nPyAPI_FUNC(void) _Py_INCREF_IncRefTotal(void);\nPyAPI_FUNC(void) _Py_DECREF_DecRefTotal(void);\n#endif  // Py_REF_DEBUG && !Py_LIMITED_API\n\nPyAPI_FUNC(void) _Py_Dealloc(PyObject *);\n\n/*\nThese are provided as conveniences to Python runtime embedders, so that\nthey can have object code that is not dependent on Python compilation flags.\n*/\nPyAPI_FUNC(void) Py_IncRef(PyObject *);\nPyAPI_FUNC(void) Py_DecRef(PyObject *);\n\n// Similar to Py_IncRef() and Py_DecRef() but the argument must be non-NULL.\n// Private functions used by Py_INCREF() and Py_DECREF().\nPyAPI_FUNC(void) _Py_IncRef(PyObject *);\nPyAPI_FUNC(void) _Py_DecRef(PyObject *);\n\nstatic inline Py_ALWAYS_INLINE void Py_INCREF(PyObject *op)\n{\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n    // Stable ABI implements Py_INCREF() as a function call on limited C API\n    // version 3.12 and newer, and on Python built in debug mode. _Py_IncRef()\n    // was added to Python 3.10.0a7, use Py_IncRef() on older Python versions.\n    // Py_IncRef() accepts NULL whereas _Py_IncRef() doesn't.\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_IncRef(op);\n#  else\n    Py_IncRef(op);\n#  endif\n#else\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n#if SIZEOF_VOID_P > 4\n    // Portable saturated add, branching on the carry flag and set low bits\n    PY_UINT32_T cur_refcnt = op->ob_refcnt_split[PY_BIG_ENDIAN];\n    PY_UINT32_T new_refcnt = cur_refcnt + 1;\n    if (new_refcnt == 0) {\n        return;\n    }\n    op->ob_refcnt_split[PY_BIG_ENDIAN] = new_refcnt;\n#else\n    // Explicitly check immortality against the immortal value\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    op->ob_refcnt++;\n#endif\n    _Py_INCREF_STAT_INC();\n#ifdef Py_REF_DEBUG\n    _Py_INCREF_IncRefTotal();\n#endif\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_INCREF(op) Py_INCREF(_PyObject_CAST(op))\n#endif\n\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n// Stable ABI implements Py_DECREF() as a function call on limited C API\n// version 3.12 and newer, and on Python built in debug mode. _Py_DecRef() was\n// added to Python 3.10.0a7, use Py_DecRef() on older Python versions.\n// Py_DecRef() accepts NULL whereas _Py_IncRef() doesn't.\nstatic inline void Py_DECREF(PyObject *op) {\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_DecRef(op);\n#  else\n    Py_DecRef(op);\n#  endif\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    if (op->ob_refcnt <= 0) {\n        _Py_NegativeRefcount(filename, lineno, op);\n    }\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#else\nstatic inline Py_ALWAYS_INLINE void Py_DECREF(PyObject *op)\n{\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n#endif\n\n\n/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear\n * and tp_dealloc implementations.\n *\n * Note that \"the obvious\" code can be deadly:\n *\n *     Py_XDECREF(op);\n *     op = NULL;\n *\n * Typically, `op` is something like self->containee, and `self` is done\n * using its `containee` member.  In the code sequence above, suppose\n * `containee` is non-NULL with a refcount of 1.  Its refcount falls to\n * 0 on the first line, which can trigger an arbitrary amount of code,\n * possibly including finalizers (like __del__ methods or weakref callbacks)\n * coded in Python, which in turn can release the GIL and allow other threads\n * to run, etc.  Such code may even invoke methods of `self` again, or cause\n * cyclic gc to trigger, but-- oops! --self->containee still points to the\n * object being torn down, and it may be in an insane state while being torn\n * down.  This has in fact been a rich historic source of miserable (rare &\n * hard-to-diagnose) segfaulting (and other) bugs.\n *\n * The safe way is:\n *\n *      Py_CLEAR(op);\n *\n * That arranges to set `op` to NULL _before_ decref'ing, so that any code\n * triggered as a side-effect of `op` getting torn down no longer believes\n * `op` points to a valid object.\n *\n * There are cases where it's safe to use the naive code, but they're brittle.\n * For example, if `op` points to a Python integer, you know that destroying\n * one of those can't cause problems -- but in part that relies on that\n * Python integers aren't currently weakly referencable.  Best practice is\n * to use Py_CLEAR() even if you can't think of a reason for why you need to.\n *\n * gh-98724: Use a temporary variable to only evaluate the macro argument once,\n * to avoid the duplication of side effects if the argument has side effects.\n *\n * gh-99701: If the PyObject* type is used with casting arguments to PyObject*,\n * the code can be miscompiled with strict aliasing because of type punning.\n * With strict aliasing, a compiler considers that two pointers of different\n * types cannot read or write the same memory which enables optimization\n * opportunities.\n *\n * If available, use _Py_TYPEOF() to use the 'op' type for temporary variables,\n * and so avoid type punning. Otherwise, use memcpy() which causes type erasure\n * and so prevents the compiler to reuse an old cached 'op' value after\n * Py_CLEAR().\n */\n#ifdef _Py_TYPEOF\n#define Py_CLEAR(op) \\\n    do { \\\n        _Py_TYPEOF(op)* _tmp_op_ptr = &(op); \\\n        _Py_TYPEOF(op) _tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            *_tmp_op_ptr = _Py_NULL; \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#else\n#define Py_CLEAR(op) \\\n    do { \\\n        PyObject **_tmp_op_ptr = _Py_CAST(PyObject**, &(op)); \\\n        PyObject *_tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            PyObject *_null_ptr = _Py_NULL; \\\n            memcpy(_tmp_op_ptr, &_null_ptr, sizeof(PyObject*)); \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#endif\n\n\n/* Function to use in case the object pointer can be NULL: */\nstatic inline void Py_XINCREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_INCREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XINCREF(op) Py_XINCREF(_PyObject_CAST(op))\n#endif\n\nstatic inline void Py_XDECREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_DECREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XDECREF(op) Py_XDECREF(_PyObject_CAST(op))\n#endif\n\n// Create a new strong reference to an object:\n// increment the reference count of the object and return the object.\nPyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);\n\n// Similar to Py_NewRef(), but the object can be NULL.\nPyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);\n\nstatic inline PyObject* _Py_NewRef(PyObject *obj)\n{\n    Py_INCREF(obj);\n    return obj;\n}\n\nstatic inline PyObject* _Py_XNewRef(PyObject *obj)\n{\n    Py_XINCREF(obj);\n    return obj;\n}\n\n// Py_NewRef() and Py_XNewRef() are exported as functions for the stable ABI.\n// Names overridden with macros by static inline functions for best\n// performances.\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_NewRef(obj) _Py_NewRef(_PyObject_CAST(obj))\n#  define Py_XNewRef(obj) _Py_XNewRef(_PyObject_CAST(obj))\n#else\n#  define Py_NewRef(obj) _Py_NewRef(obj)\n#  define Py_XNewRef(obj) _Py_XNewRef(obj)\n#endif\n\n\n/*\n_Py_NoneStruct is an object of undefined type which can be used in contexts\nwhere NULL (nil) is not suitable (since NULL often means 'error').\n\nDon't forget to apply Py_INCREF() when returning this value!!!\n*/\nPyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n#define Py_None (&_Py_NoneStruct)\n\n// Test if an object is the None singleton, the same as \"x is None\" in Python.\nPyAPI_FUNC(int) Py_IsNone(PyObject *x);\n#define Py_IsNone(x) Py_Is((x), Py_None)\n\n/* Macro for returning Py_None from a function */\n#define Py_RETURN_NONE return Py_None\n\n/*\nPy_NotImplemented is a singleton used to signal that an operation is\nnot implemented for a given type combination.\n*/\nPyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */\n#define Py_NotImplemented (&_Py_NotImplementedStruct)\n\n/* Macro for returning Py_NotImplemented from a function */\n#define Py_RETURN_NOTIMPLEMENTED return Py_NotImplemented\n\n/* Rich comparison opcodes */\n#define Py_LT 0\n#define Py_LE 1\n#define Py_EQ 2\n#define Py_NE 3\n#define Py_GT 4\n#define Py_GE 5\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000\n/* Result of calling PyIter_Send */\ntypedef enum {\n    PYGEN_RETURN = 0,\n    PYGEN_ERROR = -1,\n    PYGEN_NEXT = 1,\n} PySendResult;\n#endif\n\n/*\n * Macro for implementing rich comparisons\n *\n * Needs to be a macro because any C-comparable type can be used.\n */\n#define Py_RETURN_RICHCOMPARE(val1, val2, op)                               \\\n    do {                                                                    \\\n        switch (op) {                                                       \\\n        case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        default:                                                            \\\n            Py_UNREACHABLE();                                               \\\n        }                                                                   \\\n    } while (0)\n\n\n/*\nMore conventions\n================\n\nArgument Checking\n-----------------\n\nFunctions that take objects as arguments normally don't check for nil\narguments, but they do check the type of the argument, and return an\nerror if the function doesn't apply to the type.\n\nFailure Modes\n-------------\n\nFunctions may fail for a variety of reasons, including running out of\nmemory.  This is communicated to the caller in two ways: an error string\nis set (see errors.h), and the function result differs: functions that\nnormally return a pointer return NULL for failure, functions returning\nan integer return -1 (which could be a legal return value too!), and\nother functions return 0 for success and -1 for failure.\nCallers should always check for errors before using the result.  If\nan error was set, the caller must either explicitly clear it, or pass\nthe error on to its caller.\n\nReference Counts\n----------------\n\nIt takes a while to get used to the proper usage of reference counts.\n\nFunctions that create an object set the reference count to 1; such new\nobjects must be stored somewhere or destroyed again with Py_DECREF().\nSome functions that 'store' objects, such as PyTuple_SetItem() and\nPyList_SetItem(),\ndon't increment the reference count of the object, since the most\nfrequent use is to store a fresh object.  Functions that 'retrieve'\nobjects, such as PyTuple_GetItem() and PyDict_GetItemString(), also\ndon't increment\nthe reference count, since most frequently the object is only looked at\nquickly.  Thus, to retrieve an object and store it again, the caller\nmust call Py_INCREF() explicitly.\n\nNOTE: functions that 'consume' a reference count, like\nPyList_SetItem(), consume the reference even if the object wasn't\nsuccessfully stored, to simplify error handling.\n\nIt seems attractive to make other functions that take an object as\nargument consume a reference count; however, this may quickly get\nconfusing (even the current practice is already confusing).  Consider\nit carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at\ntimes.\n*/\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_OBJECT_H\n#  include \"cpython/object.h\"\n#  undef Py_CPYTHON_OBJECT_H\n#endif\n\n\nstatic inline int\nPyType_HasFeature(PyTypeObject *type, unsigned long feature)\n{\n    unsigned long flags;\n#ifdef Py_LIMITED_API\n    // PyTypeObject is opaque in the limited C API\n    flags = PyType_GetFlags(type);\n#else\n    flags = type->tp_flags;\n#endif\n    return ((flags & feature) != 0);\n}\n\n#define PyType_FastSubclass(type, flag) PyType_HasFeature((type), (flag))\n\nstatic inline int PyType_Check(PyObject *op) {\n    return PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_Check(op) PyType_Check(_PyObject_CAST(op))\n#endif\n\n#define _PyType_CAST(op) \\\n    (assert(PyType_Check(op)), _Py_CAST(PyTypeObject*, (op)))\n\nstatic inline int PyType_CheckExact(PyObject *op) {\n    return Py_IS_TYPE(op, &PyType_Type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_CheckExact(op) PyType_CheckExact(_PyObject_CAST(op))\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif   // !Py_OBJECT_H\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-null-dereference",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 26897,
                                       "gcc/analyzer/saved_diagnostic/snode": 1483,
                                       "gcc/analyzer/saved_diagnostic/sval": "(Py_ssize_t *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 25},
                        "level": "warning",
                        "message": {"text": "dereference of NULL '*mv.view.strides'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 620,
                                                                       "startColumn": 13,
                                                                       "endColumn": 14},
                                                            "contextRegion": {"startLine": 620,
                                                                              "snippet": {"text": "        if (MV_CONTIGUOUS_NDIM1(view))\n"}}},
                                       "logicalLocations": [{"name": "init_flags",
                                                             "fullyQualifiedName": "init_flags",
                                                             "decoratedName": "init_flags",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2548,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 17},
                                                                                                         "contextRegion": {"startLine": 2548,
                                                                                                                           "snippet": {"text": "memory_subscript(PyMemoryViewObject *self, PyObject *key)\n"}}},
                                                                                    "logicalLocations": [{"name": "memory_subscript",
                                                                                                          "fullyQualifiedName": "memory_subscript",
                                                                                                          "decoratedName": "memory_subscript",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'memory_subscript'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CONSOLIDATED_CFG_EDGES"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2553,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 2553,
                                                                                                                           "snippet": {"text": "    CHECK_RELEASED(self);\n"}}},
                                                                                    "logicalLocations": [{"name": "memory_subscript",
                                                                                                          "fullyQualifiedName": "memory_subscript",
                                                                                                          "decoratedName": "memory_subscript",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CONSOLIDATED_CFG_EDGES"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2555,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 19},
                                                                                                         "contextRegion": {"startLine": 2555,
                                                                                                                           "snippet": {"text": "    if (view->ndim == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "memory_subscript",
                                                                                                          "fullyQualifiedName": "memory_subscript",
                                                                                                          "decoratedName": "memory_subscript",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 548,
                                                                                                                                 "dst_idx": 560,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2555,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 2555,
                                                                                                                           "snippet": {"text": "    if (view->ndim == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "memory_subscript",
                                                                                                          "fullyQualifiedName": "memory_subscript",
                                                                                                          "decoratedName": "memory_subscript",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2572,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 2572,
                                                                                                                           "snippet": {"text": "    if (_PyIndex_Check(key)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "memory_subscript",
                                                                                                          "fullyQualifiedName": "memory_subscript",
                                                                                                          "decoratedName": "memory_subscript",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to '_PyIndex_Check' from 'memory_subscript'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_abstract.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 15,
                                                                                                                    "startColumn": 37,
                                                                                                                    "endColumn": 38},
                                                                                                         "contextRegion": {"startLine": 15,
                                                                                                                           "snippet": {"text": "    PyNumberMethods *tp_as_number = Py_TYPE(obj)->tp_as_number;\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyIndex_Check",
                                                                                                          "fullyQualifiedName": "_PyIndex_Check",
                                                                                                          "decoratedName": "_PyIndex_Check",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'Py_TYPE' from '_PyIndex_Check'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "memory_subscript",
                                                                                                                                     "fullyQualifiedName": "memory_subscript",
                                                                                                                                     "decoratedName": "memory_subscript",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 1,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 548,
                                                                                                                                 "dst_idx": 560,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 220,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 23},
                                                                                                         "contextRegion": {"startLine": 220,
                                                                                                                           "snippet": {"text": "    return ob->ob_type;\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_TYPE",
                                                                                                          "fullyQualifiedName": "Py_TYPE",
                                                                                                          "decoratedName": "Py_TYPE",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 563,
                                                                                                                                 "dst_idx": 567,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2579,
                                                                                                                    "startColumn": 13,
                                                                                                                    "endColumn": 14},
                                                                                                         "contextRegion": {"startLine": 2579,
                                                                                                                           "snippet": {"text": "    else if (PySlice_Check(key)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "memory_subscript",
                                                                                                          "fullyQualifiedName": "memory_subscript",
                                                                                                          "decoratedName": "memory_subscript",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 563,
                                                                                                                                 "dst_idx": 567,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2580,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 2580,
                                                                                                                           "snippet": {"text": "        CHECK_RESTRICTED(self);\n"}}},
                                                                                    "logicalLocations": [{"name": "memory_subscript",
                                                                                                          "fullyQualifiedName": "memory_subscript",
                                                                                                          "decoratedName": "memory_subscript",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 567,
                                                                                                                                 "dst_idx": 569,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2580,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 2580,
                                                                                                                           "snippet": {"text": "        CHECK_RESTRICTED(self);\n"}}},
                                                                                    "logicalLocations": [{"name": "memory_subscript",
                                                                                                          "fullyQualifiedName": "memory_subscript",
                                                                                                          "decoratedName": "memory_subscript",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 567,
                                                                                                                                 "dst_idx": 569,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2583,
                                                                                                                    "startColumn": 40,
                                                                                                                    "endColumn": 71},
                                                                                                         "contextRegion": {"startLine": 2583,
                                                                                                                           "snippet": {"text": "        sliced = (PyMemoryViewObject *)mbuf_add_view(self->mbuf, view);\n"}}},
                                                                                    "logicalLocations": [{"name": "memory_subscript",
                                                                                                          "fullyQualifiedName": "memory_subscript",
                                                                                                          "decoratedName": "memory_subscript",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 569,
                                                                                                                                 "dst_idx": 1454,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2583,
                                                                                                                    "startColumn": 40,
                                                                                                                    "endColumn": 71},
                                                                                                         "contextRegion": {"startLine": 2583,
                                                                                                                           "snippet": {"text": "        sliced = (PyMemoryViewObject *)mbuf_add_view(self->mbuf, view);\n"}}},
                                                                                    "logicalLocations": [{"name": "memory_subscript",
                                                                                                          "fullyQualifiedName": "memory_subscript",
                                                                                                          "decoratedName": "memory_subscript",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'mbuf_add_view' from 'memory_subscript'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 674,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 14},
                                                                                                         "contextRegion": {"startLine": 674,
                                                                                                                           "snippet": {"text": "mbuf_add_view(_PyManagedBufferObject *mbuf, const Py_buffer *src)\n"}}},
                                                                                    "logicalLocations": [{"name": "mbuf_add_view",
                                                                                                          "fullyQualifiedName": "mbuf_add_view",
                                                                                                          "decoratedName": "mbuf_add_view",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'mbuf_add_view'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1455,
                                                                                                                                 "dst_idx": 1457,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 679,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 679,
                                                                                                                           "snippet": {"text": "    if (src == NULL)\n"}}},
                                                                                    "logicalLocations": [{"name": "mbuf_add_view",
                                                                                                          "fullyQualifiedName": "mbuf_add_view",
                                                                                                          "decoratedName": "mbuf_add_view",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'src' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1455,
                                                                                                                                 "dst_idx": 1457,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 682,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 682,
                                                                                                                           "snippet": {"text": "    if (src->ndim > PyBUF_MAX_NDIM) {\n"}}},
                                                                                    "logicalLocations": [{"name": "mbuf_add_view",
                                                                                                          "fullyQualifiedName": "mbuf_add_view",
                                                                                                          "decoratedName": "mbuf_add_view",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1457,
                                                                                                                                 "dst_idx": 1460,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 682,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 682,
                                                                                                                           "snippet": {"text": "    if (src->ndim > PyBUF_MAX_NDIM) {\n"}}},
                                                                                    "logicalLocations": [{"name": "mbuf_add_view",
                                                                                                          "fullyQualifiedName": "mbuf_add_view",
                                                                                                          "decoratedName": "mbuf_add_view",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1457,
                                                                                                                                 "dst_idx": 1460,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 689,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 33},
                                                                                                         "contextRegion": {"startLine": 689,
                                                                                                                           "snippet": {"text": "    mv = memory_alloc(src->ndim);\n"}}},
                                                                                    "logicalLocations": [{"name": "mbuf_add_view",
                                                                                                          "fullyQualifiedName": "mbuf_add_view",
                                                                                                          "decoratedName": "mbuf_add_view",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1461,
                                                                                                                                 "dst_idx": 1462,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 690,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 690,
                                                                                                                           "snippet": {"text": "    if (mv == NULL)\n"}}},
                                                                                    "logicalLocations": [{"name": "mbuf_add_view",
                                                                                                          "fullyQualifiedName": "mbuf_add_view",
                                                                                                          "decoratedName": "mbuf_add_view",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'mv' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1461,
                                                                                                                                 "dst_idx": 1462,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 693,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 21},
                                                                                                         "contextRegion": {"startLine": 693,
                                                                                                                           "snippet": {"text": "    dest = &mv->view;\n"}}},
                                                                                    "logicalLocations": [{"name": "mbuf_add_view",
                                                                                                          "fullyQualifiedName": "mbuf_add_view",
                                                                                                          "decoratedName": "mbuf_add_view",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1464,
                                                                                                                                 "dst_idx": 1494,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 695,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 34},
                                                                                                         "contextRegion": {"startLine": 695,
                                                                                                                           "snippet": {"text": "    init_shape_strides(dest, src);\n"}}},
                                                                                    "logicalLocations": [{"name": "mbuf_add_view",
                                                                                                          "fullyQualifiedName": "mbuf_add_view",
                                                                                                          "decoratedName": "mbuf_add_view",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'init_shape_strides' from 'mbuf_add_view'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 554,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 19},
                                                                                                         "contextRegion": {"startLine": 554,
                                                                                                                           "snippet": {"text": "init_shape_strides(Py_buffer *dest, const Py_buffer *src)\n"}}},
                                                                                    "logicalLocations": [{"name": "init_shape_strides",
                                                                                                          "fullyQualifiedName": "init_shape_strides",
                                                                                                          "decoratedName": "init_shape_strides",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'init_shape_strides'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1495,
                                                                                                                                 "dst_idx": 1496,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 558,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 558,
                                                                                                                           "snippet": {"text": "    if (src->ndim == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "init_shape_strides",
                                                                                                          "fullyQualifiedName": "init_shape_strides",
                                                                                                          "decoratedName": "init_shape_strides",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 22},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(23)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1495,
                                                                                                                                 "dst_idx": 1496,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 559,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 24},
                                                                                                         "contextRegion": {"startLine": 559,
                                                                                                                           "snippet": {"text": "        dest->shape = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "init_shape_strides",
                                                                                                          "fullyQualifiedName": "init_shape_strides",
                                                                                                          "decoratedName": "init_shape_strides",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 23},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(24)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 559,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 24},
                                                                                                         "contextRegion": {"startLine": 559,
                                                                                                                           "snippet": {"text": "        dest->shape = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "init_shape_strides",
                                                                                                          "fullyQualifiedName": "init_shape_strides",
                                                                                                          "decoratedName": "init_shape_strides",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'*mv.view.shape' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 24},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(25)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 560,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 26},
                                                                                                         "contextRegion": {"startLine": 560,
                                                                                                                           "snippet": {"text": "        dest->strides = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "init_shape_strides",
                                                                                                          "fullyQualifiedName": "init_shape_strides",
                                                                                                          "decoratedName": "init_shape_strides",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'*mv.view.strides' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 25},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(26)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 1510,
                                                                                                                                 "dst_idx": 1465,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 695,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 34},
                                                                                                         "contextRegion": {"startLine": 695,
                                                                                                                           "snippet": {"text": "    init_shape_strides(dest, src);\n"}}},
                                                                                    "logicalLocations": [{"name": "mbuf_add_view",
                                                                                                          "fullyQualifiedName": "mbuf_add_view",
                                                                                                          "decoratedName": "mbuf_add_view",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'mbuf_add_view' from 'init_shape_strides'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 26},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(27)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 696,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 696,
                                                                                                                           "snippet": {"text": "    init_suboffsets(dest, src);\n"}}},
                                                                                    "logicalLocations": [{"name": "mbuf_add_view",
                                                                                                          "fullyQualifiedName": "mbuf_add_view",
                                                                                                          "decoratedName": "mbuf_add_view",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'init_suboffsets' from 'mbuf_add_view'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 27},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(28)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "mbuf_add_view",
                                                                                                                                     "fullyQualifiedName": "mbuf_add_view",
                                                                                                                                     "decoratedName": "mbuf_add_view",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 2,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1465,
                                                                                                                                 "dst_idx": 1467,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 585,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 585,
                                                                                                                           "snippet": {"text": "    if (src->suboffsets == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "init_suboffsets",
                                                                                                          "fullyQualifiedName": "init_suboffsets",
                                                                                                          "decoratedName": "init_suboffsets",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 28},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(29)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "mbuf_add_view",
                                                                                                                                     "fullyQualifiedName": "mbuf_add_view",
                                                                                                                                     "decoratedName": "mbuf_add_view",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 2,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1465,
                                                                                                                                 "dst_idx": 1467,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 586,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 29},
                                                                                                         "contextRegion": {"startLine": 586,
                                                                                                                           "snippet": {"text": "        dest->suboffsets = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "init_suboffsets",
                                                                                                          "fullyQualifiedName": "init_suboffsets",
                                                                                                          "decoratedName": "init_suboffsets",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 29},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(30)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "mbuf_add_view",
                                                                                                                                     "fullyQualifiedName": "mbuf_add_view",
                                                                                                                                     "decoratedName": "mbuf_add_view",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 2},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 586,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 29},
                                                                                                         "contextRegion": {"startLine": 586,
                                                                                                                           "snippet": {"text": "        dest->suboffsets = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "init_suboffsets",
                                                                                                          "fullyQualifiedName": "init_suboffsets",
                                                                                                          "decoratedName": "init_suboffsets",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'*mv.view.strides' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 30},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(31)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1470,
                                                                                                                                 "dst_idx": 1481,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 697,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 19},
                                                                                                         "contextRegion": {"startLine": 697,
                                                                                                                           "snippet": {"text": "    init_flags(mv);\n"}}},
                                                                                    "logicalLocations": [{"name": "mbuf_add_view",
                                                                                                          "fullyQualifiedName": "mbuf_add_view",
                                                                                                          "decoratedName": "mbuf_add_view",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'init_flags' from 'mbuf_add_view'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 31},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(32)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 609,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 609,
                                                                                                                           "snippet": {"text": "init_flags(PyMemoryViewObject *mv)\n"}}},
                                                                                    "logicalLocations": [{"name": "init_flags",
                                                                                                          "fullyQualifiedName": "init_flags",
                                                                                                          "decoratedName": "init_flags",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'init_flags'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 32},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(33)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1482,
                                                                                                                                 "dst_idx": 1483,
                                                                                                                                 "desc": "{1}"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 614,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 614,
                                                                                                                           "snippet": {"text": "    switch (view->ndim) {\n"}}},
                                                                                    "logicalLocations": [{"name": "init_flags",
                                                                                                          "fullyQualifiedName": "init_flags",
                                                                                                          "decoratedName": "init_flags",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'case 1:' branch..."}},
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 33},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(34)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1482,
                                                                                                                                 "dst_idx": 1483,
                                                                                                                                 "desc": "{1}"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 619,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 619,
                                                                                                                           "snippet": {"text": "    case 1:\n"}}},
                                                                                    "logicalLocations": [{"name": "init_flags",
                                                                                                          "fullyQualifiedName": "init_flags",
                                                                                                          "decoratedName": "init_flags",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 34},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(35)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 620,
                                                                                                                    "startColumn": 13,
                                                                                                                    "endColumn": 14},
                                                                                                         "contextRegion": {"startLine": 620,
                                                                                                                           "snippet": {"text": "        if (MV_CONTIGUOUS_NDIM1(view))\n"}}},
                                                                                    "logicalLocations": [{"name": "init_flags",
                                                                                                          "fullyQualifiedName": "init_flags",
                                                                                                          "decoratedName": "init_flags",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'*mv.view.strides' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 35},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(36)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 620,
                                                                                                                    "startColumn": 13,
                                                                                                                    "endColumn": 14},
                                                                                                         "contextRegion": {"startLine": 620,
                                                                                                                           "snippet": {"text": "        if (MV_CONTIGUOUS_NDIM1(view))\n"}}},
                                                                                    "logicalLocations": [{"name": "init_flags",
                                                                                                          "fullyQualifiedName": "init_flags",
                                                                                                          "decoratedName": "init_flags",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "dereference of NULL '*(const Py_buffer *)((char *)mv + 56).shape'"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 36}]}]}]}]}]}
