{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-null-dereference", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-dereference"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "476", "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}}, "artifacts": [{"location": {"uri": "./Modules/_testcapi/heaptype_relative.c", "uriBaseId": "PWD"}, "contents": {"text": "#define Py_LIMITED_API 0x030c0000 // 3.12\n#include \"parts.h\"\n#include <stddef.h>               // max_align_t\n#include <string.h>               // memset\n\n#ifdef LIMITED_API_AVAILABLE\n\nstatic PyType_Slot empty_slots[] = {\n    {0, NULL},\n};\n\nstatic PyObject *\nmake_sized_heaptypes(PyObject *module, PyObject *args)\n{\n    PyObject *base = NULL;\n    PyObject *sub = NULL;\n    PyObject *instance = NULL;\n    PyObject *result = NULL;\n\n    int extra_base_size, basicsize;\n\n    int r = PyArg_ParseTuple(args, \"ii\", &extra_base_size, &basicsize);\n    if (!r) {\n        goto finally;\n    }\n\n    PyType_Spec base_spec = {\n        .name = \"_testcapi.Base\",\n        .basicsize = sizeof(PyObject) + extra_base_size,\n        .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n        .slots = empty_slots,\n    };\n    PyType_Spec sub_spec = {\n        .name = \"_testcapi.Sub\",\n        .basicsize = basicsize,\n        .flags = Py_TPFLAGS_DEFAULT,\n        .slots = empty_slots,\n    };\n\n    base = PyType_FromMetaclass(NULL, module, &base_spec, NULL);\n    if (!base) {\n        goto finally;\n    }\n    sub = PyType_FromMetaclass(NULL, module, &sub_spec, base);\n    if (!sub) {\n        goto finally;\n    }\n    instance = PyObject_CallNoArgs(sub);\n    if (!instance) {\n        goto finally;\n    }\n    char *data_ptr = PyObject_GetTypeData(instance, (PyTypeObject *)sub);\n    if (!data_ptr) {\n        goto finally;\n    }\n    Py_ssize_t data_size = PyType_GetTypeDataSize((PyTypeObject *)sub);\n    if (data_size < 0) {\n        goto finally;\n    }\n\n    result = Py_BuildValue(\"OOOKnn\", base, sub, instance,\n                           (unsigned long long)data_ptr,\n                           (Py_ssize_t)(data_ptr - (char*)instance),\n                           data_size);\n  finally:\n    Py_XDECREF(base);\n    Py_XDECREF(sub);\n    Py_XDECREF(instance);\n    return result;\n}\n\nstatic PyObject *\nvar_heaptype_set_data_to_3s(\n    PyObject *self, PyTypeObject *defining_class,\n    PyObject **args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    void *data_ptr = PyObject_GetTypeData(self, defining_class);\n    if (!data_ptr) {\n        return NULL;\n    }\n    Py_ssize_t data_size = PyType_GetTypeDataSize(defining_class);\n    if (data_size < 0) {\n        return NULL;\n    }\n    memset(data_ptr, 3, data_size);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nvar_heaptype_get_data(PyObject *self, PyTypeObject *defining_class,\n                      PyObject **args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    void *data_ptr = PyObject_GetTypeData(self, defining_class);\n    if (!data_ptr) {\n        return NULL;\n    }\n    Py_ssize_t data_size = PyType_GetTypeDataSize(defining_class);\n    if (data_size < 0) {\n        return NULL;\n    }\n    return PyBytes_FromStringAndSize(data_ptr, data_size);\n}\n\nstatic PyMethodDef var_heaptype_methods[] = {\n    {\"set_data_to_3s\", _PyCFunction_CAST(var_heaptype_set_data_to_3s),\n        METH_METHOD | METH_FASTCALL | METH_KEYWORDS},\n    {\"get_data\", _PyCFunction_CAST(var_heaptype_get_data),\n        METH_METHOD | METH_FASTCALL | METH_KEYWORDS},\n    {NULL},\n};\n\nstatic PyObject *\nsubclass_var_heaptype(PyObject *module, PyObject *args)\n{\n    PyObject *result = NULL;\n\n    PyObject *base; // borrowed from args\n    int basicsize, itemsize;\n    long pfunc;\n\n    int r = PyArg_ParseTuple(args, \"Oiil\", &base, &basicsize, &itemsize, &pfunc);\n    if (!r) {\n        goto finally;\n    }\n\n    PyType_Slot slots[] = {\n        {Py_tp_methods, var_heaptype_methods},\n        {0, NULL},\n    };\n\n    PyType_Spec sub_spec = {\n        .name = \"_testcapi.Sub\",\n        .basicsize = basicsize,\n        .itemsize = itemsize,\n        .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_ITEMS_AT_END,\n        .slots = slots,\n    };\n\n    result = PyType_FromMetaclass(NULL, module, &sub_spec, base);\n  finally:\n    return result;\n}\n\nstatic PyObject *\nsubclass_heaptype(PyObject *module, PyObject *args)\n{\n    PyObject *result = NULL;\n\n    PyObject *base; // borrowed from args\n    int basicsize, itemsize;\n\n    int r = PyArg_ParseTuple(args, \"Oii\", &base, &basicsize, &itemsize);\n    if (!r) {\n        goto finally;\n    }\n\n    PyType_Slot slots[] = {\n        {Py_tp_methods, var_heaptype_methods},\n        {0, NULL},\n    };\n\n    PyType_Spec sub_spec = {\n        .name = \"_testcapi.Sub\",\n        .basicsize = basicsize,\n        .itemsize = itemsize,\n        .flags = Py_TPFLAGS_DEFAULT,\n        .slots = slots,\n    };\n\n    result = PyType_FromMetaclass(NULL, module, &sub_spec, base);\n  finally:\n    return result;\n}\n\nstatic PyMemberDef *\nheaptype_with_member_extract_and_check_memb(PyObject *self)\n{\n    PyMemberDef *def = PyType_GetSlot(Py_TYPE(self), Py_tp_members);\n    if (!def) {\n        if (!PyErr_Occurred()) {\n            PyErr_SetString(PyExc_ValueError, \"tp_members is NULL\");\n        }\n        return NULL;\n    }\n    if (!def[0].name) {\n        PyErr_SetString(PyExc_ValueError, \"tp_members[0] is NULL\");\n        return NULL;\n    }\n    if (def[1].name) {\n        PyErr_SetString(PyExc_ValueError, \"tp_members[1] is not NULL\");\n        return NULL;\n    }\n    if (strcmp(def[0].name, \"memb\")) {\n        PyErr_SetString(PyExc_ValueError, \"tp_members[0] is not for `memb`\");\n        return NULL;\n    }\n    if (def[0].flags) {\n        PyErr_SetString(PyExc_ValueError, \"tp_members[0] has flags set\");\n        return NULL;\n    }\n    return def;\n}\n\nstatic PyObject *\nheaptype_with_member_get_memb(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    PyMemberDef *def = heaptype_with_member_extract_and_check_memb(self);\n    return PyMember_GetOne((const char *)self, def);\n}\n\nstatic PyObject *\nheaptype_with_member_set_memb(PyObject *self, PyObject *value)\n{\n    PyMemberDef *def = heaptype_with_member_extract_and_check_memb(self);\n    int r = PyMember_SetOne((char *)self, def, value);\n    if (r < 0) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nget_memb_offset(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    PyMemberDef *def = heaptype_with_member_extract_and_check_memb(self);\n    return PyLong_FromSsize_t(def->offset);\n}\n\nstatic PyObject *\nheaptype_with_member_get_memb_relative(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    PyMemberDef def = {\"memb\", Py_T_BYTE, sizeof(PyObject), Py_RELATIVE_OFFSET};\n    return PyMember_GetOne((const char *)self, &def);\n}\n\nstatic PyObject *\nheaptype_with_member_set_memb_relative(PyObject *self, PyObject *value)\n{\n    PyMemberDef def = {\"memb\", Py_T_BYTE, sizeof(PyObject), Py_RELATIVE_OFFSET};\n    int r = PyMember_SetOne((char *)self, &def, value);\n    if (r < 0) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nstatic PyMethodDef heaptype_with_member_methods[] = {\n    {\"get_memb\", heaptype_with_member_get_memb, METH_NOARGS},\n    {\"set_memb\", heaptype_with_member_set_memb, METH_O},\n    {\"get_memb_offset\", get_memb_offset, METH_NOARGS},\n    {\"get_memb_relative\", heaptype_with_member_get_memb_relative, METH_NOARGS},\n    {\"set_memb_relative\", heaptype_with_member_set_memb_relative, METH_O},\n    {NULL},\n};\n\nstatic PyObject *\nmake_heaptype_with_member(PyObject *module, PyObject *args)\n{\n    PyObject *base = NULL;\n    PyObject *result = NULL;\n\n    int extra_base_size, basicsize, offset, add_flag;\n\n    int r = PyArg_ParseTuple(args, \"iiip\", &extra_base_size, &basicsize, &offset, &add_flag);\n    if (!r) {\n        goto finally;\n    }\n\n    PyType_Spec base_spec = {\n        .name = \"_testcapi.Base\",\n        .basicsize = sizeof(PyObject) + extra_base_size,\n        .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n        .slots = empty_slots,\n    };\n    base = PyType_FromMetaclass(NULL, module, &base_spec, NULL);\n    if (!base) {\n        goto finally;\n    }\n\n    PyMemberDef members[] = {\n        {\"memb\", Py_T_BYTE, offset, add_flag ? Py_RELATIVE_OFFSET : 0},\n        {0},\n    };\n    PyType_Slot slots[] = {\n        {Py_tp_members, members},\n        {Py_tp_methods, heaptype_with_member_methods},\n        {0, NULL},\n    };\n\n    PyType_Spec sub_spec = {\n        .name = \"_testcapi.Sub\",\n        .basicsize = basicsize,\n        .flags = Py_TPFLAGS_DEFAULT,\n        .slots = slots,\n    };\n\n    result = PyType_FromMetaclass(NULL, module, &sub_spec, base);\n  finally:\n    Py_XDECREF(base);\n    return result;\n}\n\n\nstatic PyObject *\ntest_alignof_max_align_t(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    // We define ALIGNOF_MAX_ALIGN_T even if the compiler doesn't support\n    // max_align_t. Double-check that it's correct.\n    assert(ALIGNOF_MAX_ALIGN_T > 0);\n    assert(ALIGNOF_MAX_ALIGN_T >= _Alignof(long long));\n    assert(ALIGNOF_MAX_ALIGN_T >= _Alignof(long double));\n    assert(ALIGNOF_MAX_ALIGN_T >= _Alignof(void*));\n    assert(ALIGNOF_MAX_ALIGN_T >= _Alignof(void (*)(void)));\n\n    // Ensure it's a power of two\n    assert((ALIGNOF_MAX_ALIGN_T & (ALIGNOF_MAX_ALIGN_T - 1)) == 0);\n\n    Py_RETURN_NONE;\n}\n\nstatic PyMethodDef TestMethods[] = {\n    {\"make_sized_heaptypes\", make_sized_heaptypes, METH_VARARGS},\n    {\"subclass_var_heaptype\", subclass_var_heaptype, METH_VARARGS},\n    {\"subclass_heaptype\", subclass_heaptype, METH_VARARGS},\n    {\"make_heaptype_with_member\", make_heaptype_with_member, METH_VARARGS},\n    {\"test_alignof_max_align_t\", test_alignof_max_align_t, METH_NOARGS},\n    {NULL},\n};\n\nint\n_PyTestCapi_Init_HeaptypeRelative(PyObject *m) {\n    if (PyModule_AddFunctions(m, TestMethods) < 0) {\n        return -1;\n    }\n\n    if (PyModule_AddIntMacro(m, ALIGNOF_MAX_ALIGN_T) < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n\n#endif // LIMITED_API_AVAILABLE\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-null-dereference", "taxa": [{"id": "476", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "dereference of NULL 'def'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapi/heaptype_relative.c", "uriBaseId": "PWD"}, "region": {"startLine": 226, "startColumn": 12, "endColumn": 43}, "contextRegion": {"startLine": 226, "snippet": {"text": "    return PyLong_FromSsize_t(def->offset);\n"}}}, "logicalLocations": [{"name": "get_memb_offset", "fullyQualifiedName": "get_memb_offset", "decoratedName": "get_memb_offset", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_testcapi/heaptype_relative.c", "uriBaseId": "PWD"}, "region": {"startLine": 226, "startColumn": 12, "endColumn": 43}, "contextRegion": {"startLine": 226, "snippet": {"text": "    return PyLong_FromSsize_t(def->offset);\n"}}}, "logicalLocations": [{"name": "get_memb_offset", "fullyQualifiedName": "get_memb_offset", "decoratedName": "get_memb_offset", "kind": "function"}], "message": {"text": "dereference of NULL 'def'"}}, "kinds": ["danger"], "nestingLevel": 1}]}]}]}]}]}
