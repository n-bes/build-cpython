{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-use-of-uninitialized-value", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-use-of-uninitialized-value"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "457", "helpUri": "https://cwe.mitre.org/data/definitions/457.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}}, "artifacts": [{"location": {"uri": "./Modules/_blake2/blake2s_impl.c", "uriBaseId": "PWD"}, "contents": {"text": "/*\n * Written in 2013 by Dmitry Chestnykh <dmitry@codingrobots.com>\n * Modified for CPython by Christian Heimes <christian@python.org>\n *\n * To the extent possible under law, the author have dedicated all\n * copyright and related and neighboring rights to this software to\n * the public domain worldwide. This software is distributed without\n * any warranty. http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/* WARNING: autogenerated file!\n *\n * The blake2s_impl.c is autogenerated from blake2s_impl.c.\n */\n\n#ifndef Py_BUILD_CORE_BUILTIN\n#  define Py_BUILD_CORE_MODULE 1\n#endif\n\n#include \"Python.h\"\n#include \"pycore_strhex.h\"       // _Py_strhex()\n\n#include \"../hashlib.h\"\n#include \"blake2module.h\"\n\n#ifndef HAVE_LIBB2\n/* pure SSE2 implementation is very slow, so only use the more optimized SSSE3+\n * https://bugs.python.org/issue31834 */\n#if defined(__SSSE3__) || defined(__SSE4_1__) || defined(__AVX__) || defined(__XOP__)\n#include \"impl/blake2s.c\"\n#else\n#include \"impl/blake2s-ref.c\"\n#endif\n#endif // !HAVE_LIBB2\n\n#define HAVE_BLAKE2S 1\n\nextern PyType_Spec blake2s_type_spec;\n\n\ntypedef struct {\n    PyObject_HEAD\n    blake2s_param    param;\n    blake2s_state    state;\n    PyThread_type_lock lock;\n} BLAKE2sObject;\n\n#include \"clinic/blake2s_impl.c.h\"\n\n/*[clinic input]\nmodule _blake2\nclass _blake2.blake2s \"BLAKE2sObject *\" \"&PyBlake2_BLAKE2sType\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=4b79d7ffe07286ce]*/\n\n\nstatic BLAKE2sObject *\nnew_BLAKE2sObject(PyTypeObject *type)\n{\n    BLAKE2sObject *self;\n    self = (BLAKE2sObject *)type->tp_alloc(type, 0);\n    if (self != NULL) {\n        self->lock = NULL;\n    }\n    return self;\n}\n\n/*[clinic input]\n@classmethod\n_blake2.blake2s.__new__ as py_blake2s_new\n    data: object(c_default=\"NULL\") = b''\n    /\n    *\n    digest_size: int(c_default=\"BLAKE2S_OUTBYTES\") = _blake2.blake2s.MAX_DIGEST_SIZE\n    key: Py_buffer(c_default=\"NULL\", py_default=\"b''\") = None\n    salt: Py_buffer(c_default=\"NULL\", py_default=\"b''\") = None\n    person: Py_buffer(c_default=\"NULL\", py_default=\"b''\") = None\n    fanout: int = 1\n    depth: int = 1\n    leaf_size: unsigned_long = 0\n    node_offset: unsigned_long_long = 0\n    node_depth: int = 0\n    inner_size: int = 0\n    last_node: bool = False\n    usedforsecurity: bool = True\n\nReturn a new BLAKE2s hash object.\n[clinic start generated code]*/\n\nstatic PyObject *\npy_blake2s_new_impl(PyTypeObject *type, PyObject *data, int digest_size,\n                    Py_buffer *key, Py_buffer *salt, Py_buffer *person,\n                    int fanout, int depth, unsigned long leaf_size,\n                    unsigned long long node_offset, int node_depth,\n                    int inner_size, int last_node, int usedforsecurity)\n/*[clinic end generated code: output=556181f73905c686 input=4dda87723f23abb0]*/\n{\n    BLAKE2sObject *self = NULL;\n    Py_buffer buf;\n\n    self = new_BLAKE2sObject(type);\n    if (self == NULL) {\n        goto error;\n    }\n\n    /* Zero parameter block. */\n    memset(&self->param, 0, sizeof(self->param));\n\n    /* Set digest size. */\n    if (digest_size <= 0 || digest_size > BLAKE2S_OUTBYTES) {\n        PyErr_Format(PyExc_ValueError,\n                \"digest_size must be between 1 and %d bytes\",\n                BLAKE2S_OUTBYTES);\n        goto error;\n    }\n    self->param.digest_length = digest_size;\n\n    /* Set salt parameter. */\n    if ((salt->obj != NULL) && salt->len) {\n        if (salt->len > BLAKE2S_SALTBYTES) {\n            PyErr_Format(PyExc_ValueError,\n                \"maximum salt length is %d bytes\",\n                BLAKE2S_SALTBYTES);\n            goto error;\n        }\n        memcpy(self->param.salt, salt->buf, salt->len);\n    }\n\n    /* Set personalization parameter. */\n    if ((person->obj != NULL) && person->len) {\n        if (person->len > BLAKE2S_PERSONALBYTES) {\n            PyErr_Format(PyExc_ValueError,\n                \"maximum person length is %d bytes\",\n                BLAKE2S_PERSONALBYTES);\n            goto error;\n        }\n        memcpy(self->param.personal, person->buf, person->len);\n    }\n\n    /* Set tree parameters. */\n    if (fanout < 0 || fanout > 255) {\n        PyErr_SetString(PyExc_ValueError,\n                \"fanout must be between 0 and 255\");\n        goto error;\n    }\n    self->param.fanout = (uint8_t)fanout;\n\n    if (depth <= 0 || depth > 255) {\n        PyErr_SetString(PyExc_ValueError,\n                \"depth must be between 1 and 255\");\n        goto error;\n    }\n    self->param.depth = (uint8_t)depth;\n\n    if (leaf_size > 0xFFFFFFFFU) {\n        PyErr_SetString(PyExc_OverflowError, \"leaf_size is too large\");\n        goto error;\n    }\n    // NB: Simple assignment here would be incorrect on big endian platforms.\n    store32(&(self->param.leaf_length), leaf_size);\n\n#ifdef HAVE_BLAKE2S\n    if (node_offset > 0xFFFFFFFFFFFFULL) {\n        /* maximum 2**48 - 1 */\n         PyErr_SetString(PyExc_OverflowError, \"node_offset is too large\");\n         goto error;\n     }\n    store48(&(self->param.node_offset), node_offset);\n#else\n    // NB: Simple assignment here would be incorrect on big endian platforms.\n    store64(&(self->param.node_offset), node_offset);\n#endif\n\n    if (node_depth < 0 || node_depth > 255) {\n        PyErr_SetString(PyExc_ValueError,\n                \"node_depth must be between 0 and 255\");\n        goto error;\n    }\n    self->param.node_depth = node_depth;\n\n    if (inner_size < 0 || inner_size > BLAKE2S_OUTBYTES) {\n        PyErr_Format(PyExc_ValueError,\n                \"inner_size must be between 0 and is %d\",\n                BLAKE2S_OUTBYTES);\n        goto error;\n    }\n    self->param.inner_length = inner_size;\n\n    /* Set key length. */\n    if ((key->obj != NULL) && key->len) {\n        if (key->len > BLAKE2S_KEYBYTES) {\n            PyErr_Format(PyExc_ValueError,\n                \"maximum key length is %d bytes\",\n                BLAKE2S_KEYBYTES);\n            goto error;\n        }\n        self->param.key_length = (uint8_t)key->len;\n    }\n\n    /* Initialize hash state. */\n    if (blake2s_init_param(&self->state, &self->param) < 0) {\n        PyErr_SetString(PyExc_RuntimeError,\n                \"error initializing hash state\");\n        goto error;\n    }\n\n    /* Set last node flag (must come after initialization). */\n    self->state.last_node = last_node;\n\n    /* Process key block if any. */\n    if (self->param.key_length) {\n        uint8_t block[BLAKE2S_BLOCKBYTES];\n        memset(block, 0, sizeof(block));\n        memcpy(block, key->buf, key->len);\n        blake2s_update(&self->state, block, sizeof(block));\n        secure_zero_memory(block, sizeof(block));\n    }\n\n    /* Process initial data if any. */\n    if (data != NULL) {\n        GET_BUFFER_VIEW_OR_ERROR(data, &buf, goto error);\n\n        if (buf.len >= HASHLIB_GIL_MINSIZE) {\n            Py_BEGIN_ALLOW_THREADS\n            blake2s_update(&self->state, buf.buf, buf.len);\n            Py_END_ALLOW_THREADS\n        } else {\n            blake2s_update(&self->state, buf.buf, buf.len);\n        }\n        PyBuffer_Release(&buf);\n    }\n\n    return (PyObject *)self;\n\n  error:\n    if (self != NULL) {\n        Py_DECREF(self);\n    }\n    return NULL;\n}\n\n/*[clinic input]\n_blake2.blake2s.copy\n\nReturn a copy of the hash object.\n[clinic start generated code]*/\n\nstatic PyObject *\n_blake2_blake2s_copy_impl(BLAKE2sObject *self)\n/*[clinic end generated code: output=5b90131c4eae275e input=0b9d44942f0fe4b2]*/\n{\n    BLAKE2sObject *cpy;\n\n    if ((cpy = new_BLAKE2sObject(Py_TYPE(self))) == NULL)\n        return NULL;\n\n    ENTER_HASHLIB(self);\n    cpy->param = self->param;\n    cpy->state = self->state;\n    LEAVE_HASHLIB(self);\n    return (PyObject *)cpy;\n}\n\n/*[clinic input]\n_blake2.blake2s.update\n\n    data: object\n    /\n\nUpdate this hash object's state with the provided bytes-like object.\n[clinic start generated code]*/\n\nstatic PyObject *\n_blake2_blake2s_update(BLAKE2sObject *self, PyObject *data)\n/*[clinic end generated code: output=757dc087fec37815 input=97500db2f9de4aaa]*/\n{\n    Py_buffer buf;\n\n    GET_BUFFER_VIEW_OR_ERROUT(data, &buf);\n\n    if (self->lock == NULL && buf.len >= HASHLIB_GIL_MINSIZE)\n        self->lock = PyThread_allocate_lock();\n\n    if (self->lock != NULL) {\n       Py_BEGIN_ALLOW_THREADS\n       PyThread_acquire_lock(self->lock, 1);\n       blake2s_update(&self->state, buf.buf, buf.len);\n       PyThread_release_lock(self->lock);\n       Py_END_ALLOW_THREADS\n    } else {\n        blake2s_update(&self->state, buf.buf, buf.len);\n    }\n    PyBuffer_Release(&buf);\n\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n_blake2.blake2s.digest\n\nReturn the digest value as a bytes object.\n[clinic start generated code]*/\n\nstatic PyObject *\n_blake2_blake2s_digest_impl(BLAKE2sObject *self)\n/*[clinic end generated code: output=40c566ca4bc6bc51 input=f41e0b8d6d937454]*/\n{\n    uint8_t digest[BLAKE2S_OUTBYTES];\n    blake2s_state state_cpy;\n\n    ENTER_HASHLIB(self);\n    state_cpy = self->state;\n    blake2s_final(&state_cpy, digest, self->param.digest_length);\n    LEAVE_HASHLIB(self);\n    return PyBytes_FromStringAndSize((const char *)digest,\n            self->param.digest_length);\n}\n\n/*[clinic input]\n_blake2.blake2s.hexdigest\n\nReturn the digest value as a string of hexadecimal digits.\n[clinic start generated code]*/\n\nstatic PyObject *\n_blake2_blake2s_hexdigest_impl(BLAKE2sObject *self)\n/*[clinic end generated code: output=15153eb5e59c52eb input=c77a1321567e8952]*/\n{\n    uint8_t digest[BLAKE2S_OUTBYTES];\n    blake2s_state state_cpy;\n\n    ENTER_HASHLIB(self);\n    state_cpy = self->state;\n    blake2s_final(&state_cpy, digest, self->param.digest_length);\n    LEAVE_HASHLIB(self);\n    return _Py_strhex((const char *)digest, self->param.digest_length);\n}\n\n\nstatic PyMethodDef py_blake2s_methods[] = {\n    _BLAKE2_BLAKE2S_COPY_METHODDEF\n    _BLAKE2_BLAKE2S_DIGEST_METHODDEF\n    _BLAKE2_BLAKE2S_HEXDIGEST_METHODDEF\n    _BLAKE2_BLAKE2S_UPDATE_METHODDEF\n    {NULL, NULL}\n};\n\n\n\nstatic PyObject *\npy_blake2s_get_name(BLAKE2sObject *self, void *closure)\n{\n    return PyUnicode_FromString(\"blake2s\");\n}\n\n\n\nstatic PyObject *\npy_blake2s_get_block_size(BLAKE2sObject *self, void *closure)\n{\n    return PyLong_FromLong(BLAKE2S_BLOCKBYTES);\n}\n\n\n\nstatic PyObject *\npy_blake2s_get_digest_size(BLAKE2sObject *self, void *closure)\n{\n    return PyLong_FromLong(self->param.digest_length);\n}\n\n\nstatic PyGetSetDef py_blake2s_getsetters[] = {\n    {\"name\", (getter)py_blake2s_get_name,\n        NULL, NULL, NULL},\n    {\"block_size\", (getter)py_blake2s_get_block_size,\n        NULL, NULL, NULL},\n    {\"digest_size\", (getter)py_blake2s_get_digest_size,\n        NULL, NULL, NULL},\n    {NULL}\n};\n\n\nstatic void\npy_blake2s_dealloc(PyObject *self)\n{\n    BLAKE2sObject *obj = (BLAKE2sObject *)self;\n\n    /* Try not to leave state in memory. */\n    secure_zero_memory(&obj->param, sizeof(obj->param));\n    secure_zero_memory(&obj->state, sizeof(obj->state));\n    if (obj->lock) {\n        PyThread_free_lock(obj->lock);\n        obj->lock = NULL;\n    }\n\n    PyTypeObject *type = Py_TYPE(self);\n    PyObject_Free(self);\n    Py_DECREF(type);\n}\n\nstatic PyType_Slot blake2s_type_slots[] = {\n    {Py_tp_dealloc, py_blake2s_dealloc},\n    {Py_tp_doc, (char *)py_blake2s_new__doc__},\n    {Py_tp_methods, py_blake2s_methods},\n    {Py_tp_getset, py_blake2s_getsetters},\n    {Py_tp_new, py_blake2s_new},\n    {0,0}\n};\n\nPyType_Spec blake2s_type_spec = {\n    .name = \"_blake2.blake2s\",\n    .basicsize =  sizeof(BLAKE2sObject),\n    .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE,\n    .slots = blake2s_type_slots\n};\n"}, "sourceLanguage": "c"}, {"location": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "contents": {"text": "/*\n   BLAKE2 reference source code package - reference C implementations\n\n   Written in 2012 by Samuel Neves <sneves@dei.uc.pt>\n\n   To the extent possible under law, the author(s) have dedicated all copyright\n   and related and neighboring rights to this software to the public domain\n   worldwide. This software is distributed without any warranty.\n\n   You should have received a copy of the CC0 Public Domain Dedication along with\n   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n\n#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"blake2.h\"\n#include \"blake2-impl.h\"\n\nstatic const uint32_t blake2s_IV[8] =\n{\n  0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL, 0xA54FF53AUL,\n  0x510E527FUL, 0x9B05688CUL, 0x1F83D9ABUL, 0x5BE0CD19UL\n};\n\nstatic const uint8_t blake2s_sigma[10][16] =\n{\n  {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,\n  { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 } ,\n  { 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 } ,\n  {  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 } ,\n  {  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 } ,\n  {  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 } ,\n  { 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 } ,\n  { 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 } ,\n  {  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 } ,\n  { 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 } ,\n};\n\nstatic inline int blake2s_set_lastnode( blake2s_state *S )\n{\n  S->f[1] = ~0U;\n  return 0;\n}\n\nstatic inline int blake2s_clear_lastnode( blake2s_state *S )\n{\n  S->f[1] = 0U;\n  return 0;\n}\n\n/* Some helper functions, not necessarily useful */\nstatic inline int blake2s_set_lastblock( blake2s_state *S )\n{\n  if( S->last_node ) blake2s_set_lastnode( S );\n\n  S->f[0] = ~0U;\n  return 0;\n}\n\nstatic inline int blake2s_clear_lastblock( blake2s_state *S )\n{\n  if( S->last_node ) blake2s_clear_lastnode( S );\n\n  S->f[0] = 0U;\n  return 0;\n}\n\nstatic inline int blake2s_increment_counter( blake2s_state *S, const uint32_t inc )\n{\n  S->t[0] += inc;\n  S->t[1] += ( S->t[0] < inc );\n  return 0;\n}\n\n// Parameter-related functions\nstatic inline int blake2s_param_set_digest_length( blake2s_param *P, const uint8_t digest_length )\n{\n  P->digest_length = digest_length;\n  return 0;\n}\n\nstatic inline int blake2s_param_set_fanout( blake2s_param *P, const uint8_t fanout )\n{\n  P->fanout = fanout;\n  return 0;\n}\n\nstatic inline int blake2s_param_set_max_depth( blake2s_param *P, const uint8_t depth )\n{\n  P->depth = depth;\n  return 0;\n}\n\nstatic inline int blake2s_param_set_leaf_length( blake2s_param *P, const uint32_t leaf_length )\n{\n  store32( &P->leaf_length, leaf_length );\n  return 0;\n}\n\nstatic inline int blake2s_param_set_node_offset( blake2s_param *P, const uint64_t node_offset )\n{\n  store48( P->node_offset, node_offset );\n  return 0;\n}\n\nstatic inline int blake2s_param_set_node_depth( blake2s_param *P, const uint8_t node_depth )\n{\n  P->node_depth = node_depth;\n  return 0;\n}\n\nstatic inline int blake2s_param_set_inner_length( blake2s_param *P, const uint8_t inner_length )\n{\n  P->inner_length = inner_length;\n  return 0;\n}\n\nstatic inline int blake2s_param_set_salt( blake2s_param *P, const uint8_t salt[BLAKE2S_SALTBYTES] )\n{\n  memcpy( P->salt, salt, BLAKE2S_SALTBYTES );\n  return 0;\n}\n\nstatic inline int blake2s_param_set_personal( blake2s_param *P, const uint8_t personal[BLAKE2S_PERSONALBYTES] )\n{\n  memcpy( P->personal, personal, BLAKE2S_PERSONALBYTES );\n  return 0;\n}\n\nstatic inline int blake2s_init0( blake2s_state *S )\n{\n  memset( S, 0, sizeof( blake2s_state ) );\n\n  for( int i = 0; i < 8; ++i ) S->h[i] = blake2s_IV[i];\n\n  return 0;\n}\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n  int blake2s_init( blake2s_state *S, size_t outlen );\n  int blake2s_init_param( blake2s_state *S, const blake2s_param *P );\n  int blake2s_init_key( blake2s_state *S, size_t outlen, const void *key, size_t keylen );\n  int blake2s_update( blake2s_state *S, const uint8_t *in, size_t inlen );\n  int blake2s_final( blake2s_state *S, uint8_t *out, size_t outlen );\n  int blake2s( uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen );\n#if defined(__cplusplus)\n}\n#endif\n\n/* init2 xors IV with input parameter block */\nint blake2s_init_param( blake2s_state *S, const blake2s_param *P )\n{\n  blake2s_init0( S );\n  uint32_t *p = ( uint32_t * )( P );\n\n  /* IV XOR ParamBlock */\n  for( size_t i = 0; i < 8; ++i )\n    S->h[i] ^= load32( &p[i] );\n\n  S->outlen = P->digest_length;\n  return 0;\n}\n\n\n// Sequential blake2s initialization\nint blake2s_init( blake2s_state *S, size_t outlen )\n{\n  blake2s_param P[1];\n\n  /* Move interval verification here? */\n  if ( ( !outlen ) || ( outlen > BLAKE2S_OUTBYTES ) ) return -1;\n\n  P->digest_length = ( uint8_t) outlen;\n  P->key_length    = 0;\n  P->fanout        = 1;\n  P->depth         = 1;\n  store32( &P->leaf_length, 0 );\n  store48( &P->node_offset, 0 );\n  P->node_depth    = 0;\n  P->inner_length  = 0;\n  // memset(P->reserved, 0, sizeof(P->reserved) );\n  memset( P->salt,     0, sizeof( P->salt ) );\n  memset( P->personal, 0, sizeof( P->personal ) );\n  return blake2s_init_param( S, P );\n}\n\nint blake2s_init_key( blake2s_state *S, size_t outlen, const void *key, size_t keylen )\n{\n  blake2s_param P[1];\n\n  if ( ( !outlen ) || ( outlen > BLAKE2S_OUTBYTES ) ) return -1;\n\n  if ( !key || !keylen || keylen > BLAKE2S_KEYBYTES ) return -1;\n\n  P->digest_length = ( uint8_t ) outlen;\n  P->key_length    = ( uint8_t ) keylen;\n  P->fanout        = 1;\n  P->depth         = 1;\n  store32( &P->leaf_length, 0 );\n  store48( &P->node_offset, 0 );\n  P->node_depth    = 0;\n  P->inner_length  = 0;\n  // memset(P->reserved, 0, sizeof(P->reserved) );\n  memset( P->salt,     0, sizeof( P->salt ) );\n  memset( P->personal, 0, sizeof( P->personal ) );\n\n  if( blake2s_init_param( S, P ) < 0 ) return -1;\n\n  {\n    uint8_t block[BLAKE2S_BLOCKBYTES];\n    memset( block, 0, BLAKE2S_BLOCKBYTES );\n    memcpy( block, key, keylen );\n    blake2s_update( S, block, BLAKE2S_BLOCKBYTES );\n    secure_zero_memory( block, BLAKE2S_BLOCKBYTES ); /* Burn the key from stack */\n  }\n  return 0;\n}\n\nstatic int blake2s_compress( blake2s_state *S, const uint8_t block[BLAKE2S_BLOCKBYTES] )\n{\n  uint32_t m[16];\n  uint32_t v[16];\n\n  for( size_t i = 0; i < 16; ++i )\n    m[i] = load32( block + i * sizeof( m[i] ) );\n\n  for( size_t i = 0; i < 8; ++i )\n    v[i] = S->h[i];\n\n  v[ 8] = blake2s_IV[0];\n  v[ 9] = blake2s_IV[1];\n  v[10] = blake2s_IV[2];\n  v[11] = blake2s_IV[3];\n  v[12] = S->t[0] ^ blake2s_IV[4];\n  v[13] = S->t[1] ^ blake2s_IV[5];\n  v[14] = S->f[0] ^ blake2s_IV[6];\n  v[15] = S->f[1] ^ blake2s_IV[7];\n#define G(r,i,a,b,c,d) \\\n  do { \\\n    a = a + b + m[blake2s_sigma[r][2*i+0]]; \\\n    d = rotr32(d ^ a, 16); \\\n    c = c + d; \\\n    b = rotr32(b ^ c, 12); \\\n    a = a + b + m[blake2s_sigma[r][2*i+1]]; \\\n    d = rotr32(d ^ a, 8); \\\n    c = c + d; \\\n    b = rotr32(b ^ c, 7); \\\n  } while(0)\n#define ROUND(r)  \\\n  do { \\\n    G(r,0,v[ 0],v[ 4],v[ 8],v[12]); \\\n    G(r,1,v[ 1],v[ 5],v[ 9],v[13]); \\\n    G(r,2,v[ 2],v[ 6],v[10],v[14]); \\\n    G(r,3,v[ 3],v[ 7],v[11],v[15]); \\\n    G(r,4,v[ 0],v[ 5],v[10],v[15]); \\\n    G(r,5,v[ 1],v[ 6],v[11],v[12]); \\\n    G(r,6,v[ 2],v[ 7],v[ 8],v[13]); \\\n    G(r,7,v[ 3],v[ 4],v[ 9],v[14]); \\\n  } while(0)\n  ROUND( 0 );\n  ROUND( 1 );\n  ROUND( 2 );\n  ROUND( 3 );\n  ROUND( 4 );\n  ROUND( 5 );\n  ROUND( 6 );\n  ROUND( 7 );\n  ROUND( 8 );\n  ROUND( 9 );\n\n  for( size_t i = 0; i < 8; ++i )\n    S->h[i] = S->h[i] ^ v[i] ^ v[i + 8];\n\n#undef G\n#undef ROUND\n  return 0;\n}\n\n\nint blake2s_update( blake2s_state *S, const uint8_t *in, size_t inlen )\n{\n  while( inlen > 0 )\n  {\n    uint32_t left = S->buflen;\n    uint32_t fill = 2 * BLAKE2S_BLOCKBYTES - left;\n\n    if( inlen > fill )\n    {\n      memcpy( S->buf + left, in, fill ); // Fill buffer\n      S->buflen += fill;\n      blake2s_increment_counter( S, BLAKE2S_BLOCKBYTES );\n      blake2s_compress( S, S->buf ); // Compress\n      memcpy( S->buf, S->buf + BLAKE2S_BLOCKBYTES, BLAKE2S_BLOCKBYTES ); // Shift buffer left\n      S->buflen -= BLAKE2S_BLOCKBYTES;\n      in += fill;\n      inlen -= fill;\n    }\n    else // inlen <= fill\n    {\n      memcpy( S->buf + left, in, inlen );\n      S->buflen += ( uint32_t ) inlen; // Be lazy, do not compress\n      in += inlen;\n      inlen -= inlen;\n    }\n  }\n\n  return 0;\n}\n\nint blake2s_final( blake2s_state *S, uint8_t *out, size_t outlen )\n{\n  uint8_t buffer[BLAKE2S_OUTBYTES];\n  size_t i;\n\n  if(S->outlen != outlen) return -1;\n\n  if( S->buflen > BLAKE2S_BLOCKBYTES )\n  {\n    blake2s_increment_counter( S, BLAKE2S_BLOCKBYTES );\n    blake2s_compress( S, S->buf );\n    S->buflen -= BLAKE2S_BLOCKBYTES;\n    memmove( S->buf, S->buf + BLAKE2S_BLOCKBYTES, S->buflen );\n  }\n\n  blake2s_increment_counter( S, ( uint32_t )S->buflen );\n  blake2s_set_lastblock( S );\n  memset( S->buf + S->buflen, 0, 2 * BLAKE2S_BLOCKBYTES - S->buflen ); /* Padding */\n  blake2s_compress( S, S->buf );\n\n  for( i = 0; i < 8; ++i ) /* Output full hash to temp buffer */\n    store32( buffer + sizeof( S->h[i] ) * i, S->h[i] );\n\n  memcpy( out, buffer, outlen );\n  return 0;\n}\n\nint blake2s( uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen )\n{\n  blake2s_state S[1];\n\n  /* Verify parameters */\n  if ( NULL == in && inlen > 0 ) return -1;\n\n  if ( NULL == out ) return -1;\n\n  if ( NULL == key && keylen > 0 ) return -1;\n\n  if( !outlen || outlen > BLAKE2S_OUTBYTES ) return -1;\n\n  if( keylen > BLAKE2S_KEYBYTES ) return -1;\n\n  if( keylen > 0 )\n  {\n    if( blake2s_init_key( S, outlen, key, keylen ) < 0 ) return -1;\n  }\n  else\n  {\n    if( blake2s_init( S, outlen ) < 0 ) return -1;\n  }\n\n  if( blake2s_update( S, ( uint8_t * )in, inlen ) < 0) return -1;\n  return blake2s_final( S, out, outlen );\n}\n\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value 'v[4]'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 264, "startColumn": 3, "endColumn": 4}, "contextRegion": {"startLine": 264, "snippet": {"text": "  ROUND( 0 );\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_compress", "fullyQualifiedName": "PyBlake2_blake2s_compress", "decoratedName": "PyBlake2_blake2s_compress", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/blake2s_impl.c", "uriBaseId": "PWD"}, "region": {"startLine": 274, "startColumn": 1, "endColumn": 23}, "contextRegion": {"startLine": 274, "snippet": {"text": "_blake2_blake2s_update(BLAKE2sObject *self, PyObject *data)\n"}}}, "logicalLocations": [{"name": "_blake2_blake2s_update", "fullyQualifiedName": "_blake2_blake2s_update", "decoratedName": "_blake2_blake2s_update", "kind": "function"}], "message": {"text": "entry to '_blake2_blake2s_update'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/blake2s_impl.c", "uriBaseId": "PWD"}, "region": {"startLine": 279, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 279, "snippet": {"text": "    GET_BUFFER_VIEW_OR_ERROUT(data, &buf);\n"}}}, "logicalLocations": [{"name": "_blake2_blake2s_update", "fullyQualifiedName": "_blake2_blake2s_update", "decoratedName": "_blake2_blake2s_update", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/blake2s_impl.c", "uriBaseId": "PWD"}, "region": {"startLine": 279, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 279, "snippet": {"text": "    GET_BUFFER_VIEW_OR_ERROUT(data, &buf);\n"}}}, "logicalLocations": [{"name": "_blake2_blake2s_update", "fullyQualifiedName": "_blake2_blake2s_update", "decoratedName": "_blake2_blake2s_update", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/blake2s_impl.c", "uriBaseId": "PWD"}, "region": {"startLine": 281, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 281, "snippet": {"text": "    if (self->lock == NULL && buf.len >= HASHLIB_GIL_MINSIZE)\n"}}}, "logicalLocations": [{"name": "_blake2_blake2s_update", "fullyQualifiedName": "_blake2_blake2s_update", "decoratedName": "_blake2_blake2s_update", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/blake2s_impl.c", "uriBaseId": "PWD"}, "region": {"startLine": 282, "startColumn": 9, "endColumn": 13}, "contextRegion": {"startLine": 282, "snippet": {"text": "        self->lock = PyThread_allocate_lock();\n"}}}, "logicalLocations": [{"name": "_blake2_blake2s_update", "fullyQualifiedName": "_blake2_blake2s_update", "decoratedName": "_blake2_blake2s_update", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/blake2s_impl.c", "uriBaseId": "PWD"}, "region": {"startLine": 284, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 284, "snippet": {"text": "    if (self->lock != NULL) {\n"}}}, "logicalLocations": [{"name": "_blake2_blake2s_update", "fullyQualifiedName": "_blake2_blake2s_update", "decoratedName": "_blake2_blake2s_update", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/blake2s_impl.c", "uriBaseId": "PWD"}, "region": {"startLine": 291, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 291, "snippet": {"text": "        blake2s_update(&self->state, buf.buf, buf.len);\n"}}}, "logicalLocations": [{"name": "_blake2_blake2s_update", "fullyQualifiedName": "_blake2_blake2s_update", "decoratedName": "_blake2_blake2s_update", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/blake2s_impl.c", "uriBaseId": "PWD"}, "region": {"startLine": 291, "startColumn": 9, "endColumn": 55}, "contextRegion": {"startLine": 291, "snippet": {"text": "        blake2s_update(&self->state, buf.buf, buf.len);\n"}}}, "logicalLocations": [{"name": "_blake2_blake2s_update", "fullyQualifiedName": "_blake2_blake2s_update", "decoratedName": "_blake2_blake2s_update", "kind": "function"}], "message": {"text": "calling 'PyBlake2_blake2s_update' from '_blake2_blake2s_update'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 284, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 284, "snippet": {"text": "int blake2s_update( blake2s_state *S, const uint8_t *in, size_t inlen )\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_update", "fullyQualifiedName": "PyBlake2_blake2s_update", "decoratedName": "PyBlake2_blake2s_update", "kind": "function"}], "message": {"text": "entry to 'PyBlake2_blake2s_update'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 286, "startColumn": 10, "endColumn": 19}, "contextRegion": {"startLine": 286, "snippet": {"text": "  while( inlen > 0 )\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_update", "fullyQualifiedName": "PyBlake2_blake2s_update", "decoratedName": "PyBlake2_blake2s_update", "kind": "function"}], "message": {"text": "following 'true' branch (when 'inlen != 0')..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 288, "startColumn": 5, "endColumn": 13}, "contextRegion": {"startLine": 288, "snippet": {"text": "    uint32_t left = S->buflen;\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_update", "fullyQualifiedName": "PyBlake2_blake2s_update", "decoratedName": "PyBlake2_blake2s_update", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 291, "startColumn": 7, "endColumn": 8}, "contextRegion": {"startLine": 291, "snippet": {"text": "    if( inlen > fill )\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_update", "fullyQualifiedName": "PyBlake2_blake2s_update", "decoratedName": "PyBlake2_blake2s_update", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 293, "startColumn": 7, "endColumn": 13}, "contextRegion": {"startLine": 293, "snippet": {"text": "      memcpy( S->buf + left, in, fill ); // Fill buffer\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_update", "fullyQualifiedName": "PyBlake2_blake2s_update", "decoratedName": "PyBlake2_blake2s_update", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 296, "startColumn": 7, "endColumn": 36}, "contextRegion": {"startLine": 296, "snippet": {"text": "      blake2s_compress( S, S->buf ); // Compress\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_update", "fullyQualifiedName": "PyBlake2_blake2s_update", "decoratedName": "PyBlake2_blake2s_update", "kind": "function"}], "message": {"text": "calling 'PyBlake2_blake2s_compress' from 'PyBlake2_blake2s_update'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 223, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 223, "snippet": {"text": "static int blake2s_compress( blake2s_state *S, const uint8_t block[BLAKE2S_BLOCKBYTES] )\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_compress", "fullyQualifiedName": "PyBlake2_blake2s_compress", "decoratedName": "PyBlake2_blake2s_compress", "kind": "function"}], "message": {"text": "entry to 'PyBlake2_blake2s_compress'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 226, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 226, "snippet": {"text": "  uint32_t v[16];\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_compress", "fullyQualifiedName": "PyBlake2_blake2s_compress", "decoratedName": "PyBlake2_blake2s_compress", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 228, "startColumn": 22, "endColumn": 28}, "contextRegion": {"startLine": 228, "snippet": {"text": "  for( size_t i = 0; i < 16; ++i )\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_compress", "fullyQualifiedName": "PyBlake2_blake2s_compress", "decoratedName": "PyBlake2_blake2s_compress", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i != 16')..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 229, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 229, "snippet": {"text": "    m[i] = load32( block + i * sizeof( m[i] ) );\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_compress", "fullyQualifiedName": "PyBlake2_blake2s_compress", "decoratedName": "PyBlake2_blake2s_compress", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 228, "startColumn": 22, "endColumn": 28}, "contextRegion": {"startLine": 228, "snippet": {"text": "  for( size_t i = 0; i < 16; ++i )\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_compress", "fullyQualifiedName": "PyBlake2_blake2s_compress", "decoratedName": "PyBlake2_blake2s_compress", "kind": "function"}], "message": {"text": "following 'false' branch (when 'i == 16')..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"logicalLocations": [{"name": "PyBlake2_blake2s_compress", "fullyQualifiedName": "PyBlake2_blake2s_compress", "decoratedName": "PyBlake2_blake2s_compress", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 231, "startColumn": 22, "endColumn": 27}, "contextRegion": {"startLine": 231, "snippet": {"text": "  for( size_t i = 0; i < 8; ++i )\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_compress", "fullyQualifiedName": "PyBlake2_blake2s_compress", "decoratedName": "PyBlake2_blake2s_compress", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i != 8')..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 232, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 232, "snippet": {"text": "    v[i] = S->h[i];\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_compress", "fullyQualifiedName": "PyBlake2_blake2s_compress", "decoratedName": "PyBlake2_blake2s_compress", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 231, "startColumn": 22, "endColumn": 27}, "contextRegion": {"startLine": 231, "snippet": {"text": "  for( size_t i = 0; i < 8; ++i )\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_compress", "fullyQualifiedName": "PyBlake2_blake2s_compress", "decoratedName": "PyBlake2_blake2s_compress", "kind": "function"}], "message": {"text": "following 'false' branch (when 'i == 8')..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 234, "startColumn": 3, "endColumn": 4}, "contextRegion": {"startLine": 234, "snippet": {"text": "  v[ 8] = blake2s_IV[0];\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_compress", "fullyQualifiedName": "PyBlake2_blake2s_compress", "decoratedName": "PyBlake2_blake2s_compress", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_blake2/impl/blake2s-ref.c", "uriBaseId": "PWD"}, "region": {"startLine": 264, "startColumn": 3, "endColumn": 4}, "contextRegion": {"startLine": 264, "snippet": {"text": "  ROUND( 0 );\n"}}}, "logicalLocations": [{"name": "PyBlake2_blake2s_compress", "fullyQualifiedName": "PyBlake2_blake2s_compress", "decoratedName": "PyBlake2_blake2s_compress", "kind": "function"}], "message": {"text": "use of uninitialized value 'v[4]' here"}}, "kinds": ["danger"], "nestingLevel": 3}]}]}]}]}]}
