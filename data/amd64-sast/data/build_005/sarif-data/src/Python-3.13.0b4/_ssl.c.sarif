{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-null-dereference",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-dereference"}]}},
           "taxonomies": [{"name": "CWE",
                           "version": "4.7",
                           "organization": "MITRE",
                           "shortDescription": {"text": "The MITRE Common Weakness Enumeration"},
                           "taxa": [{"id": "476",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}],
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.13.0b4/"}},
           "artifacts": [{"location": {"uri": "./Modules/_ssl.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/* SSL socket module\n\n   SSL support based on patches by Brian E Gallew and Laszlo Kovacs.\n   Re-worked a bit by Bill Janssen to add server-side support and\n   certificate decoding.  Chris Stawarz contributed some non-blocking\n   patches.\n\n   This module is imported by ssl.py. It should *not* be used\n   directly.\n\n   XXX should partial writes be enabled, SSL_MODE_ENABLE_PARTIAL_WRITE?\n\n   XXX integrate several \"shutdown modes\" as suggested in\n       http://bugs.python.org/issue8108#msg102867 ?\n*/\n\n#ifndef Py_BUILD_CORE_BUILTIN\n#  define Py_BUILD_CORE_MODULE 1\n#endif\n\n/* Don't warn about deprecated functions, */\n#ifndef OPENSSL_API_COMPAT\n  // 0x10101000L == 1.1.1, 30000 == 3.0.0\n  #define OPENSSL_API_COMPAT 0x10101000L\n#endif\n#define OPENSSL_NO_DEPRECATED 1\n\n#include \"Python.h\"\n#include \"pycore_fileutils.h\"     // _PyIsSelectable_fd()\n#include \"pycore_pyerrors.h\"      // _PyErr_ChainExceptions1()\n#include \"pycore_time.h\"          // _PyDeadline_Init()\n\n/* Include symbols from _socket module */\n#include \"socketmodule.h\"\n\n#ifdef MS_WINDOWS\n#  include <wincrypt.h>\n#endif\n\n#include \"_ssl.h\"\n\n/* Redefined below for Windows debug builds after important #includes */\n#define _PySSL_FIX_ERRNO\n\n#define PySSL_BEGIN_ALLOW_THREADS_S(save) \\\n    do { (save) = PyEval_SaveThread(); } while(0)\n#define PySSL_END_ALLOW_THREADS_S(save) \\\n    do { PyEval_RestoreThread(save); _PySSL_FIX_ERRNO; } while(0)\n#define PySSL_BEGIN_ALLOW_THREADS { \\\n            PyThreadState *_save = NULL;  \\\n            PySSL_BEGIN_ALLOW_THREADS_S(_save);\n#define PySSL_END_ALLOW_THREADS PySSL_END_ALLOW_THREADS_S(_save); }\n\n\n#if defined(HAVE_POLL_H)\n#include <poll.h>\n#elif defined(HAVE_SYS_POLL_H)\n#include <sys/poll.h>\n#endif\n\n/* Include OpenSSL header files */\n#include \"openssl/rsa.h\"\n#include \"openssl/crypto.h\"\n#include \"openssl/x509.h\"\n#include \"openssl/x509v3.h\"\n#include \"openssl/pem.h\"\n#include \"openssl/ssl.h\"\n#include \"openssl/err.h\"\n#include \"openssl/rand.h\"\n#include \"openssl/bio.h\"\n#include \"openssl/dh.h\"\n\n#ifndef OPENSSL_THREADS\n#  error \"OPENSSL_THREADS is not defined, Python requires thread-safe OpenSSL\"\n#endif\n\n\n\nstruct py_ssl_error_code {\n    const char *mnemonic;\n    int library, reason;\n};\n\nstruct py_ssl_library_code {\n    const char *library;\n    int code;\n};\n\n#if defined(MS_WINDOWS) && defined(Py_DEBUG)\n/* Debug builds on Windows rely on getting errno directly from OpenSSL.\n * However, because it uses a different CRT, we need to transfer the\n * value of errno from OpenSSL into our debug CRT.\n *\n * Don't be fooled - this is horribly ugly code. The only reasonable\n * alternative is to do both debug and release builds of OpenSSL, which\n * requires much uglier code to transform their automatically generated\n * makefile. This is the lesser of all the evils.\n */\n\nstatic void _PySSLFixErrno(void) {\n    HMODULE ucrtbase = GetModuleHandleW(L\"ucrtbase.dll\");\n    if (!ucrtbase) {\n        /* If ucrtbase.dll is not loaded but the SSL DLLs are, we likely\n         * have a catastrophic failure, but this function is not the\n         * place to raise it. */\n        return;\n    }\n\n    typedef int *(__stdcall *errno_func)(void);\n    errno_func ssl_errno = (errno_func)GetProcAddress(ucrtbase, \"_errno\");\n    if (ssl_errno) {\n        errno = *ssl_errno();\n        *ssl_errno() = 0;\n    } else {\n        errno = ENOTRECOVERABLE;\n    }\n}\n\n#undef _PySSL_FIX_ERRNO\n#define _PySSL_FIX_ERRNO _PySSLFixErrno()\n#endif\n\n/* Include generated data (error codes) */\n#if (OPENSSL_VERSION_NUMBER >= 0x30100000L)\n#include \"_ssl_data_31.h\"\n#elif (OPENSSL_VERSION_NUMBER >= 0x30000000L)\n#include \"_ssl_data_300.h\"\n#elif (OPENSSL_VERSION_NUMBER >= 0x10101000L)\n#include \"_ssl_data_111.h\"\n#else\n#error Unsupported OpenSSL version\n#endif\n\n/* OpenSSL API 1.1.0+ does not include version methods */\n#ifndef OPENSSL_NO_SSL3_METHOD\nextern const SSL_METHOD *SSLv3_method(void);\n#endif\n#ifndef OPENSSL_NO_TLS1_METHOD\nextern const SSL_METHOD *TLSv1_method(void);\n#endif\n#ifndef OPENSSL_NO_TLS1_1_METHOD\nextern const SSL_METHOD *TLSv1_1_method(void);\n#endif\n#ifndef OPENSSL_NO_TLS1_2_METHOD\nextern const SSL_METHOD *TLSv1_2_method(void);\n#endif\n\n#ifndef INVALID_SOCKET /* MS defines this */\n#define INVALID_SOCKET (-1)\n#endif\n\n/* Default cipher suites */\n#ifndef PY_SSL_DEFAULT_CIPHERS\n#define PY_SSL_DEFAULT_CIPHERS 1\n#endif\n\n#if PY_SSL_DEFAULT_CIPHERS == 0\n  #ifndef PY_SSL_DEFAULT_CIPHER_STRING\n     #error \"Py_SSL_DEFAULT_CIPHERS 0 needs Py_SSL_DEFAULT_CIPHER_STRING\"\n  #endif\n  #ifndef PY_SSL_MIN_PROTOCOL\n    #define PY_SSL_MIN_PROTOCOL TLS1_2_VERSION\n  #endif\n#elif PY_SSL_DEFAULT_CIPHERS == 1\n/* Python custom selection of sensible cipher suites\n * @SECLEVEL=2: security level 2 with 112 bits minimum security (e.g. 2048 bits RSA key)\n * ECDH+*: enable ephemeral elliptic curve Diffie-Hellman\n * DHE+*: fallback to ephemeral finite field Diffie-Hellman\n * encryption order: AES AEAD (GCM), ChaCha AEAD, AES CBC\n * !aNULL:!eNULL: really no NULL ciphers\n * !aDSS: no authentication with discrete logarithm DSA algorithm\n * !SHA1: no weak SHA1 MAC\n * !AESCCM: no CCM mode, it's uncommon and slow\n *\n * Based on Hynek's excellent blog post (update 2021-02-11)\n * https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/\n */\n  #define PY_SSL_DEFAULT_CIPHER_STRING \"@SECLEVEL=2:ECDH+AESGCM:ECDH+CHACHA20:ECDH+AES:DHE+AES:!aNULL:!eNULL:!aDSS:!SHA1:!AESCCM\"\n  #ifndef PY_SSL_MIN_PROTOCOL\n    #define PY_SSL_MIN_PROTOCOL TLS1_2_VERSION\n  #endif\n#elif PY_SSL_DEFAULT_CIPHERS == 2\n/* Ignored in SSLContext constructor, only used to as _ssl.DEFAULT_CIPHER_STRING */\n  #define PY_SSL_DEFAULT_CIPHER_STRING SSL_DEFAULT_CIPHER_LIST\n#else\n  #error \"Unsupported PY_SSL_DEFAULT_CIPHERS\"\n#endif\n\n\nenum py_ssl_error {\n    /* these mirror ssl.h */\n    PY_SSL_ERROR_NONE,\n    PY_SSL_ERROR_SSL,\n    PY_SSL_ERROR_WANT_READ,\n    PY_SSL_ERROR_WANT_WRITE,\n    PY_SSL_ERROR_WANT_X509_LOOKUP,\n    PY_SSL_ERROR_SYSCALL,     /* look at error stack/return value/errno */\n    PY_SSL_ERROR_ZERO_RETURN,\n    PY_SSL_ERROR_WANT_CONNECT,\n    /* start of non ssl.h errorcodes */\n    PY_SSL_ERROR_EOF,         /* special case of SSL_ERROR_SYSCALL */\n    PY_SSL_ERROR_NO_SOCKET,   /* socket has been GC'd */\n    PY_SSL_ERROR_INVALID_ERROR_CODE\n};\n\nenum py_ssl_server_or_client {\n    PY_SSL_CLIENT,\n    PY_SSL_SERVER\n};\n\nenum py_ssl_cert_requirements {\n    PY_SSL_CERT_NONE,\n    PY_SSL_CERT_OPTIONAL,\n    PY_SSL_CERT_REQUIRED\n};\n\nenum py_ssl_version {\n    PY_SSL_VERSION_SSL2,\n    PY_SSL_VERSION_SSL3=1,\n    PY_SSL_VERSION_TLS, /* SSLv23 */\n    PY_SSL_VERSION_TLS1,\n    PY_SSL_VERSION_TLS1_1,\n    PY_SSL_VERSION_TLS1_2,\n    PY_SSL_VERSION_TLS_CLIENT=0x10,\n    PY_SSL_VERSION_TLS_SERVER,\n};\n\nenum py_proto_version {\n    PY_PROTO_MINIMUM_SUPPORTED = -2,\n    PY_PROTO_SSLv3 = SSL3_VERSION,\n    PY_PROTO_TLSv1 = TLS1_VERSION,\n    PY_PROTO_TLSv1_1 = TLS1_1_VERSION,\n    PY_PROTO_TLSv1_2 = TLS1_2_VERSION,\n#ifdef TLS1_3_VERSION\n    PY_PROTO_TLSv1_3 = TLS1_3_VERSION,\n#else\n    PY_PROTO_TLSv1_3 = 0x304,\n#endif\n    PY_PROTO_MAXIMUM_SUPPORTED = -1,\n\n/* OpenSSL has no dedicated API to set the minimum version to the maximum\n * available version, and the other way around. We have to figure out the\n * minimum and maximum available version on our own and hope for the best.\n */\n#if defined(SSL3_VERSION) && !defined(OPENSSL_NO_SSL3)\n    PY_PROTO_MINIMUM_AVAILABLE = PY_PROTO_SSLv3,\n#elif defined(TLS1_VERSION) && !defined(OPENSSL_NO_TLS1)\n    PY_PROTO_MINIMUM_AVAILABLE = PY_PROTO_TLSv1,\n#elif defined(TLS1_1_VERSION) && !defined(OPENSSL_NO_TLS1_1)\n    PY_PROTO_MINIMUM_AVAILABLE = PY_PROTO_TLSv1_1,\n#elif defined(TLS1_2_VERSION) && !defined(OPENSSL_NO_TLS1_2)\n    PY_PROTO_MINIMUM_AVAILABLE = PY_PROTO_TLSv1_2,\n#elif defined(TLS1_3_VERSION) && !defined(OPENSSL_NO_TLS1_3)\n    PY_PROTO_MINIMUM_AVAILABLE = PY_PROTO_TLSv1_3,\n#else\n    #error \"PY_PROTO_MINIMUM_AVAILABLE not found\"\n#endif\n\n#if defined(TLS1_3_VERSION) && !defined(OPENSSL_NO_TLS1_3)\n    PY_PROTO_MAXIMUM_AVAILABLE = PY_PROTO_TLSv1_3,\n#elif defined(TLS1_2_VERSION) && !defined(OPENSSL_NO_TLS1_2)\n    PY_PROTO_MAXIMUM_AVAILABLE = PY_PROTO_TLSv1_2,\n#elif defined(TLS1_1_VERSION) && !defined(OPENSSL_NO_TLS1_1)\n    PY_PROTO_MAXIMUM_AVAILABLE = PY_PROTO_TLSv1_1,\n#elif defined(TLS1_VERSION) && !defined(OPENSSL_NO_TLS1)\n    PY_PROTO_MAXIMUM_AVAILABLE = PY_PROTO_TLSv1,\n#elif defined(SSL3_VERSION) && !defined(OPENSSL_NO_SSL3)\n    PY_PROTO_MAXIMUM_AVAILABLE = PY_PROTO_SSLv3,\n#else\n    #error \"PY_PROTO_MAXIMUM_AVAILABLE not found\"\n#endif\n};\n\n/* SSL socket object */\n\n#define X509_NAME_MAXLEN 256\n\n\n/* In case of 'tls-unique' it will be 12 bytes for TLS, 36 bytes for\n * older SSL, but let's be safe */\n#define PySSL_CB_MAXLEN 128\n\n\ntypedef struct {\n    PyObject_HEAD\n    SSL_CTX *ctx;\n    unsigned char *alpn_protocols;\n    unsigned int alpn_protocols_len;\n    PyObject *set_sni_cb;\n    int check_hostname;\n    /* OpenSSL has no API to get hostflags from X509_VERIFY_PARAM* struct.\n     * We have to maintain our own copy. OpenSSL's hostflags default to 0.\n     */\n    unsigned int hostflags;\n    int protocol;\n#ifdef TLS1_3_VERSION\n    int post_handshake_auth;\n#endif\n    PyObject *msg_cb;\n    PyObject *keylog_filename;\n    BIO *keylog_bio;\n    /* Cached module state, also used in SSLSocket and SSLSession code. */\n    _sslmodulestate *state;\n#ifndef OPENSSL_NO_PSK\n    PyObject *psk_client_callback;\n    PyObject *psk_server_callback;\n#endif\n} PySSLContext;\n\ntypedef struct {\n    int ssl; /* last seen error from SSL */\n    int c; /* last seen error from libc */\n#ifdef MS_WINDOWS\n    int ws; /* last seen error from winsock */\n#endif\n} _PySSLError;\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *Socket; /* weakref to socket on which we're layered */\n    SSL *ssl;\n    PySSLContext *ctx; /* weakref to SSL context */\n    char shutdown_seen_zero;\n    enum py_ssl_server_or_client socket_type;\n    PyObject *owner; /* Python level \"owner\" passed to servername callback */\n    PyObject *server_hostname;\n    _PySSLError err; /* last seen error from various sources */\n    /* Some SSL callbacks don't have error reporting. Callback wrappers\n     * store exception information on the socket. The handshake, read, write,\n     * and shutdown methods check for chained exceptions.\n     */\n    PyObject *exc;\n} PySSLSocket;\n\ntypedef struct {\n    PyObject_HEAD\n    BIO *bio;\n    int eof_written;\n} PySSLMemoryBIO;\n\ntypedef struct {\n    PyObject_HEAD\n    SSL_SESSION *session;\n    PySSLContext *ctx;\n} PySSLSession;\n\nstatic inline _PySSLError _PySSL_errno(int failed, const SSL *ssl, int retcode)\n{\n    _PySSLError err = { 0 };\n    if (failed) {\n#ifdef MS_WINDOWS\n        err.ws = WSAGetLastError();\n        _PySSL_FIX_ERRNO;\n#endif\n        err.c = errno;\n        err.ssl = SSL_get_error(ssl, retcode);\n    }\n    return err;\n}\n\n/*[clinic input]\nmodule _ssl\nclass _ssl._SSLContext \"PySSLContext *\" \"get_state_type(type)->PySSLContext_Type\"\nclass _ssl._SSLSocket \"PySSLSocket *\" \"get_state_type(type)->PySSLSocket_Type\"\nclass _ssl.MemoryBIO \"PySSLMemoryBIO *\" \"get_state_type(type)->PySSLMemoryBIO_Type\"\nclass _ssl.SSLSession \"PySSLSession *\" \"get_state_type(type)->PySSLSession_Type\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=d293bed8bae240fd]*/\n\n#include \"clinic/_ssl.c.h\"\n\nstatic int PySSL_select(PySocketSockObject *s, int writing, PyTime_t timeout);\n\nstatic int PySSL_set_owner(PySSLSocket *, PyObject *, void *);\nstatic int PySSL_set_session(PySSLSocket *, PyObject *, void *);\n\ntypedef enum {\n    SOCKET_IS_NONBLOCKING,\n    SOCKET_IS_BLOCKING,\n    SOCKET_HAS_TIMED_OUT,\n    SOCKET_HAS_BEEN_CLOSED,\n    SOCKET_TOO_LARGE_FOR_SELECT,\n    SOCKET_OPERATION_OK\n} timeout_state;\n\n/* Wrap error strings with filename and line # */\n#define ERRSTR1(x,y,z) (x \":\" y \": \" z)\n#define ERRSTR(x) ERRSTR1(\"_ssl.c\", Py_STRINGIFY(__LINE__), x)\n\n// Get the socket from a PySSLSocket, if it has one.\n// Return a borrowed reference.\nstatic inline PySocketSockObject* GET_SOCKET(PySSLSocket *obj) {\n    if (obj->Socket) {\n        PyObject *sock;\n        if (PyWeakref_GetRef(obj->Socket, &sock)) {\n            // GET_SOCKET() returns a borrowed reference\n            Py_DECREF(sock);\n        }\n        else {\n            // dead weak reference\n            sock = Py_None;\n        }\n        return (PySocketSockObject *)sock;  // borrowed reference\n    }\n    else {\n        return NULL;\n    }\n}\n\n/* If sock is NULL, use a timeout of 0 second */\n#define GET_SOCKET_TIMEOUT(sock) \\\n    ((sock != NULL) ? (sock)->sock_timeout : 0)\n\n#include \"_ssl/debughelpers.c\"\n\n/*\n * SSL errors.\n */\n\nPyDoc_STRVAR(SSLError_doc,\n\"An error occurred in the SSL implementation.\");\n\nPyDoc_STRVAR(SSLCertVerificationError_doc,\n\"A certificate could not be verified.\");\n\nPyDoc_STRVAR(SSLZeroReturnError_doc,\n\"SSL/TLS session closed cleanly.\");\n\nPyDoc_STRVAR(SSLWantReadError_doc,\n\"Non-blocking SSL socket needs to read more data\\n\"\n\"before the requested operation can be completed.\");\n\nPyDoc_STRVAR(SSLWantWriteError_doc,\n\"Non-blocking SSL socket needs to write more data\\n\"\n\"before the requested operation can be completed.\");\n\nPyDoc_STRVAR(SSLSyscallError_doc,\n\"System error when attempting SSL operation.\");\n\nPyDoc_STRVAR(SSLEOFError_doc,\n\"SSL/TLS connection terminated abruptly.\");\n\nstatic PyObject *\nSSLError_str(PyOSErrorObject *self)\n{\n    if (self->strerror != NULL && PyUnicode_Check(self->strerror)) {\n        return Py_NewRef(self->strerror);\n    }\n    else\n        return PyObject_Str(self->args);\n}\n\nstatic PyType_Slot sslerror_type_slots[] = {\n    {Py_tp_doc, (void*)SSLError_doc},\n    {Py_tp_str, SSLError_str},\n    {0, 0},\n};\n\nstatic PyType_Spec sslerror_type_spec = {\n    .name = \"ssl.SSLError\",\n    .basicsize = sizeof(PyOSErrorObject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_IMMUTABLETYPE),\n    .slots = sslerror_type_slots\n};\n\nstatic void\nfill_and_set_sslerror(_sslmodulestate *state,\n                      PySSLSocket *sslsock, PyObject *type, int ssl_errno,\n                      const char *errstr, int lineno, unsigned long errcode)\n{\n    PyObject *err_value = NULL, *reason_obj = NULL, *lib_obj = NULL;\n    PyObject *verify_obj = NULL, *verify_code_obj = NULL;\n    PyObject *init_value, *msg, *key;\n\n    if (errcode != 0) {\n        int lib, reason;\n\n        lib = ERR_GET_LIB(errcode);\n        reason = ERR_GET_REASON(errcode);\n        key = Py_BuildValue(\"ii\", lib, reason);\n        if (key == NULL)\n            goto fail;\n        reason_obj = PyDict_GetItemWithError(state->err_codes_to_names, key);\n        Py_DECREF(key);\n        if (reason_obj == NULL && PyErr_Occurred()) {\n            goto fail;\n        }\n        key = PyLong_FromLong(lib);\n        if (key == NULL)\n            goto fail;\n        lib_obj = PyDict_GetItemWithError(state->lib_codes_to_names, key);\n        Py_DECREF(key);\n        if (lib_obj == NULL && PyErr_Occurred()) {\n            goto fail;\n        }\n        if (errstr == NULL)\n            errstr = ERR_reason_error_string(errcode);\n    }\n    if (errstr == NULL)\n        errstr = \"unknown error\";\n\n    /* verify code for cert validation error */\n    if ((sslsock != NULL) && (type == state->PySSLCertVerificationErrorObject)) {\n        const char *verify_str = NULL;\n        long verify_code;\n\n        verify_code = SSL_get_verify_result(sslsock->ssl);\n        verify_code_obj = PyLong_FromLong(verify_code);\n        if (verify_code_obj == NULL) {\n            goto fail;\n        }\n\n        switch (verify_code) {\n        case X509_V_ERR_HOSTNAME_MISMATCH:\n            verify_obj = PyUnicode_FromFormat(\n                \"Hostname mismatch, certificate is not valid for '%S'.\",\n                sslsock->server_hostname\n            );\n            break;\n        case X509_V_ERR_IP_ADDRESS_MISMATCH:\n            verify_obj = PyUnicode_FromFormat(\n                \"IP address mismatch, certificate is not valid for '%S'.\",\n                sslsock->server_hostname\n            );\n            break;\n        default:\n            verify_str = X509_verify_cert_error_string(verify_code);\n            if (verify_str != NULL) {\n                verify_obj = PyUnicode_FromString(verify_str);\n            } else {\n                verify_obj = Py_NewRef(Py_None);\n            }\n            break;\n        }\n        if (verify_obj == NULL) {\n            goto fail;\n        }\n    }\n\n    if (verify_obj && reason_obj && lib_obj)\n        msg = PyUnicode_FromFormat(\"[%S: %S] %s: %S (_ssl.c:%d)\",\n                                   lib_obj, reason_obj, errstr, verify_obj,\n                                   lineno);\n    else if (reason_obj && lib_obj)\n        msg = PyUnicode_FromFormat(\"[%S: %S] %s (_ssl.c:%d)\",\n                                   lib_obj, reason_obj, errstr, lineno);\n    else if (lib_obj)\n        msg = PyUnicode_FromFormat(\"[%S] %s (_ssl.c:%d)\",\n                                   lib_obj, errstr, lineno);\n    else\n        msg = PyUnicode_FromFormat(\"%s (_ssl.c:%d)\", errstr, lineno);\n    if (msg == NULL)\n        goto fail;\n\n    init_value = Py_BuildValue(\"iN\", ERR_GET_REASON(ssl_errno), msg);\n    if (init_value == NULL)\n        goto fail;\n\n    err_value = PyObject_CallObject(type, init_value);\n    Py_DECREF(init_value);\n    if (err_value == NULL)\n        goto fail;\n\n    if (reason_obj == NULL)\n        reason_obj = Py_None;\n    if (PyObject_SetAttr(err_value, state->str_reason, reason_obj))\n        goto fail;\n\n    if (lib_obj == NULL)\n        lib_obj = Py_None;\n    if (PyObject_SetAttr(err_value, state->str_library, lib_obj))\n        goto fail;\n\n    if ((sslsock != NULL) && (type == state->PySSLCertVerificationErrorObject)) {\n        /* Only set verify code / message for SSLCertVerificationError */\n        if (PyObject_SetAttr(err_value, state->str_verify_code,\n                                verify_code_obj))\n            goto fail;\n        if (PyObject_SetAttr(err_value, state->str_verify_message, verify_obj))\n            goto fail;\n    }\n\n    PyErr_SetObject(type, err_value);\nfail:\n    Py_XDECREF(err_value);\n    Py_XDECREF(verify_code_obj);\n    Py_XDECREF(verify_obj);\n}\n\nstatic int\nPySSL_ChainExceptions(PySSLSocket *sslsock) {\n    if (sslsock->exc == NULL)\n        return 0;\n\n    _PyErr_ChainExceptions1(sslsock->exc);\n    sslsock->exc = NULL;\n    return -1;\n}\n\nstatic PyObject *\nPySSL_SetError(PySSLSocket *sslsock, const char *filename, int lineno)\n{\n    PyObject *type;\n    char *errstr = NULL;\n    _PySSLError err;\n    enum py_ssl_error p = PY_SSL_ERROR_NONE;\n    unsigned long e = 0;\n\n    assert(sslsock != NULL);\n\n    _sslmodulestate *state = get_state_sock(sslsock);\n    type = state->PySSLErrorObject;\n\n    e = ERR_peek_last_error();\n\n    if (sslsock->ssl != NULL) {\n        err = sslsock->err;\n\n        switch (err.ssl) {\n        case SSL_ERROR_ZERO_RETURN:\n            errstr = \"TLS/SSL connection has been closed (EOF)\";\n            type = state->PySSLZeroReturnErrorObject;\n            p = PY_SSL_ERROR_ZERO_RETURN;\n            break;\n        case SSL_ERROR_WANT_READ:\n            errstr = \"The operation did not complete (read)\";\n            type = state->PySSLWantReadErrorObject;\n            p = PY_SSL_ERROR_WANT_READ;\n            break;\n        case SSL_ERROR_WANT_WRITE:\n            p = PY_SSL_ERROR_WANT_WRITE;\n            type = state->PySSLWantWriteErrorObject;\n            errstr = \"The operation did not complete (write)\";\n            break;\n        case SSL_ERROR_WANT_X509_LOOKUP:\n            p = PY_SSL_ERROR_WANT_X509_LOOKUP;\n            errstr = \"The operation did not complete (X509 lookup)\";\n            break;\n        case SSL_ERROR_WANT_CONNECT:\n            p = PY_SSL_ERROR_WANT_CONNECT;\n            errstr = \"The operation did not complete (connect)\";\n            break;\n        case SSL_ERROR_SYSCALL:\n        {\n            if (e == 0) {\n                /* underlying BIO reported an I/O error */\n                ERR_clear_error();\n#ifdef MS_WINDOWS\n                if (err.ws) {\n                    return PyErr_SetFromWindowsErr(err.ws);\n                }\n#endif\n                if (err.c) {\n                    errno = err.c;\n                    return PyErr_SetFromErrno(PyExc_OSError);\n                }\n                else {\n                    p = PY_SSL_ERROR_EOF;\n                    type = state->PySSLEOFErrorObject;\n                    errstr = \"EOF occurred in violation of protocol\";\n                }\n            } else {\n                if (ERR_GET_LIB(e) == ERR_LIB_SSL &&\n                        ERR_GET_REASON(e) == SSL_R_CERTIFICATE_VERIFY_FAILED) {\n                    type = state->PySSLCertVerificationErrorObject;\n                }\n                p = PY_SSL_ERROR_SYSCALL;\n            }\n            break;\n        }\n        case SSL_ERROR_SSL:\n        {\n            p = PY_SSL_ERROR_SSL;\n            if (e == 0) {\n                /* possible? */\n                errstr = \"A failure in the SSL library occurred\";\n            }\n            if (ERR_GET_LIB(e) == ERR_LIB_SSL &&\n                    ERR_GET_REASON(e) == SSL_R_CERTIFICATE_VERIFY_FAILED) {\n                type = state->PySSLCertVerificationErrorObject;\n            }\n#if defined(SSL_R_UNEXPECTED_EOF_WHILE_READING)\n            /* OpenSSL 3.0 changed transport EOF from SSL_ERROR_SYSCALL with\n             * zero return value to SSL_ERROR_SSL with a special error code. */\n            if (ERR_GET_LIB(e) == ERR_LIB_SSL &&\n                    ERR_GET_REASON(e) == SSL_R_UNEXPECTED_EOF_WHILE_READING) {\n                p = PY_SSL_ERROR_EOF;\n                type = state->PySSLEOFErrorObject;\n                errstr = \"EOF occurred in violation of protocol\";\n            }\n#endif\n            break;\n        }\n        default:\n            p = PY_SSL_ERROR_INVALID_ERROR_CODE;\n            errstr = \"Invalid error code\";\n        }\n    }\n    fill_and_set_sslerror(state, sslsock, type, p, errstr, lineno, e);\n    ERR_clear_error();\n    PySSL_ChainExceptions(sslsock);\n    return NULL;\n}\n\nstatic PyObject *\n_setSSLError (_sslmodulestate *state, const char *errstr, int errcode, const char *filename, int lineno)\n{\n    if (errstr == NULL)\n        errcode = ERR_peek_last_error();\n    else\n        errcode = 0;\n    fill_and_set_sslerror(state, NULL, state->PySSLErrorObject, errcode, errstr, lineno, errcode);\n    ERR_clear_error();\n    return NULL;\n}\n\nstatic int\n_ssl_deprecated(const char* msg, int stacklevel) {\n    return PyErr_WarnEx(\n        PyExc_DeprecationWarning, msg, stacklevel\n    );\n}\n\n#define PY_SSL_DEPRECATED(name, stacklevel, ret) \\\n    if (_ssl_deprecated((name), (stacklevel)) == -1) return (ret)\n\n/*\n * SSL objects\n */\n\nstatic int\n_ssl_configure_hostname(PySSLSocket *self, const char* server_hostname)\n{\n    int retval = -1;\n    ASN1_OCTET_STRING *ip;\n    PyObject *hostname;\n    size_t len;\n\n    assert(server_hostname);\n\n    /* Disable OpenSSL's special mode with leading dot in hostname:\n     * When name starts with a dot (e.g \".example.com\"), it will be\n     * matched by a certificate valid for any sub-domain of name.\n     */\n    len = strlen(server_hostname);\n    if (len == 0 || *server_hostname == '.') {\n        PyErr_SetString(\n            PyExc_ValueError,\n            \"server_hostname cannot be an empty string or start with a \"\n            \"leading dot.\");\n        return retval;\n    }\n\n    /* inet_pton is not available on all platforms. */\n    ip = a2i_IPADDRESS(server_hostname);\n    if (ip == NULL) {\n        ERR_clear_error();\n    }\n\n    hostname = PyUnicode_Decode(server_hostname, len, \"ascii\", \"strict\");\n    if (hostname == NULL) {\n        goto error;\n    }\n    self->server_hostname = hostname;\n\n    /* Only send SNI extension for non-IP hostnames */\n    if (ip == NULL) {\n        if (!SSL_set_tlsext_host_name(self->ssl, server_hostname)) {\n            _setSSLError(get_state_sock(self), NULL, 0, __FILE__, __LINE__);\n            goto error;\n        }\n    }\n    if (self->ctx->check_hostname) {\n        X509_VERIFY_PARAM *param = SSL_get0_param(self->ssl);\n        if (ip == NULL) {\n            if (!X509_VERIFY_PARAM_set1_host(param, server_hostname,\n                                             strlen(server_hostname))) {\n                _setSSLError(get_state_sock(self), NULL, 0, __FILE__, __LINE__);\n                goto error;\n            }\n        } else {\n            if (!X509_VERIFY_PARAM_set1_ip(param, ASN1_STRING_get0_data(ip),\n                                           ASN1_STRING_length(ip))) {\n                _setSSLError(get_state_sock(self), NULL, 0, __FILE__, __LINE__);\n                goto error;\n            }\n        }\n    }\n    retval = 0;\n  error:\n    if (ip != NULL) {\n        ASN1_OCTET_STRING_free(ip);\n    }\n    return retval;\n}\n\nstatic PySSLSocket *\nnewPySSLSocket(PySSLContext *sslctx, PySocketSockObject *sock,\n               enum py_ssl_server_or_client socket_type,\n               char *server_hostname,\n               PyObject *owner, PyObject *session,\n               PySSLMemoryBIO *inbio, PySSLMemoryBIO *outbio)\n{\n    PySSLSocket *self;\n    SSL_CTX *ctx = sslctx->ctx;\n    _PySSLError err = { 0 };\n\n    if ((socket_type == PY_SSL_SERVER) &&\n        (sslctx->protocol == PY_SSL_VERSION_TLS_CLIENT)) {\n        _setSSLError(get_state_ctx(sslctx),\n                     \"Cannot create a server socket with a \"\n                     \"PROTOCOL_TLS_CLIENT context\", 0, __FILE__, __LINE__);\n        return NULL;\n    }\n    if ((socket_type == PY_SSL_CLIENT) &&\n        (sslctx->protocol == PY_SSL_VERSION_TLS_SERVER)) {\n        _setSSLError(get_state_ctx(sslctx),\n                     \"Cannot create a client socket with a \"\n                     \"PROTOCOL_TLS_SERVER context\", 0, __FILE__, __LINE__);\n        return NULL;\n    }\n\n    self = PyObject_GC_New(PySSLSocket,\n                           get_state_ctx(sslctx)->PySSLSocket_Type);\n    if (self == NULL)\n        return NULL;\n\n    self->ssl = NULL;\n    self->Socket = NULL;\n    self->ctx = (PySSLContext*)Py_NewRef(sslctx);\n    self->shutdown_seen_zero = 0;\n    self->owner = NULL;\n    self->server_hostname = NULL;\n    self->err = err;\n    self->exc = NULL;\n\n    /* Make sure the SSL error state is initialized */\n    ERR_clear_error();\n\n    PySSL_BEGIN_ALLOW_THREADS\n    self->ssl = SSL_new(ctx);\n    PySSL_END_ALLOW_THREADS\n    if (self->ssl == NULL) {\n        Py_DECREF(self);\n        _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n        return NULL;\n    }\n\n    if (socket_type == PY_SSL_SERVER) {\n#define SID_CTX \"Python\"\n        /* Set the session id context (server-side only) */\n        SSL_set_session_id_context(self->ssl, (const unsigned char *) SID_CTX,\n                                   sizeof(SID_CTX));\n#undef SID_CTX\n    }\n\n    /* bpo43522 and OpenSSL < 1.1.1l: copy hostflags manually */\n#if OPENSSL_VERSION < 0x101010cf\n    X509_VERIFY_PARAM *ssl_params = SSL_get0_param(self->ssl);\n    X509_VERIFY_PARAM_set_hostflags(ssl_params, sslctx->hostflags);\n#endif\n    SSL_set_app_data(self->ssl, self);\n    if (sock) {\n        SSL_set_fd(self->ssl, Py_SAFE_DOWNCAST(sock->sock_fd, SOCKET_T, int));\n    } else {\n        /* BIOs are reference counted and SSL_set_bio borrows our reference.\n         * To prevent a double free in memory_bio_dealloc() we need to take an\n         * extra reference here. */\n        BIO_up_ref(inbio->bio);\n        BIO_up_ref(outbio->bio);\n        SSL_set_bio(self->ssl, inbio->bio, outbio->bio);\n    }\n    SSL_set_mode(self->ssl,\n                 SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER | SSL_MODE_AUTO_RETRY);\n\n#ifdef TLS1_3_VERSION\n    if (sslctx->post_handshake_auth == 1) {\n        if (socket_type == PY_SSL_SERVER) {\n            /* bpo-37428: OpenSSL does not ignore SSL_VERIFY_POST_HANDSHAKE.\n             * Set SSL_VERIFY_POST_HANDSHAKE flag only for server sockets and\n             * only in combination with SSL_VERIFY_PEER flag. */\n            int mode = SSL_get_verify_mode(self->ssl);\n            if (mode & SSL_VERIFY_PEER) {\n                mode |= SSL_VERIFY_POST_HANDSHAKE;\n                SSL_set_verify(self->ssl, mode, NULL);\n            }\n        } else {\n            /* client socket */\n            SSL_set_post_handshake_auth(self->ssl, 1);\n        }\n    }\n#endif\n\n    if (server_hostname != NULL) {\n        if (_ssl_configure_hostname(self, server_hostname) < 0) {\n            Py_DECREF(self);\n            return NULL;\n        }\n    }\n    /* If the socket is in non-blocking mode or timeout mode, set the BIO\n     * to non-blocking mode (blocking is the default)\n     */\n    if (sock && sock->sock_timeout >= 0) {\n        BIO_set_nbio(SSL_get_rbio(self->ssl), 1);\n        BIO_set_nbio(SSL_get_wbio(self->ssl), 1);\n    }\n\n    PySSL_BEGIN_ALLOW_THREADS\n    if (socket_type == PY_SSL_CLIENT)\n        SSL_set_connect_state(self->ssl);\n    else\n        SSL_set_accept_state(self->ssl);\n    PySSL_END_ALLOW_THREADS\n\n    self->socket_type = socket_type;\n    if (sock != NULL) {\n        self->Socket = PyWeakref_NewRef((PyObject *) sock, NULL);\n        if (self->Socket == NULL) {\n            Py_DECREF(self);\n            return NULL;\n        }\n    }\n    if (owner && owner != Py_None) {\n        if (PySSL_set_owner(self, owner, NULL) == -1) {\n            Py_DECREF(self);\n            return NULL;\n        }\n    }\n    if (session && session != Py_None) {\n        if (PySSL_set_session(self, session, NULL) == -1) {\n            Py_DECREF(self);\n            return NULL;\n        }\n    }\n\n    PyObject_GC_Track(self);\n    return self;\n}\n\n/* SSL object methods */\n\n/*[clinic input]\n_ssl._SSLSocket.do_handshake\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_do_handshake_impl(PySSLSocket *self)\n/*[clinic end generated code: output=6c0898a8936548f6 input=d2d737de3df018c8]*/\n{\n    int ret;\n    _PySSLError err;\n    int sockstate, nonblocking;\n    PySocketSockObject *sock = GET_SOCKET(self);\n    PyTime_t timeout, deadline = 0;\n    int has_timeout;\n\n    if (sock) {\n        if (((PyObject*)sock) == Py_None) {\n            _setSSLError(get_state_sock(self),\n                         \"Underlying socket connection gone\",\n                         PY_SSL_ERROR_NO_SOCKET, __FILE__, __LINE__);\n            return NULL;\n        }\n        Py_INCREF(sock);\n\n        /* just in case the blocking state of the socket has been changed */\n        nonblocking = (sock->sock_timeout >= 0);\n        BIO_set_nbio(SSL_get_rbio(self->ssl), nonblocking);\n        BIO_set_nbio(SSL_get_wbio(self->ssl), nonblocking);\n    }\n\n    timeout = GET_SOCKET_TIMEOUT(sock);\n    has_timeout = (timeout > 0);\n    if (has_timeout) {\n        deadline = _PyDeadline_Init(timeout);\n    }\n\n    /* Actually negotiate SSL connection */\n    /* XXX If SSL_do_handshake() returns 0, it's also a failure. */\n    do {\n        PySSL_BEGIN_ALLOW_THREADS\n        ret = SSL_do_handshake(self->ssl);\n        err = _PySSL_errno(ret < 1, self->ssl, ret);\n        PySSL_END_ALLOW_THREADS\n        self->err = err;\n\n        if (PyErr_CheckSignals())\n            goto error;\n\n        if (has_timeout)\n            timeout = _PyDeadline_Get(deadline);\n\n        if (err.ssl == SSL_ERROR_WANT_READ) {\n            sockstate = PySSL_select(sock, 0, timeout);\n        } else if (err.ssl == SSL_ERROR_WANT_WRITE) {\n            sockstate = PySSL_select(sock, 1, timeout);\n        } else {\n            sockstate = SOCKET_OPERATION_OK;\n        }\n\n        if (sockstate == SOCKET_HAS_TIMED_OUT) {\n            PyErr_SetString(PyExc_TimeoutError,\n                            ERRSTR(\"The handshake operation timed out\"));\n            goto error;\n        } else if (sockstate == SOCKET_HAS_BEEN_CLOSED) {\n            PyErr_SetString(get_state_sock(self)->PySSLErrorObject,\n                            ERRSTR(\"Underlying socket has been closed.\"));\n            goto error;\n        } else if (sockstate == SOCKET_TOO_LARGE_FOR_SELECT) {\n            PyErr_SetString(get_state_sock(self)->PySSLErrorObject,\n                            ERRSTR(\"Underlying socket too large for select().\"));\n            goto error;\n        } else if (sockstate == SOCKET_IS_NONBLOCKING) {\n            break;\n        }\n    } while (err.ssl == SSL_ERROR_WANT_READ ||\n             err.ssl == SSL_ERROR_WANT_WRITE);\n    Py_XDECREF(sock);\n    if (ret < 1)\n        return PySSL_SetError(self, __FILE__, __LINE__);\n    if (PySSL_ChainExceptions(self) < 0)\n        return NULL;\n    Py_RETURN_NONE;\nerror:\n    Py_XDECREF(sock);\n    PySSL_ChainExceptions(self);\n    return NULL;\n}\n\nstatic PyObject *\n_asn1obj2py(_sslmodulestate *state, const ASN1_OBJECT *name, int no_name)\n{\n    char buf[X509_NAME_MAXLEN];\n    char *namebuf = buf;\n    int buflen;\n    PyObject *name_obj = NULL;\n\n    buflen = OBJ_obj2txt(namebuf, X509_NAME_MAXLEN, name, no_name);\n    if (buflen < 0) {\n        _setSSLError(state, NULL, 0, __FILE__, __LINE__);\n        return NULL;\n    }\n    /* initial buffer is too small for oid + terminating null byte */\n    if (buflen > X509_NAME_MAXLEN - 1) {\n        /* make OBJ_obj2txt() calculate the required buflen */\n        buflen = OBJ_obj2txt(NULL, 0, name, no_name);\n        /* allocate len + 1 for terminating NULL byte */\n        namebuf = PyMem_Malloc(buflen + 1);\n        if (namebuf == NULL) {\n            PyErr_NoMemory();\n            return NULL;\n        }\n        buflen = OBJ_obj2txt(namebuf, buflen + 1, name, no_name);\n        if (buflen < 0) {\n            _setSSLError(state, NULL, 0, __FILE__, __LINE__);\n            goto done;\n        }\n    }\n    if (!buflen && no_name) {\n        name_obj = Py_NewRef(Py_None);\n    }\n    else {\n        name_obj = PyUnicode_FromStringAndSize(namebuf, buflen);\n    }\n\n  done:\n    if (buf != namebuf) {\n        PyMem_Free(namebuf);\n    }\n    return name_obj;\n}\n\nstatic PyObject *\n_create_tuple_for_attribute(_sslmodulestate *state,\n                            ASN1_OBJECT *name, ASN1_STRING *value)\n{\n    Py_ssize_t buflen;\n    PyObject *pyattr;\n    PyObject *pyname = _asn1obj2py(state, name, 0);\n\n    if (pyname == NULL) {\n        _setSSLError(state, NULL, 0, __FILE__, __LINE__);\n        return NULL;\n    }\n\n    if (ASN1_STRING_type(value) == V_ASN1_BIT_STRING) {\n        buflen = ASN1_STRING_length(value);\n        pyattr = Py_BuildValue(\"Ny#\", pyname, ASN1_STRING_get0_data(value), buflen);\n    } else {\n        unsigned char *valuebuf = NULL;\n        buflen = ASN1_STRING_to_UTF8(&valuebuf, value);\n        if (buflen < 0) {\n            _setSSLError(state, NULL, 0, __FILE__, __LINE__);\n            Py_DECREF(pyname);\n            return NULL;\n        }\n        pyattr = Py_BuildValue(\"Ns#\", pyname, valuebuf, buflen);\n        OPENSSL_free(valuebuf);\n    }\n    return pyattr;\n}\n\nstatic PyObject *\n_create_tuple_for_X509_NAME (_sslmodulestate *state, X509_NAME *xname)\n{\n    PyObject *dn = NULL;    /* tuple which represents the \"distinguished name\" */\n    PyObject *rdn = NULL;   /* tuple to hold a \"relative distinguished name\" */\n    PyObject *rdnt;\n    PyObject *attr = NULL;   /* tuple to hold an attribute */\n    int entry_count = X509_NAME_entry_count(xname);\n    X509_NAME_ENTRY *entry;\n    ASN1_OBJECT *name;\n    ASN1_STRING *value;\n    int index_counter;\n    int rdn_level = -1;\n    int retcode;\n\n    dn = PyList_New(0);\n    if (dn == NULL)\n        return NULL;\n    /* now create another tuple to hold the top-level RDN */\n    rdn = PyList_New(0);\n    if (rdn == NULL)\n        goto fail0;\n\n    for (index_counter = 0;\n         index_counter < entry_count;\n         index_counter++)\n    {\n        entry = X509_NAME_get_entry(xname, index_counter);\n\n        /* check to see if we've gotten to a new RDN */\n        if (rdn_level >= 0) {\n            if (rdn_level != X509_NAME_ENTRY_set(entry)) {\n                /* yes, new RDN */\n                /* add old RDN to DN */\n                rdnt = PyList_AsTuple(rdn);\n                Py_DECREF(rdn);\n                if (rdnt == NULL)\n                    goto fail0;\n                retcode = PyList_Append(dn, rdnt);\n                Py_DECREF(rdnt);\n                if (retcode < 0)\n                    goto fail0;\n                /* create new RDN */\n                rdn = PyList_New(0);\n                if (rdn == NULL)\n                    goto fail0;\n            }\n        }\n        rdn_level = X509_NAME_ENTRY_set(entry);\n\n        /* now add this attribute to the current RDN */\n        name = X509_NAME_ENTRY_get_object(entry);\n        value = X509_NAME_ENTRY_get_data(entry);\n        attr = _create_tuple_for_attribute(state, name, value);\n        /*\n        fprintf(stderr, \"RDN level %d, attribute %s: %s\\n\",\n            entry->set,\n            PyBytes_AS_STRING(PyTuple_GET_ITEM(attr, 0)),\n            PyBytes_AS_STRING(PyTuple_GET_ITEM(attr, 1)));\n        */\n        if (attr == NULL)\n            goto fail1;\n        retcode = PyList_Append(rdn, attr);\n        Py_DECREF(attr);\n        if (retcode < 0)\n            goto fail1;\n    }\n    /* now, there's typically a dangling RDN */\n    if (rdn != NULL) {\n        if (PyList_GET_SIZE(rdn) > 0) {\n            rdnt = PyList_AsTuple(rdn);\n            Py_DECREF(rdn);\n            if (rdnt == NULL)\n                goto fail0;\n            retcode = PyList_Append(dn, rdnt);\n            Py_DECREF(rdnt);\n            if (retcode < 0)\n                goto fail0;\n        }\n        else {\n            Py_DECREF(rdn);\n        }\n    }\n\n    /* convert list to tuple */\n    rdnt = PyList_AsTuple(dn);\n    Py_DECREF(dn);\n    if (rdnt == NULL)\n        return NULL;\n    return rdnt;\n\n  fail1:\n    Py_XDECREF(rdn);\n\n  fail0:\n    Py_XDECREF(dn);\n    return NULL;\n}\n\nstatic PyObject *\n_get_peer_alt_names (_sslmodulestate *state, X509 *certificate) {\n\n    /* this code follows the procedure outlined in\n       OpenSSL's crypto/x509v3/v3_prn.c:X509v3_EXT_print()\n       function to extract the STACK_OF(GENERAL_NAME),\n       then iterates through the stack to add the\n       names. */\n\n    int j;\n    PyObject *peer_alt_names = Py_None;\n    PyObject *v = NULL, *t;\n    GENERAL_NAMES *names = NULL;\n    GENERAL_NAME *name;\n    BIO *biobuf = NULL;\n    char buf[2048];\n    char *vptr;\n    int len;\n\n    if (certificate == NULL)\n        return peer_alt_names;\n\n    /* get a memory buffer */\n    biobuf = BIO_new(BIO_s_mem());\n    if (biobuf == NULL) {\n        PyErr_SetString(state->PySSLErrorObject, \"failed to allocate BIO\");\n        return NULL;\n    }\n\n    names = (GENERAL_NAMES *)X509_get_ext_d2i(\n        certificate, NID_subject_alt_name, NULL, NULL);\n    if (names != NULL) {\n        if (peer_alt_names == Py_None) {\n            peer_alt_names = PyList_New(0);\n            if (peer_alt_names == NULL)\n                goto fail;\n        }\n\n        for(j = 0; j < sk_GENERAL_NAME_num(names); j++) {\n            /* get a rendering of each name in the set of names */\n            int gntype;\n            ASN1_STRING *as = NULL;\n\n            name = sk_GENERAL_NAME_value(names, j);\n            gntype = name->type;\n            switch (gntype) {\n            case GEN_DIRNAME:\n                /* we special-case DirName as a tuple of\n                   tuples of attributes */\n\n                t = PyTuple_New(2);\n                if (t == NULL) {\n                    goto fail;\n                }\n\n                v = PyUnicode_FromString(\"DirName\");\n                if (v == NULL) {\n                    Py_DECREF(t);\n                    goto fail;\n                }\n                PyTuple_SET_ITEM(t, 0, v);\n\n                v = _create_tuple_for_X509_NAME(state, name->d.dirn);\n                if (v == NULL) {\n                    Py_DECREF(t);\n                    goto fail;\n                }\n                PyTuple_SET_ITEM(t, 1, v);\n                break;\n\n            case GEN_EMAIL:\n            case GEN_DNS:\n            case GEN_URI:\n                /* GENERAL_NAME_print() doesn't handle NULL bytes in ASN1_string\n                   correctly, CVE-2013-4238 */\n                t = PyTuple_New(2);\n                if (t == NULL)\n                    goto fail;\n                switch (gntype) {\n                case GEN_EMAIL:\n                    v = PyUnicode_FromString(\"email\");\n                    as = name->d.rfc822Name;\n                    break;\n                case GEN_DNS:\n                    v = PyUnicode_FromString(\"DNS\");\n                    as = name->d.dNSName;\n                    break;\n                case GEN_URI:\n                    v = PyUnicode_FromString(\"URI\");\n                    as = name->d.uniformResourceIdentifier;\n                    break;\n                }\n                if (v == NULL) {\n                    Py_DECREF(t);\n                    goto fail;\n                }\n                PyTuple_SET_ITEM(t, 0, v);\n                v = PyUnicode_FromStringAndSize((char *)ASN1_STRING_get0_data(as),\n                                                ASN1_STRING_length(as));\n                if (v == NULL) {\n                    Py_DECREF(t);\n                    goto fail;\n                }\n                PyTuple_SET_ITEM(t, 1, v);\n                break;\n\n            case GEN_RID:\n                t = PyTuple_New(2);\n                if (t == NULL)\n                    goto fail;\n\n                v = PyUnicode_FromString(\"Registered ID\");\n                if (v == NULL) {\n                    Py_DECREF(t);\n                    goto fail;\n                }\n                PyTuple_SET_ITEM(t, 0, v);\n\n                len = i2t_ASN1_OBJECT(buf, sizeof(buf)-1, name->d.rid);\n                if (len < 0) {\n                    Py_DECREF(t);\n                    _setSSLError(state, NULL, 0, __FILE__, __LINE__);\n                    goto fail;\n                } else if (len >= (int)sizeof(buf)) {\n                    v = PyUnicode_FromString(\"<INVALID>\");\n                } else {\n                    v = PyUnicode_FromStringAndSize(buf, len);\n                }\n                if (v == NULL) {\n                    Py_DECREF(t);\n                    goto fail;\n                }\n                PyTuple_SET_ITEM(t, 1, v);\n                break;\n\n            case GEN_IPADD:\n                /* OpenSSL < 3.0.0 adds a trailing \\n to IPv6. 3.0.0 removed\n                 * the trailing newline. Remove it in all versions\n                 */\n                t = PyTuple_New(2);\n                if (t == NULL)\n                    goto fail;\n\n                v = PyUnicode_FromString(\"IP Address\");\n                if (v == NULL) {\n                    Py_DECREF(t);\n                    goto fail;\n                }\n                PyTuple_SET_ITEM(t, 0, v);\n\n                if (name->d.ip->length == 4) {\n                    unsigned char *p = name->d.ip->data;\n                    v = PyUnicode_FromFormat(\n                        \"%d.%d.%d.%d\",\n                        p[0], p[1], p[2], p[3]\n                    );\n                } else if (name->d.ip->length == 16) {\n                    unsigned char *p = name->d.ip->data;\n                    v = PyUnicode_FromFormat(\n                        \"%X:%X:%X:%X:%X:%X:%X:%X\",\n                        p[0] << 8 | p[1],\n                        p[2] << 8 | p[3],\n                        p[4] << 8 | p[5],\n                        p[6] << 8 | p[7],\n                        p[8] << 8 | p[9],\n                        p[10] << 8 | p[11],\n                        p[12] << 8 | p[13],\n                        p[14] << 8 | p[15]\n                    );\n                } else {\n                    v = PyUnicode_FromString(\"<invalid>\");\n                }\n\n                if (v == NULL) {\n                    Py_DECREF(t);\n                    goto fail;\n                }\n                PyTuple_SET_ITEM(t, 1, v);\n                break;\n\n            default:\n                /* for everything else, we use the OpenSSL print form */\n                switch (gntype) {\n                    /* check for new general name type */\n                    case GEN_OTHERNAME:\n                    case GEN_X400:\n                    case GEN_EDIPARTY:\n                    case GEN_RID:\n                        break;\n                    default:\n                        if (PyErr_WarnFormat(PyExc_RuntimeWarning, 1,\n                                             \"Unknown general name type %d\",\n                                             gntype) == -1) {\n                            goto fail;\n                        }\n                        break;\n                }\n                (void) BIO_reset(biobuf);\n                GENERAL_NAME_print(biobuf, name);\n                len = BIO_gets(biobuf, buf, sizeof(buf)-1);\n                if (len < 0) {\n                    _setSSLError(state, NULL, 0, __FILE__, __LINE__);\n                    goto fail;\n                }\n                vptr = strchr(buf, ':');\n                if (vptr == NULL) {\n                    PyErr_Format(PyExc_ValueError,\n                                 \"Invalid value %.200s\",\n                                 buf);\n                    goto fail;\n                }\n                t = PyTuple_New(2);\n                if (t == NULL)\n                    goto fail;\n                v = PyUnicode_FromStringAndSize(buf, (vptr - buf));\n                if (v == NULL) {\n                    Py_DECREF(t);\n                    goto fail;\n                }\n                PyTuple_SET_ITEM(t, 0, v);\n                v = PyUnicode_FromStringAndSize((vptr + 1),\n                                                (len - (vptr - buf + 1)));\n                if (v == NULL) {\n                    Py_DECREF(t);\n                    goto fail;\n                }\n                PyTuple_SET_ITEM(t, 1, v);\n                break;\n            }\n\n            /* and add that rendering to the list */\n\n            if (PyList_Append(peer_alt_names, t) < 0) {\n                Py_DECREF(t);\n                goto fail;\n            }\n            Py_DECREF(t);\n        }\n        sk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);\n    }\n    BIO_free(biobuf);\n    if (peer_alt_names != Py_None) {\n        v = PyList_AsTuple(peer_alt_names);\n        Py_DECREF(peer_alt_names);\n        return v;\n    } else {\n        return peer_alt_names;\n    }\n\n\n  fail:\n    if (biobuf != NULL)\n        BIO_free(biobuf);\n\n    if (peer_alt_names != Py_None) {\n        Py_XDECREF(peer_alt_names);\n    }\n\n    return NULL;\n}\n\nstatic PyObject *\n_get_aia_uri(X509 *certificate, int nid) {\n    PyObject *lst = NULL, *ostr = NULL;\n    int i, result;\n    AUTHORITY_INFO_ACCESS *info;\n\n    info = X509_get_ext_d2i(certificate, NID_info_access, NULL, NULL);\n    if (info == NULL)\n        return Py_None;\n    if (sk_ACCESS_DESCRIPTION_num(info) == 0) {\n        AUTHORITY_INFO_ACCESS_free(info);\n        return Py_None;\n    }\n\n    if ((lst = PyList_New(0)) == NULL) {\n        goto fail;\n    }\n\n    for (i = 0; i < sk_ACCESS_DESCRIPTION_num(info); i++) {\n        ACCESS_DESCRIPTION *ad = sk_ACCESS_DESCRIPTION_value(info, i);\n        ASN1_IA5STRING *uri;\n\n        if ((OBJ_obj2nid(ad->method) != nid) ||\n                (ad->location->type != GEN_URI)) {\n            continue;\n        }\n        uri = ad->location->d.uniformResourceIdentifier;\n        ostr = PyUnicode_FromStringAndSize((char *)uri->data,\n                                           uri->length);\n        if (ostr == NULL) {\n            goto fail;\n        }\n        result = PyList_Append(lst, ostr);\n        Py_DECREF(ostr);\n        if (result < 0) {\n            goto fail;\n        }\n    }\n    AUTHORITY_INFO_ACCESS_free(info);\n\n    /* convert to tuple or None */\n    if (PyList_Size(lst) == 0) {\n        Py_DECREF(lst);\n        return Py_None;\n    } else {\n        PyObject *tup;\n        tup = PyList_AsTuple(lst);\n        Py_DECREF(lst);\n        return tup;\n    }\n\n  fail:\n    AUTHORITY_INFO_ACCESS_free(info);\n    Py_XDECREF(lst);\n    return NULL;\n}\n\nstatic PyObject *\n_get_crl_dp(X509 *certificate) {\n    STACK_OF(DIST_POINT) *dps;\n    int i, j;\n    PyObject *lst, *res = NULL;\n\n    dps = X509_get_ext_d2i(certificate, NID_crl_distribution_points, NULL, NULL);\n\n    if (dps == NULL)\n        return Py_None;\n\n    lst = PyList_New(0);\n    if (lst == NULL)\n        goto done;\n\n    for (i=0; i < sk_DIST_POINT_num(dps); i++) {\n        DIST_POINT *dp;\n        STACK_OF(GENERAL_NAME) *gns;\n\n        dp = sk_DIST_POINT_value(dps, i);\n        if (dp->distpoint == NULL) {\n            /* Ignore empty DP value, CVE-2019-5010 */\n            continue;\n        }\n        gns = dp->distpoint->name.fullname;\n\n        for (j=0; j < sk_GENERAL_NAME_num(gns); j++) {\n            GENERAL_NAME *gn;\n            ASN1_IA5STRING *uri;\n            PyObject *ouri;\n            int err;\n\n            gn = sk_GENERAL_NAME_value(gns, j);\n            if (gn->type != GEN_URI) {\n                continue;\n            }\n            uri = gn->d.uniformResourceIdentifier;\n            ouri = PyUnicode_FromStringAndSize((char *)uri->data,\n                                               uri->length);\n            if (ouri == NULL)\n                goto done;\n\n            err = PyList_Append(lst, ouri);\n            Py_DECREF(ouri);\n            if (err < 0)\n                goto done;\n        }\n    }\n\n    /* Convert to tuple. */\n    res = (PyList_GET_SIZE(lst) > 0) ? PyList_AsTuple(lst) : Py_None;\n\n  done:\n    Py_XDECREF(lst);\n    CRL_DIST_POINTS_free(dps);\n    return res;\n}\n\nstatic PyObject *\n_decode_certificate(_sslmodulestate *state, X509 *certificate) {\n\n    PyObject *retval = NULL;\n    BIO *biobuf = NULL;\n    PyObject *peer;\n    PyObject *peer_alt_names = NULL;\n    PyObject *issuer;\n    PyObject *version;\n    PyObject *sn_obj;\n    PyObject *obj;\n    ASN1_INTEGER *serialNumber;\n    char buf[2048];\n    int len, result;\n    const ASN1_TIME *notBefore, *notAfter;\n    PyObject *pnotBefore, *pnotAfter;\n\n    retval = PyDict_New();\n    if (retval == NULL)\n        return NULL;\n\n    peer = _create_tuple_for_X509_NAME(\n        state,\n        X509_get_subject_name(certificate));\n    if (peer == NULL)\n        goto fail0;\n    if (PyDict_SetItemString(retval, (const char *) \"subject\", peer) < 0) {\n        Py_DECREF(peer);\n        goto fail0;\n    }\n    Py_DECREF(peer);\n\n    issuer = _create_tuple_for_X509_NAME(\n        state,\n        X509_get_issuer_name(certificate));\n    if (issuer == NULL)\n        goto fail0;\n    if (PyDict_SetItemString(retval, (const char *)\"issuer\", issuer) < 0) {\n        Py_DECREF(issuer);\n        goto fail0;\n    }\n    Py_DECREF(issuer);\n\n    version = PyLong_FromLong(X509_get_version(certificate) + 1);\n    if (version == NULL)\n        goto fail0;\n    if (PyDict_SetItemString(retval, \"version\", version) < 0) {\n        Py_DECREF(version);\n        goto fail0;\n    }\n    Py_DECREF(version);\n\n    /* get a memory buffer */\n    biobuf = BIO_new(BIO_s_mem());\n    if (biobuf == NULL) {\n        PyErr_SetString(state->PySSLErrorObject, \"failed to allocate BIO\");\n        goto fail0;\n    }\n\n    (void) BIO_reset(biobuf);\n    serialNumber = X509_get_serialNumber(certificate);\n    /* should not exceed 20 octets, 160 bits, so buf is big enough */\n    i2a_ASN1_INTEGER(biobuf, serialNumber);\n    len = BIO_gets(biobuf, buf, sizeof(buf)-1);\n    if (len < 0) {\n        _setSSLError(state, NULL, 0, __FILE__, __LINE__);\n        goto fail1;\n    }\n    sn_obj = PyUnicode_FromStringAndSize(buf, len);\n    if (sn_obj == NULL)\n        goto fail1;\n    if (PyDict_SetItemString(retval, \"serialNumber\", sn_obj) < 0) {\n        Py_DECREF(sn_obj);\n        goto fail1;\n    }\n    Py_DECREF(sn_obj);\n\n    (void) BIO_reset(biobuf);\n    notBefore = X509_get0_notBefore(certificate);\n    ASN1_TIME_print(biobuf, notBefore);\n    len = BIO_gets(biobuf, buf, sizeof(buf)-1);\n    if (len < 0) {\n        _setSSLError(state, NULL, 0, __FILE__, __LINE__);\n        goto fail1;\n    }\n    pnotBefore = PyUnicode_FromStringAndSize(buf, len);\n    if (pnotBefore == NULL)\n        goto fail1;\n    if (PyDict_SetItemString(retval, \"notBefore\", pnotBefore) < 0) {\n        Py_DECREF(pnotBefore);\n        goto fail1;\n    }\n    Py_DECREF(pnotBefore);\n\n    (void) BIO_reset(biobuf);\n    notAfter = X509_get0_notAfter(certificate);\n    ASN1_TIME_print(biobuf, notAfter);\n    len = BIO_gets(biobuf, buf, sizeof(buf)-1);\n    if (len < 0) {\n        _setSSLError(state, NULL, 0, __FILE__, __LINE__);\n        goto fail1;\n    }\n    pnotAfter = PyUnicode_FromStringAndSize(buf, len);\n    if (pnotAfter == NULL)\n        goto fail1;\n    if (PyDict_SetItemString(retval, \"notAfter\", pnotAfter) < 0) {\n        Py_DECREF(pnotAfter);\n        goto fail1;\n    }\n    Py_DECREF(pnotAfter);\n\n    /* Now look for subjectAltName */\n\n    peer_alt_names = _get_peer_alt_names(state, certificate);\n    if (peer_alt_names == NULL)\n        goto fail1;\n    else if (peer_alt_names != Py_None) {\n        if (PyDict_SetItemString(retval, \"subjectAltName\",\n                                 peer_alt_names) < 0) {\n            Py_DECREF(peer_alt_names);\n            goto fail1;\n        }\n        Py_DECREF(peer_alt_names);\n    }\n\n    /* Authority Information Access: OCSP URIs */\n    obj = _get_aia_uri(certificate, NID_ad_OCSP);\n    if (obj == NULL) {\n        goto fail1;\n    } else if (obj != Py_None) {\n        result = PyDict_SetItemString(retval, \"OCSP\", obj);\n        Py_DECREF(obj);\n        if (result < 0) {\n            goto fail1;\n        }\n    }\n\n    obj = _get_aia_uri(certificate, NID_ad_ca_issuers);\n    if (obj == NULL) {\n        goto fail1;\n    } else if (obj != Py_None) {\n        result = PyDict_SetItemString(retval, \"caIssuers\", obj);\n        Py_DECREF(obj);\n        if (result < 0) {\n            goto fail1;\n        }\n    }\n\n    /* CDP (CRL distribution points) */\n    obj = _get_crl_dp(certificate);\n    if (obj == NULL) {\n        goto fail1;\n    } else if (obj != Py_None) {\n        result = PyDict_SetItemString(retval, \"crlDistributionPoints\", obj);\n        Py_DECREF(obj);\n        if (result < 0) {\n            goto fail1;\n        }\n    }\n\n    BIO_free(biobuf);\n    return retval;\n\n  fail1:\n    if (biobuf != NULL)\n        BIO_free(biobuf);\n  fail0:\n    Py_XDECREF(retval);\n    return NULL;\n}\n\nstatic PyObject *\n_certificate_to_der(_sslmodulestate *state, X509 *certificate)\n{\n    unsigned char *bytes_buf = NULL;\n    int len;\n    PyObject *retval;\n\n    bytes_buf = NULL;\n    len = i2d_X509(certificate, &bytes_buf);\n    if (len < 0) {\n        _setSSLError(state, NULL, 0, __FILE__, __LINE__);\n        return NULL;\n    }\n    /* this is actually an immutable bytes sequence */\n    retval = PyBytes_FromStringAndSize((const char *) bytes_buf, len);\n    OPENSSL_free(bytes_buf);\n    return retval;\n}\n\n#include \"_ssl/misc.c\"\n#include \"_ssl/cert.c\"\n\n/*[clinic input]\n_ssl._test_decode_cert\n    path: object(converter=\"PyUnicode_FSConverter\")\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__test_decode_cert_impl(PyObject *module, PyObject *path)\n/*[clinic end generated code: output=96becb9abb23c091 input=cdeaaf02d4346628]*/\n{\n    PyObject *retval = NULL;\n    X509 *x=NULL;\n    BIO *cert;\n    _sslmodulestate *state = get_ssl_state(module);\n\n    if ((cert=BIO_new(BIO_s_file())) == NULL) {\n        PyErr_SetString(state->PySSLErrorObject,\n                        \"Can't malloc memory to read file\");\n        goto fail0;\n    }\n\n    if (BIO_read_filename(cert, PyBytes_AsString(path)) <= 0) {\n        PyErr_SetString(state->PySSLErrorObject,\n                        \"Can't open file\");\n        goto fail0;\n    }\n\n    x = PEM_read_bio_X509(cert, NULL, NULL, NULL);\n    if (x == NULL) {\n        PyErr_SetString(state->PySSLErrorObject,\n                        \"Error decoding PEM-encoded file\");\n        goto fail0;\n    }\n\n    retval = _decode_certificate(state, x);\n    X509_free(x);\n\n  fail0:\n    Py_DECREF(path);\n    if (cert != NULL) BIO_free(cert);\n    return retval;\n}\n\n\n/*[clinic input]\n_ssl._SSLSocket.getpeercert\n    der as binary_mode: bool = False\n    /\n\nReturns the certificate for the peer.\n\nIf no certificate was provided, returns None.  If a certificate was\nprovided, but not validated, returns an empty dictionary.  Otherwise\nreturns a dict containing information about the peer certificate.\n\nIf the optional argument is True, returns a DER-encoded copy of the\npeer certificate, or None if no certificate was provided.  This will\nreturn the certificate even if it wasn't validated.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_getpeercert_impl(PySSLSocket *self, int binary_mode)\n/*[clinic end generated code: output=1f0ab66dfb693c88 input=c0fbe802e57629b7]*/\n{\n    int verification;\n    X509 *peer_cert;\n    PyObject *result;\n\n    if (!SSL_is_init_finished(self->ssl)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"handshake not done yet\");\n        return NULL;\n    }\n    peer_cert = SSL_get_peer_certificate(self->ssl);\n    if (peer_cert == NULL)\n        Py_RETURN_NONE;\n\n    if (binary_mode) {\n        /* return cert in DER-encoded format */\n        result = _certificate_to_der(get_state_sock(self), peer_cert);\n    } else {\n        verification = SSL_CTX_get_verify_mode(SSL_get_SSL_CTX(self->ssl));\n        if ((verification & SSL_VERIFY_PEER) == 0)\n            result = PyDict_New();\n        else\n            result = _decode_certificate(get_state_sock(self), peer_cert);\n    }\n    X509_free(peer_cert);\n    return result;\n}\n\n/*[clinic input]\n_ssl._SSLSocket.get_verified_chain\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_get_verified_chain_impl(PySSLSocket *self)\n/*[clinic end generated code: output=802421163cdc3110 input=5fb0714f77e2bd51]*/\n{\n    /* borrowed reference */\n    STACK_OF(X509) *chain = SSL_get0_verified_chain(self->ssl);\n    if (chain == NULL) {\n        Py_RETURN_NONE;\n    }\n    return _PySSL_CertificateFromX509Stack(self->ctx->state, chain, 1);\n}\n\n/*[clinic input]\n_ssl._SSLSocket.get_unverified_chain\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_get_unverified_chain_impl(PySSLSocket *self)\n/*[clinic end generated code: output=5acdae414e13f913 input=78c33c360c635cb5]*/\n{\n    PyObject *retval;\n    /* borrowed reference */\n    /* TODO: include SSL_get_peer_certificate() for server-side sockets */\n    STACK_OF(X509) *chain = SSL_get_peer_cert_chain(self->ssl);\n    if (chain == NULL) {\n        Py_RETURN_NONE;\n    }\n    retval = _PySSL_CertificateFromX509Stack(self->ctx->state, chain, 1);\n    if (retval == NULL) {\n        return NULL;\n    }\n    /* OpenSSL does not include peer cert for server side connections */\n    if (self->socket_type == PY_SSL_SERVER) {\n        PyObject *peerobj = NULL;\n        X509 *peer = SSL_get_peer_certificate(self->ssl);\n\n        if (peer == NULL) {\n            peerobj = Py_NewRef(Py_None);\n        } else {\n            /* consume X509 reference on success */\n            peerobj = _PySSL_CertificateFromX509(self->ctx->state, peer, 0);\n            if (peerobj == NULL) {\n                X509_free(peer);\n                Py_DECREF(retval);\n                return NULL;\n            }\n        }\n        int res = PyList_Insert(retval, 0, peerobj);\n        Py_DECREF(peerobj);\n        if (res < 0) {\n            Py_DECREF(retval);\n            return NULL;\n        }\n    }\n    return retval;\n}\n\nstatic PyObject *\ncipher_to_tuple(const SSL_CIPHER *cipher)\n{\n    const char *cipher_name, *cipher_protocol;\n    PyObject *v, *retval = PyTuple_New(3);\n    if (retval == NULL)\n        return NULL;\n\n    cipher_name = SSL_CIPHER_get_name(cipher);\n    if (cipher_name == NULL) {\n        PyTuple_SET_ITEM(retval, 0, Py_NewRef(Py_None));\n    } else {\n        v = PyUnicode_FromString(cipher_name);\n        if (v == NULL)\n            goto fail;\n        PyTuple_SET_ITEM(retval, 0, v);\n    }\n\n    cipher_protocol = SSL_CIPHER_get_version(cipher);\n    if (cipher_protocol == NULL) {\n        PyTuple_SET_ITEM(retval, 1, Py_NewRef(Py_None));\n    } else {\n        v = PyUnicode_FromString(cipher_protocol);\n        if (v == NULL)\n            goto fail;\n        PyTuple_SET_ITEM(retval, 1, v);\n    }\n\n    v = PyLong_FromLong(SSL_CIPHER_get_bits(cipher, NULL));\n    if (v == NULL)\n        goto fail;\n    PyTuple_SET_ITEM(retval, 2, v);\n\n    return retval;\n\n  fail:\n    Py_DECREF(retval);\n    return NULL;\n}\n\nstatic PyObject *\ncipher_to_dict(const SSL_CIPHER *cipher)\n{\n    const char *cipher_name, *cipher_protocol;\n\n    unsigned long cipher_id;\n    int alg_bits, strength_bits, len;\n    char buf[512] = {0};\n    int aead, nid;\n    const char *skcipher = NULL, *digest = NULL, *kx = NULL, *auth = NULL;\n\n    /* can be NULL */\n    cipher_name = SSL_CIPHER_get_name(cipher);\n    cipher_protocol = SSL_CIPHER_get_version(cipher);\n    cipher_id = SSL_CIPHER_get_id(cipher);\n    SSL_CIPHER_description(cipher, buf, sizeof(buf) - 1);\n    /* Downcast to avoid a warning. Safe since buf is always 512 bytes */\n    len = (int)strlen(buf);\n    if (len > 1 && buf[len-1] == '\\n')\n        buf[len-1] = '\\0';\n    strength_bits = SSL_CIPHER_get_bits(cipher, &alg_bits);\n\n    aead = SSL_CIPHER_is_aead(cipher);\n    nid = SSL_CIPHER_get_cipher_nid(cipher);\n    skcipher = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;\n    nid = SSL_CIPHER_get_digest_nid(cipher);\n    digest = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;\n    nid = SSL_CIPHER_get_kx_nid(cipher);\n    kx = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;\n    nid = SSL_CIPHER_get_auth_nid(cipher);\n    auth = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;\n\n    return Py_BuildValue(\n        \"{sksssssssisi\"\n        \"sOssssssss\"\n        \"}\",\n        \"id\", cipher_id,\n        \"name\", cipher_name,\n        \"protocol\", cipher_protocol,\n        \"description\", buf,\n        \"strength_bits\", strength_bits,\n        \"alg_bits\", alg_bits\n        ,\"aead\", aead ? Py_True : Py_False,\n        \"symmetric\", skcipher,\n        \"digest\", digest,\n        \"kea\", kx,\n        \"auth\", auth\n       );\n}\n\n/*[clinic input]\n_ssl._SSLSocket.shared_ciphers\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_shared_ciphers_impl(PySSLSocket *self)\n/*[clinic end generated code: output=3d174ead2e42c4fd input=0bfe149da8fe6306]*/\n{\n    STACK_OF(SSL_CIPHER) *server_ciphers;\n    STACK_OF(SSL_CIPHER) *client_ciphers;\n    int i, len;\n    PyObject *res;\n    const SSL_CIPHER* cipher;\n\n    /* Rather than use SSL_get_shared_ciphers, we use an equivalent algorithm because:\n\n       1) It returns a colon separated list of strings, in an undefined\n          order, that we would have to post process back into tuples.\n       2) It will return a truncated string with no indication that it has\n          done so, if the buffer is too small.\n     */\n\n    server_ciphers = SSL_get_ciphers(self->ssl);\n    if (!server_ciphers)\n        Py_RETURN_NONE;\n    client_ciphers = SSL_get_client_ciphers(self->ssl);\n    if (!client_ciphers)\n        Py_RETURN_NONE;\n\n    res = PyList_New(sk_SSL_CIPHER_num(server_ciphers));\n    if (!res)\n        return NULL;\n    len = 0;\n    for (i = 0; i < sk_SSL_CIPHER_num(server_ciphers); i++) {\n        cipher = sk_SSL_CIPHER_value(server_ciphers, i);\n        if (sk_SSL_CIPHER_find(client_ciphers, cipher) < 0)\n            continue;\n\n        PyObject *tup = cipher_to_tuple(cipher);\n        if (!tup) {\n            Py_DECREF(res);\n            return NULL;\n        }\n        PyList_SET_ITEM(res, len++, tup);\n    }\n    Py_SET_SIZE(res, len);\n    return res;\n}\n\n/*[clinic input]\n_ssl._SSLSocket.cipher\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_cipher_impl(PySSLSocket *self)\n/*[clinic end generated code: output=376417c16d0e5815 input=548fb0e27243796d]*/\n{\n    const SSL_CIPHER *current;\n\n    if (self->ssl == NULL)\n        Py_RETURN_NONE;\n    current = SSL_get_current_cipher(self->ssl);\n    if (current == NULL)\n        Py_RETURN_NONE;\n    return cipher_to_tuple(current);\n}\n\n/*[clinic input]\n_ssl._SSLSocket.version\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_version_impl(PySSLSocket *self)\n/*[clinic end generated code: output=178aed33193b2cdb input=900186a503436fd6]*/\n{\n    const char *version;\n\n    if (self->ssl == NULL)\n        Py_RETURN_NONE;\n    if (!SSL_is_init_finished(self->ssl)) {\n        /* handshake not finished */\n        Py_RETURN_NONE;\n    }\n    version = SSL_get_version(self->ssl);\n    if (!strcmp(version, \"unknown\"))\n        Py_RETURN_NONE;\n    return PyUnicode_FromString(version);\n}\n\n/*[clinic input]\n_ssl._SSLSocket.selected_alpn_protocol\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_selected_alpn_protocol_impl(PySSLSocket *self)\n/*[clinic end generated code: output=ec33688b303d250f input=442de30e35bc2913]*/\n{\n    const unsigned char *out;\n    unsigned int outlen;\n\n    SSL_get0_alpn_selected(self->ssl, &out, &outlen);\n\n    if (out == NULL)\n        Py_RETURN_NONE;\n    return PyUnicode_FromStringAndSize((char *)out, outlen);\n}\n\n/*[clinic input]\n_ssl._SSLSocket.compression\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_compression_impl(PySSLSocket *self)\n/*[clinic end generated code: output=bd16cb1bb4646ae7 input=5d059d0a2bbc32c8]*/\n{\n#ifdef OPENSSL_NO_COMP\n    Py_RETURN_NONE;\n#else\n    const COMP_METHOD *comp_method;\n    const char *short_name;\n\n    if (self->ssl == NULL)\n        Py_RETURN_NONE;\n    comp_method = SSL_get_current_compression(self->ssl);\n    if (comp_method == NULL || COMP_get_type(comp_method) == NID_undef)\n        Py_RETURN_NONE;\n    short_name = OBJ_nid2sn(COMP_get_type(comp_method));\n    if (short_name == NULL)\n        Py_RETURN_NONE;\n    return PyUnicode_DecodeFSDefault(short_name);\n#endif\n}\n\nstatic PySSLContext *PySSL_get_context(PySSLSocket *self, void *closure) {\n    return (PySSLContext*)Py_NewRef(self->ctx);\n}\n\nstatic int PySSL_set_context(PySSLSocket *self, PyObject *value,\n                                   void *closure) {\n\n    if (PyObject_TypeCheck(value, self->ctx->state->PySSLContext_Type)) {\n        Py_SETREF(self->ctx, (PySSLContext *)Py_NewRef(value));\n        SSL_set_SSL_CTX(self->ssl, self->ctx->ctx);\n        /* Set SSL* internal msg_callback to state of new context's state */\n        SSL_set_msg_callback(\n            self->ssl,\n            self->ctx->msg_cb ? _PySSL_msg_callback : NULL\n        );\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"The value must be a SSLContext\");\n        return -1;\n    }\n\n    return 0;\n}\n\nPyDoc_STRVAR(PySSL_set_context_doc,\n\"_setter_context(ctx)\\n\\\n\\\nThis changes the context associated with the SSLSocket. This is typically\\n\\\nused from within a callback function set by the sni_callback\\n\\\non the SSLContext to change the certificate information associated with the\\n\\\nSSLSocket before the cryptographic exchange handshake messages\\n\");\n\n\nstatic PyObject *\nPySSL_get_server_side(PySSLSocket *self, void *c)\n{\n    return PyBool_FromLong(self->socket_type == PY_SSL_SERVER);\n}\n\nPyDoc_STRVAR(PySSL_get_server_side_doc,\n\"Whether this is a server-side socket.\");\n\nstatic PyObject *\nPySSL_get_server_hostname(PySSLSocket *self, void *c)\n{\n    if (self->server_hostname == NULL)\n        Py_RETURN_NONE;\n    return Py_NewRef(self->server_hostname);\n}\n\nPyDoc_STRVAR(PySSL_get_server_hostname_doc,\n\"The currently set server hostname (for SNI).\");\n\nstatic PyObject *\nPySSL_get_owner(PySSLSocket *self, void *c)\n{\n    if (self->owner == NULL) {\n        Py_RETURN_NONE;\n    }\n    PyObject *owner;\n    if (!PyWeakref_GetRef(self->owner, &owner)) {\n        Py_RETURN_NONE;\n    }\n    return owner;\n}\n\nstatic int\nPySSL_set_owner(PySSLSocket *self, PyObject *value, void *c)\n{\n    Py_XSETREF(self->owner, PyWeakref_NewRef(value, NULL));\n    if (self->owner == NULL)\n        return -1;\n    return 0;\n}\n\nPyDoc_STRVAR(PySSL_get_owner_doc,\n\"The Python-level owner of this object.\\\nPassed as \\\"self\\\" in servername callback.\");\n\nstatic int\nPySSL_traverse(PySSLSocket *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->exc);\n    Py_VISIT(Py_TYPE(self));\n    return 0;\n}\n\nstatic int\nPySSL_clear(PySSLSocket *self)\n{\n    Py_CLEAR(self->exc);\n    return 0;\n}\n\nstatic void\nPySSL_dealloc(PySSLSocket *self)\n{\n    PyTypeObject *tp = Py_TYPE(self);\n    PyObject_GC_UnTrack(self);\n    if (self->ssl) {\n        SSL_free(self->ssl);\n    }\n    Py_XDECREF(self->Socket);\n    Py_XDECREF(self->ctx);\n    Py_XDECREF(self->server_hostname);\n    Py_XDECREF(self->owner);\n    PyObject_GC_Del(self);\n    Py_DECREF(tp);\n}\n\n/* If the socket has a timeout, do a select()/poll() on the socket.\n   The argument writing indicates the direction.\n   Returns one of the possibilities in the timeout_state enum (above).\n */\n\nstatic int\nPySSL_select(PySocketSockObject *s, int writing, PyTime_t timeout)\n{\n    int rc;\n#ifdef HAVE_POLL\n    struct pollfd pollfd;\n    PyTime_t ms;\n#else\n    int nfds;\n    fd_set fds;\n    struct timeval tv;\n#endif\n\n    /* Nothing to do unless we're in timeout mode (not non-blocking) */\n    if ((s == NULL) || (timeout == 0))\n        return SOCKET_IS_NONBLOCKING;\n    else if (timeout < 0) {\n        if (s->sock_timeout > 0)\n            return SOCKET_HAS_TIMED_OUT;\n        else\n            return SOCKET_IS_BLOCKING;\n    }\n\n    /* Guard against closed socket */\n    if (s->sock_fd == INVALID_SOCKET)\n        return SOCKET_HAS_BEEN_CLOSED;\n\n    /* Prefer poll, if available, since you can poll() any fd\n     * which can't be done with select(). */\n#ifdef HAVE_POLL\n    pollfd.fd = s->sock_fd;\n    pollfd.events = writing ? POLLOUT : POLLIN;\n\n    /* timeout is in seconds, poll() uses milliseconds */\n    ms = (int)_PyTime_AsMilliseconds(timeout, _PyTime_ROUND_CEILING);\n    assert(ms <= INT_MAX);\n\n    PySSL_BEGIN_ALLOW_THREADS\n    rc = poll(&pollfd, 1, (int)ms);\n    PySSL_END_ALLOW_THREADS\n#else\n    /* Guard against socket too large for select*/\n    if (!_PyIsSelectable_fd(s->sock_fd))\n        return SOCKET_TOO_LARGE_FOR_SELECT;\n\n    _PyTime_AsTimeval_clamp(timeout, &tv, _PyTime_ROUND_CEILING);\n\n    FD_ZERO(&fds);\n    FD_SET(s->sock_fd, &fds);\n\n    /* Wait until the socket becomes ready */\n    PySSL_BEGIN_ALLOW_THREADS\n    nfds = Py_SAFE_DOWNCAST(s->sock_fd+1, SOCKET_T, int);\n    if (writing)\n        rc = select(nfds, NULL, &fds, NULL, &tv);\n    else\n        rc = select(nfds, &fds, NULL, NULL, &tv);\n    PySSL_END_ALLOW_THREADS\n#endif\n\n    /* Return SOCKET_TIMED_OUT on timeout, SOCKET_OPERATION_OK otherwise\n       (when we are able to write or when there's something to read) */\n    return rc == 0 ? SOCKET_HAS_TIMED_OUT : SOCKET_OPERATION_OK;\n}\n\n/*[clinic input]\n_ssl._SSLSocket.write\n    b: Py_buffer\n    /\n\nWrites the bytes-like object b into the SSL object.\n\nReturns the number of bytes written.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_write_impl(PySSLSocket *self, Py_buffer *b)\n/*[clinic end generated code: output=aa7a6be5527358d8 input=77262d994fe5100a]*/\n{\n    size_t count = 0;\n    int retval;\n    int sockstate;\n    _PySSLError err;\n    int nonblocking;\n    PySocketSockObject *sock = GET_SOCKET(self);\n    PyTime_t timeout, deadline = 0;\n    int has_timeout;\n\n    if (sock != NULL) {\n        if (((PyObject*)sock) == Py_None) {\n            _setSSLError(get_state_sock(self),\n                         \"Underlying socket connection gone\",\n                         PY_SSL_ERROR_NO_SOCKET, __FILE__, __LINE__);\n            return NULL;\n        }\n        Py_INCREF(sock);\n    }\n\n    if (sock != NULL) {\n        /* just in case the blocking state of the socket has been changed */\n        nonblocking = (sock->sock_timeout >= 0);\n        BIO_set_nbio(SSL_get_rbio(self->ssl), nonblocking);\n        BIO_set_nbio(SSL_get_wbio(self->ssl), nonblocking);\n    }\n\n    timeout = GET_SOCKET_TIMEOUT(sock);\n    has_timeout = (timeout > 0);\n    if (has_timeout) {\n        deadline = _PyDeadline_Init(timeout);\n    }\n\n    sockstate = PySSL_select(sock, 1, timeout);\n    if (sockstate == SOCKET_HAS_TIMED_OUT) {\n        PyErr_SetString(PyExc_TimeoutError,\n                        \"The write operation timed out\");\n        goto error;\n    } else if (sockstate == SOCKET_HAS_BEEN_CLOSED) {\n        PyErr_SetString(get_state_sock(self)->PySSLErrorObject,\n                        \"Underlying socket has been closed.\");\n        goto error;\n    } else if (sockstate == SOCKET_TOO_LARGE_FOR_SELECT) {\n        PyErr_SetString(get_state_sock(self)->PySSLErrorObject,\n                        \"Underlying socket too large for select().\");\n        goto error;\n    }\n\n    do {\n        PySSL_BEGIN_ALLOW_THREADS\n        retval = SSL_write_ex(self->ssl, b->buf, (size_t)b->len, &count);\n        err = _PySSL_errno(retval == 0, self->ssl, retval);\n        PySSL_END_ALLOW_THREADS\n        self->err = err;\n\n        if (PyErr_CheckSignals())\n            goto error;\n\n        if (has_timeout) {\n            timeout = _PyDeadline_Get(deadline);\n        }\n\n        if (err.ssl == SSL_ERROR_WANT_READ) {\n            sockstate = PySSL_select(sock, 0, timeout);\n        } else if (err.ssl == SSL_ERROR_WANT_WRITE) {\n            sockstate = PySSL_select(sock, 1, timeout);\n        } else {\n            sockstate = SOCKET_OPERATION_OK;\n        }\n\n        if (sockstate == SOCKET_HAS_TIMED_OUT) {\n            PyErr_SetString(PyExc_TimeoutError,\n                            \"The write operation timed out\");\n            goto error;\n        } else if (sockstate == SOCKET_HAS_BEEN_CLOSED) {\n            PyErr_SetString(get_state_sock(self)->PySSLErrorObject,\n                            \"Underlying socket has been closed.\");\n            goto error;\n        } else if (sockstate == SOCKET_IS_NONBLOCKING) {\n            break;\n        }\n    } while (err.ssl == SSL_ERROR_WANT_READ ||\n             err.ssl == SSL_ERROR_WANT_WRITE);\n\n    Py_XDECREF(sock);\n    if (retval == 0)\n        return PySSL_SetError(self, __FILE__, __LINE__);\n    if (PySSL_ChainExceptions(self) < 0)\n        return NULL;\n    return PyLong_FromSize_t(count);\nerror:\n    Py_XDECREF(sock);\n    PySSL_ChainExceptions(self);\n    return NULL;\n}\n\n/*[clinic input]\n_ssl._SSLSocket.pending\n\nReturns the number of already decrypted bytes available for read, pending on the connection.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_pending_impl(PySSLSocket *self)\n/*[clinic end generated code: output=983d9fecdc308a83 input=2b77487d6dfd597f]*/\n{\n    int count = 0;\n    _PySSLError err;\n\n    PySSL_BEGIN_ALLOW_THREADS\n    count = SSL_pending(self->ssl);\n    err = _PySSL_errno(count < 0, self->ssl, count);\n    PySSL_END_ALLOW_THREADS\n    self->err = err;\n\n    if (count < 0)\n        return PySSL_SetError(self, __FILE__, __LINE__);\n    else\n        return PyLong_FromLong(count);\n}\n\n/*[clinic input]\n_ssl._SSLSocket.read\n    size as len: Py_ssize_t\n    [\n    buffer: Py_buffer(accept={rwbuffer})\n    ]\n    /\n\nRead up to size bytes from the SSL socket.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_read_impl(PySSLSocket *self, Py_ssize_t len,\n                          int group_right_1, Py_buffer *buffer)\n/*[clinic end generated code: output=49b16e6406023734 input=ec48bf622be1c4a1]*/\n{\n    PyObject *dest = NULL;\n    char *mem;\n    size_t count = 0;\n    int retval;\n    int sockstate;\n    _PySSLError err;\n    int nonblocking;\n    PySocketSockObject *sock = GET_SOCKET(self);\n    PyTime_t timeout, deadline = 0;\n    int has_timeout;\n\n    if (!group_right_1 && len < 0) {\n        PyErr_SetString(PyExc_ValueError, \"size should not be negative\");\n        return NULL;\n    }\n\n    if (sock != NULL) {\n        if (((PyObject*)sock) == Py_None) {\n            _setSSLError(get_state_sock(self),\n                         \"Underlying socket connection gone\",\n                         PY_SSL_ERROR_NO_SOCKET, __FILE__, __LINE__);\n            return NULL;\n        }\n        Py_INCREF(sock);\n    }\n\n    if (!group_right_1) {\n        dest = PyBytes_FromStringAndSize(NULL, len);\n        if (dest == NULL)\n            goto error;\n        if (len == 0) {\n            Py_XDECREF(sock);\n            return dest;\n        }\n        mem = PyBytes_AS_STRING(dest);\n    }\n    else {\n        mem = buffer->buf;\n        if (len <= 0 || len > buffer->len) {\n            len = (int) buffer->len;\n            if (buffer->len != len) {\n                PyErr_SetString(PyExc_OverflowError,\n                                \"maximum length can't fit in a C 'int'\");\n                goto error;\n            }\n            if (len == 0) {\n                count = 0;\n                goto done;\n            }\n        }\n    }\n\n    if (sock != NULL) {\n        /* just in case the blocking state of the socket has been changed */\n        nonblocking = (sock->sock_timeout >= 0);\n        BIO_set_nbio(SSL_get_rbio(self->ssl), nonblocking);\n        BIO_set_nbio(SSL_get_wbio(self->ssl), nonblocking);\n    }\n\n    timeout = GET_SOCKET_TIMEOUT(sock);\n    has_timeout = (timeout > 0);\n    if (has_timeout)\n        deadline = _PyDeadline_Init(timeout);\n\n    do {\n        PySSL_BEGIN_ALLOW_THREADS\n        retval = SSL_read_ex(self->ssl, mem, (size_t)len, &count);\n        err = _PySSL_errno(retval == 0, self->ssl, retval);\n        PySSL_END_ALLOW_THREADS\n        self->err = err;\n\n        if (PyErr_CheckSignals())\n            goto error;\n\n        if (has_timeout) {\n            timeout = _PyDeadline_Get(deadline);\n        }\n\n        if (err.ssl == SSL_ERROR_WANT_READ) {\n            sockstate = PySSL_select(sock, 0, timeout);\n        } else if (err.ssl == SSL_ERROR_WANT_WRITE) {\n            sockstate = PySSL_select(sock, 1, timeout);\n        } else if (err.ssl == SSL_ERROR_ZERO_RETURN &&\n                   SSL_get_shutdown(self->ssl) == SSL_RECEIVED_SHUTDOWN)\n        {\n            count = 0;\n            goto done;\n        }\n        else\n            sockstate = SOCKET_OPERATION_OK;\n\n        if (sockstate == SOCKET_HAS_TIMED_OUT) {\n            PyErr_SetString(PyExc_TimeoutError,\n                            \"The read operation timed out\");\n            goto error;\n        } else if (sockstate == SOCKET_IS_NONBLOCKING) {\n            break;\n        }\n    } while (err.ssl == SSL_ERROR_WANT_READ ||\n             err.ssl == SSL_ERROR_WANT_WRITE);\n\n    if (retval == 0) {\n        PySSL_SetError(self, __FILE__, __LINE__);\n        goto error;\n    }\n    if (self->exc != NULL)\n        goto error;\n\ndone:\n    Py_XDECREF(sock);\n    if (!group_right_1) {\n        _PyBytes_Resize(&dest, count);\n        return dest;\n    }\n    else {\n        return PyLong_FromSize_t(count);\n    }\n\nerror:\n    PySSL_ChainExceptions(self);\n    Py_XDECREF(sock);\n    if (!group_right_1)\n        Py_XDECREF(dest);\n    return NULL;\n}\n\n/*[clinic input]\n_ssl._SSLSocket.shutdown\n\nDoes the SSL shutdown handshake with the remote end.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_shutdown_impl(PySSLSocket *self)\n/*[clinic end generated code: output=ca1aa7ed9d25ca42 input=11d39e69b0a2bf4a]*/\n{\n    _PySSLError err;\n    int sockstate, nonblocking, ret;\n    int zeros = 0;\n    PySocketSockObject *sock = GET_SOCKET(self);\n    PyTime_t timeout, deadline = 0;\n    int has_timeout;\n\n    if (sock != NULL) {\n        /* Guard against closed socket */\n        if ((((PyObject*)sock) == Py_None) || (sock->sock_fd == INVALID_SOCKET)) {\n            _setSSLError(get_state_sock(self),\n                         \"Underlying socket connection gone\",\n                         PY_SSL_ERROR_NO_SOCKET, __FILE__, __LINE__);\n            return NULL;\n        }\n        Py_INCREF(sock);\n\n        /* Just in case the blocking state of the socket has been changed */\n        nonblocking = (sock->sock_timeout >= 0);\n        BIO_set_nbio(SSL_get_rbio(self->ssl), nonblocking);\n        BIO_set_nbio(SSL_get_wbio(self->ssl), nonblocking);\n    }\n\n    timeout = GET_SOCKET_TIMEOUT(sock);\n    has_timeout = (timeout > 0);\n    if (has_timeout) {\n        deadline = _PyDeadline_Init(timeout);\n    }\n\n    while (1) {\n        PySSL_BEGIN_ALLOW_THREADS\n        /* Disable read-ahead so that unwrap can work correctly.\n         * Otherwise OpenSSL might read in too much data,\n         * eating clear text data that happens to be\n         * transmitted after the SSL shutdown.\n         * Should be safe to call repeatedly every time this\n         * function is used and the shutdown_seen_zero != 0\n         * condition is met.\n         */\n        if (self->shutdown_seen_zero)\n            SSL_set_read_ahead(self->ssl, 0);\n        ret = SSL_shutdown(self->ssl);\n        err = _PySSL_errno(ret < 0, self->ssl, ret);\n        PySSL_END_ALLOW_THREADS\n        self->err = err;\n\n        /* If err == 1, a secure shutdown with SSL_shutdown() is complete */\n        if (ret > 0)\n            break;\n        if (ret == 0) {\n            /* Don't loop endlessly; instead preserve legacy\n               behaviour of trying SSL_shutdown() only twice.\n               This looks necessary for OpenSSL < 0.9.8m */\n            if (++zeros > 1)\n                break;\n            /* Shutdown was sent, now try receiving */\n            self->shutdown_seen_zero = 1;\n            continue;\n        }\n\n        if (has_timeout) {\n            timeout = _PyDeadline_Get(deadline);\n        }\n\n        /* Possibly retry shutdown until timeout or failure */\n        if (err.ssl == SSL_ERROR_WANT_READ)\n            sockstate = PySSL_select(sock, 0, timeout);\n        else if (err.ssl == SSL_ERROR_WANT_WRITE)\n            sockstate = PySSL_select(sock, 1, timeout);\n        else\n            break;\n\n        if (sockstate == SOCKET_HAS_TIMED_OUT) {\n            if (err.ssl == SSL_ERROR_WANT_READ)\n                PyErr_SetString(PyExc_TimeoutError,\n                                \"The read operation timed out\");\n            else\n                PyErr_SetString(PyExc_TimeoutError,\n                                \"The write operation timed out\");\n            goto error;\n        }\n        else if (sockstate == SOCKET_TOO_LARGE_FOR_SELECT) {\n            PyErr_SetString(get_state_sock(self)->PySSLErrorObject,\n                            \"Underlying socket too large for select().\");\n            goto error;\n        }\n        else if (sockstate != SOCKET_OPERATION_OK)\n            /* Retain the SSL error code */\n            break;\n    }\n    if (ret < 0) {\n        Py_XDECREF(sock);\n        PySSL_SetError(self, __FILE__, __LINE__);\n        return NULL;\n    }\n    if (self->exc != NULL)\n        goto error;\n    if (sock)\n        /* It's already INCREF'ed */\n        return (PyObject *) sock;\n    else\n        Py_RETURN_NONE;\n\nerror:\n    Py_XDECREF(sock);\n    PySSL_ChainExceptions(self);\n    return NULL;\n}\n\n/*[clinic input]\n_ssl._SSLSocket.get_channel_binding\n   cb_type: str = \"tls-unique\"\n\nGet channel binding data for current connection.\n\nRaise ValueError if the requested `cb_type` is not supported.  Return bytes\nof the data or None if the data is not available (e.g. before the handshake).\nOnly 'tls-unique' channel binding data from RFC 5929 is supported.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_get_channel_binding_impl(PySSLSocket *self,\n                                         const char *cb_type)\n/*[clinic end generated code: output=34bac9acb6a61d31 input=08b7e43b99c17d41]*/\n{\n    char buf[PySSL_CB_MAXLEN];\n    size_t len;\n\n    if (strcmp(cb_type, \"tls-unique\") == 0) {\n        if (SSL_session_reused(self->ssl) ^ !self->socket_type) {\n            /* if session is resumed XOR we are the client */\n            len = SSL_get_finished(self->ssl, buf, PySSL_CB_MAXLEN);\n        }\n        else {\n            /* if a new session XOR we are the server */\n            len = SSL_get_peer_finished(self->ssl, buf, PySSL_CB_MAXLEN);\n        }\n    }\n    else {\n        PyErr_Format(\n            PyExc_ValueError,\n            \"'%s' channel binding type not implemented\",\n            cb_type\n        );\n        return NULL;\n    }\n\n    /* It cannot be negative in current OpenSSL version as of July 2011 */\n    if (len == 0)\n        Py_RETURN_NONE;\n\n    return PyBytes_FromStringAndSize(buf, len);\n}\n\n/*[clinic input]\n_ssl._SSLSocket.verify_client_post_handshake\n\nInitiate TLS 1.3 post-handshake authentication\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLSocket_verify_client_post_handshake_impl(PySSLSocket *self)\n/*[clinic end generated code: output=532147f3b1341425 input=6bfa874810a3d889]*/\n{\n#ifdef TLS1_3_VERSION\n    int err = SSL_verify_client_post_handshake(self->ssl);\n    if (err == 0)\n        return _setSSLError(get_state_sock(self), NULL, 0, __FILE__, __LINE__);\n    else\n        Py_RETURN_NONE;\n#else\n    PyErr_SetString(PyExc_NotImplementedError,\n                    \"Post-handshake auth is not supported by your \"\n                    \"OpenSSL version.\");\n    return NULL;\n#endif\n}\n\nstatic SSL_SESSION*\n_ssl_session_dup(SSL_SESSION *session) {\n    SSL_SESSION *newsession = NULL;\n    int slen;\n    unsigned char *senc = NULL, *p;\n    const unsigned char *const_p;\n\n    if (session == NULL) {\n        PyErr_SetString(PyExc_ValueError, \"Invalid session\");\n        goto error;\n    }\n\n    /* get length */\n    slen = i2d_SSL_SESSION(session, NULL);\n    if (slen == 0 || slen > 0xFF00) {\n        PyErr_SetString(PyExc_ValueError, \"i2d() failed\");\n        goto error;\n    }\n    if ((senc = PyMem_Malloc(slen)) == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n    p = senc;\n    if (!i2d_SSL_SESSION(session, &p)) {\n        PyErr_SetString(PyExc_ValueError, \"i2d() failed\");\n        goto error;\n    }\n    const_p = senc;\n    newsession = d2i_SSL_SESSION(NULL, &const_p, slen);\n    if (newsession == NULL) {\n        PyErr_SetString(PyExc_ValueError, \"d2i() failed\");\n        goto error;\n    }\n    PyMem_Free(senc);\n    return newsession;\n  error:\n    if (senc != NULL) {\n        PyMem_Free(senc);\n    }\n    return NULL;\n}\n\nstatic PyObject *\nPySSL_get_session(PySSLSocket *self, void *closure) {\n    /* get_session can return sessions from a server-side connection,\n     * it does not check for handshake done or client socket. */\n    PySSLSession *pysess;\n    SSL_SESSION *session;\n\n    /* duplicate session as workaround for session bug in OpenSSL 1.1.0,\n     * https://github.com/openssl/openssl/issues/1550 */\n    session = SSL_get0_session(self->ssl);  /* borrowed reference */\n    if (session == NULL) {\n        Py_RETURN_NONE;\n    }\n    if ((session = _ssl_session_dup(session)) == NULL) {\n        return NULL;\n    }\n    session = SSL_get1_session(self->ssl);\n    if (session == NULL) {\n        Py_RETURN_NONE;\n    }\n    pysess = PyObject_GC_New(PySSLSession, self->ctx->state->PySSLSession_Type);\n    if (pysess == NULL) {\n        SSL_SESSION_free(session);\n        return NULL;\n    }\n\n    assert(self->ctx);\n    pysess->ctx = (PySSLContext*)Py_NewRef(self->ctx);\n    pysess->session = session;\n    PyObject_GC_Track(pysess);\n    return (PyObject *)pysess;\n}\n\nstatic int PySSL_set_session(PySSLSocket *self, PyObject *value,\n                             void *closure)\n                              {\n    PySSLSession *pysess;\n    SSL_SESSION *session;\n    int result;\n\n    if (!Py_IS_TYPE(value, get_state_sock(self)->PySSLSession_Type)) {\n        PyErr_SetString(PyExc_TypeError, \"Value is not a SSLSession.\");\n        return -1;\n    }\n    pysess = (PySSLSession *)value;\n\n    if (self->ctx->ctx != pysess->ctx->ctx) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"Session refers to a different SSLContext.\");\n        return -1;\n    }\n    if (self->socket_type != PY_SSL_CLIENT) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"Cannot set session for server-side SSLSocket.\");\n        return -1;\n    }\n    if (SSL_is_init_finished(self->ssl)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"Cannot set session after handshake.\");\n        return -1;\n    }\n    /* duplicate session */\n    if ((session = _ssl_session_dup(pysess->session)) == NULL) {\n        return -1;\n    }\n    result = SSL_set_session(self->ssl, session);\n    /* free duplicate, SSL_set_session() bumps ref count */\n    SSL_SESSION_free(session);\n    if (result == 0) {\n        _setSSLError(get_state_sock(self), NULL, 0, __FILE__, __LINE__);\n        return -1;\n    }\n    return 0;\n}\n\nPyDoc_STRVAR(PySSL_set_session_doc,\n\"_setter_session(session)\\n\\\n\\\nGet / set SSLSession.\");\n\nstatic PyObject *\nPySSL_get_session_reused(PySSLSocket *self, void *closure) {\n    if (SSL_session_reused(self->ssl)) {\n        Py_RETURN_TRUE;\n    } else {\n        Py_RETURN_FALSE;\n    }\n}\n\nPyDoc_STRVAR(PySSL_get_session_reused_doc,\n\"Was the client session reused during handshake?\");\n\nstatic PyGetSetDef ssl_getsetlist[] = {\n    {\"context\", (getter) PySSL_get_context,\n                (setter) PySSL_set_context, PySSL_set_context_doc},\n    {\"server_side\", (getter) PySSL_get_server_side, NULL,\n                    PySSL_get_server_side_doc},\n    {\"server_hostname\", (getter) PySSL_get_server_hostname, NULL,\n                        PySSL_get_server_hostname_doc},\n    {\"owner\", (getter) PySSL_get_owner, (setter) PySSL_set_owner,\n              PySSL_get_owner_doc},\n    {\"session\", (getter) PySSL_get_session,\n                (setter) PySSL_set_session, PySSL_set_session_doc},\n    {\"session_reused\", (getter) PySSL_get_session_reused, NULL,\n              PySSL_get_session_reused_doc},\n    {NULL},            /* sentinel */\n};\n\nstatic PyMethodDef PySSLMethods[] = {\n    _SSL__SSLSOCKET_DO_HANDSHAKE_METHODDEF\n    _SSL__SSLSOCKET_WRITE_METHODDEF\n    _SSL__SSLSOCKET_READ_METHODDEF\n    _SSL__SSLSOCKET_PENDING_METHODDEF\n    _SSL__SSLSOCKET_GETPEERCERT_METHODDEF\n    _SSL__SSLSOCKET_GET_CHANNEL_BINDING_METHODDEF\n    _SSL__SSLSOCKET_CIPHER_METHODDEF\n    _SSL__SSLSOCKET_SHARED_CIPHERS_METHODDEF\n    _SSL__SSLSOCKET_VERSION_METHODDEF\n    _SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF\n    _SSL__SSLSOCKET_COMPRESSION_METHODDEF\n    _SSL__SSLSOCKET_SHUTDOWN_METHODDEF\n    _SSL__SSLSOCKET_VERIFY_CLIENT_POST_HANDSHAKE_METHODDEF\n    _SSL__SSLSOCKET_GET_UNVERIFIED_CHAIN_METHODDEF\n    _SSL__SSLSOCKET_GET_VERIFIED_CHAIN_METHODDEF\n    {NULL, NULL}\n};\n\nstatic PyType_Slot PySSLSocket_slots[] = {\n    {Py_tp_methods, PySSLMethods},\n    {Py_tp_getset, ssl_getsetlist},\n    {Py_tp_dealloc, PySSL_dealloc},\n    {Py_tp_traverse, PySSL_traverse},\n    {Py_tp_clear, PySSL_clear},\n    {0, 0},\n};\n\nstatic PyType_Spec PySSLSocket_spec = {\n    .name = \"_ssl._SSLSocket\",\n    .basicsize = sizeof(PySSLSocket),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE |\n              Py_TPFLAGS_HAVE_GC),\n    .slots = PySSLSocket_slots,\n};\n\n/*\n * _SSLContext objects\n */\n\nstatic int\n_set_verify_mode(PySSLContext *self, enum py_ssl_cert_requirements n)\n{\n    int mode;\n\n    switch(n) {\n    case PY_SSL_CERT_NONE:\n        mode = SSL_VERIFY_NONE;\n        break;\n    case PY_SSL_CERT_OPTIONAL:\n        mode = SSL_VERIFY_PEER;\n        break;\n    case PY_SSL_CERT_REQUIRED:\n        mode = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n        break;\n    default:\n         PyErr_SetString(PyExc_ValueError,\n                        \"invalid value for verify_mode\");\n        return -1;\n    }\n\n    /* bpo-37428: newPySSLSocket() sets SSL_VERIFY_POST_HANDSHAKE flag for\n     * server sockets and SSL_set_post_handshake_auth() for client. */\n\n    SSL_CTX_set_verify(self->ctx, mode, NULL);\n    return 0;\n}\n\n/*[clinic input]\n@classmethod\n_ssl._SSLContext.__new__\n    protocol as proto_version: int\n    /\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext_impl(PyTypeObject *type, int proto_version)\n/*[clinic end generated code: output=2cf0d7a0741b6bd1 input=8d58a805b95fc534]*/\n{\n    PySSLContext *self;\n    uint64_t options;\n    const SSL_METHOD *method = NULL;\n    SSL_CTX *ctx = NULL;\n    X509_VERIFY_PARAM *params;\n    int result;\n\n   /* slower approach, walk MRO and get borrowed reference to module.\n    * PyType_GetModuleByDef is required for SSLContext subclasses */\n    PyObject *module = PyType_GetModuleByDef(type, &_sslmodule_def);\n    if (module == NULL) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"Cannot find internal module state\");\n        return NULL;\n    }\n\n    switch(proto_version) {\n#if defined(SSL3_VERSION) && !defined(OPENSSL_NO_SSL3)\n    case PY_SSL_VERSION_SSL3:\n        PY_SSL_DEPRECATED(\"ssl.PROTOCOL_SSLv3 is deprecated\", 2, NULL);\n        method = SSLv3_method();\n        break;\n#endif\n#if (defined(TLS1_VERSION) && \\\n        !defined(OPENSSL_NO_TLS1) && \\\n        !defined(OPENSSL_NO_TLS1_METHOD))\n    case PY_SSL_VERSION_TLS1:\n        PY_SSL_DEPRECATED(\"ssl.PROTOCOL_TLSv1 is deprecated\", 2, NULL);\n        method = TLSv1_method();\n        break;\n#endif\n#if (defined(TLS1_1_VERSION) && \\\n        !defined(OPENSSL_NO_TLS1_1) && \\\n        !defined(OPENSSL_NO_TLS1_1_METHOD))\n    case PY_SSL_VERSION_TLS1_1:\n        PY_SSL_DEPRECATED(\"ssl.PROTOCOL_TLSv1_1 is deprecated\", 2, NULL);\n        method = TLSv1_1_method();\n        break;\n#endif\n#if (defined(TLS1_2_VERSION) && \\\n        !defined(OPENSSL_NO_TLS1_2) && \\\n        !defined(OPENSSL_NO_TLS1_2_METHOD))\n    case PY_SSL_VERSION_TLS1_2:\n        PY_SSL_DEPRECATED(\"ssl.PROTOCOL_TLSv1_2 is deprecated\", 2, NULL);\n        method = TLSv1_2_method();\n        break;\n#endif\n    case PY_SSL_VERSION_TLS:\n        PY_SSL_DEPRECATED(\"ssl.PROTOCOL_TLS is deprecated\", 2, NULL);\n        method = TLS_method();\n        break;\n    case PY_SSL_VERSION_TLS_CLIENT:\n        method = TLS_client_method();\n        break;\n    case PY_SSL_VERSION_TLS_SERVER:\n        method = TLS_server_method();\n        break;\n    default:\n        method = NULL;\n    }\n\n    if (method == NULL) {\n        PyErr_Format(PyExc_ValueError,\n                     \"invalid or unsupported protocol version %i\",\n                     proto_version);\n        return NULL;\n    }\n\n    PySSL_BEGIN_ALLOW_THREADS\n    ctx = SSL_CTX_new(method);\n    PySSL_END_ALLOW_THREADS\n\n    if (ctx == NULL) {\n        _setSSLError(get_ssl_state(module), NULL, 0, __FILE__, __LINE__);\n        return NULL;\n    }\n\n    assert(type != NULL && type->tp_alloc != NULL);\n    self = (PySSLContext *) type->tp_alloc(type, 0);\n    if (self == NULL) {\n        SSL_CTX_free(ctx);\n        return NULL;\n    }\n    self->ctx = ctx;\n    self->hostflags = X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS;\n    self->protocol = proto_version;\n    self->msg_cb = NULL;\n    self->keylog_filename = NULL;\n    self->keylog_bio = NULL;\n    self->alpn_protocols = NULL;\n    self->set_sni_cb = NULL;\n    self->state = get_ssl_state(module);\n#ifndef OPENSSL_NO_PSK\n    self->psk_client_callback = NULL;\n    self->psk_server_callback = NULL;\n#endif\n\n    /* Don't check host name by default */\n    if (proto_version == PY_SSL_VERSION_TLS_CLIENT) {\n        self->check_hostname = 1;\n        if (_set_verify_mode(self, PY_SSL_CERT_REQUIRED) == -1) {\n            Py_DECREF(self);\n            return NULL;\n        }\n    } else {\n        self->check_hostname = 0;\n        if (_set_verify_mode(self, PY_SSL_CERT_NONE) == -1) {\n            Py_DECREF(self);\n            return NULL;\n        }\n    }\n    /* Defaults */\n    options = SSL_OP_ALL & ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;\n    if (proto_version != PY_SSL_VERSION_SSL2)\n        options |= SSL_OP_NO_SSLv2;\n    if (proto_version != PY_SSL_VERSION_SSL3)\n        options |= SSL_OP_NO_SSLv3;\n    /* Minimal security flags for server and client side context.\n     * Client sockets ignore server-side parameters. */\n#ifdef SSL_OP_NO_COMPRESSION\n    options |= SSL_OP_NO_COMPRESSION;\n#endif\n#ifdef SSL_OP_CIPHER_SERVER_PREFERENCE\n    options |= SSL_OP_CIPHER_SERVER_PREFERENCE;\n#endif\n#ifdef SSL_OP_SINGLE_DH_USE\n    options |= SSL_OP_SINGLE_DH_USE;\n#endif\n#ifdef SSL_OP_SINGLE_ECDH_USE\n    options |= SSL_OP_SINGLE_ECDH_USE;\n#endif\n    SSL_CTX_set_options(self->ctx, options);\n\n    /* A bare minimum cipher list without completely broken cipher suites.\n     * It's far from perfect but gives users a better head start. */\n    if (proto_version != PY_SSL_VERSION_SSL2) {\n#if PY_SSL_DEFAULT_CIPHERS == 2\n        /* stick to OpenSSL's default settings */\n        result = 1;\n#else\n        result = SSL_CTX_set_cipher_list(ctx, PY_SSL_DEFAULT_CIPHER_STRING);\n#endif\n    } else {\n        /* SSLv2 needs MD5 */\n        result = SSL_CTX_set_cipher_list(ctx, \"HIGH:!aNULL:!eNULL\");\n    }\n    if (result == 0) {\n        ERR_clear_error();\n        PyErr_SetString(get_state_ctx(self)->PySSLErrorObject,\n                        \"No cipher can be selected.\");\n        goto error;\n    }\n#ifdef PY_SSL_MIN_PROTOCOL\n    switch(proto_version) {\n    case PY_SSL_VERSION_TLS:\n    case PY_SSL_VERSION_TLS_CLIENT:\n    case PY_SSL_VERSION_TLS_SERVER:\n        result = SSL_CTX_set_min_proto_version(ctx, PY_SSL_MIN_PROTOCOL);\n        if (result == 0) {\n            PyErr_Format(PyExc_ValueError,\n                         \"Failed to set minimum protocol 0x%x\",\n                          PY_SSL_MIN_PROTOCOL);\n            goto error;\n        }\n        break;\n    default:\n        break;\n    }\n#endif\n\n    /* Set SSL_MODE_RELEASE_BUFFERS. This potentially greatly reduces memory\n       usage for no cost at all. */\n    SSL_CTX_set_mode(self->ctx, SSL_MODE_RELEASE_BUFFERS);\n\n    params = SSL_CTX_get0_param(self->ctx);\n    /* Improve trust chain building when cross-signed intermediate\n       certificates are present. See https://bugs.python.org/issue23476. */\n    X509_VERIFY_PARAM_set_flags(params, X509_V_FLAG_TRUSTED_FIRST);\n    X509_VERIFY_PARAM_set_hostflags(params, self->hostflags);\n\n#ifdef TLS1_3_VERSION\n    self->post_handshake_auth = 0;\n    SSL_CTX_set_post_handshake_auth(self->ctx, self->post_handshake_auth);\n#endif\n\n    return (PyObject *)self;\n  error:\n    Py_XDECREF(self);\n    ERR_clear_error();\n    return NULL;\n}\n\nstatic int\ncontext_traverse(PySSLContext *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->set_sni_cb);\n    Py_VISIT(self->msg_cb);\n    Py_VISIT(Py_TYPE(self));\n    return 0;\n}\n\nstatic int\ncontext_clear(PySSLContext *self)\n{\n    Py_CLEAR(self->set_sni_cb);\n    Py_CLEAR(self->msg_cb);\n    Py_CLEAR(self->keylog_filename);\n#ifndef OPENSSL_NO_PSK\n    Py_CLEAR(self->psk_client_callback);\n    Py_CLEAR(self->psk_server_callback);\n#endif\n    if (self->keylog_bio != NULL) {\n        PySSL_BEGIN_ALLOW_THREADS\n        BIO_free_all(self->keylog_bio);\n        PySSL_END_ALLOW_THREADS\n        self->keylog_bio = NULL;\n    }\n    return 0;\n}\n\nstatic void\ncontext_dealloc(PySSLContext *self)\n{\n    PyTypeObject *tp = Py_TYPE(self);\n    /* bpo-31095: UnTrack is needed before calling any callbacks */\n    PyObject_GC_UnTrack(self);\n    context_clear(self);\n    SSL_CTX_free(self->ctx);\n    PyMem_FREE(self->alpn_protocols);\n    Py_TYPE(self)->tp_free(self);\n    Py_DECREF(tp);\n}\n\n/*[clinic input]\n_ssl._SSLContext.set_ciphers\n    cipherlist: str\n    /\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext_set_ciphers_impl(PySSLContext *self, const char *cipherlist)\n/*[clinic end generated code: output=3a3162f3557c0f3f input=a7ac931b9f3ca7fc]*/\n{\n    int ret = SSL_CTX_set_cipher_list(self->ctx, cipherlist);\n    if (ret == 0) {\n        /* Clearing the error queue is necessary on some OpenSSL versions,\n           otherwise the error will be reported again when another SSL call\n           is done. */\n        ERR_clear_error();\n        PyErr_SetString(get_state_ctx(self)->PySSLErrorObject,\n                        \"No cipher can be selected.\");\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n_ssl._SSLContext.get_ciphers\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext_get_ciphers_impl(PySSLContext *self)\n/*[clinic end generated code: output=a56e4d68a406dfc4 input=a2aadc9af89b79c5]*/\n{\n    SSL *ssl = NULL;\n    STACK_OF(SSL_CIPHER) *sk = NULL;\n    const SSL_CIPHER *cipher;\n    int i=0;\n    PyObject *result = NULL, *dct;\n\n    ssl = SSL_new(self->ctx);\n    if (ssl == NULL) {\n        _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n        goto exit;\n    }\n    sk = SSL_get_ciphers(ssl);\n\n    result = PyList_New(sk_SSL_CIPHER_num(sk));\n    if (result == NULL) {\n        goto exit;\n    }\n\n    for (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {\n        cipher = sk_SSL_CIPHER_value(sk, i);\n        dct = cipher_to_dict(cipher);\n        if (dct == NULL) {\n            Py_CLEAR(result);\n            goto exit;\n        }\n        PyList_SET_ITEM(result, i, dct);\n    }\n\n  exit:\n    if (ssl != NULL)\n        SSL_free(ssl);\n    return result;\n\n}\n\n\nstatic int\ndo_protocol_selection(int alpn, unsigned char **out, unsigned char *outlen,\n                      const unsigned char *server_protocols, unsigned int server_protocols_len,\n                      const unsigned char *client_protocols, unsigned int client_protocols_len)\n{\n    int ret;\n    if (client_protocols == NULL) {\n        client_protocols = (unsigned char *)\"\";\n        client_protocols_len = 0;\n    }\n    if (server_protocols == NULL) {\n        server_protocols = (unsigned char *)\"\";\n        server_protocols_len = 0;\n    }\n\n    ret = SSL_select_next_proto(out, outlen,\n                                server_protocols, server_protocols_len,\n                                client_protocols, client_protocols_len);\n    if (alpn && ret != OPENSSL_NPN_NEGOTIATED)\n        return SSL_TLSEXT_ERR_NOACK;\n\n    return SSL_TLSEXT_ERR_OK;\n}\n\nstatic int\n_selectALPN_cb(SSL *s,\n              const unsigned char **out, unsigned char *outlen,\n              const unsigned char *client_protocols, unsigned int client_protocols_len,\n              void *args)\n{\n    PySSLContext *ctx = (PySSLContext *)args;\n    return do_protocol_selection(1, (unsigned char **)out, outlen,\n                                 ctx->alpn_protocols, ctx->alpn_protocols_len,\n                                 client_protocols, client_protocols_len);\n}\n\n/*[clinic input]\n_ssl._SSLContext._set_alpn_protocols\n    protos: Py_buffer\n    /\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext__set_alpn_protocols_impl(PySSLContext *self,\n                                          Py_buffer *protos)\n/*[clinic end generated code: output=87599a7f76651a9b input=9bba964595d519be]*/\n{\n    if ((size_t)protos->len > UINT_MAX) {\n        PyErr_Format(PyExc_OverflowError,\n            \"protocols longer than %u bytes\", UINT_MAX);\n        return NULL;\n    }\n\n    PyMem_Free(self->alpn_protocols);\n    self->alpn_protocols = PyMem_Malloc(protos->len);\n    if (!self->alpn_protocols)\n        return PyErr_NoMemory();\n    memcpy(self->alpn_protocols, protos->buf, protos->len);\n    self->alpn_protocols_len = (unsigned int)protos->len;\n\n    if (SSL_CTX_set_alpn_protos(self->ctx, self->alpn_protocols, self->alpn_protocols_len))\n        return PyErr_NoMemory();\n    SSL_CTX_set_alpn_select_cb(self->ctx, _selectALPN_cb, self);\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nget_verify_mode(PySSLContext *self, void *c)\n{\n    /* ignore SSL_VERIFY_CLIENT_ONCE and SSL_VERIFY_POST_HANDSHAKE */\n    int mask = (SSL_VERIFY_NONE | SSL_VERIFY_PEER |\n                SSL_VERIFY_FAIL_IF_NO_PEER_CERT);\n    switch (SSL_CTX_get_verify_mode(self->ctx) & mask) {\n    case SSL_VERIFY_NONE:\n        return PyLong_FromLong(PY_SSL_CERT_NONE);\n    case SSL_VERIFY_PEER:\n        return PyLong_FromLong(PY_SSL_CERT_OPTIONAL);\n    case SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT:\n        return PyLong_FromLong(PY_SSL_CERT_REQUIRED);\n    }\n    PyErr_SetString(get_state_ctx(self)->PySSLErrorObject,\n                    \"invalid return value from SSL_CTX_get_verify_mode\");\n    return NULL;\n}\n\nstatic int\nset_verify_mode(PySSLContext *self, PyObject *arg, void *c)\n{\n    int n;\n    if (!PyArg_Parse(arg, \"i\", &n))\n        return -1;\n    if (n == PY_SSL_CERT_NONE && self->check_hostname) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"Cannot set verify_mode to CERT_NONE when \"\n                        \"check_hostname is enabled.\");\n        return -1;\n    }\n    return _set_verify_mode(self, n);\n}\n\nstatic PyObject *\nget_verify_flags(PySSLContext *self, void *c)\n{\n    X509_VERIFY_PARAM *param;\n    unsigned long flags;\n\n    param = SSL_CTX_get0_param(self->ctx);\n    flags = X509_VERIFY_PARAM_get_flags(param);\n    return PyLong_FromUnsignedLong(flags);\n}\n\nstatic int\nset_verify_flags(PySSLContext *self, PyObject *arg, void *c)\n{\n    X509_VERIFY_PARAM *param;\n    unsigned long new_flags, flags, set, clear;\n\n    if (!PyArg_Parse(arg, \"k\", &new_flags))\n        return -1;\n    param = SSL_CTX_get0_param(self->ctx);\n    flags = X509_VERIFY_PARAM_get_flags(param);\n    clear = flags & ~new_flags;\n    set = ~flags & new_flags;\n    if (clear) {\n        if (!X509_VERIFY_PARAM_clear_flags(param, clear)) {\n            _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n            return -1;\n        }\n    }\n    if (set) {\n        if (!X509_VERIFY_PARAM_set_flags(param, set)) {\n            _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n            return -1;\n        }\n    }\n    return 0;\n}\n\n/* Getter and setter for protocol version */\nstatic int\nset_min_max_proto_version(PySSLContext *self, PyObject *arg, int what)\n{\n    long v;\n    int result;\n\n    if (!PyArg_Parse(arg, \"l\", &v))\n        return -1;\n    if (v > INT_MAX) {\n        PyErr_SetString(PyExc_OverflowError, \"Option is too long\");\n        return -1;\n    }\n\n    switch(self->protocol) {\n    case PY_SSL_VERSION_TLS_CLIENT:  /* fall through */\n    case PY_SSL_VERSION_TLS_SERVER:  /* fall through */\n    case PY_SSL_VERSION_TLS:\n        break;\n    default:\n        PyErr_SetString(\n            PyExc_ValueError,\n            \"The context's protocol doesn't support modification of \"\n            \"highest and lowest version.\"\n        );\n        return -1;\n    }\n\n    /* check for deprecations and supported values */\n    switch(v) {\n        case PY_PROTO_SSLv3:\n            PY_SSL_DEPRECATED(\"ssl.TLSVersion.SSLv3 is deprecated\", 2, -1);\n            break;\n        case PY_PROTO_TLSv1:\n            PY_SSL_DEPRECATED(\"ssl.TLSVersion.TLSv1 is deprecated\", 2, -1);\n            break;\n        case PY_PROTO_TLSv1_1:\n            PY_SSL_DEPRECATED(\"ssl.TLSVersion.TLSv1_1 is deprecated\", 2, -1);\n            break;\n        case PY_PROTO_MINIMUM_SUPPORTED:\n        case PY_PROTO_MAXIMUM_SUPPORTED:\n        case PY_PROTO_TLSv1_2:\n        case PY_PROTO_TLSv1_3:\n            /* ok */\n            break;\n        default:\n            PyErr_Format(PyExc_ValueError,\n                     \"Unsupported TLS/SSL version 0x%x\", v);\n            return -1;\n    }\n\n    if (what == 0) {\n        switch(v) {\n        case PY_PROTO_MINIMUM_SUPPORTED:\n            v = 0;\n            break;\n        case PY_PROTO_MAXIMUM_SUPPORTED:\n            /* Emulate max for set_min_proto_version */\n            v = PY_PROTO_MAXIMUM_AVAILABLE;\n            break;\n        default:\n            break;\n        }\n        result = SSL_CTX_set_min_proto_version(self->ctx, v);\n    }\n    else {\n        switch(v) {\n        case PY_PROTO_MAXIMUM_SUPPORTED:\n            v = 0;\n            break;\n        case PY_PROTO_MINIMUM_SUPPORTED:\n            /* Emulate max for set_min_proto_version */\n            v = PY_PROTO_MINIMUM_AVAILABLE;\n            break;\n        default:\n            break;\n        }\n        result = SSL_CTX_set_max_proto_version(self->ctx, v);\n    }\n    if (result == 0) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Unsupported protocol version 0x%x\", v);\n        return -1;\n    }\n    return 0;\n}\n\nstatic PyObject *\nget_minimum_version(PySSLContext *self, void *c)\n{\n    int v = SSL_CTX_get_min_proto_version(self->ctx);\n    if (v == 0) {\n        v = PY_PROTO_MINIMUM_SUPPORTED;\n    }\n    return PyLong_FromLong(v);\n}\n\nstatic int\nset_minimum_version(PySSLContext *self, PyObject *arg, void *c)\n{\n    return set_min_max_proto_version(self, arg, 0);\n}\n\nstatic PyObject *\nget_maximum_version(PySSLContext *self, void *c)\n{\n    int v = SSL_CTX_get_max_proto_version(self->ctx);\n    if (v == 0) {\n        v = PY_PROTO_MAXIMUM_SUPPORTED;\n    }\n    return PyLong_FromLong(v);\n}\n\nstatic int\nset_maximum_version(PySSLContext *self, PyObject *arg, void *c)\n{\n    return set_min_max_proto_version(self, arg, 1);\n}\n\n#ifdef TLS1_3_VERSION\nstatic PyObject *\nget_num_tickets(PySSLContext *self, void *c)\n{\n    return PyLong_FromSize_t(SSL_CTX_get_num_tickets(self->ctx));\n}\n\nstatic int\nset_num_tickets(PySSLContext *self, PyObject *arg, void *c)\n{\n    long num;\n    if (!PyArg_Parse(arg, \"l\", &num))\n        return -1;\n    if (num < 0) {\n        PyErr_SetString(PyExc_ValueError, \"value must be non-negative\");\n        return -1;\n    }\n    if (self->protocol != PY_SSL_VERSION_TLS_SERVER) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"SSLContext is not a server context.\");\n        return -1;\n    }\n    if (SSL_CTX_set_num_tickets(self->ctx, num) != 1) {\n        PyErr_SetString(PyExc_ValueError, \"failed to set num tickets.\");\n        return -1;\n    }\n    return 0;\n}\n\nPyDoc_STRVAR(PySSLContext_num_tickets_doc,\n\"Control the number of TLSv1.3 session tickets\");\n#endif /* TLS1_3_VERSION */\n\nstatic PyObject *\nget_security_level(PySSLContext *self, void *c)\n{\n    return PyLong_FromLong(SSL_CTX_get_security_level(self->ctx));\n}\nPyDoc_STRVAR(PySSLContext_security_level_doc, \"The current security level\");\n\nstatic PyObject *\nget_options(PySSLContext *self, void *c)\n{\n    uint64_t options = SSL_CTX_get_options(self->ctx);\n    Py_BUILD_ASSERT(sizeof(unsigned long long) >= sizeof(options));\n    return PyLong_FromUnsignedLongLong(options);\n}\n\nstatic int\nset_options(PySSLContext *self, PyObject *arg, void *c)\n{\n    PyObject *new_opts_obj;\n    unsigned long long new_opts_arg;\n    uint64_t new_opts, opts, clear, set;\n    uint64_t opt_no = (\n        SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1 |\n        SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2 | SSL_OP_NO_TLSv1_3\n    );\n\n    if (!PyArg_Parse(arg, \"O!\", &PyLong_Type, &new_opts_obj)) {\n        return -1;\n    }\n    new_opts_arg = PyLong_AsUnsignedLongLong(new_opts_obj);\n    if (new_opts_arg == (unsigned long long)-1 && PyErr_Occurred()) {\n        return -1;\n    }\n    Py_BUILD_ASSERT(sizeof(new_opts) >= sizeof(new_opts_arg));\n    new_opts = (uint64_t)new_opts_arg;\n\n    opts = SSL_CTX_get_options(self->ctx);\n    clear = opts & ~new_opts;\n    set = ~opts & new_opts;\n\n    if ((set & opt_no) != 0) {\n        if (_ssl_deprecated(\"ssl.OP_NO_SSL*/ssl.OP_NO_TLS* options are \"\n                            \"deprecated\", 2) < 0) {\n            return -1;\n        }\n    }\n    if (clear) {\n        SSL_CTX_clear_options(self->ctx, clear);\n    }\n    if (set) {\n        SSL_CTX_set_options(self->ctx, set);\n    }\n    return 0;\n}\n\nstatic PyObject *\nget_host_flags(PySSLContext *self, void *c)\n{\n    return PyLong_FromUnsignedLong(self->hostflags);\n}\n\nstatic int\nset_host_flags(PySSLContext *self, PyObject *arg, void *c)\n{\n    X509_VERIFY_PARAM *param;\n    unsigned int new_flags = 0;\n\n    if (!PyArg_Parse(arg, \"I\", &new_flags))\n        return -1;\n\n    param = SSL_CTX_get0_param(self->ctx);\n    self->hostflags = new_flags;\n    X509_VERIFY_PARAM_set_hostflags(param, new_flags);\n    return 0;\n}\n\nstatic PyObject *\nget_check_hostname(PySSLContext *self, void *c)\n{\n    return PyBool_FromLong(self->check_hostname);\n}\n\nstatic int\nset_check_hostname(PySSLContext *self, PyObject *arg, void *c)\n{\n    int check_hostname;\n    if (!PyArg_Parse(arg, \"p\", &check_hostname))\n        return -1;\n    if (check_hostname &&\n            SSL_CTX_get_verify_mode(self->ctx) == SSL_VERIFY_NONE) {\n        /* check_hostname = True sets verify_mode = CERT_REQUIRED */\n        if (_set_verify_mode(self, PY_SSL_CERT_REQUIRED) == -1) {\n            return -1;\n        }\n    }\n    self->check_hostname = check_hostname;\n    return 0;\n}\n\nstatic PyObject *\nget_post_handshake_auth(PySSLContext *self, void *c) {\n#if TLS1_3_VERSION\n    return PyBool_FromLong(self->post_handshake_auth);\n#else\n    Py_RETURN_NONE;\n#endif\n}\n\n#if TLS1_3_VERSION\nstatic int\nset_post_handshake_auth(PySSLContext *self, PyObject *arg, void *c) {\n    if (arg == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"cannot delete attribute\");\n        return -1;\n    }\n    int pha = PyObject_IsTrue(arg);\n\n    if (pha == -1) {\n        return -1;\n    }\n    self->post_handshake_auth = pha;\n\n    /* bpo-37428: newPySSLSocket() sets SSL_VERIFY_POST_HANDSHAKE flag for\n     * server sockets and SSL_set_post_handshake_auth() for client. */\n\n    return 0;\n}\n#endif\n\nstatic PyObject *\nget_protocol(PySSLContext *self, void *c) {\n    return PyLong_FromLong(self->protocol);\n}\n\ntypedef struct {\n    PyThreadState *thread_state;\n    PyObject *callable;\n    char *password;\n    int size;\n    int error;\n} _PySSLPasswordInfo;\n\nstatic int\n_pwinfo_set(_PySSLPasswordInfo *pw_info, PyObject* password,\n            const char *bad_type_error)\n{\n    /* Set the password and size fields of a _PySSLPasswordInfo struct\n       from a unicode, bytes, or byte array object.\n       The password field will be dynamically allocated and must be freed\n       by the caller */\n    PyObject *password_bytes = NULL;\n    const char *data = NULL;\n    Py_ssize_t size;\n\n    if (PyUnicode_Check(password)) {\n        password_bytes = PyUnicode_AsUTF8String(password);\n        if (!password_bytes) {\n            goto error;\n        }\n        data = PyBytes_AS_STRING(password_bytes);\n        size = PyBytes_GET_SIZE(password_bytes);\n    } else if (PyBytes_Check(password)) {\n        data = PyBytes_AS_STRING(password);\n        size = PyBytes_GET_SIZE(password);\n    } else if (PyByteArray_Check(password)) {\n        data = PyByteArray_AS_STRING(password);\n        size = PyByteArray_GET_SIZE(password);\n    } else {\n        PyErr_SetString(PyExc_TypeError, bad_type_error);\n        goto error;\n    }\n\n    if (size > (Py_ssize_t)INT_MAX) {\n        PyErr_Format(PyExc_ValueError,\n                     \"password cannot be longer than %d bytes\", INT_MAX);\n        goto error;\n    }\n\n    PyMem_Free(pw_info->password);\n    pw_info->password = PyMem_Malloc(size);\n    if (!pw_info->password) {\n        PyErr_SetString(PyExc_MemoryError,\n                        \"unable to allocate password buffer\");\n        goto error;\n    }\n    memcpy(pw_info->password, data, size);\n    pw_info->size = (int)size;\n\n    Py_XDECREF(password_bytes);\n    return 1;\n\nerror:\n    Py_XDECREF(password_bytes);\n    return 0;\n}\n\nstatic int\n_password_callback(char *buf, int size, int rwflag, void *userdata)\n{\n    _PySSLPasswordInfo *pw_info = (_PySSLPasswordInfo*) userdata;\n    PyObject *fn_ret = NULL;\n\n    PySSL_END_ALLOW_THREADS_S(pw_info->thread_state);\n\n    if (pw_info->error) {\n        /* already failed previously. OpenSSL 3.0.0-alpha14 invokes the\n         * callback multiple times which can lead to fatal Python error in\n         * exception check. */\n        goto error;\n    }\n\n    if (pw_info->callable) {\n        fn_ret = PyObject_CallNoArgs(pw_info->callable);\n        if (!fn_ret) {\n            /* TODO: It would be nice to move _ctypes_add_traceback() into the\n               core python API, so we could use it to add a frame here */\n            goto error;\n        }\n\n        if (!_pwinfo_set(pw_info, fn_ret,\n                         \"password callback must return a string\")) {\n            goto error;\n        }\n        Py_CLEAR(fn_ret);\n    }\n\n    if (pw_info->size > size) {\n        PyErr_Format(PyExc_ValueError,\n                     \"password cannot be longer than %d bytes\", size);\n        goto error;\n    }\n\n    PySSL_BEGIN_ALLOW_THREADS_S(pw_info->thread_state);\n    memcpy(buf, pw_info->password, pw_info->size);\n    return pw_info->size;\n\nerror:\n    Py_XDECREF(fn_ret);\n    PySSL_BEGIN_ALLOW_THREADS_S(pw_info->thread_state);\n    pw_info->error = 1;\n    return -1;\n}\n\n/*[clinic input]\n_ssl._SSLContext.load_cert_chain\n    certfile: object\n    keyfile: object = None\n    password: object = None\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext_load_cert_chain_impl(PySSLContext *self, PyObject *certfile,\n                                      PyObject *keyfile, PyObject *password)\n/*[clinic end generated code: output=9480bc1c380e2095 input=30bc7e967ea01a58]*/\n{\n    PyObject *certfile_bytes = NULL, *keyfile_bytes = NULL;\n    pem_password_cb *orig_passwd_cb = SSL_CTX_get_default_passwd_cb(self->ctx);\n    void *orig_passwd_userdata = SSL_CTX_get_default_passwd_cb_userdata(self->ctx);\n    _PySSLPasswordInfo pw_info = { NULL, NULL, NULL, 0, 0 };\n    int r;\n\n    errno = 0;\n    ERR_clear_error();\n    if (keyfile == Py_None)\n        keyfile = NULL;\n    if (!PyUnicode_FSConverter(certfile, &certfile_bytes)) {\n        if (PyErr_ExceptionMatches(PyExc_TypeError)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"certfile should be a valid filesystem path\");\n        }\n        return NULL;\n    }\n    if (keyfile && !PyUnicode_FSConverter(keyfile, &keyfile_bytes)) {\n        if (PyErr_ExceptionMatches(PyExc_TypeError)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"keyfile should be a valid filesystem path\");\n        }\n        goto error;\n    }\n    if (password != Py_None) {\n        if (PyCallable_Check(password)) {\n            pw_info.callable = password;\n        } else if (!_pwinfo_set(&pw_info, password,\n                                \"password should be a string or callable\")) {\n            goto error;\n        }\n        SSL_CTX_set_default_passwd_cb(self->ctx, _password_callback);\n        SSL_CTX_set_default_passwd_cb_userdata(self->ctx, &pw_info);\n    }\n    PySSL_BEGIN_ALLOW_THREADS_S(pw_info.thread_state);\n    r = SSL_CTX_use_certificate_chain_file(self->ctx,\n        PyBytes_AS_STRING(certfile_bytes));\n    PySSL_END_ALLOW_THREADS_S(pw_info.thread_state);\n    if (r != 1) {\n        if (pw_info.error) {\n            ERR_clear_error();\n            /* the password callback has already set the error information */\n        }\n        else if (errno != 0) {\n            PyErr_SetFromErrno(PyExc_OSError);\n            ERR_clear_error();\n        }\n        else {\n            _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n        }\n        goto error;\n    }\n    PySSL_BEGIN_ALLOW_THREADS_S(pw_info.thread_state);\n    r = SSL_CTX_use_PrivateKey_file(self->ctx,\n        PyBytes_AS_STRING(keyfile ? keyfile_bytes : certfile_bytes),\n        SSL_FILETYPE_PEM);\n    PySSL_END_ALLOW_THREADS_S(pw_info.thread_state);\n    Py_CLEAR(keyfile_bytes);\n    Py_CLEAR(certfile_bytes);\n    if (r != 1) {\n        if (pw_info.error) {\n            ERR_clear_error();\n            /* the password callback has already set the error information */\n        }\n        else if (errno != 0) {\n            PyErr_SetFromErrno(PyExc_OSError);\n            ERR_clear_error();\n        }\n        else {\n            _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n        }\n        goto error;\n    }\n    PySSL_BEGIN_ALLOW_THREADS_S(pw_info.thread_state);\n    r = SSL_CTX_check_private_key(self->ctx);\n    PySSL_END_ALLOW_THREADS_S(pw_info.thread_state);\n    if (r != 1) {\n        _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n        goto error;\n    }\n    SSL_CTX_set_default_passwd_cb(self->ctx, orig_passwd_cb);\n    SSL_CTX_set_default_passwd_cb_userdata(self->ctx, orig_passwd_userdata);\n    PyMem_Free(pw_info.password);\n    Py_RETURN_NONE;\n\nerror:\n    SSL_CTX_set_default_passwd_cb(self->ctx, orig_passwd_cb);\n    SSL_CTX_set_default_passwd_cb_userdata(self->ctx, orig_passwd_userdata);\n    PyMem_Free(pw_info.password);\n    Py_XDECREF(keyfile_bytes);\n    Py_XDECREF(certfile_bytes);\n    return NULL;\n}\n\n/* internal helper function, returns -1 on error\n */\nstatic int\n_add_ca_certs(PySSLContext *self, const void *data, Py_ssize_t len,\n              int filetype)\n{\n    BIO *biobuf = NULL;\n    X509_STORE *store;\n    int retval = -1, err, loaded = 0, was_bio_eof = 0;\n\n    assert(filetype == SSL_FILETYPE_ASN1 || filetype == SSL_FILETYPE_PEM);\n\n    if (len <= 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"Empty certificate data\");\n        return -1;\n    } else if (len > INT_MAX) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"Certificate data is too long.\");\n        return -1;\n    }\n\n    biobuf = BIO_new_mem_buf(data, (int)len);\n    if (biobuf == NULL) {\n        _setSSLError(get_state_ctx(self), \"Can't allocate buffer\", 0, __FILE__, __LINE__);\n        return -1;\n    }\n\n    store = SSL_CTX_get_cert_store(self->ctx);\n    assert(store != NULL);\n\n    while (1) {\n        X509 *cert = NULL;\n        int r;\n\n        if (filetype == SSL_FILETYPE_ASN1) {\n            if (BIO_eof(biobuf)) {\n                was_bio_eof = 1;\n                break;\n            }\n            cert = d2i_X509_bio(biobuf, NULL);\n        } else {\n            cert = PEM_read_bio_X509(biobuf, NULL,\n                                     SSL_CTX_get_default_passwd_cb(self->ctx),\n                                     SSL_CTX_get_default_passwd_cb_userdata(self->ctx)\n                                    );\n        }\n        if (cert == NULL) {\n            break;\n        }\n        r = X509_STORE_add_cert(store, cert);\n        X509_free(cert);\n        if (!r) {\n            err = ERR_peek_last_error();\n            if ((ERR_GET_LIB(err) == ERR_LIB_X509) &&\n                (ERR_GET_REASON(err) == X509_R_CERT_ALREADY_IN_HASH_TABLE)) {\n                /* cert already in hash table, not an error */\n                ERR_clear_error();\n            } else {\n                break;\n            }\n        }\n        loaded++;\n    }\n\n    err = ERR_peek_last_error();\n    if (loaded == 0) {\n        const char *msg = NULL;\n        if (filetype == SSL_FILETYPE_PEM) {\n            msg = \"no start line: cadata does not contain a certificate\";\n        } else {\n            msg = \"not enough data: cadata does not contain a certificate\";\n        }\n        _setSSLError(get_state_ctx(self), msg, 0, __FILE__, __LINE__);\n        retval = -1;\n    } else if ((filetype == SSL_FILETYPE_ASN1) && was_bio_eof) {\n        /* EOF ASN1 file, not an error */\n        ERR_clear_error();\n        retval = 0;\n    } else if ((filetype == SSL_FILETYPE_PEM) &&\n                   (ERR_GET_LIB(err) == ERR_LIB_PEM) &&\n                   (ERR_GET_REASON(err) == PEM_R_NO_START_LINE)) {\n        /* EOF PEM file, not an error */\n        ERR_clear_error();\n        retval = 0;\n    } else if (err != 0) {\n        _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n        retval = -1;\n    } else {\n        retval = 0;\n    }\n\n    BIO_free(biobuf);\n    return retval;\n}\n\n\n/*[clinic input]\n_ssl._SSLContext.load_verify_locations\n    cafile: object = None\n    capath: object = None\n    cadata: object = None\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext_load_verify_locations_impl(PySSLContext *self,\n                                            PyObject *cafile,\n                                            PyObject *capath,\n                                            PyObject *cadata)\n/*[clinic end generated code: output=454c7e41230ca551 input=42ecfe258233e194]*/\n{\n    PyObject *cafile_bytes = NULL, *capath_bytes = NULL;\n    const char *cafile_buf = NULL, *capath_buf = NULL;\n    int r = 0, ok = 1;\n\n    errno = 0;\n    if (cafile == Py_None)\n        cafile = NULL;\n    if (capath == Py_None)\n        capath = NULL;\n    if (cadata == Py_None)\n        cadata = NULL;\n\n    if (cafile == NULL && capath == NULL && cadata == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"cafile, capath and cadata cannot be all omitted\");\n        goto error;\n    }\n    if (cafile && !PyUnicode_FSConverter(cafile, &cafile_bytes)) {\n        if (PyErr_ExceptionMatches(PyExc_TypeError)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"cafile should be a valid filesystem path\");\n        }\n        goto error;\n    }\n    if (capath && !PyUnicode_FSConverter(capath, &capath_bytes)) {\n        if (PyErr_ExceptionMatches(PyExc_TypeError)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"capath should be a valid filesystem path\");\n        }\n        goto error;\n    }\n\n    /* validate cadata type and load cadata */\n    if (cadata) {\n        if (PyUnicode_Check(cadata)) {\n            PyObject *cadata_ascii = PyUnicode_AsASCIIString(cadata);\n            if (cadata_ascii == NULL) {\n                if (PyErr_ExceptionMatches(PyExc_UnicodeEncodeError)) {\n                    goto invalid_cadata;\n                }\n                goto error;\n            }\n            r = _add_ca_certs(self,\n                              PyBytes_AS_STRING(cadata_ascii),\n                              PyBytes_GET_SIZE(cadata_ascii),\n                              SSL_FILETYPE_PEM);\n            Py_DECREF(cadata_ascii);\n            if (r == -1) {\n                goto error;\n            }\n        }\n        else if (PyObject_CheckBuffer(cadata)) {\n            Py_buffer buf;\n            if (PyObject_GetBuffer(cadata, &buf, PyBUF_SIMPLE)) {\n                goto error;\n            }\n            assert(PyBuffer_IsContiguous(&buf, 'C'));\n            if (buf.ndim > 1) {\n                PyBuffer_Release(&buf);\n                PyErr_SetString(PyExc_TypeError,\n                                \"cadata should be a contiguous buffer with \"\n                                \"a single dimension\");\n                goto error;\n            }\n            r = _add_ca_certs(self, buf.buf, buf.len, SSL_FILETYPE_ASN1);\n            PyBuffer_Release(&buf);\n            if (r == -1) {\n                goto error;\n            }\n        }\n        else {\n  invalid_cadata:\n            PyErr_SetString(PyExc_TypeError,\n                            \"cadata should be an ASCII string or a \"\n                            \"bytes-like object\");\n            goto error;\n        }\n    }\n\n    /* load cafile or capath */\n    if (cafile || capath) {\n        if (cafile)\n            cafile_buf = PyBytes_AS_STRING(cafile_bytes);\n        if (capath)\n            capath_buf = PyBytes_AS_STRING(capath_bytes);\n        PySSL_BEGIN_ALLOW_THREADS\n        r = SSL_CTX_load_verify_locations(self->ctx, cafile_buf, capath_buf);\n        PySSL_END_ALLOW_THREADS\n        if (r != 1) {\n            if (errno != 0) {\n                PyErr_SetFromErrno(PyExc_OSError);\n                ERR_clear_error();\n            }\n            else {\n                _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n            }\n            goto error;\n        }\n    }\n    goto end;\n\n  error:\n    ok = 0;\n  end:\n    Py_XDECREF(cafile_bytes);\n    Py_XDECREF(capath_bytes);\n    if (ok) {\n        Py_RETURN_NONE;\n    } else {\n        return NULL;\n    }\n}\n\n/*[clinic input]\n_ssl._SSLContext.load_dh_params\n    path as filepath: object\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext_load_dh_params(PySSLContext *self, PyObject *filepath)\n/*[clinic end generated code: output=1c8e57a38e055af0 input=c8871f3c796ae1d6]*/\n{\n    FILE *f;\n    DH *dh;\n\n    f = _Py_fopen_obj(filepath, \"rb\");\n    if (f == NULL)\n        return NULL;\n\n    errno = 0;\n    PySSL_BEGIN_ALLOW_THREADS\n    dh = PEM_read_DHparams(f, NULL, NULL, NULL);\n    fclose(f);\n    PySSL_END_ALLOW_THREADS\n    if (dh == NULL) {\n        if (errno != 0) {\n            PyErr_SetFromErrnoWithFilenameObject(PyExc_OSError, filepath);\n            ERR_clear_error();\n        }\n        else {\n            _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n        }\n        return NULL;\n    }\n    if (!SSL_CTX_set_tmp_dh(self->ctx, dh)) {\n        DH_free(dh);\n        return _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n    }\n    DH_free(dh);\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n_ssl._SSLContext._wrap_socket\n    sock: object(subclass_of=\"get_state_ctx(self)->Sock_Type\")\n    server_side: bool\n    server_hostname as hostname_obj: object = None\n    *\n    owner: object = None\n    session: object = None\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext__wrap_socket_impl(PySSLContext *self, PyObject *sock,\n                                   int server_side, PyObject *hostname_obj,\n                                   PyObject *owner, PyObject *session)\n/*[clinic end generated code: output=f103f238633940b4 input=700ca8fedff53994]*/\n{\n    char *hostname = NULL;\n    PyObject *res;\n\n    /* server_hostname is either None (or absent), or to be encoded\n       as IDN A-label (ASCII str) without NULL bytes. */\n    if (hostname_obj != Py_None) {\n        if (!PyArg_Parse(hostname_obj, \"es\", \"ascii\", &hostname))\n            return NULL;\n    }\n\n    res = (PyObject *) newPySSLSocket(self, (PySocketSockObject *)sock,\n                                      server_side, hostname,\n                                      owner, session,\n                                      NULL, NULL);\n    if (hostname != NULL)\n        PyMem_Free(hostname);\n    return res;\n}\n\n/*[clinic input]\n_ssl._SSLContext._wrap_bio\n    incoming: object(subclass_of=\"get_state_ctx(self)->PySSLMemoryBIO_Type\", type=\"PySSLMemoryBIO *\")\n    outgoing: object(subclass_of=\"get_state_ctx(self)->PySSLMemoryBIO_Type\", type=\"PySSLMemoryBIO *\")\n    server_side: bool\n    server_hostname as hostname_obj: object = None\n    *\n    owner: object = None\n    session: object = None\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext__wrap_bio_impl(PySSLContext *self, PySSLMemoryBIO *incoming,\n                                PySSLMemoryBIO *outgoing, int server_side,\n                                PyObject *hostname_obj, PyObject *owner,\n                                PyObject *session)\n/*[clinic end generated code: output=5c5d6d9b41f99332 input=a9205d097fd45a82]*/\n{\n    char *hostname = NULL;\n    PyObject *res;\n\n    /* server_hostname is either None (or absent), or to be encoded\n       as IDN A-label (ASCII str) without NULL bytes. */\n    if (hostname_obj != Py_None) {\n        if (!PyArg_Parse(hostname_obj, \"es\", \"ascii\", &hostname))\n            return NULL;\n    }\n\n    res = (PyObject *) newPySSLSocket(self, NULL, server_side, hostname,\n                                      owner, session,\n                                      incoming, outgoing);\n\n    PyMem_Free(hostname);\n    return res;\n}\n\n/*[clinic input]\n_ssl._SSLContext.session_stats\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext_session_stats_impl(PySSLContext *self)\n/*[clinic end generated code: output=0d96411c42893bfb input=7e0a81fb11102c8b]*/\n{\n    int r;\n    PyObject *value, *stats = PyDict_New();\n    if (!stats)\n        return NULL;\n\n#define ADD_STATS(SSL_NAME, KEY_NAME) \\\n    value = PyLong_FromLong(SSL_CTX_sess_ ## SSL_NAME (self->ctx)); \\\n    if (value == NULL) \\\n        goto error; \\\n    r = PyDict_SetItemString(stats, KEY_NAME, value); \\\n    Py_DECREF(value); \\\n    if (r < 0) \\\n        goto error;\n\n    ADD_STATS(number, \"number\");\n    ADD_STATS(connect, \"connect\");\n    ADD_STATS(connect_good, \"connect_good\");\n    ADD_STATS(connect_renegotiate, \"connect_renegotiate\");\n    ADD_STATS(accept, \"accept\");\n    ADD_STATS(accept_good, \"accept_good\");\n    ADD_STATS(accept_renegotiate, \"accept_renegotiate\");\n    ADD_STATS(accept, \"accept\");\n    ADD_STATS(hits, \"hits\");\n    ADD_STATS(misses, \"misses\");\n    ADD_STATS(timeouts, \"timeouts\");\n    ADD_STATS(cache_full, \"cache_full\");\n\n#undef ADD_STATS\n\n    return stats;\n\nerror:\n    Py_DECREF(stats);\n    return NULL;\n}\n\n/*[clinic input]\n_ssl._SSLContext.set_default_verify_paths\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext_set_default_verify_paths_impl(PySSLContext *self)\n/*[clinic end generated code: output=0bee74e6e09deaaa input=35f3408021463d74]*/\n{\n    int rc;\n    Py_BEGIN_ALLOW_THREADS\n    rc = SSL_CTX_set_default_verify_paths(self->ctx);\n    Py_END_ALLOW_THREADS\n    if (!rc) {\n        _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n_ssl._SSLContext.set_ecdh_curve\n    name: object\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext_set_ecdh_curve(PySSLContext *self, PyObject *name)\n/*[clinic end generated code: output=23022c196e40d7d2 input=c2bafb6f6e34726b]*/\n{\n    PyObject *name_bytes;\n    int nid;\n    if (!PyUnicode_FSConverter(name, &name_bytes))\n        return NULL;\n    assert(PyBytes_Check(name_bytes));\n    nid = OBJ_sn2nid(PyBytes_AS_STRING(name_bytes));\n    Py_DECREF(name_bytes);\n    if (nid == 0) {\n        PyErr_Format(PyExc_ValueError,\n                     \"unknown elliptic curve name %R\", name);\n        return NULL;\n    }\n#if OPENSSL_VERSION_MAJOR < 3\n    EC_KEY *key = EC_KEY_new_by_curve_name(nid);\n    if (key == NULL) {\n        _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n        return NULL;\n    }\n    SSL_CTX_set_tmp_ecdh(self->ctx, key);\n    EC_KEY_free(key);\n#else\n    if (!SSL_CTX_set1_groups(self->ctx, &nid, 1)) {\n        _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);\n        return NULL;\n    }\n#endif\n    Py_RETURN_NONE;\n}\n\nstatic int\n_servername_callback(SSL *s, int *al, void *args)\n{\n    int ret;\n    PySSLContext *sslctx = (PySSLContext *) args;\n    PySSLSocket *ssl;\n    PyObject *result;\n    /* The high-level ssl.SSLSocket object */\n    PyObject *ssl_socket;\n    const char *servername = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);\n    PyGILState_STATE gstate = PyGILState_Ensure();\n\n    if (sslctx->set_sni_cb == NULL) {\n        /* remove race condition in this the call back while if removing the\n         * callback is in progress */\n        PyGILState_Release(gstate);\n        return SSL_TLSEXT_ERR_OK;\n    }\n\n    ssl = SSL_get_app_data(s);\n    assert(Py_IS_TYPE(ssl, get_state_ctx(sslctx)->PySSLSocket_Type));\n\n    /* The servername callback expects an argument that represents the current\n     * SSL connection and that has a .context attribute that can be changed to\n     * identify the requested hostname. Since the official API is the Python\n     * level API we want to pass the callback a Python level object rather than\n     * a _ssl.SSLSocket instance. If there's an \"owner\" (typically an\n     * SSLObject) that will be passed. Otherwise if there's a socket then that\n     * will be passed. If both do not exist only then the C-level object is\n     * passed. */\n    if (ssl->owner)\n        PyWeakref_GetRef(ssl->owner, &ssl_socket);\n    else if (ssl->Socket)\n        PyWeakref_GetRef(ssl->Socket, &ssl_socket);\n    else\n        ssl_socket = Py_NewRef(ssl);\n\n    if (ssl_socket == NULL)\n        goto error;\n\n    if (servername == NULL) {\n        result = PyObject_CallFunctionObjArgs(sslctx->set_sni_cb, ssl_socket,\n                                              Py_None, sslctx, NULL);\n    }\n    else {\n        PyObject *servername_bytes;\n        PyObject *servername_str;\n\n        servername_bytes = PyBytes_FromString(servername);\n        if (servername_bytes == NULL) {\n            PyErr_WriteUnraisable((PyObject *) sslctx);\n            goto error;\n        }\n        /* server_hostname was encoded to an A-label by our caller; put it\n         * back into a str object, but still as an A-label (bpo-28414)\n         */\n        servername_str = PyUnicode_FromEncodedObject(servername_bytes, \"ascii\", NULL);\n        if (servername_str == NULL) {\n            PyErr_WriteUnraisable(servername_bytes);\n            Py_DECREF(servername_bytes);\n            goto error;\n        }\n        Py_DECREF(servername_bytes);\n        result = PyObject_CallFunctionObjArgs(\n            sslctx->set_sni_cb, ssl_socket, servername_str,\n            sslctx, NULL);\n        Py_DECREF(servername_str);\n    }\n    Py_DECREF(ssl_socket);\n\n    if (result == NULL) {\n        PyErr_WriteUnraisable(sslctx->set_sni_cb);\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        ret = SSL_TLSEXT_ERR_ALERT_FATAL;\n    }\n    else {\n        /* Result may be None, a SSLContext or an integer\n         * None and SSLContext are OK, integer or other values are an error.\n         */\n        if (result == Py_None) {\n            ret = SSL_TLSEXT_ERR_OK;\n        } else {\n            *al = (int) PyLong_AsLong(result);\n            if (PyErr_Occurred()) {\n                PyErr_WriteUnraisable(result);\n                *al = SSL_AD_INTERNAL_ERROR;\n            }\n            ret = SSL_TLSEXT_ERR_ALERT_FATAL;\n        }\n        Py_DECREF(result);\n    }\n\n    PyGILState_Release(gstate);\n    return ret;\n\nerror:\n    Py_DECREF(ssl_socket);\n    *al = SSL_AD_INTERNAL_ERROR;\n    ret = SSL_TLSEXT_ERR_ALERT_FATAL;\n    PyGILState_Release(gstate);\n    return ret;\n}\n\nstatic PyObject *\nget_sni_callback(PySSLContext *self, void *c)\n{\n    PyObject *cb = self->set_sni_cb;\n    if (cb == NULL) {\n        Py_RETURN_NONE;\n    }\n    return Py_NewRef(cb);\n}\n\nstatic int\nset_sni_callback(PySSLContext *self, PyObject *arg, void *c)\n{\n    if (self->protocol == PY_SSL_VERSION_TLS_CLIENT) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"sni_callback cannot be set on TLS_CLIENT context\");\n        return -1;\n    }\n    Py_CLEAR(self->set_sni_cb);\n    if (arg == Py_None) {\n        SSL_CTX_set_tlsext_servername_callback(self->ctx, NULL);\n    }\n    else {\n        if (!PyCallable_Check(arg)) {\n            SSL_CTX_set_tlsext_servername_callback(self->ctx, NULL);\n            PyErr_SetString(PyExc_TypeError,\n                            \"not a callable object\");\n            return -1;\n        }\n        self->set_sni_cb = Py_NewRef(arg);\n        SSL_CTX_set_tlsext_servername_callback(self->ctx, _servername_callback);\n        SSL_CTX_set_tlsext_servername_arg(self->ctx, self);\n    }\n    return 0;\n}\n\n#if OPENSSL_VERSION_NUMBER < 0x30300000L\nstatic X509_OBJECT *x509_object_dup(const X509_OBJECT *obj)\n{\n    int ok;\n    X509_OBJECT *ret = X509_OBJECT_new();\n    if (ret == NULL) {\n        return NULL;\n    }\n    switch (X509_OBJECT_get_type(obj)) {\n        case X509_LU_X509:\n            ok = X509_OBJECT_set1_X509(ret, X509_OBJECT_get0_X509(obj));\n            break;\n        case X509_LU_CRL:\n            /* X509_OBJECT_get0_X509_CRL was not const-correct prior to 3.0.*/\n            ok = X509_OBJECT_set1_X509_CRL(\n                ret, X509_OBJECT_get0_X509_CRL((X509_OBJECT *)obj));\n            break;\n        default:\n            /* We cannot duplicate unrecognized types in a polyfill, but it is\n             * safe to leave an empty object. The caller will ignore it. */\n            ok = 1;\n            break;\n    }\n    if (!ok) {\n        X509_OBJECT_free(ret);\n        return NULL;\n    }\n    return ret;\n}\n\nstatic STACK_OF(X509_OBJECT) *\nX509_STORE_get1_objects(X509_STORE *store)\n{\n    STACK_OF(X509_OBJECT) *ret;\n    if (!X509_STORE_lock(store)) {\n        return NULL;\n    }\n    ret = sk_X509_OBJECT_deep_copy(X509_STORE_get0_objects(store),\n                                   x509_object_dup, X509_OBJECT_free);\n    X509_STORE_unlock(store);\n    return ret;\n}\n#endif\n\nPyDoc_STRVAR(PySSLContext_sni_callback_doc,\n\"Set a callback that will be called when a server name is provided by the SSL/TLS client in the SNI extension.\\n\\\n\\n\\\nIf the argument is None then the callback is disabled. The method is called\\n\\\nwith the SSLSocket, the server name as a string, and the SSLContext object.\\n\\\nSee RFC 6066 for details of the SNI extension.\");\n\n/*[clinic input]\n_ssl._SSLContext.cert_store_stats\n\nReturns quantities of loaded X.509 certificates.\n\nX.509 certificates with a CA extension and certificate revocation lists\ninside the context's cert store.\n\nNOTE: Certificates in a capath directory aren't loaded unless they have\nbeen used at least once.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext_cert_store_stats_impl(PySSLContext *self)\n/*[clinic end generated code: output=5f356f4d9cca874d input=eb40dd0f6d0e40cf]*/\n{\n    X509_STORE *store;\n    STACK_OF(X509_OBJECT) *objs;\n    X509_OBJECT *obj;\n    int x509 = 0, crl = 0, ca = 0, i;\n\n    store = SSL_CTX_get_cert_store(self->ctx);\n    objs = X509_STORE_get1_objects(store);\n    if (objs == NULL) {\n        PyErr_SetString(PyExc_MemoryError, \"failed to query cert store\");\n        return NULL;\n    }\n\n    for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {\n        obj = sk_X509_OBJECT_value(objs, i);\n        switch (X509_OBJECT_get_type(obj)) {\n            case X509_LU_X509:\n                x509++;\n                if (X509_check_ca(X509_OBJECT_get0_X509(obj))) {\n                    ca++;\n                }\n                break;\n            case X509_LU_CRL:\n                crl++;\n                break;\n            default:\n                /* Ignore unrecognized types. */\n                break;\n        }\n    }\n    sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);\n    return Py_BuildValue(\"{sisisi}\", \"x509\", x509, \"crl\", crl,\n        \"x509_ca\", ca);\n}\n\n/*[clinic input]\n_ssl._SSLContext.get_ca_certs\n    binary_form: bool = False\n\nReturns a list of dicts with information of loaded CA certs.\n\nIf the optional argument is True, returns a DER-encoded copy of the CA\ncertificate.\n\nNOTE: Certificates in a capath directory aren't loaded unless they have\nbeen used at least once.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext_get_ca_certs_impl(PySSLContext *self, int binary_form)\n/*[clinic end generated code: output=0d58f148f37e2938 input=6887b5a09b7f9076]*/\n{\n    X509_STORE *store;\n    STACK_OF(X509_OBJECT) *objs;\n    PyObject *ci = NULL, *rlist = NULL;\n    int i;\n\n    if ((rlist = PyList_New(0)) == NULL) {\n        return NULL;\n    }\n\n    store = SSL_CTX_get_cert_store(self->ctx);\n    objs = X509_STORE_get1_objects(store);\n    if (objs == NULL) {\n        PyErr_SetString(PyExc_MemoryError, \"failed to query cert store\");\n        goto error;\n    }\n\n    for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {\n        X509_OBJECT *obj;\n        X509 *cert;\n\n        obj = sk_X509_OBJECT_value(objs, i);\n        if (X509_OBJECT_get_type(obj) != X509_LU_X509) {\n            /* not a x509 cert */\n            continue;\n        }\n        /* CA for any purpose */\n        cert = X509_OBJECT_get0_X509(obj);\n        if (!X509_check_ca(cert)) {\n            continue;\n        }\n        if (binary_form) {\n            ci = _certificate_to_der(get_state_ctx(self), cert);\n        } else {\n            ci = _decode_certificate(get_state_ctx(self), cert);\n        }\n        if (ci == NULL) {\n            goto error;\n        }\n        if (PyList_Append(rlist, ci) == -1) {\n            goto error;\n        }\n        Py_CLEAR(ci);\n    }\n    sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);\n    return rlist;\n\n  error:\n    sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);\n    Py_XDECREF(ci);\n    Py_XDECREF(rlist);\n    return NULL;\n}\n\n#ifndef OPENSSL_NO_PSK\nstatic unsigned int psk_client_callback(SSL *s,\n                                        const char *hint,\n                                        char *identity,\n                                        unsigned int max_identity_len,\n                                        unsigned char *psk,\n                                        unsigned int max_psk_len)\n{\n    PyGILState_STATE gstate = PyGILState_Ensure();\n    PyObject *callback = NULL;\n\n    PySSLSocket *ssl = SSL_get_app_data(s);\n    if (ssl == NULL || ssl->ctx == NULL) {\n        goto error;\n    }\n    callback = ssl->ctx->psk_client_callback;\n    if (callback == NULL) {\n        goto error;\n    }\n\n    PyObject *hint_str = (hint != NULL && hint[0] != '\\0') ?\n            PyUnicode_DecodeUTF8(hint, strlen(hint), \"strict\") :\n            Py_NewRef(Py_None);\n    if (hint_str == NULL) {\n        /* The remote side has sent an invalid UTF-8 string\n         * (breaking the standard), drop the connection without\n         * raising a decode exception. */\n        PyErr_Clear();\n        goto error;\n    }\n    PyObject *result = PyObject_CallFunctionObjArgs(callback, hint_str, NULL);\n    Py_DECREF(hint_str);\n\n    if (result == NULL) {\n        goto error;\n    }\n\n    const char *psk_;\n    const char *identity_;\n    Py_ssize_t psk_len_;\n    Py_ssize_t identity_len_ = 0;\n    if (!PyArg_ParseTuple(result, \"z#y#\", &identity_, &identity_len_, &psk_, &psk_len_)) {\n        Py_DECREF(result);\n        goto error;\n    }\n\n    if (identity_len_ + 1 > max_identity_len || psk_len_ > max_psk_len) {\n        Py_DECREF(result);\n        goto error;\n    }\n    memcpy(psk, psk_, psk_len_);\n    if (identity_ != NULL) {\n        memcpy(identity, identity_, identity_len_);\n    }\n    identity[identity_len_] = 0;\n\n    Py_DECREF(result);\n\n    PyGILState_Release(gstate);\n    return (unsigned int)psk_len_;\n\nerror:\n    if (PyErr_Occurred()) {\n        PyErr_WriteUnraisable(callback);\n    }\n    PyGILState_Release(gstate);\n    return 0;\n}\n#endif\n\n/*[clinic input]\n_ssl._SSLContext.set_psk_client_callback\n    callback: object\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext_set_psk_client_callback_impl(PySSLContext *self,\n                                              PyObject *callback)\n/*[clinic end generated code: output=0aba86f6ed75119e input=7627bae0e5ee7635]*/\n{\n#ifndef OPENSSL_NO_PSK\n    if (self->protocol == PY_SSL_VERSION_TLS_SERVER) {\n        _setSSLError(get_state_ctx(self),\n                     \"Cannot add PSK client callback to a \"\n                     \"PROTOCOL_TLS_SERVER context\", 0, __FILE__, __LINE__);\n        return NULL;\n    }\n\n    SSL_psk_client_cb_func ssl_callback;\n    if (callback == Py_None) {\n        callback = NULL;\n        // Delete the existing callback\n        ssl_callback = NULL;\n    } else {\n        if (!PyCallable_Check(callback)) {\n            PyErr_SetString(PyExc_TypeError, \"callback must be callable\");\n            return NULL;\n        }\n        ssl_callback = psk_client_callback;\n    }\n\n    Py_XDECREF(self->psk_client_callback);\n    Py_XINCREF(callback);\n\n    self->psk_client_callback = callback;\n    SSL_CTX_set_psk_client_callback(self->ctx, ssl_callback);\n\n    Py_RETURN_NONE;\n#else\n    PyErr_SetString(PyExc_NotImplementedError,\n                    \"TLS-PSK is not supported by your OpenSSL version.\");\n    return NULL;\n#endif\n}\n\n#ifndef OPENSSL_NO_PSK\nstatic unsigned int psk_server_callback(SSL *s,\n                                        const char *identity,\n                                        unsigned char *psk,\n                                        unsigned int max_psk_len)\n{\n    PyGILState_STATE gstate = PyGILState_Ensure();\n    PyObject *callback = NULL;\n\n    PySSLSocket *ssl = SSL_get_app_data(s);\n    if (ssl == NULL || ssl->ctx == NULL) {\n        goto error;\n    }\n    callback = ssl->ctx->psk_server_callback;\n    if (callback == NULL) {\n        goto error;\n    }\n\n    PyObject *identity_str = (identity != NULL && identity[0] != '\\0') ?\n            PyUnicode_DecodeUTF8(identity, strlen(identity), \"strict\") :\n            Py_NewRef(Py_None);\n    if (identity_str == NULL) {\n        /* The remote side has sent an invalid UTF-8 string\n         * (breaking the standard), drop the connection without\n         * raising a decode exception. */\n        PyErr_Clear();\n        goto error;\n    }\n    PyObject *result = PyObject_CallFunctionObjArgs(callback, identity_str, NULL);\n    Py_DECREF(identity_str);\n\n    if (result == NULL) {\n        goto error;\n    }\n\n    char *psk_;\n    Py_ssize_t psk_len_;\n    if (PyBytes_AsStringAndSize(result, &psk_, &psk_len_) < 0) {\n        Py_DECREF(result);\n        goto error;\n    }\n\n    if (psk_len_ > max_psk_len) {\n        Py_DECREF(result);\n        goto error;\n    }\n    memcpy(psk, psk_, psk_len_);\n\n    Py_DECREF(result);\n\n    PyGILState_Release(gstate);\n    return (unsigned int)psk_len_;\n\nerror:\n    if (PyErr_Occurred()) {\n        PyErr_WriteUnraisable(callback);\n    }\n    PyGILState_Release(gstate);\n    return 0;\n}\n#endif\n\n/*[clinic input]\n_ssl._SSLContext.set_psk_server_callback\n    callback: object\n    identity_hint: str(accept={str, NoneType}) = None\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl__SSLContext_set_psk_server_callback_impl(PySSLContext *self,\n                                              PyObject *callback,\n                                              const char *identity_hint)\n/*[clinic end generated code: output=1f4d6a4e09a92b03 input=65d4b6022aa85ea3]*/\n{\n#ifndef OPENSSL_NO_PSK\n    if (self->protocol == PY_SSL_VERSION_TLS_CLIENT) {\n        _setSSLError(get_state_ctx(self),\n                     \"Cannot add PSK server callback to a \"\n                     \"PROTOCOL_TLS_CLIENT context\", 0, __FILE__, __LINE__);\n        return NULL;\n    }\n\n    SSL_psk_server_cb_func ssl_callback;\n    if (callback == Py_None) {\n        callback = NULL;\n        // Delete the existing callback and hint\n        ssl_callback = NULL;\n        identity_hint = NULL;\n    } else {\n        if (!PyCallable_Check(callback)) {\n            PyErr_SetString(PyExc_TypeError, \"callback must be callable\");\n            return NULL;\n        }\n        ssl_callback = psk_server_callback;\n    }\n\n    if (SSL_CTX_use_psk_identity_hint(self->ctx, identity_hint) != 1) {\n        PyErr_SetString(PyExc_ValueError, \"failed to set identity hint\");\n        return NULL;\n    }\n\n    Py_XDECREF(self->psk_server_callback);\n    Py_XINCREF(callback);\n\n    self->psk_server_callback = callback;\n    SSL_CTX_set_psk_server_callback(self->ctx, ssl_callback);\n\n    Py_RETURN_NONE;\n#else\n    PyErr_SetString(PyExc_NotImplementedError,\n                    \"TLS-PSK is not supported by your OpenSSL version.\");\n    return NULL;\n#endif\n}\n\n\nstatic PyGetSetDef context_getsetlist[] = {\n    {\"check_hostname\", (getter) get_check_hostname,\n                       (setter) set_check_hostname, NULL},\n    {\"_host_flags\", (getter) get_host_flags,\n                    (setter) set_host_flags, NULL},\n    {\"minimum_version\", (getter) get_minimum_version,\n                        (setter) set_minimum_version, NULL},\n    {\"maximum_version\", (getter) get_maximum_version,\n                        (setter) set_maximum_version, NULL},\n    {\"keylog_filename\", (getter) _PySSLContext_get_keylog_filename,\n                        (setter) _PySSLContext_set_keylog_filename, NULL},\n    {\"_msg_callback\", (getter) _PySSLContext_get_msg_callback,\n                      (setter) _PySSLContext_set_msg_callback, NULL},\n    {\"sni_callback\", (getter) get_sni_callback,\n                     (setter) set_sni_callback, PySSLContext_sni_callback_doc},\n#ifdef TLS1_3_VERSION\n    {\"num_tickets\", (getter) get_num_tickets,\n                    (setter) set_num_tickets, PySSLContext_num_tickets_doc},\n#endif\n    {\"options\", (getter) get_options,\n                (setter) set_options, NULL},\n    {\"post_handshake_auth\", (getter) get_post_handshake_auth,\n#ifdef TLS1_3_VERSION\n                            (setter) set_post_handshake_auth,\n#else\n                            NULL,\n#endif\n                            NULL},\n    {\"protocol\", (getter) get_protocol,\n                 NULL, NULL},\n    {\"verify_flags\", (getter) get_verify_flags,\n                     (setter) set_verify_flags, NULL},\n    {\"verify_mode\", (getter) get_verify_mode,\n                    (setter) set_verify_mode, NULL},\n    {\"security_level\", (getter) get_security_level,\n                       NULL, PySSLContext_security_level_doc},\n    {NULL},            /* sentinel */\n};\n\nstatic struct PyMethodDef context_methods[] = {\n    _SSL__SSLCONTEXT__WRAP_SOCKET_METHODDEF\n    _SSL__SSLCONTEXT__WRAP_BIO_METHODDEF\n    _SSL__SSLCONTEXT_SET_CIPHERS_METHODDEF\n    _SSL__SSLCONTEXT__SET_ALPN_PROTOCOLS_METHODDEF\n    _SSL__SSLCONTEXT_LOAD_CERT_CHAIN_METHODDEF\n    _SSL__SSLCONTEXT_LOAD_DH_PARAMS_METHODDEF\n    _SSL__SSLCONTEXT_LOAD_VERIFY_LOCATIONS_METHODDEF\n    _SSL__SSLCONTEXT_SESSION_STATS_METHODDEF\n    _SSL__SSLCONTEXT_SET_DEFAULT_VERIFY_PATHS_METHODDEF\n    _SSL__SSLCONTEXT_SET_ECDH_CURVE_METHODDEF\n    _SSL__SSLCONTEXT_CERT_STORE_STATS_METHODDEF\n    _SSL__SSLCONTEXT_GET_CA_CERTS_METHODDEF\n    _SSL__SSLCONTEXT_GET_CIPHERS_METHODDEF\n    _SSL__SSLCONTEXT_SET_PSK_CLIENT_CALLBACK_METHODDEF\n    _SSL__SSLCONTEXT_SET_PSK_SERVER_CALLBACK_METHODDEF\n    {NULL, NULL}        /* sentinel */\n};\n\nstatic PyType_Slot PySSLContext_slots[] = {\n    {Py_tp_methods, context_methods},\n    {Py_tp_getset, context_getsetlist},\n    {Py_tp_new, _ssl__SSLContext},\n    {Py_tp_dealloc, context_dealloc},\n    {Py_tp_traverse, context_traverse},\n    {Py_tp_clear, context_clear},\n    {0, 0},\n};\n\nstatic PyType_Spec PySSLContext_spec = {\n    .name = \"_ssl._SSLContext\",\n    .basicsize = sizeof(PySSLContext),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC |\n              Py_TPFLAGS_IMMUTABLETYPE),\n    .slots = PySSLContext_slots,\n};\n\n\n/*\n * MemoryBIO objects\n */\n\n/*[clinic input]\n@classmethod\n_ssl.MemoryBIO.__new__\n\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl_MemoryBIO_impl(PyTypeObject *type)\n/*[clinic end generated code: output=8820a58db78330ac input=26d22e4909ecb1b5]*/\n{\n    BIO *bio;\n    PySSLMemoryBIO *self;\n\n    bio = BIO_new(BIO_s_mem());\n    if (bio == NULL) {\n        PyErr_SetString(PyExc_MemoryError, \"failed to allocate BIO\");\n        return NULL;\n    }\n    /* Since our BIO is non-blocking an empty read() does not indicate EOF,\n     * just that no data is currently available. The SSL routines should retry\n     * the read, which we can achieve by calling BIO_set_retry_read(). */\n    BIO_set_retry_read(bio);\n    BIO_set_mem_eof_return(bio, -1);\n\n    assert(type != NULL && type->tp_alloc != NULL);\n    self = (PySSLMemoryBIO *) type->tp_alloc(type, 0);\n    if (self == NULL) {\n        BIO_free(bio);\n        return NULL;\n    }\n    self->bio = bio;\n    self->eof_written = 0;\n\n    return (PyObject *) self;\n}\n\nstatic int\nmemory_bio_traverse(PySSLMemoryBIO *self, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(self));\n    return 0;\n}\n\nstatic void\nmemory_bio_dealloc(PySSLMemoryBIO *self)\n{\n    PyTypeObject *tp = Py_TYPE(self);\n    PyObject_GC_UnTrack(self);\n    BIO_free(self->bio);\n    Py_TYPE(self)->tp_free(self);\n    Py_DECREF(tp);\n}\n\nstatic PyObject *\nmemory_bio_get_pending(PySSLMemoryBIO *self, void *c)\n{\n    return PyLong_FromSize_t(BIO_ctrl_pending(self->bio));\n}\n\nPyDoc_STRVAR(PySSL_memory_bio_pending_doc,\n\"The number of bytes pending in the memory BIO.\");\n\nstatic PyObject *\nmemory_bio_get_eof(PySSLMemoryBIO *self, void *c)\n{\n    return PyBool_FromLong((BIO_ctrl_pending(self->bio) == 0)\n                           && self->eof_written);\n}\n\nPyDoc_STRVAR(PySSL_memory_bio_eof_doc,\n\"Whether the memory BIO is at EOF.\");\n\n/*[clinic input]\n_ssl.MemoryBIO.read\n    size as len: int = -1\n    /\n\nRead up to size bytes from the memory BIO.\n\nIf size is not specified, read the entire buffer.\nIf the return value is an empty bytes instance, this means either\nEOF or that no data is available. Use the \"eof\" property to\ndistinguish between the two.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl_MemoryBIO_read_impl(PySSLMemoryBIO *self, int len)\n/*[clinic end generated code: output=a657aa1e79cd01b3 input=574d7be06a902366]*/\n{\n    int avail, nbytes;\n    PyObject *result;\n\n    avail = (int)Py_MIN(BIO_ctrl_pending(self->bio), INT_MAX);\n    if ((len < 0) || (len > avail))\n        len = avail;\n\n    result = PyBytes_FromStringAndSize(NULL, len);\n    if ((result == NULL) || (len == 0))\n        return result;\n\n    nbytes = BIO_read(self->bio, PyBytes_AS_STRING(result), len);\n    if (nbytes < 0) {\n        _sslmodulestate *state = get_state_mbio(self);\n        Py_DECREF(result);\n        _setSSLError(state, NULL, 0, __FILE__, __LINE__);\n        return NULL;\n    }\n\n    /* There should never be any short reads but check anyway. */\n    if (nbytes < len) {\n        _PyBytes_Resize(&result, nbytes);\n    }\n\n    return result;\n}\n\n/*[clinic input]\n_ssl.MemoryBIO.write\n    b: Py_buffer\n    /\n\nWrites the bytes b into the memory BIO.\n\nReturns the number of bytes written.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl_MemoryBIO_write_impl(PySSLMemoryBIO *self, Py_buffer *b)\n/*[clinic end generated code: output=156ec59110d75935 input=e45757b3e17c4808]*/\n{\n    int nbytes;\n\n    if (b->len > INT_MAX) {\n        PyErr_Format(PyExc_OverflowError,\n                     \"string longer than %d bytes\", INT_MAX);\n        return NULL;\n    }\n\n    if (self->eof_written) {\n        PyObject *module = PyType_GetModule(Py_TYPE(self));\n        if (module == NULL)\n            return NULL;\n        PyErr_SetString(get_ssl_state(module)->PySSLErrorObject,\n                        \"cannot write() after write_eof()\");\n        return NULL;\n    }\n\n    nbytes = BIO_write(self->bio, b->buf, (int)b->len);\n    if (nbytes < 0) {\n        _sslmodulestate *state = get_state_mbio(self);\n        _setSSLError(state, NULL, 0, __FILE__, __LINE__);\n        return NULL;\n    }\n\n    return PyLong_FromLong(nbytes);\n}\n\n/*[clinic input]\n_ssl.MemoryBIO.write_eof\n\nWrite an EOF marker to the memory BIO.\n\nWhen all data has been read, the \"eof\" property will be True.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl_MemoryBIO_write_eof_impl(PySSLMemoryBIO *self)\n/*[clinic end generated code: output=d4106276ccd1ed34 input=56a945f1d29e8bd6]*/\n{\n    self->eof_written = 1;\n    /* After an EOF is written, a zero return from read() should be a real EOF\n     * i.e. it should not be retried. Clear the SHOULD_RETRY flag. */\n    BIO_clear_retry_flags(self->bio);\n    BIO_set_mem_eof_return(self->bio, 0);\n\n    Py_RETURN_NONE;\n}\n\nstatic PyGetSetDef memory_bio_getsetlist[] = {\n    {\"pending\", (getter) memory_bio_get_pending, NULL,\n                PySSL_memory_bio_pending_doc},\n    {\"eof\", (getter) memory_bio_get_eof, NULL,\n            PySSL_memory_bio_eof_doc},\n    {NULL},            /* sentinel */\n};\n\nstatic struct PyMethodDef memory_bio_methods[] = {\n    _SSL_MEMORYBIO_READ_METHODDEF\n    _SSL_MEMORYBIO_WRITE_METHODDEF\n    _SSL_MEMORYBIO_WRITE_EOF_METHODDEF\n    {NULL, NULL}        /* sentinel */\n};\n\nstatic PyType_Slot PySSLMemoryBIO_slots[] = {\n    {Py_tp_methods, memory_bio_methods},\n    {Py_tp_getset, memory_bio_getsetlist},\n    {Py_tp_new, _ssl_MemoryBIO},\n    {Py_tp_dealloc, memory_bio_dealloc},\n    {Py_tp_traverse, memory_bio_traverse},\n    {0, 0},\n};\n\nstatic PyType_Spec PySSLMemoryBIO_spec = {\n    .name = \"_ssl.MemoryBIO\",\n    .basicsize = sizeof(PySSLMemoryBIO),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE |\n              Py_TPFLAGS_HAVE_GC),\n    .slots = PySSLMemoryBIO_slots,\n};\n\n/*\n * SSL Session object\n */\n\nstatic void\nPySSLSession_dealloc(PySSLSession *self)\n{\n    PyTypeObject *tp = Py_TYPE(self);\n    /* bpo-31095: UnTrack is needed before calling any callbacks */\n    PyObject_GC_UnTrack(self);\n    Py_XDECREF(self->ctx);\n    if (self->session != NULL) {\n        SSL_SESSION_free(self->session);\n    }\n    PyObject_GC_Del(self);\n    Py_DECREF(tp);\n}\n\nstatic PyObject *\nPySSLSession_richcompare(PyObject *left, PyObject *right, int op)\n{\n    int result;\n    PyTypeObject *sesstype = ((PySSLSession*)left)->ctx->state->PySSLSession_Type;\n\n    if (left == NULL || right == NULL) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n\n    if (!Py_IS_TYPE(left, sesstype) || !Py_IS_TYPE(right, sesstype)) {\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n\n    if (left == right) {\n        result = 0;\n    } else {\n        const unsigned char *left_id, *right_id;\n        unsigned int left_len, right_len;\n        left_id = SSL_SESSION_get_id(((PySSLSession *)left)->session,\n                                     &left_len);\n        right_id = SSL_SESSION_get_id(((PySSLSession *)right)->session,\n                                      &right_len);\n        if (left_len == right_len) {\n            result = memcmp(left_id, right_id, left_len);\n        } else {\n            result = 1;\n        }\n    }\n\n    switch (op) {\n      case Py_EQ:\n        if (result == 0) {\n            Py_RETURN_TRUE;\n        } else {\n            Py_RETURN_FALSE;\n        }\n        break;\n      case Py_NE:\n        if (result != 0) {\n            Py_RETURN_TRUE;\n        } else {\n            Py_RETURN_FALSE;\n        }\n        break;\n      case Py_LT:\n      case Py_LE:\n      case Py_GT:\n      case Py_GE:\n        Py_RETURN_NOTIMPLEMENTED;\n        break;\n      default:\n        PyErr_BadArgument();\n        return NULL;\n    }\n}\n\nstatic int\nPySSLSession_traverse(PySSLSession *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->ctx);\n    Py_VISIT(Py_TYPE(self));\n    return 0;\n}\n\nstatic int\nPySSLSession_clear(PySSLSession *self)\n{\n    Py_CLEAR(self->ctx);\n    return 0;\n}\n\n\nstatic PyObject *\nPySSLSession_get_time(PySSLSession *self, void *closure) {\n#if OPENSSL_VERSION_NUMBER >= 0x30300000L\n    return _PyLong_FromTime_t(SSL_SESSION_get_time_ex(self->session));\n#else\n    return PyLong_FromLong(SSL_SESSION_get_time(self->session));\n#endif\n}\n\nPyDoc_STRVAR(PySSLSession_get_time_doc,\n\"Session creation time (seconds since epoch).\");\n\n\nstatic PyObject *\nPySSLSession_get_timeout(PySSLSession *self, void *closure) {\n    return PyLong_FromLong(SSL_SESSION_get_timeout(self->session));\n}\n\nPyDoc_STRVAR(PySSLSession_get_timeout_doc,\n\"Session timeout (delta in seconds).\");\n\n\nstatic PyObject *\nPySSLSession_get_ticket_lifetime_hint(PySSLSession *self, void *closure) {\n    unsigned long hint = SSL_SESSION_get_ticket_lifetime_hint(self->session);\n    return PyLong_FromUnsignedLong(hint);\n}\n\nPyDoc_STRVAR(PySSLSession_get_ticket_lifetime_hint_doc,\n\"Ticket life time hint.\");\n\n\nstatic PyObject *\nPySSLSession_get_session_id(PySSLSession *self, void *closure) {\n    const unsigned char *id;\n    unsigned int len;\n    id = SSL_SESSION_get_id(self->session, &len);\n    return PyBytes_FromStringAndSize((const char *)id, len);\n}\n\nPyDoc_STRVAR(PySSLSession_get_session_id_doc,\n\"Session id\");\n\n\nstatic PyObject *\nPySSLSession_get_has_ticket(PySSLSession *self, void *closure) {\n    if (SSL_SESSION_has_ticket(self->session)) {\n        Py_RETURN_TRUE;\n    } else {\n        Py_RETURN_FALSE;\n    }\n}\n\nPyDoc_STRVAR(PySSLSession_get_has_ticket_doc,\n\"Does the session contain a ticket?\");\n\n\nstatic PyGetSetDef PySSLSession_getsetlist[] = {\n    {\"has_ticket\", (getter) PySSLSession_get_has_ticket, NULL,\n              PySSLSession_get_has_ticket_doc},\n    {\"id\",   (getter) PySSLSession_get_session_id, NULL,\n              PySSLSession_get_session_id_doc},\n    {\"ticket_lifetime_hint\", (getter) PySSLSession_get_ticket_lifetime_hint,\n              NULL, PySSLSession_get_ticket_lifetime_hint_doc},\n    {\"time\", (getter) PySSLSession_get_time, NULL,\n              PySSLSession_get_time_doc},\n    {\"timeout\", (getter) PySSLSession_get_timeout, NULL,\n              PySSLSession_get_timeout_doc},\n    {NULL},            /* sentinel */\n};\n\nstatic PyType_Slot PySSLSession_slots[] = {\n    {Py_tp_getset,PySSLSession_getsetlist},\n    {Py_tp_richcompare, PySSLSession_richcompare},\n    {Py_tp_dealloc, PySSLSession_dealloc},\n    {Py_tp_traverse, PySSLSession_traverse},\n    {Py_tp_clear, PySSLSession_clear},\n    {0, 0},\n};\n\nstatic PyType_Spec PySSLSession_spec = {\n    .name = \"_ssl.SSLSession\",\n    .basicsize = sizeof(PySSLSession),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n              Py_TPFLAGS_IMMUTABLETYPE |\n              Py_TPFLAGS_DISALLOW_INSTANTIATION),\n    .slots = PySSLSession_slots,\n};\n\n\n/* helper routines for seeding the SSL PRNG */\n/*[clinic input]\n_ssl.RAND_add\n    string as view: Py_buffer(accept={str, buffer})\n    entropy: double\n    /\n\nMix string into the OpenSSL PRNG state.\n\nentropy (a float) is a lower bound on the entropy contained in\nstring.  See RFC 4086.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl_RAND_add_impl(PyObject *module, Py_buffer *view, double entropy)\n/*[clinic end generated code: output=e6dd48df9c9024e9 input=5c33017422828f5c]*/\n{\n    const char *buf;\n    Py_ssize_t len, written;\n\n    buf = (const char *)view->buf;\n    len = view->len;\n    do {\n        written = Py_MIN(len, INT_MAX);\n        RAND_add(buf, (int)written, entropy);\n        buf += written;\n        len -= written;\n    } while (len);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nPySSL_RAND(PyObject *module, int len, int pseudo)\n{\n    int ok;\n    PyObject *bytes;\n    unsigned long err;\n    const char *errstr;\n    PyObject *v;\n\n    if (len < 0) {\n        PyErr_SetString(PyExc_ValueError, \"num must be positive\");\n        return NULL;\n    }\n\n    bytes = PyBytes_FromStringAndSize(NULL, len);\n    if (bytes == NULL)\n        return NULL;\n    if (pseudo) {\n        ok = RAND_bytes((unsigned char*)PyBytes_AS_STRING(bytes), len);\n        if (ok == 0 || ok == 1)\n            return Py_BuildValue(\"NO\", bytes, ok == 1 ? Py_True : Py_False);\n    }\n    else {\n        ok = RAND_bytes((unsigned char*)PyBytes_AS_STRING(bytes), len);\n        if (ok == 1)\n            return bytes;\n    }\n    Py_DECREF(bytes);\n\n    err = ERR_get_error();\n    errstr = ERR_reason_error_string(err);\n    v = Py_BuildValue(\"(ks)\", err, errstr);\n    if (v != NULL) {\n        PyErr_SetObject(get_ssl_state(module)->PySSLErrorObject, v);\n        Py_DECREF(v);\n    }\n    return NULL;\n}\n\n/*[clinic input]\n_ssl.RAND_bytes\n    n: int\n    /\n\nGenerate n cryptographically strong pseudo-random bytes.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl_RAND_bytes_impl(PyObject *module, int n)\n/*[clinic end generated code: output=977da635e4838bc7 input=678ddf2872dfebfc]*/\n{\n    return PySSL_RAND(module, n, 0);\n}\n\n\n/*[clinic input]\n_ssl.RAND_status\n\nReturns True if the OpenSSL PRNG has been seeded with enough data and False if not.\n\nIt is necessary to seed the PRNG with RAND_add() on some platforms before\nusing the ssl() function.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl_RAND_status_impl(PyObject *module)\n/*[clinic end generated code: output=7e0aaa2d39fdc1ad input=d5ae5aea52f36e01]*/\n{\n    return PyBool_FromLong(RAND_status());\n}\n\n/*[clinic input]\n_ssl.get_default_verify_paths\n\nReturn search paths and environment vars that are used by SSLContext's set_default_verify_paths() to load default CAs.\n\nThe values are 'cert_file_env', 'cert_file', 'cert_dir_env', 'cert_dir'.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl_get_default_verify_paths_impl(PyObject *module)\n/*[clinic end generated code: output=e5b62a466271928b input=5210c953d98c3eb5]*/\n{\n    PyObject *ofile_env = NULL;\n    PyObject *ofile = NULL;\n    PyObject *odir_env = NULL;\n    PyObject *odir = NULL;\n\n#define CONVERT(info, target) { \\\n        const char *tmp = (info); \\\n        target = NULL; \\\n        if (!tmp) { target = Py_NewRef(Py_None); } \\\n        else if ((target = PyUnicode_DecodeFSDefault(tmp)) == NULL) { \\\n            target = PyBytes_FromString(tmp); } \\\n        if (!target) goto error; \\\n    }\n\n    CONVERT(X509_get_default_cert_file_env(), ofile_env);\n    CONVERT(X509_get_default_cert_file(), ofile);\n    CONVERT(X509_get_default_cert_dir_env(), odir_env);\n    CONVERT(X509_get_default_cert_dir(), odir);\n#undef CONVERT\n\n    return Py_BuildValue(\"NNNN\", ofile_env, ofile, odir_env, odir);\n\n  error:\n    Py_XDECREF(ofile_env);\n    Py_XDECREF(ofile);\n    Py_XDECREF(odir_env);\n    Py_XDECREF(odir);\n    return NULL;\n}\n\nstatic PyObject*\nasn1obj2py(_sslmodulestate *state, ASN1_OBJECT *obj)\n{\n    int nid;\n    const char *ln, *sn;\n\n    nid = OBJ_obj2nid(obj);\n    if (nid == NID_undef) {\n        PyErr_Format(PyExc_ValueError, \"Unknown object\");\n        return NULL;\n    }\n    sn = OBJ_nid2sn(nid);\n    ln = OBJ_nid2ln(nid);\n    return Py_BuildValue(\"issN\", nid, sn, ln, _asn1obj2py(state, obj, 1));\n}\n\n/*[clinic input]\n_ssl.txt2obj\n    txt: str\n    name: bool = False\n\nLookup NID, short name, long name and OID of an ASN1_OBJECT.\n\nBy default objects are looked up by OID. With name=True short and\nlong name are also matched.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl_txt2obj_impl(PyObject *module, const char *txt, int name)\n/*[clinic end generated code: output=c38e3991347079c1 input=1c1e7d0aa7c48602]*/\n{\n    PyObject *result = NULL;\n    ASN1_OBJECT *obj;\n\n    obj = OBJ_txt2obj(txt, name ? 0 : 1);\n    if (obj == NULL) {\n        PyErr_Format(PyExc_ValueError, \"unknown object '%.100s'\", txt);\n        return NULL;\n    }\n    result = asn1obj2py(get_ssl_state(module), obj);\n    ASN1_OBJECT_free(obj);\n    return result;\n}\n\n/*[clinic input]\n_ssl.nid2obj\n    nid: int\n    /\n\nLookup NID, short name, long name and OID of an ASN1_OBJECT by NID.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl_nid2obj_impl(PyObject *module, int nid)\n/*[clinic end generated code: output=4a98ab691cd4f84a input=51787a3bee7d8f98]*/\n{\n    PyObject *result = NULL;\n    ASN1_OBJECT *obj;\n\n    if (nid < NID_undef) {\n        PyErr_SetString(PyExc_ValueError, \"NID must be positive.\");\n        return NULL;\n    }\n    obj = OBJ_nid2obj(nid);\n    if (obj == NULL) {\n        PyErr_Format(PyExc_ValueError, \"unknown NID %i\", nid);\n        return NULL;\n    }\n    result = asn1obj2py(get_ssl_state(module), obj);\n    ASN1_OBJECT_free(obj);\n    return result;\n}\n\n#ifdef _MSC_VER\n\nstatic PyObject*\ncertEncodingType(DWORD encodingType)\n{\n    static PyObject *x509_asn = NULL;\n    static PyObject *pkcs_7_asn = NULL;\n\n    if (x509_asn == NULL) {\n        x509_asn = PyUnicode_InternFromString(\"x509_asn\");\n        if (x509_asn == NULL)\n            return NULL;\n    }\n    if (pkcs_7_asn == NULL) {\n        pkcs_7_asn = PyUnicode_InternFromString(\"pkcs_7_asn\");\n        if (pkcs_7_asn == NULL)\n            return NULL;\n    }\n    switch(encodingType) {\n    case X509_ASN_ENCODING:\n        return Py_NewRef(x509_asn);\n    case PKCS_7_ASN_ENCODING:\n        return Py_NewRef(pkcs_7_asn);\n    default:\n        return PyLong_FromLong(encodingType);\n    }\n}\n\nstatic PyObject*\nparseKeyUsage(PCCERT_CONTEXT pCertCtx, DWORD flags)\n{\n    CERT_ENHKEY_USAGE *usage;\n    DWORD size, error, i;\n    PyObject *retval;\n\n    if (!CertGetEnhancedKeyUsage(pCertCtx, flags, NULL, &size)) {\n        error = GetLastError();\n        if (error == CRYPT_E_NOT_FOUND) {\n            Py_RETURN_TRUE;\n        }\n        return PyErr_SetFromWindowsErr(error);\n    }\n\n    usage = (CERT_ENHKEY_USAGE*)PyMem_Malloc(size);\n    if (usage == NULL) {\n        return PyErr_NoMemory();\n    }\n\n    /* Now get the actual enhanced usage property */\n    if (!CertGetEnhancedKeyUsage(pCertCtx, flags, usage, &size)) {\n        PyMem_Free(usage);\n        error = GetLastError();\n        if (error == CRYPT_E_NOT_FOUND) {\n            Py_RETURN_TRUE;\n        }\n        return PyErr_SetFromWindowsErr(error);\n    }\n    retval = PyFrozenSet_New(NULL);\n    if (retval == NULL) {\n        goto error;\n    }\n    for (i = 0; i < usage->cUsageIdentifier; ++i) {\n        if (usage->rgpszUsageIdentifier[i]) {\n            PyObject *oid;\n            int err;\n            oid = PyUnicode_FromString(usage->rgpszUsageIdentifier[i]);\n            if (oid == NULL) {\n                Py_CLEAR(retval);\n                goto error;\n            }\n            err = PySet_Add(retval, oid);\n            Py_DECREF(oid);\n            if (err == -1) {\n                Py_CLEAR(retval);\n                goto error;\n            }\n        }\n    }\n  error:\n    PyMem_Free(usage);\n    return retval;\n}\n\nstatic HCERTSTORE\nssl_collect_certificates(const char *store_name)\n{\n/* this function collects the system certificate stores listed in\n * system_stores into a collection certificate store for being\n * enumerated. The store must be readable to be added to the\n * store collection.\n */\n\n    HCERTSTORE hCollectionStore = NULL, hSystemStore = NULL;\n    static DWORD system_stores[] = {\n        CERT_SYSTEM_STORE_LOCAL_MACHINE,\n        CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE,\n        CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY,\n        CERT_SYSTEM_STORE_CURRENT_USER,\n        CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY,\n        CERT_SYSTEM_STORE_SERVICES,\n        CERT_SYSTEM_STORE_USERS};\n    size_t i, storesAdded;\n    BOOL result;\n\n    hCollectionStore = CertOpenStore(CERT_STORE_PROV_COLLECTION, 0,\n                                     (HCRYPTPROV)NULL, 0, NULL);\n    if (!hCollectionStore) {\n        return NULL;\n    }\n    storesAdded = 0;\n    for (i = 0; i < sizeof(system_stores) / sizeof(DWORD); i++) {\n        hSystemStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, 0,\n                                     (HCRYPTPROV)NULL,\n                                     CERT_STORE_READONLY_FLAG |\n                                     system_stores[i], store_name);\n        if (hSystemStore) {\n            result = CertAddStoreToCollection(hCollectionStore, hSystemStore,\n                                     CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG, 0);\n            if (result) {\n                ++storesAdded;\n            }\n            CertCloseStore(hSystemStore, 0);  /* flag must be 0 */\n        }\n    }\n    if (storesAdded == 0) {\n        CertCloseStore(hCollectionStore, CERT_CLOSE_STORE_FORCE_FLAG);\n        return NULL;\n    }\n\n    return hCollectionStore;\n}\n\n/*[clinic input]\n_ssl.enum_certificates\n    store_name: str\n\nRetrieve certificates from Windows' cert store.\n\nstore_name may be one of 'CA', 'ROOT' or 'MY'.  The system may provide\nmore cert storages, too.  The function returns a list of (bytes,\nencoding_type, trust) tuples.  The encoding_type flag can be interpreted\nwith X509_ASN_ENCODING or PKCS_7_ASN_ENCODING. The trust setting is either\na set of OIDs or the boolean True.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl_enum_certificates_impl(PyObject *module, const char *store_name)\n/*[clinic end generated code: output=5134dc8bb3a3c893 input=915f60d70461ea4e]*/\n{\n    HCERTSTORE hCollectionStore = NULL;\n    PCCERT_CONTEXT pCertCtx = NULL;\n    PyObject *keyusage = NULL, *cert = NULL, *enc = NULL, *tup = NULL;\n    PyObject *result = NULL;\n\n    result = PySet_New(NULL);\n    if (result == NULL) {\n        return NULL;\n    }\n    hCollectionStore = ssl_collect_certificates(store_name);\n    if (hCollectionStore == NULL) {\n        Py_DECREF(result);\n        return PyErr_SetFromWindowsErr(GetLastError());\n    }\n\n    while (pCertCtx = CertEnumCertificatesInStore(hCollectionStore, pCertCtx)) {\n        cert = PyBytes_FromStringAndSize((const char*)pCertCtx->pbCertEncoded,\n                                            pCertCtx->cbCertEncoded);\n        if (!cert) {\n            Py_CLEAR(result);\n            break;\n        }\n        if ((enc = certEncodingType(pCertCtx->dwCertEncodingType)) == NULL) {\n            Py_CLEAR(result);\n            break;\n        }\n        keyusage = parseKeyUsage(pCertCtx, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG);\n        if (keyusage == Py_True) {\n            Py_DECREF(keyusage);\n            keyusage = parseKeyUsage(pCertCtx, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG);\n        }\n        if (keyusage == NULL) {\n            Py_CLEAR(result);\n            break;\n        }\n        if ((tup = PyTuple_New(3)) == NULL) {\n            Py_CLEAR(result);\n            break;\n        }\n        PyTuple_SET_ITEM(tup, 0, cert);\n        cert = NULL;\n        PyTuple_SET_ITEM(tup, 1, enc);\n        enc = NULL;\n        PyTuple_SET_ITEM(tup, 2, keyusage);\n        keyusage = NULL;\n        if (PySet_Add(result, tup) == -1) {\n            Py_CLEAR(result);\n            Py_CLEAR(tup);\n            break;\n        }\n        Py_CLEAR(tup);\n    }\n    if (pCertCtx) {\n        /* loop ended with an error, need to clean up context manually */\n        CertFreeCertificateContext(pCertCtx);\n    }\n\n    /* In error cases cert, enc and tup may not be NULL */\n    Py_XDECREF(cert);\n    Py_XDECREF(enc);\n    Py_XDECREF(keyusage);\n    Py_XDECREF(tup);\n\n    /* CERT_CLOSE_STORE_FORCE_FLAG forces freeing of memory for all contexts\n       associated with the store, in this case our collection store and the\n       associated system stores. */\n    if (!CertCloseStore(hCollectionStore, CERT_CLOSE_STORE_FORCE_FLAG)) {\n        /* This error case might shadow another exception.*/\n        Py_XDECREF(result);\n        return PyErr_SetFromWindowsErr(GetLastError());\n    }\n\n    /* convert set to list */\n    if (result == NULL) {\n        return NULL;\n    } else {\n        PyObject *lst = PySequence_List(result);\n        Py_DECREF(result);\n        return lst;\n    }\n}\n\n/*[clinic input]\n_ssl.enum_crls\n    store_name: str\n\nRetrieve CRLs from Windows' cert store.\n\nstore_name may be one of 'CA', 'ROOT' or 'MY'.  The system may provide\nmore cert storages, too.  The function returns a list of (bytes,\nencoding_type) tuples.  The encoding_type flag can be interpreted with\nX509_ASN_ENCODING or PKCS_7_ASN_ENCODING.\n[clinic start generated code]*/\n\nstatic PyObject *\n_ssl_enum_crls_impl(PyObject *module, const char *store_name)\n/*[clinic end generated code: output=bce467f60ccd03b6 input=a1f1d7629f1c5d3d]*/\n{\n    HCERTSTORE hCollectionStore = NULL;\n    PCCRL_CONTEXT pCrlCtx = NULL;\n    PyObject *crl = NULL, *enc = NULL, *tup = NULL;\n    PyObject *result = NULL;\n\n    result = PySet_New(NULL);\n    if (result == NULL) {\n        return NULL;\n    }\n    hCollectionStore = ssl_collect_certificates(store_name);\n    if (hCollectionStore == NULL) {\n        Py_DECREF(result);\n        return PyErr_SetFromWindowsErr(GetLastError());\n    }\n\n    while (pCrlCtx = CertEnumCRLsInStore(hCollectionStore, pCrlCtx)) {\n        crl = PyBytes_FromStringAndSize((const char*)pCrlCtx->pbCrlEncoded,\n                                            pCrlCtx->cbCrlEncoded);\n        if (!crl) {\n            Py_CLEAR(result);\n            break;\n        }\n        if ((enc = certEncodingType(pCrlCtx->dwCertEncodingType)) == NULL) {\n            Py_CLEAR(result);\n            break;\n        }\n        if ((tup = PyTuple_New(2)) == NULL) {\n            Py_CLEAR(result);\n            break;\n        }\n        PyTuple_SET_ITEM(tup, 0, crl);\n        crl = NULL;\n        PyTuple_SET_ITEM(tup, 1, enc);\n        enc = NULL;\n\n        if (PySet_Add(result, tup) == -1) {\n            Py_CLEAR(result);\n            Py_CLEAR(tup);\n            break;\n        }\n        Py_CLEAR(tup);\n    }\n    if (pCrlCtx) {\n        /* loop ended with an error, need to clean up context manually */\n        CertFreeCRLContext(pCrlCtx);\n    }\n\n    /* In error cases cert, enc and tup may not be NULL */\n    Py_XDECREF(crl);\n    Py_XDECREF(enc);\n    Py_XDECREF(tup);\n\n    /* CERT_CLOSE_STORE_FORCE_FLAG forces freeing of memory for all contexts\n       associated with the store, in this case our collection store and the\n       associated system stores. */\n    if (!CertCloseStore(hCollectionStore, CERT_CLOSE_STORE_FORCE_FLAG)) {\n        /* This error case might shadow another exception.*/\n        Py_XDECREF(result);\n        return PyErr_SetFromWindowsErr(GetLastError());\n    }\n    /* convert set to list */\n    if (result == NULL) {\n        return NULL;\n    } else {\n        PyObject *lst = PySequence_List(result);\n        Py_DECREF(result);\n        return lst;\n    }\n}\n\n#endif /* _MSC_VER */\n\n/* List of functions exported by this module. */\nstatic PyMethodDef PySSL_methods[] = {\n    _SSL__TEST_DECODE_CERT_METHODDEF\n    _SSL_RAND_ADD_METHODDEF\n    _SSL_RAND_BYTES_METHODDEF\n    _SSL_RAND_STATUS_METHODDEF\n    _SSL_GET_DEFAULT_VERIFY_PATHS_METHODDEF\n    _SSL_ENUM_CERTIFICATES_METHODDEF\n    _SSL_ENUM_CRLS_METHODDEF\n    _SSL_TXT2OBJ_METHODDEF\n    _SSL_NID2OBJ_METHODDEF\n    {NULL,                  NULL}            /* Sentinel */\n};\n\n\nPyDoc_STRVAR(module_doc,\n\"Implementation module for SSL socket operations.  See the socket module\\n\\\nfor documentation.\");\n\nstatic int\nsslmodule_init_exceptions(PyObject *module)\n{\n    _sslmodulestate *state = get_ssl_state(module);\n    PyObject *bases = NULL;\n\n#define add_exception(exc, name, doc, base)                                 \\\ndo {                                                                        \\\n    (exc) = PyErr_NewExceptionWithDoc(\"ssl.\" name, (doc), (base), NULL);    \\\n    if ((state) == NULL) goto error;                                        \\\n    if (PyModule_AddObjectRef(module, name, exc) < 0) goto error;           \\\n} while(0)\n\n    state->PySSLErrorObject = PyType_FromSpecWithBases(\n        &sslerror_type_spec, PyExc_OSError);\n    if (state->PySSLErrorObject == NULL) {\n        goto error;\n    }\n    if (PyModule_AddObjectRef(module, \"SSLError\", state->PySSLErrorObject) < 0) {\n        goto error;\n    }\n\n    /* ssl.CertificateError used to be a subclass of ValueError */\n    bases = PyTuple_Pack(2, state->PySSLErrorObject, PyExc_ValueError);\n    if (bases == NULL) {\n        goto error;\n    }\n    add_exception(\n        state->PySSLCertVerificationErrorObject,\n        \"SSLCertVerificationError\",\n        SSLCertVerificationError_doc,\n        bases\n    );\n    Py_CLEAR(bases);\n\n    add_exception(\n        state->PySSLZeroReturnErrorObject,\n        \"SSLZeroReturnError\",\n        SSLZeroReturnError_doc,\n        state->PySSLErrorObject\n    );\n\n    add_exception(\n        state->PySSLWantWriteErrorObject,\n        \"SSLWantWriteError\",\n        SSLWantWriteError_doc,\n        state->PySSLErrorObject\n    );\n\n    add_exception(\n        state->PySSLWantReadErrorObject,\n        \"SSLWantReadError\",\n        SSLWantReadError_doc,\n        state->PySSLErrorObject\n    );\n\n    add_exception(\n        state->PySSLSyscallErrorObject,\n        \"SSLSyscallError\",\n        SSLSyscallError_doc,\n        state->PySSLErrorObject\n    );\n\n    add_exception(\n        state->PySSLEOFErrorObject,\n        \"SSLEOFError\",\n        SSLEOFError_doc,\n        state->PySSLErrorObject\n    );\n#undef add_exception\n\n    return 0;\n  error:\n    Py_XDECREF(bases);\n    return -1;\n}\n\nstatic int\nsslmodule_init_socketapi(PyObject *module)\n{\n    _sslmodulestate *state = get_ssl_state(module);\n    PySocketModule_APIObject *sockmod = PySocketModule_ImportModuleAndAPI();\n\n    if ((sockmod == NULL) || (sockmod->Sock_Type == NULL)) {\n        return -1;\n    }\n    state->Sock_Type = (PyTypeObject*)Py_NewRef(sockmod->Sock_Type);\n    return 0;\n}\n\n\nstatic int\nsslmodule_add_option(PyObject *m, const char *name, uint64_t value)\n{\n    Py_BUILD_ASSERT(sizeof(unsigned long long) >= sizeof(value));\n    return PyModule_Add(m, name, PyLong_FromUnsignedLongLong(value));\n}\n\n\nstatic int\nsslmodule_init_constants(PyObject *m)\n{\n    if (PyModule_AddStringConstant(m, \"_DEFAULT_CIPHERS\",\n                                   PY_SSL_DEFAULT_CIPHER_STRING) < 0)\n    {\n        return -1;\n    }\n\n#define ADD_INT_CONST(NAME, VALUE) do {                 \\\n    if (PyModule_AddIntConstant(m, NAME, VALUE) < 0) {  \\\n        return -1;                                      \\\n    }                                                   \\\n} while (0)\n\n    ADD_INT_CONST(\"SSL_ERROR_ZERO_RETURN\", PY_SSL_ERROR_ZERO_RETURN);\n    ADD_INT_CONST(\"SSL_ERROR_WANT_READ\", PY_SSL_ERROR_WANT_READ);\n    ADD_INT_CONST(\"SSL_ERROR_WANT_WRITE\", PY_SSL_ERROR_WANT_WRITE);\n    ADD_INT_CONST(\"SSL_ERROR_WANT_X509_LOOKUP\", PY_SSL_ERROR_WANT_X509_LOOKUP);\n    ADD_INT_CONST(\"SSL_ERROR_SYSCALL\", PY_SSL_ERROR_SYSCALL);\n    ADD_INT_CONST(\"SSL_ERROR_SSL\", PY_SSL_ERROR_SSL);\n    ADD_INT_CONST(\"SSL_ERROR_WANT_CONNECT\", PY_SSL_ERROR_WANT_CONNECT);\n    /* non ssl.h errorcodes */\n    ADD_INT_CONST(\"SSL_ERROR_EOF\", PY_SSL_ERROR_EOF);\n    ADD_INT_CONST(\"SSL_ERROR_INVALID_ERROR_CODE\",\n                  PY_SSL_ERROR_INVALID_ERROR_CODE);\n    /* cert requirements */\n    ADD_INT_CONST(\"CERT_NONE\", PY_SSL_CERT_NONE);\n    ADD_INT_CONST(\"CERT_OPTIONAL\", PY_SSL_CERT_OPTIONAL);\n    ADD_INT_CONST(\"CERT_REQUIRED\", PY_SSL_CERT_REQUIRED);\n    /* CRL verification for verification_flags */\n    ADD_INT_CONST(\"VERIFY_DEFAULT\", 0);\n    ADD_INT_CONST(\"VERIFY_CRL_CHECK_LEAF\", X509_V_FLAG_CRL_CHECK);\n    ADD_INT_CONST(\"VERIFY_CRL_CHECK_CHAIN\",\n                  X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);\n    ADD_INT_CONST(\"VERIFY_X509_STRICT\", X509_V_FLAG_X509_STRICT);\n    ADD_INT_CONST(\"VERIFY_ALLOW_PROXY_CERTS\", X509_V_FLAG_ALLOW_PROXY_CERTS);\n    ADD_INT_CONST(\"VERIFY_X509_TRUSTED_FIRST\", X509_V_FLAG_TRUSTED_FIRST);\n\n#ifdef X509_V_FLAG_PARTIAL_CHAIN\n    ADD_INT_CONST(\"VERIFY_X509_PARTIAL_CHAIN\", X509_V_FLAG_PARTIAL_CHAIN);\n#endif\n\n    /* Alert Descriptions from ssl.h */\n    /* note RESERVED constants no longer intended for use have been removed */\n    /* http://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-6 */\n\n#define ADD_AD_CONSTANT(s) \\\n    ADD_INT_CONST(\"ALERT_DESCRIPTION_\"#s, \\\n                            SSL_AD_##s)\n\n    ADD_AD_CONSTANT(CLOSE_NOTIFY);\n    ADD_AD_CONSTANT(UNEXPECTED_MESSAGE);\n    ADD_AD_CONSTANT(BAD_RECORD_MAC);\n    ADD_AD_CONSTANT(RECORD_OVERFLOW);\n    ADD_AD_CONSTANT(DECOMPRESSION_FAILURE);\n    ADD_AD_CONSTANT(HANDSHAKE_FAILURE);\n    ADD_AD_CONSTANT(BAD_CERTIFICATE);\n    ADD_AD_CONSTANT(UNSUPPORTED_CERTIFICATE);\n    ADD_AD_CONSTANT(CERTIFICATE_REVOKED);\n    ADD_AD_CONSTANT(CERTIFICATE_EXPIRED);\n    ADD_AD_CONSTANT(CERTIFICATE_UNKNOWN);\n    ADD_AD_CONSTANT(ILLEGAL_PARAMETER);\n    ADD_AD_CONSTANT(UNKNOWN_CA);\n    ADD_AD_CONSTANT(ACCESS_DENIED);\n    ADD_AD_CONSTANT(DECODE_ERROR);\n    ADD_AD_CONSTANT(DECRYPT_ERROR);\n    ADD_AD_CONSTANT(PROTOCOL_VERSION);\n    ADD_AD_CONSTANT(INSUFFICIENT_SECURITY);\n    ADD_AD_CONSTANT(INTERNAL_ERROR);\n    ADD_AD_CONSTANT(USER_CANCELLED);\n    ADD_AD_CONSTANT(NO_RENEGOTIATION);\n    /* Not all constants are in old OpenSSL versions */\n#ifdef SSL_AD_UNSUPPORTED_EXTENSION\n    ADD_AD_CONSTANT(UNSUPPORTED_EXTENSION);\n#endif\n#ifdef SSL_AD_CERTIFICATE_UNOBTAINABLE\n    ADD_AD_CONSTANT(CERTIFICATE_UNOBTAINABLE);\n#endif\n#ifdef SSL_AD_UNRECOGNIZED_NAME\n    ADD_AD_CONSTANT(UNRECOGNIZED_NAME);\n#endif\n#ifdef SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE\n    ADD_AD_CONSTANT(BAD_CERTIFICATE_STATUS_RESPONSE);\n#endif\n#ifdef SSL_AD_BAD_CERTIFICATE_HASH_VALUE\n    ADD_AD_CONSTANT(BAD_CERTIFICATE_HASH_VALUE);\n#endif\n#ifdef SSL_AD_UNKNOWN_PSK_IDENTITY\n    ADD_AD_CONSTANT(UNKNOWN_PSK_IDENTITY);\n#endif\n\n#undef ADD_AD_CONSTANT\n\n    /* protocol versions */\n#ifndef OPENSSL_NO_SSL3\n    ADD_INT_CONST(\"PROTOCOL_SSLv3\", PY_SSL_VERSION_SSL3);\n#endif\n    ADD_INT_CONST(\"PROTOCOL_SSLv23\", PY_SSL_VERSION_TLS);\n    ADD_INT_CONST(\"PROTOCOL_TLS\", PY_SSL_VERSION_TLS);\n    ADD_INT_CONST(\"PROTOCOL_TLS_CLIENT\", PY_SSL_VERSION_TLS_CLIENT);\n    ADD_INT_CONST(\"PROTOCOL_TLS_SERVER\", PY_SSL_VERSION_TLS_SERVER);\n    ADD_INT_CONST(\"PROTOCOL_TLSv1\", PY_SSL_VERSION_TLS1);\n    ADD_INT_CONST(\"PROTOCOL_TLSv1_1\", PY_SSL_VERSION_TLS1_1);\n    ADD_INT_CONST(\"PROTOCOL_TLSv1_2\", PY_SSL_VERSION_TLS1_2);\n\n#define ADD_OPTION(NAME, VALUE) if (sslmodule_add_option(m, NAME, (VALUE)) < 0) return -1\n\n    /* protocol options */\n    ADD_OPTION(\"OP_ALL\", SSL_OP_ALL & ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);\n    ADD_OPTION(\"OP_NO_SSLv2\", SSL_OP_NO_SSLv2);\n    ADD_OPTION(\"OP_NO_SSLv3\", SSL_OP_NO_SSLv3);\n    ADD_OPTION(\"OP_NO_TLSv1\", SSL_OP_NO_TLSv1);\n    ADD_OPTION(\"OP_NO_TLSv1_1\", SSL_OP_NO_TLSv1_1);\n    ADD_OPTION(\"OP_NO_TLSv1_2\", SSL_OP_NO_TLSv1_2);\n#ifdef SSL_OP_NO_TLSv1_3\n    ADD_OPTION(\"OP_NO_TLSv1_3\", SSL_OP_NO_TLSv1_3);\n#else\n    ADD_OPTION(\"OP_NO_TLSv1_3\", 0);\n#endif\n    ADD_OPTION(\"OP_CIPHER_SERVER_PREFERENCE\",\n                            SSL_OP_CIPHER_SERVER_PREFERENCE);\n    ADD_OPTION(\"OP_SINGLE_DH_USE\", SSL_OP_SINGLE_DH_USE);\n    ADD_OPTION(\"OP_NO_TICKET\", SSL_OP_NO_TICKET);\n    ADD_OPTION(\"OP_LEGACY_SERVER_CONNECT\",\n                            SSL_OP_LEGACY_SERVER_CONNECT);\n#ifdef SSL_OP_SINGLE_ECDH_USE\n    ADD_OPTION(\"OP_SINGLE_ECDH_USE\", SSL_OP_SINGLE_ECDH_USE);\n#endif\n#ifdef SSL_OP_NO_COMPRESSION\n    ADD_OPTION(\"OP_NO_COMPRESSION\",\n                            SSL_OP_NO_COMPRESSION);\n#endif\n#ifdef SSL_OP_ENABLE_MIDDLEBOX_COMPAT\n    ADD_OPTION(\"OP_ENABLE_MIDDLEBOX_COMPAT\",\n                            SSL_OP_ENABLE_MIDDLEBOX_COMPAT);\n#endif\n#ifdef SSL_OP_NO_RENEGOTIATION\n    ADD_OPTION(\"OP_NO_RENEGOTIATION\",\n                            SSL_OP_NO_RENEGOTIATION);\n#endif\n#ifdef SSL_OP_IGNORE_UNEXPECTED_EOF\n    ADD_OPTION(\"OP_IGNORE_UNEXPECTED_EOF\",\n                            SSL_OP_IGNORE_UNEXPECTED_EOF);\n#endif\n#ifdef SSL_OP_ENABLE_KTLS\n    ADD_OPTION(\"OP_ENABLE_KTLS\", SSL_OP_ENABLE_KTLS);\n#endif\n\n#undef ADD_OPTION\n\n#ifdef X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT\n    ADD_INT_CONST(\"HOSTFLAG_ALWAYS_CHECK_SUBJECT\",\n                  X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT);\n#endif\n#ifdef X509_CHECK_FLAG_NEVER_CHECK_SUBJECT\n    ADD_INT_CONST(\"HOSTFLAG_NEVER_CHECK_SUBJECT\",\n                  X509_CHECK_FLAG_NEVER_CHECK_SUBJECT);\n#endif\n#ifdef X509_CHECK_FLAG_NO_WILDCARDS\n    ADD_INT_CONST(\"HOSTFLAG_NO_WILDCARDS\",\n                  X509_CHECK_FLAG_NO_WILDCARDS);\n#endif\n#ifdef X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS\n    ADD_INT_CONST(\"HOSTFLAG_NO_PARTIAL_WILDCARDS\",\n                  X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS);\n#endif\n#ifdef X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS\n    ADD_INT_CONST(\"HOSTFLAG_MULTI_LABEL_WILDCARDS\",\n                  X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS);\n#endif\n#ifdef X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS\n    ADD_INT_CONST(\"HOSTFLAG_SINGLE_LABEL_SUBDOMAINS\",\n                  X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS);\n#endif\n\n    /* file types */\n    ADD_INT_CONST(\"ENCODING_PEM\", PY_SSL_ENCODING_PEM);\n    ADD_INT_CONST(\"ENCODING_DER\", PY_SSL_ENCODING_DER);\n\n    /* protocol versions */\n    ADD_INT_CONST(\"PROTO_MINIMUM_SUPPORTED\", PY_PROTO_MINIMUM_SUPPORTED);\n    ADD_INT_CONST(\"PROTO_MAXIMUM_SUPPORTED\", PY_PROTO_MAXIMUM_SUPPORTED);\n    ADD_INT_CONST(\"PROTO_SSLv3\", PY_PROTO_SSLv3);\n    ADD_INT_CONST(\"PROTO_TLSv1\", PY_PROTO_TLSv1);\n    ADD_INT_CONST(\"PROTO_TLSv1_1\", PY_PROTO_TLSv1_1);\n    ADD_INT_CONST(\"PROTO_TLSv1_2\", PY_PROTO_TLSv1_2);\n    ADD_INT_CONST(\"PROTO_TLSv1_3\", PY_PROTO_TLSv1_3);\n\n#define addbool(m, key, value) \\\n    do { \\\n        PyObject *bool_obj = (value) ? Py_True : Py_False; \\\n        if (PyModule_AddObjectRef((m), (key), bool_obj) < 0) { \\\n            return -1; \\\n        } \\\n    } while (0)\n\n    addbool(m, \"HAS_SNI\", 1);\n    addbool(m, \"HAS_TLS_UNIQUE\", 1);\n    addbool(m, \"HAS_ECDH\", 1);\n    addbool(m, \"HAS_NPN\", 0);\n    addbool(m, \"HAS_ALPN\", 1);\n\n    addbool(m, \"HAS_SSLv2\", 0);\n\n#if defined(SSL3_VERSION) && !defined(OPENSSL_NO_SSL3)\n    addbool(m, \"HAS_SSLv3\", 1);\n#else\n    addbool(m, \"HAS_SSLv3\", 0);\n#endif\n\n#if defined(TLS1_VERSION) && !defined(OPENSSL_NO_TLS1)\n    addbool(m, \"HAS_TLSv1\", 1);\n#else\n    addbool(m, \"HAS_TLSv1\", 0);\n#endif\n\n#if defined(TLS1_1_VERSION) && !defined(OPENSSL_NO_TLS1_1)\n    addbool(m, \"HAS_TLSv1_1\", 1);\n#else\n    addbool(m, \"HAS_TLSv1_1\", 0);\n#endif\n\n#if defined(TLS1_2_VERSION) && !defined(OPENSSL_NO_TLS1_2)\n    addbool(m, \"HAS_TLSv1_2\", 1);\n#else\n    addbool(m, \"HAS_TLSv1_2\", 0);\n#endif\n\n#if defined(TLS1_3_VERSION) && !defined(OPENSSL_NO_TLS1_3)\n    addbool(m, \"HAS_TLSv1_3\", 1);\n#else\n    addbool(m, \"HAS_TLSv1_3\", 0);\n#endif\n\n#ifdef OPENSSL_NO_PSK\n    addbool(m, \"HAS_PSK\", 0);\n#else\n    addbool(m, \"HAS_PSK\", 1);\n#endif\n\n#undef addbool\n#undef ADD_INT_CONST\n\n    return 0;\n}\n\nstatic int\nsslmodule_init_errorcodes(PyObject *module)\n{\n    _sslmodulestate *state = get_ssl_state(module);\n\n    struct py_ssl_error_code *errcode;\n    struct py_ssl_library_code *libcode;\n\n    /* Mappings for error codes */\n    state->err_codes_to_names = PyDict_New();\n    if (state->err_codes_to_names == NULL)\n        return -1;\n    state->lib_codes_to_names = PyDict_New();\n    if (state->lib_codes_to_names == NULL)\n        return -1;\n\n    errcode = error_codes;\n    while (errcode->mnemonic != NULL) {\n        PyObject *mnemo = PyUnicode_FromString(errcode->mnemonic);\n        if (mnemo == NULL) {\n            return -1;\n        }\n        PyObject *key = Py_BuildValue(\"ii\", errcode->library, errcode->reason);\n        if (key == NULL) {\n            Py_DECREF(mnemo);\n            return -1;\n        }\n        int rc = PyDict_SetItem(state->err_codes_to_names, key, mnemo);\n        Py_DECREF(key);\n        Py_DECREF(mnemo);\n        if (rc < 0) {\n            return -1;\n        }\n        errcode++;\n    }\n\n    libcode = library_codes;\n    while (libcode->library != NULL) {\n        PyObject *mnemo, *key;\n        key = PyLong_FromLong(libcode->code);\n        mnemo = PyUnicode_FromString(libcode->library);\n        if (key == NULL || mnemo == NULL)\n            return -1;\n        if (PyDict_SetItem(state->lib_codes_to_names, key, mnemo))\n            return -1;\n        Py_DECREF(key);\n        Py_DECREF(mnemo);\n        libcode++;\n    }\n\n    return 0;\n}\n\nstatic void\nparse_openssl_version(unsigned long libver,\n                      unsigned int *major, unsigned int *minor,\n                      unsigned int *fix, unsigned int *patch,\n                      unsigned int *status)\n{\n    *status = libver & 0xF;\n    libver >>= 4;\n    *patch = libver & 0xFF;\n    libver >>= 8;\n    *fix = libver & 0xFF;\n    libver >>= 8;\n    *minor = libver & 0xFF;\n    libver >>= 8;\n    *major = libver & 0xFF;\n}\n\nstatic int\nsslmodule_init_versioninfo(PyObject *m)\n{\n    PyObject *r;\n    unsigned long libver;\n    unsigned int major, minor, fix, patch, status;\n\n    /* OpenSSL version */\n    /* SSLeay() gives us the version of the library linked against,\n       which could be different from the headers version.\n    */\n    libver = OpenSSL_version_num();\n    r = PyLong_FromUnsignedLong(libver);\n    if (PyModule_Add(m, \"OPENSSL_VERSION_NUMBER\", r) < 0)\n        return -1;\n\n    parse_openssl_version(libver, &major, &minor, &fix, &patch, &status);\n    r = Py_BuildValue(\"IIIII\", major, minor, fix, patch, status);\n    if (PyModule_Add(m, \"OPENSSL_VERSION_INFO\", r) < 0)\n        return -1;\n\n    r = PyUnicode_FromString(OpenSSL_version(OPENSSL_VERSION));\n    if (PyModule_Add(m, \"OPENSSL_VERSION\", r) < 0)\n        return -1;\n\n    libver = OPENSSL_VERSION_NUMBER;\n    parse_openssl_version(libver, &major, &minor, &fix, &patch, &status);\n    r = Py_BuildValue(\"IIIII\", major, minor, fix, patch, status);\n    if (PyModule_Add(m, \"_OPENSSL_API_VERSION\", r) < 0)\n        return -1;\n\n    return 0;\n}\n\nstatic int\nsslmodule_init_types(PyObject *module)\n{\n    _sslmodulestate *state = get_ssl_state(module);\n\n    state->PySSLContext_Type = (PyTypeObject *)PyType_FromModuleAndSpec(\n        module, &PySSLContext_spec, NULL\n    );\n    if (state->PySSLContext_Type == NULL)\n        return -1;\n\n    state->PySSLSocket_Type = (PyTypeObject *)PyType_FromModuleAndSpec(\n        module, &PySSLSocket_spec, NULL\n    );\n    if (state->PySSLSocket_Type == NULL)\n        return -1;\n\n    state->PySSLMemoryBIO_Type = (PyTypeObject *)PyType_FromModuleAndSpec(\n        module, &PySSLMemoryBIO_spec, NULL\n    );\n    if (state->PySSLMemoryBIO_Type == NULL)\n        return -1;\n\n    state->PySSLSession_Type = (PyTypeObject *)PyType_FromModuleAndSpec(\n        module, &PySSLSession_spec, NULL\n    );\n    if (state->PySSLSession_Type == NULL)\n        return -1;\n\n    state->PySSLCertificate_Type = (PyTypeObject *)PyType_FromModuleAndSpec(\n        module, &PySSLCertificate_spec, NULL\n    );\n    if (state->PySSLCertificate_Type == NULL)\n        return -1;\n\n    if (PyModule_AddType(module, state->PySSLContext_Type))\n        return -1;\n    if (PyModule_AddType(module, state->PySSLSocket_Type))\n        return -1;\n    if (PyModule_AddType(module, state->PySSLMemoryBIO_Type))\n        return -1;\n    if (PyModule_AddType(module, state->PySSLSession_Type))\n        return -1;\n    if (PyModule_AddType(module, state->PySSLCertificate_Type))\n        return -1;\n    return 0;\n}\n\nstatic int\nsslmodule_init_strings(PyObject *module)\n{\n    _sslmodulestate *state = get_ssl_state(module);\n    state->str_library = PyUnicode_InternFromString(\"library\");\n    if (state->str_library == NULL) {\n        return -1;\n    }\n    state->str_reason = PyUnicode_InternFromString(\"reason\");\n    if (state->str_reason == NULL) {\n        return -1;\n    }\n    state->str_verify_message = PyUnicode_InternFromString(\"verify_message\");\n    if (state->str_verify_message == NULL) {\n        return -1;\n    }\n    state->str_verify_code = PyUnicode_InternFromString(\"verify_code\");\n    if (state->str_verify_code == NULL) {\n        return -1;\n    }\n    return 0;\n}\n\nstatic int\nsslmodule_init_lock(PyObject *module)\n{\n    _sslmodulestate *state = get_ssl_state(module);\n    state->keylog_lock = PyThread_allocate_lock();\n    if (state->keylog_lock == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    return 0;\n}\n\nstatic PyModuleDef_Slot sslmodule_slots[] = {\n    {Py_mod_exec, sslmodule_init_types},\n    {Py_mod_exec, sslmodule_init_exceptions},\n    {Py_mod_exec, sslmodule_init_socketapi},\n    {Py_mod_exec, sslmodule_init_errorcodes},\n    {Py_mod_exec, sslmodule_init_constants},\n    {Py_mod_exec, sslmodule_init_versioninfo},\n    {Py_mod_exec, sslmodule_init_strings},\n    {Py_mod_exec, sslmodule_init_lock},\n    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},\n    {Py_mod_gil, Py_MOD_GIL_NOT_USED},\n    {0, NULL}\n};\n\nstatic int\nsslmodule_traverse(PyObject *m, visitproc visit, void *arg)\n{\n    _sslmodulestate *state = get_ssl_state(m);\n\n    Py_VISIT(state->PySSLContext_Type);\n    Py_VISIT(state->PySSLSocket_Type);\n    Py_VISIT(state->PySSLMemoryBIO_Type);\n    Py_VISIT(state->PySSLSession_Type);\n    Py_VISIT(state->PySSLCertificate_Type);\n    Py_VISIT(state->PySSLErrorObject);\n    Py_VISIT(state->PySSLCertVerificationErrorObject);\n    Py_VISIT(state->PySSLZeroReturnErrorObject);\n    Py_VISIT(state->PySSLWantReadErrorObject);\n    Py_VISIT(state->PySSLWantWriteErrorObject);\n    Py_VISIT(state->PySSLSyscallErrorObject);\n    Py_VISIT(state->PySSLEOFErrorObject);\n    Py_VISIT(state->err_codes_to_names);\n    Py_VISIT(state->lib_codes_to_names);\n    Py_VISIT(state->Sock_Type);\n\n    return 0;\n}\n\nstatic int\nsslmodule_clear(PyObject *m)\n{\n    _sslmodulestate *state = get_ssl_state(m);\n\n    Py_CLEAR(state->PySSLContext_Type);\n    Py_CLEAR(state->PySSLSocket_Type);\n    Py_CLEAR(state->PySSLMemoryBIO_Type);\n    Py_CLEAR(state->PySSLSession_Type);\n    Py_CLEAR(state->PySSLCertificate_Type);\n    Py_CLEAR(state->PySSLErrorObject);\n    Py_CLEAR(state->PySSLCertVerificationErrorObject);\n    Py_CLEAR(state->PySSLZeroReturnErrorObject);\n    Py_CLEAR(state->PySSLWantReadErrorObject);\n    Py_CLEAR(state->PySSLWantWriteErrorObject);\n    Py_CLEAR(state->PySSLSyscallErrorObject);\n    Py_CLEAR(state->PySSLEOFErrorObject);\n    Py_CLEAR(state->err_codes_to_names);\n    Py_CLEAR(state->lib_codes_to_names);\n    Py_CLEAR(state->Sock_Type);\n    Py_CLEAR(state->str_library);\n    Py_CLEAR(state->str_reason);\n    Py_CLEAR(state->str_verify_code);\n    Py_CLEAR(state->str_verify_message);\n    return 0;\n}\n\nstatic void\nsslmodule_free(void *m)\n{\n    sslmodule_clear((PyObject *)m);\n    _sslmodulestate *state = get_ssl_state(m);\n    PyThread_free_lock(state->keylog_lock);\n}\n\nstatic struct PyModuleDef _sslmodule_def = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = \"_ssl\",\n    .m_doc = module_doc,\n    .m_size = sizeof(_sslmodulestate),\n    .m_methods = PySSL_methods,\n    .m_slots = sslmodule_slots,\n    .m_traverse = sslmodule_traverse,\n    .m_clear = sslmodule_clear,\n    .m_free = sslmodule_free\n};\n\nPyMODINIT_FUNC\nPyInit__ssl(void)\n{\n    return PyModuleDef_Init(&_sslmodule_def);\n}\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-null-dereference",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 49913,
                                       "gcc/analyzer/saved_diagnostic/snode": 2558,
                                       "gcc/analyzer/saved_diagnostic/sval": "(struct PySSLMemoryBIO *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 0},
                        "level": "warning",
                        "message": {"text": "dereference of NULL 'inbio'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ssl.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 869,
                                                                       "startColumn": 9,
                                                                       "endColumn": 31},
                                                            "contextRegion": {"startLine": 869,
                                                                              "snippet": {"text": "        BIO_up_ref(inbio->bio);\n"}}},
                                       "logicalLocations": [{"name": "newPySSLSocket",
                                                             "fullyQualifiedName": "newPySSLSocket",
                                                             "decoratedName": "newPySSLSocket",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ssl.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 4240,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 35},
                                                                                                         "contextRegion": {"startLine": 4240,
                                                                                                                           "snippet": {"text": "_ssl__SSLContext__wrap_socket_impl(PySSLContext *self, PyObject *sock,\n"}}},
                                                                                    "logicalLocations": [{"name": "_ssl__SSLContext__wrap_socket_impl",
                                                                                                          "fullyQualifiedName": "_ssl__SSLContext__wrap_socket_impl",
                                                                                                          "decoratedName": "_ssl__SSLContext__wrap_socket_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_ssl__SSLContext__wrap_socket_impl'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 982,
                                                                                                                                 "dst_idx": 984,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ssl.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 4250,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 4250,
                                                                                                                           "snippet": {"text": "    if (hostname_obj != Py_None) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_ssl__SSLContext__wrap_socket_impl",
                                                                                                          "fullyQualifiedName": "_ssl__SSLContext__wrap_socket_impl",
                                                                                                          "decoratedName": "_ssl__SSLContext__wrap_socket_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 982,
                                                                                                                                 "dst_idx": 984,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ssl.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 4255,
                                                                                                                    "startColumn": 24,
                                                                                                                    "endLine": 4258,
                                                                                                                    "endColumn": 50},
                                                                                                         "contextRegion": {"startLine": 4255,
                                                                                                                           "endLine": 4258,
                                                                                                                           "snippet": {"text": "    res = (PyObject *) newPySSLSocket(self, (PySocketSockObject *)sock,\n                                      server_side, hostname,\n                                      owner, session,\n                                      NULL, NULL);\n"}}},
                                                                                    "logicalLocations": [{"name": "_ssl__SSLContext__wrap_socket_impl",
                                                                                                          "fullyQualifiedName": "_ssl__SSLContext__wrap_socket_impl",
                                                                                                          "decoratedName": "_ssl__SSLContext__wrap_socket_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 984,
                                                                                                                                 "dst_idx": 2535,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ssl.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 4255,
                                                                                                                    "startColumn": 24,
                                                                                                                    "endLine": 4258,
                                                                                                                    "endColumn": 50},
                                                                                                         "contextRegion": {"startLine": 4255,
                                                                                                                           "endLine": 4258,
                                                                                                                           "snippet": {"text": "    res = (PyObject *) newPySSLSocket(self, (PySocketSockObject *)sock,\n                                      server_side, hostname,\n                                      owner, session,\n                                      NULL, NULL);\n"}}},
                                                                                    "logicalLocations": [{"name": "_ssl__SSLContext__wrap_socket_impl",
                                                                                                          "fullyQualifiedName": "_ssl__SSLContext__wrap_socket_impl",
                                                                                                          "decoratedName": "_ssl__SSLContext__wrap_socket_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'newPySSLSocket' from '_ssl__SSLContext__wrap_socket_impl'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ssl.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 798,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 798,
                                                                                                                           "snippet": {"text": "newPySSLSocket(PySSLContext *sslctx, PySocketSockObject *sock,\n"}}},
                                                                                    "logicalLocations": [{"name": "newPySSLSocket",
                                                                                                          "fullyQualifiedName": "newPySSLSocket",
                                                                                                          "decoratedName": "newPySSLSocket",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'newPySSLSocket'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2545,
                                                                                                                                 "dst_idx": 2546,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ssl.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 825,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 825,
                                                                                                                           "snippet": {"text": "    if (self == NULL)\n"}}},
                                                                                    "logicalLocations": [{"name": "newPySSLSocket",
                                                                                                          "fullyQualifiedName": "newPySSLSocket",
                                                                                                          "decoratedName": "newPySSLSocket",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'self' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2545,
                                                                                                                                 "dst_idx": 2546,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ssl.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 828,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 828,
                                                                                                                           "snippet": {"text": "    self->ssl = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "newPySSLSocket",
                                                                                                          "fullyQualifiedName": "newPySSLSocket",
                                                                                                          "decoratedName": "newPySSLSocket",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2548,
                                                                                                                                 "dst_idx": 2554,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ssl.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 843,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 843,
                                                                                                                           "snippet": {"text": "    if (self->ssl == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "newPySSLSocket",
                                                                                                          "fullyQualifiedName": "newPySSLSocket",
                                                                                                          "decoratedName": "newPySSLSocket",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2548,
                                                                                                                                 "dst_idx": 2554,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ssl.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 849,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 849,
                                                                                                                           "snippet": {"text": "    if (socket_type == PY_SSL_SERVER) {\n"}}},
                                                                                    "logicalLocations": [{"name": "newPySSLSocket",
                                                                                                          "fullyQualifiedName": "newPySSLSocket",
                                                                                                          "decoratedName": "newPySSLSocket",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2556,
                                                                                                                                 "dst_idx": 2558,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ssl.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 863,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 863,
                                                                                                                           "snippet": {"text": "    if (sock) {\n"}}},
                                                                                    "logicalLocations": [{"name": "newPySSLSocket",
                                                                                                          "fullyQualifiedName": "newPySSLSocket",
                                                                                                          "decoratedName": "newPySSLSocket",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'sock' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 2556,
                                                                                                                                 "dst_idx": 2558,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ssl.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 869,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 31},
                                                                                                         "contextRegion": {"startLine": 869,
                                                                                                                           "snippet": {"text": "        BIO_up_ref(inbio->bio);\n"}}},
                                                                                    "logicalLocations": [{"name": "newPySSLSocket",
                                                                                                          "fullyQualifiedName": "newPySSLSocket",
                                                                                                          "decoratedName": "newPySSLSocket",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ssl.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 869,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 31},
                                                                                                         "contextRegion": {"startLine": 869,
                                                                                                                           "snippet": {"text": "        BIO_up_ref(inbio->bio);\n"}}},
                                                                                    "logicalLocations": [{"name": "newPySSLSocket",
                                                                                                          "fullyQualifiedName": "newPySSLSocket",
                                                                                                          "decoratedName": "newPySSLSocket",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "dereference of NULL 'inbio'"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 12}]}]}]}]}]}
