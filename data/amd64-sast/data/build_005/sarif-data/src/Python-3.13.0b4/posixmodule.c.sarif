{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-null-argument",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-argument"},
                                         {"id": "-Wanalyzer-fd-leak",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-fd-leak"}]}},
           "taxonomies": [{"name": "CWE",
                           "version": "4.7",
                           "organization": "MITRE",
                           "shortDescription": {"text": "The MITRE Common Weakness Enumeration"},
                           "taxa": [{"id": "775",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/775.html"},
                                    {"id": "476",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}],
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.13.0b4/"}},
           "artifacts": [{"location": {"uri": "/usr/include/unistd.h"},
                          "contents": {"text": "/* Copyright (C) 1991-2024 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <https://www.gnu.org/licenses/>.  */\n\n/*\n *\tPOSIX Standard: 2.10 Symbolic Constants\t\t<unistd.h>\n */\n\n#ifndef\t_UNISTD_H\n#define\t_UNISTD_H\t1\n\n#include <features.h>\n\n__BEGIN_DECLS\n\n/* These may be used to determine what facilities are present at compile time.\n   Their values can be obtained at run time from `sysconf'.  */\n\n#ifdef __USE_XOPEN2K8\n/* POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.  */\n# define _POSIX_VERSION\t200809L\n#elif defined __USE_XOPEN2K\n/* POSIX Standard approved as ISO/IEC 9945-1 as of December 2001.  */\n# define _POSIX_VERSION\t200112L\n#elif defined __USE_POSIX199506\n/* POSIX Standard approved as ISO/IEC 9945-1 as of June 1995.  */\n# define _POSIX_VERSION\t199506L\n#elif defined __USE_POSIX199309\n/* POSIX Standard approved as ISO/IEC 9945-1 as of September 1993.  */\n# define _POSIX_VERSION\t199309L\n#else\n/* POSIX Standard approved as ISO/IEC 9945-1 as of September 1990.  */\n# define _POSIX_VERSION\t199009L\n#endif\n\n/* These are not #ifdef __USE_POSIX2 because they are\n   in the theoretically application-owned namespace.  */\n\n#ifdef __USE_XOPEN2K8\n# define __POSIX2_THIS_VERSION\t200809L\n/* The utilities on GNU systems also correspond to this version.  */\n#elif defined __USE_XOPEN2K\n/* The utilities on GNU systems also correspond to this version.  */\n# define __POSIX2_THIS_VERSION\t200112L\n#elif defined __USE_POSIX199506\n/* The utilities on GNU systems also correspond to this version.  */\n# define __POSIX2_THIS_VERSION\t199506L\n#else\n/* The utilities on GNU systems also correspond to this version.  */\n# define __POSIX2_THIS_VERSION\t199209L\n#endif\n\n/* The utilities on GNU systems also correspond to this version.  */\n#define _POSIX2_VERSION\t__POSIX2_THIS_VERSION\n\n/* This symbol was required until the 2001 edition of POSIX.  */\n#define\t_POSIX2_C_VERSION\t__POSIX2_THIS_VERSION\n\n/* If defined, the implementation supports the\n   C Language Bindings Option.  */\n#define\t_POSIX2_C_BIND\t__POSIX2_THIS_VERSION\n\n/* If defined, the implementation supports the\n   C Language Development Utilities Option.  */\n#define\t_POSIX2_C_DEV\t__POSIX2_THIS_VERSION\n\n/* If defined, the implementation supports the\n   Software Development Utilities Option.  */\n#define\t_POSIX2_SW_DEV\t__POSIX2_THIS_VERSION\n\n/* If defined, the implementation supports the\n   creation of locales with the localedef utility.  */\n#define _POSIX2_LOCALEDEF       __POSIX2_THIS_VERSION\n\n/* X/Open version number to which the library conforms.  It is selectable.  */\n#ifdef __USE_XOPEN2K8\n# define _XOPEN_VERSION\t700\n#elif defined __USE_XOPEN2K\n# define _XOPEN_VERSION\t600\n#elif defined __USE_UNIX98\n# define _XOPEN_VERSION\t500\n#else\n# define _XOPEN_VERSION\t4\n#endif\n\n/* Commands and utilities from XPG4 are available.  */\n#define _XOPEN_XCU_VERSION\t4\n\n/* We are compatible with the old published standards as well.  */\n#define _XOPEN_XPG2\t1\n#define _XOPEN_XPG3\t1\n#define _XOPEN_XPG4\t1\n\n/* The X/Open Unix extensions are available.  */\n#define _XOPEN_UNIX\t1\n\n/* The enhanced internationalization capabilities according to XPG4.2\n   are present.  */\n#define\t_XOPEN_ENH_I18N\t1\n\n/* The legacy interfaces are also available.  */\n#define _XOPEN_LEGACY\t1\n\n\n/* Get values of POSIX options:\n\n   If these symbols are defined, the corresponding features are\n   always available.  If not, they may be available sometimes.\n   The current values can be obtained with `sysconf'.\n\n   _POSIX_JOB_CONTROL\t\tJob control is supported.\n   _POSIX_SAVED_IDS\t\tProcesses have a saved set-user-ID\n\t\t\t\tand a saved set-group-ID.\n   _POSIX_REALTIME_SIGNALS\tReal-time, queued signals are supported.\n   _POSIX_PRIORITY_SCHEDULING\tPriority scheduling is supported.\n   _POSIX_TIMERS\t\tPOSIX.4 clocks and timers are supported.\n   _POSIX_ASYNCHRONOUS_IO\tAsynchronous I/O is supported.\n   _POSIX_PRIORITIZED_IO\tPrioritized asynchronous I/O is supported.\n   _POSIX_SYNCHRONIZED_IO\tSynchronizing file data is supported.\n   _POSIX_FSYNC\t\t\tThe fsync function is present.\n   _POSIX_MAPPED_FILES\t\tMapping of files to memory is supported.\n   _POSIX_MEMLOCK\t\tLocking of all memory is supported.\n   _POSIX_MEMLOCK_RANGE\t\tLocking of ranges of memory is supported.\n   _POSIX_MEMORY_PROTECTION\tSetting of memory protections is supported.\n   _POSIX_MESSAGE_PASSING\tPOSIX.4 message queues are supported.\n   _POSIX_SEMAPHORES\t\tPOSIX.4 counting semaphores are supported.\n   _POSIX_SHARED_MEMORY_OBJECTS\tPOSIX.4 shared memory objects are supported.\n   _POSIX_THREADS\t\tPOSIX.1c pthreads are supported.\n   _POSIX_THREAD_ATTR_STACKADDR\tThread stack address attribute option supported.\n   _POSIX_THREAD_ATTR_STACKSIZE\tThread stack size attribute option supported.\n   _POSIX_THREAD_SAFE_FUNCTIONS\tThread-safe functions are supported.\n   _POSIX_THREAD_PRIORITY_SCHEDULING\n\t\t\t\tPOSIX.1c thread execution scheduling supported.\n   _POSIX_THREAD_PRIO_INHERIT\tThread priority inheritance option supported.\n   _POSIX_THREAD_PRIO_PROTECT\tThread priority protection option supported.\n   _POSIX_THREAD_PROCESS_SHARED\tProcess-shared synchronization supported.\n   _POSIX_PII\t\t\tProtocol-independent interfaces are supported.\n   _POSIX_PII_XTI\t\tXTI protocol-indep. interfaces are supported.\n   _POSIX_PII_SOCKET\t\tSocket protocol-indep. interfaces are supported.\n   _POSIX_PII_INTERNET\t\tInternet family of protocols supported.\n   _POSIX_PII_INTERNET_STREAM\tConnection-mode Internet protocol supported.\n   _POSIX_PII_INTERNET_DGRAM\tConnectionless Internet protocol supported.\n   _POSIX_PII_OSI\t\tISO/OSI family of protocols supported.\n   _POSIX_PII_OSI_COTS\t\tConnection-mode ISO/OSI service supported.\n   _POSIX_PII_OSI_CLTS\t\tConnectionless ISO/OSI service supported.\n   _POSIX_POLL\t\t\tImplementation supports `poll' function.\n   _POSIX_SELECT\t\tImplementation supports `select' and `pselect'.\n\n   _XOPEN_REALTIME\t\tX/Open realtime support is available.\n   _XOPEN_REALTIME_THREADS\tX/Open realtime thread support is available.\n   _XOPEN_SHM\t\t\tShared memory interface according to XPG4.2.\n\n   _XBS5_ILP32_OFF32\t\tImplementation provides environment with 32-bit\n\t\t\t\tint, long, pointer, and off_t types.\n   _XBS5_ILP32_OFFBIG\t\tImplementation provides environment with 32-bit\n\t\t\t\tint, long, and pointer and off_t with at least\n\t\t\t\t64 bits.\n   _XBS5_LP64_OFF64\t\tImplementation provides environment with 32-bit\n\t\t\t\tint, and 64-bit long, pointer, and off_t types.\n   _XBS5_LPBIG_OFFBIG\t\tImplementation provides environment with at\n\t\t\t\tleast 32 bits int and long, pointer, and off_t\n\t\t\t\twith at least 64 bits.\n\n   If any of these symbols is defined as -1, the corresponding option is not\n   true for any file.  If any is defined as other than -1, the corresponding\n   option is true for all files.  If a symbol is not defined at all, the value\n   for a specific file can be obtained from `pathconf' and `fpathconf'.\n\n   _POSIX_CHOWN_RESTRICTED\tOnly the super user can use `chown' to change\n\t\t\t\tthe owner of a file.  `chown' can only be used\n\t\t\t\tto change the group ID of a file to a group of\n\t\t\t\twhich the calling process is a member.\n   _POSIX_NO_TRUNC\t\tPathname components longer than\n\t\t\t\tNAME_MAX generate an error.\n   _POSIX_VDISABLE\t\tIf defined, if the value of an element of the\n\t\t\t\t`c_cc' member of `struct termios' is\n\t\t\t\t_POSIX_VDISABLE, no character will have the\n\t\t\t\teffect associated with that element.\n   _POSIX_SYNC_IO\t\tSynchronous I/O may be performed.\n   _POSIX_ASYNC_IO\t\tAsynchronous I/O may be performed.\n   _POSIX_PRIO_IO\t\tPrioritized Asynchronous I/O may be performed.\n\n   Support for the Large File Support interface is not generally available.\n   If it is available the following constants are defined to one.\n   _LFS64_LARGEFILE\t\tLow-level I/O supports large files.\n   _LFS64_STDIO\t\t\tStandard I/O supports large files.\n   */\n\n#include <bits/posix_opt.h>\n\n/* Get the environment definitions from Unix98.  */\n#if defined __USE_UNIX98 || defined __USE_XOPEN2K\n# include <bits/environments.h>\n#endif\n\n/* Standard file descriptors.  */\n#define\tSTDIN_FILENO\t0\t/* Standard input.  */\n#define\tSTDOUT_FILENO\t1\t/* Standard output.  */\n#define\tSTDERR_FILENO\t2\t/* Standard error output.  */\n\n\n/* All functions that are not declared anywhere else.  */\n\n#include <bits/types.h>\n\n#ifndef\t__ssize_t_defined\ntypedef __ssize_t ssize_t;\n# define __ssize_t_defined\n#endif\n\n#define\t__need_size_t\n#define __need_NULL\n#include <stddef.h>\n\n#if defined __USE_XOPEN || defined __USE_XOPEN2K\n/* The Single Unix specification says that some more types are\n   available here.  */\n# ifndef __gid_t_defined\ntypedef __gid_t gid_t;\n#  define __gid_t_defined\n# endif\n\n# ifndef __uid_t_defined\ntypedef __uid_t uid_t;\n#  define __uid_t_defined\n# endif\n\n# ifndef __off_t_defined\n#  ifndef __USE_FILE_OFFSET64\ntypedef __off_t off_t;\n#  else\ntypedef __off64_t off_t;\n#  endif\n#  define __off_t_defined\n# endif\n# if defined __USE_LARGEFILE64 && !defined __off64_t_defined\ntypedef __off64_t off64_t;\n#  define __off64_t_defined\n# endif\n\n# ifndef __useconds_t_defined\ntypedef __useconds_t useconds_t;\n#  define __useconds_t_defined\n# endif\n\n# ifndef __pid_t_defined\ntypedef __pid_t pid_t;\n#  define __pid_t_defined\n# endif\n#endif\t/* X/Open */\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K\n# ifndef __intptr_t_defined\ntypedef __intptr_t intptr_t;\n#  define __intptr_t_defined\n# endif\n#endif\n\n#if defined __USE_MISC || defined __USE_XOPEN\n# ifndef __socklen_t_defined\ntypedef __socklen_t socklen_t;\n#  define __socklen_t_defined\n# endif\n#endif\n\n/* Values for the second argument to access.\n   These may be OR'd together.  */\n#define\tR_OK\t4\t\t/* Test for read permission.  */\n#define\tW_OK\t2\t\t/* Test for write permission.  */\n#define\tX_OK\t1\t\t/* Test for execute permission.  */\n#define\tF_OK\t0\t\t/* Test for existence.  */\n\n/* Test for access to NAME using the real UID and real GID.  */\nextern int access (const char *__name, int __type) __THROW __nonnull ((1));\n\n#ifdef __USE_GNU\n/* Test for access to NAME using the effective UID and GID\n   (as normal file operations use).  */\nextern int euidaccess (const char *__name, int __type)\n     __THROW __nonnull ((1));\n\n/* An alias for `euidaccess', used by some other systems.  */\nextern int eaccess (const char *__name, int __type)\n     __THROW __nonnull ((1));\n\n/* Execute program relative to a directory file descriptor.  */\nextern int execveat (int __fd, const char *__path, char *const __argv[],\n                     char *const __envp[], int __flags)\n    __THROW __nonnull ((2, 3));\n#endif\n\n#ifdef __USE_ATFILE\n/* Test for access to FILE relative to the directory FD is open on.\n   If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',\n   otherwise use real IDs like `access'.  */\nextern int faccessat (int __fd, const char *__file, int __type, int __flag)\n     __THROW __nonnull ((2)) __wur;\n#endif /* Use GNU.  */\n\n\n/* Values for the WHENCE argument to lseek.  */\n#ifndef\t_STDIO_H\t\t/* <stdio.h> has the same definitions.  */\n# define SEEK_SET\t0\t/* Seek from beginning of file.  */\n# define SEEK_CUR\t1\t/* Seek from current position.  */\n# define SEEK_END\t2\t/* Seek from end of file.  */\n# ifdef __USE_GNU\n#  define SEEK_DATA\t3\t/* Seek to next data.  */\n#  define SEEK_HOLE\t4\t/* Seek to next hole.  */\n# endif\n#endif\n\n#if defined __USE_MISC && !defined L_SET\n/* Old BSD names for the same constants; just for compatibility.  */\n# define L_SET\t\tSEEK_SET\n# define L_INCR\t\tSEEK_CUR\n# define L_XTND\t\tSEEK_END\n#endif\n\n\n/* Move FD's file position to OFFSET bytes from the\n   beginning of the file (if WHENCE is SEEK_SET),\n   the current position (if WHENCE is SEEK_CUR),\n   or the end of the file (if WHENCE is SEEK_END).\n   Return the new file position.  */\n#ifndef __USE_FILE_OFFSET64\nextern __off_t lseek (int __fd, __off_t __offset, int __whence) __THROW;\n#else\n# ifdef __REDIRECT_NTH\nextern __off64_t __REDIRECT_NTH (lseek,\n\t\t\t\t (int __fd, __off64_t __offset, int __whence),\n\t\t\t\t lseek64);\n# else\n#  define lseek lseek64\n# endif\n#endif\n#ifdef __USE_LARGEFILE64\nextern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)\n     __THROW;\n#endif\n\n/* Close the file descriptor FD.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int close (int __fd);\n\n#ifdef __USE_MISC\n/* Close all open file descriptors greater than or equal to LOWFD.\n   Negative LOWFD is clamped to 0.  */\nextern void closefrom (int __lowfd) __THROW;\n#endif\n\n/* Read NBYTES into BUF from FD.  Return the\n   number read, -1 for errors or 0 for EOF.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern ssize_t read (int __fd, void *__buf, size_t __nbytes) __wur\n    __fortified_attr_access (__write_only__, 2, 3);\n\n/* Write N bytes of BUF to FD.  Return the number written, or -1.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern ssize_t write (int __fd, const void *__buf, size_t __n) __wur\n    __attr_access ((__read_only__, 2, 3));\n\n#if defined __USE_UNIX98 || defined __USE_XOPEN2K8\n# ifndef __USE_FILE_OFFSET64\n/* Read NBYTES into BUF from FD at the given position OFFSET without\n   changing the file pointer.  Return the number read, -1 for errors\n   or 0 for EOF.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern ssize_t pread (int __fd, void *__buf, size_t __nbytes,\n\t\t      __off_t __offset) __wur\n    __fortified_attr_access (__write_only__, 2, 3);\n\n/* Write N bytes of BUF to FD at the given position OFFSET without\n   changing the file pointer.  Return the number written, or -1.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern ssize_t pwrite (int __fd, const void *__buf, size_t __n,\n\t\t       __off_t __offset) __wur\n    __attr_access ((__read_only__, 2, 3));\n\n# else\n#  ifdef __REDIRECT\nextern ssize_t __REDIRECT (pread, (int __fd, void *__buf, size_t __nbytes,\n\t\t\t\t   __off64_t __offset),\n\t\t\t   pread64) __wur\n    __fortified_attr_access (__write_only__, 2, 3);\nextern ssize_t __REDIRECT (pwrite, (int __fd, const void *__buf,\n\t\t\t\t    size_t __nbytes, __off64_t __offset),\n\t\t\t   pwrite64) __wur\n    __attr_access ((__read_only__, 2, 3));\n#  else\n#   define pread pread64\n#   define pwrite pwrite64\n#  endif\n# endif\n\n# ifdef __USE_LARGEFILE64\n/* Read NBYTES into BUF from FD at the given position OFFSET without\n   changing the file pointer.  Return the number read, -1 for errors\n   or 0 for EOF.  */\nextern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,\n\t\t\t__off64_t __offset) __wur\n    __fortified_attr_access (__write_only__, 2, 3);\n/* Write N bytes of BUF to FD at the given position OFFSET without\n   changing the file pointer.  Return the number written, or -1.  */\nextern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,\n\t\t\t __off64_t __offset) __wur\n    __attr_access ((__read_only__, 2, 3));\n# endif\n#endif\n\n/* Create a one-way communication channel (pipe).\n   If successful, two file descriptors are stored in PIPEDES;\n   bytes written on PIPEDES[1] can be read from PIPEDES[0].\n   Returns 0 if successful, -1 if not.  */\nextern int pipe (int __pipedes[2]) __THROW __wur;\n\n#ifdef __USE_GNU\n/* Same as pipe but apply flags passed in FLAGS to the new file\n   descriptors.  */\nextern int pipe2 (int __pipedes[2], int __flags) __THROW __wur;\n#endif\n\n/* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.\n   If SECONDS is zero, any currently scheduled alarm will be cancelled.\n   The function returns the number of seconds remaining until the last\n   alarm scheduled would have signaled, or zero if there wasn't one.\n   There is no return value to indicate an error, but you can set `errno'\n   to 0 and check its value after calling `alarm', and this might tell you.\n   The signal may come late due to processor scheduling.  */\nextern unsigned int alarm (unsigned int __seconds) __THROW;\n\n/* Make the process sleep for SECONDS seconds, or until a signal arrives\n   and is not ignored.  The function returns the number of seconds less\n   than SECONDS which it actually slept (thus zero if it slept the full time).\n   If a signal handler does a `longjmp' or modifies the handling of the\n   SIGALRM signal while inside `sleep' call, the handling of the SIGALRM\n   signal afterwards is undefined.  There is no return value to indicate\n   error, but if `sleep' returns SECONDS, it probably didn't work.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern unsigned int sleep (unsigned int __seconds);\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \\\n    || defined __USE_MISC\n/* Set an alarm to go off (generating a SIGALRM signal) in VALUE\n   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the\n   timer is reset to go off every INTERVAL microseconds thereafter.\n   Returns the number of microseconds remaining before the alarm.  */\nextern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)\n     __THROW;\n\n/* Sleep USECONDS microseconds, or until a signal arrives that is not blocked\n   or ignored.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int usleep (__useconds_t __useconds);\n#endif\n\n\n/* Suspend the process until a signal arrives.\n   This always returns -1 and sets `errno' to EINTR.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int pause (void);\n\n\n/* Change the owner and group of FILE.  */\nextern int chown (const char *__file, __uid_t __owner, __gid_t __group)\n     __THROW __nonnull ((1)) __wur;\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n/* Change the owner and group of the file that FD is open on.  */\nextern int fchown (int __fd, __uid_t __owner, __gid_t __group) __THROW __wur;\n\n\n/* Change owner and group of FILE, if it is a symbolic\n   link the ownership of the symbolic link is changed.  */\nextern int lchown (const char *__file, __uid_t __owner, __gid_t __group)\n     __THROW __nonnull ((1)) __wur;\n\n#endif /* Use X/Open Unix.  */\n\n#ifdef __USE_ATFILE\n/* Change the owner and group of FILE relative to the directory FD is open\n   on.  */\nextern int fchownat (int __fd, const char *__file, __uid_t __owner,\n\t\t     __gid_t __group, int __flag)\n     __THROW __nonnull ((2)) __wur;\n#endif /* Use GNU.  */\n\n/* Change the process's working directory to PATH.  */\nextern int chdir (const char *__path) __THROW __nonnull ((1)) __wur;\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n/* Change the process's working directory to the one FD is open on.  */\nextern int fchdir (int __fd) __THROW __wur;\n#endif\n\n/* Get the pathname of the current working directory,\n   and put it in SIZE bytes of BUF.  Returns NULL if the\n   directory couldn't be determined or SIZE was too small.\n   If successful, returns BUF.  In GNU, if BUF is NULL,\n   an array is allocated with `malloc'; the array is SIZE\n   bytes long, unless SIZE == 0, in which case it is as\n   big as necessary.  */\nextern char *getcwd (char *__buf, size_t __size) __THROW __wur;\n\n#ifdef\t__USE_GNU\n/* Return a malloc'd string containing the current directory name.\n   If the environment variable `PWD' is set, and its value is correct,\n   that value is used.  */\nextern char *get_current_dir_name (void) __THROW;\n#endif\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \\\n    || defined __USE_MISC\n/* Put the absolute pathname of the current working directory in BUF.\n   If successful, return BUF.  If not, put an error message in\n   BUF and return NULL.  BUF should be at least PATH_MAX bytes long.  */\nextern char *getwd (char *__buf)\n     __THROW __nonnull ((1)) __attribute_deprecated__ __wur\n    __attr_access ((__write_only__, 1));\n#endif\n\n\n/* Duplicate FD, returning a new file descriptor on the same file.  */\nextern int dup (int __fd) __THROW __wur;\n\n/* Duplicate FD to FD2, closing FD2 and making it open on the same file.  */\nextern int dup2 (int __fd, int __fd2) __THROW;\n\n#ifdef __USE_GNU\n/* Duplicate FD to FD2, closing FD2 and making it open on the same\n   file while setting flags according to FLAGS.  */\nextern int dup3 (int __fd, int __fd2, int __flags) __THROW;\n#endif\n\n/* NULL-terminated array of \"NAME=VALUE\" environment variables.  */\nextern char **__environ;\n#ifdef __USE_GNU\nextern char **environ;\n#endif\n\n\n/* Replace the current process, executing PATH with arguments ARGV and\n   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */\nextern int execve (const char *__path, char *const __argv[],\n\t\t   char *const __envp[]) __THROW __nonnull ((1, 2));\n\n#ifdef __USE_XOPEN2K8\n/* Execute the file FD refers to, overlaying the running program image.\n   ARGV and ENVP are passed to the new program, as for `execve'.  */\nextern int fexecve (int __fd, char *const __argv[], char *const __envp[])\n     __THROW __nonnull ((2));\n#endif\n\n\n/* Execute PATH with arguments ARGV and environment from `environ'.  */\nextern int execv (const char *__path, char *const __argv[])\n     __THROW __nonnull ((1, 2));\n\n/* Execute PATH with all arguments after PATH until a NULL pointer,\n   and the argument after that for environment.  */\nextern int execle (const char *__path, const char *__arg, ...)\n     __THROW __nonnull ((1, 2));\n\n/* Execute PATH with all arguments after PATH until\n   a NULL pointer and environment from `environ'.  */\nextern int execl (const char *__path, const char *__arg, ...)\n     __THROW __nonnull ((1, 2));\n\n/* Execute FILE, searching in the `PATH' environment variable if it contains\n   no slashes, with arguments ARGV and environment from `environ'.  */\nextern int execvp (const char *__file, char *const __argv[])\n     __THROW __nonnull ((1, 2));\n\n/* Execute FILE, searching in the `PATH' environment variable if\n   it contains no slashes, with all arguments after FILE until a\n   NULL pointer and environment from `environ'.  */\nextern int execlp (const char *__file, const char *__arg, ...)\n     __THROW __nonnull ((1, 2));\n\n#ifdef __USE_GNU\n/* Execute FILE, searching in the `PATH' environment variable if it contains\n   no slashes, with arguments ARGV and environment from `environ'.  */\nextern int execvpe (const char *__file, char *const __argv[],\n\t\t    char *const __envp[])\n     __THROW __nonnull ((1, 2));\n#endif\n\n\n#if defined __USE_MISC || defined __USE_XOPEN\n/* Add INC to priority of the current process.  */\nextern int nice (int __inc) __THROW __wur;\n#endif\n\n\n/* Terminate program execution with the low-order 8 bits of STATUS.  */\nextern void _exit (int __status) __attribute__ ((__noreturn__));\n\n\n/* Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';\n   the `_SC_*' symbols for the NAME argument to `sysconf';\n   and the `_CS_*' symbols for the NAME argument to `confstr'.  */\n#include <bits/confname.h>\n\n/* Get file-specific configuration information about PATH.  */\nextern long int pathconf (const char *__path, int __name)\n     __THROW __nonnull ((1));\n\n/* Get file-specific configuration about descriptor FD.  */\nextern long int fpathconf (int __fd, int __name) __THROW;\n\n/* Get the value of the system variable NAME.  */\nextern long int sysconf (int __name) __THROW;\n\n#ifdef\t__USE_POSIX2\n/* Get the value of the string-valued system variable NAME.  */\nextern size_t confstr (int __name, char *__buf, size_t __len) __THROW\n    __fortified_attr_access (__write_only__, 2, 3);\n#endif\n\n\n/* Get the process ID of the calling process.  */\nextern __pid_t getpid (void) __THROW;\n\n/* Get the process ID of the calling process's parent.  */\nextern __pid_t getppid (void) __THROW;\n\n/* Get the process group ID of the calling process.  */\nextern __pid_t getpgrp (void) __THROW;\n\n/* Get the process group ID of process PID.  */\nextern __pid_t __getpgid (__pid_t __pid) __THROW;\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\nextern __pid_t getpgid (__pid_t __pid) __THROW;\n#endif\n\n\n/* Set the process group ID of the process matching PID to PGID.\n   If PID is zero, the current process's process group ID is set.\n   If PGID is zero, the process ID of the process is used.  */\nextern int setpgid (__pid_t __pid, __pid_t __pgid) __THROW;\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n/* Both System V and BSD have `setpgrp' functions, but with different\n   calling conventions.  The BSD function is the same as POSIX.1 `setpgid'\n   (above).  The System V function takes no arguments and puts the calling\n   process in its on group like `setpgid (0, 0)'.\n\n   New programs should always use `setpgid' instead.\n\n   GNU provides the POSIX.1 function.  */\n\n/* Set the process group ID of the calling process to its own PID.\n   This is exactly the same as `setpgid (0, 0)'.  */\nextern int setpgrp (void) __THROW;\n\n#endif\t/* Use misc or X/Open.  */\n\n/* Create a new session with the calling process as its leader.\n   The process group IDs of the session and the calling process\n   are set to the process ID of the calling process, which is returned.  */\nextern __pid_t setsid (void) __THROW;\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n/* Return the session ID of the given process.  */\nextern __pid_t getsid (__pid_t __pid) __THROW;\n#endif\n\n/* Get the real user ID of the calling process.  */\nextern __uid_t getuid (void) __THROW;\n\n/* Get the effective user ID of the calling process.  */\nextern __uid_t geteuid (void) __THROW;\n\n/* Get the real group ID of the calling process.  */\nextern __gid_t getgid (void) __THROW;\n\n/* Get the effective group ID of the calling process.  */\nextern __gid_t getegid (void) __THROW;\n\n/* If SIZE is zero, return the number of supplementary groups\n   the calling process is in.  Otherwise, fill in the group IDs\n   of its supplementary groups in LIST and return the number written.  */\nextern int getgroups (int __size, __gid_t __list[]) __THROW __wur\n    __fortified_attr_access (__write_only__, 2, 1);\n#ifdef\t__USE_GNU\n/* Return nonzero iff the calling process is in group GID.  */\nextern int group_member (__gid_t __gid) __THROW;\n#endif\n\n/* Set the user ID of the calling process to UID.\n   If the calling process is the super-user, set the real\n   and effective user IDs, and the saved set-user-ID to UID;\n   if not, the effective user ID is set to UID.  */\nextern int setuid (__uid_t __uid) __THROW __wur;\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n/* Set the real user ID of the calling process to RUID,\n   and the effective user ID of the calling process to EUID.  */\nextern int setreuid (__uid_t __ruid, __uid_t __euid) __THROW __wur;\n#endif\n\n#ifdef __USE_XOPEN2K\n/* Set the effective user ID of the calling process to UID.  */\nextern int seteuid (__uid_t __uid) __THROW __wur;\n#endif /* Use POSIX.1-2001.  */\n\n/* Set the group ID of the calling process to GID.\n   If the calling process is the super-user, set the real\n   and effective group IDs, and the saved set-group-ID to GID;\n   if not, the effective group ID is set to GID.  */\nextern int setgid (__gid_t __gid) __THROW __wur;\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n/* Set the real group ID of the calling process to RGID,\n   and the effective group ID of the calling process to EGID.  */\nextern int setregid (__gid_t __rgid, __gid_t __egid) __THROW __wur;\n#endif\n\n#ifdef __USE_XOPEN2K\n/* Set the effective group ID of the calling process to GID.  */\nextern int setegid (__gid_t __gid) __THROW __wur;\n#endif /* Use POSIX.1-2001.  */\n\n#ifdef __USE_GNU\n/* Fetch the real user ID, effective user ID, and saved-set user ID,\n   of the calling process.  */\nextern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)\n     __THROW;\n\n/* Fetch the real group ID, effective group ID, and saved-set group ID,\n   of the calling process.  */\nextern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)\n     __THROW;\n\n/* Set the real user ID, effective user ID, and saved-set user ID,\n   of the calling process to RUID, EUID, and SUID, respectively.  */\nextern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)\n     __THROW __wur;\n\n/* Set the real group ID, effective group ID, and saved-set group ID,\n   of the calling process to RGID, EGID, and SGID, respectively.  */\nextern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)\n     __THROW __wur;\n#endif\n\n\n/* Clone the calling process, creating an exact copy.\n   Return -1 for errors, 0 to the new process,\n   and the process ID of the new process to the old process.  */\nextern __pid_t fork (void) __THROWNL;\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \\\n    || defined __USE_MISC\n/* Clone the calling process, but without copying the whole address space.\n   The calling process is suspended until the new process exits or is\n   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,\n   and the process ID of the new process to the old process.  */\nextern __pid_t vfork (void) __THROW;\n#endif /* Use misc or XPG < 7. */\n\n#ifdef __USE_GNU\n/* This is similar to fork, however it does not run the atfork handlers\n   neither reinitialize any internal locks in multithread case.\n   Different than fork, _Fork is async-signal-safe.  */\nextern __pid_t _Fork (void) __THROW;\n#endif\n\n\n/* Return the pathname of the terminal FD is open on, or NULL on errors.\n   The returned storage is good only until the next call to this function.  */\nextern char *ttyname (int __fd) __THROW;\n\n/* Store at most BUFLEN characters of the pathname of the terminal FD is\n   open on in BUF.  Return 0 on success, otherwise an error number.  */\nextern int ttyname_r (int __fd, char *__buf, size_t __buflen)\n     __THROW __nonnull ((2)) __wur\n     __fortified_attr_access (__write_only__, 2, 3);\n\n/* Return 1 if FD is a valid descriptor associated\n   with a terminal, zero if not.  */\nextern int isatty (int __fd) __THROW;\n\n#ifdef __USE_MISC\n/* Return the index into the active-logins file (utmp) for\n   the controlling terminal.  */\nextern int ttyslot (void) __THROW;\n#endif\n\n\n/* Make a link to FROM named TO.  */\nextern int link (const char *__from, const char *__to)\n     __THROW __nonnull ((1, 2)) __wur;\n\n#ifdef __USE_ATFILE\n/* Like link but relative paths in TO and FROM are interpreted relative\n   to FROMFD and TOFD respectively.  */\nextern int linkat (int __fromfd, const char *__from, int __tofd,\n\t\t   const char *__to, int __flags)\n     __THROW __nonnull ((2, 4)) __wur;\n#endif\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K\n/* Make a symbolic link to FROM named TO.  */\nextern int symlink (const char *__from, const char *__to)\n     __THROW __nonnull ((1, 2)) __wur;\n\n/* Read the contents of the symbolic link PATH into no more than\n   LEN bytes of BUF.  The contents are not null-terminated.\n   Returns the number of characters read, or -1 for errors.  */\nextern ssize_t readlink (const char *__restrict __path,\n\t\t\t char *__restrict __buf, size_t __len)\n     __THROW __nonnull ((1, 2)) __wur\n     __fortified_attr_access (__write_only__, 2, 3);\n\n#endif /* Use POSIX.1-2001.  */\n\n#ifdef __USE_ATFILE\n/* Like symlink but a relative path in TO is interpreted relative to TOFD.  */\nextern int symlinkat (const char *__from, int __tofd,\n\t\t      const char *__to) __THROW __nonnull ((1, 3)) __wur;\n\n/* Like readlink but a relative PATH is interpreted relative to FD.  */\nextern ssize_t readlinkat (int __fd, const char *__restrict __path,\n\t\t\t   char *__restrict __buf, size_t __len)\n     __THROW __nonnull ((2, 3)) __wur\n     __fortified_attr_access (__write_only__, 3, 4);\n#endif\n\n/* Remove the link NAME.  */\nextern int unlink (const char *__name) __THROW __nonnull ((1));\n\n#ifdef __USE_ATFILE\n/* Remove the link NAME relative to FD.  */\nextern int unlinkat (int __fd, const char *__name, int __flag)\n     __THROW __nonnull ((2));\n#endif\n\n/* Remove the directory PATH.  */\nextern int rmdir (const char *__path) __THROW __nonnull ((1));\n\n\n/* Return the foreground process group ID of FD.  */\nextern __pid_t tcgetpgrp (int __fd) __THROW;\n\n/* Set the foreground process group ID of FD set PGRP_ID.  */\nextern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __THROW;\n\n\n/* Return the login name of the user.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern char *getlogin (void);\n#ifdef __USE_POSIX199506\n/* Return at most NAME_LEN characters of the login name of the user in NAME.\n   If it cannot be determined or some other error occurred, return the error\n   code.  Otherwise return 0.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern int getlogin_r (char *__name, size_t __name_len) __nonnull ((1))\n    __fortified_attr_access (__write_only__, 1, 2);\n#endif\n\n#ifdef\t__USE_MISC\n/* Set the login name returned by `getlogin'.  */\nextern int setlogin (const char *__name) __THROW __nonnull ((1));\n#endif\n\n\n#ifdef\t__USE_POSIX2\n/* Get definitions and prototypes for functions to process the\n   arguments in ARGV (ARGC of them, minus the program name) for\n   options given in OPTS.  */\n# include <bits/getopt_posix.h>\n#endif\n\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K\n/* Put the name of the current host in no more than LEN bytes of NAME.\n   The result is null-terminated if LEN is large enough for the full\n   name and the terminator.  */\nextern int gethostname (char *__name, size_t __len) __THROW __nonnull ((1))\n    __fortified_attr_access (__write_only__, 1, 2);\n#endif\n\n\n#if defined __USE_MISC\n/* Set the name of the current host to NAME, which is LEN bytes long.\n   This call is restricted to the super-user.  */\nextern int sethostname (const char *__name, size_t __len)\n     __THROW __nonnull ((1)) __wur __attr_access ((__read_only__, 1, 2));\n\n/* Set the current machine's Internet number to ID.\n   This call is restricted to the super-user.  */\nextern int sethostid (long int __id) __THROW __wur;\n\n\n/* Get and set the NIS (aka YP) domain name, if any.\n   Called just like `gethostname' and `sethostname'.\n   The NIS domain name is usually the empty string when not using NIS.  */\nextern int getdomainname (char *__name, size_t __len)\n     __THROW __nonnull ((1)) __wur\n     __fortified_attr_access (__write_only__, 1, 2);\nextern int setdomainname (const char *__name, size_t __len)\n     __THROW __nonnull ((1)) __wur __attr_access ((__read_only__, 1, 2));\n\n/* Revoke access permissions to all processes currently communicating\n   with the control terminal, and then send a SIGHUP signal to the process\n   group of the control terminal.  */\nextern int vhangup (void) __THROW;\n\n/* Revoke the access of all descriptors currently open on FILE.  */\nextern int revoke (const char *__file) __THROW __nonnull ((1)) __wur;\n\n\n/* Enable statistical profiling, writing samples of the PC into at most\n   SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling\n   is enabled, the system examines the user PC and increments\n   SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,\n   disable profiling.  Returns zero on success, -1 on error.  */\nextern int profil (unsigned short int *__sample_buffer, size_t __size,\n\t\t   size_t __offset, unsigned int __scale)\n     __THROW __nonnull ((1));\n\n\n/* Turn accounting on if NAME is an existing file.  The system will then write\n   a record for each process as it terminates, to this file.  If NAME is NULL,\n   turn accounting off.  This call is restricted to the super-user.  */\nextern int acct (const char *__name) __THROW;\n\n\n/* Successive calls return the shells listed in `/etc/shells'.  */\nextern char *getusershell (void) __THROW;\nextern void endusershell (void) __THROW; /* Discard cached info.  */\nextern void setusershell (void) __THROW; /* Rewind and re-read the file.  */\n\n\n/* Put the program in the background, and dissociate from the controlling\n   terminal.  If NOCHDIR is zero, do `chdir (\"/\")'.  If NOCLOSE is zero,\n   redirects stdin, stdout, and stderr to /dev/null.  */\nextern int daemon (int __nochdir, int __noclose) __THROW __wur;\n#endif /* Use misc.  */\n\n\n#if defined __USE_MISC || (defined __USE_XOPEN && !defined __USE_XOPEN2K)\n/* Make PATH be the root directory (the starting point for absolute paths).\n   This call is restricted to the super-user.  */\nextern int chroot (const char *__path) __THROW __nonnull ((1)) __wur;\n\n/* Prompt with PROMPT and read a string from the terminal without echoing.\n   Uses /dev/tty if possible; otherwise stderr and stdin.  */\nextern char *getpass (const char *__prompt) __nonnull ((1));\n#endif /* Use misc || X/Open.  */\n\n\n/* Make all changes done to FD actually appear on disk.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int fsync (int __fd);\n\n\n#ifdef __USE_GNU\n/* Make all changes done to all files on the file system associated\n   with FD actually appear on disk.  */\nextern int syncfs (int __fd) __THROW;\n#endif\n\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n\n/* Return identifier for the current host.  */\nextern long int gethostid (void);\n\n/* Make all changes done to all files actually appear on disk.  */\nextern void sync (void) __THROW;\n\n\n# if defined __USE_MISC || !defined __USE_XOPEN2K\n/* Return the number of bytes in a page.  This is the system's page size,\n   which is not necessarily the same as the hardware page size.  */\nextern int getpagesize (void)  __THROW __attribute__ ((__const__));\n\n\n/* Return the maximum number of file descriptors\n   the current process could possibly have.  */\nextern int getdtablesize (void) __THROW;\n# endif\n\n#endif /* Use misc || X/Open Unix.  */\n\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n\n/* Truncate FILE to LENGTH bytes.  */\n# ifndef __USE_FILE_OFFSET64\nextern int truncate (const char *__file, __off_t __length)\n     __THROW __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (truncate,\n\t\t\t   (const char *__file, __off64_t __length),\n\t\t\t   truncate64) __nonnull ((1)) __wur;\n#  else\n#   define truncate truncate64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int truncate64 (const char *__file, __off64_t __length)\n     __THROW __nonnull ((1)) __wur;\n# endif\n\n#endif /* Use X/Open Unix || POSIX 2008.  */\n\n#if defined __USE_POSIX199309 \\\n    || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K\n\n/* Truncate the file FD is open on to LENGTH bytes.  */\n# ifndef __USE_FILE_OFFSET64\nextern int ftruncate (int __fd, __off_t __length) __THROW __wur;\n# else\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (ftruncate, (int __fd, __off64_t __length),\n\t\t\t   ftruncate64) __wur;\n#  else\n#   define ftruncate ftruncate64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int ftruncate64 (int __fd, __off64_t __length) __THROW __wur;\n# endif\n\n#endif /* Use POSIX.1b || X/Open Unix || XPG6.  */\n\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K) \\\n    || defined __USE_MISC\n\n/* Set the end of accessible data space (aka \"the break\") to ADDR.\n   Returns zero on success and -1 for errors (with errno set).  */\nextern int brk (void *__addr) __THROW __wur;\n\n/* Increase or decrease the end of accessible data space by DELTA bytes.\n   If successful, returns the address the previous end of data space\n   (i.e. the beginning of the new space, if DELTA > 0);\n   returns (void *) -1 for errors (with errno set).  */\nextern void *sbrk (intptr_t __delta) __THROW;\n#endif\n\n\n#ifdef __USE_MISC\n/* Invoke `system call' number SYSNO, passing it the remaining arguments.\n   This is completely system-dependent, and not often useful.\n\n   In Unix, `syscall' sets `errno' for all errors and most calls return -1\n   for errors; in many systems you cannot pass arguments or get return\n   values for all system calls (`pipe', `fork', and `getppid' typically\n   among them).\n\n   In Mach, all system calls take normal arguments and always return an\n   error code (zero for success).  */\nextern long int syscall (long int __sysno, ...) __THROW;\n\n#endif\t/* Use misc.  */\n\n\n#if (defined __USE_MISC || defined __USE_XOPEN_EXTENDED) && !defined F_LOCK\n/* NOTE: These declarations also appear in <fcntl.h>; be sure to keep both\n   files consistent.  Some systems have them there and some here, and some\n   software depends on the macros being defined without including both.  */\n\n/* `lockf' is a simpler interface to the locking facilities of `fcntl'.\n   LEN is always relative to the current file position.\n   The CMD argument is one of the following.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\n\n# define F_ULOCK 0\t/* Unlock a previously locked region.  */\n# define F_LOCK  1\t/* Lock a region for exclusive use.  */\n# define F_TLOCK 2\t/* Test and lock a region for exclusive use.  */\n# define F_TEST  3\t/* Test a region for other processes locks.  */\n\n# ifndef __USE_FILE_OFFSET64\nextern int lockf (int __fd, int __cmd, __off_t __len) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (lockf, (int __fd, int __cmd, __off64_t __len),\n\t\t       lockf64) __wur;\n#  else\n#   define lockf lockf64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int lockf64 (int __fd, int __cmd, __off64_t __len) __wur;\n# endif\n#endif /* Use misc and F_LOCK not already defined.  */\n\n\n#ifdef __USE_GNU\n\n/* Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno'\n   set to EINTR.  */\n\n# define TEMP_FAILURE_RETRY(expression) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n    ({ long int __result;\t\t\t\t\t\t      \\\n       do __result = (long int) (expression);\t\t\t\t      \\\n       while (__result == -1L && errno == EINTR);\t\t\t      \\\n       __result; }))\n\n/* Copy LENGTH bytes from INFD to OUTFD.  */\nssize_t copy_file_range (int __infd, __off64_t *__pinoff,\n\t\t\t int __outfd, __off64_t *__poutoff,\n\t\t\t size_t __length, unsigned int __flags);\n#endif /* __USE_GNU */\n\n#if defined __USE_POSIX199309 || defined __USE_UNIX98\n/* Synchronize at least the data part of a file with the underlying\n   media.  */\nextern int fdatasync (int __fildes);\n#endif /* Use POSIX199309 */\n\n#ifdef __USE_MISC\n/* One-way hash PHRASE, returning a string suitable for storage in the\n   user database.  SALT selects the one-way function to use, and\n   ensures that no two users' hashes are the same, even if they use\n   the same passphrase.  The return value points to static storage\n   which will be overwritten by the next call to crypt.\n\n   This declaration is deprecated; applications should include\n   <crypt.h> instead.  */\nextern char *crypt (const char *__key, const char *__salt)\n     __THROW __nonnull ((1, 2));\n#endif\n\n#ifdef\t__USE_XOPEN\n/* Swab pairs bytes in the first N bytes of the area pointed to by\n   FROM and copy the result to TO.  The value of TO must not be in the\n   range [FROM - N + 1, FROM - 1].  If N is odd the first byte in FROM\n   is without partner.  */\nextern void swab (const void *__restrict __from, void *__restrict __to,\n\t\t  ssize_t __n) __THROW __nonnull ((1, 2))\n    __attr_access ((__read_only__, 1, 3))\n    __attr_access ((__write_only__, 2, 3));\n#endif\n\n\n/* Prior to Issue 6, the Single Unix Specification required these\n   prototypes to appear in this header.  They are also found in\n   <stdio.h>.  */\n#if defined __USE_XOPEN && !defined __USE_XOPEN2K\n/* Return the name of the controlling terminal.  */\nextern char *ctermid (char *__s) __THROW;\n\n/* Return the name of the current user.  */\nextern char *cuserid (char *__s);\n#endif\n\n\n/* Unix98 requires this function to be declared here.  In other\n   standards it is in <pthread.h>.  */\n#if defined __USE_UNIX98 && !defined __USE_XOPEN2K\nextern int pthread_atfork (void (*__prepare) (void),\n\t\t\t   void (*__parent) (void),\n\t\t\t   void (*__child) (void)) __THROW;\n#endif\n\n#ifdef __USE_MISC\n/* Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on\n   success or -1 on error.  */\nint getentropy (void *__buffer, size_t __length) __wur\n    __attr_access ((__write_only__, 1, 2));\n#endif\n\n#ifdef __USE_GNU\n/* Close all file descriptors in the range FD up to MAX_FD.  The flag FLAGS\n   are define by the CLOSE_RANGE prefix.  This function behaves like close\n   on the range and gaps where the file descriptor is invalid or errors\n   encountered while closing file descriptors are ignored.   Returns 0 on\n   successor or -1 for failure (and sets errno accordingly).  */\nextern int close_range (unsigned int __fd, unsigned int __max_fd,\n\t\t\tint __flags) __THROW;\n#endif\n\n/* Define some macros helping to catch buffer overflows.  */\n#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function\n# include <bits/unistd.h>\n#endif\n\n/* System-specific extensions.  */\n#include <bits/unistd_ext.h>\n\n__END_DECLS\n\n#endif /* unistd.h  */\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/object.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_OBJECT_H\n#define Py_OBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Object and type object interface */\n\n/*\nObjects are structures allocated on the heap.  Special rules apply to\nthe use of objects to ensure they are properly garbage-collected.\nObjects are never allocated statically or on the stack; they must be\naccessed through special macros and functions only.  (Type objects are\nexceptions to the first rule; the standard types are represented by\nstatically initialized type objects, although work on type/class unification\nfor Python 2.2 made it possible to have heap-allocated type objects too).\n\nAn object has a 'reference count' that is increased or decreased when a\npointer to the object is copied or deleted; when the reference count\nreaches zero there are no references to the object left and it can be\nremoved from the heap.\n\nAn object has a 'type' that determines what it represents and what kind\nof data it contains.  An object's type is fixed when it is created.\nTypes themselves are represented as objects; an object contains a\npointer to the corresponding type object.  The type itself has a type\npointer pointing to the object representing the type 'type', which\ncontains a pointer to itself!.\n\nObjects do not float around in memory; once allocated an object keeps\nthe same size and address.  Objects that must hold variable-size data\ncan contain pointers to variable-size parts of the object.  Not all\nobjects of the same type have the same size; but the size cannot change\nafter allocation.  (These restrictions are made so a reference to an\nobject can be simply a pointer -- moving an object would require\nupdating all the pointers, and changing an object's size would require\nmoving it if there was another object right next to it.)\n\nObjects are always accessed through pointers of the type 'PyObject *'.\nThe type 'PyObject' is a structure that only contains the reference count\nand the type pointer.  The actual memory allocated for an object\ncontains other data that can only be accessed after casting the pointer\nto a pointer to a longer structure type.  This longer type must start\nwith the reference count and type fields; the macro PyObject_HEAD should be\nused for this (to accommodate for future changes).  The implementation\nof a particular object type can cast the object pointer to the proper\ntype and back.\n\nA standard interface exists for objects that contain an array of items\nwhose size is determined when the object is allocated.\n*/\n\n/* Py_DEBUG implies Py_REF_DEBUG. */\n#if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)\n#  define Py_REF_DEBUG\n#endif\n\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   PyObject ob_base;\n\n/*\nImmortalization:\n\nThe following indicates the immortalization strategy depending on the amount\nof available bits in the reference count field. All strategies are backwards\ncompatible but the specific reference count value or immortalization check\nmight change depending on the specializations for the underlying system.\n\nProper deallocation of immortal instances requires distinguishing between\nstatically allocated immortal instances vs those promoted by the runtime to be\nimmortal. The latter should be the only instances that require\ncleanup during runtime finalization.\n*/\n\n#if SIZEOF_VOID_P > 4\n/*\nIn 64+ bit systems, an object will be marked as immortal by setting all of the\nlower 32 bits of the reference count field, which is equal to: 0xFFFFFFFF\n\nUsing the lower 32 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases will use saturated arithmetic, taking advantage of\nhaving all the lower 32 bits set, which will avoid the reference count to go\nbeyond the refcount limit. Immortality checks for reference count decreases will\nbe done by checking the bit sign flag in the lower 32 bits.\n*/\n#define _Py_IMMORTAL_REFCNT _Py_CAST(Py_ssize_t, UINT_MAX)\n\n#else\n/*\nIn 32 bit systems, an object will be marked as immortal by setting all of the\nlower 30 bits of the reference count field, which is equal to: 0x3FFFFFFF\n\nUsing the lower 30 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases and decreases will first go through an immortality\ncheck by comparing the reference count field to the immortality reference count.\n*/\n#define _Py_IMMORTAL_REFCNT _Py_CAST(Py_ssize_t, UINT_MAX >> 2)\n#endif\n\n// Py_GIL_DISABLED builds indicate immortal objects using `ob_ref_local`, which is\n// always 32-bits.\n#ifdef Py_GIL_DISABLED\n#define _Py_IMMORTAL_REFCNT_LOCAL UINT32_MAX\n#endif\n\n// Kept for backward compatibility. It was needed by Py_TRACE_REFS build.\n#define _PyObject_EXTRA_INIT\n\n/* Make all uses of PyObject_HEAD_INIT immortal.\n *\n * Statically allocated objects might be shared between\n * interpreters, so must be marked as immortal.\n */\n#if defined(Py_GIL_DISABLED)\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        0,                          \\\n        0,                          \\\n        { 0 },                      \\\n        0,                          \\\n        _Py_IMMORTAL_REFCNT_LOCAL,  \\\n        0,                          \\\n        (type),                     \\\n    },\n#else\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        { _Py_IMMORTAL_REFCNT },    \\\n        (type)                      \\\n    },\n#endif\n\n#define PyVarObject_HEAD_INIT(type, size) \\\n    {                                     \\\n        PyObject_HEAD_INIT(type)          \\\n        (size)                            \\\n    },\n\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD      PyVarObject ob_base;\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\n#ifndef Py_GIL_DISABLED\nstruct _object {\n#if (defined(__GNUC__) || defined(__clang__)) \\\n        && !(defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L)\n    // On C99 and older, anonymous union is a GCC and clang extension\n    __extension__\n#endif\n#ifdef _MSC_VER\n    // Ignore MSC warning C4201: \"nonstandard extension used:\n    // nameless struct/union\"\n    __pragma(warning(push))\n    __pragma(warning(disable: 4201))\n#endif\n    union {\n       Py_ssize_t ob_refcnt;\n#if SIZEOF_VOID_P > 4\n       PY_UINT32_T ob_refcnt_split[2];\n#endif\n    };\n#ifdef _MSC_VER\n    __pragma(warning(pop))\n#endif\n\n    PyTypeObject *ob_type;\n};\n#else\n// Objects that are not owned by any thread use a thread id (tid) of zero.\n// This includes both immortal objects and objects whose reference count\n// fields have been merged.\n#define _Py_UNOWNED_TID             0\n\n// The shared reference count uses the two least-significant bits to store\n// flags. The remaining bits are used to store the reference count.\n#define _Py_REF_SHARED_SHIFT        2\n#define _Py_REF_SHARED_FLAG_MASK    0x3\n\n// The shared flags are initialized to zero.\n#define _Py_REF_SHARED_INIT         0x0\n#define _Py_REF_MAYBE_WEAKREF       0x1\n#define _Py_REF_QUEUED              0x2\n#define _Py_REF_MERGED              0x3\n\n// Create a shared field from a refcnt and desired flags\n#define _Py_REF_SHARED(refcnt, flags) (((refcnt) << _Py_REF_SHARED_SHIFT) + (flags))\n\nstruct _object {\n    // ob_tid stores the thread id (or zero). It is also used by the GC and the\n    // trashcan mechanism as a linked list pointer and by the GC to store the\n    // computed \"gc_refs\" refcount.\n    uintptr_t ob_tid;\n    uint16_t _padding;\n    PyMutex ob_mutex;           // per-object lock\n    uint8_t ob_gc_bits;         // gc-related state\n    uint32_t ob_ref_local;      // local reference count\n    Py_ssize_t ob_ref_shared;   // shared (atomic) reference count\n    PyTypeObject *ob_type;\n};\n#endif\n\n/* Cast argument to PyObject* type. */\n#define _PyObject_CAST(op) _Py_CAST(PyObject*, (op))\n\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n/* Cast argument to PyVarObject* type. */\n#define _PyVarObject_CAST(op) _Py_CAST(PyVarObject*, (op))\n\n\n// Test if the 'x' object is the 'y' object, the same as \"x is y\" in Python.\nPyAPI_FUNC(int) Py_Is(PyObject *x, PyObject *y);\n#define Py_Is(x, y) ((x) == (y))\n\n#if defined(Py_GIL_DISABLED) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(uintptr_t) _Py_GetThreadLocal_Addr(void);\n\nstatic inline uintptr_t\n_Py_ThreadId(void)\n{\n    uintptr_t tid;\n#if defined(_MSC_VER) && defined(_M_X64)\n    tid = __readgsqword(48);\n#elif defined(_MSC_VER) && defined(_M_IX86)\n    tid = __readfsdword(24);\n#elif defined(_MSC_VER) && defined(_M_ARM64)\n    tid = __getReg(18);\n#elif defined(__i386__)\n    __asm__(\"movl %%gs:0, %0\" : \"=r\" (tid));  // 32-bit always uses GS\n#elif defined(__MACH__) && defined(__x86_64__)\n    __asm__(\"movq %%gs:0, %0\" : \"=r\" (tid));  // x86_64 macOSX uses GS\n#elif defined(__x86_64__)\n   __asm__(\"movq %%fs:0, %0\" : \"=r\" (tid));  // x86_64 Linux, BSD uses FS\n#elif defined(__arm__)\n    __asm__ (\"mrc p15, 0, %0, c13, c0, 3\\nbic %0, %0, #3\" : \"=r\" (tid));\n#elif defined(__aarch64__) && defined(__APPLE__)\n    __asm__ (\"mrs %0, tpidrro_el0\" : \"=r\" (tid));\n#elif defined(__aarch64__)\n    __asm__ (\"mrs %0, tpidr_el0\" : \"=r\" (tid));\n#elif defined(__powerpc64__)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // r13 is reserved for use as system thread ID by the Power 64-bit ABI.\n    register uintptr_t tp __asm__ (\"r13\");\n    __asm__(\"\" : \"=r\" (tp));\n    tid = tp;\n    #endif\n#elif defined(__powerpc__)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // r2 is reserved for use as system thread ID by the Power 32-bit ABI.\n    register uintptr_t tp __asm__ (\"r2\");\n    __asm__ (\"\" : \"=r\" (tp));\n    tid = tp;\n    #endif\n#elif defined(__s390__) && defined(__GNUC__)\n    // Both GCC and Clang have supported __builtin_thread_pointer\n    // for s390 from long time ago.\n    tid = (uintptr_t)__builtin_thread_pointer();\n#elif defined(__riscv)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // tp is Thread Pointer provided by the RISC-V ABI.\n    __asm__ (\"mv %0, tp\" : \"=r\" (tid));\n    #endif\n#else\n    // Fallback to a portable implementation if we do not have a faster\n    // platform-specific implementation.\n    tid = _Py_GetThreadLocal_Addr();\n#endif\n  return tid;\n}\n\nstatic inline Py_ALWAYS_INLINE int\n_Py_IsOwnedByCurrentThread(PyObject *ob)\n{\n#ifdef _Py_THREAD_SANITIZER\n    return _Py_atomic_load_uintptr_relaxed(&ob->ob_tid) == _Py_ThreadId();\n#else\n    return ob->ob_tid == _Py_ThreadId();\n#endif\n}\n#endif\n\nstatic inline Py_ssize_t Py_REFCNT(PyObject *ob) {\n#if !defined(Py_GIL_DISABLED)\n    return ob->ob_refcnt;\n#else\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&ob->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return _Py_IMMORTAL_REFCNT;\n    }\n    Py_ssize_t shared = _Py_atomic_load_ssize_relaxed(&ob->ob_ref_shared);\n    return _Py_STATIC_CAST(Py_ssize_t, local) +\n           Py_ARITHMETIC_RIGHT_SHIFT(Py_ssize_t, shared, _Py_REF_SHARED_SHIFT);\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_REFCNT(ob) Py_REFCNT(_PyObject_CAST(ob))\n#endif\n\n\n// bpo-39573: The Py_SET_TYPE() function must be used to set an object type.\nstatic inline PyTypeObject* Py_TYPE(PyObject *ob) {\n    return ob->ob_type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_TYPE(ob) Py_TYPE(_PyObject_CAST(ob))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyLong_Type;\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n\n// bpo-39573: The Py_SET_SIZE() function must be used to set an object size.\nstatic inline Py_ssize_t Py_SIZE(PyObject *ob) {\n    assert(ob->ob_type != &PyLong_Type);\n    assert(ob->ob_type != &PyBool_Type);\n    return  _PyVarObject_CAST(ob)->ob_size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SIZE(ob) Py_SIZE(_PyObject_CAST(ob))\n#endif\n\nstatic inline Py_ALWAYS_INLINE int _Py_IsImmortal(PyObject *op)\n{\n#if defined(Py_GIL_DISABLED)\n    return (_Py_atomic_load_uint32_relaxed(&op->ob_ref_local) ==\n            _Py_IMMORTAL_REFCNT_LOCAL);\n#elif SIZEOF_VOID_P > 4\n    return (_Py_CAST(PY_INT32_T, op->ob_refcnt) < 0);\n#else\n    return (op->ob_refcnt == _Py_IMMORTAL_REFCNT);\n#endif\n}\n#define _Py_IsImmortal(op) _Py_IsImmortal(_PyObject_CAST(op))\n\nstatic inline int Py_IS_TYPE(PyObject *ob, PyTypeObject *type) {\n    return Py_TYPE(ob) == type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_IS_TYPE(ob, type) Py_IS_TYPE(_PyObject_CAST(ob), (type))\n#endif\n\n\n// Py_SET_REFCNT() implementation for stable ABI\nPyAPI_FUNC(void) _Py_SetRefcnt(PyObject *ob, Py_ssize_t refcnt);\n\nstatic inline void Py_SET_REFCNT(PyObject *ob, Py_ssize_t refcnt) {\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030d0000\n    // Stable ABI implements Py_SET_REFCNT() as a function call\n    // on limited C API version 3.13 and newer.\n    _Py_SetRefcnt(ob, refcnt);\n#else\n    // This immortal check is for code that is unaware of immortal objects.\n    // The runtime tracks these objects and we should avoid as much\n    // as possible having extensions inadvertently change the refcnt\n    // of an immortalized object.\n    if (_Py_IsImmortal(ob)) {\n        return;\n    }\n\n#ifndef Py_GIL_DISABLED\n    ob->ob_refcnt = refcnt;\n#else\n    if (_Py_IsOwnedByCurrentThread(ob)) {\n        if ((size_t)refcnt > (size_t)UINT32_MAX) {\n            // On overflow, make the object immortal\n            ob->ob_tid = _Py_UNOWNED_TID;\n            ob->ob_ref_local = _Py_IMMORTAL_REFCNT_LOCAL;\n            ob->ob_ref_shared = 0;\n        }\n        else {\n            // Set local refcount to desired refcount and shared refcount\n            // to zero, but preserve the shared refcount flags.\n            ob->ob_ref_local = _Py_STATIC_CAST(uint32_t, refcnt);\n            ob->ob_ref_shared &= _Py_REF_SHARED_FLAG_MASK;\n        }\n    }\n    else {\n        // Set local refcount to zero and shared refcount to desired refcount.\n        // Mark the object as merged.\n        ob->ob_tid = _Py_UNOWNED_TID;\n        ob->ob_ref_local = 0;\n        ob->ob_ref_shared = _Py_REF_SHARED(refcnt, _Py_REF_MERGED);\n    }\n#endif  // Py_GIL_DISABLED\n#endif  // Py_LIMITED_API+0 < 0x030d0000\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_REFCNT(ob, refcnt) Py_SET_REFCNT(_PyObject_CAST(ob), (refcnt))\n#endif\n\n\nstatic inline void Py_SET_TYPE(PyObject *ob, PyTypeObject *type) {\n    ob->ob_type = type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_TYPE(ob, type) Py_SET_TYPE(_PyObject_CAST(ob), type)\n#endif\n\nstatic inline void Py_SET_SIZE(PyVarObject *ob, Py_ssize_t size) {\n    assert(ob->ob_base.ob_type != &PyLong_Type);\n    assert(ob->ob_base.ob_type != &PyBool_Type);\n#ifdef Py_GIL_DISABLED\n    _Py_atomic_store_ssize_relaxed(&ob->ob_size, size);\n#else\n    ob->ob_size = size;\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_SIZE(ob, size) Py_SET_SIZE(_PyVarObject_CAST(ob), (size))\n#endif\n\n\n/*\nType objects contain a string containing the type name (to help somewhat\nin debugging), the allocation parameters (see PyObject_New() and\nPyObject_NewVar()),\nand methods for accessing objects of the type.  Methods are optional, a\nnil pointer meaning that particular kind of access is not available for\nthis type.  The Py_DECREF() macro uses the tp_dealloc method without\nchecking for a nil pointer; it should always be implemented except if\nthe implementation can guarantee that the reference count will never\nreach zero (e.g., for statically allocated type objects).\n\nNB: the methods for certain type groups are now contained in separate\nmethod blocks.\n*/\n\ntypedef PyObject * (*unaryfunc)(PyObject *);\ntypedef PyObject * (*binaryfunc)(PyObject *, PyObject *);\ntypedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);\ntypedef int (*inquiry)(PyObject *);\ntypedef Py_ssize_t (*lenfunc)(PyObject *);\ntypedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);\ntypedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);\ntypedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);\ntypedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);\ntypedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);\n\ntypedef int (*objobjproc)(PyObject *, PyObject *);\ntypedef int (*visitproc)(PyObject *, void *);\ntypedef int (*traverseproc)(PyObject *, visitproc, void *);\n\n\ntypedef void (*freefunc)(void *);\ntypedef void (*destructor)(PyObject *);\ntypedef PyObject *(*getattrfunc)(PyObject *, char *);\ntypedef PyObject *(*getattrofunc)(PyObject *, PyObject *);\ntypedef int (*setattrfunc)(PyObject *, char *, PyObject *);\ntypedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*reprfunc)(PyObject *);\ntypedef Py_hash_t (*hashfunc)(PyObject *);\ntypedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);\ntypedef PyObject *(*getiterfunc) (PyObject *);\ntypedef PyObject *(*iternextfunc) (PyObject *);\ntypedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*initproc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*newfunc)(PyTypeObject *, PyObject *, PyObject *);\ntypedef PyObject *(*allocfunc)(PyTypeObject *, Py_ssize_t);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030c0000 // 3.12\ntypedef PyObject *(*vectorcallfunc)(PyObject *callable, PyObject *const *args,\n                                    size_t nargsf, PyObject *kwnames);\n#endif\n\ntypedef struct{\n    int slot;    /* slot id, see below */\n    void *pfunc; /* function pointer */\n} PyType_Slot;\n\ntypedef struct{\n    const char* name;\n    int basicsize;\n    int itemsize;\n    unsigned int flags;\n    PyType_Slot *slots; /* terminated by slot==0. */\n} PyType_Spec;\n\nPyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000\nPyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);\nPyAPI_FUNC(PyObject *) PyType_GetModule(PyTypeObject *);\nPyAPI_FUNC(void *) PyType_GetModuleState(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000\nPyAPI_FUNC(PyObject *) PyType_GetName(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GetQualName(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030D0000\nPyAPI_FUNC(PyObject *) PyType_GetFullyQualifiedName(PyTypeObject *type);\nPyAPI_FUNC(PyObject *) PyType_GetModuleName(PyTypeObject *type);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\nPyAPI_FUNC(PyObject *) PyType_FromMetaclass(PyTypeObject*, PyObject*, PyType_Spec*, PyObject*);\nPyAPI_FUNC(void *) PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls);\nPyAPI_FUNC(Py_ssize_t) PyType_GetTypeDataSize(PyTypeObject *cls);\n#endif\n\n/* Generic type check */\nPyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);\n\nstatic inline int PyObject_TypeCheck(PyObject *ob, PyTypeObject *type) {\n    return Py_IS_TYPE(ob, type) || PyType_IsSubtype(Py_TYPE(ob), type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyObject_TypeCheck(ob, type) PyObject_TypeCheck(_PyObject_CAST(ob), (type))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */\nPyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */\nPyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */\n\nPyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);\n\nPyAPI_FUNC(int) PyType_Ready(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,\n                                               PyObject *, PyObject *);\nPyAPI_FUNC(unsigned int) PyType_ClearCache(void);\nPyAPI_FUNC(void) PyType_Modified(PyTypeObject *);\n\n/* Generic operations on objects */\nPyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);\nPyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);\nPyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);\nPyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);\nPyAPI_FUNC(int) PyObject_DelAttrString(PyObject *v, const char *name);\nPyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(int) PyObject_GetOptionalAttr(PyObject *, PyObject *, PyObject **);\nPyAPI_FUNC(int) PyObject_GetOptionalAttrString(PyObject *, const char *, PyObject **);\n#endif\nPyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_DelAttr(PyObject *v, PyObject *name);\nPyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(int) PyObject_HasAttrWithError(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttrStringWithError(PyObject *, const char *);\n#endif\nPyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);\n#endif\nPyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);\nPyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);\nPyAPI_FUNC(int) PyObject_IsTrue(PyObject *);\nPyAPI_FUNC(int) PyObject_Not(PyObject *);\nPyAPI_FUNC(int) PyCallable_Check(PyObject *);\nPyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);\n\n/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a\n   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),\n   returning the names of the current locals.  In this case, if there are\n   no current locals, NULL is returned, and PyErr_Occurred() is false.\n*/\nPyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);\n\n/* Helpers for printing recursive container types */\nPyAPI_FUNC(int) Py_ReprEnter(PyObject *);\nPyAPI_FUNC(void) Py_ReprLeave(PyObject *);\n\n/* Flag bits for printing: */\n#define Py_PRINT_RAW    1       /* No string quotes etc. */\n\n/*\nType flags (tp_flags)\n\nThese flags are used to change expected features and behavior for a\nparticular type.\n\nArbitration of the flag bit positions will need to be coordinated among\nall extension writers who publicly release their extensions (this will\nbe fewer than you might expect!).\n\nMost flags were removed as of Python 3.0 to make room for new flags.  (Some\nflags are not for backwards compatibility but to indicate the presence of an\noptional feature; these flags remain of course.)\n\nType definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.\n\nCode can use PyType_HasFeature(type_ob, flag_value) to test whether the\ngiven type object has a specified feature.\n*/\n\n#ifndef Py_LIMITED_API\n\n/* Track types initialized using _PyStaticType_InitBuiltin(). */\n#define _Py_TPFLAGS_STATIC_BUILTIN (1 << 1)\n\n/* The values array is placed inline directly after the rest of\n * the object. Implies Py_TPFLAGS_HAVE_GC.\n */\n#define Py_TPFLAGS_INLINE_VALUES (1 << 2)\n\n/* Placement of weakref pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_weaklistoffset.\n */\n#define Py_TPFLAGS_MANAGED_WEAKREF (1 << 3)\n\n/* Placement of dict (and values) pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_dictoffset. Implies Py_TPFLAGS_HAVE_GC.\n */\n#define Py_TPFLAGS_MANAGED_DICT (1 << 4)\n\n#define Py_TPFLAGS_PREHEADER (Py_TPFLAGS_MANAGED_WEAKREF | Py_TPFLAGS_MANAGED_DICT)\n\n/* Set if instances of the type object are treated as sequences for pattern matching */\n#define Py_TPFLAGS_SEQUENCE (1 << 5)\n/* Set if instances of the type object are treated as mappings for pattern matching */\n#define Py_TPFLAGS_MAPPING (1 << 6)\n#endif\n\n/* Disallow creating instances of the type: set tp_new to NULL and don't create\n * the \"__new__\" key in the type dictionary. */\n#define Py_TPFLAGS_DISALLOW_INSTANTIATION (1UL << 7)\n\n/* Set if the type object is immutable: type attributes cannot be set nor deleted */\n#define Py_TPFLAGS_IMMUTABLETYPE (1UL << 8)\n\n/* Set if the type object is dynamically allocated */\n#define Py_TPFLAGS_HEAPTYPE (1UL << 9)\n\n/* Set if the type allows subclassing */\n#define Py_TPFLAGS_BASETYPE (1UL << 10)\n\n/* Set if the type implements the vectorcall protocol (PEP 590) */\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\n#define Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)\n#ifndef Py_LIMITED_API\n// Backwards compatibility alias for API that was provisional in Python 3.8\n#define _Py_TPFLAGS_HAVE_VECTORCALL Py_TPFLAGS_HAVE_VECTORCALL\n#endif\n#endif\n\n/* Set if the type is 'ready' -- fully initialized */\n#define Py_TPFLAGS_READY (1UL << 12)\n\n/* Set while the type is being 'readied', to prevent recursive ready calls */\n#define Py_TPFLAGS_READYING (1UL << 13)\n\n/* Objects support garbage collection (see objimpl.h) */\n#define Py_TPFLAGS_HAVE_GC (1UL << 14)\n\n/* These two bits are preserved for Stackless Python, next after this is 17 */\n#ifdef STACKLESS\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)\n#else\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0\n#endif\n\n/* Objects behave like an unbound method */\n#define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)\n\n/* Unused. Legacy flag */\n#define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)\n\n/* Type is abstract and cannot be instantiated */\n#define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)\n\n// This undocumented flag gives certain built-ins their unique pattern-matching\n// behavior, which allows a single positional subpattern to match against the\n// subject itself (rather than a mapped attribute on it):\n#define _Py_TPFLAGS_MATCH_SELF (1UL << 22)\n\n/* Items (ob_size*tp_itemsize) are found at the end of an instance's memory */\n#define Py_TPFLAGS_ITEMS_AT_END (1UL << 23)\n\n/* These flags are used to determine if a type is a subclass. */\n#define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)\n#define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)\n#define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)\n#define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)\n#define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)\n#define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)\n#define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)\n#define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)\n\n#define Py_TPFLAGS_DEFAULT  ( \\\n                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \\\n                0)\n\n/* NOTE: Some of the following flags reuse lower bits (removed as part of the\n * Python 3.0 transition). */\n\n/* The following flags are kept for compatibility; in previous\n * versions they indicated presence of newer tp_* fields on the\n * type struct.\n * Starting with 3.8, binary compatibility of C extensions across\n * feature releases of Python is not supported anymore (except when\n * using the stable ABI, in which all classes are created dynamically,\n * using the interpreter's memory layout.)\n * Note that older extensions using the stable ABI set these flags,\n * so the bits must not be repurposed.\n */\n#define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)\n#define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)\n\n\n/*\nThe macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement\nreference counts.  Py_DECREF calls the object's deallocator function when\nthe refcount falls to 0; for\nobjects that don't contain references to other objects or heap memory\nthis can be the standard function free().  Both macros can be used\nwherever a void expression is allowed.  The argument must not be a\nNULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.\nThe macro _Py_NewReference(op) initialize reference counts to 1, and\nin special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional\nbookkeeping appropriate to the special build.\n\nWe assume that the reference count field can never overflow; this can\nbe proven when the size of the field is the same as the pointer size, so\nwe ignore the possibility.  Provided a C int is at least 32 bits (which\nis implicitly assumed in many parts of this code), that's enough for\nabout 2**31 references to an object.\n\nXXX The following became out of date in Python 2.2, but I'm not sure\nXXX what the full truth is now.  Certainly, heap-allocated type objects\nXXX can and should be deallocated.\nType objects should never be deallocated; the type pointer in an object\nis not considered to be a reference to the type object, to save\ncomplications in the deallocation function.  (This is actually a\ndecision that's up to the implementer of each new type so if you want,\nyou can count such references to the type object.)\n*/\n\n#if defined(Py_REF_DEBUG) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,\n                                      PyObject *op);\nPyAPI_FUNC(void) _Py_INCREF_IncRefTotal(void);\nPyAPI_FUNC(void) _Py_DECREF_DecRefTotal(void);\n#endif  // Py_REF_DEBUG && !Py_LIMITED_API\n\nPyAPI_FUNC(void) _Py_Dealloc(PyObject *);\n\n/*\nThese are provided as conveniences to Python runtime embedders, so that\nthey can have object code that is not dependent on Python compilation flags.\n*/\nPyAPI_FUNC(void) Py_IncRef(PyObject *);\nPyAPI_FUNC(void) Py_DecRef(PyObject *);\n\n// Similar to Py_IncRef() and Py_DecRef() but the argument must be non-NULL.\n// Private functions used by Py_INCREF() and Py_DECREF().\nPyAPI_FUNC(void) _Py_IncRef(PyObject *);\nPyAPI_FUNC(void) _Py_DecRef(PyObject *);\n\nstatic inline Py_ALWAYS_INLINE void Py_INCREF(PyObject *op)\n{\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n    // Stable ABI implements Py_INCREF() as a function call on limited C API\n    // version 3.12 and newer, and on Python built in debug mode. _Py_IncRef()\n    // was added to Python 3.10.0a7, use Py_IncRef() on older Python versions.\n    // Py_IncRef() accepts NULL whereas _Py_IncRef() doesn't.\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_IncRef(op);\n#  else\n    Py_IncRef(op);\n#  endif\n#else\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n#if defined(Py_GIL_DISABLED)\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    uint32_t new_local = local + 1;\n    if (new_local == 0) {\n        // local is equal to _Py_IMMORTAL_REFCNT: do nothing\n        return;\n    }\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, new_local);\n    }\n    else {\n        _Py_atomic_add_ssize(&op->ob_ref_shared, (1 << _Py_REF_SHARED_SHIFT));\n    }\n#elif SIZEOF_VOID_P > 4\n    // Portable saturated add, branching on the carry flag and set low bits\n    PY_UINT32_T cur_refcnt = op->ob_refcnt_split[PY_BIG_ENDIAN];\n    PY_UINT32_T new_refcnt = cur_refcnt + 1;\n    if (new_refcnt == 0) {\n        // cur_refcnt is equal to _Py_IMMORTAL_REFCNT: the object is immortal,\n        // do nothing\n        return;\n    }\n    op->ob_refcnt_split[PY_BIG_ENDIAN] = new_refcnt;\n#else\n    // Explicitly check immortality against the immortal value\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    op->ob_refcnt++;\n#endif\n    _Py_INCREF_STAT_INC();\n#ifdef Py_REF_DEBUG\n    _Py_INCREF_IncRefTotal();\n#endif\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_INCREF(op) Py_INCREF(_PyObject_CAST(op))\n#endif\n\n\n#if !defined(Py_LIMITED_API) && defined(Py_GIL_DISABLED)\n// Implements Py_DECREF on objects not owned by the current thread.\nPyAPI_FUNC(void) _Py_DecRefShared(PyObject *);\nPyAPI_FUNC(void) _Py_DecRefSharedDebug(PyObject *, const char *, int);\n\n// Called from Py_DECREF by the owning thread when the local refcount reaches\n// zero. The call will deallocate the object if the shared refcount is also\n// zero. Otherwise, the thread gives up ownership and merges the reference\n// count fields.\nPyAPI_FUNC(void) _Py_MergeZeroLocalRefcount(PyObject *);\n#endif\n\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n// Stable ABI implements Py_DECREF() as a function call on limited C API\n// version 3.12 and newer, and on Python built in debug mode. _Py_DecRef() was\n// added to Python 3.10.0a7, use Py_DecRef() on older Python versions.\n// Py_DecRef() accepts NULL whereas _Py_IncRef() doesn't.\nstatic inline void Py_DECREF(PyObject *op) {\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_DecRef(op);\n#  else\n    Py_DecRef(op);\n#  endif\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_GIL_DISABLED) && defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        if (local == 0) {\n            _Py_NegativeRefcount(filename, lineno, op);\n        }\n        local--;\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, local);\n        if (local == 0) {\n            _Py_MergeZeroLocalRefcount(op);\n        }\n    }\n    else {\n        _Py_DecRefSharedDebug(op, filename, lineno);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#elif defined(Py_GIL_DISABLED)\nstatic inline void Py_DECREF(PyObject *op)\n{\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        local--;\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, local);\n        if (local == 0) {\n            _Py_MergeZeroLocalRefcount(op);\n        }\n    }\n    else {\n        _Py_DecRefShared(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    if (op->ob_refcnt <= 0) {\n        _Py_NegativeRefcount(filename, lineno, op);\n    }\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#else\nstatic inline Py_ALWAYS_INLINE void Py_DECREF(PyObject *op)\n{\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n#endif\n\n\n/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear\n * and tp_dealloc implementations.\n *\n * Note that \"the obvious\" code can be deadly:\n *\n *     Py_XDECREF(op);\n *     op = NULL;\n *\n * Typically, `op` is something like self->containee, and `self` is done\n * using its `containee` member.  In the code sequence above, suppose\n * `containee` is non-NULL with a refcount of 1.  Its refcount falls to\n * 0 on the first line, which can trigger an arbitrary amount of code,\n * possibly including finalizers (like __del__ methods or weakref callbacks)\n * coded in Python, which in turn can release the GIL and allow other threads\n * to run, etc.  Such code may even invoke methods of `self` again, or cause\n * cyclic gc to trigger, but-- oops! --self->containee still points to the\n * object being torn down, and it may be in an insane state while being torn\n * down.  This has in fact been a rich historic source of miserable (rare &\n * hard-to-diagnose) segfaulting (and other) bugs.\n *\n * The safe way is:\n *\n *      Py_CLEAR(op);\n *\n * That arranges to set `op` to NULL _before_ decref'ing, so that any code\n * triggered as a side-effect of `op` getting torn down no longer believes\n * `op` points to a valid object.\n *\n * There are cases where it's safe to use the naive code, but they're brittle.\n * For example, if `op` points to a Python integer, you know that destroying\n * one of those can't cause problems -- but in part that relies on that\n * Python integers aren't currently weakly referencable.  Best practice is\n * to use Py_CLEAR() even if you can't think of a reason for why you need to.\n *\n * gh-98724: Use a temporary variable to only evaluate the macro argument once,\n * to avoid the duplication of side effects if the argument has side effects.\n *\n * gh-99701: If the PyObject* type is used with casting arguments to PyObject*,\n * the code can be miscompiled with strict aliasing because of type punning.\n * With strict aliasing, a compiler considers that two pointers of different\n * types cannot read or write the same memory which enables optimization\n * opportunities.\n *\n * If available, use _Py_TYPEOF() to use the 'op' type for temporary variables,\n * and so avoid type punning. Otherwise, use memcpy() which causes type erasure\n * and so prevents the compiler to reuse an old cached 'op' value after\n * Py_CLEAR().\n */\n#ifdef _Py_TYPEOF\n#define Py_CLEAR(op) \\\n    do { \\\n        _Py_TYPEOF(op)* _tmp_op_ptr = &(op); \\\n        _Py_TYPEOF(op) _tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            *_tmp_op_ptr = _Py_NULL; \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#else\n#define Py_CLEAR(op) \\\n    do { \\\n        PyObject **_tmp_op_ptr = _Py_CAST(PyObject**, &(op)); \\\n        PyObject *_tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            PyObject *_null_ptr = _Py_NULL; \\\n            memcpy(_tmp_op_ptr, &_null_ptr, sizeof(PyObject*)); \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#endif\n\n\n/* Function to use in case the object pointer can be NULL: */\nstatic inline void Py_XINCREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_INCREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XINCREF(op) Py_XINCREF(_PyObject_CAST(op))\n#endif\n\nstatic inline void Py_XDECREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_DECREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XDECREF(op) Py_XDECREF(_PyObject_CAST(op))\n#endif\n\n// Create a new strong reference to an object:\n// increment the reference count of the object and return the object.\nPyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);\n\n// Similar to Py_NewRef(), but the object can be NULL.\nPyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);\n\nstatic inline PyObject* _Py_NewRef(PyObject *obj)\n{\n    Py_INCREF(obj);\n    return obj;\n}\n\nstatic inline PyObject* _Py_XNewRef(PyObject *obj)\n{\n    Py_XINCREF(obj);\n    return obj;\n}\n\n// Py_NewRef() and Py_XNewRef() are exported as functions for the stable ABI.\n// Names overridden with macros by static inline functions for best\n// performances.\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_NewRef(obj) _Py_NewRef(_PyObject_CAST(obj))\n#  define Py_XNewRef(obj) _Py_XNewRef(_PyObject_CAST(obj))\n#else\n#  define Py_NewRef(obj) _Py_NewRef(obj)\n#  define Py_XNewRef(obj) _Py_XNewRef(obj)\n#endif\n\n\n#define Py_CONSTANT_NONE 0\n#define Py_CONSTANT_FALSE 1\n#define Py_CONSTANT_TRUE 2\n#define Py_CONSTANT_ELLIPSIS 3\n#define Py_CONSTANT_NOT_IMPLEMENTED 4\n#define Py_CONSTANT_ZERO 5\n#define Py_CONSTANT_ONE 6\n#define Py_CONSTANT_EMPTY_STR 7\n#define Py_CONSTANT_EMPTY_BYTES 8\n#define Py_CONSTANT_EMPTY_TUPLE 9\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(PyObject*) Py_GetConstant(unsigned int constant_id);\nPyAPI_FUNC(PyObject*) Py_GetConstantBorrowed(unsigned int constant_id);\n#endif\n\n\n/*\n_Py_NoneStruct is an object of undefined type which can be used in contexts\nwhere NULL (nil) is not suitable (since NULL often means 'error').\n*/\nPyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000\n#  define Py_None Py_GetConstantBorrowed(Py_CONSTANT_NONE)\n#else\n#  define Py_None (&_Py_NoneStruct)\n#endif\n\n// Test if an object is the None singleton, the same as \"x is None\" in Python.\nPyAPI_FUNC(int) Py_IsNone(PyObject *x);\n#define Py_IsNone(x) Py_Is((x), Py_None)\n\n/* Macro for returning Py_None from a function */\n#define Py_RETURN_NONE return Py_None\n\n/*\nPy_NotImplemented is a singleton used to signal that an operation is\nnot implemented for a given type combination.\n*/\nPyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */\n\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000\n#  define Py_NotImplemented Py_GetConstantBorrowed(Py_CONSTANT_NOT_IMPLEMENTED)\n#else\n#  define Py_NotImplemented (&_Py_NotImplementedStruct)\n#endif\n\n/* Macro for returning Py_NotImplemented from a function */\n#define Py_RETURN_NOTIMPLEMENTED return Py_NotImplemented\n\n/* Rich comparison opcodes */\n#define Py_LT 0\n#define Py_LE 1\n#define Py_EQ 2\n#define Py_NE 3\n#define Py_GT 4\n#define Py_GE 5\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000\n/* Result of calling PyIter_Send */\ntypedef enum {\n    PYGEN_RETURN = 0,\n    PYGEN_ERROR = -1,\n    PYGEN_NEXT = 1,\n} PySendResult;\n#endif\n\n/*\n * Macro for implementing rich comparisons\n *\n * Needs to be a macro because any C-comparable type can be used.\n */\n#define Py_RETURN_RICHCOMPARE(val1, val2, op)                               \\\n    do {                                                                    \\\n        switch (op) {                                                       \\\n        case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        default:                                                            \\\n            Py_UNREACHABLE();                                               \\\n        }                                                                   \\\n    } while (0)\n\n\n/*\nMore conventions\n================\n\nArgument Checking\n-----------------\n\nFunctions that take objects as arguments normally don't check for nil\narguments, but they do check the type of the argument, and return an\nerror if the function doesn't apply to the type.\n\nFailure Modes\n-------------\n\nFunctions may fail for a variety of reasons, including running out of\nmemory.  This is communicated to the caller in two ways: an error string\nis set (see errors.h), and the function result differs: functions that\nnormally return a pointer return NULL for failure, functions returning\nan integer return -1 (which could be a legal return value too!), and\nother functions return 0 for success and -1 for failure.\nCallers should always check for errors before using the result.  If\nan error was set, the caller must either explicitly clear it, or pass\nthe error on to its caller.\n\nReference Counts\n----------------\n\nIt takes a while to get used to the proper usage of reference counts.\n\nFunctions that create an object set the reference count to 1; such new\nobjects must be stored somewhere or destroyed again with Py_DECREF().\nSome functions that 'store' objects, such as PyTuple_SetItem() and\nPyList_SetItem(),\ndon't increment the reference count of the object, since the most\nfrequent use is to store a fresh object.  Functions that 'retrieve'\nobjects, such as PyTuple_GetItem() and PyDict_GetItemString(), also\ndon't increment\nthe reference count, since most frequently the object is only looked at\nquickly.  Thus, to retrieve an object and store it again, the caller\nmust call Py_INCREF() explicitly.\n\nNOTE: functions that 'consume' a reference count, like\nPyList_SetItem(), consume the reference even if the object wasn't\nsuccessfully stored, to simplify error handling.\n\nIt seems attractive to make other functions that take an object as\nargument consume a reference count; however, this may quickly get\nconfusing (even the current practice is already confusing).  Consider\nit carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at\ntimes.\n*/\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_OBJECT_H\n#  include \"cpython/object.h\"\n#  undef Py_CPYTHON_OBJECT_H\n#endif\n\n\nstatic inline int\nPyType_HasFeature(PyTypeObject *type, unsigned long feature)\n{\n    unsigned long flags;\n#ifdef Py_LIMITED_API\n    // PyTypeObject is opaque in the limited C API\n    flags = PyType_GetFlags(type);\n#else\n#   ifdef Py_GIL_DISABLED\n        flags = _Py_atomic_load_ulong_relaxed(&type->tp_flags);\n#   else\n        flags = type->tp_flags;\n#   endif\n#endif\n    return ((flags & feature) != 0);\n}\n\n#define PyType_FastSubclass(type, flag) PyType_HasFeature((type), (flag))\n\nstatic inline int PyType_Check(PyObject *op) {\n    return PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_Check(op) PyType_Check(_PyObject_CAST(op))\n#endif\n\n#define _PyType_CAST(op) \\\n    (assert(PyType_Check(op)), _Py_CAST(PyTypeObject*, (op)))\n\nstatic inline int PyType_CheckExact(PyObject *op) {\n    return Py_IS_TYPE(op, &PyType_Type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_CheckExact(op) PyType_CheckExact(_PyObject_CAST(op))\n#endif\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(PyObject *) PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif   // !Py_OBJECT_H\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "/usr/include/sys/stat.h"},
                          "contents": {"text": "/* Copyright (C) 1991-2024 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <https://www.gnu.org/licenses/>.  */\n\n/*\n *\tPOSIX Standard: 5.6 File Characteristics\t<sys/stat.h>\n */\n\n#ifndef\t_SYS_STAT_H\n#define\t_SYS_STAT_H\t1\n\n#include <features.h>\n\n#include <bits/types.h>\t\t/* For __mode_t and __dev_t.  */\n\n#ifdef __USE_XOPEN2K8\n# include <bits/types/struct_timespec.h>\n#endif\n\n#if defined __USE_XOPEN || defined __USE_XOPEN2K\n/* The Single Unix specification says that some more types are\n   available here.  */\n\n# include <bits/types/time_t.h>\n\n# ifndef __dev_t_defined\ntypedef __dev_t dev_t;\n#  define __dev_t_defined\n# endif\n\n# ifndef __gid_t_defined\ntypedef __gid_t gid_t;\n#  define __gid_t_defined\n# endif\n\n# ifndef __ino_t_defined\n#  ifndef __USE_FILE_OFFSET64\ntypedef __ino_t ino_t;\n#  else\ntypedef __ino64_t ino_t;\n#  endif\n#  define __ino_t_defined\n# endif\n\n# ifndef __mode_t_defined\ntypedef __mode_t mode_t;\n#  define __mode_t_defined\n# endif\n\n# ifndef __nlink_t_defined\ntypedef __nlink_t nlink_t;\n#  define __nlink_t_defined\n# endif\n\n# ifndef __off_t_defined\n#  ifndef __USE_FILE_OFFSET64\ntypedef __off_t off_t;\n#  else\ntypedef __off64_t off_t;\n#  endif\n#  define __off_t_defined\n# endif\n\n# ifndef __uid_t_defined\ntypedef __uid_t uid_t;\n#  define __uid_t_defined\n# endif\n#endif\t/* X/Open */\n\n#ifdef __USE_UNIX98\n# ifndef __blkcnt_t_defined\n#  ifndef __USE_FILE_OFFSET64\ntypedef __blkcnt_t blkcnt_t;\n#  else\ntypedef __blkcnt64_t blkcnt_t;\n#  endif\n#  define __blkcnt_t_defined\n# endif\n\n# ifndef __blksize_t_defined\ntypedef __blksize_t blksize_t;\n#  define __blksize_t_defined\n# endif\n#endif\t/* Unix98 */\n\n__BEGIN_DECLS\n\n#include <bits/stat.h>\n\n#if defined __USE_MISC || defined __USE_XOPEN\n# define S_IFMT\t\t__S_IFMT\n# define S_IFDIR\t__S_IFDIR\n# define S_IFCHR\t__S_IFCHR\n# define S_IFBLK\t__S_IFBLK\n# define S_IFREG\t__S_IFREG\n# ifdef __S_IFIFO\n#  define S_IFIFO\t__S_IFIFO\n# endif\n# ifdef __S_IFLNK\n#  define S_IFLNK\t__S_IFLNK\n# endif\n# if (defined __USE_MISC || defined __USE_XOPEN_EXTENDED) \\\n     && defined __S_IFSOCK\n#  define S_IFSOCK\t__S_IFSOCK\n# endif\n#endif\n\n/* Test macros for file types.\t*/\n\n#define\t__S_ISTYPE(mode, mask)\t(((mode) & __S_IFMT) == (mask))\n\n#define\tS_ISDIR(mode)\t __S_ISTYPE((mode), __S_IFDIR)\n#define\tS_ISCHR(mode)\t __S_ISTYPE((mode), __S_IFCHR)\n#define\tS_ISBLK(mode)\t __S_ISTYPE((mode), __S_IFBLK)\n#define\tS_ISREG(mode)\t __S_ISTYPE((mode), __S_IFREG)\n#ifdef __S_IFIFO\n# define S_ISFIFO(mode)\t __S_ISTYPE((mode), __S_IFIFO)\n#endif\n#ifdef __S_IFLNK\n# define S_ISLNK(mode)\t __S_ISTYPE((mode), __S_IFLNK)\n#endif\n\n#if defined __USE_MISC && !defined __S_IFLNK\n# define S_ISLNK(mode)  0\n#endif\n\n#if (defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K) \\\n    && defined __S_IFSOCK\n# define S_ISSOCK(mode) __S_ISTYPE((mode), __S_IFSOCK)\n#elif defined __USE_XOPEN2K\n# define S_ISSOCK(mode) 0\n#endif\n\n/* These are from POSIX.1b.  If the objects are not implemented using separate\n   distinct file types, the macros always will evaluate to zero.  Unlike the\n   other S_* macros the following three take a pointer to a `struct stat'\n   object as the argument.  */\n#ifdef\t__USE_POSIX199309\n# define S_TYPEISMQ(buf) __S_TYPEISMQ(buf)\n# define S_TYPEISSEM(buf) __S_TYPEISSEM(buf)\n# define S_TYPEISSHM(buf) __S_TYPEISSHM(buf)\n#endif\n\n\n/* Protection bits.  */\n\n#define\tS_ISUID __S_ISUID\t/* Set user ID on execution.  */\n#define\tS_ISGID\t__S_ISGID\t/* Set group ID on execution.  */\n\n#if defined __USE_MISC || defined __USE_XOPEN\n/* Save swapped text after use (sticky bit).  This is pretty well obsolete.  */\n# define S_ISVTX\t__S_ISVTX\n#endif\n\n#define\tS_IRUSR\t__S_IREAD\t/* Read by owner.  */\n#define\tS_IWUSR\t__S_IWRITE\t/* Write by owner.  */\n#define\tS_IXUSR\t__S_IEXEC\t/* Execute by owner.  */\n/* Read, write, and execute by owner.  */\n#define\tS_IRWXU\t(__S_IREAD|__S_IWRITE|__S_IEXEC)\n\n#ifdef __USE_MISC\n# define S_IREAD\tS_IRUSR\n# define S_IWRITE\tS_IWUSR\n# define S_IEXEC\tS_IXUSR\n#endif\n\n#define\tS_IRGRP\t(S_IRUSR >> 3)\t/* Read by group.  */\n#define\tS_IWGRP\t(S_IWUSR >> 3)\t/* Write by group.  */\n#define\tS_IXGRP\t(S_IXUSR >> 3)\t/* Execute by group.  */\n/* Read, write, and execute by group.  */\n#define\tS_IRWXG\t(S_IRWXU >> 3)\n\n#define\tS_IROTH\t(S_IRGRP >> 3)\t/* Read by others.  */\n#define\tS_IWOTH\t(S_IWGRP >> 3)\t/* Write by others.  */\n#define\tS_IXOTH\t(S_IXGRP >> 3)\t/* Execute by others.  */\n/* Read, write, and execute by others.  */\n#define\tS_IRWXO\t(S_IRWXG >> 3)\n\n\n#ifdef\t__USE_MISC\n/* Macros for common mode bit masks.  */\n# define ACCESSPERMS (S_IRWXU|S_IRWXG|S_IRWXO) /* 0777 */\n# define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)/* 07777 */\n# define DEFFILEMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)/* 0666*/\n\n# define S_BLKSIZE\t512\t/* Block size for `st_blocks'.  */\n#endif\n\n\n#ifndef __USE_FILE_OFFSET64\n/* Get file attributes for FILE and put them in BUF.  */\nextern int stat (const char *__restrict __file,\n\t\t struct stat *__restrict __buf) __THROW __nonnull ((1, 2));\n\n/* Get file attributes for the file, device, pipe, or socket\n   that file descriptor FD is open on and put them in BUF.  */\nextern int fstat (int __fd, struct stat *__buf) __THROW __nonnull ((2));\n#else\n# ifdef __USE_TIME64_REDIRECTS\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (stat, (const char *__restrict __file,\n\t\t\t\t  struct stat *__restrict __buf),\n\t\t\t\t  __stat64_time64)\n     __nonnull ((1, 2));\nextern int __REDIRECT_NTH (fstat, (int __fd, struct stat *__buf),\n\t\t\t\t   __fstat64_time64)\n     __nonnull ((2));\n#  else\n#   define stat __stat64_time64\n#   define fstat __fstat64_time64\n#  endif\n# else\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (stat, (const char *__restrict __file,\n\t\t\t\t  struct stat *__restrict __buf), stat64)\n     __nonnull ((1, 2));\nextern int __REDIRECT_NTH (fstat, (int __fd, struct stat *__buf), fstat64)\n     __nonnull ((2));\n#  else\n#   define stat stat64\n#   define fstat fstat64\n#  endif\n# endif\n#endif\n#ifdef __USE_LARGEFILE64\n# ifndef __USE_TIME64_REDIRECTS\nextern int stat64 (const char *__restrict __file,\n\t\t   struct stat64 *__restrict __buf) __THROW __nonnull ((1, 2));\nextern int fstat64 (int __fd, struct stat64 *__buf) __THROW __nonnull ((2));\n# else\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (stat64, (const char *__restrict __file,\n\t\t\t\t    struct stat64 *__restrict __buf),\n\t\t\t   __stat64_time64)\n     __nonnull ((1, 2));\nextern int __REDIRECT_NTH (fstat64, (int __fd, struct stat64 *__buf),\n\t\t\t   __fstat64_time64)\n     __nonnull ((2));\n#  else\n#   define stat64 __stat64_time64\n#   define fstat64 __fstat64_time64\n#  endif\n# endif\n#endif\n\n#ifdef __USE_ATFILE\n/* Similar to stat, get the attributes for FILE and put them in BUF.\n   Relative path names are interpreted relative to FD unless FD is\n   AT_FDCWD.  */\n# ifndef __USE_FILE_OFFSET64\nextern int fstatat (int __fd, const char *__restrict __file,\n\t\t    struct stat *__restrict __buf, int __flag)\n     __THROW __nonnull ((2, 3));\n# else\n#  ifdef __USE_TIME64_REDIRECTS\n#   ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (fstatat, (int __fd, const char *__restrict __file,\n\t\t\t\t     struct stat *__restrict __buf,\n\t\t\t\t     int __flag),\n\t\t\t   __fstatat64_time64) __nonnull ((2, 3));\n#   else\n#    define fstatat __fstatat64_time64\n#   endif\n#  else\n#   ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (fstatat, (int __fd, const char *__restrict __file,\n\t\t\t\t     struct stat *__restrict __buf,\n\t\t\t\t     int __flag),\n\t\t\t   fstatat64) __nonnull ((2, 3));\n#   else\n#    define fstatat fstatat64\n#   endif\n#  endif\n# endif\n\n# ifdef __USE_LARGEFILE64\n#  ifndef __USE_TIME64_REDIRECTS\nextern int fstatat64 (int __fd, const char *__restrict __file,\n\t\t      struct stat64 *__restrict __buf, int __flag)\n     __THROW __nonnull ((2, 3));\n#  else\n#   ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (fstatat64, (int __fd,\n\t\t\t\t       const char *__restrict __file,\n\t\t\t\t       struct stat64 *__restrict __buf,\n\t\t\t\t       int __flag),\n\t\t\t   __fstatat64_time64)\n     __nonnull ((2, 3));\n#   else\n#    define fstatat64 __fstatat64_time64\n#   endif\n#  endif\n# endif\n#endif\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K\n# ifndef __USE_FILE_OFFSET64\n/* Get file attributes about FILE and put them in BUF.\n   If FILE is a symbolic link, do not follow it.  */\nextern int lstat (const char *__restrict __file,\n\t\t  struct stat *__restrict __buf) __THROW __nonnull ((1, 2));\n# else\n#  ifdef __USE_TIME64_REDIRECTS\n#   ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (lstat,\n\t\t\t   (const char *__restrict __file,\n\t\t\t    struct stat *__restrict __buf), __lstat64_time64)\n     __nonnull ((1, 2));\n#   else\n#    define lstat __lstat64_time64\n#   endif\n#  else\n#   ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (lstat,\n\t\t\t   (const char *__restrict __file,\n\t\t\t    struct stat *__restrict __buf), lstat64)\n     __nonnull ((1, 2));\n#   else\n#    define lstat lstat64\n#   endif\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\n#  ifndef __USE_TIME64_REDIRECTS\nextern int lstat64 (const char *__restrict __file,\n\t\t    struct stat64 *__restrict __buf)\n     __THROW __nonnull ((1, 2));\n#  else\nextern int __REDIRECT_NTH (lstat64, (const char *__restrict __file,\n\t\t\t\t     struct stat64 *__restrict __buf),\n\t\t\t   __lstat64_time64)\n     __nonnull ((1, 2));\n#  endif\n# endif\n#endif\n\n/* Set file access permissions for FILE to MODE.\n   If FILE is a symbolic link, this affects its target instead.  */\nextern int chmod (const char *__file, __mode_t __mode)\n     __THROW __nonnull ((1));\n\n#ifdef __USE_MISC\n/* Set file access permissions for FILE to MODE.\n   If FILE is a symbolic link, this affects the link itself\n   rather than its target.  */\nextern int lchmod (const char *__file, __mode_t __mode)\n     __THROW __nonnull ((1));\n#endif\n\n/* Set file access permissions of the file FD is open on to MODE.  */\n#if defined __USE_POSIX199309 || defined __USE_XOPEN_EXTENDED\nextern int fchmod (int __fd, __mode_t __mode) __THROW;\n#endif\n\n#ifdef __USE_ATFILE\n/* Set file access permissions of FILE relative to\n   the directory FD is open on.  */\nextern int fchmodat (int __fd, const char *__file, __mode_t __mode,\n\t\t     int __flag)\n     __THROW __nonnull ((2)) __wur;\n#endif /* Use ATFILE.  */\n\n\n\n/* Set the file creation mask of the current process to MASK,\n   and return the old creation mask.  */\nextern __mode_t umask (__mode_t __mask) __THROW;\n\n#ifdef\t__USE_GNU\n/* Get the current `umask' value without changing it.\n   This function is only available under the GNU Hurd.  */\nextern __mode_t getumask (void) __THROW;\n#endif\n\n/* Create a new directory named PATH, with permission bits MODE.  */\nextern int mkdir (const char *__path, __mode_t __mode)\n     __THROW __nonnull ((1));\n\n#ifdef __USE_ATFILE\n/* Like mkdir, create a new directory with permission bits MODE.  But\n   interpret relative PATH names relative to the directory associated\n   with FD.  */\nextern int mkdirat (int __fd, const char *__path, __mode_t __mode)\n     __THROW __nonnull ((2));\n#endif\n\n/* Create a device file named PATH, with permission and special bits MODE\n   and device number DEV (which can be constructed from major and minor\n   device numbers with the `makedev' macro above).  */\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\nextern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)\n     __THROW __nonnull ((1));\n\n# ifdef __USE_ATFILE\n/* Like mknod, create a new device file with permission bits MODE and\n   device number DEV.  But interpret relative PATH names relative to\n   the directory associated with FD.  */\nextern int mknodat (int __fd, const char *__path, __mode_t __mode,\n\t\t    __dev_t __dev) __THROW __nonnull ((2));\n# endif\n#endif\n\n\n/* Create a new FIFO named PATH, with permission bits MODE.  */\nextern int mkfifo (const char *__path, __mode_t __mode)\n     __THROW __nonnull ((1));\n\n#ifdef __USE_ATFILE\n/* Like mkfifo, create a new FIFO with permission bits MODE.  But\n   interpret relative PATH names relative to the directory associated\n   with FD.  */\nextern int mkfifoat (int __fd, const char *__path, __mode_t __mode)\n     __THROW __nonnull ((2));\n#endif\n\f\n#ifdef __USE_ATFILE\n# ifndef __USE_TIME64_REDIRECTS\n/* Set file access and modification times relative to directory file\n   descriptor.  */\nextern int utimensat (int __fd, const char *__path,\n\t\t      const struct timespec __times[2],\n\t\t      int __flags)\n     __THROW __nonnull ((2));\n# else\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (utimensat, (int fd, const char *__path,\n                                       const struct timespec __times[2],\n                                       int flags),\n                           __utimensat64) __nonnull ((2));\n#  else\n#   define utimensat __utimensat64\n#  endif\n# endif\n#endif\n\n#ifdef __USE_XOPEN2K8\n# ifndef __USE_TIME64_REDIRECTS\n/* Set file access and modification times of the file associated with FD.  */\nextern int futimens (int __fd, const struct timespec __times[2]) __THROW;\n\n# else\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (futimens, (int fd, const struct timespec __times[2]),\n                           __futimens64);\n#  else\n#   define futimens __futimens64\n#  endif\n# endif\n#endif\n\n#ifdef __USE_GNU\n# include <bits/statx.h>\n#endif\n\n__END_DECLS\n\n\n#endif /* sys/stat.h  */\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Modules/clinic/posixmodule.c.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/*[clinic input]\npreserve\n[clinic start generated code]*/\n\n#if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n#  include \"pycore_gc.h\"          // PyGC_Head\n#  include \"pycore_runtime.h\"     // _Py_ID()\n#endif\n#include \"pycore_abstract.h\"      // _PyNumber_Index()\n#include \"pycore_long.h\"          // _PyLong_UnsignedInt_Converter()\n#include \"pycore_modsupport.h\"    // _PyArg_UnpackKeywords()\n\nPyDoc_STRVAR(os_stat__doc__,\n\"stat($module, /, path, *, dir_fd=None, follow_symlinks=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Perform a stat system call on the given path.\\n\"\n\"\\n\"\n\"  path\\n\"\n\"    Path to be examined; can be string, bytes, a path-like object or\\n\"\n\"    open-file-descriptor int.\\n\"\n\"  dir_fd\\n\"\n\"    If not None, it should be a file descriptor open to a directory,\\n\"\n\"    and path should be a relative string; path will then be relative to\\n\"\n\"    that directory.\\n\"\n\"  follow_symlinks\\n\"\n\"    If False, and the last element of the path is a symbolic link,\\n\"\n\"    stat will examine the symbolic link itself instead of the file\\n\"\n\"    the link points to.\\n\"\n\"\\n\"\n\"dir_fd and follow_symlinks may not be implemented\\n\"\n\"  on your platform.  If they are unavailable, using them will raise a\\n\"\n\"  NotImplementedError.\\n\"\n\"\\n\"\n\"It\\'s an error to use dir_fd or follow_symlinks when specifying path as\\n\"\n\"  an open file descriptor.\");\n\n#define OS_STAT_METHODDEF    \\\n    {\"stat\", _PyCFunction_CAST(os_stat), METH_FASTCALL|METH_KEYWORDS, os_stat__doc__},\n\nstatic PyObject *\nos_stat_impl(PyObject *module, path_t *path, int dir_fd, int follow_symlinks);\n\nstatic PyObject *\nos_stat(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(dir_fd), &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"dir_fd\", \"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"stat\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[3];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    path_t path = PATH_T_INITIALIZE_P(\"stat\", \"path\", 0, 0, 0, 1);\n    int dir_fd = DEFAULT_DIR_FD;\n    int follow_symlinks = 1;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (args[1]) {\n        if (!FSTATAT_DIR_FD_CONVERTER(args[1], &dir_fd)) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    follow_symlinks = PyObject_IsTrue(args[2]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_stat_impl(module, &path, dir_fd, follow_symlinks);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\nPyDoc_STRVAR(os_lstat__doc__,\n\"lstat($module, /, path, *, dir_fd=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Perform a stat system call on the given path, without following symbolic links.\\n\"\n\"\\n\"\n\"Like stat(), but do not follow symbolic links.\\n\"\n\"Equivalent to stat(path, follow_symlinks=False).\");\n\n#define OS_LSTAT_METHODDEF    \\\n    {\"lstat\", _PyCFunction_CAST(os_lstat), METH_FASTCALL|METH_KEYWORDS, os_lstat__doc__},\n\nstatic PyObject *\nos_lstat_impl(PyObject *module, path_t *path, int dir_fd);\n\nstatic PyObject *\nos_lstat(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(dir_fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"dir_fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"lstat\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    path_t path = PATH_T_INITIALIZE_P(\"lstat\", \"path\", 0, 0, 0, 0);\n    int dir_fd = DEFAULT_DIR_FD;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (!FSTATAT_DIR_FD_CONVERTER(args[1], &dir_fd)) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_lstat_impl(module, &path, dir_fd);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\nPyDoc_STRVAR(os_access__doc__,\n\"access($module, /, path, mode, *, dir_fd=None, effective_ids=False,\\n\"\n\"       follow_symlinks=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Use the real uid/gid to test for access to a path.\\n\"\n\"\\n\"\n\"  path\\n\"\n\"    Path to be tested; can be string, bytes, or a path-like object.\\n\"\n\"  mode\\n\"\n\"    Operating-system mode bitfield.  Can be F_OK to test existence,\\n\"\n\"    or the inclusive-OR of R_OK, W_OK, and X_OK.\\n\"\n\"  dir_fd\\n\"\n\"    If not None, it should be a file descriptor open to a directory,\\n\"\n\"    and path should be relative; path will then be relative to that\\n\"\n\"    directory.\\n\"\n\"  effective_ids\\n\"\n\"    If True, access will use the effective uid/gid instead of\\n\"\n\"    the real uid/gid.\\n\"\n\"  follow_symlinks\\n\"\n\"    If False, and the last element of the path is a symbolic link,\\n\"\n\"    access will examine the symbolic link itself instead of the file\\n\"\n\"    the link points to.\\n\"\n\"\\n\"\n\"dir_fd, effective_ids, and follow_symlinks may not be implemented\\n\"\n\"  on your platform.  If they are unavailable, using them will raise a\\n\"\n\"  NotImplementedError.\\n\"\n\"\\n\"\n\"Note that most operations will use the effective uid/gid, therefore this\\n\"\n\"  routine can be used in a suid/sgid environment to test if the invoking user\\n\"\n\"  has the specified access to the path.\");\n\n#define OS_ACCESS_METHODDEF    \\\n    {\"access\", _PyCFunction_CAST(os_access), METH_FASTCALL|METH_KEYWORDS, os_access__doc__},\n\nstatic int\nos_access_impl(PyObject *module, path_t *path, int mode, int dir_fd,\n               int effective_ids, int follow_symlinks);\n\nstatic PyObject *\nos_access(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 5\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(mode), &_Py_ID(dir_fd), &_Py_ID(effective_ids), &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"mode\", \"dir_fd\", \"effective_ids\", \"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"access\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[5];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;\n    path_t path = PATH_T_INITIALIZE_P(\"access\", \"path\", 0, 0, 0, 0);\n    int mode;\n    int dir_fd = DEFAULT_DIR_FD;\n    int effective_ids = 0;\n    int follow_symlinks = 1;\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    mode = PyLong_AsInt(args[1]);\n    if (mode == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (args[2]) {\n        if (!FACCESSAT_DIR_FD_CONVERTER(args[2], &dir_fd)) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[3]) {\n        effective_ids = PyObject_IsTrue(args[3]);\n        if (effective_ids < 0) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    follow_symlinks = PyObject_IsTrue(args[4]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    _return_value = os_access_impl(module, &path, mode, dir_fd, effective_ids, follow_symlinks);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#if defined(HAVE_TTYNAME)\n\nPyDoc_STRVAR(os_ttyname__doc__,\n\"ttyname($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the name of the terminal device connected to \\'fd\\'.\\n\"\n\"\\n\"\n\"  fd\\n\"\n\"    Integer file descriptor handle.\");\n\n#define OS_TTYNAME_METHODDEF    \\\n    {\"ttyname\", (PyCFunction)os_ttyname, METH_O, os_ttyname__doc__},\n\nstatic PyObject *\nos_ttyname_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_ttyname(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n\n    fd = PyLong_AsInt(arg);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_ttyname_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_TTYNAME) */\n\n#if defined(HAVE_CTERMID)\n\nPyDoc_STRVAR(os_ctermid__doc__,\n\"ctermid($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the name of the controlling terminal for this process.\");\n\n#define OS_CTERMID_METHODDEF    \\\n    {\"ctermid\", (PyCFunction)os_ctermid, METH_NOARGS, os_ctermid__doc__},\n\nstatic PyObject *\nos_ctermid_impl(PyObject *module);\n\nstatic PyObject *\nos_ctermid(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_ctermid_impl(module);\n}\n\n#endif /* defined(HAVE_CTERMID) */\n\nPyDoc_STRVAR(os_chdir__doc__,\n\"chdir($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Change the current working directory to the specified path.\\n\"\n\"\\n\"\n\"path may always be specified as a string.\\n\"\n\"On some platforms, path may also be specified as an open file descriptor.\\n\"\n\"  If this functionality is unavailable, using it raises an exception.\");\n\n#define OS_CHDIR_METHODDEF    \\\n    {\"chdir\", _PyCFunction_CAST(os_chdir), METH_FASTCALL|METH_KEYWORDS, os_chdir__doc__},\n\nstatic PyObject *\nos_chdir_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos_chdir(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"chdir\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE_P(\"chdir\", \"path\", 0, 0, 0, PATH_HAVE_FCHDIR);\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    return_value = os_chdir_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#if defined(HAVE_FCHDIR)\n\nPyDoc_STRVAR(os_fchdir__doc__,\n\"fchdir($module, /, fd)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Change to the directory of the given file descriptor.\\n\"\n\"\\n\"\n\"fd must be opened on a directory, not a file.\\n\"\n\"Equivalent to os.chdir(fd).\");\n\n#define OS_FCHDIR_METHODDEF    \\\n    {\"fchdir\", _PyCFunction_CAST(os_fchdir), METH_FASTCALL|METH_KEYWORDS, os_fchdir__doc__},\n\nstatic PyObject *\nos_fchdir_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_fchdir(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"fchdir\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int fd;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyObject_AsFileDescriptor(args[0]);\n    if (fd < 0) {\n        goto exit;\n    }\n    return_value = os_fchdir_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_FCHDIR) */\n\nPyDoc_STRVAR(os_chmod__doc__,\n\"chmod($module, /, path, mode, *, dir_fd=None,\\n\"\n\"      follow_symlinks=(os.name != \\'nt\\'))\\n\"\n\"--\\n\"\n\"\\n\"\n\"Change the access permissions of a file.\\n\"\n\"\\n\"\n\"  path\\n\"\n\"    Path to be modified.  May always be specified as a str, bytes, or a path-like object.\\n\"\n\"    On some platforms, path may also be specified as an open file descriptor.\\n\"\n\"    If this functionality is unavailable, using it raises an exception.\\n\"\n\"  mode\\n\"\n\"    Operating-system mode bitfield.\\n\"\n\"    Be careful when using number literals for *mode*. The conventional UNIX notation for\\n\"\n\"    numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\\n\"\n\"    Python.\\n\"\n\"  dir_fd\\n\"\n\"    If not None, it should be a file descriptor open to a directory,\\n\"\n\"    and path should be relative; path will then be relative to that\\n\"\n\"    directory.\\n\"\n\"  follow_symlinks\\n\"\n\"    If False, and the last element of the path is a symbolic link,\\n\"\n\"    chmod will modify the symbolic link itself instead of the file\\n\"\n\"    the link points to.\\n\"\n\"\\n\"\n\"It is an error to use dir_fd or follow_symlinks when specifying path as\\n\"\n\"  an open file descriptor.\\n\"\n\"dir_fd and follow_symlinks may not be implemented on your platform.\\n\"\n\"  If they are unavailable, using them will raise a NotImplementedError.\");\n\n#define OS_CHMOD_METHODDEF    \\\n    {\"chmod\", _PyCFunction_CAST(os_chmod), METH_FASTCALL|METH_KEYWORDS, os_chmod__doc__},\n\nstatic PyObject *\nos_chmod_impl(PyObject *module, path_t *path, int mode, int dir_fd,\n              int follow_symlinks);\n\nstatic PyObject *\nos_chmod(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 4\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(mode), &_Py_ID(dir_fd), &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"mode\", \"dir_fd\", \"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"chmod\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[4];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;\n    path_t path = PATH_T_INITIALIZE_P(\"chmod\", \"path\", 0, 0, 0, PATH_HAVE_FCHMOD);\n    int mode;\n    int dir_fd = DEFAULT_DIR_FD;\n    int follow_symlinks = CHMOD_DEFAULT_FOLLOW_SYMLINKS;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    mode = PyLong_AsInt(args[1]);\n    if (mode == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (args[2]) {\n        if (!FCHMODAT_DIR_FD_CONVERTER(args[2], &dir_fd)) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    follow_symlinks = PyObject_IsTrue(args[3]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_chmod_impl(module, &path, mode, dir_fd, follow_symlinks);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#if (defined(HAVE_FCHMOD) || defined(MS_WINDOWS))\n\nPyDoc_STRVAR(os_fchmod__doc__,\n\"fchmod($module, /, fd, mode)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Change the access permissions of the file given by file descriptor fd.\\n\"\n\"\\n\"\n\"  fd\\n\"\n\"    The file descriptor of the file to be modified.\\n\"\n\"  mode\\n\"\n\"    Operating-system mode bitfield.\\n\"\n\"    Be careful when using number literals for *mode*. The conventional UNIX notation for\\n\"\n\"    numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\\n\"\n\"    Python.\\n\"\n\"\\n\"\n\"Equivalent to os.chmod(fd, mode).\");\n\n#define OS_FCHMOD_METHODDEF    \\\n    {\"fchmod\", _PyCFunction_CAST(os_fchmod), METH_FASTCALL|METH_KEYWORDS, os_fchmod__doc__},\n\nstatic PyObject *\nos_fchmod_impl(PyObject *module, int fd, int mode);\n\nstatic PyObject *\nos_fchmod(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(fd), &_Py_ID(mode), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"fd\", \"mode\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"fchmod\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    int fd;\n    int mode;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    mode = PyLong_AsInt(args[1]);\n    if (mode == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_fchmod_impl(module, fd, mode);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(HAVE_FCHMOD) || defined(MS_WINDOWS)) */\n\n#if (defined(HAVE_LCHMOD) || defined(MS_WINDOWS))\n\nPyDoc_STRVAR(os_lchmod__doc__,\n\"lchmod($module, /, path, mode)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Change the access permissions of a file, without following symbolic links.\\n\"\n\"\\n\"\n\"If path is a symlink, this affects the link itself rather than the target.\\n\"\n\"Equivalent to chmod(path, mode, follow_symlinks=False).\\\"\");\n\n#define OS_LCHMOD_METHODDEF    \\\n    {\"lchmod\", _PyCFunction_CAST(os_lchmod), METH_FASTCALL|METH_KEYWORDS, os_lchmod__doc__},\n\nstatic PyObject *\nos_lchmod_impl(PyObject *module, path_t *path, int mode);\n\nstatic PyObject *\nos_lchmod(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(mode), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"mode\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"lchmod\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    path_t path = PATH_T_INITIALIZE_P(\"lchmod\", \"path\", 0, 0, 0, 0);\n    int mode;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    mode = PyLong_AsInt(args[1]);\n    if (mode == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_lchmod_impl(module, &path, mode);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* (defined(HAVE_LCHMOD) || defined(MS_WINDOWS)) */\n\n#if defined(HAVE_CHFLAGS)\n\nPyDoc_STRVAR(os_chflags__doc__,\n\"chflags($module, /, path, flags, follow_symlinks=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set file flags.\\n\"\n\"\\n\"\n\"If follow_symlinks is False, and the last element of the path is a symbolic\\n\"\n\"  link, chflags will change flags on the symbolic link itself instead of the\\n\"\n\"  file the link points to.\\n\"\n\"follow_symlinks may not be implemented on your platform.  If it is\\n\"\n\"unavailable, using it will raise a NotImplementedError.\");\n\n#define OS_CHFLAGS_METHODDEF    \\\n    {\"chflags\", _PyCFunction_CAST(os_chflags), METH_FASTCALL|METH_KEYWORDS, os_chflags__doc__},\n\nstatic PyObject *\nos_chflags_impl(PyObject *module, path_t *path, unsigned long flags,\n                int follow_symlinks);\n\nstatic PyObject *\nos_chflags(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(flags), &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"flags\", \"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"chflags\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[3];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;\n    path_t path = PATH_T_INITIALIZE_P(\"chflags\", \"path\", 0, 0, 0, 0);\n    unsigned long flags;\n    int follow_symlinks = 1;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 3, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!PyLong_Check(args[1])) {\n        _PyArg_BadArgument(\"chflags\", \"argument 'flags'\", \"int\", args[1]);\n        goto exit;\n    }\n    flags = PyLong_AsUnsignedLongMask(args[1]);\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    follow_symlinks = PyObject_IsTrue(args[2]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_pos:\n    return_value = os_chflags_impl(module, &path, flags, follow_symlinks);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_CHFLAGS) */\n\n#if defined(HAVE_LCHFLAGS)\n\nPyDoc_STRVAR(os_lchflags__doc__,\n\"lchflags($module, /, path, flags)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set file flags.\\n\"\n\"\\n\"\n\"This function will not follow symbolic links.\\n\"\n\"Equivalent to chflags(path, flags, follow_symlinks=False).\");\n\n#define OS_LCHFLAGS_METHODDEF    \\\n    {\"lchflags\", _PyCFunction_CAST(os_lchflags), METH_FASTCALL|METH_KEYWORDS, os_lchflags__doc__},\n\nstatic PyObject *\nos_lchflags_impl(PyObject *module, path_t *path, unsigned long flags);\n\nstatic PyObject *\nos_lchflags(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(flags), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"flags\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"lchflags\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    path_t path = PATH_T_INITIALIZE_P(\"lchflags\", \"path\", 0, 0, 0, 0);\n    unsigned long flags;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!PyLong_Check(args[1])) {\n        _PyArg_BadArgument(\"lchflags\", \"argument 'flags'\", \"int\", args[1]);\n        goto exit;\n    }\n    flags = PyLong_AsUnsignedLongMask(args[1]);\n    return_value = os_lchflags_impl(module, &path, flags);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_LCHFLAGS) */\n\n#if defined(HAVE_CHROOT)\n\nPyDoc_STRVAR(os_chroot__doc__,\n\"chroot($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Change root directory to path.\");\n\n#define OS_CHROOT_METHODDEF    \\\n    {\"chroot\", _PyCFunction_CAST(os_chroot), METH_FASTCALL|METH_KEYWORDS, os_chroot__doc__},\n\nstatic PyObject *\nos_chroot_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos_chroot(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"chroot\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE_P(\"chroot\", \"path\", 0, 0, 0, 0);\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    return_value = os_chroot_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_CHROOT) */\n\n#if defined(HAVE_FSYNC)\n\nPyDoc_STRVAR(os_fsync__doc__,\n\"fsync($module, /, fd)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Force write of fd to disk.\");\n\n#define OS_FSYNC_METHODDEF    \\\n    {\"fsync\", _PyCFunction_CAST(os_fsync), METH_FASTCALL|METH_KEYWORDS, os_fsync__doc__},\n\nstatic PyObject *\nos_fsync_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_fsync(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"fsync\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int fd;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyObject_AsFileDescriptor(args[0]);\n    if (fd < 0) {\n        goto exit;\n    }\n    return_value = os_fsync_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_FSYNC) */\n\n#if defined(HAVE_SYNC)\n\nPyDoc_STRVAR(os_sync__doc__,\n\"sync($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Force write of everything to disk.\");\n\n#define OS_SYNC_METHODDEF    \\\n    {\"sync\", (PyCFunction)os_sync, METH_NOARGS, os_sync__doc__},\n\nstatic PyObject *\nos_sync_impl(PyObject *module);\n\nstatic PyObject *\nos_sync(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_sync_impl(module);\n}\n\n#endif /* defined(HAVE_SYNC) */\n\n#if defined(HAVE_FDATASYNC)\n\nPyDoc_STRVAR(os_fdatasync__doc__,\n\"fdatasync($module, /, fd)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Force write of fd to disk without forcing update of metadata.\");\n\n#define OS_FDATASYNC_METHODDEF    \\\n    {\"fdatasync\", _PyCFunction_CAST(os_fdatasync), METH_FASTCALL|METH_KEYWORDS, os_fdatasync__doc__},\n\nstatic PyObject *\nos_fdatasync_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_fdatasync(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"fdatasync\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int fd;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyObject_AsFileDescriptor(args[0]);\n    if (fd < 0) {\n        goto exit;\n    }\n    return_value = os_fdatasync_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_FDATASYNC) */\n\n#if defined(HAVE_CHOWN)\n\nPyDoc_STRVAR(os_chown__doc__,\n\"chown($module, /, path, uid, gid, *, dir_fd=None, follow_symlinks=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Change the owner and group id of path to the numeric uid and gid.\\\\\\n\"\n\"\\n\"\n\"  path\\n\"\n\"    Path to be examined; can be string, bytes, a path-like object, or open-file-descriptor int.\\n\"\n\"  dir_fd\\n\"\n\"    If not None, it should be a file descriptor open to a directory,\\n\"\n\"    and path should be relative; path will then be relative to that\\n\"\n\"    directory.\\n\"\n\"  follow_symlinks\\n\"\n\"    If False, and the last element of the path is a symbolic link,\\n\"\n\"    stat will examine the symbolic link itself instead of the file\\n\"\n\"    the link points to.\\n\"\n\"\\n\"\n\"path may always be specified as a string.\\n\"\n\"On some platforms, path may also be specified as an open file descriptor.\\n\"\n\"  If this functionality is unavailable, using it raises an exception.\\n\"\n\"If dir_fd is not None, it should be a file descriptor open to a directory,\\n\"\n\"  and path should be relative; path will then be relative to that directory.\\n\"\n\"If follow_symlinks is False, and the last element of the path is a symbolic\\n\"\n\"  link, chown will modify the symbolic link itself instead of the file the\\n\"\n\"  link points to.\\n\"\n\"It is an error to use dir_fd or follow_symlinks when specifying path as\\n\"\n\"  an open file descriptor.\\n\"\n\"dir_fd and follow_symlinks may not be implemented on your platform.\\n\"\n\"  If they are unavailable, using them will raise a NotImplementedError.\");\n\n#define OS_CHOWN_METHODDEF    \\\n    {\"chown\", _PyCFunction_CAST(os_chown), METH_FASTCALL|METH_KEYWORDS, os_chown__doc__},\n\nstatic PyObject *\nos_chown_impl(PyObject *module, path_t *path, uid_t uid, gid_t gid,\n              int dir_fd, int follow_symlinks);\n\nstatic PyObject *\nos_chown(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 5\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(uid), &_Py_ID(gid), &_Py_ID(dir_fd), &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"uid\", \"gid\", \"dir_fd\", \"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"chown\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[5];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;\n    path_t path = PATH_T_INITIALIZE_P(\"chown\", \"path\", 0, 0, 0, PATH_HAVE_FCHOWN);\n    uid_t uid;\n    gid_t gid;\n    int dir_fd = DEFAULT_DIR_FD;\n    int follow_symlinks = 1;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 3, 3, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!_Py_Uid_Converter(args[1], &uid)) {\n        goto exit;\n    }\n    if (!_Py_Gid_Converter(args[2], &gid)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (args[3]) {\n        if (!FCHOWNAT_DIR_FD_CONVERTER(args[3], &dir_fd)) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    follow_symlinks = PyObject_IsTrue(args[4]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_chown_impl(module, &path, uid, gid, dir_fd, follow_symlinks);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_CHOWN) */\n\n#if defined(HAVE_FCHOWN)\n\nPyDoc_STRVAR(os_fchown__doc__,\n\"fchown($module, /, fd, uid, gid)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Change the owner and group id of the file specified by file descriptor.\\n\"\n\"\\n\"\n\"Equivalent to os.chown(fd, uid, gid).\");\n\n#define OS_FCHOWN_METHODDEF    \\\n    {\"fchown\", _PyCFunction_CAST(os_fchown), METH_FASTCALL|METH_KEYWORDS, os_fchown__doc__},\n\nstatic PyObject *\nos_fchown_impl(PyObject *module, int fd, uid_t uid, gid_t gid);\n\nstatic PyObject *\nos_fchown(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(fd), &_Py_ID(uid), &_Py_ID(gid), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"fd\", \"uid\", \"gid\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"fchown\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[3];\n    int fd;\n    uid_t uid;\n    gid_t gid;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 3, 3, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!_Py_Uid_Converter(args[1], &uid)) {\n        goto exit;\n    }\n    if (!_Py_Gid_Converter(args[2], &gid)) {\n        goto exit;\n    }\n    return_value = os_fchown_impl(module, fd, uid, gid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_FCHOWN) */\n\n#if defined(HAVE_LCHOWN)\n\nPyDoc_STRVAR(os_lchown__doc__,\n\"lchown($module, /, path, uid, gid)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Change the owner and group id of path to the numeric uid and gid.\\n\"\n\"\\n\"\n\"This function will not follow symbolic links.\\n\"\n\"Equivalent to os.chown(path, uid, gid, follow_symlinks=False).\");\n\n#define OS_LCHOWN_METHODDEF    \\\n    {\"lchown\", _PyCFunction_CAST(os_lchown), METH_FASTCALL|METH_KEYWORDS, os_lchown__doc__},\n\nstatic PyObject *\nos_lchown_impl(PyObject *module, path_t *path, uid_t uid, gid_t gid);\n\nstatic PyObject *\nos_lchown(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(uid), &_Py_ID(gid), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"uid\", \"gid\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"lchown\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[3];\n    path_t path = PATH_T_INITIALIZE_P(\"lchown\", \"path\", 0, 0, 0, 0);\n    uid_t uid;\n    gid_t gid;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 3, 3, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!_Py_Uid_Converter(args[1], &uid)) {\n        goto exit;\n    }\n    if (!_Py_Gid_Converter(args[2], &gid)) {\n        goto exit;\n    }\n    return_value = os_lchown_impl(module, &path, uid, gid);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_LCHOWN) */\n\nPyDoc_STRVAR(os_getcwd__doc__,\n\"getcwd($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a unicode string representing the current working directory.\");\n\n#define OS_GETCWD_METHODDEF    \\\n    {\"getcwd\", (PyCFunction)os_getcwd, METH_NOARGS, os_getcwd__doc__},\n\nstatic PyObject *\nos_getcwd_impl(PyObject *module);\n\nstatic PyObject *\nos_getcwd(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_getcwd_impl(module);\n}\n\nPyDoc_STRVAR(os_getcwdb__doc__,\n\"getcwdb($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a bytes string representing the current working directory.\");\n\n#define OS_GETCWDB_METHODDEF    \\\n    {\"getcwdb\", (PyCFunction)os_getcwdb, METH_NOARGS, os_getcwdb__doc__},\n\nstatic PyObject *\nos_getcwdb_impl(PyObject *module);\n\nstatic PyObject *\nos_getcwdb(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_getcwdb_impl(module);\n}\n\n#if defined(HAVE_LINK)\n\nPyDoc_STRVAR(os_link__doc__,\n\"link($module, /, src, dst, *, src_dir_fd=None, dst_dir_fd=None,\\n\"\n\"     follow_symlinks=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Create a hard link to a file.\\n\"\n\"\\n\"\n\"If either src_dir_fd or dst_dir_fd is not None, it should be a file\\n\"\n\"  descriptor open to a directory, and the respective path string (src or dst)\\n\"\n\"  should be relative; the path will then be relative to that directory.\\n\"\n\"If follow_symlinks is False, and the last element of src is a symbolic\\n\"\n\"  link, link will create a link to the symbolic link itself instead of the\\n\"\n\"  file the link points to.\\n\"\n\"src_dir_fd, dst_dir_fd, and follow_symlinks may not be implemented on your\\n\"\n\"  platform.  If they are unavailable, using them will raise a\\n\"\n\"  NotImplementedError.\");\n\n#define OS_LINK_METHODDEF    \\\n    {\"link\", _PyCFunction_CAST(os_link), METH_FASTCALL|METH_KEYWORDS, os_link__doc__},\n\nstatic PyObject *\nos_link_impl(PyObject *module, path_t *src, path_t *dst, int src_dir_fd,\n             int dst_dir_fd, int follow_symlinks);\n\nstatic PyObject *\nos_link(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 5\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(src), &_Py_ID(dst), &_Py_ID(src_dir_fd), &_Py_ID(dst_dir_fd), &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"src\", \"dst\", \"src_dir_fd\", \"dst_dir_fd\", \"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"link\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[5];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;\n    path_t src = PATH_T_INITIALIZE_P(\"link\", \"src\", 0, 0, 0, 0);\n    path_t dst = PATH_T_INITIALIZE_P(\"link\", \"dst\", 0, 0, 0, 0);\n    int src_dir_fd = DEFAULT_DIR_FD;\n    int dst_dir_fd = DEFAULT_DIR_FD;\n    int follow_symlinks = 1;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &src)) {\n        goto exit;\n    }\n    if (!path_converter(args[1], &dst)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (args[2]) {\n        if (!dir_fd_converter(args[2], &src_dir_fd)) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[3]) {\n        if (!dir_fd_converter(args[3], &dst_dir_fd)) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    follow_symlinks = PyObject_IsTrue(args[4]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_link_impl(module, &src, &dst, src_dir_fd, dst_dir_fd, follow_symlinks);\n\nexit:\n    /* Cleanup for src */\n    path_cleanup(&src);\n    /* Cleanup for dst */\n    path_cleanup(&dst);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_LINK) */\n\nPyDoc_STRVAR(os_listdir__doc__,\n\"listdir($module, /, path=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a list containing the names of the files in the directory.\\n\"\n\"\\n\"\n\"path can be specified as either str, bytes, or a path-like object.  If path is bytes,\\n\"\n\"  the filenames returned will also be bytes; in all other circumstances\\n\"\n\"  the filenames returned will be str.\\n\"\n\"If path is None, uses the path=\\'.\\'.\\n\"\n\"On some platforms, path may also be specified as an open file descriptor;\\\\\\n\"\n\"  the file descriptor must refer to a directory.\\n\"\n\"  If this functionality is unavailable, using it raises NotImplementedError.\\n\"\n\"\\n\"\n\"The list is in arbitrary order.  It does not include the special\\n\"\n\"entries \\'.\\' and \\'..\\' even if they are present in the directory.\");\n\n#define OS_LISTDIR_METHODDEF    \\\n    {\"listdir\", _PyCFunction_CAST(os_listdir), METH_FASTCALL|METH_KEYWORDS, os_listdir__doc__},\n\nstatic PyObject *\nos_listdir_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos_listdir(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"listdir\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;\n    path_t path = PATH_T_INITIALIZE_P(\"listdir\", \"path\", 1, 0, 0, PATH_HAVE_FDOPENDIR);\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\nskip_optional_pos:\n    return_value = os_listdir_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os_listdrives__doc__,\n\"listdrives($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a list containing the names of drives in the system.\\n\"\n\"\\n\"\n\"A drive name typically looks like \\'C:\\\\\\\\\\'.\");\n\n#define OS_LISTDRIVES_METHODDEF    \\\n    {\"listdrives\", (PyCFunction)os_listdrives, METH_NOARGS, os_listdrives__doc__},\n\nstatic PyObject *\nos_listdrives_impl(PyObject *module);\n\nstatic PyObject *\nos_listdrives(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_listdrives_impl(module);\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os_listvolumes__doc__,\n\"listvolumes($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a list containing the volumes in the system.\\n\"\n\"\\n\"\n\"Volumes are typically represented as a GUID path.\");\n\n#define OS_LISTVOLUMES_METHODDEF    \\\n    {\"listvolumes\", (PyCFunction)os_listvolumes, METH_NOARGS, os_listvolumes__doc__},\n\nstatic PyObject *\nos_listvolumes_impl(PyObject *module);\n\nstatic PyObject *\nos_listvolumes(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_listvolumes_impl(module);\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os_listmounts__doc__,\n\"listmounts($module, /, volume)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a list containing mount points for a particular volume.\\n\"\n\"\\n\"\n\"\\'volume\\' should be a GUID path as returned from os.listvolumes.\");\n\n#define OS_LISTMOUNTS_METHODDEF    \\\n    {\"listmounts\", _PyCFunction_CAST(os_listmounts), METH_FASTCALL|METH_KEYWORDS, os_listmounts__doc__},\n\nstatic PyObject *\nos_listmounts_impl(PyObject *module, path_t *volume);\n\nstatic PyObject *\nos_listmounts(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(volume), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"volume\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"listmounts\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t volume = PATH_T_INITIALIZE_P(\"listmounts\", \"volume\", 0, 0, 0, 0);\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &volume)) {\n        goto exit;\n    }\n    return_value = os_listmounts_impl(module, &volume);\n\nexit:\n    /* Cleanup for volume */\n    path_cleanup(&volume);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__path_isdevdrive__doc__,\n\"_path_isdevdrive($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Determines whether the specified path is on a Windows Dev Drive.\");\n\n#define OS__PATH_ISDEVDRIVE_METHODDEF    \\\n    {\"_path_isdevdrive\", _PyCFunction_CAST(os__path_isdevdrive), METH_FASTCALL|METH_KEYWORDS, os__path_isdevdrive__doc__},\n\nstatic PyObject *\nos__path_isdevdrive_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__path_isdevdrive(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"_path_isdevdrive\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE_P(\"_path_isdevdrive\", \"path\", 0, 0, 0, 0);\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    return_value = os__path_isdevdrive_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__getfullpathname__doc__,\n\"_getfullpathname($module, path, /)\\n\"\n\"--\\n\"\n\"\\n\");\n\n#define OS__GETFULLPATHNAME_METHODDEF    \\\n    {\"_getfullpathname\", (PyCFunction)os__getfullpathname, METH_O, os__getfullpathname__doc__},\n\nstatic PyObject *\nos__getfullpathname_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__getfullpathname(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    path_t path = PATH_T_INITIALIZE_P(\"_getfullpathname\", \"path\", 0, 0, 0, 0);\n\n    if (!path_converter(arg, &path)) {\n        goto exit;\n    }\n    return_value = os__getfullpathname_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__getfinalpathname__doc__,\n\"_getfinalpathname($module, path, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"A helper function for samepath on windows.\");\n\n#define OS__GETFINALPATHNAME_METHODDEF    \\\n    {\"_getfinalpathname\", (PyCFunction)os__getfinalpathname, METH_O, os__getfinalpathname__doc__},\n\nstatic PyObject *\nos__getfinalpathname_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__getfinalpathname(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    path_t path = PATH_T_INITIALIZE_P(\"_getfinalpathname\", \"path\", 0, 0, 0, 0);\n\n    if (!path_converter(arg, &path)) {\n        goto exit;\n    }\n    return_value = os__getfinalpathname_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__findfirstfile__doc__,\n\"_findfirstfile($module, path, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"A function to get the real file name without accessing the file in Windows.\");\n\n#define OS__FINDFIRSTFILE_METHODDEF    \\\n    {\"_findfirstfile\", (PyCFunction)os__findfirstfile, METH_O, os__findfirstfile__doc__},\n\nstatic PyObject *\nos__findfirstfile_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__findfirstfile(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    path_t path = PATH_T_INITIALIZE_P(\"_findfirstfile\", \"path\", 0, 0, 0, 0);\n\n    if (!path_converter(arg, &path)) {\n        goto exit;\n    }\n    return_value = os__findfirstfile_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__getvolumepathname__doc__,\n\"_getvolumepathname($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"A helper function for ismount on Win32.\");\n\n#define OS__GETVOLUMEPATHNAME_METHODDEF    \\\n    {\"_getvolumepathname\", _PyCFunction_CAST(os__getvolumepathname), METH_FASTCALL|METH_KEYWORDS, os__getvolumepathname__doc__},\n\nstatic PyObject *\nos__getvolumepathname_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__getvolumepathname(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"_getvolumepathname\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE_P(\"_getvolumepathname\", \"path\", 0, 0, 0, 0);\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    return_value = os__getvolumepathname_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__path_splitroot__doc__,\n\"_path_splitroot($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Removes everything after the root on Win32.\");\n\n#define OS__PATH_SPLITROOT_METHODDEF    \\\n    {\"_path_splitroot\", _PyCFunction_CAST(os__path_splitroot), METH_FASTCALL|METH_KEYWORDS, os__path_splitroot__doc__},\n\nstatic PyObject *\nos__path_splitroot_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__path_splitroot(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"_path_splitroot\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE_P(\"_path_splitroot\", \"path\", 0, 0, 0, 0);\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    return_value = os__path_splitroot_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__path_exists__doc__,\n\"_path_exists($module, path, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Test whether a path exists.  Returns False for broken symbolic links.\");\n\n#define OS__PATH_EXISTS_METHODDEF    \\\n    {\"_path_exists\", (PyCFunction)os__path_exists, METH_O, os__path_exists__doc__},\n\nstatic int\nos__path_exists_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__path_exists(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    path_t path = PATH_T_INITIALIZE_P(\"_path_exists\", \"path\", 0, 0, 1, 1);\n    int _return_value;\n\n    if (!path_converter(arg, &path)) {\n        goto exit;\n    }\n    _return_value = os__path_exists_impl(module, &path);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__path_lexists__doc__,\n\"_path_lexists($module, path, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Test whether a path exists.  Returns True for broken symbolic links.\");\n\n#define OS__PATH_LEXISTS_METHODDEF    \\\n    {\"_path_lexists\", (PyCFunction)os__path_lexists, METH_O, os__path_lexists__doc__},\n\nstatic int\nos__path_lexists_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__path_lexists(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    path_t path = PATH_T_INITIALIZE_P(\"_path_lexists\", \"path\", 0, 0, 1, 1);\n    int _return_value;\n\n    if (!path_converter(arg, &path)) {\n        goto exit;\n    }\n    _return_value = os__path_lexists_impl(module, &path);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__path_isdir__doc__,\n\"_path_isdir($module, /, s)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return true if the pathname refers to an existing directory.\");\n\n#define OS__PATH_ISDIR_METHODDEF    \\\n    {\"_path_isdir\", _PyCFunction_CAST(os__path_isdir), METH_FASTCALL|METH_KEYWORDS, os__path_isdir__doc__},\n\nstatic int\nos__path_isdir_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__path_isdir(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { _Py_LATIN1_CHR('s'), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"s\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"_path_isdir\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE_P(\"_path_isdir\", \"path\", 0, 0, 1, 1);\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    _return_value = os__path_isdir_impl(module, &path);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__path_isfile__doc__,\n\"_path_isfile($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Test whether a path is a regular file\");\n\n#define OS__PATH_ISFILE_METHODDEF    \\\n    {\"_path_isfile\", _PyCFunction_CAST(os__path_isfile), METH_FASTCALL|METH_KEYWORDS, os__path_isfile__doc__},\n\nstatic int\nos__path_isfile_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__path_isfile(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"_path_isfile\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE_P(\"_path_isfile\", \"path\", 0, 0, 1, 1);\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    _return_value = os__path_isfile_impl(module, &path);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__path_islink__doc__,\n\"_path_islink($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Test whether a path is a symbolic link\");\n\n#define OS__PATH_ISLINK_METHODDEF    \\\n    {\"_path_islink\", _PyCFunction_CAST(os__path_islink), METH_FASTCALL|METH_KEYWORDS, os__path_islink__doc__},\n\nstatic int\nos__path_islink_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__path_islink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"_path_islink\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE_P(\"_path_islink\", \"path\", 0, 0, 1, 1);\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    _return_value = os__path_islink_impl(module, &path);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__path_isjunction__doc__,\n\"_path_isjunction($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Test whether a path is a junction\");\n\n#define OS__PATH_ISJUNCTION_METHODDEF    \\\n    {\"_path_isjunction\", _PyCFunction_CAST(os__path_isjunction), METH_FASTCALL|METH_KEYWORDS, os__path_isjunction__doc__},\n\nstatic int\nos__path_isjunction_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__path_isjunction(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"_path_isjunction\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE_P(\"_path_isjunction\", \"path\", 0, 0, 1, 1);\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    _return_value = os__path_isjunction_impl(module, &path);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\nPyDoc_STRVAR(os__path_splitroot_ex__doc__,\n\"_path_splitroot_ex($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Split a pathname into drive, root and tail.\\n\"\n\"\\n\"\n\"The tail contains anything after the root.\");\n\n#define OS__PATH_SPLITROOT_EX_METHODDEF    \\\n    {\"_path_splitroot_ex\", _PyCFunction_CAST(os__path_splitroot_ex), METH_FASTCALL|METH_KEYWORDS, os__path_splitroot_ex__doc__},\n\nstatic PyObject *\nos__path_splitroot_ex_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__path_splitroot_ex(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"_path_splitroot_ex\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE(\"_path_splitroot_ex\", \"path\", 0, 1, 1, 0, 0);\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    return_value = os__path_splitroot_ex_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\nPyDoc_STRVAR(os__path_normpath__doc__,\n\"_path_normpath($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Normalize path, eliminating double slashes, etc.\");\n\n#define OS__PATH_NORMPATH_METHODDEF    \\\n    {\"_path_normpath\", _PyCFunction_CAST(os__path_normpath), METH_FASTCALL|METH_KEYWORDS, os__path_normpath__doc__},\n\nstatic PyObject *\nos__path_normpath_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__path_normpath(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"_path_normpath\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE(\"_path_normpath\", \"path\", 0, 1, 1, 0, 0);\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    return_value = os__path_normpath_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\nPyDoc_STRVAR(os_mkdir__doc__,\n\"mkdir($module, /, path, mode=511, *, dir_fd=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Create a directory.\\n\"\n\"\\n\"\n\"If dir_fd is not None, it should be a file descriptor open to a directory,\\n\"\n\"  and path should be relative; path will then be relative to that directory.\\n\"\n\"dir_fd may not be implemented on your platform.\\n\"\n\"  If it is unavailable, using it will raise a NotImplementedError.\\n\"\n\"\\n\"\n\"The mode argument is ignored on Windows. Where it is used, the current umask\\n\"\n\"value is first masked out.\");\n\n#define OS_MKDIR_METHODDEF    \\\n    {\"mkdir\", _PyCFunction_CAST(os_mkdir), METH_FASTCALL|METH_KEYWORDS, os_mkdir__doc__},\n\nstatic PyObject *\nos_mkdir_impl(PyObject *module, path_t *path, int mode, int dir_fd);\n\nstatic PyObject *\nos_mkdir(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(mode), &_Py_ID(dir_fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"mode\", \"dir_fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"mkdir\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[3];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    path_t path = PATH_T_INITIALIZE_P(\"mkdir\", \"path\", 0, 0, 0, 0);\n    int mode = 511;\n    int dir_fd = DEFAULT_DIR_FD;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[1]) {\n        mode = PyLong_AsInt(args[1]);\n        if (mode == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\nskip_optional_pos:\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (!MKDIRAT_DIR_FD_CONVERTER(args[2], &dir_fd)) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_mkdir_impl(module, &path, mode, dir_fd);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#if defined(HAVE_NICE)\n\nPyDoc_STRVAR(os_nice__doc__,\n\"nice($module, increment, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Add increment to the priority of process and return the new priority.\");\n\n#define OS_NICE_METHODDEF    \\\n    {\"nice\", (PyCFunction)os_nice, METH_O, os_nice__doc__},\n\nstatic PyObject *\nos_nice_impl(PyObject *module, int increment);\n\nstatic PyObject *\nos_nice(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int increment;\n\n    increment = PyLong_AsInt(arg);\n    if (increment == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_nice_impl(module, increment);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_NICE) */\n\n#if defined(HAVE_GETPRIORITY)\n\nPyDoc_STRVAR(os_getpriority__doc__,\n\"getpriority($module, /, which, who)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return program scheduling priority.\");\n\n#define OS_GETPRIORITY_METHODDEF    \\\n    {\"getpriority\", _PyCFunction_CAST(os_getpriority), METH_FASTCALL|METH_KEYWORDS, os_getpriority__doc__},\n\nstatic PyObject *\nos_getpriority_impl(PyObject *module, int which, int who);\n\nstatic PyObject *\nos_getpriority(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(which), &_Py_ID(who), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"which\", \"who\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"getpriority\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    int which;\n    int who;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    which = PyLong_AsInt(args[0]);\n    if (which == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    who = PyLong_AsInt(args[1]);\n    if (who == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_getpriority_impl(module, which, who);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_GETPRIORITY) */\n\n#if defined(HAVE_SETPRIORITY)\n\nPyDoc_STRVAR(os_setpriority__doc__,\n\"setpriority($module, /, which, who, priority)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set program scheduling priority.\");\n\n#define OS_SETPRIORITY_METHODDEF    \\\n    {\"setpriority\", _PyCFunction_CAST(os_setpriority), METH_FASTCALL|METH_KEYWORDS, os_setpriority__doc__},\n\nstatic PyObject *\nos_setpriority_impl(PyObject *module, int which, int who, int priority);\n\nstatic PyObject *\nos_setpriority(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(which), &_Py_ID(who), &_Py_ID(priority), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"which\", \"who\", \"priority\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"setpriority\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[3];\n    int which;\n    int who;\n    int priority;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 3, 3, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    which = PyLong_AsInt(args[0]);\n    if (which == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    who = PyLong_AsInt(args[1]);\n    if (who == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    priority = PyLong_AsInt(args[2]);\n    if (priority == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_setpriority_impl(module, which, who, priority);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SETPRIORITY) */\n\nPyDoc_STRVAR(os_rename__doc__,\n\"rename($module, /, src, dst, *, src_dir_fd=None, dst_dir_fd=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Rename a file or directory.\\n\"\n\"\\n\"\n\"If either src_dir_fd or dst_dir_fd is not None, it should be a file\\n\"\n\"  descriptor open to a directory, and the respective path string (src or dst)\\n\"\n\"  should be relative; the path will then be relative to that directory.\\n\"\n\"src_dir_fd and dst_dir_fd, may not be implemented on your platform.\\n\"\n\"  If they are unavailable, using them will raise a NotImplementedError.\");\n\n#define OS_RENAME_METHODDEF    \\\n    {\"rename\", _PyCFunction_CAST(os_rename), METH_FASTCALL|METH_KEYWORDS, os_rename__doc__},\n\nstatic PyObject *\nos_rename_impl(PyObject *module, path_t *src, path_t *dst, int src_dir_fd,\n               int dst_dir_fd);\n\nstatic PyObject *\nos_rename(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 4\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(src), &_Py_ID(dst), &_Py_ID(src_dir_fd), &_Py_ID(dst_dir_fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"src\", \"dst\", \"src_dir_fd\", \"dst_dir_fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"rename\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[4];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;\n    path_t src = PATH_T_INITIALIZE_P(\"rename\", \"src\", 0, 0, 0, 0);\n    path_t dst = PATH_T_INITIALIZE_P(\"rename\", \"dst\", 0, 0, 0, 0);\n    int src_dir_fd = DEFAULT_DIR_FD;\n    int dst_dir_fd = DEFAULT_DIR_FD;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &src)) {\n        goto exit;\n    }\n    if (!path_converter(args[1], &dst)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (args[2]) {\n        if (!dir_fd_converter(args[2], &src_dir_fd)) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (!dir_fd_converter(args[3], &dst_dir_fd)) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_rename_impl(module, &src, &dst, src_dir_fd, dst_dir_fd);\n\nexit:\n    /* Cleanup for src */\n    path_cleanup(&src);\n    /* Cleanup for dst */\n    path_cleanup(&dst);\n\n    return return_value;\n}\n\nPyDoc_STRVAR(os_replace__doc__,\n\"replace($module, /, src, dst, *, src_dir_fd=None, dst_dir_fd=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Rename a file or directory, overwriting the destination.\\n\"\n\"\\n\"\n\"If either src_dir_fd or dst_dir_fd is not None, it should be a file\\n\"\n\"  descriptor open to a directory, and the respective path string (src or dst)\\n\"\n\"  should be relative; the path will then be relative to that directory.\\n\"\n\"src_dir_fd and dst_dir_fd, may not be implemented on your platform.\\n\"\n\"  If they are unavailable, using them will raise a NotImplementedError.\");\n\n#define OS_REPLACE_METHODDEF    \\\n    {\"replace\", _PyCFunction_CAST(os_replace), METH_FASTCALL|METH_KEYWORDS, os_replace__doc__},\n\nstatic PyObject *\nos_replace_impl(PyObject *module, path_t *src, path_t *dst, int src_dir_fd,\n                int dst_dir_fd);\n\nstatic PyObject *\nos_replace(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 4\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(src), &_Py_ID(dst), &_Py_ID(src_dir_fd), &_Py_ID(dst_dir_fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"src\", \"dst\", \"src_dir_fd\", \"dst_dir_fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"replace\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[4];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;\n    path_t src = PATH_T_INITIALIZE_P(\"replace\", \"src\", 0, 0, 0, 0);\n    path_t dst = PATH_T_INITIALIZE_P(\"replace\", \"dst\", 0, 0, 0, 0);\n    int src_dir_fd = DEFAULT_DIR_FD;\n    int dst_dir_fd = DEFAULT_DIR_FD;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &src)) {\n        goto exit;\n    }\n    if (!path_converter(args[1], &dst)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (args[2]) {\n        if (!dir_fd_converter(args[2], &src_dir_fd)) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (!dir_fd_converter(args[3], &dst_dir_fd)) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_replace_impl(module, &src, &dst, src_dir_fd, dst_dir_fd);\n\nexit:\n    /* Cleanup for src */\n    path_cleanup(&src);\n    /* Cleanup for dst */\n    path_cleanup(&dst);\n\n    return return_value;\n}\n\nPyDoc_STRVAR(os_rmdir__doc__,\n\"rmdir($module, /, path, *, dir_fd=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Remove a directory.\\n\"\n\"\\n\"\n\"If dir_fd is not None, it should be a file descriptor open to a directory,\\n\"\n\"  and path should be relative; path will then be relative to that directory.\\n\"\n\"dir_fd may not be implemented on your platform.\\n\"\n\"  If it is unavailable, using it will raise a NotImplementedError.\");\n\n#define OS_RMDIR_METHODDEF    \\\n    {\"rmdir\", _PyCFunction_CAST(os_rmdir), METH_FASTCALL|METH_KEYWORDS, os_rmdir__doc__},\n\nstatic PyObject *\nos_rmdir_impl(PyObject *module, path_t *path, int dir_fd);\n\nstatic PyObject *\nos_rmdir(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(dir_fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"dir_fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"rmdir\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    path_t path = PATH_T_INITIALIZE_P(\"rmdir\", \"path\", 0, 0, 0, 0);\n    int dir_fd = DEFAULT_DIR_FD;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (!UNLINKAT_DIR_FD_CONVERTER(args[1], &dir_fd)) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_rmdir_impl(module, &path, dir_fd);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#if defined(HAVE_SYSTEM) && defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os_system__doc__,\n\"system($module, /, command)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Execute the command in a subshell.\");\n\n#define OS_SYSTEM_METHODDEF    \\\n    {\"system\", _PyCFunction_CAST(os_system), METH_FASTCALL|METH_KEYWORDS, os_system__doc__},\n\nstatic long\nos_system_impl(PyObject *module, const wchar_t *command);\n\nstatic PyObject *\nos_system(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(command), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"command\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"system\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    const wchar_t *command = NULL;\n    long _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!PyUnicode_Check(args[0])) {\n        _PyArg_BadArgument(\"system\", \"argument 'command'\", \"str\", args[0]);\n        goto exit;\n    }\n    command = PyUnicode_AsWideCharString(args[0], NULL);\n    if (command == NULL) {\n        goto exit;\n    }\n    _return_value = os_system_impl(module, command);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong(_return_value);\n\nexit:\n    /* Cleanup for command */\n    PyMem_Free((void *)command);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_SYSTEM) && defined(MS_WINDOWS) */\n\n#if defined(HAVE_SYSTEM) && !defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os_system__doc__,\n\"system($module, /, command)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Execute the command in a subshell.\");\n\n#define OS_SYSTEM_METHODDEF    \\\n    {\"system\", _PyCFunction_CAST(os_system), METH_FASTCALL|METH_KEYWORDS, os_system__doc__},\n\nstatic long\nos_system_impl(PyObject *module, PyObject *command);\n\nstatic PyObject *\nos_system(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(command), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"command\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"system\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    PyObject *command = NULL;\n    long _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!PyUnicode_FSConverter(args[0], &command)) {\n        goto exit;\n    }\n    _return_value = os_system_impl(module, command);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong(_return_value);\n\nexit:\n    /* Cleanup for command */\n    Py_XDECREF(command);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_SYSTEM) && !defined(MS_WINDOWS) */\n\n#if defined(HAVE_UMASK)\n\nPyDoc_STRVAR(os_umask__doc__,\n\"umask($module, mask, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the current numeric umask and return the previous umask.\");\n\n#define OS_UMASK_METHODDEF    \\\n    {\"umask\", (PyCFunction)os_umask, METH_O, os_umask__doc__},\n\nstatic PyObject *\nos_umask_impl(PyObject *module, int mask);\n\nstatic PyObject *\nos_umask(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int mask;\n\n    mask = PyLong_AsInt(arg);\n    if (mask == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_umask_impl(module, mask);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_UMASK) */\n\nPyDoc_STRVAR(os_unlink__doc__,\n\"unlink($module, /, path, *, dir_fd=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Remove a file (same as remove()).\\n\"\n\"\\n\"\n\"If dir_fd is not None, it should be a file descriptor open to a directory,\\n\"\n\"  and path should be relative; path will then be relative to that directory.\\n\"\n\"dir_fd may not be implemented on your platform.\\n\"\n\"  If it is unavailable, using it will raise a NotImplementedError.\");\n\n#define OS_UNLINK_METHODDEF    \\\n    {\"unlink\", _PyCFunction_CAST(os_unlink), METH_FASTCALL|METH_KEYWORDS, os_unlink__doc__},\n\nstatic PyObject *\nos_unlink_impl(PyObject *module, path_t *path, int dir_fd);\n\nstatic PyObject *\nos_unlink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(dir_fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"dir_fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"unlink\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    path_t path = PATH_T_INITIALIZE_P(\"unlink\", \"path\", 0, 0, 0, 0);\n    int dir_fd = DEFAULT_DIR_FD;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (!UNLINKAT_DIR_FD_CONVERTER(args[1], &dir_fd)) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_unlink_impl(module, &path, dir_fd);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\nPyDoc_STRVAR(os_remove__doc__,\n\"remove($module, /, path, *, dir_fd=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Remove a file (same as unlink()).\\n\"\n\"\\n\"\n\"If dir_fd is not None, it should be a file descriptor open to a directory,\\n\"\n\"  and path should be relative; path will then be relative to that directory.\\n\"\n\"dir_fd may not be implemented on your platform.\\n\"\n\"  If it is unavailable, using it will raise a NotImplementedError.\");\n\n#define OS_REMOVE_METHODDEF    \\\n    {\"remove\", _PyCFunction_CAST(os_remove), METH_FASTCALL|METH_KEYWORDS, os_remove__doc__},\n\nstatic PyObject *\nos_remove_impl(PyObject *module, path_t *path, int dir_fd);\n\nstatic PyObject *\nos_remove(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(dir_fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"dir_fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"remove\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    path_t path = PATH_T_INITIALIZE_P(\"remove\", \"path\", 0, 0, 0, 0);\n    int dir_fd = DEFAULT_DIR_FD;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (!UNLINKAT_DIR_FD_CONVERTER(args[1], &dir_fd)) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_remove_impl(module, &path, dir_fd);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#if defined(HAVE_UNAME)\n\nPyDoc_STRVAR(os_uname__doc__,\n\"uname($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return an object identifying the current operating system.\\n\"\n\"\\n\"\n\"The object behaves like a named tuple with the following fields:\\n\"\n\"  (sysname, nodename, release, version, machine)\");\n\n#define OS_UNAME_METHODDEF    \\\n    {\"uname\", (PyCFunction)os_uname, METH_NOARGS, os_uname__doc__},\n\nstatic PyObject *\nos_uname_impl(PyObject *module);\n\nstatic PyObject *\nos_uname(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_uname_impl(module);\n}\n\n#endif /* defined(HAVE_UNAME) */\n\nPyDoc_STRVAR(os_utime__doc__,\n\"utime($module, /, path, times=None, *, ns=<unrepresentable>,\\n\"\n\"      dir_fd=None, follow_symlinks=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the access and modified time of path.\\n\"\n\"\\n\"\n\"path may always be specified as a string.\\n\"\n\"On some platforms, path may also be specified as an open file descriptor.\\n\"\n\"  If this functionality is unavailable, using it raises an exception.\\n\"\n\"\\n\"\n\"If times is not None, it must be a tuple (atime, mtime);\\n\"\n\"    atime and mtime should be expressed as float seconds since the epoch.\\n\"\n\"If ns is specified, it must be a tuple (atime_ns, mtime_ns);\\n\"\n\"    atime_ns and mtime_ns should be expressed as integer nanoseconds\\n\"\n\"    since the epoch.\\n\"\n\"If times is None and ns is unspecified, utime uses the current time.\\n\"\n\"Specifying tuples for both times and ns is an error.\\n\"\n\"\\n\"\n\"If dir_fd is not None, it should be a file descriptor open to a directory,\\n\"\n\"  and path should be relative; path will then be relative to that directory.\\n\"\n\"If follow_symlinks is False, and the last element of the path is a symbolic\\n\"\n\"  link, utime will modify the symbolic link itself instead of the file the\\n\"\n\"  link points to.\\n\"\n\"It is an error to use dir_fd or follow_symlinks when specifying path\\n\"\n\"  as an open file descriptor.\\n\"\n\"dir_fd and follow_symlinks may not be available on your platform.\\n\"\n\"  If they are unavailable, using them will raise a NotImplementedError.\");\n\n#define OS_UTIME_METHODDEF    \\\n    {\"utime\", _PyCFunction_CAST(os_utime), METH_FASTCALL|METH_KEYWORDS, os_utime__doc__},\n\nstatic PyObject *\nos_utime_impl(PyObject *module, path_t *path, PyObject *times, PyObject *ns,\n              int dir_fd, int follow_symlinks);\n\nstatic PyObject *\nos_utime(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 5\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(times), &_Py_ID(ns), &_Py_ID(dir_fd), &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"times\", \"ns\", \"dir_fd\", \"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"utime\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[5];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    path_t path = PATH_T_INITIALIZE_P(\"utime\", \"path\", 0, 0, 0, PATH_UTIME_HAVE_FD);\n    PyObject *times = Py_None;\n    PyObject *ns = NULL;\n    int dir_fd = DEFAULT_DIR_FD;\n    int follow_symlinks = 1;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[1]) {\n        times = args[1];\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\nskip_optional_pos:\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (args[2]) {\n        ns = args[2];\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[3]) {\n        if (!FUTIMENSAT_DIR_FD_CONVERTER(args[3], &dir_fd)) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    follow_symlinks = PyObject_IsTrue(args[4]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_utime_impl(module, &path, times, ns, dir_fd, follow_symlinks);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\nPyDoc_STRVAR(os__exit__doc__,\n\"_exit($module, /, status)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Exit to the system with specified status, without normal exit processing.\");\n\n#define OS__EXIT_METHODDEF    \\\n    {\"_exit\", _PyCFunction_CAST(os__exit), METH_FASTCALL|METH_KEYWORDS, os__exit__doc__},\n\nstatic PyObject *\nos__exit_impl(PyObject *module, int status);\n\nstatic PyObject *\nos__exit(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(status), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"status\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"_exit\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int status;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    status = PyLong_AsInt(args[0]);\n    if (status == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os__exit_impl(module, status);\n\nexit:\n    return return_value;\n}\n\n#if defined(HAVE_EXECV)\n\nPyDoc_STRVAR(os_execv__doc__,\n\"execv($module, path, argv, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Execute an executable path with arguments, replacing current process.\\n\"\n\"\\n\"\n\"  path\\n\"\n\"    Path of executable file.\\n\"\n\"  argv\\n\"\n\"    Tuple or list of strings.\");\n\n#define OS_EXECV_METHODDEF    \\\n    {\"execv\", _PyCFunction_CAST(os_execv), METH_FASTCALL, os_execv__doc__},\n\nstatic PyObject *\nos_execv_impl(PyObject *module, path_t *path, PyObject *argv);\n\nstatic PyObject *\nos_execv(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    path_t path = PATH_T_INITIALIZE_P(\"execv\", \"path\", 0, 0, 0, 0);\n    PyObject *argv;\n\n    if (!_PyArg_CheckPositional(\"execv\", nargs, 2, 2)) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    argv = args[1];\n    return_value = os_execv_impl(module, &path, argv);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_EXECV) */\n\n#if defined(HAVE_EXECV)\n\nPyDoc_STRVAR(os_execve__doc__,\n\"execve($module, /, path, argv, env)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Execute an executable path with arguments, replacing current process.\\n\"\n\"\\n\"\n\"  path\\n\"\n\"    Path of executable file.\\n\"\n\"  argv\\n\"\n\"    Tuple or list of strings.\\n\"\n\"  env\\n\"\n\"    Dictionary of strings mapping to strings.\");\n\n#define OS_EXECVE_METHODDEF    \\\n    {\"execve\", _PyCFunction_CAST(os_execve), METH_FASTCALL|METH_KEYWORDS, os_execve__doc__},\n\nstatic PyObject *\nos_execve_impl(PyObject *module, path_t *path, PyObject *argv, PyObject *env);\n\nstatic PyObject *\nos_execve(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(argv), &_Py_ID(env), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"argv\", \"env\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"execve\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[3];\n    path_t path = PATH_T_INITIALIZE_P(\"execve\", \"path\", 0, 0, 0, PATH_HAVE_FEXECVE);\n    PyObject *argv;\n    PyObject *env;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 3, 3, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    argv = args[1];\n    env = args[2];\n    return_value = os_execve_impl(module, &path, argv, env);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_EXECV) */\n\n#if defined(HAVE_POSIX_SPAWN)\n\nPyDoc_STRVAR(os_posix_spawn__doc__,\n\"posix_spawn($module, path, argv, env, /, *, file_actions=(),\\n\"\n\"            setpgroup=<unrepresentable>, resetids=False, setsid=False,\\n\"\n\"            setsigmask=(), setsigdef=(), scheduler=<unrepresentable>)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Execute the program specified by path in a new process.\\n\"\n\"\\n\"\n\"  path\\n\"\n\"    Path of executable file.\\n\"\n\"  argv\\n\"\n\"    Tuple or list of strings.\\n\"\n\"  env\\n\"\n\"    Dictionary of strings mapping to strings.\\n\"\n\"  file_actions\\n\"\n\"    A sequence of file action tuples.\\n\"\n\"  setpgroup\\n\"\n\"    The pgroup to use with the POSIX_SPAWN_SETPGROUP flag.\\n\"\n\"  resetids\\n\"\n\"    If the value is `true` the POSIX_SPAWN_RESETIDS will be activated.\\n\"\n\"  setsid\\n\"\n\"    If the value is `true` the POSIX_SPAWN_SETSID or POSIX_SPAWN_SETSID_NP will be activated.\\n\"\n\"  setsigmask\\n\"\n\"    The sigmask to use with the POSIX_SPAWN_SETSIGMASK flag.\\n\"\n\"  setsigdef\\n\"\n\"    The sigmask to use with the POSIX_SPAWN_SETSIGDEF flag.\\n\"\n\"  scheduler\\n\"\n\"    A tuple with the scheduler policy (optional) and parameters.\");\n\n#define OS_POSIX_SPAWN_METHODDEF    \\\n    {\"posix_spawn\", _PyCFunction_CAST(os_posix_spawn), METH_FASTCALL|METH_KEYWORDS, os_posix_spawn__doc__},\n\nstatic PyObject *\nos_posix_spawn_impl(PyObject *module, path_t *path, PyObject *argv,\n                    PyObject *env, PyObject *file_actions,\n                    PyObject *setpgroup, int resetids, int setsid,\n                    PyObject *setsigmask, PyObject *setsigdef,\n                    PyObject *scheduler);\n\nstatic PyObject *\nos_posix_spawn(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 7\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(file_actions), &_Py_ID(setpgroup), &_Py_ID(resetids), &_Py_ID(setsid), &_Py_ID(setsigmask), &_Py_ID(setsigdef), &_Py_ID(scheduler), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"\", \"\", \"\", \"file_actions\", \"setpgroup\", \"resetids\", \"setsid\", \"setsigmask\", \"setsigdef\", \"scheduler\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"posix_spawn\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[10];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;\n    path_t path = PATH_T_INITIALIZE_P(\"posix_spawn\", \"path\", 0, 0, 0, 0);\n    PyObject *argv;\n    PyObject *env;\n    PyObject *file_actions = NULL;\n    PyObject *setpgroup = NULL;\n    int resetids = 0;\n    int setsid = 0;\n    PyObject *setsigmask = NULL;\n    PyObject *setsigdef = NULL;\n    PyObject *scheduler = NULL;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 3, 3, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    argv = args[1];\n    env = args[2];\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (args[3]) {\n        file_actions = args[3];\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[4]) {\n        setpgroup = args[4];\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[5]) {\n        resetids = PyObject_IsTrue(args[5]);\n        if (resetids < 0) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[6]) {\n        setsid = PyObject_IsTrue(args[6]);\n        if (setsid < 0) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[7]) {\n        setsigmask = args[7];\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[8]) {\n        setsigdef = args[8];\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    scheduler = args[9];\nskip_optional_kwonly:\n    return_value = os_posix_spawn_impl(module, &path, argv, env, file_actions, setpgroup, resetids, setsid, setsigmask, setsigdef, scheduler);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_POSIX_SPAWN) */\n\n#if defined(HAVE_POSIX_SPAWNP)\n\nPyDoc_STRVAR(os_posix_spawnp__doc__,\n\"posix_spawnp($module, path, argv, env, /, *, file_actions=(),\\n\"\n\"             setpgroup=<unrepresentable>, resetids=False, setsid=False,\\n\"\n\"             setsigmask=(), setsigdef=(), scheduler=<unrepresentable>)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Execute the program specified by path in a new process.\\n\"\n\"\\n\"\n\"  path\\n\"\n\"    Path of executable file.\\n\"\n\"  argv\\n\"\n\"    Tuple or list of strings.\\n\"\n\"  env\\n\"\n\"    Dictionary of strings mapping to strings.\\n\"\n\"  file_actions\\n\"\n\"    A sequence of file action tuples.\\n\"\n\"  setpgroup\\n\"\n\"    The pgroup to use with the POSIX_SPAWN_SETPGROUP flag.\\n\"\n\"  resetids\\n\"\n\"    If the value is `True` the POSIX_SPAWN_RESETIDS will be activated.\\n\"\n\"  setsid\\n\"\n\"    If the value is `True` the POSIX_SPAWN_SETSID or POSIX_SPAWN_SETSID_NP will be activated.\\n\"\n\"  setsigmask\\n\"\n\"    The sigmask to use with the POSIX_SPAWN_SETSIGMASK flag.\\n\"\n\"  setsigdef\\n\"\n\"    The sigmask to use with the POSIX_SPAWN_SETSIGDEF flag.\\n\"\n\"  scheduler\\n\"\n\"    A tuple with the scheduler policy (optional) and parameters.\");\n\n#define OS_POSIX_SPAWNP_METHODDEF    \\\n    {\"posix_spawnp\", _PyCFunction_CAST(os_posix_spawnp), METH_FASTCALL|METH_KEYWORDS, os_posix_spawnp__doc__},\n\nstatic PyObject *\nos_posix_spawnp_impl(PyObject *module, path_t *path, PyObject *argv,\n                     PyObject *env, PyObject *file_actions,\n                     PyObject *setpgroup, int resetids, int setsid,\n                     PyObject *setsigmask, PyObject *setsigdef,\n                     PyObject *scheduler);\n\nstatic PyObject *\nos_posix_spawnp(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 7\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(file_actions), &_Py_ID(setpgroup), &_Py_ID(resetids), &_Py_ID(setsid), &_Py_ID(setsigmask), &_Py_ID(setsigdef), &_Py_ID(scheduler), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"\", \"\", \"\", \"file_actions\", \"setpgroup\", \"resetids\", \"setsid\", \"setsigmask\", \"setsigdef\", \"scheduler\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"posix_spawnp\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[10];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;\n    path_t path = PATH_T_INITIALIZE_P(\"posix_spawnp\", \"path\", 0, 0, 0, 0);\n    PyObject *argv;\n    PyObject *env;\n    PyObject *file_actions = NULL;\n    PyObject *setpgroup = NULL;\n    int resetids = 0;\n    int setsid = 0;\n    PyObject *setsigmask = NULL;\n    PyObject *setsigdef = NULL;\n    PyObject *scheduler = NULL;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 3, 3, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    argv = args[1];\n    env = args[2];\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (args[3]) {\n        file_actions = args[3];\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[4]) {\n        setpgroup = args[4];\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[5]) {\n        resetids = PyObject_IsTrue(args[5]);\n        if (resetids < 0) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[6]) {\n        setsid = PyObject_IsTrue(args[6]);\n        if (setsid < 0) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[7]) {\n        setsigmask = args[7];\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[8]) {\n        setsigdef = args[8];\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    scheduler = args[9];\nskip_optional_kwonly:\n    return_value = os_posix_spawnp_impl(module, &path, argv, env, file_actions, setpgroup, resetids, setsid, setsigmask, setsigdef, scheduler);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_POSIX_SPAWNP) */\n\n#if (defined(HAVE_SPAWNV) || defined(HAVE_WSPAWNV) || defined(HAVE_RTPSPAWN))\n\nPyDoc_STRVAR(os_spawnv__doc__,\n\"spawnv($module, mode, path, argv, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Execute the program specified by path in a new process.\\n\"\n\"\\n\"\n\"  mode\\n\"\n\"    Mode of process creation.\\n\"\n\"  path\\n\"\n\"    Path of executable file.\\n\"\n\"  argv\\n\"\n\"    Tuple or list of strings.\");\n\n#define OS_SPAWNV_METHODDEF    \\\n    {\"spawnv\", _PyCFunction_CAST(os_spawnv), METH_FASTCALL, os_spawnv__doc__},\n\nstatic PyObject *\nos_spawnv_impl(PyObject *module, int mode, path_t *path, PyObject *argv);\n\nstatic PyObject *\nos_spawnv(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int mode;\n    path_t path = PATH_T_INITIALIZE_P(\"spawnv\", \"path\", 0, 0, 0, 0);\n    PyObject *argv;\n\n    if (!_PyArg_CheckPositional(\"spawnv\", nargs, 3, 3)) {\n        goto exit;\n    }\n    mode = PyLong_AsInt(args[0]);\n    if (mode == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!path_converter(args[1], &path)) {\n        goto exit;\n    }\n    argv = args[2];\n    return_value = os_spawnv_impl(module, mode, &path, argv);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* (defined(HAVE_SPAWNV) || defined(HAVE_WSPAWNV) || defined(HAVE_RTPSPAWN)) */\n\n#if (defined(HAVE_SPAWNV) || defined(HAVE_WSPAWNV) || defined(HAVE_RTPSPAWN))\n\nPyDoc_STRVAR(os_spawnve__doc__,\n\"spawnve($module, mode, path, argv, env, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Execute the program specified by path in a new process.\\n\"\n\"\\n\"\n\"  mode\\n\"\n\"    Mode of process creation.\\n\"\n\"  path\\n\"\n\"    Path of executable file.\\n\"\n\"  argv\\n\"\n\"    Tuple or list of strings.\\n\"\n\"  env\\n\"\n\"    Dictionary of strings mapping to strings.\");\n\n#define OS_SPAWNVE_METHODDEF    \\\n    {\"spawnve\", _PyCFunction_CAST(os_spawnve), METH_FASTCALL, os_spawnve__doc__},\n\nstatic PyObject *\nos_spawnve_impl(PyObject *module, int mode, path_t *path, PyObject *argv,\n                PyObject *env);\n\nstatic PyObject *\nos_spawnve(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int mode;\n    path_t path = PATH_T_INITIALIZE_P(\"spawnve\", \"path\", 0, 0, 0, 0);\n    PyObject *argv;\n    PyObject *env;\n\n    if (!_PyArg_CheckPositional(\"spawnve\", nargs, 4, 4)) {\n        goto exit;\n    }\n    mode = PyLong_AsInt(args[0]);\n    if (mode == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!path_converter(args[1], &path)) {\n        goto exit;\n    }\n    argv = args[2];\n    env = args[3];\n    return_value = os_spawnve_impl(module, mode, &path, argv, env);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* (defined(HAVE_SPAWNV) || defined(HAVE_WSPAWNV) || defined(HAVE_RTPSPAWN)) */\n\n#if defined(HAVE_FORK)\n\nPyDoc_STRVAR(os_register_at_fork__doc__,\n\"register_at_fork($module, /, *, before=<unrepresentable>,\\n\"\n\"                 after_in_child=<unrepresentable>,\\n\"\n\"                 after_in_parent=<unrepresentable>)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Register callables to be called when forking a new process.\\n\"\n\"\\n\"\n\"  before\\n\"\n\"    A callable to be called in the parent before the fork() syscall.\\n\"\n\"  after_in_child\\n\"\n\"    A callable to be called in the child after fork().\\n\"\n\"  after_in_parent\\n\"\n\"    A callable to be called in the parent after fork().\\n\"\n\"\\n\"\n\"\\'before\\' callbacks are called in reverse order.\\n\"\n\"\\'after_in_child\\' and \\'after_in_parent\\' callbacks are called in order.\");\n\n#define OS_REGISTER_AT_FORK_METHODDEF    \\\n    {\"register_at_fork\", _PyCFunction_CAST(os_register_at_fork), METH_FASTCALL|METH_KEYWORDS, os_register_at_fork__doc__},\n\nstatic PyObject *\nos_register_at_fork_impl(PyObject *module, PyObject *before,\n                         PyObject *after_in_child, PyObject *after_in_parent);\n\nstatic PyObject *\nos_register_at_fork(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(before), &_Py_ID(after_in_child), &_Py_ID(after_in_parent), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"before\", \"after_in_child\", \"after_in_parent\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"register_at_fork\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[3];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;\n    PyObject *before = NULL;\n    PyObject *after_in_child = NULL;\n    PyObject *after_in_parent = NULL;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (args[0]) {\n        before = args[0];\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[1]) {\n        after_in_child = args[1];\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    after_in_parent = args[2];\nskip_optional_kwonly:\n    return_value = os_register_at_fork_impl(module, before, after_in_child, after_in_parent);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_FORK) */\n\n#if defined(HAVE_FORK1)\n\nPyDoc_STRVAR(os_fork1__doc__,\n\"fork1($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Fork a child process with a single multiplexed (i.e., not bound) thread.\\n\"\n\"\\n\"\n\"Return 0 to child process and PID of child to parent process.\");\n\n#define OS_FORK1_METHODDEF    \\\n    {\"fork1\", (PyCFunction)os_fork1, METH_NOARGS, os_fork1__doc__},\n\nstatic PyObject *\nos_fork1_impl(PyObject *module);\n\nstatic PyObject *\nos_fork1(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_fork1_impl(module);\n}\n\n#endif /* defined(HAVE_FORK1) */\n\n#if defined(HAVE_FORK)\n\nPyDoc_STRVAR(os_fork__doc__,\n\"fork($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Fork a child process.\\n\"\n\"\\n\"\n\"Return 0 to child process and PID of child to parent process.\");\n\n#define OS_FORK_METHODDEF    \\\n    {\"fork\", (PyCFunction)os_fork, METH_NOARGS, os_fork__doc__},\n\nstatic PyObject *\nos_fork_impl(PyObject *module);\n\nstatic PyObject *\nos_fork(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_fork_impl(module);\n}\n\n#endif /* defined(HAVE_FORK) */\n\n#if defined(HAVE_SCHED_H) && defined(HAVE_SCHED_GET_PRIORITY_MAX)\n\nPyDoc_STRVAR(os_sched_get_priority_max__doc__,\n\"sched_get_priority_max($module, /, policy)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Get the maximum scheduling priority for policy.\");\n\n#define OS_SCHED_GET_PRIORITY_MAX_METHODDEF    \\\n    {\"sched_get_priority_max\", _PyCFunction_CAST(os_sched_get_priority_max), METH_FASTCALL|METH_KEYWORDS, os_sched_get_priority_max__doc__},\n\nstatic PyObject *\nos_sched_get_priority_max_impl(PyObject *module, int policy);\n\nstatic PyObject *\nos_sched_get_priority_max(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(policy), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"policy\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"sched_get_priority_max\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int policy;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    policy = PyLong_AsInt(args[0]);\n    if (policy == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_sched_get_priority_max_impl(module, policy);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SCHED_H) && defined(HAVE_SCHED_GET_PRIORITY_MAX) */\n\n#if defined(HAVE_SCHED_H) && defined(HAVE_SCHED_GET_PRIORITY_MAX)\n\nPyDoc_STRVAR(os_sched_get_priority_min__doc__,\n\"sched_get_priority_min($module, /, policy)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Get the minimum scheduling priority for policy.\");\n\n#define OS_SCHED_GET_PRIORITY_MIN_METHODDEF    \\\n    {\"sched_get_priority_min\", _PyCFunction_CAST(os_sched_get_priority_min), METH_FASTCALL|METH_KEYWORDS, os_sched_get_priority_min__doc__},\n\nstatic PyObject *\nos_sched_get_priority_min_impl(PyObject *module, int policy);\n\nstatic PyObject *\nos_sched_get_priority_min(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(policy), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"policy\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"sched_get_priority_min\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int policy;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    policy = PyLong_AsInt(args[0]);\n    if (policy == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_sched_get_priority_min_impl(module, policy);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SCHED_H) && defined(HAVE_SCHED_GET_PRIORITY_MAX) */\n\n#if defined(HAVE_SCHED_H) && defined(HAVE_SCHED_SETSCHEDULER)\n\nPyDoc_STRVAR(os_sched_getscheduler__doc__,\n\"sched_getscheduler($module, pid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Get the scheduling policy for the process identified by pid.\\n\"\n\"\\n\"\n\"Passing 0 for pid returns the scheduling policy for the calling process.\");\n\n#define OS_SCHED_GETSCHEDULER_METHODDEF    \\\n    {\"sched_getscheduler\", (PyCFunction)os_sched_getscheduler, METH_O, os_sched_getscheduler__doc__},\n\nstatic PyObject *\nos_sched_getscheduler_impl(PyObject *module, pid_t pid);\n\nstatic PyObject *\nos_sched_getscheduler(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    pid_t pid;\n\n    if (!PyArg_Parse(arg, \"\" _Py_PARSE_PID \":sched_getscheduler\", &pid)) {\n        goto exit;\n    }\n    return_value = os_sched_getscheduler_impl(module, pid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SCHED_H) && defined(HAVE_SCHED_SETSCHEDULER) */\n\n#if defined(HAVE_SCHED_H) && (defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDPARAM))\n\nPyDoc_STRVAR(os_sched_param__doc__,\n\"sched_param(sched_priority)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Currently has only one field: sched_priority\\n\"\n\"\\n\"\n\"  sched_priority\\n\"\n\"    A scheduling parameter.\");\n\nstatic PyObject *\nos_sched_param_impl(PyTypeObject *type, PyObject *sched_priority);\n\nstatic PyObject *\nos_sched_param(PyTypeObject *type, PyObject *args, PyObject *kwargs)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(sched_priority), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"sched_priority\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"sched_param\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    PyObject * const *fastargs;\n    Py_ssize_t nargs = PyTuple_GET_SIZE(args);\n    PyObject *sched_priority;\n\n    fastargs = _PyArg_UnpackKeywords(_PyTuple_CAST(args)->ob_item, nargs, kwargs, NULL, &_parser, 1, 1, 0, argsbuf);\n    if (!fastargs) {\n        goto exit;\n    }\n    sched_priority = fastargs[0];\n    return_value = os_sched_param_impl(type, sched_priority);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SCHED_H) && (defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDPARAM)) */\n\n#if defined(HAVE_SCHED_H) && defined(HAVE_SCHED_SETSCHEDULER)\n\nPyDoc_STRVAR(os_sched_setscheduler__doc__,\n\"sched_setscheduler($module, pid, policy, param, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the scheduling policy for the process identified by pid.\\n\"\n\"\\n\"\n\"If pid is 0, the calling process is changed.\\n\"\n\"param is an instance of sched_param.\");\n\n#define OS_SCHED_SETSCHEDULER_METHODDEF    \\\n    {\"sched_setscheduler\", _PyCFunction_CAST(os_sched_setscheduler), METH_FASTCALL, os_sched_setscheduler__doc__},\n\nstatic PyObject *\nos_sched_setscheduler_impl(PyObject *module, pid_t pid, int policy,\n                           PyObject *param_obj);\n\nstatic PyObject *\nos_sched_setscheduler(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    pid_t pid;\n    int policy;\n    PyObject *param_obj;\n\n    if (!_PyArg_ParseStack(args, nargs, \"\" _Py_PARSE_PID \"iO:sched_setscheduler\",\n        &pid, &policy, &param_obj)) {\n        goto exit;\n    }\n    return_value = os_sched_setscheduler_impl(module, pid, policy, param_obj);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SCHED_H) && defined(HAVE_SCHED_SETSCHEDULER) */\n\n#if defined(HAVE_SCHED_H) && defined(HAVE_SCHED_SETPARAM)\n\nPyDoc_STRVAR(os_sched_getparam__doc__,\n\"sched_getparam($module, pid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Returns scheduling parameters for the process identified by pid.\\n\"\n\"\\n\"\n\"If pid is 0, returns parameters for the calling process.\\n\"\n\"Return value is an instance of sched_param.\");\n\n#define OS_SCHED_GETPARAM_METHODDEF    \\\n    {\"sched_getparam\", (PyCFunction)os_sched_getparam, METH_O, os_sched_getparam__doc__},\n\nstatic PyObject *\nos_sched_getparam_impl(PyObject *module, pid_t pid);\n\nstatic PyObject *\nos_sched_getparam(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    pid_t pid;\n\n    if (!PyArg_Parse(arg, \"\" _Py_PARSE_PID \":sched_getparam\", &pid)) {\n        goto exit;\n    }\n    return_value = os_sched_getparam_impl(module, pid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SCHED_H) && defined(HAVE_SCHED_SETPARAM) */\n\n#if defined(HAVE_SCHED_H) && defined(HAVE_SCHED_SETPARAM)\n\nPyDoc_STRVAR(os_sched_setparam__doc__,\n\"sched_setparam($module, pid, param, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set scheduling parameters for the process identified by pid.\\n\"\n\"\\n\"\n\"If pid is 0, sets parameters for the calling process.\\n\"\n\"param should be an instance of sched_param.\");\n\n#define OS_SCHED_SETPARAM_METHODDEF    \\\n    {\"sched_setparam\", _PyCFunction_CAST(os_sched_setparam), METH_FASTCALL, os_sched_setparam__doc__},\n\nstatic PyObject *\nos_sched_setparam_impl(PyObject *module, pid_t pid, PyObject *param_obj);\n\nstatic PyObject *\nos_sched_setparam(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    pid_t pid;\n    PyObject *param_obj;\n\n    if (!_PyArg_ParseStack(args, nargs, \"\" _Py_PARSE_PID \"O:sched_setparam\",\n        &pid, &param_obj)) {\n        goto exit;\n    }\n    return_value = os_sched_setparam_impl(module, pid, param_obj);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SCHED_H) && defined(HAVE_SCHED_SETPARAM) */\n\n#if defined(HAVE_SCHED_H) && defined(HAVE_SCHED_RR_GET_INTERVAL)\n\nPyDoc_STRVAR(os_sched_rr_get_interval__doc__,\n\"sched_rr_get_interval($module, pid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the round-robin quantum for the process identified by pid, in seconds.\\n\"\n\"\\n\"\n\"Value returned is a float.\");\n\n#define OS_SCHED_RR_GET_INTERVAL_METHODDEF    \\\n    {\"sched_rr_get_interval\", (PyCFunction)os_sched_rr_get_interval, METH_O, os_sched_rr_get_interval__doc__},\n\nstatic double\nos_sched_rr_get_interval_impl(PyObject *module, pid_t pid);\n\nstatic PyObject *\nos_sched_rr_get_interval(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    pid_t pid;\n    double _return_value;\n\n    if (!PyArg_Parse(arg, \"\" _Py_PARSE_PID \":sched_rr_get_interval\", &pid)) {\n        goto exit;\n    }\n    _return_value = os_sched_rr_get_interval_impl(module, pid);\n    if ((_return_value == -1.0) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyFloat_FromDouble(_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SCHED_H) && defined(HAVE_SCHED_RR_GET_INTERVAL) */\n\n#if defined(HAVE_SCHED_H)\n\nPyDoc_STRVAR(os_sched_yield__doc__,\n\"sched_yield($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Voluntarily relinquish the CPU.\");\n\n#define OS_SCHED_YIELD_METHODDEF    \\\n    {\"sched_yield\", (PyCFunction)os_sched_yield, METH_NOARGS, os_sched_yield__doc__},\n\nstatic PyObject *\nos_sched_yield_impl(PyObject *module);\n\nstatic PyObject *\nos_sched_yield(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_sched_yield_impl(module);\n}\n\n#endif /* defined(HAVE_SCHED_H) */\n\n#if defined(HAVE_SCHED_H) && defined(HAVE_SCHED_SETAFFINITY)\n\nPyDoc_STRVAR(os_sched_setaffinity__doc__,\n\"sched_setaffinity($module, pid, mask, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the CPU affinity of the process identified by pid to mask.\\n\"\n\"\\n\"\n\"mask should be an iterable of integers identifying CPUs.\");\n\n#define OS_SCHED_SETAFFINITY_METHODDEF    \\\n    {\"sched_setaffinity\", _PyCFunction_CAST(os_sched_setaffinity), METH_FASTCALL, os_sched_setaffinity__doc__},\n\nstatic PyObject *\nos_sched_setaffinity_impl(PyObject *module, pid_t pid, PyObject *mask);\n\nstatic PyObject *\nos_sched_setaffinity(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    pid_t pid;\n    PyObject *mask;\n\n    if (!_PyArg_ParseStack(args, nargs, \"\" _Py_PARSE_PID \"O:sched_setaffinity\",\n        &pid, &mask)) {\n        goto exit;\n    }\n    return_value = os_sched_setaffinity_impl(module, pid, mask);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SCHED_H) && defined(HAVE_SCHED_SETAFFINITY) */\n\n#if defined(HAVE_SCHED_H) && defined(HAVE_SCHED_SETAFFINITY)\n\nPyDoc_STRVAR(os_sched_getaffinity__doc__,\n\"sched_getaffinity($module, pid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the affinity of the process identified by pid (or the current process if zero).\\n\"\n\"\\n\"\n\"The affinity is returned as a set of CPU identifiers.\");\n\n#define OS_SCHED_GETAFFINITY_METHODDEF    \\\n    {\"sched_getaffinity\", (PyCFunction)os_sched_getaffinity, METH_O, os_sched_getaffinity__doc__},\n\nstatic PyObject *\nos_sched_getaffinity_impl(PyObject *module, pid_t pid);\n\nstatic PyObject *\nos_sched_getaffinity(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    pid_t pid;\n\n    if (!PyArg_Parse(arg, \"\" _Py_PARSE_PID \":sched_getaffinity\", &pid)) {\n        goto exit;\n    }\n    return_value = os_sched_getaffinity_impl(module, pid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SCHED_H) && defined(HAVE_SCHED_SETAFFINITY) */\n\n#if defined(HAVE_POSIX_OPENPT)\n\nPyDoc_STRVAR(os_posix_openpt__doc__,\n\"posix_openpt($module, oflag, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Open and return a file descriptor for a master pseudo-terminal device.\\n\"\n\"\\n\"\n\"Performs a posix_openpt() C function call. The oflag argument is used to\\n\"\n\"set file status flags and file access modes as specified in the manual page\\n\"\n\"of posix_openpt() of your system.\");\n\n#define OS_POSIX_OPENPT_METHODDEF    \\\n    {\"posix_openpt\", (PyCFunction)os_posix_openpt, METH_O, os_posix_openpt__doc__},\n\nstatic int\nos_posix_openpt_impl(PyObject *module, int oflag);\n\nstatic PyObject *\nos_posix_openpt(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int oflag;\n    int _return_value;\n\n    oflag = PyLong_AsInt(arg);\n    if (oflag == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_posix_openpt_impl(module, oflag);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_POSIX_OPENPT) */\n\n#if defined(HAVE_GRANTPT)\n\nPyDoc_STRVAR(os_grantpt__doc__,\n\"grantpt($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Grant access to the slave pseudo-terminal device.\\n\"\n\"\\n\"\n\"  fd\\n\"\n\"    File descriptor of a master pseudo-terminal device.\\n\"\n\"\\n\"\n\"Performs a grantpt() C function call.\");\n\n#define OS_GRANTPT_METHODDEF    \\\n    {\"grantpt\", (PyCFunction)os_grantpt, METH_O, os_grantpt__doc__},\n\nstatic PyObject *\nos_grantpt_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_grantpt(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n\n    fd = PyObject_AsFileDescriptor(arg);\n    if (fd < 0) {\n        goto exit;\n    }\n    return_value = os_grantpt_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_GRANTPT) */\n\n#if defined(HAVE_UNLOCKPT)\n\nPyDoc_STRVAR(os_unlockpt__doc__,\n\"unlockpt($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Unlock a pseudo-terminal master/slave pair.\\n\"\n\"\\n\"\n\"  fd\\n\"\n\"    File descriptor of a master pseudo-terminal device.\\n\"\n\"\\n\"\n\"Performs an unlockpt() C function call.\");\n\n#define OS_UNLOCKPT_METHODDEF    \\\n    {\"unlockpt\", (PyCFunction)os_unlockpt, METH_O, os_unlockpt__doc__},\n\nstatic PyObject *\nos_unlockpt_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_unlockpt(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n\n    fd = PyObject_AsFileDescriptor(arg);\n    if (fd < 0) {\n        goto exit;\n    }\n    return_value = os_unlockpt_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_UNLOCKPT) */\n\n#if (defined(HAVE_PTSNAME) || defined(HAVE_PTSNAME_R))\n\nPyDoc_STRVAR(os_ptsname__doc__,\n\"ptsname($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the name of the slave pseudo-terminal device.\\n\"\n\"\\n\"\n\"  fd\\n\"\n\"    File descriptor of a master pseudo-terminal device.\\n\"\n\"\\n\"\n\"If the ptsname_r() C function is available, it is called;\\n\"\n\"otherwise, performs a ptsname() C function call.\");\n\n#define OS_PTSNAME_METHODDEF    \\\n    {\"ptsname\", (PyCFunction)os_ptsname, METH_O, os_ptsname__doc__},\n\nstatic PyObject *\nos_ptsname_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_ptsname(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n\n    fd = PyObject_AsFileDescriptor(arg);\n    if (fd < 0) {\n        goto exit;\n    }\n    return_value = os_ptsname_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(HAVE_PTSNAME) || defined(HAVE_PTSNAME_R)) */\n\n#if (defined(HAVE_OPENPTY) || defined(HAVE__GETPTY) || defined(HAVE_DEV_PTMX))\n\nPyDoc_STRVAR(os_openpty__doc__,\n\"openpty($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Open a pseudo-terminal.\\n\"\n\"\\n\"\n\"Return a tuple of (master_fd, slave_fd) containing open file descriptors\\n\"\n\"for both the master and slave ends.\");\n\n#define OS_OPENPTY_METHODDEF    \\\n    {\"openpty\", (PyCFunction)os_openpty, METH_NOARGS, os_openpty__doc__},\n\nstatic PyObject *\nos_openpty_impl(PyObject *module);\n\nstatic PyObject *\nos_openpty(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_openpty_impl(module);\n}\n\n#endif /* (defined(HAVE_OPENPTY) || defined(HAVE__GETPTY) || defined(HAVE_DEV_PTMX)) */\n\n#if (defined(HAVE_LOGIN_TTY) || defined(HAVE_FALLBACK_LOGIN_TTY))\n\nPyDoc_STRVAR(os_login_tty__doc__,\n\"login_tty($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Prepare the tty of which fd is a file descriptor for a new login session.\\n\"\n\"\\n\"\n\"Make the calling process a session leader; make the tty the\\n\"\n\"controlling tty, the stdin, the stdout, and the stderr of the\\n\"\n\"calling process; close fd.\");\n\n#define OS_LOGIN_TTY_METHODDEF    \\\n    {\"login_tty\", (PyCFunction)os_login_tty, METH_O, os_login_tty__doc__},\n\nstatic PyObject *\nos_login_tty_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_login_tty(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n\n    fd = PyObject_AsFileDescriptor(arg);\n    if (fd < 0) {\n        goto exit;\n    }\n    return_value = os_login_tty_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(HAVE_LOGIN_TTY) || defined(HAVE_FALLBACK_LOGIN_TTY)) */\n\n#if defined(HAVE_FORKPTY)\n\nPyDoc_STRVAR(os_forkpty__doc__,\n\"forkpty($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Fork a new process with a new pseudo-terminal as controlling tty.\\n\"\n\"\\n\"\n\"Returns a tuple of (pid, master_fd).\\n\"\n\"Like fork(), return pid of 0 to the child process,\\n\"\n\"and pid of child to the parent process.\\n\"\n\"To both, return fd of newly opened pseudo-terminal.\");\n\n#define OS_FORKPTY_METHODDEF    \\\n    {\"forkpty\", (PyCFunction)os_forkpty, METH_NOARGS, os_forkpty__doc__},\n\nstatic PyObject *\nos_forkpty_impl(PyObject *module);\n\nstatic PyObject *\nos_forkpty(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_forkpty_impl(module);\n}\n\n#endif /* defined(HAVE_FORKPTY) */\n\n#if defined(HAVE_GETEGID)\n\nPyDoc_STRVAR(os_getegid__doc__,\n\"getegid($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the current process\\'s effective group id.\");\n\n#define OS_GETEGID_METHODDEF    \\\n    {\"getegid\", (PyCFunction)os_getegid, METH_NOARGS, os_getegid__doc__},\n\nstatic PyObject *\nos_getegid_impl(PyObject *module);\n\nstatic PyObject *\nos_getegid(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_getegid_impl(module);\n}\n\n#endif /* defined(HAVE_GETEGID) */\n\n#if defined(HAVE_GETEUID)\n\nPyDoc_STRVAR(os_geteuid__doc__,\n\"geteuid($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the current process\\'s effective user id.\");\n\n#define OS_GETEUID_METHODDEF    \\\n    {\"geteuid\", (PyCFunction)os_geteuid, METH_NOARGS, os_geteuid__doc__},\n\nstatic PyObject *\nos_geteuid_impl(PyObject *module);\n\nstatic PyObject *\nos_geteuid(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_geteuid_impl(module);\n}\n\n#endif /* defined(HAVE_GETEUID) */\n\n#if defined(HAVE_GETGID)\n\nPyDoc_STRVAR(os_getgid__doc__,\n\"getgid($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the current process\\'s group id.\");\n\n#define OS_GETGID_METHODDEF    \\\n    {\"getgid\", (PyCFunction)os_getgid, METH_NOARGS, os_getgid__doc__},\n\nstatic PyObject *\nos_getgid_impl(PyObject *module);\n\nstatic PyObject *\nos_getgid(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_getgid_impl(module);\n}\n\n#endif /* defined(HAVE_GETGID) */\n\n#if defined(HAVE_GETPID)\n\nPyDoc_STRVAR(os_getpid__doc__,\n\"getpid($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the current process id.\");\n\n#define OS_GETPID_METHODDEF    \\\n    {\"getpid\", (PyCFunction)os_getpid, METH_NOARGS, os_getpid__doc__},\n\nstatic PyObject *\nos_getpid_impl(PyObject *module);\n\nstatic PyObject *\nos_getpid(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_getpid_impl(module);\n}\n\n#endif /* defined(HAVE_GETPID) */\n\n#if defined(HAVE_GETGROUPLIST) && defined(__APPLE__)\n\nPyDoc_STRVAR(os_getgrouplist__doc__,\n\"getgrouplist($module, user, group, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Returns a list of groups to which a user belongs.\\n\"\n\"\\n\"\n\"  user\\n\"\n\"    username to lookup\\n\"\n\"  group\\n\"\n\"    base group id of the user\");\n\n#define OS_GETGROUPLIST_METHODDEF    \\\n    {\"getgrouplist\", _PyCFunction_CAST(os_getgrouplist), METH_FASTCALL, os_getgrouplist__doc__},\n\nstatic PyObject *\nos_getgrouplist_impl(PyObject *module, const char *user, int basegid);\n\nstatic PyObject *\nos_getgrouplist(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    const char *user;\n    int basegid;\n\n    if (!_PyArg_CheckPositional(\"getgrouplist\", nargs, 2, 2)) {\n        goto exit;\n    }\n    if (!PyUnicode_Check(args[0])) {\n        _PyArg_BadArgument(\"getgrouplist\", \"argument 1\", \"str\", args[0]);\n        goto exit;\n    }\n    Py_ssize_t user_length;\n    user = PyUnicode_AsUTF8AndSize(args[0], &user_length);\n    if (user == NULL) {\n        goto exit;\n    }\n    if (strlen(user) != (size_t)user_length) {\n        PyErr_SetString(PyExc_ValueError, \"embedded null character\");\n        goto exit;\n    }\n    basegid = PyLong_AsInt(args[1]);\n    if (basegid == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_getgrouplist_impl(module, user, basegid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_GETGROUPLIST) && defined(__APPLE__) */\n\n#if defined(HAVE_GETGROUPLIST) && !defined(__APPLE__)\n\nPyDoc_STRVAR(os_getgrouplist__doc__,\n\"getgrouplist($module, user, group, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Returns a list of groups to which a user belongs.\\n\"\n\"\\n\"\n\"  user\\n\"\n\"    username to lookup\\n\"\n\"  group\\n\"\n\"    base group id of the user\");\n\n#define OS_GETGROUPLIST_METHODDEF    \\\n    {\"getgrouplist\", _PyCFunction_CAST(os_getgrouplist), METH_FASTCALL, os_getgrouplist__doc__},\n\nstatic PyObject *\nos_getgrouplist_impl(PyObject *module, const char *user, gid_t basegid);\n\nstatic PyObject *\nos_getgrouplist(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    const char *user;\n    gid_t basegid;\n\n    if (!_PyArg_CheckPositional(\"getgrouplist\", nargs, 2, 2)) {\n        goto exit;\n    }\n    if (!PyUnicode_Check(args[0])) {\n        _PyArg_BadArgument(\"getgrouplist\", \"argument 1\", \"str\", args[0]);\n        goto exit;\n    }\n    Py_ssize_t user_length;\n    user = PyUnicode_AsUTF8AndSize(args[0], &user_length);\n    if (user == NULL) {\n        goto exit;\n    }\n    if (strlen(user) != (size_t)user_length) {\n        PyErr_SetString(PyExc_ValueError, \"embedded null character\");\n        goto exit;\n    }\n    if (!_Py_Gid_Converter(args[1], &basegid)) {\n        goto exit;\n    }\n    return_value = os_getgrouplist_impl(module, user, basegid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_GETGROUPLIST) && !defined(__APPLE__) */\n\n#if defined(HAVE_GETGROUPS)\n\nPyDoc_STRVAR(os_getgroups__doc__,\n\"getgroups($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return list of supplemental group IDs for the process.\");\n\n#define OS_GETGROUPS_METHODDEF    \\\n    {\"getgroups\", (PyCFunction)os_getgroups, METH_NOARGS, os_getgroups__doc__},\n\nstatic PyObject *\nos_getgroups_impl(PyObject *module);\n\nstatic PyObject *\nos_getgroups(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_getgroups_impl(module);\n}\n\n#endif /* defined(HAVE_GETGROUPS) */\n\n#if defined(HAVE_INITGROUPS) && defined(__APPLE__)\n\nPyDoc_STRVAR(os_initgroups__doc__,\n\"initgroups($module, username, gid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Initialize the group access list.\\n\"\n\"\\n\"\n\"Call the system initgroups() to initialize the group access list with all of\\n\"\n\"the groups of which the specified username is a member, plus the specified\\n\"\n\"group id.\");\n\n#define OS_INITGROUPS_METHODDEF    \\\n    {\"initgroups\", _PyCFunction_CAST(os_initgroups), METH_FASTCALL, os_initgroups__doc__},\n\nstatic PyObject *\nos_initgroups_impl(PyObject *module, PyObject *oname, int gid);\n\nstatic PyObject *\nos_initgroups(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    PyObject *oname = NULL;\n    int gid;\n\n    if (!_PyArg_CheckPositional(\"initgroups\", nargs, 2, 2)) {\n        goto exit;\n    }\n    if (!PyUnicode_FSConverter(args[0], &oname)) {\n        goto exit;\n    }\n    gid = PyLong_AsInt(args[1]);\n    if (gid == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_initgroups_impl(module, oname, gid);\n\nexit:\n    /* Cleanup for oname */\n    Py_XDECREF(oname);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_INITGROUPS) && defined(__APPLE__) */\n\n#if defined(HAVE_INITGROUPS) && !defined(__APPLE__)\n\nPyDoc_STRVAR(os_initgroups__doc__,\n\"initgroups($module, username, gid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Initialize the group access list.\\n\"\n\"\\n\"\n\"Call the system initgroups() to initialize the group access list with all of\\n\"\n\"the groups of which the specified username is a member, plus the specified\\n\"\n\"group id.\");\n\n#define OS_INITGROUPS_METHODDEF    \\\n    {\"initgroups\", _PyCFunction_CAST(os_initgroups), METH_FASTCALL, os_initgroups__doc__},\n\nstatic PyObject *\nos_initgroups_impl(PyObject *module, PyObject *oname, gid_t gid);\n\nstatic PyObject *\nos_initgroups(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    PyObject *oname = NULL;\n    gid_t gid;\n\n    if (!_PyArg_CheckPositional(\"initgroups\", nargs, 2, 2)) {\n        goto exit;\n    }\n    if (!PyUnicode_FSConverter(args[0], &oname)) {\n        goto exit;\n    }\n    if (!_Py_Gid_Converter(args[1], &gid)) {\n        goto exit;\n    }\n    return_value = os_initgroups_impl(module, oname, gid);\n\nexit:\n    /* Cleanup for oname */\n    Py_XDECREF(oname);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_INITGROUPS) && !defined(__APPLE__) */\n\n#if defined(HAVE_GETPGID)\n\nPyDoc_STRVAR(os_getpgid__doc__,\n\"getpgid($module, /, pid)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Call the system call getpgid(), and return the result.\");\n\n#define OS_GETPGID_METHODDEF    \\\n    {\"getpgid\", _PyCFunction_CAST(os_getpgid), METH_FASTCALL|METH_KEYWORDS, os_getpgid__doc__},\n\nstatic PyObject *\nos_getpgid_impl(PyObject *module, pid_t pid);\n\nstatic PyObject *\nos_getpgid(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(pid), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"pid\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .format = \"\" _Py_PARSE_PID \":getpgid\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    pid_t pid;\n\n    if (!_PyArg_ParseStackAndKeywords(args, nargs, kwnames, &_parser,\n        &pid)) {\n        goto exit;\n    }\n    return_value = os_getpgid_impl(module, pid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_GETPGID) */\n\n#if defined(HAVE_GETPGRP)\n\nPyDoc_STRVAR(os_getpgrp__doc__,\n\"getpgrp($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the current process group id.\");\n\n#define OS_GETPGRP_METHODDEF    \\\n    {\"getpgrp\", (PyCFunction)os_getpgrp, METH_NOARGS, os_getpgrp__doc__},\n\nstatic PyObject *\nos_getpgrp_impl(PyObject *module);\n\nstatic PyObject *\nos_getpgrp(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_getpgrp_impl(module);\n}\n\n#endif /* defined(HAVE_GETPGRP) */\n\n#if defined(HAVE_SETPGRP)\n\nPyDoc_STRVAR(os_setpgrp__doc__,\n\"setpgrp($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Make the current process the leader of its process group.\");\n\n#define OS_SETPGRP_METHODDEF    \\\n    {\"setpgrp\", (PyCFunction)os_setpgrp, METH_NOARGS, os_setpgrp__doc__},\n\nstatic PyObject *\nos_setpgrp_impl(PyObject *module);\n\nstatic PyObject *\nos_setpgrp(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_setpgrp_impl(module);\n}\n\n#endif /* defined(HAVE_SETPGRP) */\n\n#if defined(HAVE_GETPPID)\n\nPyDoc_STRVAR(os_getppid__doc__,\n\"getppid($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the parent\\'s process id.\\n\"\n\"\\n\"\n\"If the parent process has already exited, Windows machines will still\\n\"\n\"return its id; others systems will return the id of the \\'init\\' process (1).\");\n\n#define OS_GETPPID_METHODDEF    \\\n    {\"getppid\", (PyCFunction)os_getppid, METH_NOARGS, os_getppid__doc__},\n\nstatic PyObject *\nos_getppid_impl(PyObject *module);\n\nstatic PyObject *\nos_getppid(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_getppid_impl(module);\n}\n\n#endif /* defined(HAVE_GETPPID) */\n\n#if defined(HAVE_GETLOGIN)\n\nPyDoc_STRVAR(os_getlogin__doc__,\n\"getlogin($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the actual login name.\");\n\n#define OS_GETLOGIN_METHODDEF    \\\n    {\"getlogin\", (PyCFunction)os_getlogin, METH_NOARGS, os_getlogin__doc__},\n\nstatic PyObject *\nos_getlogin_impl(PyObject *module);\n\nstatic PyObject *\nos_getlogin(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_getlogin_impl(module);\n}\n\n#endif /* defined(HAVE_GETLOGIN) */\n\n#if defined(HAVE_GETUID)\n\nPyDoc_STRVAR(os_getuid__doc__,\n\"getuid($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the current process\\'s user id.\");\n\n#define OS_GETUID_METHODDEF    \\\n    {\"getuid\", (PyCFunction)os_getuid, METH_NOARGS, os_getuid__doc__},\n\nstatic PyObject *\nos_getuid_impl(PyObject *module);\n\nstatic PyObject *\nos_getuid(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_getuid_impl(module);\n}\n\n#endif /* defined(HAVE_GETUID) */\n\n#if defined(HAVE_KILL)\n\nPyDoc_STRVAR(os_kill__doc__,\n\"kill($module, pid, signal, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Kill a process with a signal.\");\n\n#define OS_KILL_METHODDEF    \\\n    {\"kill\", _PyCFunction_CAST(os_kill), METH_FASTCALL, os_kill__doc__},\n\nstatic PyObject *\nos_kill_impl(PyObject *module, pid_t pid, Py_ssize_t signal);\n\nstatic PyObject *\nos_kill(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    pid_t pid;\n    Py_ssize_t signal;\n\n    if (!_PyArg_ParseStack(args, nargs, \"\" _Py_PARSE_PID \"n:kill\",\n        &pid, &signal)) {\n        goto exit;\n    }\n    return_value = os_kill_impl(module, pid, signal);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_KILL) */\n\n#if defined(HAVE_KILLPG)\n\nPyDoc_STRVAR(os_killpg__doc__,\n\"killpg($module, pgid, signal, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Kill a process group with a signal.\");\n\n#define OS_KILLPG_METHODDEF    \\\n    {\"killpg\", _PyCFunction_CAST(os_killpg), METH_FASTCALL, os_killpg__doc__},\n\nstatic PyObject *\nos_killpg_impl(PyObject *module, pid_t pgid, int signal);\n\nstatic PyObject *\nos_killpg(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    pid_t pgid;\n    int signal;\n\n    if (!_PyArg_ParseStack(args, nargs, \"\" _Py_PARSE_PID \"i:killpg\",\n        &pgid, &signal)) {\n        goto exit;\n    }\n    return_value = os_killpg_impl(module, pgid, signal);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_KILLPG) */\n\n#if defined(HAVE_PLOCK)\n\nPyDoc_STRVAR(os_plock__doc__,\n\"plock($module, op, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Lock program segments into memory.\\\");\");\n\n#define OS_PLOCK_METHODDEF    \\\n    {\"plock\", (PyCFunction)os_plock, METH_O, os_plock__doc__},\n\nstatic PyObject *\nos_plock_impl(PyObject *module, int op);\n\nstatic PyObject *\nos_plock(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int op;\n\n    op = PyLong_AsInt(arg);\n    if (op == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_plock_impl(module, op);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_PLOCK) */\n\n#if defined(HAVE_SETUID)\n\nPyDoc_STRVAR(os_setuid__doc__,\n\"setuid($module, uid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the current process\\'s user id.\");\n\n#define OS_SETUID_METHODDEF    \\\n    {\"setuid\", (PyCFunction)os_setuid, METH_O, os_setuid__doc__},\n\nstatic PyObject *\nos_setuid_impl(PyObject *module, uid_t uid);\n\nstatic PyObject *\nos_setuid(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    uid_t uid;\n\n    if (!_Py_Uid_Converter(arg, &uid)) {\n        goto exit;\n    }\n    return_value = os_setuid_impl(module, uid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SETUID) */\n\n#if defined(HAVE_SETEUID)\n\nPyDoc_STRVAR(os_seteuid__doc__,\n\"seteuid($module, euid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the current process\\'s effective user id.\");\n\n#define OS_SETEUID_METHODDEF    \\\n    {\"seteuid\", (PyCFunction)os_seteuid, METH_O, os_seteuid__doc__},\n\nstatic PyObject *\nos_seteuid_impl(PyObject *module, uid_t euid);\n\nstatic PyObject *\nos_seteuid(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    uid_t euid;\n\n    if (!_Py_Uid_Converter(arg, &euid)) {\n        goto exit;\n    }\n    return_value = os_seteuid_impl(module, euid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SETEUID) */\n\n#if defined(HAVE_SETEGID)\n\nPyDoc_STRVAR(os_setegid__doc__,\n\"setegid($module, egid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the current process\\'s effective group id.\");\n\n#define OS_SETEGID_METHODDEF    \\\n    {\"setegid\", (PyCFunction)os_setegid, METH_O, os_setegid__doc__},\n\nstatic PyObject *\nos_setegid_impl(PyObject *module, gid_t egid);\n\nstatic PyObject *\nos_setegid(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    gid_t egid;\n\n    if (!_Py_Gid_Converter(arg, &egid)) {\n        goto exit;\n    }\n    return_value = os_setegid_impl(module, egid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SETEGID) */\n\n#if defined(HAVE_SETREUID)\n\nPyDoc_STRVAR(os_setreuid__doc__,\n\"setreuid($module, ruid, euid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the current process\\'s real and effective user ids.\");\n\n#define OS_SETREUID_METHODDEF    \\\n    {\"setreuid\", _PyCFunction_CAST(os_setreuid), METH_FASTCALL, os_setreuid__doc__},\n\nstatic PyObject *\nos_setreuid_impl(PyObject *module, uid_t ruid, uid_t euid);\n\nstatic PyObject *\nos_setreuid(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    uid_t ruid;\n    uid_t euid;\n\n    if (!_PyArg_CheckPositional(\"setreuid\", nargs, 2, 2)) {\n        goto exit;\n    }\n    if (!_Py_Uid_Converter(args[0], &ruid)) {\n        goto exit;\n    }\n    if (!_Py_Uid_Converter(args[1], &euid)) {\n        goto exit;\n    }\n    return_value = os_setreuid_impl(module, ruid, euid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SETREUID) */\n\n#if defined(HAVE_SETREGID)\n\nPyDoc_STRVAR(os_setregid__doc__,\n\"setregid($module, rgid, egid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the current process\\'s real and effective group ids.\");\n\n#define OS_SETREGID_METHODDEF    \\\n    {\"setregid\", _PyCFunction_CAST(os_setregid), METH_FASTCALL, os_setregid__doc__},\n\nstatic PyObject *\nos_setregid_impl(PyObject *module, gid_t rgid, gid_t egid);\n\nstatic PyObject *\nos_setregid(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    gid_t rgid;\n    gid_t egid;\n\n    if (!_PyArg_CheckPositional(\"setregid\", nargs, 2, 2)) {\n        goto exit;\n    }\n    if (!_Py_Gid_Converter(args[0], &rgid)) {\n        goto exit;\n    }\n    if (!_Py_Gid_Converter(args[1], &egid)) {\n        goto exit;\n    }\n    return_value = os_setregid_impl(module, rgid, egid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SETREGID) */\n\n#if defined(HAVE_SETGID)\n\nPyDoc_STRVAR(os_setgid__doc__,\n\"setgid($module, gid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the current process\\'s group id.\");\n\n#define OS_SETGID_METHODDEF    \\\n    {\"setgid\", (PyCFunction)os_setgid, METH_O, os_setgid__doc__},\n\nstatic PyObject *\nos_setgid_impl(PyObject *module, gid_t gid);\n\nstatic PyObject *\nos_setgid(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    gid_t gid;\n\n    if (!_Py_Gid_Converter(arg, &gid)) {\n        goto exit;\n    }\n    return_value = os_setgid_impl(module, gid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SETGID) */\n\n#if defined(HAVE_SETGROUPS)\n\nPyDoc_STRVAR(os_setgroups__doc__,\n\"setgroups($module, groups, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the groups of the current process to list.\");\n\n#define OS_SETGROUPS_METHODDEF    \\\n    {\"setgroups\", (PyCFunction)os_setgroups, METH_O, os_setgroups__doc__},\n\n#endif /* defined(HAVE_SETGROUPS) */\n\n#if defined(HAVE_WAIT3)\n\nPyDoc_STRVAR(os_wait3__doc__,\n\"wait3($module, /, options)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Wait for completion of a child process.\\n\"\n\"\\n\"\n\"Returns a tuple of information about the child process:\\n\"\n\"  (pid, status, rusage)\");\n\n#define OS_WAIT3_METHODDEF    \\\n    {\"wait3\", _PyCFunction_CAST(os_wait3), METH_FASTCALL|METH_KEYWORDS, os_wait3__doc__},\n\nstatic PyObject *\nos_wait3_impl(PyObject *module, int options);\n\nstatic PyObject *\nos_wait3(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(options), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"options\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"wait3\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int options;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    options = PyLong_AsInt(args[0]);\n    if (options == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_wait3_impl(module, options);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_WAIT3) */\n\n#if defined(HAVE_WAIT4)\n\nPyDoc_STRVAR(os_wait4__doc__,\n\"wait4($module, /, pid, options)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Wait for completion of a specific child process.\\n\"\n\"\\n\"\n\"Returns a tuple of information about the child process:\\n\"\n\"  (pid, status, rusage)\");\n\n#define OS_WAIT4_METHODDEF    \\\n    {\"wait4\", _PyCFunction_CAST(os_wait4), METH_FASTCALL|METH_KEYWORDS, os_wait4__doc__},\n\nstatic PyObject *\nos_wait4_impl(PyObject *module, pid_t pid, int options);\n\nstatic PyObject *\nos_wait4(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(pid), &_Py_ID(options), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"pid\", \"options\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .format = \"\" _Py_PARSE_PID \"i:wait4\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    pid_t pid;\n    int options;\n\n    if (!_PyArg_ParseStackAndKeywords(args, nargs, kwnames, &_parser,\n        &pid, &options)) {\n        goto exit;\n    }\n    return_value = os_wait4_impl(module, pid, options);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_WAIT4) */\n\n#if defined(HAVE_WAITID)\n\nPyDoc_STRVAR(os_waitid__doc__,\n\"waitid($module, idtype, id, options, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Returns the result of waiting for a process or processes.\\n\"\n\"\\n\"\n\"  idtype\\n\"\n\"    Must be one of be P_PID, P_PGID or P_ALL.\\n\"\n\"  id\\n\"\n\"    The id to wait on.\\n\"\n\"  options\\n\"\n\"    Constructed from the ORing of one or more of WEXITED, WSTOPPED\\n\"\n\"    or WCONTINUED and additionally may be ORed with WNOHANG or WNOWAIT.\\n\"\n\"\\n\"\n\"Returns either waitid_result or None if WNOHANG is specified and there are\\n\"\n\"no children in a waitable state.\");\n\n#define OS_WAITID_METHODDEF    \\\n    {\"waitid\", _PyCFunction_CAST(os_waitid), METH_FASTCALL, os_waitid__doc__},\n\nstatic PyObject *\nos_waitid_impl(PyObject *module, idtype_t idtype, id_t id, int options);\n\nstatic PyObject *\nos_waitid(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    idtype_t idtype;\n    id_t id;\n    int options;\n\n    if (!_PyArg_ParseStack(args, nargs, \"i\" _Py_PARSE_PID \"i:waitid\",\n        &idtype, &id, &options)) {\n        goto exit;\n    }\n    return_value = os_waitid_impl(module, idtype, id, options);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_WAITID) */\n\n#if defined(HAVE_WAITPID)\n\nPyDoc_STRVAR(os_waitpid__doc__,\n\"waitpid($module, pid, options, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Wait for completion of a given child process.\\n\"\n\"\\n\"\n\"Returns a tuple of information regarding the child process:\\n\"\n\"    (pid, status)\\n\"\n\"\\n\"\n\"The options argument is ignored on Windows.\");\n\n#define OS_WAITPID_METHODDEF    \\\n    {\"waitpid\", _PyCFunction_CAST(os_waitpid), METH_FASTCALL, os_waitpid__doc__},\n\nstatic PyObject *\nos_waitpid_impl(PyObject *module, pid_t pid, int options);\n\nstatic PyObject *\nos_waitpid(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    pid_t pid;\n    int options;\n\n    if (!_PyArg_ParseStack(args, nargs, \"\" _Py_PARSE_PID \"i:waitpid\",\n        &pid, &options)) {\n        goto exit;\n    }\n    return_value = os_waitpid_impl(module, pid, options);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_WAITPID) */\n\n#if !defined(HAVE_WAITPID) && defined(HAVE_CWAIT)\n\nPyDoc_STRVAR(os_waitpid__doc__,\n\"waitpid($module, pid, options, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Wait for completion of a given process.\\n\"\n\"\\n\"\n\"Returns a tuple of information regarding the process:\\n\"\n\"    (pid, status << 8)\\n\"\n\"\\n\"\n\"The options argument is ignored on Windows.\");\n\n#define OS_WAITPID_METHODDEF    \\\n    {\"waitpid\", _PyCFunction_CAST(os_waitpid), METH_FASTCALL, os_waitpid__doc__},\n\nstatic PyObject *\nos_waitpid_impl(PyObject *module, intptr_t pid, int options);\n\nstatic PyObject *\nos_waitpid(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    intptr_t pid;\n    int options;\n\n    if (!_PyArg_ParseStack(args, nargs, \"\" _Py_PARSE_INTPTR \"i:waitpid\",\n        &pid, &options)) {\n        goto exit;\n    }\n    return_value = os_waitpid_impl(module, pid, options);\n\nexit:\n    return return_value;\n}\n\n#endif /* !defined(HAVE_WAITPID) && defined(HAVE_CWAIT) */\n\n#if defined(HAVE_WAIT)\n\nPyDoc_STRVAR(os_wait__doc__,\n\"wait($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Wait for completion of a child process.\\n\"\n\"\\n\"\n\"Returns a tuple of information about the child process:\\n\"\n\"    (pid, status)\");\n\n#define OS_WAIT_METHODDEF    \\\n    {\"wait\", (PyCFunction)os_wait, METH_NOARGS, os_wait__doc__},\n\nstatic PyObject *\nos_wait_impl(PyObject *module);\n\nstatic PyObject *\nos_wait(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_wait_impl(module);\n}\n\n#endif /* defined(HAVE_WAIT) */\n\n#if (defined(__linux__) && defined(__NR_pidfd_open))\n\nPyDoc_STRVAR(os_pidfd_open__doc__,\n\"pidfd_open($module, /, pid, flags=0)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a file descriptor referring to the process *pid*.\\n\"\n\"\\n\"\n\"The descriptor can be used to perform process management without races and\\n\"\n\"signals.\");\n\n#define OS_PIDFD_OPEN_METHODDEF    \\\n    {\"pidfd_open\", _PyCFunction_CAST(os_pidfd_open), METH_FASTCALL|METH_KEYWORDS, os_pidfd_open__doc__},\n\nstatic PyObject *\nos_pidfd_open_impl(PyObject *module, pid_t pid, unsigned int flags);\n\nstatic PyObject *\nos_pidfd_open(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(pid), &_Py_ID(flags), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"pid\", \"flags\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .format = \"\" _Py_PARSE_PID \"|O&:pidfd_open\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    pid_t pid;\n    unsigned int flags = 0;\n\n    if (!_PyArg_ParseStackAndKeywords(args, nargs, kwnames, &_parser,\n        &pid, _PyLong_UnsignedInt_Converter, &flags)) {\n        goto exit;\n    }\n    return_value = os_pidfd_open_impl(module, pid, flags);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(__linux__) && defined(__NR_pidfd_open)) */\n\n#if defined(HAVE_SETNS)\n\nPyDoc_STRVAR(os_setns__doc__,\n\"setns($module, /, fd, nstype=0)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Move the calling thread into different namespaces.\\n\"\n\"\\n\"\n\"  fd\\n\"\n\"    A file descriptor to a namespace.\\n\"\n\"  nstype\\n\"\n\"    Type of namespace.\");\n\n#define OS_SETNS_METHODDEF    \\\n    {\"setns\", _PyCFunction_CAST(os_setns), METH_FASTCALL|METH_KEYWORDS, os_setns__doc__},\n\nstatic PyObject *\nos_setns_impl(PyObject *module, int fd, int nstype);\n\nstatic PyObject *\nos_setns(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(fd), &_Py_ID(nstype), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"fd\", \"nstype\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"setns\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    int fd;\n    int nstype = 0;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyObject_AsFileDescriptor(args[0]);\n    if (fd < 0) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    nstype = PyLong_AsInt(args[1]);\n    if (nstype == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional_pos:\n    return_value = os_setns_impl(module, fd, nstype);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SETNS) */\n\n#if defined(HAVE_UNSHARE)\n\nPyDoc_STRVAR(os_unshare__doc__,\n\"unshare($module, /, flags)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Disassociate parts of a process (or thread) execution context.\\n\"\n\"\\n\"\n\"  flags\\n\"\n\"    Namespaces to be unshared.\");\n\n#define OS_UNSHARE_METHODDEF    \\\n    {\"unshare\", _PyCFunction_CAST(os_unshare), METH_FASTCALL|METH_KEYWORDS, os_unshare__doc__},\n\nstatic PyObject *\nos_unshare_impl(PyObject *module, int flags);\n\nstatic PyObject *\nos_unshare(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(flags), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"flags\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"unshare\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int flags;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    flags = PyLong_AsInt(args[0]);\n    if (flags == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_unshare_impl(module, flags);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_UNSHARE) */\n\n#if (defined(HAVE_READLINK) || defined(MS_WINDOWS))\n\nPyDoc_STRVAR(os_readlink__doc__,\n\"readlink($module, /, path, *, dir_fd=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a string representing the path to which the symbolic link points.\\n\"\n\"\\n\"\n\"If dir_fd is not None, it should be a file descriptor open to a directory,\\n\"\n\"and path should be relative; path will then be relative to that directory.\\n\"\n\"\\n\"\n\"dir_fd may not be implemented on your platform.  If it is unavailable,\\n\"\n\"using it will raise a NotImplementedError.\");\n\n#define OS_READLINK_METHODDEF    \\\n    {\"readlink\", _PyCFunction_CAST(os_readlink), METH_FASTCALL|METH_KEYWORDS, os_readlink__doc__},\n\nstatic PyObject *\nos_readlink_impl(PyObject *module, path_t *path, int dir_fd);\n\nstatic PyObject *\nos_readlink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(dir_fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"dir_fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"readlink\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    path_t path = PATH_T_INITIALIZE_P(\"readlink\", \"path\", 0, 0, 0, 0);\n    int dir_fd = DEFAULT_DIR_FD;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (!READLINKAT_DIR_FD_CONVERTER(args[1], &dir_fd)) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_readlink_impl(module, &path, dir_fd);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* (defined(HAVE_READLINK) || defined(MS_WINDOWS)) */\n\n#if defined(HAVE_SYMLINK)\n\nPyDoc_STRVAR(os_symlink__doc__,\n\"symlink($module, /, src, dst, target_is_directory=False, *, dir_fd=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Create a symbolic link pointing to src named dst.\\n\"\n\"\\n\"\n\"target_is_directory is required on Windows if the target is to be\\n\"\n\"  interpreted as a directory.  (On Windows, symlink requires\\n\"\n\"  Windows 6.0 or greater, and raises a NotImplementedError otherwise.)\\n\"\n\"  target_is_directory is ignored on non-Windows platforms.\\n\"\n\"\\n\"\n\"If dir_fd is not None, it should be a file descriptor open to a directory,\\n\"\n\"  and path should be relative; path will then be relative to that directory.\\n\"\n\"dir_fd may not be implemented on your platform.\\n\"\n\"  If it is unavailable, using it will raise a NotImplementedError.\");\n\n#define OS_SYMLINK_METHODDEF    \\\n    {\"symlink\", _PyCFunction_CAST(os_symlink), METH_FASTCALL|METH_KEYWORDS, os_symlink__doc__},\n\nstatic PyObject *\nos_symlink_impl(PyObject *module, path_t *src, path_t *dst,\n                int target_is_directory, int dir_fd);\n\nstatic PyObject *\nos_symlink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 4\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(src), &_Py_ID(dst), &_Py_ID(target_is_directory), &_Py_ID(dir_fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"src\", \"dst\", \"target_is_directory\", \"dir_fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"symlink\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[4];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;\n    path_t src = PATH_T_INITIALIZE_P(\"symlink\", \"src\", 0, 0, 0, 0);\n    path_t dst = PATH_T_INITIALIZE_P(\"symlink\", \"dst\", 0, 0, 0, 0);\n    int target_is_directory = 0;\n    int dir_fd = DEFAULT_DIR_FD;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 3, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &src)) {\n        goto exit;\n    }\n    if (!path_converter(args[1], &dst)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[2]) {\n        target_is_directory = PyObject_IsTrue(args[2]);\n        if (target_is_directory < 0) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\nskip_optional_pos:\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (!SYMLINKAT_DIR_FD_CONVERTER(args[3], &dir_fd)) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_symlink_impl(module, &src, &dst, target_is_directory, dir_fd);\n\nexit:\n    /* Cleanup for src */\n    path_cleanup(&src);\n    /* Cleanup for dst */\n    path_cleanup(&dst);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_SYMLINK) */\n\nPyDoc_STRVAR(os_times__doc__,\n\"times($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a collection containing process timing information.\\n\"\n\"\\n\"\n\"The object returned behaves like a named tuple with these fields:\\n\"\n\"  (utime, stime, cutime, cstime, elapsed_time)\\n\"\n\"All fields are floating point numbers.\");\n\n#define OS_TIMES_METHODDEF    \\\n    {\"times\", (PyCFunction)os_times, METH_NOARGS, os_times__doc__},\n\nstatic PyObject *\nos_times_impl(PyObject *module);\n\nstatic PyObject *\nos_times(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_times_impl(module);\n}\n\n#if defined(HAVE_TIMERFD_CREATE)\n\nPyDoc_STRVAR(os_timerfd_create__doc__,\n\"timerfd_create($module, clockid, /, *, flags=0)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Create and return a timer file descriptor.\\n\"\n\"\\n\"\n\"  clockid\\n\"\n\"    A valid clock ID constant as timer file descriptor.\\n\"\n\"\\n\"\n\"    time.CLOCK_REALTIME\\n\"\n\"    time.CLOCK_MONOTONIC\\n\"\n\"    time.CLOCK_BOOTTIME\\n\"\n\"  flags\\n\"\n\"    0 or a bit mask of os.TFD_NONBLOCK or os.TFD_CLOEXEC.\\n\"\n\"\\n\"\n\"    os.TFD_NONBLOCK\\n\"\n\"        If *TFD_NONBLOCK* is set as a flag, read doesn\\'t blocks.\\n\"\n\"        If *TFD_NONBLOCK* is not set as a flag, read block until the timer fires.\\n\"\n\"\\n\"\n\"    os.TFD_CLOEXEC\\n\"\n\"        If *TFD_CLOEXEC* is set as a flag, enable the close-on-exec flag\");\n\n#define OS_TIMERFD_CREATE_METHODDEF    \\\n    {\"timerfd_create\", _PyCFunction_CAST(os_timerfd_create), METH_FASTCALL|METH_KEYWORDS, os_timerfd_create__doc__},\n\nstatic PyObject *\nos_timerfd_create_impl(PyObject *module, int clockid, int flags);\n\nstatic PyObject *\nos_timerfd_create(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(flags), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"\", \"flags\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"timerfd_create\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    int clockid;\n    int flags = 0;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    clockid = PyLong_AsInt(args[0]);\n    if (clockid == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    flags = PyLong_AsInt(args[1]);\n    if (flags == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_timerfd_create_impl(module, clockid, flags);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_TIMERFD_CREATE) */\n\n#if defined(HAVE_TIMERFD_CREATE)\n\nPyDoc_STRVAR(os_timerfd_settime__doc__,\n\"timerfd_settime($module, fd, /, *, flags=0, initial=0.0, interval=0.0)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Alter a timer file descriptor\\'s internal timer in seconds.\\n\"\n\"\\n\"\n\"  fd\\n\"\n\"    A timer file descriptor.\\n\"\n\"  flags\\n\"\n\"    0 or a bit mask of TFD_TIMER_ABSTIME or TFD_TIMER_CANCEL_ON_SET.\\n\"\n\"  initial\\n\"\n\"    The initial expiration time, in seconds.\\n\"\n\"  interval\\n\"\n\"    The timer\\'s interval, in seconds.\");\n\n#define OS_TIMERFD_SETTIME_METHODDEF    \\\n    {\"timerfd_settime\", _PyCFunction_CAST(os_timerfd_settime), METH_FASTCALL|METH_KEYWORDS, os_timerfd_settime__doc__},\n\nstatic PyObject *\nos_timerfd_settime_impl(PyObject *module, int fd, int flags,\n                        double initial_double, double interval_double);\n\nstatic PyObject *\nos_timerfd_settime(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(flags), &_Py_ID(initial), &_Py_ID(interval), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"\", \"flags\", \"initial\", \"interval\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"timerfd_settime\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[4];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    int fd;\n    int flags = 0;\n    double initial_double = 0.0;\n    double interval_double = 0.0;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyObject_AsFileDescriptor(args[0]);\n    if (fd < 0) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (args[1]) {\n        flags = PyLong_AsInt(args[1]);\n        if (flags == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[2]) {\n        if (PyFloat_CheckExact(args[2])) {\n            initial_double = PyFloat_AS_DOUBLE(args[2]);\n        }\n        else\n        {\n            initial_double = PyFloat_AsDouble(args[2]);\n            if (initial_double == -1.0 && PyErr_Occurred()) {\n                goto exit;\n            }\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (PyFloat_CheckExact(args[3])) {\n        interval_double = PyFloat_AS_DOUBLE(args[3]);\n    }\n    else\n    {\n        interval_double = PyFloat_AsDouble(args[3]);\n        if (interval_double == -1.0 && PyErr_Occurred()) {\n            goto exit;\n        }\n    }\nskip_optional_kwonly:\n    return_value = os_timerfd_settime_impl(module, fd, flags, initial_double, interval_double);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_TIMERFD_CREATE) */\n\n#if defined(HAVE_TIMERFD_CREATE)\n\nPyDoc_STRVAR(os_timerfd_settime_ns__doc__,\n\"timerfd_settime_ns($module, fd, /, *, flags=0, initial=0, interval=0)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Alter a timer file descriptor\\'s internal timer in nanoseconds.\\n\"\n\"\\n\"\n\"  fd\\n\"\n\"    A timer file descriptor.\\n\"\n\"  flags\\n\"\n\"    0 or a bit mask of TFD_TIMER_ABSTIME or TFD_TIMER_CANCEL_ON_SET.\\n\"\n\"  initial\\n\"\n\"    initial expiration timing in seconds.\\n\"\n\"  interval\\n\"\n\"    interval for the timer in seconds.\");\n\n#define OS_TIMERFD_SETTIME_NS_METHODDEF    \\\n    {\"timerfd_settime_ns\", _PyCFunction_CAST(os_timerfd_settime_ns), METH_FASTCALL|METH_KEYWORDS, os_timerfd_settime_ns__doc__},\n\nstatic PyObject *\nos_timerfd_settime_ns_impl(PyObject *module, int fd, int flags,\n                           long long initial, long long interval);\n\nstatic PyObject *\nos_timerfd_settime_ns(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(flags), &_Py_ID(initial), &_Py_ID(interval), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"\", \"flags\", \"initial\", \"interval\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"timerfd_settime_ns\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[4];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    int fd;\n    int flags = 0;\n    long long initial = 0;\n    long long interval = 0;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyObject_AsFileDescriptor(args[0]);\n    if (fd < 0) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (args[1]) {\n        flags = PyLong_AsInt(args[1]);\n        if (flags == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    if (args[2]) {\n        initial = PyLong_AsLongLong(args[2]);\n        if (initial == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_kwonly;\n        }\n    }\n    interval = PyLong_AsLongLong(args[3]);\n    if (interval == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_timerfd_settime_ns_impl(module, fd, flags, initial, interval);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_TIMERFD_CREATE) */\n\n#if defined(HAVE_TIMERFD_CREATE)\n\nPyDoc_STRVAR(os_timerfd_gettime__doc__,\n\"timerfd_gettime($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a tuple of a timer file descriptor\\'s (interval, next expiration) in float seconds.\\n\"\n\"\\n\"\n\"  fd\\n\"\n\"    A timer file descriptor.\");\n\n#define OS_TIMERFD_GETTIME_METHODDEF    \\\n    {\"timerfd_gettime\", (PyCFunction)os_timerfd_gettime, METH_O, os_timerfd_gettime__doc__},\n\nstatic PyObject *\nos_timerfd_gettime_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_timerfd_gettime(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n\n    fd = PyObject_AsFileDescriptor(arg);\n    if (fd < 0) {\n        goto exit;\n    }\n    return_value = os_timerfd_gettime_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_TIMERFD_CREATE) */\n\n#if defined(HAVE_TIMERFD_CREATE)\n\nPyDoc_STRVAR(os_timerfd_gettime_ns__doc__,\n\"timerfd_gettime_ns($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a tuple of a timer file descriptor\\'s (interval, next expiration) in nanoseconds.\\n\"\n\"\\n\"\n\"  fd\\n\"\n\"    A timer file descriptor.\");\n\n#define OS_TIMERFD_GETTIME_NS_METHODDEF    \\\n    {\"timerfd_gettime_ns\", (PyCFunction)os_timerfd_gettime_ns, METH_O, os_timerfd_gettime_ns__doc__},\n\nstatic PyObject *\nos_timerfd_gettime_ns_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_timerfd_gettime_ns(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n\n    fd = PyObject_AsFileDescriptor(arg);\n    if (fd < 0) {\n        goto exit;\n    }\n    return_value = os_timerfd_gettime_ns_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_TIMERFD_CREATE) */\n\n#if defined(HAVE_GETSID)\n\nPyDoc_STRVAR(os_getsid__doc__,\n\"getsid($module, pid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Call the system call getsid(pid) and return the result.\");\n\n#define OS_GETSID_METHODDEF    \\\n    {\"getsid\", (PyCFunction)os_getsid, METH_O, os_getsid__doc__},\n\nstatic PyObject *\nos_getsid_impl(PyObject *module, pid_t pid);\n\nstatic PyObject *\nos_getsid(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    pid_t pid;\n\n    if (!PyArg_Parse(arg, \"\" _Py_PARSE_PID \":getsid\", &pid)) {\n        goto exit;\n    }\n    return_value = os_getsid_impl(module, pid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_GETSID) */\n\n#if defined(HAVE_SETSID)\n\nPyDoc_STRVAR(os_setsid__doc__,\n\"setsid($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Call the system call setsid().\");\n\n#define OS_SETSID_METHODDEF    \\\n    {\"setsid\", (PyCFunction)os_setsid, METH_NOARGS, os_setsid__doc__},\n\nstatic PyObject *\nos_setsid_impl(PyObject *module);\n\nstatic PyObject *\nos_setsid(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_setsid_impl(module);\n}\n\n#endif /* defined(HAVE_SETSID) */\n\n#if defined(HAVE_SETPGID)\n\nPyDoc_STRVAR(os_setpgid__doc__,\n\"setpgid($module, pid, pgrp, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Call the system call setpgid(pid, pgrp).\");\n\n#define OS_SETPGID_METHODDEF    \\\n    {\"setpgid\", _PyCFunction_CAST(os_setpgid), METH_FASTCALL, os_setpgid__doc__},\n\nstatic PyObject *\nos_setpgid_impl(PyObject *module, pid_t pid, pid_t pgrp);\n\nstatic PyObject *\nos_setpgid(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    pid_t pid;\n    pid_t pgrp;\n\n    if (!_PyArg_ParseStack(args, nargs, \"\" _Py_PARSE_PID \"\" _Py_PARSE_PID \":setpgid\",\n        &pid, &pgrp)) {\n        goto exit;\n    }\n    return_value = os_setpgid_impl(module, pid, pgrp);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SETPGID) */\n\n#if defined(HAVE_TCGETPGRP)\n\nPyDoc_STRVAR(os_tcgetpgrp__doc__,\n\"tcgetpgrp($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the process group associated with the terminal specified by fd.\");\n\n#define OS_TCGETPGRP_METHODDEF    \\\n    {\"tcgetpgrp\", (PyCFunction)os_tcgetpgrp, METH_O, os_tcgetpgrp__doc__},\n\nstatic PyObject *\nos_tcgetpgrp_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_tcgetpgrp(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n\n    fd = PyLong_AsInt(arg);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_tcgetpgrp_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_TCGETPGRP) */\n\n#if defined(HAVE_TCSETPGRP)\n\nPyDoc_STRVAR(os_tcsetpgrp__doc__,\n\"tcsetpgrp($module, fd, pgid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the process group associated with the terminal specified by fd.\");\n\n#define OS_TCSETPGRP_METHODDEF    \\\n    {\"tcsetpgrp\", _PyCFunction_CAST(os_tcsetpgrp), METH_FASTCALL, os_tcsetpgrp__doc__},\n\nstatic PyObject *\nos_tcsetpgrp_impl(PyObject *module, int fd, pid_t pgid);\n\nstatic PyObject *\nos_tcsetpgrp(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    pid_t pgid;\n\n    if (!_PyArg_ParseStack(args, nargs, \"i\" _Py_PARSE_PID \":tcsetpgrp\",\n        &fd, &pgid)) {\n        goto exit;\n    }\n    return_value = os_tcsetpgrp_impl(module, fd, pgid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_TCSETPGRP) */\n\nPyDoc_STRVAR(os_open__doc__,\n\"open($module, /, path, flags, mode=511, *, dir_fd=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Open a file for low level IO.  Returns a file descriptor (integer).\\n\"\n\"\\n\"\n\"If dir_fd is not None, it should be a file descriptor open to a directory,\\n\"\n\"  and path should be relative; path will then be relative to that directory.\\n\"\n\"dir_fd may not be implemented on your platform.\\n\"\n\"  If it is unavailable, using it will raise a NotImplementedError.\");\n\n#define OS_OPEN_METHODDEF    \\\n    {\"open\", _PyCFunction_CAST(os_open), METH_FASTCALL|METH_KEYWORDS, os_open__doc__},\n\nstatic int\nos_open_impl(PyObject *module, path_t *path, int flags, int mode, int dir_fd);\n\nstatic PyObject *\nos_open(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 4\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(flags), &_Py_ID(mode), &_Py_ID(dir_fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"flags\", \"mode\", \"dir_fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"open\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[4];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;\n    path_t path = PATH_T_INITIALIZE_P(\"open\", \"path\", 0, 0, 0, 0);\n    int flags;\n    int mode = 511;\n    int dir_fd = DEFAULT_DIR_FD;\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 3, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    flags = PyLong_AsInt(args[1]);\n    if (flags == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[2]) {\n        mode = PyLong_AsInt(args[2]);\n        if (mode == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\nskip_optional_pos:\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (!OPENAT_DIR_FD_CONVERTER(args[3], &dir_fd)) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    _return_value = os_open_impl(module, &path, flags, mode, dir_fd);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong((long)_return_value);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\nPyDoc_STRVAR(os_close__doc__,\n\"close($module, /, fd)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Close a file descriptor.\");\n\n#define OS_CLOSE_METHODDEF    \\\n    {\"close\", _PyCFunction_CAST(os_close), METH_FASTCALL|METH_KEYWORDS, os_close__doc__},\n\nstatic PyObject *\nos_close_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_close(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"close\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int fd;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_close_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(os_closerange__doc__,\n\"closerange($module, fd_low, fd_high, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Closes all file descriptors in [fd_low, fd_high), ignoring errors.\");\n\n#define OS_CLOSERANGE_METHODDEF    \\\n    {\"closerange\", _PyCFunction_CAST(os_closerange), METH_FASTCALL, os_closerange__doc__},\n\nstatic PyObject *\nos_closerange_impl(PyObject *module, int fd_low, int fd_high);\n\nstatic PyObject *\nos_closerange(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd_low;\n    int fd_high;\n\n    if (!_PyArg_CheckPositional(\"closerange\", nargs, 2, 2)) {\n        goto exit;\n    }\n    fd_low = PyLong_AsInt(args[0]);\n    if (fd_low == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    fd_high = PyLong_AsInt(args[1]);\n    if (fd_high == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_closerange_impl(module, fd_low, fd_high);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(os_dup__doc__,\n\"dup($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a duplicate of a file descriptor.\");\n\n#define OS_DUP_METHODDEF    \\\n    {\"dup\", (PyCFunction)os_dup, METH_O, os_dup__doc__},\n\nstatic int\nos_dup_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_dup(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    int _return_value;\n\n    fd = PyLong_AsInt(arg);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_dup_impl(module, fd);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\n#if ((defined(HAVE_DUP3) || defined(F_DUPFD) || defined(MS_WINDOWS)))\n\nPyDoc_STRVAR(os_dup2__doc__,\n\"dup2($module, /, fd, fd2, inheritable=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Duplicate file descriptor.\");\n\n#define OS_DUP2_METHODDEF    \\\n    {\"dup2\", _PyCFunction_CAST(os_dup2), METH_FASTCALL|METH_KEYWORDS, os_dup2__doc__},\n\nstatic int\nos_dup2_impl(PyObject *module, int fd, int fd2, int inheritable);\n\nstatic PyObject *\nos_dup2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(fd), &_Py_ID(fd2), &_Py_ID(inheritable), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"fd\", \"fd2\", \"inheritable\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"dup2\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[3];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;\n    int fd;\n    int fd2;\n    int inheritable = 1;\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 3, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    fd2 = PyLong_AsInt(args[1]);\n    if (fd2 == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    inheritable = PyObject_IsTrue(args[2]);\n    if (inheritable < 0) {\n        goto exit;\n    }\nskip_optional_pos:\n    _return_value = os_dup2_impl(module, fd, fd2, inheritable);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* ((defined(HAVE_DUP3) || defined(F_DUPFD) || defined(MS_WINDOWS))) */\n\n#if defined(HAVE_LOCKF)\n\nPyDoc_STRVAR(os_lockf__doc__,\n\"lockf($module, fd, command, length, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Apply, test or remove a POSIX lock on an open file descriptor.\\n\"\n\"\\n\"\n\"  fd\\n\"\n\"    An open file descriptor.\\n\"\n\"  command\\n\"\n\"    One of F_LOCK, F_TLOCK, F_ULOCK or F_TEST.\\n\"\n\"  length\\n\"\n\"    The number of bytes to lock, starting at the current position.\");\n\n#define OS_LOCKF_METHODDEF    \\\n    {\"lockf\", _PyCFunction_CAST(os_lockf), METH_FASTCALL, os_lockf__doc__},\n\nstatic PyObject *\nos_lockf_impl(PyObject *module, int fd, int command, Py_off_t length);\n\nstatic PyObject *\nos_lockf(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    int command;\n    Py_off_t length;\n\n    if (!_PyArg_CheckPositional(\"lockf\", nargs, 3, 3)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    command = PyLong_AsInt(args[1]);\n    if (command == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!Py_off_t_converter(args[2], &length)) {\n        goto exit;\n    }\n    return_value = os_lockf_impl(module, fd, command, length);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_LOCKF) */\n\nPyDoc_STRVAR(os_lseek__doc__,\n\"lseek($module, fd, position, whence, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the position of a file descriptor.  Return the new position.\\n\"\n\"\\n\"\n\"  fd\\n\"\n\"    An open file descriptor, as returned by os.open().\\n\"\n\"  position\\n\"\n\"    Position, interpreted relative to \\'whence\\'.\\n\"\n\"  whence\\n\"\n\"    The relative position to seek from. Valid values are:\\n\"\n\"    - SEEK_SET: seek from the start of the file.\\n\"\n\"    - SEEK_CUR: seek from the current file position.\\n\"\n\"    - SEEK_END: seek from the end of the file.\\n\"\n\"\\n\"\n\"The return value is the number of bytes relative to the beginning of the file.\");\n\n#define OS_LSEEK_METHODDEF    \\\n    {\"lseek\", _PyCFunction_CAST(os_lseek), METH_FASTCALL, os_lseek__doc__},\n\nstatic Py_off_t\nos_lseek_impl(PyObject *module, int fd, Py_off_t position, int how);\n\nstatic PyObject *\nos_lseek(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    Py_off_t position;\n    int how;\n    Py_off_t _return_value;\n\n    if (!_PyArg_CheckPositional(\"lseek\", nargs, 3, 3)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!Py_off_t_converter(args[1], &position)) {\n        goto exit;\n    }\n    how = PyLong_AsInt(args[2]);\n    if (how == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_lseek_impl(module, fd, position, how);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromPy_off_t(_return_value);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(os_read__doc__,\n\"read($module, fd, length, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Read from a file descriptor.  Returns a bytes object.\");\n\n#define OS_READ_METHODDEF    \\\n    {\"read\", _PyCFunction_CAST(os_read), METH_FASTCALL, os_read__doc__},\n\nstatic PyObject *\nos_read_impl(PyObject *module, int fd, Py_ssize_t length);\n\nstatic PyObject *\nos_read(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    Py_ssize_t length;\n\n    if (!_PyArg_CheckPositional(\"read\", nargs, 2, 2)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    {\n        Py_ssize_t ival = -1;\n        PyObject *iobj = _PyNumber_Index(args[1]);\n        if (iobj != NULL) {\n            ival = PyLong_AsSsize_t(iobj);\n            Py_DECREF(iobj);\n        }\n        if (ival == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        length = ival;\n    }\n    return_value = os_read_impl(module, fd, length);\n\nexit:\n    return return_value;\n}\n\n#if defined(HAVE_READV)\n\nPyDoc_STRVAR(os_readv__doc__,\n\"readv($module, fd, buffers, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Read from a file descriptor fd into an iterable of buffers.\\n\"\n\"\\n\"\n\"The buffers should be mutable buffers accepting bytes.\\n\"\n\"readv will transfer data into each buffer until it is full\\n\"\n\"and then move on to the next buffer in the sequence to hold\\n\"\n\"the rest of the data.\\n\"\n\"\\n\"\n\"readv returns the total number of bytes read,\\n\"\n\"which may be less than the total capacity of all the buffers.\");\n\n#define OS_READV_METHODDEF    \\\n    {\"readv\", _PyCFunction_CAST(os_readv), METH_FASTCALL, os_readv__doc__},\n\nstatic Py_ssize_t\nos_readv_impl(PyObject *module, int fd, PyObject *buffers);\n\nstatic PyObject *\nos_readv(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    PyObject *buffers;\n    Py_ssize_t _return_value;\n\n    if (!_PyArg_CheckPositional(\"readv\", nargs, 2, 2)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    buffers = args[1];\n    _return_value = os_readv_impl(module, fd, buffers);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromSsize_t(_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_READV) */\n\n#if defined(HAVE_PREAD)\n\nPyDoc_STRVAR(os_pread__doc__,\n\"pread($module, fd, length, offset, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Read a number of bytes from a file descriptor starting at a particular offset.\\n\"\n\"\\n\"\n\"Read length bytes from file descriptor fd, starting at offset bytes from\\n\"\n\"the beginning of the file.  The file offset remains unchanged.\");\n\n#define OS_PREAD_METHODDEF    \\\n    {\"pread\", _PyCFunction_CAST(os_pread), METH_FASTCALL, os_pread__doc__},\n\nstatic PyObject *\nos_pread_impl(PyObject *module, int fd, Py_ssize_t length, Py_off_t offset);\n\nstatic PyObject *\nos_pread(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    Py_ssize_t length;\n    Py_off_t offset;\n\n    if (!_PyArg_CheckPositional(\"pread\", nargs, 3, 3)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    {\n        Py_ssize_t ival = -1;\n        PyObject *iobj = _PyNumber_Index(args[1]);\n        if (iobj != NULL) {\n            ival = PyLong_AsSsize_t(iobj);\n            Py_DECREF(iobj);\n        }\n        if (ival == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        length = ival;\n    }\n    if (!Py_off_t_converter(args[2], &offset)) {\n        goto exit;\n    }\n    return_value = os_pread_impl(module, fd, length, offset);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_PREAD) */\n\n#if (defined(HAVE_PREADV) || defined (HAVE_PREADV2))\n\nPyDoc_STRVAR(os_preadv__doc__,\n\"preadv($module, fd, buffers, offset, flags=0, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Reads from a file descriptor into a number of mutable bytes-like objects.\\n\"\n\"\\n\"\n\"Combines the functionality of readv() and pread(). As readv(), it will\\n\"\n\"transfer data into each buffer until it is full and then move on to the next\\n\"\n\"buffer in the sequence to hold the rest of the data. Its fourth argument,\\n\"\n\"specifies the file offset at which the input operation is to be performed. It\\n\"\n\"will return the total number of bytes read (which can be less than the total\\n\"\n\"capacity of all the objects).\\n\"\n\"\\n\"\n\"The flags argument contains a bitwise OR of zero or more of the following flags:\\n\"\n\"\\n\"\n\"- RWF_HIPRI\\n\"\n\"- RWF_NOWAIT\\n\"\n\"\\n\"\n\"Using non-zero flags requires Linux 4.6 or newer.\");\n\n#define OS_PREADV_METHODDEF    \\\n    {\"preadv\", _PyCFunction_CAST(os_preadv), METH_FASTCALL, os_preadv__doc__},\n\nstatic Py_ssize_t\nos_preadv_impl(PyObject *module, int fd, PyObject *buffers, Py_off_t offset,\n               int flags);\n\nstatic PyObject *\nos_preadv(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    PyObject *buffers;\n    Py_off_t offset;\n    int flags = 0;\n    Py_ssize_t _return_value;\n\n    if (!_PyArg_CheckPositional(\"preadv\", nargs, 3, 4)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    buffers = args[1];\n    if (!Py_off_t_converter(args[2], &offset)) {\n        goto exit;\n    }\n    if (nargs < 4) {\n        goto skip_optional;\n    }\n    flags = PyLong_AsInt(args[3]);\n    if (flags == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional:\n    _return_value = os_preadv_impl(module, fd, buffers, offset, flags);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromSsize_t(_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(HAVE_PREADV) || defined (HAVE_PREADV2)) */\n\nPyDoc_STRVAR(os_write__doc__,\n\"write($module, fd, data, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Write a bytes object to a file descriptor.\");\n\n#define OS_WRITE_METHODDEF    \\\n    {\"write\", _PyCFunction_CAST(os_write), METH_FASTCALL, os_write__doc__},\n\nstatic Py_ssize_t\nos_write_impl(PyObject *module, int fd, Py_buffer *data);\n\nstatic PyObject *\nos_write(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    Py_buffer data = {NULL, NULL};\n    Py_ssize_t _return_value;\n\n    if (!_PyArg_CheckPositional(\"write\", nargs, 2, 2)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (PyObject_GetBuffer(args[1], &data, PyBUF_SIMPLE) != 0) {\n        goto exit;\n    }\n    _return_value = os_write_impl(module, fd, &data);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromSsize_t(_return_value);\n\nexit:\n    /* Cleanup for data */\n    if (data.obj) {\n       PyBuffer_Release(&data);\n    }\n\n    return return_value;\n}\n\n#if defined(HAVE_SENDFILE) && defined(__APPLE__)\n\nPyDoc_STRVAR(os_sendfile__doc__,\n\"sendfile($module, /, out_fd, in_fd, offset, count, headers=(),\\n\"\n\"         trailers=(), flags=0)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Copy count bytes from file descriptor in_fd to file descriptor out_fd.\");\n\n#define OS_SENDFILE_METHODDEF    \\\n    {\"sendfile\", _PyCFunction_CAST(os_sendfile), METH_FASTCALL|METH_KEYWORDS, os_sendfile__doc__},\n\nstatic PyObject *\nos_sendfile_impl(PyObject *module, int out_fd, int in_fd, Py_off_t offset,\n                 Py_off_t sbytes, PyObject *headers, PyObject *trailers,\n                 int flags);\n\nstatic PyObject *\nos_sendfile(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 7\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(out_fd), &_Py_ID(in_fd), &_Py_ID(offset), &_Py_ID(count), &_Py_ID(headers), &_Py_ID(trailers), &_Py_ID(flags), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"out_fd\", \"in_fd\", \"offset\", \"count\", \"headers\", \"trailers\", \"flags\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"sendfile\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[7];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 4;\n    int out_fd;\n    int in_fd;\n    Py_off_t offset;\n    Py_off_t sbytes;\n    PyObject *headers = NULL;\n    PyObject *trailers = NULL;\n    int flags = 0;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 4, 7, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    out_fd = PyLong_AsInt(args[0]);\n    if (out_fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    in_fd = PyLong_AsInt(args[1]);\n    if (in_fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!Py_off_t_converter(args[2], &offset)) {\n        goto exit;\n    }\n    if (!Py_off_t_converter(args[3], &sbytes)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[4]) {\n        headers = args[4];\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\n    if (args[5]) {\n        trailers = args[5];\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\n    flags = PyLong_AsInt(args[6]);\n    if (flags == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional_pos:\n    return_value = os_sendfile_impl(module, out_fd, in_fd, offset, sbytes, headers, trailers, flags);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SENDFILE) && defined(__APPLE__) */\n\n#if defined(HAVE_SENDFILE) && !defined(__APPLE__) && (defined(__FreeBSD__) || defined(__DragonFly__))\n\nPyDoc_STRVAR(os_sendfile__doc__,\n\"sendfile($module, /, out_fd, in_fd, offset, count, headers=(),\\n\"\n\"         trailers=(), flags=0)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Copy count bytes from file descriptor in_fd to file descriptor out_fd.\");\n\n#define OS_SENDFILE_METHODDEF    \\\n    {\"sendfile\", _PyCFunction_CAST(os_sendfile), METH_FASTCALL|METH_KEYWORDS, os_sendfile__doc__},\n\nstatic PyObject *\nos_sendfile_impl(PyObject *module, int out_fd, int in_fd, Py_off_t offset,\n                 Py_ssize_t count, PyObject *headers, PyObject *trailers,\n                 int flags);\n\nstatic PyObject *\nos_sendfile(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 7\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(out_fd), &_Py_ID(in_fd), &_Py_ID(offset), &_Py_ID(count), &_Py_ID(headers), &_Py_ID(trailers), &_Py_ID(flags), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"out_fd\", \"in_fd\", \"offset\", \"count\", \"headers\", \"trailers\", \"flags\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"sendfile\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[7];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 4;\n    int out_fd;\n    int in_fd;\n    Py_off_t offset;\n    Py_ssize_t count;\n    PyObject *headers = NULL;\n    PyObject *trailers = NULL;\n    int flags = 0;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 4, 7, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    out_fd = PyLong_AsInt(args[0]);\n    if (out_fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    in_fd = PyLong_AsInt(args[1]);\n    if (in_fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!Py_off_t_converter(args[2], &offset)) {\n        goto exit;\n    }\n    {\n        Py_ssize_t ival = -1;\n        PyObject *iobj = _PyNumber_Index(args[3]);\n        if (iobj != NULL) {\n            ival = PyLong_AsSsize_t(iobj);\n            Py_DECREF(iobj);\n        }\n        if (ival == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        count = ival;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[4]) {\n        headers = args[4];\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\n    if (args[5]) {\n        trailers = args[5];\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\n    flags = PyLong_AsInt(args[6]);\n    if (flags == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional_pos:\n    return_value = os_sendfile_impl(module, out_fd, in_fd, offset, count, headers, trailers, flags);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SENDFILE) && !defined(__APPLE__) && (defined(__FreeBSD__) || defined(__DragonFly__)) */\n\n#if defined(HAVE_SENDFILE) && !defined(__APPLE__) && !(defined(__FreeBSD__) || defined(__DragonFly__))\n\nPyDoc_STRVAR(os_sendfile__doc__,\n\"sendfile($module, /, out_fd, in_fd, offset, count)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Copy count bytes from file descriptor in_fd to file descriptor out_fd.\");\n\n#define OS_SENDFILE_METHODDEF    \\\n    {\"sendfile\", _PyCFunction_CAST(os_sendfile), METH_FASTCALL|METH_KEYWORDS, os_sendfile__doc__},\n\nstatic PyObject *\nos_sendfile_impl(PyObject *module, int out_fd, int in_fd, PyObject *offobj,\n                 Py_ssize_t count);\n\nstatic PyObject *\nos_sendfile(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 4\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(out_fd), &_Py_ID(in_fd), &_Py_ID(offset), &_Py_ID(count), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"out_fd\", \"in_fd\", \"offset\", \"count\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"sendfile\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[4];\n    int out_fd;\n    int in_fd;\n    PyObject *offobj;\n    Py_ssize_t count;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 4, 4, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    out_fd = PyLong_AsInt(args[0]);\n    if (out_fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    in_fd = PyLong_AsInt(args[1]);\n    if (in_fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    offobj = args[2];\n    {\n        Py_ssize_t ival = -1;\n        PyObject *iobj = _PyNumber_Index(args[3]);\n        if (iobj != NULL) {\n            ival = PyLong_AsSsize_t(iobj);\n            Py_DECREF(iobj);\n        }\n        if (ival == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        count = ival;\n    }\n    return_value = os_sendfile_impl(module, out_fd, in_fd, offobj, count);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SENDFILE) && !defined(__APPLE__) && !(defined(__FreeBSD__) || defined(__DragonFly__)) */\n\n#if defined(__APPLE__)\n\nPyDoc_STRVAR(os__fcopyfile__doc__,\n\"_fcopyfile($module, in_fd, out_fd, flags, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Efficiently copy content or metadata of 2 regular file descriptors (macOS).\");\n\n#define OS__FCOPYFILE_METHODDEF    \\\n    {\"_fcopyfile\", _PyCFunction_CAST(os__fcopyfile), METH_FASTCALL, os__fcopyfile__doc__},\n\nstatic PyObject *\nos__fcopyfile_impl(PyObject *module, int in_fd, int out_fd, int flags);\n\nstatic PyObject *\nos__fcopyfile(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int in_fd;\n    int out_fd;\n    int flags;\n\n    if (!_PyArg_CheckPositional(\"_fcopyfile\", nargs, 3, 3)) {\n        goto exit;\n    }\n    in_fd = PyLong_AsInt(args[0]);\n    if (in_fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    out_fd = PyLong_AsInt(args[1]);\n    if (out_fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    flags = PyLong_AsInt(args[2]);\n    if (flags == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os__fcopyfile_impl(module, in_fd, out_fd, flags);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(__APPLE__) */\n\nPyDoc_STRVAR(os_fstat__doc__,\n\"fstat($module, /, fd)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Perform a stat system call on the given file descriptor.\\n\"\n\"\\n\"\n\"Like stat(), but for an open file descriptor.\\n\"\n\"Equivalent to os.stat(fd).\");\n\n#define OS_FSTAT_METHODDEF    \\\n    {\"fstat\", _PyCFunction_CAST(os_fstat), METH_FASTCALL|METH_KEYWORDS, os_fstat__doc__},\n\nstatic PyObject *\nos_fstat_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_fstat(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"fstat\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int fd;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_fstat_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(os_isatty__doc__,\n\"isatty($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the fd is connected to a terminal.\\n\"\n\"\\n\"\n\"Return True if the file descriptor is an open file descriptor\\n\"\n\"connected to the slave end of a terminal.\");\n\n#define OS_ISATTY_METHODDEF    \\\n    {\"isatty\", (PyCFunction)os_isatty, METH_O, os_isatty__doc__},\n\nstatic int\nos_isatty_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_isatty(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    int _return_value;\n\n    fd = PyLong_AsInt(arg);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_isatty_impl(module, fd);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\n#if defined(HAVE_PIPE)\n\nPyDoc_STRVAR(os_pipe__doc__,\n\"pipe($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Create a pipe.\\n\"\n\"\\n\"\n\"Returns a tuple of two file descriptors:\\n\"\n\"  (read_fd, write_fd)\");\n\n#define OS_PIPE_METHODDEF    \\\n    {\"pipe\", (PyCFunction)os_pipe, METH_NOARGS, os_pipe__doc__},\n\nstatic PyObject *\nos_pipe_impl(PyObject *module);\n\nstatic PyObject *\nos_pipe(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_pipe_impl(module);\n}\n\n#endif /* defined(HAVE_PIPE) */\n\n#if defined(HAVE_PIPE2)\n\nPyDoc_STRVAR(os_pipe2__doc__,\n\"pipe2($module, flags, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Create a pipe with flags set atomically.\\n\"\n\"\\n\"\n\"Returns a tuple of two file descriptors:\\n\"\n\"  (read_fd, write_fd)\\n\"\n\"\\n\"\n\"flags can be constructed by ORing together one or more of these values:\\n\"\n\"O_NONBLOCK, O_CLOEXEC.\");\n\n#define OS_PIPE2_METHODDEF    \\\n    {\"pipe2\", (PyCFunction)os_pipe2, METH_O, os_pipe2__doc__},\n\nstatic PyObject *\nos_pipe2_impl(PyObject *module, int flags);\n\nstatic PyObject *\nos_pipe2(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int flags;\n\n    flags = PyLong_AsInt(arg);\n    if (flags == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_pipe2_impl(module, flags);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_PIPE2) */\n\n#if defined(HAVE_WRITEV)\n\nPyDoc_STRVAR(os_writev__doc__,\n\"writev($module, fd, buffers, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Iterate over buffers, and write the contents of each to a file descriptor.\\n\"\n\"\\n\"\n\"Returns the total number of bytes written.\\n\"\n\"buffers must be a sequence of bytes-like objects.\");\n\n#define OS_WRITEV_METHODDEF    \\\n    {\"writev\", _PyCFunction_CAST(os_writev), METH_FASTCALL, os_writev__doc__},\n\nstatic Py_ssize_t\nos_writev_impl(PyObject *module, int fd, PyObject *buffers);\n\nstatic PyObject *\nos_writev(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    PyObject *buffers;\n    Py_ssize_t _return_value;\n\n    if (!_PyArg_CheckPositional(\"writev\", nargs, 2, 2)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    buffers = args[1];\n    _return_value = os_writev_impl(module, fd, buffers);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromSsize_t(_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_WRITEV) */\n\n#if defined(HAVE_PWRITE)\n\nPyDoc_STRVAR(os_pwrite__doc__,\n\"pwrite($module, fd, buffer, offset, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Write bytes to a file descriptor starting at a particular offset.\\n\"\n\"\\n\"\n\"Write buffer to fd, starting at offset bytes from the beginning of\\n\"\n\"the file.  Returns the number of bytes written.  Does not change the\\n\"\n\"current file offset.\");\n\n#define OS_PWRITE_METHODDEF    \\\n    {\"pwrite\", _PyCFunction_CAST(os_pwrite), METH_FASTCALL, os_pwrite__doc__},\n\nstatic Py_ssize_t\nos_pwrite_impl(PyObject *module, int fd, Py_buffer *buffer, Py_off_t offset);\n\nstatic PyObject *\nos_pwrite(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    Py_buffer buffer = {NULL, NULL};\n    Py_off_t offset;\n    Py_ssize_t _return_value;\n\n    if (!_PyArg_CheckPositional(\"pwrite\", nargs, 3, 3)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (PyObject_GetBuffer(args[1], &buffer, PyBUF_SIMPLE) != 0) {\n        goto exit;\n    }\n    if (!Py_off_t_converter(args[2], &offset)) {\n        goto exit;\n    }\n    _return_value = os_pwrite_impl(module, fd, &buffer, offset);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromSsize_t(_return_value);\n\nexit:\n    /* Cleanup for buffer */\n    if (buffer.obj) {\n       PyBuffer_Release(&buffer);\n    }\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_PWRITE) */\n\n#if (defined(HAVE_PWRITEV) || defined (HAVE_PWRITEV2))\n\nPyDoc_STRVAR(os_pwritev__doc__,\n\"pwritev($module, fd, buffers, offset, flags=0, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Writes the contents of bytes-like objects to a file descriptor at a given offset.\\n\"\n\"\\n\"\n\"Combines the functionality of writev() and pwrite(). All buffers must be a sequence\\n\"\n\"of bytes-like objects. Buffers are processed in array order. Entire contents of first\\n\"\n\"buffer is written before proceeding to second, and so on. The operating system may\\n\"\n\"set a limit (sysconf() value SC_IOV_MAX) on the number of buffers that can be used.\\n\"\n\"This function writes the contents of each object to the file descriptor and returns\\n\"\n\"the total number of bytes written.\\n\"\n\"\\n\"\n\"The flags argument contains a bitwise OR of zero or more of the following flags:\\n\"\n\"\\n\"\n\"- RWF_DSYNC\\n\"\n\"- RWF_SYNC\\n\"\n\"- RWF_APPEND\\n\"\n\"\\n\"\n\"Using non-zero flags requires Linux 4.7 or newer.\");\n\n#define OS_PWRITEV_METHODDEF    \\\n    {\"pwritev\", _PyCFunction_CAST(os_pwritev), METH_FASTCALL, os_pwritev__doc__},\n\nstatic Py_ssize_t\nos_pwritev_impl(PyObject *module, int fd, PyObject *buffers, Py_off_t offset,\n                int flags);\n\nstatic PyObject *\nos_pwritev(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    PyObject *buffers;\n    Py_off_t offset;\n    int flags = 0;\n    Py_ssize_t _return_value;\n\n    if (!_PyArg_CheckPositional(\"pwritev\", nargs, 3, 4)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    buffers = args[1];\n    if (!Py_off_t_converter(args[2], &offset)) {\n        goto exit;\n    }\n    if (nargs < 4) {\n        goto skip_optional;\n    }\n    flags = PyLong_AsInt(args[3]);\n    if (flags == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional:\n    _return_value = os_pwritev_impl(module, fd, buffers, offset, flags);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromSsize_t(_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(HAVE_PWRITEV) || defined (HAVE_PWRITEV2)) */\n\n#if defined(HAVE_COPY_FILE_RANGE)\n\nPyDoc_STRVAR(os_copy_file_range__doc__,\n\"copy_file_range($module, /, src, dst, count, offset_src=None,\\n\"\n\"                offset_dst=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Copy count bytes from one file descriptor to another.\\n\"\n\"\\n\"\n\"  src\\n\"\n\"    Source file descriptor.\\n\"\n\"  dst\\n\"\n\"    Destination file descriptor.\\n\"\n\"  count\\n\"\n\"    Number of bytes to copy.\\n\"\n\"  offset_src\\n\"\n\"    Starting offset in src.\\n\"\n\"  offset_dst\\n\"\n\"    Starting offset in dst.\\n\"\n\"\\n\"\n\"If offset_src is None, then src is read from the current position;\\n\"\n\"respectively for offset_dst.\");\n\n#define OS_COPY_FILE_RANGE_METHODDEF    \\\n    {\"copy_file_range\", _PyCFunction_CAST(os_copy_file_range), METH_FASTCALL|METH_KEYWORDS, os_copy_file_range__doc__},\n\nstatic PyObject *\nos_copy_file_range_impl(PyObject *module, int src, int dst, Py_ssize_t count,\n                        PyObject *offset_src, PyObject *offset_dst);\n\nstatic PyObject *\nos_copy_file_range(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 5\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(src), &_Py_ID(dst), &_Py_ID(count), &_Py_ID(offset_src), &_Py_ID(offset_dst), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"src\", \"dst\", \"count\", \"offset_src\", \"offset_dst\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"copy_file_range\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[5];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;\n    int src;\n    int dst;\n    Py_ssize_t count;\n    PyObject *offset_src = Py_None;\n    PyObject *offset_dst = Py_None;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 3, 5, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    src = PyLong_AsInt(args[0]);\n    if (src == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    dst = PyLong_AsInt(args[1]);\n    if (dst == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    {\n        Py_ssize_t ival = -1;\n        PyObject *iobj = _PyNumber_Index(args[2]);\n        if (iobj != NULL) {\n            ival = PyLong_AsSsize_t(iobj);\n            Py_DECREF(iobj);\n        }\n        if (ival == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        count = ival;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[3]) {\n        offset_src = args[3];\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\n    offset_dst = args[4];\nskip_optional_pos:\n    return_value = os_copy_file_range_impl(module, src, dst, count, offset_src, offset_dst);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_COPY_FILE_RANGE) */\n\n#if ((defined(HAVE_SPLICE) && !defined(_AIX)))\n\nPyDoc_STRVAR(os_splice__doc__,\n\"splice($module, /, src, dst, count, offset_src=None, offset_dst=None,\\n\"\n\"       flags=0)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Transfer count bytes from one pipe to a descriptor or vice versa.\\n\"\n\"\\n\"\n\"  src\\n\"\n\"    Source file descriptor.\\n\"\n\"  dst\\n\"\n\"    Destination file descriptor.\\n\"\n\"  count\\n\"\n\"    Number of bytes to copy.\\n\"\n\"  offset_src\\n\"\n\"    Starting offset in src.\\n\"\n\"  offset_dst\\n\"\n\"    Starting offset in dst.\\n\"\n\"  flags\\n\"\n\"    Flags to modify the semantics of the call.\\n\"\n\"\\n\"\n\"If offset_src is None, then src is read from the current position;\\n\"\n\"respectively for offset_dst. The offset associated to the file\\n\"\n\"descriptor that refers to a pipe must be None.\");\n\n#define OS_SPLICE_METHODDEF    \\\n    {\"splice\", _PyCFunction_CAST(os_splice), METH_FASTCALL|METH_KEYWORDS, os_splice__doc__},\n\nstatic PyObject *\nos_splice_impl(PyObject *module, int src, int dst, Py_ssize_t count,\n               PyObject *offset_src, PyObject *offset_dst,\n               unsigned int flags);\n\nstatic PyObject *\nos_splice(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 6\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(src), &_Py_ID(dst), &_Py_ID(count), &_Py_ID(offset_src), &_Py_ID(offset_dst), &_Py_ID(flags), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"src\", \"dst\", \"count\", \"offset_src\", \"offset_dst\", \"flags\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"splice\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[6];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;\n    int src;\n    int dst;\n    Py_ssize_t count;\n    PyObject *offset_src = Py_None;\n    PyObject *offset_dst = Py_None;\n    unsigned int flags = 0;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 3, 6, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    src = PyLong_AsInt(args[0]);\n    if (src == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    dst = PyLong_AsInt(args[1]);\n    if (dst == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    {\n        Py_ssize_t ival = -1;\n        PyObject *iobj = _PyNumber_Index(args[2]);\n        if (iobj != NULL) {\n            ival = PyLong_AsSsize_t(iobj);\n            Py_DECREF(iobj);\n        }\n        if (ival == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        count = ival;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[3]) {\n        offset_src = args[3];\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\n    if (args[4]) {\n        offset_dst = args[4];\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\n    if (!_PyLong_UnsignedInt_Converter(args[5], &flags)) {\n        goto exit;\n    }\nskip_optional_pos:\n    return_value = os_splice_impl(module, src, dst, count, offset_src, offset_dst, flags);\n\nexit:\n    return return_value;\n}\n\n#endif /* ((defined(HAVE_SPLICE) && !defined(_AIX))) */\n\n#if defined(HAVE_MKFIFO)\n\nPyDoc_STRVAR(os_mkfifo__doc__,\n\"mkfifo($module, /, path, mode=438, *, dir_fd=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Create a \\\"fifo\\\" (a POSIX named pipe).\\n\"\n\"\\n\"\n\"If dir_fd is not None, it should be a file descriptor open to a directory,\\n\"\n\"  and path should be relative; path will then be relative to that directory.\\n\"\n\"dir_fd may not be implemented on your platform.\\n\"\n\"  If it is unavailable, using it will raise a NotImplementedError.\");\n\n#define OS_MKFIFO_METHODDEF    \\\n    {\"mkfifo\", _PyCFunction_CAST(os_mkfifo), METH_FASTCALL|METH_KEYWORDS, os_mkfifo__doc__},\n\nstatic PyObject *\nos_mkfifo_impl(PyObject *module, path_t *path, int mode, int dir_fd);\n\nstatic PyObject *\nos_mkfifo(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(mode), &_Py_ID(dir_fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"mode\", \"dir_fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"mkfifo\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[3];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    path_t path = PATH_T_INITIALIZE_P(\"mkfifo\", \"path\", 0, 0, 0, 0);\n    int mode = 438;\n    int dir_fd = DEFAULT_DIR_FD;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[1]) {\n        mode = PyLong_AsInt(args[1]);\n        if (mode == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\nskip_optional_pos:\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (!MKFIFOAT_DIR_FD_CONVERTER(args[2], &dir_fd)) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_mkfifo_impl(module, &path, mode, dir_fd);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_MKFIFO) */\n\n#if (defined(HAVE_MKNOD) && defined(HAVE_MAKEDEV))\n\nPyDoc_STRVAR(os_mknod__doc__,\n\"mknod($module, /, path, mode=384, device=0, *, dir_fd=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Create a node in the file system.\\n\"\n\"\\n\"\n\"Create a node in the file system (file, device special file or named pipe)\\n\"\n\"at path.  mode specifies both the permissions to use and the\\n\"\n\"type of node to be created, being combined (bitwise OR) with one of\\n\"\n\"S_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO.  If S_IFCHR or S_IFBLK is set on mode,\\n\"\n\"device defines the newly created device special file (probably using\\n\"\n\"os.makedev()).  Otherwise device is ignored.\\n\"\n\"\\n\"\n\"If dir_fd is not None, it should be a file descriptor open to a directory,\\n\"\n\"  and path should be relative; path will then be relative to that directory.\\n\"\n\"dir_fd may not be implemented on your platform.\\n\"\n\"  If it is unavailable, using it will raise a NotImplementedError.\");\n\n#define OS_MKNOD_METHODDEF    \\\n    {\"mknod\", _PyCFunction_CAST(os_mknod), METH_FASTCALL|METH_KEYWORDS, os_mknod__doc__},\n\nstatic PyObject *\nos_mknod_impl(PyObject *module, path_t *path, int mode, dev_t device,\n              int dir_fd);\n\nstatic PyObject *\nos_mknod(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 4\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(mode), &_Py_ID(device), &_Py_ID(dir_fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"mode\", \"device\", \"dir_fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"mknod\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[4];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    path_t path = PATH_T_INITIALIZE_P(\"mknod\", \"path\", 0, 0, 0, 0);\n    int mode = 384;\n    dev_t device = 0;\n    int dir_fd = DEFAULT_DIR_FD;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 3, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[1]) {\n        mode = PyLong_AsInt(args[1]);\n        if (mode == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\n    if (args[2]) {\n        if (!_Py_Dev_Converter(args[2], &device)) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\nskip_optional_pos:\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    if (!MKNODAT_DIR_FD_CONVERTER(args[3], &dir_fd)) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_mknod_impl(module, &path, mode, device, dir_fd);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* (defined(HAVE_MKNOD) && defined(HAVE_MAKEDEV)) */\n\n#if defined(HAVE_DEVICE_MACROS)\n\nPyDoc_STRVAR(os_major__doc__,\n\"major($module, device, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Extracts a device major number from a raw device number.\");\n\n#define OS_MAJOR_METHODDEF    \\\n    {\"major\", (PyCFunction)os_major, METH_O, os_major__doc__},\n\nstatic PyObject *\nos_major_impl(PyObject *module, dev_t device);\n\nstatic PyObject *\nos_major(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    dev_t device;\n\n    if (!_Py_Dev_Converter(arg, &device)) {\n        goto exit;\n    }\n    return_value = os_major_impl(module, device);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_DEVICE_MACROS) */\n\n#if defined(HAVE_DEVICE_MACROS)\n\nPyDoc_STRVAR(os_minor__doc__,\n\"minor($module, device, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Extracts a device minor number from a raw device number.\");\n\n#define OS_MINOR_METHODDEF    \\\n    {\"minor\", (PyCFunction)os_minor, METH_O, os_minor__doc__},\n\nstatic PyObject *\nos_minor_impl(PyObject *module, dev_t device);\n\nstatic PyObject *\nos_minor(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    dev_t device;\n\n    if (!_Py_Dev_Converter(arg, &device)) {\n        goto exit;\n    }\n    return_value = os_minor_impl(module, device);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_DEVICE_MACROS) */\n\n#if defined(HAVE_DEVICE_MACROS)\n\nPyDoc_STRVAR(os_makedev__doc__,\n\"makedev($module, major, minor, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Composes a raw device number from the major and minor device numbers.\");\n\n#define OS_MAKEDEV_METHODDEF    \\\n    {\"makedev\", _PyCFunction_CAST(os_makedev), METH_FASTCALL, os_makedev__doc__},\n\nstatic dev_t\nos_makedev_impl(PyObject *module, dev_t major, dev_t minor);\n\nstatic PyObject *\nos_makedev(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    dev_t major;\n    dev_t minor;\n    dev_t _return_value;\n\n    if (!_PyArg_CheckPositional(\"makedev\", nargs, 2, 2)) {\n        goto exit;\n    }\n    if (!_Py_Dev_Converter(args[0], &major)) {\n        goto exit;\n    }\n    if (!_Py_Dev_Converter(args[1], &minor)) {\n        goto exit;\n    }\n    _return_value = os_makedev_impl(module, major, minor);\n    if ((_return_value == (dev_t)-1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = _PyLong_FromDev(_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_DEVICE_MACROS) */\n\n#if (defined HAVE_FTRUNCATE || defined MS_WINDOWS)\n\nPyDoc_STRVAR(os_ftruncate__doc__,\n\"ftruncate($module, fd, length, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Truncate a file, specified by file descriptor, to a specific length.\");\n\n#define OS_FTRUNCATE_METHODDEF    \\\n    {\"ftruncate\", _PyCFunction_CAST(os_ftruncate), METH_FASTCALL, os_ftruncate__doc__},\n\nstatic PyObject *\nos_ftruncate_impl(PyObject *module, int fd, Py_off_t length);\n\nstatic PyObject *\nos_ftruncate(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    Py_off_t length;\n\n    if (!_PyArg_CheckPositional(\"ftruncate\", nargs, 2, 2)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!Py_off_t_converter(args[1], &length)) {\n        goto exit;\n    }\n    return_value = os_ftruncate_impl(module, fd, length);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined HAVE_FTRUNCATE || defined MS_WINDOWS) */\n\n#if (defined HAVE_TRUNCATE || defined MS_WINDOWS)\n\nPyDoc_STRVAR(os_truncate__doc__,\n\"truncate($module, /, path, length)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Truncate a file, specified by path, to a specific length.\\n\"\n\"\\n\"\n\"On some platforms, path may also be specified as an open file descriptor.\\n\"\n\"  If this functionality is unavailable, using it raises an exception.\");\n\n#define OS_TRUNCATE_METHODDEF    \\\n    {\"truncate\", _PyCFunction_CAST(os_truncate), METH_FASTCALL|METH_KEYWORDS, os_truncate__doc__},\n\nstatic PyObject *\nos_truncate_impl(PyObject *module, path_t *path, Py_off_t length);\n\nstatic PyObject *\nos_truncate(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(length), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"length\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"truncate\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    path_t path = PATH_T_INITIALIZE_P(\"truncate\", \"path\", 0, 0, 0, PATH_HAVE_FTRUNCATE);\n    Py_off_t length;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!Py_off_t_converter(args[1], &length)) {\n        goto exit;\n    }\n    return_value = os_truncate_impl(module, &path, length);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* (defined HAVE_TRUNCATE || defined MS_WINDOWS) */\n\n#if (defined(HAVE_POSIX_FALLOCATE) && !defined(POSIX_FADVISE_AIX_BUG) && !defined(__wasi__))\n\nPyDoc_STRVAR(os_posix_fallocate__doc__,\n\"posix_fallocate($module, fd, offset, length, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Ensure a file has allocated at least a particular number of bytes on disk.\\n\"\n\"\\n\"\n\"Ensure that the file specified by fd encompasses a range of bytes\\n\"\n\"starting at offset bytes from the beginning and continuing for length bytes.\");\n\n#define OS_POSIX_FALLOCATE_METHODDEF    \\\n    {\"posix_fallocate\", _PyCFunction_CAST(os_posix_fallocate), METH_FASTCALL, os_posix_fallocate__doc__},\n\nstatic PyObject *\nos_posix_fallocate_impl(PyObject *module, int fd, Py_off_t offset,\n                        Py_off_t length);\n\nstatic PyObject *\nos_posix_fallocate(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    Py_off_t offset;\n    Py_off_t length;\n\n    if (!_PyArg_CheckPositional(\"posix_fallocate\", nargs, 3, 3)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!Py_off_t_converter(args[1], &offset)) {\n        goto exit;\n    }\n    if (!Py_off_t_converter(args[2], &length)) {\n        goto exit;\n    }\n    return_value = os_posix_fallocate_impl(module, fd, offset, length);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(HAVE_POSIX_FALLOCATE) && !defined(POSIX_FADVISE_AIX_BUG) && !defined(__wasi__)) */\n\n#if (defined(HAVE_POSIX_FADVISE) && !defined(POSIX_FADVISE_AIX_BUG))\n\nPyDoc_STRVAR(os_posix_fadvise__doc__,\n\"posix_fadvise($module, fd, offset, length, advice, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Announce an intention to access data in a specific pattern.\\n\"\n\"\\n\"\n\"Announce an intention to access data in a specific pattern, thus allowing\\n\"\n\"the kernel to make optimizations.\\n\"\n\"The advice applies to the region of the file specified by fd starting at\\n\"\n\"offset and continuing for length bytes.\\n\"\n\"advice is one of POSIX_FADV_NORMAL, POSIX_FADV_SEQUENTIAL,\\n\"\n\"POSIX_FADV_RANDOM, POSIX_FADV_NOREUSE, POSIX_FADV_WILLNEED, or\\n\"\n\"POSIX_FADV_DONTNEED.\");\n\n#define OS_POSIX_FADVISE_METHODDEF    \\\n    {\"posix_fadvise\", _PyCFunction_CAST(os_posix_fadvise), METH_FASTCALL, os_posix_fadvise__doc__},\n\nstatic PyObject *\nos_posix_fadvise_impl(PyObject *module, int fd, Py_off_t offset,\n                      Py_off_t length, int advice);\n\nstatic PyObject *\nos_posix_fadvise(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    Py_off_t offset;\n    Py_off_t length;\n    int advice;\n\n    if (!_PyArg_CheckPositional(\"posix_fadvise\", nargs, 4, 4)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    if (!Py_off_t_converter(args[1], &offset)) {\n        goto exit;\n    }\n    if (!Py_off_t_converter(args[2], &length)) {\n        goto exit;\n    }\n    advice = PyLong_AsInt(args[3]);\n    if (advice == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_posix_fadvise_impl(module, fd, offset, length, advice);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(HAVE_POSIX_FADVISE) && !defined(POSIX_FADVISE_AIX_BUG)) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os_putenv__doc__,\n\"putenv($module, name, value, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Change or add an environment variable.\");\n\n#define OS_PUTENV_METHODDEF    \\\n    {\"putenv\", _PyCFunction_CAST(os_putenv), METH_FASTCALL, os_putenv__doc__},\n\nstatic PyObject *\nos_putenv_impl(PyObject *module, PyObject *name, PyObject *value);\n\nstatic PyObject *\nos_putenv(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    PyObject *name;\n    PyObject *value;\n\n    if (!_PyArg_CheckPositional(\"putenv\", nargs, 2, 2)) {\n        goto exit;\n    }\n    if (!PyUnicode_Check(args[0])) {\n        _PyArg_BadArgument(\"putenv\", \"argument 1\", \"str\", args[0]);\n        goto exit;\n    }\n    name = args[0];\n    if (!PyUnicode_Check(args[1])) {\n        _PyArg_BadArgument(\"putenv\", \"argument 2\", \"str\", args[1]);\n        goto exit;\n    }\n    value = args[1];\n    return_value = os_putenv_impl(module, name, value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if !defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os_putenv__doc__,\n\"putenv($module, name, value, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Change or add an environment variable.\");\n\n#define OS_PUTENV_METHODDEF    \\\n    {\"putenv\", _PyCFunction_CAST(os_putenv), METH_FASTCALL, os_putenv__doc__},\n\nstatic PyObject *\nos_putenv_impl(PyObject *module, PyObject *name, PyObject *value);\n\nstatic PyObject *\nos_putenv(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    PyObject *name = NULL;\n    PyObject *value = NULL;\n\n    if (!_PyArg_CheckPositional(\"putenv\", nargs, 2, 2)) {\n        goto exit;\n    }\n    if (!PyUnicode_FSConverter(args[0], &name)) {\n        goto exit;\n    }\n    if (!PyUnicode_FSConverter(args[1], &value)) {\n        goto exit;\n    }\n    return_value = os_putenv_impl(module, name, value);\n\nexit:\n    /* Cleanup for name */\n    Py_XDECREF(name);\n    /* Cleanup for value */\n    Py_XDECREF(value);\n\n    return return_value;\n}\n\n#endif /* !defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os_unsetenv__doc__,\n\"unsetenv($module, name, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Delete an environment variable.\");\n\n#define OS_UNSETENV_METHODDEF    \\\n    {\"unsetenv\", (PyCFunction)os_unsetenv, METH_O, os_unsetenv__doc__},\n\nstatic PyObject *\nos_unsetenv_impl(PyObject *module, PyObject *name);\n\nstatic PyObject *\nos_unsetenv(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    PyObject *name;\n\n    if (!PyUnicode_Check(arg)) {\n        _PyArg_BadArgument(\"unsetenv\", \"argument\", \"str\", arg);\n        goto exit;\n    }\n    name = arg;\n    return_value = os_unsetenv_impl(module, name);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if !defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os_unsetenv__doc__,\n\"unsetenv($module, name, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Delete an environment variable.\");\n\n#define OS_UNSETENV_METHODDEF    \\\n    {\"unsetenv\", (PyCFunction)os_unsetenv, METH_O, os_unsetenv__doc__},\n\nstatic PyObject *\nos_unsetenv_impl(PyObject *module, PyObject *name);\n\nstatic PyObject *\nos_unsetenv(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    PyObject *name = NULL;\n\n    if (!PyUnicode_FSConverter(arg, &name)) {\n        goto exit;\n    }\n    return_value = os_unsetenv_impl(module, name);\n\nexit:\n    /* Cleanup for name */\n    Py_XDECREF(name);\n\n    return return_value;\n}\n\n#endif /* !defined(MS_WINDOWS) */\n\nPyDoc_STRVAR(os_strerror__doc__,\n\"strerror($module, code, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Translate an error code to a message string.\");\n\n#define OS_STRERROR_METHODDEF    \\\n    {\"strerror\", (PyCFunction)os_strerror, METH_O, os_strerror__doc__},\n\nstatic PyObject *\nos_strerror_impl(PyObject *module, int code);\n\nstatic PyObject *\nos_strerror(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int code;\n\n    code = PyLong_AsInt(arg);\n    if (code == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_strerror_impl(module, code);\n\nexit:\n    return return_value;\n}\n\n#if defined(HAVE_SYS_WAIT_H) && defined(WCOREDUMP)\n\nPyDoc_STRVAR(os_WCOREDUMP__doc__,\n\"WCOREDUMP($module, status, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the process returning status was dumped to a core file.\");\n\n#define OS_WCOREDUMP_METHODDEF    \\\n    {\"WCOREDUMP\", (PyCFunction)os_WCOREDUMP, METH_O, os_WCOREDUMP__doc__},\n\nstatic int\nos_WCOREDUMP_impl(PyObject *module, int status);\n\nstatic PyObject *\nos_WCOREDUMP(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int status;\n    int _return_value;\n\n    status = PyLong_AsInt(arg);\n    if (status == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_WCOREDUMP_impl(module, status);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SYS_WAIT_H) && defined(WCOREDUMP) */\n\n#if defined(HAVE_SYS_WAIT_H) && defined(WIFCONTINUED)\n\nPyDoc_STRVAR(os_WIFCONTINUED__doc__,\n\"WIFCONTINUED($module, /, status)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if a particular process was continued from a job control stop.\\n\"\n\"\\n\"\n\"Return True if the process returning status was continued from a\\n\"\n\"job control stop.\");\n\n#define OS_WIFCONTINUED_METHODDEF    \\\n    {\"WIFCONTINUED\", _PyCFunction_CAST(os_WIFCONTINUED), METH_FASTCALL|METH_KEYWORDS, os_WIFCONTINUED__doc__},\n\nstatic int\nos_WIFCONTINUED_impl(PyObject *module, int status);\n\nstatic PyObject *\nos_WIFCONTINUED(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(status), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"status\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"WIFCONTINUED\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int status;\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    status = PyLong_AsInt(args[0]);\n    if (status == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_WIFCONTINUED_impl(module, status);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SYS_WAIT_H) && defined(WIFCONTINUED) */\n\n#if defined(HAVE_SYS_WAIT_H) && defined(WIFSTOPPED)\n\nPyDoc_STRVAR(os_WIFSTOPPED__doc__,\n\"WIFSTOPPED($module, /, status)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the process returning status was stopped.\");\n\n#define OS_WIFSTOPPED_METHODDEF    \\\n    {\"WIFSTOPPED\", _PyCFunction_CAST(os_WIFSTOPPED), METH_FASTCALL|METH_KEYWORDS, os_WIFSTOPPED__doc__},\n\nstatic int\nos_WIFSTOPPED_impl(PyObject *module, int status);\n\nstatic PyObject *\nos_WIFSTOPPED(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(status), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"status\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"WIFSTOPPED\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int status;\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    status = PyLong_AsInt(args[0]);\n    if (status == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_WIFSTOPPED_impl(module, status);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SYS_WAIT_H) && defined(WIFSTOPPED) */\n\n#if defined(HAVE_SYS_WAIT_H) && defined(WIFSIGNALED)\n\nPyDoc_STRVAR(os_WIFSIGNALED__doc__,\n\"WIFSIGNALED($module, /, status)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the process returning status was terminated by a signal.\");\n\n#define OS_WIFSIGNALED_METHODDEF    \\\n    {\"WIFSIGNALED\", _PyCFunction_CAST(os_WIFSIGNALED), METH_FASTCALL|METH_KEYWORDS, os_WIFSIGNALED__doc__},\n\nstatic int\nos_WIFSIGNALED_impl(PyObject *module, int status);\n\nstatic PyObject *\nos_WIFSIGNALED(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(status), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"status\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"WIFSIGNALED\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int status;\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    status = PyLong_AsInt(args[0]);\n    if (status == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_WIFSIGNALED_impl(module, status);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SYS_WAIT_H) && defined(WIFSIGNALED) */\n\n#if defined(HAVE_SYS_WAIT_H) && defined(WIFEXITED)\n\nPyDoc_STRVAR(os_WIFEXITED__doc__,\n\"WIFEXITED($module, /, status)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the process returning status exited via the exit() system call.\");\n\n#define OS_WIFEXITED_METHODDEF    \\\n    {\"WIFEXITED\", _PyCFunction_CAST(os_WIFEXITED), METH_FASTCALL|METH_KEYWORDS, os_WIFEXITED__doc__},\n\nstatic int\nos_WIFEXITED_impl(PyObject *module, int status);\n\nstatic PyObject *\nos_WIFEXITED(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(status), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"status\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"WIFEXITED\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int status;\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    status = PyLong_AsInt(args[0]);\n    if (status == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_WIFEXITED_impl(module, status);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SYS_WAIT_H) && defined(WIFEXITED) */\n\n#if defined(HAVE_SYS_WAIT_H) && defined(WEXITSTATUS)\n\nPyDoc_STRVAR(os_WEXITSTATUS__doc__,\n\"WEXITSTATUS($module, /, status)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the process return code from status.\");\n\n#define OS_WEXITSTATUS_METHODDEF    \\\n    {\"WEXITSTATUS\", _PyCFunction_CAST(os_WEXITSTATUS), METH_FASTCALL|METH_KEYWORDS, os_WEXITSTATUS__doc__},\n\nstatic int\nos_WEXITSTATUS_impl(PyObject *module, int status);\n\nstatic PyObject *\nos_WEXITSTATUS(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(status), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"status\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"WEXITSTATUS\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int status;\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    status = PyLong_AsInt(args[0]);\n    if (status == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_WEXITSTATUS_impl(module, status);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SYS_WAIT_H) && defined(WEXITSTATUS) */\n\n#if defined(HAVE_SYS_WAIT_H) && defined(WTERMSIG)\n\nPyDoc_STRVAR(os_WTERMSIG__doc__,\n\"WTERMSIG($module, /, status)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the signal that terminated the process that provided the status value.\");\n\n#define OS_WTERMSIG_METHODDEF    \\\n    {\"WTERMSIG\", _PyCFunction_CAST(os_WTERMSIG), METH_FASTCALL|METH_KEYWORDS, os_WTERMSIG__doc__},\n\nstatic int\nos_WTERMSIG_impl(PyObject *module, int status);\n\nstatic PyObject *\nos_WTERMSIG(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(status), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"status\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"WTERMSIG\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int status;\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    status = PyLong_AsInt(args[0]);\n    if (status == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_WTERMSIG_impl(module, status);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SYS_WAIT_H) && defined(WTERMSIG) */\n\n#if defined(HAVE_SYS_WAIT_H) && defined(WSTOPSIG)\n\nPyDoc_STRVAR(os_WSTOPSIG__doc__,\n\"WSTOPSIG($module, /, status)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the signal that stopped the process that provided the status value.\");\n\n#define OS_WSTOPSIG_METHODDEF    \\\n    {\"WSTOPSIG\", _PyCFunction_CAST(os_WSTOPSIG), METH_FASTCALL|METH_KEYWORDS, os_WSTOPSIG__doc__},\n\nstatic int\nos_WSTOPSIG_impl(PyObject *module, int status);\n\nstatic PyObject *\nos_WSTOPSIG(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(status), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"status\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"WSTOPSIG\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int status;\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    status = PyLong_AsInt(args[0]);\n    if (status == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_WSTOPSIG_impl(module, status);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SYS_WAIT_H) && defined(WSTOPSIG) */\n\n#if (defined(HAVE_FSTATVFS) && defined(HAVE_SYS_STATVFS_H))\n\nPyDoc_STRVAR(os_fstatvfs__doc__,\n\"fstatvfs($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Perform an fstatvfs system call on the given fd.\\n\"\n\"\\n\"\n\"Equivalent to statvfs(fd).\");\n\n#define OS_FSTATVFS_METHODDEF    \\\n    {\"fstatvfs\", (PyCFunction)os_fstatvfs, METH_O, os_fstatvfs__doc__},\n\nstatic PyObject *\nos_fstatvfs_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_fstatvfs(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n\n    fd = PyLong_AsInt(arg);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_fstatvfs_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(HAVE_FSTATVFS) && defined(HAVE_SYS_STATVFS_H)) */\n\n#if (defined(HAVE_STATVFS) && defined(HAVE_SYS_STATVFS_H))\n\nPyDoc_STRVAR(os_statvfs__doc__,\n\"statvfs($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Perform a statvfs system call on the given path.\\n\"\n\"\\n\"\n\"path may always be specified as a string.\\n\"\n\"On some platforms, path may also be specified as an open file descriptor.\\n\"\n\"  If this functionality is unavailable, using it raises an exception.\");\n\n#define OS_STATVFS_METHODDEF    \\\n    {\"statvfs\", _PyCFunction_CAST(os_statvfs), METH_FASTCALL|METH_KEYWORDS, os_statvfs__doc__},\n\nstatic PyObject *\nos_statvfs_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos_statvfs(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"statvfs\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE_P(\"statvfs\", \"path\", 0, 0, 0, PATH_HAVE_FSTATVFS);\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    return_value = os_statvfs_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* (defined(HAVE_STATVFS) && defined(HAVE_SYS_STATVFS_H)) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__getdiskusage__doc__,\n\"_getdiskusage($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return disk usage statistics about the given path as a (total, free) tuple.\");\n\n#define OS__GETDISKUSAGE_METHODDEF    \\\n    {\"_getdiskusage\", _PyCFunction_CAST(os__getdiskusage), METH_FASTCALL|METH_KEYWORDS, os__getdiskusage__doc__},\n\nstatic PyObject *\nos__getdiskusage_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__getdiskusage(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"_getdiskusage\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE_P(\"_getdiskusage\", \"path\", 0, 0, 0, 0);\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    return_value = os__getdiskusage_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(HAVE_FPATHCONF)\n\nPyDoc_STRVAR(os_fpathconf__doc__,\n\"fpathconf($module, fd, name, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the configuration limit name for the file descriptor fd.\\n\"\n\"\\n\"\n\"If there is no limit, return -1.\");\n\n#define OS_FPATHCONF_METHODDEF    \\\n    {\"fpathconf\", _PyCFunction_CAST(os_fpathconf), METH_FASTCALL, os_fpathconf__doc__},\n\nstatic long\nos_fpathconf_impl(PyObject *module, int fd, int name);\n\nstatic PyObject *\nos_fpathconf(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    int name;\n    long _return_value;\n\n    if (!_PyArg_CheckPositional(\"fpathconf\", nargs, 2, 2)) {\n        goto exit;\n    }\n    fd = PyObject_AsFileDescriptor(args[0]);\n    if (fd < 0) {\n        goto exit;\n    }\n    if (!conv_path_confname(args[1], &name)) {\n        goto exit;\n    }\n    _return_value = os_fpathconf_impl(module, fd, name);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong(_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_FPATHCONF) */\n\n#if defined(HAVE_PATHCONF)\n\nPyDoc_STRVAR(os_pathconf__doc__,\n\"pathconf($module, /, path, name)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the configuration limit name for the file or directory path.\\n\"\n\"\\n\"\n\"If there is no limit, return -1.\\n\"\n\"On some platforms, path may also be specified as an open file descriptor.\\n\"\n\"  If this functionality is unavailable, using it raises an exception.\");\n\n#define OS_PATHCONF_METHODDEF    \\\n    {\"pathconf\", _PyCFunction_CAST(os_pathconf), METH_FASTCALL|METH_KEYWORDS, os_pathconf__doc__},\n\nstatic long\nos_pathconf_impl(PyObject *module, path_t *path, int name);\n\nstatic PyObject *\nos_pathconf(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(name), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"name\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"pathconf\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    path_t path = PATH_T_INITIALIZE_P(\"pathconf\", \"path\", 0, 0, 0, PATH_HAVE_FPATHCONF);\n    int name;\n    long _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!conv_path_confname(args[1], &name)) {\n        goto exit;\n    }\n    _return_value = os_pathconf_impl(module, &path, name);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong(_return_value);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_PATHCONF) */\n\n#if defined(HAVE_CONFSTR)\n\nPyDoc_STRVAR(os_confstr__doc__,\n\"confstr($module, name, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a string-valued system configuration variable.\");\n\n#define OS_CONFSTR_METHODDEF    \\\n    {\"confstr\", (PyCFunction)os_confstr, METH_O, os_confstr__doc__},\n\nstatic PyObject *\nos_confstr_impl(PyObject *module, int name);\n\nstatic PyObject *\nos_confstr(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int name;\n\n    if (!conv_confstr_confname(arg, &name)) {\n        goto exit;\n    }\n    return_value = os_confstr_impl(module, name);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_CONFSTR) */\n\n#if defined(HAVE_SYSCONF)\n\nPyDoc_STRVAR(os_sysconf__doc__,\n\"sysconf($module, name, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return an integer-valued system configuration variable.\");\n\n#define OS_SYSCONF_METHODDEF    \\\n    {\"sysconf\", (PyCFunction)os_sysconf, METH_O, os_sysconf__doc__},\n\nstatic long\nos_sysconf_impl(PyObject *module, int name);\n\nstatic PyObject *\nos_sysconf(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int name;\n    long _return_value;\n\n    if (!conv_sysconf_confname(arg, &name)) {\n        goto exit;\n    }\n    _return_value = os_sysconf_impl(module, name);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyLong_FromLong(_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SYSCONF) */\n\nPyDoc_STRVAR(os_abort__doc__,\n\"abort($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Abort the interpreter immediately.\\n\"\n\"\\n\"\n\"This function \\'dumps core\\' or otherwise fails in the hardest way possible\\n\"\n\"on the hosting operating system.  This function never returns.\");\n\n#define OS_ABORT_METHODDEF    \\\n    {\"abort\", (PyCFunction)os_abort, METH_NOARGS, os_abort__doc__},\n\nstatic PyObject *\nos_abort_impl(PyObject *module);\n\nstatic PyObject *\nos_abort(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_abort_impl(module);\n}\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os_startfile__doc__,\n\"startfile($module, /, filepath, operation=<unrepresentable>,\\n\"\n\"          arguments=<unrepresentable>, cwd=None, show_cmd=1)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Start a file with its associated application.\\n\"\n\"\\n\"\n\"When \\\"operation\\\" is not specified or \\\"open\\\", this acts like\\n\"\n\"double-clicking the file in Explorer, or giving the file name as an\\n\"\n\"argument to the DOS \\\"start\\\" command: the file is opened with whatever\\n\"\n\"application (if any) its extension is associated.\\n\"\n\"When another \\\"operation\\\" is given, it specifies what should be done with\\n\"\n\"the file.  A typical operation is \\\"print\\\".\\n\"\n\"\\n\"\n\"\\\"arguments\\\" is passed to the application, but should be omitted if the\\n\"\n\"file is a document.\\n\"\n\"\\n\"\n\"\\\"cwd\\\" is the working directory for the operation. If \\\"filepath\\\" is\\n\"\n\"relative, it will be resolved against this directory. This argument\\n\"\n\"should usually be an absolute path.\\n\"\n\"\\n\"\n\"\\\"show_cmd\\\" can be used to override the recommended visibility option.\\n\"\n\"See the Windows ShellExecute documentation for values.\\n\"\n\"\\n\"\n\"startfile returns as soon as the associated application is launched.\\n\"\n\"There is no option to wait for the application to close, and no way\\n\"\n\"to retrieve the application\\'s exit status.\\n\"\n\"\\n\"\n\"The filepath is relative to the current directory.  If you want to use\\n\"\n\"an absolute path, make sure the first character is not a slash (\\\"/\\\");\\n\"\n\"the underlying Win32 ShellExecute function doesn\\'t work if it is.\");\n\n#define OS_STARTFILE_METHODDEF    \\\n    {\"startfile\", _PyCFunction_CAST(os_startfile), METH_FASTCALL|METH_KEYWORDS, os_startfile__doc__},\n\nstatic PyObject *\nos_startfile_impl(PyObject *module, path_t *filepath,\n                  const wchar_t *operation, const wchar_t *arguments,\n                  path_t *cwd, int show_cmd);\n\nstatic PyObject *\nos_startfile(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 5\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(filepath), &_Py_ID(operation), &_Py_ID(arguments), &_Py_ID(cwd), &_Py_ID(show_cmd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"filepath\", \"operation\", \"arguments\", \"cwd\", \"show_cmd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"startfile\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[5];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    path_t filepath = PATH_T_INITIALIZE_P(\"startfile\", \"filepath\", 0, 0, 0, 0);\n    const wchar_t *operation = NULL;\n    const wchar_t *arguments = NULL;\n    path_t cwd = PATH_T_INITIALIZE_P(\"startfile\", \"cwd\", 1, 0, 0, 0);\n    int show_cmd = 1;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 5, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &filepath)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[1]) {\n        if (!PyUnicode_Check(args[1])) {\n            _PyArg_BadArgument(\"startfile\", \"argument 'operation'\", \"str\", args[1]);\n            goto exit;\n        }\n        operation = PyUnicode_AsWideCharString(args[1], NULL);\n        if (operation == NULL) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\n    if (args[2]) {\n        if (!PyUnicode_Check(args[2])) {\n            _PyArg_BadArgument(\"startfile\", \"argument 'arguments'\", \"str\", args[2]);\n            goto exit;\n        }\n        arguments = PyUnicode_AsWideCharString(args[2], NULL);\n        if (arguments == NULL) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\n    if (args[3]) {\n        if (!path_converter(args[3], &cwd)) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\n    show_cmd = PyLong_AsInt(args[4]);\n    if (show_cmd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional_pos:\n    return_value = os_startfile_impl(module, &filepath, operation, arguments, &cwd, show_cmd);\n\nexit:\n    /* Cleanup for filepath */\n    path_cleanup(&filepath);\n    /* Cleanup for operation */\n    PyMem_Free((void *)operation);\n    /* Cleanup for arguments */\n    PyMem_Free((void *)arguments);\n    /* Cleanup for cwd */\n    path_cleanup(&cwd);\n\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(HAVE_GETLOADAVG)\n\nPyDoc_STRVAR(os_getloadavg__doc__,\n\"getloadavg($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return average recent system load information.\\n\"\n\"\\n\"\n\"Return the number of processes in the system run queue averaged over\\n\"\n\"the last 1, 5, and 15 minutes as a tuple of three floats.\\n\"\n\"Raises OSError if the load average was unobtainable.\");\n\n#define OS_GETLOADAVG_METHODDEF    \\\n    {\"getloadavg\", (PyCFunction)os_getloadavg, METH_NOARGS, os_getloadavg__doc__},\n\nstatic PyObject *\nos_getloadavg_impl(PyObject *module);\n\nstatic PyObject *\nos_getloadavg(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_getloadavg_impl(module);\n}\n\n#endif /* defined(HAVE_GETLOADAVG) */\n\nPyDoc_STRVAR(os_device_encoding__doc__,\n\"device_encoding($module, /, fd)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a string describing the encoding of a terminal\\'s file descriptor.\\n\"\n\"\\n\"\n\"The file descriptor must be attached to a terminal.\\n\"\n\"If the device is not a terminal, return None.\");\n\n#define OS_DEVICE_ENCODING_METHODDEF    \\\n    {\"device_encoding\", _PyCFunction_CAST(os_device_encoding), METH_FASTCALL|METH_KEYWORDS, os_device_encoding__doc__},\n\nstatic PyObject *\nos_device_encoding_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_device_encoding(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"device_encoding\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int fd;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_device_encoding_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#if defined(HAVE_SETRESUID)\n\nPyDoc_STRVAR(os_setresuid__doc__,\n\"setresuid($module, ruid, euid, suid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the current process\\'s real, effective, and saved user ids.\");\n\n#define OS_SETRESUID_METHODDEF    \\\n    {\"setresuid\", _PyCFunction_CAST(os_setresuid), METH_FASTCALL, os_setresuid__doc__},\n\nstatic PyObject *\nos_setresuid_impl(PyObject *module, uid_t ruid, uid_t euid, uid_t suid);\n\nstatic PyObject *\nos_setresuid(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    uid_t ruid;\n    uid_t euid;\n    uid_t suid;\n\n    if (!_PyArg_CheckPositional(\"setresuid\", nargs, 3, 3)) {\n        goto exit;\n    }\n    if (!_Py_Uid_Converter(args[0], &ruid)) {\n        goto exit;\n    }\n    if (!_Py_Uid_Converter(args[1], &euid)) {\n        goto exit;\n    }\n    if (!_Py_Uid_Converter(args[2], &suid)) {\n        goto exit;\n    }\n    return_value = os_setresuid_impl(module, ruid, euid, suid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SETRESUID) */\n\n#if defined(HAVE_SETRESGID)\n\nPyDoc_STRVAR(os_setresgid__doc__,\n\"setresgid($module, rgid, egid, sgid, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the current process\\'s real, effective, and saved group ids.\");\n\n#define OS_SETRESGID_METHODDEF    \\\n    {\"setresgid\", _PyCFunction_CAST(os_setresgid), METH_FASTCALL, os_setresgid__doc__},\n\nstatic PyObject *\nos_setresgid_impl(PyObject *module, gid_t rgid, gid_t egid, gid_t sgid);\n\nstatic PyObject *\nos_setresgid(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    gid_t rgid;\n    gid_t egid;\n    gid_t sgid;\n\n    if (!_PyArg_CheckPositional(\"setresgid\", nargs, 3, 3)) {\n        goto exit;\n    }\n    if (!_Py_Gid_Converter(args[0], &rgid)) {\n        goto exit;\n    }\n    if (!_Py_Gid_Converter(args[1], &egid)) {\n        goto exit;\n    }\n    if (!_Py_Gid_Converter(args[2], &sgid)) {\n        goto exit;\n    }\n    return_value = os_setresgid_impl(module, rgid, egid, sgid);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_SETRESGID) */\n\n#if defined(HAVE_GETRESUID)\n\nPyDoc_STRVAR(os_getresuid__doc__,\n\"getresuid($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a tuple of the current process\\'s real, effective, and saved user ids.\");\n\n#define OS_GETRESUID_METHODDEF    \\\n    {\"getresuid\", (PyCFunction)os_getresuid, METH_NOARGS, os_getresuid__doc__},\n\nstatic PyObject *\nos_getresuid_impl(PyObject *module);\n\nstatic PyObject *\nos_getresuid(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_getresuid_impl(module);\n}\n\n#endif /* defined(HAVE_GETRESUID) */\n\n#if defined(HAVE_GETRESGID)\n\nPyDoc_STRVAR(os_getresgid__doc__,\n\"getresgid($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a tuple of the current process\\'s real, effective, and saved group ids.\");\n\n#define OS_GETRESGID_METHODDEF    \\\n    {\"getresgid\", (PyCFunction)os_getresgid, METH_NOARGS, os_getresgid__doc__},\n\nstatic PyObject *\nos_getresgid_impl(PyObject *module);\n\nstatic PyObject *\nos_getresgid(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_getresgid_impl(module);\n}\n\n#endif /* defined(HAVE_GETRESGID) */\n\n#if defined(USE_XATTRS)\n\nPyDoc_STRVAR(os_getxattr__doc__,\n\"getxattr($module, /, path, attribute, *, follow_symlinks=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the value of extended attribute attribute on path.\\n\"\n\"\\n\"\n\"path may be either a string, a path-like object, or an open file descriptor.\\n\"\n\"If follow_symlinks is False, and the last element of the path is a symbolic\\n\"\n\"  link, getxattr will examine the symbolic link itself instead of the file\\n\"\n\"  the link points to.\");\n\n#define OS_GETXATTR_METHODDEF    \\\n    {\"getxattr\", _PyCFunction_CAST(os_getxattr), METH_FASTCALL|METH_KEYWORDS, os_getxattr__doc__},\n\nstatic PyObject *\nos_getxattr_impl(PyObject *module, path_t *path, path_t *attribute,\n                 int follow_symlinks);\n\nstatic PyObject *\nos_getxattr(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(attribute), &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"attribute\", \"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"getxattr\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[3];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;\n    path_t path = PATH_T_INITIALIZE_P(\"getxattr\", \"path\", 0, 0, 0, 1);\n    path_t attribute = PATH_T_INITIALIZE_P(\"getxattr\", \"attribute\", 0, 0, 0, 0);\n    int follow_symlinks = 1;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!path_converter(args[1], &attribute)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    follow_symlinks = PyObject_IsTrue(args[2]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_getxattr_impl(module, &path, &attribute, follow_symlinks);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n    /* Cleanup for attribute */\n    path_cleanup(&attribute);\n\n    return return_value;\n}\n\n#endif /* defined(USE_XATTRS) */\n\n#if defined(USE_XATTRS)\n\nPyDoc_STRVAR(os_setxattr__doc__,\n\"setxattr($module, /, path, attribute, value, flags=0, *,\\n\"\n\"         follow_symlinks=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set extended attribute attribute on path to value.\\n\"\n\"\\n\"\n\"path may be either a string, a path-like object,  or an open file descriptor.\\n\"\n\"If follow_symlinks is False, and the last element of the path is a symbolic\\n\"\n\"  link, setxattr will modify the symbolic link itself instead of the file\\n\"\n\"  the link points to.\");\n\n#define OS_SETXATTR_METHODDEF    \\\n    {\"setxattr\", _PyCFunction_CAST(os_setxattr), METH_FASTCALL|METH_KEYWORDS, os_setxattr__doc__},\n\nstatic PyObject *\nos_setxattr_impl(PyObject *module, path_t *path, path_t *attribute,\n                 Py_buffer *value, int flags, int follow_symlinks);\n\nstatic PyObject *\nos_setxattr(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 5\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(attribute), &_Py_ID(value), &_Py_ID(flags), &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"attribute\", \"value\", \"flags\", \"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"setxattr\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[5];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;\n    path_t path = PATH_T_INITIALIZE_P(\"setxattr\", \"path\", 0, 0, 0, 1);\n    path_t attribute = PATH_T_INITIALIZE_P(\"setxattr\", \"attribute\", 0, 0, 0, 0);\n    Py_buffer value = {NULL, NULL};\n    int flags = 0;\n    int follow_symlinks = 1;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 3, 4, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!path_converter(args[1], &attribute)) {\n        goto exit;\n    }\n    if (PyObject_GetBuffer(args[2], &value, PyBUF_SIMPLE) != 0) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[3]) {\n        flags = PyLong_AsInt(args[3]);\n        if (flags == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\nskip_optional_pos:\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    follow_symlinks = PyObject_IsTrue(args[4]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_setxattr_impl(module, &path, &attribute, &value, flags, follow_symlinks);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n    /* Cleanup for attribute */\n    path_cleanup(&attribute);\n    /* Cleanup for value */\n    if (value.obj) {\n       PyBuffer_Release(&value);\n    }\n\n    return return_value;\n}\n\n#endif /* defined(USE_XATTRS) */\n\n#if defined(USE_XATTRS)\n\nPyDoc_STRVAR(os_removexattr__doc__,\n\"removexattr($module, /, path, attribute, *, follow_symlinks=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Remove extended attribute attribute on path.\\n\"\n\"\\n\"\n\"path may be either a string, a path-like object, or an open file descriptor.\\n\"\n\"If follow_symlinks is False, and the last element of the path is a symbolic\\n\"\n\"  link, removexattr will modify the symbolic link itself instead of the file\\n\"\n\"  the link points to.\");\n\n#define OS_REMOVEXATTR_METHODDEF    \\\n    {\"removexattr\", _PyCFunction_CAST(os_removexattr), METH_FASTCALL|METH_KEYWORDS, os_removexattr__doc__},\n\nstatic PyObject *\nos_removexattr_impl(PyObject *module, path_t *path, path_t *attribute,\n                    int follow_symlinks);\n\nstatic PyObject *\nos_removexattr(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 3\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(attribute), &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"attribute\", \"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"removexattr\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[3];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;\n    path_t path = PATH_T_INITIALIZE_P(\"removexattr\", \"path\", 0, 0, 0, 1);\n    path_t attribute = PATH_T_INITIALIZE_P(\"removexattr\", \"attribute\", 0, 0, 0, 0);\n    int follow_symlinks = 1;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    if (!path_converter(args[1], &attribute)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    follow_symlinks = PyObject_IsTrue(args[2]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_removexattr_impl(module, &path, &attribute, follow_symlinks);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n    /* Cleanup for attribute */\n    path_cleanup(&attribute);\n\n    return return_value;\n}\n\n#endif /* defined(USE_XATTRS) */\n\n#if defined(USE_XATTRS)\n\nPyDoc_STRVAR(os_listxattr__doc__,\n\"listxattr($module, /, path=None, *, follow_symlinks=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a list of extended attributes on path.\\n\"\n\"\\n\"\n\"path may be either None, a string, a path-like object, or an open file descriptor.\\n\"\n\"if path is None, listxattr will examine the current directory.\\n\"\n\"If follow_symlinks is False, and the last element of the path is a symbolic\\n\"\n\"  link, listxattr will examine the symbolic link itself instead of the file\\n\"\n\"  the link points to.\");\n\n#define OS_LISTXATTR_METHODDEF    \\\n    {\"listxattr\", _PyCFunction_CAST(os_listxattr), METH_FASTCALL|METH_KEYWORDS, os_listxattr__doc__},\n\nstatic PyObject *\nos_listxattr_impl(PyObject *module, path_t *path, int follow_symlinks);\n\nstatic PyObject *\nos_listxattr(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", \"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"listxattr\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;\n    path_t path = PATH_T_INITIALIZE_P(\"listxattr\", \"path\", 1, 0, 0, 1);\n    int follow_symlinks = 1;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (args[0]) {\n        if (!path_converter(args[0], &path)) {\n            goto exit;\n        }\n        if (!--noptargs) {\n            goto skip_optional_pos;\n        }\n    }\nskip_optional_pos:\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    follow_symlinks = PyObject_IsTrue(args[1]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_listxattr_impl(module, &path, follow_symlinks);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* defined(USE_XATTRS) */\n\nPyDoc_STRVAR(os_urandom__doc__,\n\"urandom($module, size, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return a bytes object containing random bytes suitable for cryptographic use.\");\n\n#define OS_URANDOM_METHODDEF    \\\n    {\"urandom\", (PyCFunction)os_urandom, METH_O, os_urandom__doc__},\n\nstatic PyObject *\nos_urandom_impl(PyObject *module, Py_ssize_t size);\n\nstatic PyObject *\nos_urandom(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    Py_ssize_t size;\n\n    {\n        Py_ssize_t ival = -1;\n        PyObject *iobj = _PyNumber_Index(arg);\n        if (iobj != NULL) {\n            ival = PyLong_AsSsize_t(iobj);\n            Py_DECREF(iobj);\n        }\n        if (ival == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        size = ival;\n    }\n    return_value = os_urandom_impl(module, size);\n\nexit:\n    return return_value;\n}\n\n#if defined(HAVE_MEMFD_CREATE)\n\nPyDoc_STRVAR(os_memfd_create__doc__,\n\"memfd_create($module, /, name, flags=MFD_CLOEXEC)\\n\"\n\"--\\n\"\n\"\\n\");\n\n#define OS_MEMFD_CREATE_METHODDEF    \\\n    {\"memfd_create\", _PyCFunction_CAST(os_memfd_create), METH_FASTCALL|METH_KEYWORDS, os_memfd_create__doc__},\n\nstatic PyObject *\nos_memfd_create_impl(PyObject *module, PyObject *name, unsigned int flags);\n\nstatic PyObject *\nos_memfd_create(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(name), &_Py_ID(flags), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"name\", \"flags\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"memfd_create\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    PyObject *name = NULL;\n    unsigned int flags = MFD_CLOEXEC;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!PyUnicode_FSConverter(args[0], &name)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    flags = (unsigned int)PyLong_AsUnsignedLongMask(args[1]);\n    if (flags == (unsigned int)-1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional_pos:\n    return_value = os_memfd_create_impl(module, name, flags);\n\nexit:\n    /* Cleanup for name */\n    Py_XDECREF(name);\n\n    return return_value;\n}\n\n#endif /* defined(HAVE_MEMFD_CREATE) */\n\n#if (defined(HAVE_EVENTFD) && defined(EFD_CLOEXEC))\n\nPyDoc_STRVAR(os_eventfd__doc__,\n\"eventfd($module, /, initval, flags=EFD_CLOEXEC)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Creates and returns an event notification file descriptor.\");\n\n#define OS_EVENTFD_METHODDEF    \\\n    {\"eventfd\", _PyCFunction_CAST(os_eventfd), METH_FASTCALL|METH_KEYWORDS, os_eventfd__doc__},\n\nstatic PyObject *\nos_eventfd_impl(PyObject *module, unsigned int initval, int flags);\n\nstatic PyObject *\nos_eventfd(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(initval), &_Py_ID(flags), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"initval\", \"flags\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"eventfd\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    unsigned int initval;\n    int flags = EFD_CLOEXEC;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!_PyLong_UnsignedInt_Converter(args[0], &initval)) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    flags = PyLong_AsInt(args[1]);\n    if (flags == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional_pos:\n    return_value = os_eventfd_impl(module, initval, flags);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(HAVE_EVENTFD) && defined(EFD_CLOEXEC)) */\n\n#if (defined(HAVE_EVENTFD) && defined(EFD_CLOEXEC))\n\nPyDoc_STRVAR(os_eventfd_read__doc__,\n\"eventfd_read($module, /, fd)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Read eventfd value\");\n\n#define OS_EVENTFD_READ_METHODDEF    \\\n    {\"eventfd_read\", _PyCFunction_CAST(os_eventfd_read), METH_FASTCALL|METH_KEYWORDS, os_eventfd_read__doc__},\n\nstatic PyObject *\nos_eventfd_read_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_eventfd_read(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(fd), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"fd\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"eventfd_read\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    int fd;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyObject_AsFileDescriptor(args[0]);\n    if (fd < 0) {\n        goto exit;\n    }\n    return_value = os_eventfd_read_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(HAVE_EVENTFD) && defined(EFD_CLOEXEC)) */\n\n#if (defined(HAVE_EVENTFD) && defined(EFD_CLOEXEC))\n\nPyDoc_STRVAR(os_eventfd_write__doc__,\n\"eventfd_write($module, /, fd, value)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Write eventfd value.\");\n\n#define OS_EVENTFD_WRITE_METHODDEF    \\\n    {\"eventfd_write\", _PyCFunction_CAST(os_eventfd_write), METH_FASTCALL|METH_KEYWORDS, os_eventfd_write__doc__},\n\nstatic PyObject *\nos_eventfd_write_impl(PyObject *module, int fd, unsigned long long value);\n\nstatic PyObject *\nos_eventfd_write(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(fd), &_Py_ID(value), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"fd\", \"value\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"eventfd_write\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    int fd;\n    unsigned long long value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    fd = PyObject_AsFileDescriptor(args[0]);\n    if (fd < 0) {\n        goto exit;\n    }\n    if (!_PyLong_UnsignedLongLong_Converter(args[1], &value)) {\n        goto exit;\n    }\n    return_value = os_eventfd_write_impl(module, fd, value);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(HAVE_EVENTFD) && defined(EFD_CLOEXEC)) */\n\n#if (defined(TERMSIZE_USE_CONIO) || defined(TERMSIZE_USE_IOCTL))\n\nPyDoc_STRVAR(os_get_terminal_size__doc__,\n\"get_terminal_size($module, fd=<unrepresentable>, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the size of the terminal window as (columns, lines).\\n\"\n\"\\n\"\n\"The optional argument fd (default standard output) specifies\\n\"\n\"which file descriptor should be queried.\\n\"\n\"\\n\"\n\"If the file descriptor is not connected to a terminal, an OSError\\n\"\n\"is thrown.\\n\"\n\"\\n\"\n\"This function will only be defined if an implementation is\\n\"\n\"available for this system.\\n\"\n\"\\n\"\n\"shutil.get_terminal_size is the high-level function which should\\n\"\n\"normally be used, os.get_terminal_size is the low-level implementation.\");\n\n#define OS_GET_TERMINAL_SIZE_METHODDEF    \\\n    {\"get_terminal_size\", _PyCFunction_CAST(os_get_terminal_size), METH_FASTCALL, os_get_terminal_size__doc__},\n\nstatic PyObject *\nos_get_terminal_size_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_get_terminal_size(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd = fileno(stdout);\n\n    if (!_PyArg_CheckPositional(\"get_terminal_size\", nargs, 0, 1)) {\n        goto exit;\n    }\n    if (nargs < 1) {\n        goto skip_optional;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional:\n    return_value = os_get_terminal_size_impl(module, fd);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(TERMSIZE_USE_CONIO) || defined(TERMSIZE_USE_IOCTL)) */\n\nPyDoc_STRVAR(os_cpu_count__doc__,\n\"cpu_count($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the number of logical CPUs in the system.\\n\"\n\"\\n\"\n\"Return None if indeterminable.\");\n\n#define OS_CPU_COUNT_METHODDEF    \\\n    {\"cpu_count\", (PyCFunction)os_cpu_count, METH_NOARGS, os_cpu_count__doc__},\n\nstatic PyObject *\nos_cpu_count_impl(PyObject *module);\n\nstatic PyObject *\nos_cpu_count(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os_cpu_count_impl(module);\n}\n\nPyDoc_STRVAR(os_get_inheritable__doc__,\n\"get_inheritable($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Get the close-on-exe flag of the specified file descriptor.\");\n\n#define OS_GET_INHERITABLE_METHODDEF    \\\n    {\"get_inheritable\", (PyCFunction)os_get_inheritable, METH_O, os_get_inheritable__doc__},\n\nstatic int\nos_get_inheritable_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_get_inheritable(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    int _return_value;\n\n    fd = PyLong_AsInt(arg);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_get_inheritable_impl(module, fd);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(os_set_inheritable__doc__,\n\"set_inheritable($module, fd, inheritable, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the inheritable flag of the specified file descriptor.\");\n\n#define OS_SET_INHERITABLE_METHODDEF    \\\n    {\"set_inheritable\", _PyCFunction_CAST(os_set_inheritable), METH_FASTCALL, os_set_inheritable__doc__},\n\nstatic PyObject *\nos_set_inheritable_impl(PyObject *module, int fd, int inheritable);\n\nstatic PyObject *\nos_set_inheritable(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    int inheritable;\n\n    if (!_PyArg_CheckPositional(\"set_inheritable\", nargs, 2, 2)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    inheritable = PyLong_AsInt(args[1]);\n    if (inheritable == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = os_set_inheritable_impl(module, fd, inheritable);\n\nexit:\n    return return_value;\n}\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os_get_handle_inheritable__doc__,\n\"get_handle_inheritable($module, handle, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Get the close-on-exe flag of the specified file descriptor.\");\n\n#define OS_GET_HANDLE_INHERITABLE_METHODDEF    \\\n    {\"get_handle_inheritable\", (PyCFunction)os_get_handle_inheritable, METH_O, os_get_handle_inheritable__doc__},\n\nstatic int\nos_get_handle_inheritable_impl(PyObject *module, intptr_t handle);\n\nstatic PyObject *\nos_get_handle_inheritable(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    intptr_t handle;\n    int _return_value;\n\n    if (!PyArg_Parse(arg, \"\" _Py_PARSE_INTPTR \":get_handle_inheritable\", &handle)) {\n        goto exit;\n    }\n    _return_value = os_get_handle_inheritable_impl(module, handle);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os_set_handle_inheritable__doc__,\n\"set_handle_inheritable($module, handle, inheritable, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the inheritable flag of the specified handle.\");\n\n#define OS_SET_HANDLE_INHERITABLE_METHODDEF    \\\n    {\"set_handle_inheritable\", _PyCFunction_CAST(os_set_handle_inheritable), METH_FASTCALL, os_set_handle_inheritable__doc__},\n\nstatic PyObject *\nos_set_handle_inheritable_impl(PyObject *module, intptr_t handle,\n                               int inheritable);\n\nstatic PyObject *\nos_set_handle_inheritable(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    intptr_t handle;\n    int inheritable;\n\n    if (!_PyArg_ParseStack(args, nargs, \"\" _Py_PARSE_INTPTR \"p:set_handle_inheritable\",\n        &handle, &inheritable)) {\n        goto exit;\n    }\n    return_value = os_set_handle_inheritable_impl(module, handle, inheritable);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(MS_WINDOWS) */\n\nPyDoc_STRVAR(os_get_blocking__doc__,\n\"get_blocking($module, fd, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Get the blocking mode of the file descriptor.\\n\"\n\"\\n\"\n\"Return False if the O_NONBLOCK flag is set, True if the flag is cleared.\");\n\n#define OS_GET_BLOCKING_METHODDEF    \\\n    {\"get_blocking\", (PyCFunction)os_get_blocking, METH_O, os_get_blocking__doc__},\n\nstatic int\nos_get_blocking_impl(PyObject *module, int fd);\n\nstatic PyObject *\nos_get_blocking(PyObject *module, PyObject *arg)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    int _return_value;\n\n    fd = PyLong_AsInt(arg);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    _return_value = os_get_blocking_impl(module, fd);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(os_set_blocking__doc__,\n\"set_blocking($module, fd, blocking, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Set the blocking mode of the specified file descriptor.\\n\"\n\"\\n\"\n\"Set the O_NONBLOCK flag if blocking is False,\\n\"\n\"clear the O_NONBLOCK flag otherwise.\");\n\n#define OS_SET_BLOCKING_METHODDEF    \\\n    {\"set_blocking\", _PyCFunction_CAST(os_set_blocking), METH_FASTCALL, os_set_blocking__doc__},\n\nstatic PyObject *\nos_set_blocking_impl(PyObject *module, int fd, int blocking);\n\nstatic PyObject *\nos_set_blocking(PyObject *module, PyObject *const *args, Py_ssize_t nargs)\n{\n    PyObject *return_value = NULL;\n    int fd;\n    int blocking;\n\n    if (!_PyArg_CheckPositional(\"set_blocking\", nargs, 2, 2)) {\n        goto exit;\n    }\n    fd = PyLong_AsInt(args[0]);\n    if (fd == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\n    blocking = PyObject_IsTrue(args[1]);\n    if (blocking < 0) {\n        goto exit;\n    }\n    return_value = os_set_blocking_impl(module, fd, blocking);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(os_DirEntry_is_symlink__doc__,\n\"is_symlink($self, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the entry is a symbolic link; cached per entry.\");\n\n#define OS_DIRENTRY_IS_SYMLINK_METHODDEF    \\\n    {\"is_symlink\", _PyCFunction_CAST(os_DirEntry_is_symlink), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, os_DirEntry_is_symlink__doc__},\n\nstatic int\nos_DirEntry_is_symlink_impl(DirEntry *self, PyTypeObject *defining_class);\n\nstatic PyObject *\nos_DirEntry_is_symlink(DirEntry *self, PyTypeObject *defining_class, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    int _return_value;\n\n    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {\n        PyErr_SetString(PyExc_TypeError, \"is_symlink() takes no arguments\");\n        goto exit;\n    }\n    _return_value = os_DirEntry_is_symlink_impl(self, defining_class);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(os_DirEntry_is_junction__doc__,\n\"is_junction($self, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the entry is a junction; cached per entry.\");\n\n#define OS_DIRENTRY_IS_JUNCTION_METHODDEF    \\\n    {\"is_junction\", (PyCFunction)os_DirEntry_is_junction, METH_NOARGS, os_DirEntry_is_junction__doc__},\n\nstatic int\nos_DirEntry_is_junction_impl(DirEntry *self);\n\nstatic PyObject *\nos_DirEntry_is_junction(DirEntry *self, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *return_value = NULL;\n    int _return_value;\n\n    _return_value = os_DirEntry_is_junction_impl(self);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(os_DirEntry_stat__doc__,\n\"stat($self, /, *, follow_symlinks=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return stat_result object for the entry; cached per entry.\");\n\n#define OS_DIRENTRY_STAT_METHODDEF    \\\n    {\"stat\", _PyCFunction_CAST(os_DirEntry_stat), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, os_DirEntry_stat__doc__},\n\nstatic PyObject *\nos_DirEntry_stat_impl(DirEntry *self, PyTypeObject *defining_class,\n                      int follow_symlinks);\n\nstatic PyObject *\nos_DirEntry_stat(DirEntry *self, PyTypeObject *defining_class, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"stat\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;\n    int follow_symlinks = 1;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    follow_symlinks = PyObject_IsTrue(args[0]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    return_value = os_DirEntry_stat_impl(self, defining_class, follow_symlinks);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(os_DirEntry_is_dir__doc__,\n\"is_dir($self, /, *, follow_symlinks=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the entry is a directory; cached per entry.\");\n\n#define OS_DIRENTRY_IS_DIR_METHODDEF    \\\n    {\"is_dir\", _PyCFunction_CAST(os_DirEntry_is_dir), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, os_DirEntry_is_dir__doc__},\n\nstatic int\nos_DirEntry_is_dir_impl(DirEntry *self, PyTypeObject *defining_class,\n                        int follow_symlinks);\n\nstatic PyObject *\nos_DirEntry_is_dir(DirEntry *self, PyTypeObject *defining_class, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"is_dir\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;\n    int follow_symlinks = 1;\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    follow_symlinks = PyObject_IsTrue(args[0]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    _return_value = os_DirEntry_is_dir_impl(self, defining_class, follow_symlinks);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(os_DirEntry_is_file__doc__,\n\"is_file($self, /, *, follow_symlinks=True)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return True if the entry is a file; cached per entry.\");\n\n#define OS_DIRENTRY_IS_FILE_METHODDEF    \\\n    {\"is_file\", _PyCFunction_CAST(os_DirEntry_is_file), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, os_DirEntry_is_file__doc__},\n\nstatic int\nos_DirEntry_is_file_impl(DirEntry *self, PyTypeObject *defining_class,\n                         int follow_symlinks);\n\nstatic PyObject *\nos_DirEntry_is_file(DirEntry *self, PyTypeObject *defining_class, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(follow_symlinks), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"follow_symlinks\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"is_file\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;\n    int follow_symlinks = 1;\n    int _return_value;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_kwonly;\n    }\n    follow_symlinks = PyObject_IsTrue(args[0]);\n    if (follow_symlinks < 0) {\n        goto exit;\n    }\nskip_optional_kwonly:\n    _return_value = os_DirEntry_is_file_impl(self, defining_class, follow_symlinks);\n    if ((_return_value == -1) && PyErr_Occurred()) {\n        goto exit;\n    }\n    return_value = PyBool_FromLong((long)_return_value);\n\nexit:\n    return return_value;\n}\n\nPyDoc_STRVAR(os_DirEntry_inode__doc__,\n\"inode($self, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return inode of the entry; cached per entry.\");\n\n#define OS_DIRENTRY_INODE_METHODDEF    \\\n    {\"inode\", (PyCFunction)os_DirEntry_inode, METH_NOARGS, os_DirEntry_inode__doc__},\n\nstatic PyObject *\nos_DirEntry_inode_impl(DirEntry *self);\n\nstatic PyObject *\nos_DirEntry_inode(DirEntry *self, PyObject *Py_UNUSED(ignored))\n{\n    return os_DirEntry_inode_impl(self);\n}\n\nPyDoc_STRVAR(os_DirEntry___fspath____doc__,\n\"__fspath__($self, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Returns the path for the entry.\");\n\n#define OS_DIRENTRY___FSPATH___METHODDEF    \\\n    {\"__fspath__\", (PyCFunction)os_DirEntry___fspath__, METH_NOARGS, os_DirEntry___fspath____doc__},\n\nstatic PyObject *\nos_DirEntry___fspath___impl(DirEntry *self);\n\nstatic PyObject *\nos_DirEntry___fspath__(DirEntry *self, PyObject *Py_UNUSED(ignored))\n{\n    return os_DirEntry___fspath___impl(self);\n}\n\nPyDoc_STRVAR(os_scandir__doc__,\n\"scandir($module, /, path=None)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return an iterator of DirEntry objects for given path.\\n\"\n\"\\n\"\n\"path can be specified as either str, bytes, or a path-like object.  If path\\n\"\n\"is bytes, the names of yielded DirEntry objects will also be bytes; in\\n\"\n\"all other circumstances they will be str.\\n\"\n\"\\n\"\n\"If path is None, uses the path=\\'.\\'.\");\n\n#define OS_SCANDIR_METHODDEF    \\\n    {\"scandir\", _PyCFunction_CAST(os_scandir), METH_FASTCALL|METH_KEYWORDS, os_scandir__doc__},\n\nstatic PyObject *\nos_scandir_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos_scandir(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"scandir\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;\n    path_t path = PATH_T_INITIALIZE_P(\"scandir\", \"path\", 1, 0, 0, PATH_HAVE_FDOPENDIR);\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\nskip_optional_pos:\n    return_value = os_scandir_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\nPyDoc_STRVAR(os_fspath__doc__,\n\"fspath($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Return the file system path representation of the object.\\n\"\n\"\\n\"\n\"If the object is str or bytes, then allow it to pass through as-is. If the\\n\"\n\"object defines __fspath__(), then return the result of that method. All other\\n\"\n\"types raise a TypeError.\");\n\n#define OS_FSPATH_METHODDEF    \\\n    {\"fspath\", _PyCFunction_CAST(os_fspath), METH_FASTCALL|METH_KEYWORDS, os_fspath__doc__},\n\nstatic PyObject *\nos_fspath_impl(PyObject *module, PyObject *path);\n\nstatic PyObject *\nos_fspath(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"fspath\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    PyObject *path;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    path = args[0];\n    return_value = os_fspath_impl(module, path);\n\nexit:\n    return return_value;\n}\n\n#if defined(HAVE_GETRANDOM_SYSCALL)\n\nPyDoc_STRVAR(os_getrandom__doc__,\n\"getrandom($module, /, size, flags=0)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Obtain a series of random bytes.\");\n\n#define OS_GETRANDOM_METHODDEF    \\\n    {\"getrandom\", _PyCFunction_CAST(os_getrandom), METH_FASTCALL|METH_KEYWORDS, os_getrandom__doc__},\n\nstatic PyObject *\nos_getrandom_impl(PyObject *module, Py_ssize_t size, int flags);\n\nstatic PyObject *\nos_getrandom(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 2\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(size), &_Py_ID(flags), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"size\", \"flags\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"getrandom\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[2];\n    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;\n    Py_ssize_t size;\n    int flags = 0;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    {\n        Py_ssize_t ival = -1;\n        PyObject *iobj = _PyNumber_Index(args[0]);\n        if (iobj != NULL) {\n            ival = PyLong_AsSsize_t(iobj);\n            Py_DECREF(iobj);\n        }\n        if (ival == -1 && PyErr_Occurred()) {\n            goto exit;\n        }\n        size = ival;\n    }\n    if (!noptargs) {\n        goto skip_optional_pos;\n    }\n    flags = PyLong_AsInt(args[1]);\n    if (flags == -1 && PyErr_Occurred()) {\n        goto exit;\n    }\nskip_optional_pos:\n    return_value = os_getrandom_impl(module, size, flags);\n\nexit:\n    return return_value;\n}\n\n#endif /* defined(HAVE_GETRANDOM_SYSCALL) */\n\n#if (defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_APP) || defined(MS_WINDOWS_SYSTEM))\n\nPyDoc_STRVAR(os__add_dll_directory__doc__,\n\"_add_dll_directory($module, /, path)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Add a path to the DLL search path.\\n\"\n\"\\n\"\n\"This search path is used when resolving dependencies for imported\\n\"\n\"extension modules (the module itself is resolved through sys.path),\\n\"\n\"and also by ctypes.\\n\"\n\"\\n\"\n\"Returns an opaque value that may be passed to os.remove_dll_directory\\n\"\n\"to remove this directory from the search path.\");\n\n#define OS__ADD_DLL_DIRECTORY_METHODDEF    \\\n    {\"_add_dll_directory\", _PyCFunction_CAST(os__add_dll_directory), METH_FASTCALL|METH_KEYWORDS, os__add_dll_directory__doc__},\n\nstatic PyObject *\nos__add_dll_directory_impl(PyObject *module, path_t *path);\n\nstatic PyObject *\nos__add_dll_directory(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(path), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"path\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"_add_dll_directory\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    path_t path = PATH_T_INITIALIZE_P(\"_add_dll_directory\", \"path\", 0, 0, 0, 0);\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    if (!path_converter(args[0], &path)) {\n        goto exit;\n    }\n    return_value = os__add_dll_directory_impl(module, &path);\n\nexit:\n    /* Cleanup for path */\n    path_cleanup(&path);\n\n    return return_value;\n}\n\n#endif /* (defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_APP) || defined(MS_WINDOWS_SYSTEM)) */\n\n#if (defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_APP) || defined(MS_WINDOWS_SYSTEM))\n\nPyDoc_STRVAR(os__remove_dll_directory__doc__,\n\"_remove_dll_directory($module, /, cookie)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Removes a path from the DLL search path.\\n\"\n\"\\n\"\n\"The parameter is an opaque value that was returned from\\n\"\n\"os.add_dll_directory. You can only remove directories that you added\\n\"\n\"yourself.\");\n\n#define OS__REMOVE_DLL_DIRECTORY_METHODDEF    \\\n    {\"_remove_dll_directory\", _PyCFunction_CAST(os__remove_dll_directory), METH_FASTCALL|METH_KEYWORDS, os__remove_dll_directory__doc__},\n\nstatic PyObject *\nos__remove_dll_directory_impl(PyObject *module, PyObject *cookie);\n\nstatic PyObject *\nos__remove_dll_directory(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(cookie), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"cookie\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"_remove_dll_directory\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    PyObject *cookie;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    cookie = args[0];\n    return_value = os__remove_dll_directory_impl(module, cookie);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_APP) || defined(MS_WINDOWS_SYSTEM)) */\n\n#if (defined(WIFEXITED) || defined(MS_WINDOWS))\n\nPyDoc_STRVAR(os_waitstatus_to_exitcode__doc__,\n\"waitstatus_to_exitcode($module, /, status)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Convert a wait status to an exit code.\\n\"\n\"\\n\"\n\"On Unix:\\n\"\n\"\\n\"\n\"* If WIFEXITED(status) is true, return WEXITSTATUS(status).\\n\"\n\"* If WIFSIGNALED(status) is true, return -WTERMSIG(status).\\n\"\n\"* Otherwise, raise a ValueError.\\n\"\n\"\\n\"\n\"On Windows, return status shifted right by 8 bits.\\n\"\n\"\\n\"\n\"On Unix, if the process is being traced or if waitpid() was called with\\n\"\n\"WUNTRACED option, the caller must first check if WIFSTOPPED(status) is true.\\n\"\n\"This function must not be called if WIFSTOPPED(status) is true.\");\n\n#define OS_WAITSTATUS_TO_EXITCODE_METHODDEF    \\\n    {\"waitstatus_to_exitcode\", _PyCFunction_CAST(os_waitstatus_to_exitcode), METH_FASTCALL|METH_KEYWORDS, os_waitstatus_to_exitcode__doc__},\n\nstatic PyObject *\nos_waitstatus_to_exitcode_impl(PyObject *module, PyObject *status_obj);\n\nstatic PyObject *\nos_waitstatus_to_exitcode(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n{\n    PyObject *return_value = NULL;\n    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n\n    #define NUM_KEYWORDS 1\n    static struct {\n        PyGC_Head _this_is_not_used;\n        PyObject_VAR_HEAD\n        PyObject *ob_item[NUM_KEYWORDS];\n    } _kwtuple = {\n        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)\n        .ob_item = { &_Py_ID(status), },\n    };\n    #undef NUM_KEYWORDS\n    #define KWTUPLE (&_kwtuple.ob_base.ob_base)\n\n    #else  // !Py_BUILD_CORE\n    #  define KWTUPLE NULL\n    #endif  // !Py_BUILD_CORE\n\n    static const char * const _keywords[] = {\"status\", NULL};\n    static _PyArg_Parser _parser = {\n        .keywords = _keywords,\n        .fname = \"waitstatus_to_exitcode\",\n        .kwtuple = KWTUPLE,\n    };\n    #undef KWTUPLE\n    PyObject *argsbuf[1];\n    PyObject *status_obj;\n\n    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);\n    if (!args) {\n        goto exit;\n    }\n    status_obj = args[0];\n    return_value = os_waitstatus_to_exitcode_impl(module, status_obj);\n\nexit:\n    return return_value;\n}\n\n#endif /* (defined(WIFEXITED) || defined(MS_WINDOWS)) */\n\n#if defined(MS_WINDOWS)\n\nPyDoc_STRVAR(os__supports_virtual_terminal__doc__,\n\"_supports_virtual_terminal($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Checks if virtual terminal is supported in windows\");\n\n#define OS__SUPPORTS_VIRTUAL_TERMINAL_METHODDEF    \\\n    {\"_supports_virtual_terminal\", (PyCFunction)os__supports_virtual_terminal, METH_NOARGS, os__supports_virtual_terminal__doc__},\n\nstatic PyObject *\nos__supports_virtual_terminal_impl(PyObject *module);\n\nstatic PyObject *\nos__supports_virtual_terminal(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os__supports_virtual_terminal_impl(module);\n}\n\n#endif /* defined(MS_WINDOWS) */\n\nPyDoc_STRVAR(os__inputhook__doc__,\n\"_inputhook($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Calls PyOS_CallInputHook droppong the GIL first\");\n\n#define OS__INPUTHOOK_METHODDEF    \\\n    {\"_inputhook\", (PyCFunction)os__inputhook, METH_NOARGS, os__inputhook__doc__},\n\nstatic PyObject *\nos__inputhook_impl(PyObject *module);\n\nstatic PyObject *\nos__inputhook(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os__inputhook_impl(module);\n}\n\nPyDoc_STRVAR(os__is_inputhook_installed__doc__,\n\"_is_inputhook_installed($module, /)\\n\"\n\"--\\n\"\n\"\\n\"\n\"Checks if PyOS_CallInputHook is set\");\n\n#define OS__IS_INPUTHOOK_INSTALLED_METHODDEF    \\\n    {\"_is_inputhook_installed\", (PyCFunction)os__is_inputhook_installed, METH_NOARGS, os__is_inputhook_installed__doc__},\n\nstatic PyObject *\nos__is_inputhook_installed_impl(PyObject *module);\n\nstatic PyObject *\nos__is_inputhook_installed(PyObject *module, PyObject *Py_UNUSED(ignored))\n{\n    return os__is_inputhook_installed_impl(module);\n}\n\n#ifndef OS_TTYNAME_METHODDEF\n    #define OS_TTYNAME_METHODDEF\n#endif /* !defined(OS_TTYNAME_METHODDEF) */\n\n#ifndef OS_CTERMID_METHODDEF\n    #define OS_CTERMID_METHODDEF\n#endif /* !defined(OS_CTERMID_METHODDEF) */\n\n#ifndef OS_FCHDIR_METHODDEF\n    #define OS_FCHDIR_METHODDEF\n#endif /* !defined(OS_FCHDIR_METHODDEF) */\n\n#ifndef OS_FCHMOD_METHODDEF\n    #define OS_FCHMOD_METHODDEF\n#endif /* !defined(OS_FCHMOD_METHODDEF) */\n\n#ifndef OS_LCHMOD_METHODDEF\n    #define OS_LCHMOD_METHODDEF\n#endif /* !defined(OS_LCHMOD_METHODDEF) */\n\n#ifndef OS_CHFLAGS_METHODDEF\n    #define OS_CHFLAGS_METHODDEF\n#endif /* !defined(OS_CHFLAGS_METHODDEF) */\n\n#ifndef OS_LCHFLAGS_METHODDEF\n    #define OS_LCHFLAGS_METHODDEF\n#endif /* !defined(OS_LCHFLAGS_METHODDEF) */\n\n#ifndef OS_CHROOT_METHODDEF\n    #define OS_CHROOT_METHODDEF\n#endif /* !defined(OS_CHROOT_METHODDEF) */\n\n#ifndef OS_FSYNC_METHODDEF\n    #define OS_FSYNC_METHODDEF\n#endif /* !defined(OS_FSYNC_METHODDEF) */\n\n#ifndef OS_SYNC_METHODDEF\n    #define OS_SYNC_METHODDEF\n#endif /* !defined(OS_SYNC_METHODDEF) */\n\n#ifndef OS_FDATASYNC_METHODDEF\n    #define OS_FDATASYNC_METHODDEF\n#endif /* !defined(OS_FDATASYNC_METHODDEF) */\n\n#ifndef OS_CHOWN_METHODDEF\n    #define OS_CHOWN_METHODDEF\n#endif /* !defined(OS_CHOWN_METHODDEF) */\n\n#ifndef OS_FCHOWN_METHODDEF\n    #define OS_FCHOWN_METHODDEF\n#endif /* !defined(OS_FCHOWN_METHODDEF) */\n\n#ifndef OS_LCHOWN_METHODDEF\n    #define OS_LCHOWN_METHODDEF\n#endif /* !defined(OS_LCHOWN_METHODDEF) */\n\n#ifndef OS_LINK_METHODDEF\n    #define OS_LINK_METHODDEF\n#endif /* !defined(OS_LINK_METHODDEF) */\n\n#ifndef OS_LISTDRIVES_METHODDEF\n    #define OS_LISTDRIVES_METHODDEF\n#endif /* !defined(OS_LISTDRIVES_METHODDEF) */\n\n#ifndef OS_LISTVOLUMES_METHODDEF\n    #define OS_LISTVOLUMES_METHODDEF\n#endif /* !defined(OS_LISTVOLUMES_METHODDEF) */\n\n#ifndef OS_LISTMOUNTS_METHODDEF\n    #define OS_LISTMOUNTS_METHODDEF\n#endif /* !defined(OS_LISTMOUNTS_METHODDEF) */\n\n#ifndef OS__PATH_ISDEVDRIVE_METHODDEF\n    #define OS__PATH_ISDEVDRIVE_METHODDEF\n#endif /* !defined(OS__PATH_ISDEVDRIVE_METHODDEF) */\n\n#ifndef OS__GETFULLPATHNAME_METHODDEF\n    #define OS__GETFULLPATHNAME_METHODDEF\n#endif /* !defined(OS__GETFULLPATHNAME_METHODDEF) */\n\n#ifndef OS__GETFINALPATHNAME_METHODDEF\n    #define OS__GETFINALPATHNAME_METHODDEF\n#endif /* !defined(OS__GETFINALPATHNAME_METHODDEF) */\n\n#ifndef OS__FINDFIRSTFILE_METHODDEF\n    #define OS__FINDFIRSTFILE_METHODDEF\n#endif /* !defined(OS__FINDFIRSTFILE_METHODDEF) */\n\n#ifndef OS__GETVOLUMEPATHNAME_METHODDEF\n    #define OS__GETVOLUMEPATHNAME_METHODDEF\n#endif /* !defined(OS__GETVOLUMEPATHNAME_METHODDEF) */\n\n#ifndef OS__PATH_SPLITROOT_METHODDEF\n    #define OS__PATH_SPLITROOT_METHODDEF\n#endif /* !defined(OS__PATH_SPLITROOT_METHODDEF) */\n\n#ifndef OS__PATH_EXISTS_METHODDEF\n    #define OS__PATH_EXISTS_METHODDEF\n#endif /* !defined(OS__PATH_EXISTS_METHODDEF) */\n\n#ifndef OS__PATH_LEXISTS_METHODDEF\n    #define OS__PATH_LEXISTS_METHODDEF\n#endif /* !defined(OS__PATH_LEXISTS_METHODDEF) */\n\n#ifndef OS__PATH_ISDIR_METHODDEF\n    #define OS__PATH_ISDIR_METHODDEF\n#endif /* !defined(OS__PATH_ISDIR_METHODDEF) */\n\n#ifndef OS__PATH_ISFILE_METHODDEF\n    #define OS__PATH_ISFILE_METHODDEF\n#endif /* !defined(OS__PATH_ISFILE_METHODDEF) */\n\n#ifndef OS__PATH_ISLINK_METHODDEF\n    #define OS__PATH_ISLINK_METHODDEF\n#endif /* !defined(OS__PATH_ISLINK_METHODDEF) */\n\n#ifndef OS__PATH_ISJUNCTION_METHODDEF\n    #define OS__PATH_ISJUNCTION_METHODDEF\n#endif /* !defined(OS__PATH_ISJUNCTION_METHODDEF) */\n\n#ifndef OS_NICE_METHODDEF\n    #define OS_NICE_METHODDEF\n#endif /* !defined(OS_NICE_METHODDEF) */\n\n#ifndef OS_GETPRIORITY_METHODDEF\n    #define OS_GETPRIORITY_METHODDEF\n#endif /* !defined(OS_GETPRIORITY_METHODDEF) */\n\n#ifndef OS_SETPRIORITY_METHODDEF\n    #define OS_SETPRIORITY_METHODDEF\n#endif /* !defined(OS_SETPRIORITY_METHODDEF) */\n\n#ifndef OS_SYSTEM_METHODDEF\n    #define OS_SYSTEM_METHODDEF\n#endif /* !defined(OS_SYSTEM_METHODDEF) */\n\n#ifndef OS_UMASK_METHODDEF\n    #define OS_UMASK_METHODDEF\n#endif /* !defined(OS_UMASK_METHODDEF) */\n\n#ifndef OS_UNAME_METHODDEF\n    #define OS_UNAME_METHODDEF\n#endif /* !defined(OS_UNAME_METHODDEF) */\n\n#ifndef OS_EXECV_METHODDEF\n    #define OS_EXECV_METHODDEF\n#endif /* !defined(OS_EXECV_METHODDEF) */\n\n#ifndef OS_EXECVE_METHODDEF\n    #define OS_EXECVE_METHODDEF\n#endif /* !defined(OS_EXECVE_METHODDEF) */\n\n#ifndef OS_POSIX_SPAWN_METHODDEF\n    #define OS_POSIX_SPAWN_METHODDEF\n#endif /* !defined(OS_POSIX_SPAWN_METHODDEF) */\n\n#ifndef OS_POSIX_SPAWNP_METHODDEF\n    #define OS_POSIX_SPAWNP_METHODDEF\n#endif /* !defined(OS_POSIX_SPAWNP_METHODDEF) */\n\n#ifndef OS_SPAWNV_METHODDEF\n    #define OS_SPAWNV_METHODDEF\n#endif /* !defined(OS_SPAWNV_METHODDEF) */\n\n#ifndef OS_SPAWNVE_METHODDEF\n    #define OS_SPAWNVE_METHODDEF\n#endif /* !defined(OS_SPAWNVE_METHODDEF) */\n\n#ifndef OS_REGISTER_AT_FORK_METHODDEF\n    #define OS_REGISTER_AT_FORK_METHODDEF\n#endif /* !defined(OS_REGISTER_AT_FORK_METHODDEF) */\n\n#ifndef OS_FORK1_METHODDEF\n    #define OS_FORK1_METHODDEF\n#endif /* !defined(OS_FORK1_METHODDEF) */\n\n#ifndef OS_FORK_METHODDEF\n    #define OS_FORK_METHODDEF\n#endif /* !defined(OS_FORK_METHODDEF) */\n\n#ifndef OS_SCHED_GET_PRIORITY_MAX_METHODDEF\n    #define OS_SCHED_GET_PRIORITY_MAX_METHODDEF\n#endif /* !defined(OS_SCHED_GET_PRIORITY_MAX_METHODDEF) */\n\n#ifndef OS_SCHED_GET_PRIORITY_MIN_METHODDEF\n    #define OS_SCHED_GET_PRIORITY_MIN_METHODDEF\n#endif /* !defined(OS_SCHED_GET_PRIORITY_MIN_METHODDEF) */\n\n#ifndef OS_SCHED_GETSCHEDULER_METHODDEF\n    #define OS_SCHED_GETSCHEDULER_METHODDEF\n#endif /* !defined(OS_SCHED_GETSCHEDULER_METHODDEF) */\n\n#ifndef OS_SCHED_SETSCHEDULER_METHODDEF\n    #define OS_SCHED_SETSCHEDULER_METHODDEF\n#endif /* !defined(OS_SCHED_SETSCHEDULER_METHODDEF) */\n\n#ifndef OS_SCHED_GETPARAM_METHODDEF\n    #define OS_SCHED_GETPARAM_METHODDEF\n#endif /* !defined(OS_SCHED_GETPARAM_METHODDEF) */\n\n#ifndef OS_SCHED_SETPARAM_METHODDEF\n    #define OS_SCHED_SETPARAM_METHODDEF\n#endif /* !defined(OS_SCHED_SETPARAM_METHODDEF) */\n\n#ifndef OS_SCHED_RR_GET_INTERVAL_METHODDEF\n    #define OS_SCHED_RR_GET_INTERVAL_METHODDEF\n#endif /* !defined(OS_SCHED_RR_GET_INTERVAL_METHODDEF) */\n\n#ifndef OS_SCHED_YIELD_METHODDEF\n    #define OS_SCHED_YIELD_METHODDEF\n#endif /* !defined(OS_SCHED_YIELD_METHODDEF) */\n\n#ifndef OS_SCHED_SETAFFINITY_METHODDEF\n    #define OS_SCHED_SETAFFINITY_METHODDEF\n#endif /* !defined(OS_SCHED_SETAFFINITY_METHODDEF) */\n\n#ifndef OS_SCHED_GETAFFINITY_METHODDEF\n    #define OS_SCHED_GETAFFINITY_METHODDEF\n#endif /* !defined(OS_SCHED_GETAFFINITY_METHODDEF) */\n\n#ifndef OS_POSIX_OPENPT_METHODDEF\n    #define OS_POSIX_OPENPT_METHODDEF\n#endif /* !defined(OS_POSIX_OPENPT_METHODDEF) */\n\n#ifndef OS_GRANTPT_METHODDEF\n    #define OS_GRANTPT_METHODDEF\n#endif /* !defined(OS_GRANTPT_METHODDEF) */\n\n#ifndef OS_UNLOCKPT_METHODDEF\n    #define OS_UNLOCKPT_METHODDEF\n#endif /* !defined(OS_UNLOCKPT_METHODDEF) */\n\n#ifndef OS_PTSNAME_METHODDEF\n    #define OS_PTSNAME_METHODDEF\n#endif /* !defined(OS_PTSNAME_METHODDEF) */\n\n#ifndef OS_OPENPTY_METHODDEF\n    #define OS_OPENPTY_METHODDEF\n#endif /* !defined(OS_OPENPTY_METHODDEF) */\n\n#ifndef OS_LOGIN_TTY_METHODDEF\n    #define OS_LOGIN_TTY_METHODDEF\n#endif /* !defined(OS_LOGIN_TTY_METHODDEF) */\n\n#ifndef OS_FORKPTY_METHODDEF\n    #define OS_FORKPTY_METHODDEF\n#endif /* !defined(OS_FORKPTY_METHODDEF) */\n\n#ifndef OS_GETEGID_METHODDEF\n    #define OS_GETEGID_METHODDEF\n#endif /* !defined(OS_GETEGID_METHODDEF) */\n\n#ifndef OS_GETEUID_METHODDEF\n    #define OS_GETEUID_METHODDEF\n#endif /* !defined(OS_GETEUID_METHODDEF) */\n\n#ifndef OS_GETGID_METHODDEF\n    #define OS_GETGID_METHODDEF\n#endif /* !defined(OS_GETGID_METHODDEF) */\n\n#ifndef OS_GETPID_METHODDEF\n    #define OS_GETPID_METHODDEF\n#endif /* !defined(OS_GETPID_METHODDEF) */\n\n#ifndef OS_GETGROUPLIST_METHODDEF\n    #define OS_GETGROUPLIST_METHODDEF\n#endif /* !defined(OS_GETGROUPLIST_METHODDEF) */\n\n#ifndef OS_GETGROUPS_METHODDEF\n    #define OS_GETGROUPS_METHODDEF\n#endif /* !defined(OS_GETGROUPS_METHODDEF) */\n\n#ifndef OS_INITGROUPS_METHODDEF\n    #define OS_INITGROUPS_METHODDEF\n#endif /* !defined(OS_INITGROUPS_METHODDEF) */\n\n#ifndef OS_GETPGID_METHODDEF\n    #define OS_GETPGID_METHODDEF\n#endif /* !defined(OS_GETPGID_METHODDEF) */\n\n#ifndef OS_GETPGRP_METHODDEF\n    #define OS_GETPGRP_METHODDEF\n#endif /* !defined(OS_GETPGRP_METHODDEF) */\n\n#ifndef OS_SETPGRP_METHODDEF\n    #define OS_SETPGRP_METHODDEF\n#endif /* !defined(OS_SETPGRP_METHODDEF) */\n\n#ifndef OS_GETPPID_METHODDEF\n    #define OS_GETPPID_METHODDEF\n#endif /* !defined(OS_GETPPID_METHODDEF) */\n\n#ifndef OS_GETLOGIN_METHODDEF\n    #define OS_GETLOGIN_METHODDEF\n#endif /* !defined(OS_GETLOGIN_METHODDEF) */\n\n#ifndef OS_GETUID_METHODDEF\n    #define OS_GETUID_METHODDEF\n#endif /* !defined(OS_GETUID_METHODDEF) */\n\n#ifndef OS_KILL_METHODDEF\n    #define OS_KILL_METHODDEF\n#endif /* !defined(OS_KILL_METHODDEF) */\n\n#ifndef OS_KILLPG_METHODDEF\n    #define OS_KILLPG_METHODDEF\n#endif /* !defined(OS_KILLPG_METHODDEF) */\n\n#ifndef OS_PLOCK_METHODDEF\n    #define OS_PLOCK_METHODDEF\n#endif /* !defined(OS_PLOCK_METHODDEF) */\n\n#ifndef OS_SETUID_METHODDEF\n    #define OS_SETUID_METHODDEF\n#endif /* !defined(OS_SETUID_METHODDEF) */\n\n#ifndef OS_SETEUID_METHODDEF\n    #define OS_SETEUID_METHODDEF\n#endif /* !defined(OS_SETEUID_METHODDEF) */\n\n#ifndef OS_SETEGID_METHODDEF\n    #define OS_SETEGID_METHODDEF\n#endif /* !defined(OS_SETEGID_METHODDEF) */\n\n#ifndef OS_SETREUID_METHODDEF\n    #define OS_SETREUID_METHODDEF\n#endif /* !defined(OS_SETREUID_METHODDEF) */\n\n#ifndef OS_SETREGID_METHODDEF\n    #define OS_SETREGID_METHODDEF\n#endif /* !defined(OS_SETREGID_METHODDEF) */\n\n#ifndef OS_SETGID_METHODDEF\n    #define OS_SETGID_METHODDEF\n#endif /* !defined(OS_SETGID_METHODDEF) */\n\n#ifndef OS_SETGROUPS_METHODDEF\n    #define OS_SETGROUPS_METHODDEF\n#endif /* !defined(OS_SETGROUPS_METHODDEF) */\n\n#ifndef OS_WAIT3_METHODDEF\n    #define OS_WAIT3_METHODDEF\n#endif /* !defined(OS_WAIT3_METHODDEF) */\n\n#ifndef OS_WAIT4_METHODDEF\n    #define OS_WAIT4_METHODDEF\n#endif /* !defined(OS_WAIT4_METHODDEF) */\n\n#ifndef OS_WAITID_METHODDEF\n    #define OS_WAITID_METHODDEF\n#endif /* !defined(OS_WAITID_METHODDEF) */\n\n#ifndef OS_WAITPID_METHODDEF\n    #define OS_WAITPID_METHODDEF\n#endif /* !defined(OS_WAITPID_METHODDEF) */\n\n#ifndef OS_WAIT_METHODDEF\n    #define OS_WAIT_METHODDEF\n#endif /* !defined(OS_WAIT_METHODDEF) */\n\n#ifndef OS_PIDFD_OPEN_METHODDEF\n    #define OS_PIDFD_OPEN_METHODDEF\n#endif /* !defined(OS_PIDFD_OPEN_METHODDEF) */\n\n#ifndef OS_SETNS_METHODDEF\n    #define OS_SETNS_METHODDEF\n#endif /* !defined(OS_SETNS_METHODDEF) */\n\n#ifndef OS_UNSHARE_METHODDEF\n    #define OS_UNSHARE_METHODDEF\n#endif /* !defined(OS_UNSHARE_METHODDEF) */\n\n#ifndef OS_READLINK_METHODDEF\n    #define OS_READLINK_METHODDEF\n#endif /* !defined(OS_READLINK_METHODDEF) */\n\n#ifndef OS_SYMLINK_METHODDEF\n    #define OS_SYMLINK_METHODDEF\n#endif /* !defined(OS_SYMLINK_METHODDEF) */\n\n#ifndef OS_TIMERFD_CREATE_METHODDEF\n    #define OS_TIMERFD_CREATE_METHODDEF\n#endif /* !defined(OS_TIMERFD_CREATE_METHODDEF) */\n\n#ifndef OS_TIMERFD_SETTIME_METHODDEF\n    #define OS_TIMERFD_SETTIME_METHODDEF\n#endif /* !defined(OS_TIMERFD_SETTIME_METHODDEF) */\n\n#ifndef OS_TIMERFD_SETTIME_NS_METHODDEF\n    #define OS_TIMERFD_SETTIME_NS_METHODDEF\n#endif /* !defined(OS_TIMERFD_SETTIME_NS_METHODDEF) */\n\n#ifndef OS_TIMERFD_GETTIME_METHODDEF\n    #define OS_TIMERFD_GETTIME_METHODDEF\n#endif /* !defined(OS_TIMERFD_GETTIME_METHODDEF) */\n\n#ifndef OS_TIMERFD_GETTIME_NS_METHODDEF\n    #define OS_TIMERFD_GETTIME_NS_METHODDEF\n#endif /* !defined(OS_TIMERFD_GETTIME_NS_METHODDEF) */\n\n#ifndef OS_GETSID_METHODDEF\n    #define OS_GETSID_METHODDEF\n#endif /* !defined(OS_GETSID_METHODDEF) */\n\n#ifndef OS_SETSID_METHODDEF\n    #define OS_SETSID_METHODDEF\n#endif /* !defined(OS_SETSID_METHODDEF) */\n\n#ifndef OS_SETPGID_METHODDEF\n    #define OS_SETPGID_METHODDEF\n#endif /* !defined(OS_SETPGID_METHODDEF) */\n\n#ifndef OS_TCGETPGRP_METHODDEF\n    #define OS_TCGETPGRP_METHODDEF\n#endif /* !defined(OS_TCGETPGRP_METHODDEF) */\n\n#ifndef OS_TCSETPGRP_METHODDEF\n    #define OS_TCSETPGRP_METHODDEF\n#endif /* !defined(OS_TCSETPGRP_METHODDEF) */\n\n#ifndef OS_DUP2_METHODDEF\n    #define OS_DUP2_METHODDEF\n#endif /* !defined(OS_DUP2_METHODDEF) */\n\n#ifndef OS_LOCKF_METHODDEF\n    #define OS_LOCKF_METHODDEF\n#endif /* !defined(OS_LOCKF_METHODDEF) */\n\n#ifndef OS_READV_METHODDEF\n    #define OS_READV_METHODDEF\n#endif /* !defined(OS_READV_METHODDEF) */\n\n#ifndef OS_PREAD_METHODDEF\n    #define OS_PREAD_METHODDEF\n#endif /* !defined(OS_PREAD_METHODDEF) */\n\n#ifndef OS_PREADV_METHODDEF\n    #define OS_PREADV_METHODDEF\n#endif /* !defined(OS_PREADV_METHODDEF) */\n\n#ifndef OS_SENDFILE_METHODDEF\n    #define OS_SENDFILE_METHODDEF\n#endif /* !defined(OS_SENDFILE_METHODDEF) */\n\n#ifndef OS__FCOPYFILE_METHODDEF\n    #define OS__FCOPYFILE_METHODDEF\n#endif /* !defined(OS__FCOPYFILE_METHODDEF) */\n\n#ifndef OS_PIPE_METHODDEF\n    #define OS_PIPE_METHODDEF\n#endif /* !defined(OS_PIPE_METHODDEF) */\n\n#ifndef OS_PIPE2_METHODDEF\n    #define OS_PIPE2_METHODDEF\n#endif /* !defined(OS_PIPE2_METHODDEF) */\n\n#ifndef OS_WRITEV_METHODDEF\n    #define OS_WRITEV_METHODDEF\n#endif /* !defined(OS_WRITEV_METHODDEF) */\n\n#ifndef OS_PWRITE_METHODDEF\n    #define OS_PWRITE_METHODDEF\n#endif /* !defined(OS_PWRITE_METHODDEF) */\n\n#ifndef OS_PWRITEV_METHODDEF\n    #define OS_PWRITEV_METHODDEF\n#endif /* !defined(OS_PWRITEV_METHODDEF) */\n\n#ifndef OS_COPY_FILE_RANGE_METHODDEF\n    #define OS_COPY_FILE_RANGE_METHODDEF\n#endif /* !defined(OS_COPY_FILE_RANGE_METHODDEF) */\n\n#ifndef OS_SPLICE_METHODDEF\n    #define OS_SPLICE_METHODDEF\n#endif /* !defined(OS_SPLICE_METHODDEF) */\n\n#ifndef OS_MKFIFO_METHODDEF\n    #define OS_MKFIFO_METHODDEF\n#endif /* !defined(OS_MKFIFO_METHODDEF) */\n\n#ifndef OS_MKNOD_METHODDEF\n    #define OS_MKNOD_METHODDEF\n#endif /* !defined(OS_MKNOD_METHODDEF) */\n\n#ifndef OS_MAJOR_METHODDEF\n    #define OS_MAJOR_METHODDEF\n#endif /* !defined(OS_MAJOR_METHODDEF) */\n\n#ifndef OS_MINOR_METHODDEF\n    #define OS_MINOR_METHODDEF\n#endif /* !defined(OS_MINOR_METHODDEF) */\n\n#ifndef OS_MAKEDEV_METHODDEF\n    #define OS_MAKEDEV_METHODDEF\n#endif /* !defined(OS_MAKEDEV_METHODDEF) */\n\n#ifndef OS_FTRUNCATE_METHODDEF\n    #define OS_FTRUNCATE_METHODDEF\n#endif /* !defined(OS_FTRUNCATE_METHODDEF) */\n\n#ifndef OS_TRUNCATE_METHODDEF\n    #define OS_TRUNCATE_METHODDEF\n#endif /* !defined(OS_TRUNCATE_METHODDEF) */\n\n#ifndef OS_POSIX_FALLOCATE_METHODDEF\n    #define OS_POSIX_FALLOCATE_METHODDEF\n#endif /* !defined(OS_POSIX_FALLOCATE_METHODDEF) */\n\n#ifndef OS_POSIX_FADVISE_METHODDEF\n    #define OS_POSIX_FADVISE_METHODDEF\n#endif /* !defined(OS_POSIX_FADVISE_METHODDEF) */\n\n#ifndef OS_PUTENV_METHODDEF\n    #define OS_PUTENV_METHODDEF\n#endif /* !defined(OS_PUTENV_METHODDEF) */\n\n#ifndef OS_UNSETENV_METHODDEF\n    #define OS_UNSETENV_METHODDEF\n#endif /* !defined(OS_UNSETENV_METHODDEF) */\n\n#ifndef OS_WCOREDUMP_METHODDEF\n    #define OS_WCOREDUMP_METHODDEF\n#endif /* !defined(OS_WCOREDUMP_METHODDEF) */\n\n#ifndef OS_WIFCONTINUED_METHODDEF\n    #define OS_WIFCONTINUED_METHODDEF\n#endif /* !defined(OS_WIFCONTINUED_METHODDEF) */\n\n#ifndef OS_WIFSTOPPED_METHODDEF\n    #define OS_WIFSTOPPED_METHODDEF\n#endif /* !defined(OS_WIFSTOPPED_METHODDEF) */\n\n#ifndef OS_WIFSIGNALED_METHODDEF\n    #define OS_WIFSIGNALED_METHODDEF\n#endif /* !defined(OS_WIFSIGNALED_METHODDEF) */\n\n#ifndef OS_WIFEXITED_METHODDEF\n    #define OS_WIFEXITED_METHODDEF\n#endif /* !defined(OS_WIFEXITED_METHODDEF) */\n\n#ifndef OS_WEXITSTATUS_METHODDEF\n    #define OS_WEXITSTATUS_METHODDEF\n#endif /* !defined(OS_WEXITSTATUS_METHODDEF) */\n\n#ifndef OS_WTERMSIG_METHODDEF\n    #define OS_WTERMSIG_METHODDEF\n#endif /* !defined(OS_WTERMSIG_METHODDEF) */\n\n#ifndef OS_WSTOPSIG_METHODDEF\n    #define OS_WSTOPSIG_METHODDEF\n#endif /* !defined(OS_WSTOPSIG_METHODDEF) */\n\n#ifndef OS_FSTATVFS_METHODDEF\n    #define OS_FSTATVFS_METHODDEF\n#endif /* !defined(OS_FSTATVFS_METHODDEF) */\n\n#ifndef OS_STATVFS_METHODDEF\n    #define OS_STATVFS_METHODDEF\n#endif /* !defined(OS_STATVFS_METHODDEF) */\n\n#ifndef OS__GETDISKUSAGE_METHODDEF\n    #define OS__GETDISKUSAGE_METHODDEF\n#endif /* !defined(OS__GETDISKUSAGE_METHODDEF) */\n\n#ifndef OS_FPATHCONF_METHODDEF\n    #define OS_FPATHCONF_METHODDEF\n#endif /* !defined(OS_FPATHCONF_METHODDEF) */\n\n#ifndef OS_PATHCONF_METHODDEF\n    #define OS_PATHCONF_METHODDEF\n#endif /* !defined(OS_PATHCONF_METHODDEF) */\n\n#ifndef OS_CONFSTR_METHODDEF\n    #define OS_CONFSTR_METHODDEF\n#endif /* !defined(OS_CONFSTR_METHODDEF) */\n\n#ifndef OS_SYSCONF_METHODDEF\n    #define OS_SYSCONF_METHODDEF\n#endif /* !defined(OS_SYSCONF_METHODDEF) */\n\n#ifndef OS_STARTFILE_METHODDEF\n    #define OS_STARTFILE_METHODDEF\n#endif /* !defined(OS_STARTFILE_METHODDEF) */\n\n#ifndef OS_GETLOADAVG_METHODDEF\n    #define OS_GETLOADAVG_METHODDEF\n#endif /* !defined(OS_GETLOADAVG_METHODDEF) */\n\n#ifndef OS_SETRESUID_METHODDEF\n    #define OS_SETRESUID_METHODDEF\n#endif /* !defined(OS_SETRESUID_METHODDEF) */\n\n#ifndef OS_SETRESGID_METHODDEF\n    #define OS_SETRESGID_METHODDEF\n#endif /* !defined(OS_SETRESGID_METHODDEF) */\n\n#ifndef OS_GETRESUID_METHODDEF\n    #define OS_GETRESUID_METHODDEF\n#endif /* !defined(OS_GETRESUID_METHODDEF) */\n\n#ifndef OS_GETRESGID_METHODDEF\n    #define OS_GETRESGID_METHODDEF\n#endif /* !defined(OS_GETRESGID_METHODDEF) */\n\n#ifndef OS_GETXATTR_METHODDEF\n    #define OS_GETXATTR_METHODDEF\n#endif /* !defined(OS_GETXATTR_METHODDEF) */\n\n#ifndef OS_SETXATTR_METHODDEF\n    #define OS_SETXATTR_METHODDEF\n#endif /* !defined(OS_SETXATTR_METHODDEF) */\n\n#ifndef OS_REMOVEXATTR_METHODDEF\n    #define OS_REMOVEXATTR_METHODDEF\n#endif /* !defined(OS_REMOVEXATTR_METHODDEF) */\n\n#ifndef OS_LISTXATTR_METHODDEF\n    #define OS_LISTXATTR_METHODDEF\n#endif /* !defined(OS_LISTXATTR_METHODDEF) */\n\n#ifndef OS_MEMFD_CREATE_METHODDEF\n    #define OS_MEMFD_CREATE_METHODDEF\n#endif /* !defined(OS_MEMFD_CREATE_METHODDEF) */\n\n#ifndef OS_EVENTFD_METHODDEF\n    #define OS_EVENTFD_METHODDEF\n#endif /* !defined(OS_EVENTFD_METHODDEF) */\n\n#ifndef OS_EVENTFD_READ_METHODDEF\n    #define OS_EVENTFD_READ_METHODDEF\n#endif /* !defined(OS_EVENTFD_READ_METHODDEF) */\n\n#ifndef OS_EVENTFD_WRITE_METHODDEF\n    #define OS_EVENTFD_WRITE_METHODDEF\n#endif /* !defined(OS_EVENTFD_WRITE_METHODDEF) */\n\n#ifndef OS_GET_TERMINAL_SIZE_METHODDEF\n    #define OS_GET_TERMINAL_SIZE_METHODDEF\n#endif /* !defined(OS_GET_TERMINAL_SIZE_METHODDEF) */\n\n#ifndef OS_GET_HANDLE_INHERITABLE_METHODDEF\n    #define OS_GET_HANDLE_INHERITABLE_METHODDEF\n#endif /* !defined(OS_GET_HANDLE_INHERITABLE_METHODDEF) */\n\n#ifndef OS_SET_HANDLE_INHERITABLE_METHODDEF\n    #define OS_SET_HANDLE_INHERITABLE_METHODDEF\n#endif /* !defined(OS_SET_HANDLE_INHERITABLE_METHODDEF) */\n\n#ifndef OS_GETRANDOM_METHODDEF\n    #define OS_GETRANDOM_METHODDEF\n#endif /* !defined(OS_GETRANDOM_METHODDEF) */\n\n#ifndef OS__ADD_DLL_DIRECTORY_METHODDEF\n    #define OS__ADD_DLL_DIRECTORY_METHODDEF\n#endif /* !defined(OS__ADD_DLL_DIRECTORY_METHODDEF) */\n\n#ifndef OS__REMOVE_DLL_DIRECTORY_METHODDEF\n    #define OS__REMOVE_DLL_DIRECTORY_METHODDEF\n#endif /* !defined(OS__REMOVE_DLL_DIRECTORY_METHODDEF) */\n\n#ifndef OS_WAITSTATUS_TO_EXITCODE_METHODDEF\n    #define OS_WAITSTATUS_TO_EXITCODE_METHODDEF\n#endif /* !defined(OS_WAITSTATUS_TO_EXITCODE_METHODDEF) */\n\n#ifndef OS__SUPPORTS_VIRTUAL_TERMINAL_METHODDEF\n    #define OS__SUPPORTS_VIRTUAL_TERMINAL_METHODDEF\n#endif /* !defined(OS__SUPPORTS_VIRTUAL_TERMINAL_METHODDEF) */\n/*[clinic end generated code: output=cebab1ef718b4878 input=a9049054013a1b77]*/\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "/usr/include/sys/statvfs.h"},
                          "contents": {"text": "/* Definitions for getting information about a filesystem.\n   Copyright (C) 1998-2024 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <https://www.gnu.org/licenses/>.  */\n\n#ifndef\t_SYS_STATVFS_H\n#define\t_SYS_STATVFS_H\t1\n\n#include <features.h>\n\n/* Get the system-specific definition of `struct statvfs'.  */\n#include <bits/statvfs.h>\n\n#ifndef __USE_FILE_OFFSET64\n# ifndef __fsblkcnt_t_defined\ntypedef __fsblkcnt_t fsblkcnt_t; /* Type to count file system blocks.  */\n#  define __fsblkcnt_t_defined\n# endif\n# ifndef __fsfilcnt_t_defined\ntypedef __fsfilcnt_t fsfilcnt_t; /* Type to count file system inodes.  */\n#  define __fsfilcnt_t_defined\n# endif\n#else\n# ifndef __fsblkcnt_t_defined\ntypedef __fsblkcnt64_t fsblkcnt_t; /* Type to count file system blocks.  */\n#  define __fsblkcnt_t_defined\n# endif\n# ifndef __fsfilcnt_t_defined\ntypedef __fsfilcnt64_t fsfilcnt_t; /* Type to count file system inodes.  */\n#  define __fsfilcnt_t_defined\n# endif\n#endif\n\n__BEGIN_DECLS\n\n/* Return information about the filesystem on which FILE resides.  */\n#ifndef __USE_FILE_OFFSET64\nextern int statvfs (const char *__restrict __file,\n\t\t    struct statvfs *__restrict __buf)\n     __THROW __nonnull ((1, 2));\n#else\n# ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (statvfs,\n\t\t\t   (const char *__restrict __file,\n\t\t\t    struct statvfs *__restrict __buf), statvfs64)\n     __nonnull ((1, 2));\n# else\n#  define statvfs statvfs64\n# endif\n#endif\n#ifdef __USE_LARGEFILE64\nextern int statvfs64 (const char *__restrict __file,\n\t\t      struct statvfs64 *__restrict __buf)\n     __THROW __nonnull ((1, 2));\n#endif\n\n/* Return information about the filesystem containing the file FILDES\n   refers to.  */\n#ifndef __USE_FILE_OFFSET64\nextern int fstatvfs (int __fildes, struct statvfs *__buf)\n     __THROW __nonnull ((2));\n#else\n# ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (fstatvfs, (int __fildes, struct statvfs *__buf),\n\t\t\t   fstatvfs64) __nonnull ((2));\n# else\n#  define fstatvfs fstatvfs64\n# endif\n#endif\n#ifdef __USE_LARGEFILE64\nextern int fstatvfs64 (int __fildes, struct statvfs64 *__buf)\n     __THROW __nonnull ((2));\n#endif\n\n__END_DECLS\n\n#endif\t/* sys/statvfs.h */\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Modules/posixmodule.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/* POSIX module implementation */\n\n/* This file is also used for Windows NT/MS-Win.  In that case the\n   module actually calls itself 'nt', not 'posix', and a few\n   functions are either unimplemented or implemented differently.  The source\n   assumes that for Windows NT, the macro 'MS_WINDOWS' is defined independent\n   of the compiler used.  Different compilers define their own feature\n   test macro, e.g. '_MSC_VER'. */\n\n#include \"Python.h\"\n\n#ifdef __VXWORKS__\n#  include \"pycore_bitutils.h\"    // _Py_popcount32()\n#endif\n#include \"pycore_abstract.h\"      // _PyNumber_Index()\n#include \"pycore_call.h\"          // _PyObject_CallNoArgs()\n#include \"pycore_ceval.h\"         // _PyEval_ReInitThreads()\n#include \"pycore_fileutils.h\"     // _Py_closerange()\n#include \"pycore_initconfig.h\"    // _PyStatus_EXCEPTION()\n#include \"pycore_long.h\"          // _PyLong_IsNegative()\n#include \"pycore_moduleobject.h\"  // _PyModule_GetState()\n#include \"pycore_object.h\"        // _PyObject_LookupSpecial()\n#include \"pycore_pylifecycle.h\"   // _PyOS_URandom()\n#include \"pycore_pystate.h\"       // _PyInterpreterState_GET()\n#include \"pycore_signal.h\"        // Py_NSIG\n#include \"pycore_time.h\"          // _PyLong_FromTime_t()\n\n#ifdef HAVE_UNISTD_H\n#  include <unistd.h>             // symlink()\n#endif\n\n#ifdef MS_WINDOWS\n#  include <windows.h>\n#  if !defined(MS_WINDOWS_GAMES) || defined(MS_WINDOWS_DESKTOP)\n#    include <pathcch.h>\n#  endif\n#  include <winioctl.h>\n#  include <lmcons.h>             // UNLEN\n#  include \"osdefs.h\"             // SEP\n#  include <aclapi.h>             // SetEntriesInAcl\n#  include <sddl.h>               // SDDL_REVISION_1\n#  if defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_SYSTEM)\n#    define HAVE_SYMLINK\n#  endif /* MS_WINDOWS_DESKTOP | MS_WINDOWS_SYSTEM */\n#endif\n\n#ifndef MS_WINDOWS\n#  include \"posixmodule.h\"\n#else\n#  include \"pycore_fileutils_windows.h\"\n#  include \"winreparse.h\"\n#endif\n\n#if !defined(EX_OK) && defined(EXIT_SUCCESS)\n#  define EX_OK EXIT_SUCCESS\n#endif\n\n#ifdef __APPLE__\n /* Needed for the implementation of os.statvfs */\n#  include <sys/param.h>\n#  include <sys/mount.h>\n#endif\n\n/* On android API level 21, 'AT_EACCESS' is not declared although\n * HAVE_FACCESSAT is defined. */\n#ifdef __ANDROID__\n#  undef HAVE_FACCESSAT\n#endif\n\n#include <stdio.h>                // ctermid()\n#include <stdlib.h>               // system()\n#ifdef HAVE_SYS_TIME_H\n#  include <sys/time.h>           // futimes()\n#endif\n\n\n// SGI apparently needs this forward declaration\n#ifdef HAVE__GETPTY\n#  include <sys/types.h>          // mode_t\n   extern char * _getpty(int *, int, mode_t, int);\n#endif\n\n\n/*\n * A number of APIs are available on macOS from a certain macOS version.\n * To support building with a new SDK while deploying to older versions\n * the availability test is split into two:\n *   - HAVE_<FUNCTION>:  The configure check for compile time availability\n *   - HAVE_<FUNCTION>_RUNTIME: Runtime check for availability\n *\n * The latter is always true when not on macOS, or when using a compiler\n * that does not support __has_builtin (older versions of Xcode).\n *\n * Due to compiler restrictions there is one valid use of HAVE_<FUNCTION>_RUNTIME:\n *    if (HAVE_<FUNCTION>_RUNTIME) { ... }\n *\n * In mixing the test with other tests or using negations will result in compile\n * errors.\n */\n#if defined(__APPLE__)\n\n#include <mach/mach.h>\n\n#if defined(__has_builtin)\n#if __has_builtin(__builtin_available)\n#define HAVE_BUILTIN_AVAILABLE 1\n#endif\n#endif\n\n#ifdef HAVE_BUILTIN_AVAILABLE\n#  define HAVE_FSTATAT_RUNTIME __builtin_available(macOS 10.10, iOS 8.0, *)\n#  define HAVE_FACCESSAT_RUNTIME __builtin_available(macOS 10.10, iOS 8.0, *)\n#  define HAVE_FCHMODAT_RUNTIME __builtin_available(macOS 10.10, iOS 8.0, *)\n#  define HAVE_FCHOWNAT_RUNTIME __builtin_available(macOS 10.10, iOS 8.0, *)\n#  define HAVE_LINKAT_RUNTIME __builtin_available(macOS 10.10, iOS 8.0, *)\n#  define HAVE_FDOPENDIR_RUNTIME __builtin_available(macOS 10.10, iOS 8.0, *)\n#  define HAVE_MKDIRAT_RUNTIME __builtin_available(macOS 10.10, iOS 8.0, *)\n#  define HAVE_RENAMEAT_RUNTIME __builtin_available(macOS 10.10, iOS 8.0, *)\n#  define HAVE_UNLINKAT_RUNTIME __builtin_available(macOS 10.10, iOS 8.0, *)\n#  define HAVE_OPENAT_RUNTIME __builtin_available(macOS 10.10, iOS 8.0, *)\n#  define HAVE_READLINKAT_RUNTIME __builtin_available(macOS 10.10, iOS 8.0, *)\n#  define HAVE_SYMLINKAT_RUNTIME __builtin_available(macOS 10.10, iOS 8.0, *)\n#  define HAVE_FUTIMENS_RUNTIME __builtin_available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)\n#  define HAVE_UTIMENSAT_RUNTIME __builtin_available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)\n#  define HAVE_PWRITEV_RUNTIME __builtin_available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)\n#  define HAVE_MKFIFOAT_RUNTIME __builtin_available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)\n#  define HAVE_MKNODAT_RUNTIME __builtin_available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)\n\n#  define HAVE_POSIX_SPAWN_SETSID_RUNTIME __builtin_available(macOS 10.15, *)\n\n#else /* Xcode 8 or earlier */\n\n   /* __builtin_available is not present in these compilers, but\n    * some of the symbols might be weak linked (10.10 SDK or later\n    * deploying on 10.9.\n    *\n    * Fall back to the older style of availability checking for\n    * symbols introduced in macOS 10.10.\n    */\n\n#  ifdef HAVE_FSTATAT\n#    define HAVE_FSTATAT_RUNTIME (fstatat != NULL)\n#  endif\n\n#  ifdef HAVE_FACCESSAT\n#    define HAVE_FACCESSAT_RUNTIME (faccessat != NULL)\n#  endif\n\n#  ifdef HAVE_FCHMODAT\n#    define HAVE_FCHMODAT_RUNTIME (fchmodat != NULL)\n#  endif\n\n#  ifdef HAVE_FCHOWNAT\n#    define HAVE_FCHOWNAT_RUNTIME (fchownat != NULL)\n#  endif\n\n#  ifdef HAVE_LINKAT\n#    define HAVE_LINKAT_RUNTIME (linkat != NULL)\n#  endif\n\n#  ifdef HAVE_FDOPENDIR\n#    define HAVE_FDOPENDIR_RUNTIME (fdopendir != NULL)\n#  endif\n\n#  ifdef HAVE_MKDIRAT\n#    define HAVE_MKDIRAT_RUNTIME (mkdirat != NULL)\n#  endif\n\n#  ifdef HAVE_RENAMEAT\n#    define HAVE_RENAMEAT_RUNTIME (renameat != NULL)\n#  endif\n\n#  ifdef HAVE_UNLINKAT\n#    define HAVE_UNLINKAT_RUNTIME (unlinkat != NULL)\n#  endif\n\n#  ifdef HAVE_OPENAT\n#    define HAVE_OPENAT_RUNTIME (openat != NULL)\n#  endif\n\n#  ifdef HAVE_READLINKAT\n#    define HAVE_READLINKAT_RUNTIME (readlinkat != NULL)\n#  endif\n\n#  ifdef HAVE_SYMLINKAT\n#    define HAVE_SYMLINKAT_RUNTIME (symlinkat != NULL)\n#  endif\n\n#  ifdef HAVE_UTIMENSAT\n#    define HAVE_UTIMENSAT_RUNTIME (utimensat != NULL)\n#  endif\n\n#  ifdef HAVE_FUTIMENS\n#    define HAVE_FUTIMENS_RUNTIME (futimens != NULL)\n#  endif\n\n#  ifdef HAVE_PWRITEV\n#    define HAVE_PWRITEV_RUNTIME (pwritev != NULL)\n#  endif\n\n#  ifdef HAVE_MKFIFOAT\n#    define HAVE_MKFIFOAT_RUNTIME (mkfifoat != NULL)\n#  endif\n\n#  ifdef HAVE_MKNODAT\n#    define HAVE_MKNODAT_RUNTIME (mknodat != NULL)\n#  endif\n\n#endif\n\n#ifdef HAVE_FUTIMESAT\n/* Some of the logic for weak linking depends on this assertion */\n# error \"HAVE_FUTIMESAT unexpectedly defined\"\n#endif\n\n#else\n#  define HAVE_FSTATAT_RUNTIME 1\n#  define HAVE_FACCESSAT_RUNTIME 1\n#  define HAVE_FCHMODAT_RUNTIME 1\n#  define HAVE_FCHOWNAT_RUNTIME 1\n#  define HAVE_LINKAT_RUNTIME 1\n#  define HAVE_FDOPENDIR_RUNTIME 1\n#  define HAVE_MKDIRAT_RUNTIME 1\n#  define HAVE_RENAMEAT_RUNTIME 1\n#  define HAVE_UNLINKAT_RUNTIME 1\n#  define HAVE_OPENAT_RUNTIME 1\n#  define HAVE_READLINKAT_RUNTIME 1\n#  define HAVE_SYMLINKAT_RUNTIME 1\n#  define HAVE_FUTIMENS_RUNTIME 1\n#  define HAVE_UTIMENSAT_RUNTIME 1\n#  define HAVE_PWRITEV_RUNTIME 1\n#  define HAVE_MKFIFOAT_RUNTIME 1\n#  define HAVE_MKNODAT_RUNTIME 1\n#endif\n\n\nPyDoc_STRVAR(posix__doc__,\n\"This module provides access to operating system functionality that is\\n\\\nstandardized by the C Standard and the POSIX standard (a thinly\\n\\\ndisguised Unix interface).  Refer to the library manual and\\n\\\ncorresponding Unix manual entries for more information on calls.\");\n\n\n#ifdef HAVE_SYS_UIO_H\n#  include <sys/uio.h>\n#endif\n\n#ifdef HAVE_SYS_TYPES_H\n/* Should be included before <sys/sysmacros.h> on HP-UX v3 */\n#  include <sys/types.h>\n#endif /* HAVE_SYS_TYPES_H */\n\n#ifdef HAVE_SYS_SYSMACROS_H\n/* GNU C Library: major(), minor(), makedev() */\n#  include <sys/sysmacros.h>\n#endif\n\n#ifdef HAVE_SYS_STAT_H\n#  include <sys/stat.h>\n#endif /* HAVE_SYS_STAT_H */\n\n#ifdef HAVE_SYS_WAIT_H\n#  include <sys/wait.h>           // WNOHANG\n#endif\n#ifdef HAVE_LINUX_WAIT_H\n#  include <linux/wait.h>         // P_PIDFD\n#endif\n\n#ifdef HAVE_SIGNAL_H\n#  include <signal.h>\n#endif\n\n#ifdef HAVE_FCNTL_H\n#  include <fcntl.h>\n#endif\n\n#ifdef HAVE_GRP_H\n#  include <grp.h>\n#endif\n\n#ifdef HAVE_SYSEXITS_H\n#  include <sysexits.h>\n#endif\n\n#ifdef HAVE_SYS_LOADAVG_H\n#  include <sys/loadavg.h>\n#endif\n\n#ifdef HAVE_SYS_SENDFILE_H\n#  include <sys/sendfile.h>\n#endif\n\n#if defined(__APPLE__)\n#  include <copyfile.h>\n#endif\n\n#ifdef HAVE_SCHED_H\n#  include <sched.h>\n#endif\n\n#if !defined(CPU_ALLOC) && defined(HAVE_SCHED_SETAFFINITY)\n#  undef HAVE_SCHED_SETAFFINITY\n#endif\n\n#if defined(HAVE_SYS_XATTR_H)\n#  if defined(HAVE_LINUX_LIMITS_H) && !defined(__FreeBSD_kernel__) && !defined(__GNU__)\n#    define USE_XATTRS\n#    include <linux/limits.h>  // Needed for XATTR_SIZE_MAX on musl libc.\n#  endif\n#  if defined(__CYGWIN__)\n#    define USE_XATTRS\n#    include <cygwin/limits.h>  // Needed for XATTR_SIZE_MAX and XATTR_LIST_MAX.\n#  endif\n#endif\n\n#ifdef USE_XATTRS\n#  include <sys/xattr.h>\n#endif\n\n#if defined(__FreeBSD__) || defined(__DragonFly__) || defined(__APPLE__)\n#  ifdef HAVE_SYS_SOCKET_H\n#    include <sys/socket.h>\n#  endif\n#endif\n\n#ifdef HAVE_DLFCN_H\n#  include <dlfcn.h>\n#endif\n\n#ifdef __hpux\n#  include <sys/mpctl.h>\n#endif\n\n#if defined(__DragonFly__) || \\\n    defined(__OpenBSD__)   || \\\n    defined(__FreeBSD__)   || \\\n    defined(__NetBSD__)    || \\\n    defined(__APPLE__)\n#  include <sys/sysctl.h>\n#endif\n\n#ifdef HAVE_LINUX_RANDOM_H\n#  include <linux/random.h>\n#endif\n#ifdef HAVE_GETRANDOM_SYSCALL\n#  include <sys/syscall.h>\n#endif\n\n#ifdef HAVE_WINDOWS_CONSOLE_IO\n#  define TERMSIZE_USE_CONIO\n#elif defined(HAVE_SYS_IOCTL_H)\n#  include <sys/ioctl.h>\n#  if defined(HAVE_TERMIOS_H)\n#    include <termios.h>\n#  endif\n#  if defined(TIOCGWINSZ)\n#    define TERMSIZE_USE_IOCTL\n#  endif\n#endif /* HAVE_WINDOWS_CONSOLE_IO */\n\n/* Various compilers have only certain posix functions */\n/* XXX Gosh I wish these were all moved into pyconfig.h */\n#if defined(__WATCOMC__) && !defined(__QNX__)           /* Watcom compiler */\n#  define HAVE_OPENDIR    1\n#  define HAVE_SYSTEM     1\n#  include <process.h>\n#elif defined( _MSC_VER)\n  /* Microsoft compiler */\n#  if defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_APP) || defined(MS_WINDOWS_SYSTEM)\n#    define HAVE_GETPPID    1\n#  endif /* MS_WINDOWS_DESKTOP | MS_WINDOWS_APP | MS_WINDOWS_SYSTEM */\n#  if defined(MS_WINDOWS_DESKTOP)\n#    define HAVE_GETLOGIN   1\n#  endif /* MS_WINDOWS_DESKTOP */\n#  if defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_SYSTEM)\n#    define HAVE_SPAWNV     1\n#    define HAVE_EXECV      1\n#    define HAVE_WSPAWNV    1\n#    define HAVE_WEXECV     1\n#    define HAVE_SYSTEM     1\n#    define HAVE_CWAIT      1\n#  endif /* MS_WINDOWS_DESKTOP | MS_WINDOWS_SYSTEM */\n#  define HAVE_PIPE       1\n#  define HAVE_FSYNC      1\n#  define fsync _commit\n#endif  /* ! __WATCOMC__ || __QNX__ */\n\n/*[clinic input]\n# one of the few times we lie about this name!\nmodule os\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=94a0f0f978acae17]*/\n\n#ifndef _MSC_VER\n\n#if defined(__sgi)&&_COMPILER_VERSION>=700\n/* declare ctermid_r if compiling with MIPSPro 7.x in ANSI C mode\n   (default) */\nextern char        *ctermid_r(char *);\n#endif\n\n#endif /* !_MSC_VER */\n\n#if defined(__VXWORKS__)\n#  include <vxCpuLib.h>\n#  include <rtpLib.h>\n#  include <wait.h>\n#  include <taskLib.h>\n#  ifndef _P_WAIT\n#    define _P_WAIT          0\n#    define _P_NOWAIT        1\n#    define _P_NOWAITO       1\n#  endif\n#endif /* __VXWORKS__ */\n\n#ifdef HAVE_POSIX_SPAWN\n#  include <spawn.h>\n#endif\n\n#ifdef HAVE_UTIME_H\n#  include <utime.h>\n#endif /* HAVE_UTIME_H */\n\n#ifdef HAVE_SYS_UTIME_H\n#  include <sys/utime.h>\n#  define HAVE_UTIME_H /* pretend we do for the rest of this file */\n#endif /* HAVE_SYS_UTIME_H */\n\n#ifdef HAVE_SYS_TIMES_H\n#  include <sys/times.h>\n#endif /* HAVE_SYS_TIMES_H */\n\n#ifdef HAVE_SYS_PARAM_H\n#  include <sys/param.h>\n#endif /* HAVE_SYS_PARAM_H */\n\n#ifdef HAVE_SYS_UTSNAME_H\n#  include <sys/utsname.h>\n#endif /* HAVE_SYS_UTSNAME_H */\n\n#ifdef HAVE_DIRENT_H\n#  include <dirent.h>\n#  define NAMLEN(dirent) strlen((dirent)->d_name)\n#else\n#  if defined(__WATCOMC__) && !defined(__QNX__)\n#    include <direct.h>\n#    define NAMLEN(dirent) strlen((dirent)->d_name)\n#  else\n#    define dirent direct\n#    define NAMLEN(dirent) (dirent)->d_namlen\n#  endif\n#  ifdef HAVE_SYS_NDIR_H\n#    include <sys/ndir.h>\n#  endif\n#  ifdef HAVE_SYS_DIR_H\n#    include <sys/dir.h>\n#  endif\n#  ifdef HAVE_NDIR_H\n#    include <ndir.h>\n#  endif\n#endif\n\n#ifdef _MSC_VER\n#  ifdef HAVE_DIRECT_H\n#    include <direct.h>\n#  endif\n#  ifdef HAVE_IO_H\n#    include <io.h>\n#  endif\n#  ifdef HAVE_PROCESS_H\n#    include <process.h>\n#  endif\n#  include <malloc.h>\n#endif /* _MSC_VER */\n\n#ifndef MAXPATHLEN\n#  if defined(PATH_MAX) && PATH_MAX > 1024\n#    define MAXPATHLEN PATH_MAX\n#  else\n#    define MAXPATHLEN 1024\n#  endif\n#endif /* MAXPATHLEN */\n\n#ifdef UNION_WAIT\n   /* Emulate some macros on systems that have a union instead of macros */\n#  ifndef WIFEXITED\n#    define WIFEXITED(u_wait) (!(u_wait).w_termsig && !(u_wait).w_coredump)\n#  endif\n#  ifndef WEXITSTATUS\n#    define WEXITSTATUS(u_wait) (WIFEXITED(u_wait)?((u_wait).w_retcode):-1)\n#  endif\n#  ifndef WTERMSIG\n#    define WTERMSIG(u_wait) ((u_wait).w_termsig)\n#  endif\n#  define WAIT_TYPE union wait\n#  define WAIT_STATUS_INT(s) (s.w_status)\n#else\n   /* !UNION_WAIT */\n#  define WAIT_TYPE int\n#  define WAIT_STATUS_INT(s) (s)\n#endif /* UNION_WAIT */\n\n/* Don't use the \"_r\" form if we don't need it (also, won't have a\n   prototype for it, at least on Solaris -- maybe others as well?). */\n#if defined(HAVE_CTERMID_R)\n#  define USE_CTERMID_R\n#endif\n\n/* choose the appropriate stat and fstat functions and return structs */\n#undef STAT\n#undef FSTAT\n#undef STRUCT_STAT\n#ifdef MS_WINDOWS\n#  define STAT win32_stat\n#  define LSTAT win32_lstat\n#  define FSTAT _Py_fstat_noraise\n#  define STRUCT_STAT struct _Py_stat_struct\n#else\n#  define STAT stat\n#  define LSTAT lstat\n#  define FSTAT fstat\n#  define STRUCT_STAT struct stat\n#endif\n\n#if defined(MAJOR_IN_MKDEV)\n#  include <sys/mkdev.h>\n#else\n#  if defined(MAJOR_IN_SYSMACROS)\n#    include <sys/sysmacros.h>\n#  endif\n#  if defined(HAVE_MKNOD) && defined(HAVE_SYS_MKDEV_H)\n#    include <sys/mkdev.h>\n#  endif\n#endif\n\n#ifdef MS_WINDOWS\n#  define INITFUNC PyInit_nt\n#  define MODNAME \"nt\"\n#  define MODNAME_OBJ &_Py_ID(nt)\n#else\n#  define INITFUNC PyInit_posix\n#  define MODNAME \"posix\"\n#  define MODNAME_OBJ &_Py_ID(posix)\n#endif\n\n#if defined(__sun)\n/* Something to implement in autoconf, not present in autoconf 2.69 */\n#  define HAVE_STRUCT_STAT_ST_FSTYPE 1\n#endif\n\n/* memfd_create is either defined in sys/mman.h or sys/memfd.h\n * linux/memfd.h defines additional flags\n */\n#ifdef HAVE_SYS_MMAN_H\n#  include <sys/mman.h>\n#endif\n#ifdef HAVE_SYS_MEMFD_H\n#  include <sys/memfd.h>\n#endif\n#ifdef HAVE_LINUX_MEMFD_H\n#  include <linux/memfd.h>\n#endif\n\n/* eventfd() */\n#ifdef HAVE_SYS_EVENTFD_H\n#  include <sys/eventfd.h>\n#endif\n\n/* timerfd_create() */\n#ifdef HAVE_SYS_TIMERFD_H\n#  include <sys/timerfd.h>\n#endif\n\n#ifdef _Py_MEMORY_SANITIZER\n#  include <sanitizer/msan_interface.h>\n#endif\n\n#ifdef HAVE_FORK\nstatic void\nrun_at_forkers(PyObject *lst, int reverse)\n{\n    Py_ssize_t i;\n    PyObject *cpy;\n\n    if (lst != NULL) {\n        assert(PyList_CheckExact(lst));\n\n        /* Use a list copy in case register_at_fork() is called from\n         * one of the callbacks.\n         */\n        cpy = PyList_GetSlice(lst, 0, PyList_GET_SIZE(lst));\n        if (cpy == NULL)\n            PyErr_WriteUnraisable(lst);\n        else {\n            if (reverse)\n                PyList_Reverse(cpy);\n            for (i = 0; i < PyList_GET_SIZE(cpy); i++) {\n                PyObject *func, *res;\n                func = PyList_GET_ITEM(cpy, i);\n                res = _PyObject_CallNoArgs(func);\n                if (res == NULL)\n                    PyErr_WriteUnraisable(func);\n                else\n                    Py_DECREF(res);\n            }\n            Py_DECREF(cpy);\n        }\n    }\n}\n\nvoid\nPyOS_BeforeFork(void)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    run_at_forkers(interp->before_forkers, 1);\n\n    _PyImport_AcquireLock(interp);\n    _PyEval_StopTheWorldAll(&_PyRuntime);\n    HEAD_LOCK(&_PyRuntime);\n}\n\nvoid\nPyOS_AfterFork_Parent(void)\n{\n    HEAD_UNLOCK(&_PyRuntime);\n    _PyEval_StartTheWorldAll(&_PyRuntime);\n\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    _PyImport_ReleaseLock(interp);\n    run_at_forkers(interp->after_forkers_parent, 0);\n}\n\nvoid\nPyOS_AfterFork_Child(void)\n{\n    PyStatus status;\n    _PyRuntimeState *runtime = &_PyRuntime;\n\n    // re-creates runtime->interpreters.mutex (HEAD_UNLOCK)\n    status = _PyRuntimeState_ReInitThreads(runtime);\n    if (_PyStatus_EXCEPTION(status)) {\n        goto fatal_error;\n    }\n\n    PyThreadState *tstate = _PyThreadState_GET();\n    _Py_EnsureTstateNotNULL(tstate);\n\n    assert(tstate->thread_id == PyThread_get_thread_ident());\n#ifdef PY_HAVE_THREAD_NATIVE_ID\n    tstate->native_thread_id = PyThread_get_thread_native_id();\n#endif\n\n#ifdef Py_GIL_DISABLED\n    _Py_brc_after_fork(tstate->interp);\n    _Py_qsbr_after_fork((_PyThreadStateImpl *)tstate);\n#endif\n\n    // Ideally we could guarantee tstate is running main.\n    _PyInterpreterState_ReinitRunningMain(tstate);\n\n    status = _PyEval_ReInitThreads(tstate);\n    if (_PyStatus_EXCEPTION(status)) {\n        goto fatal_error;\n    }\n\n    // Remove the dead thread states. We \"start the world\" once we are the only\n    // thread state left to undo the stop the world call in `PyOS_BeforeFork`.\n    // That needs to happen before `_PyThreadState_DeleteList`, because that\n    // may call destructors.\n    PyThreadState *list = _PyThreadState_RemoveExcept(tstate);\n    _PyEval_StartTheWorldAll(&_PyRuntime);\n    _PyThreadState_DeleteList(list);\n\n    _PyImport_ReleaseLock(tstate->interp);\n\n    _PySignal_AfterFork();\n\n    status = _PyInterpreterState_DeleteExceptMain(runtime);\n    if (_PyStatus_EXCEPTION(status)) {\n        goto fatal_error;\n    }\n    assert(_PyThreadState_GET() == tstate);\n\n    status = _PyPerfTrampoline_AfterFork_Child();\n    if (_PyStatus_EXCEPTION(status)) {\n        goto fatal_error;\n    }\n\n    run_at_forkers(tstate->interp->after_forkers_child, 0);\n    return;\n\nfatal_error:\n    Py_ExitStatusException(status);\n}\n\nstatic int\nregister_at_forker(PyObject **lst, PyObject *func)\n{\n    if (func == NULL)  /* nothing to register? do nothing. */\n        return 0;\n    if (*lst == NULL) {\n        *lst = PyList_New(0);\n        if (*lst == NULL)\n            return -1;\n    }\n    return PyList_Append(*lst, func);\n}\n#endif  /* HAVE_FORK */\n\n\n/* Legacy wrapper */\nvoid\nPyOS_AfterFork(void)\n{\n#ifdef HAVE_FORK\n    PyOS_AfterFork_Child();\n#endif\n}\n\n\n#ifdef MS_WINDOWS\n/* defined in fileutils.c */\nvoid _Py_time_t_to_FILE_TIME(time_t, int, FILETIME *);\nvoid _Py_attribute_data_to_stat(BY_HANDLE_FILE_INFORMATION *, ULONG,\n                                FILE_BASIC_INFO *, FILE_ID_INFO *,\n                                struct _Py_stat_struct *);\nvoid _Py_stat_basic_info_to_stat(FILE_STAT_BASIC_INFORMATION *,\n                                 struct _Py_stat_struct *);\n#endif\n\n\n#ifndef MS_WINDOWS\nPyObject *\n_PyLong_FromUid(uid_t uid)\n{\n    if (uid == (uid_t)-1)\n        return PyLong_FromLong(-1);\n    return PyLong_FromUnsignedLong(uid);\n}\n\nPyObject *\n_PyLong_FromGid(gid_t gid)\n{\n    if (gid == (gid_t)-1)\n        return PyLong_FromLong(-1);\n    return PyLong_FromUnsignedLong(gid);\n}\n\nint\n_Py_Uid_Converter(PyObject *obj, uid_t *p)\n{\n    uid_t uid;\n    PyObject *index;\n    int overflow;\n    long result;\n    unsigned long uresult;\n\n    index = _PyNumber_Index(obj);\n    if (index == NULL) {\n        PyErr_Format(PyExc_TypeError,\n                     \"uid should be integer, not %.200s\",\n                     _PyType_Name(Py_TYPE(obj)));\n        return 0;\n    }\n\n    /*\n     * Handling uid_t is complicated for two reasons:\n     *  * Although uid_t is (always?) unsigned, it still\n     *    accepts -1.\n     *  * We don't know its size in advance--it may be\n     *    bigger than an int, or it may be smaller than\n     *    a long.\n     *\n     * So a bit of defensive programming is in order.\n     * Start with interpreting the value passed\n     * in as a signed long and see if it works.\n     */\n\n    result = PyLong_AsLongAndOverflow(index, &overflow);\n\n    if (!overflow) {\n        uid = (uid_t)result;\n\n        if (result == -1) {\n            if (PyErr_Occurred())\n                goto fail;\n            /* It's a legitimate -1, we're done. */\n            goto success;\n        }\n\n        /* Any other negative number is disallowed. */\n        if (result < 0)\n            goto underflow;\n\n        /* Ensure the value wasn't truncated. */\n        if (sizeof(uid_t) < sizeof(long) &&\n            (long)uid != result)\n            goto underflow;\n        goto success;\n    }\n\n    if (overflow < 0)\n        goto underflow;\n\n    /*\n     * Okay, the value overflowed a signed long.  If it\n     * fits in an *unsigned* long, it may still be okay,\n     * as uid_t may be unsigned long on this platform.\n     */\n    uresult = PyLong_AsUnsignedLong(index);\n    if (PyErr_Occurred()) {\n        if (PyErr_ExceptionMatches(PyExc_OverflowError))\n            goto overflow;\n        goto fail;\n    }\n\n    uid = (uid_t)uresult;\n\n    /*\n     * If uid == (uid_t)-1, the user actually passed in ULONG_MAX,\n     * but this value would get interpreted as (uid_t)-1  by chown\n     * and its siblings.   That's not what the user meant!  So we\n     * throw an overflow exception instead.   (We already\n     * handled a real -1 with PyLong_AsLongAndOverflow() above.)\n     */\n    if (uid == (uid_t)-1)\n        goto overflow;\n\n    /* Ensure the value wasn't truncated. */\n    if (sizeof(uid_t) < sizeof(long) &&\n        (unsigned long)uid != uresult)\n        goto overflow;\n    /* fallthrough */\n\nsuccess:\n    Py_DECREF(index);\n    *p = uid;\n    return 1;\n\nunderflow:\n    PyErr_SetString(PyExc_OverflowError,\n                    \"uid is less than minimum\");\n    goto fail;\n\noverflow:\n    PyErr_SetString(PyExc_OverflowError,\n                    \"uid is greater than maximum\");\n    /* fallthrough */\n\nfail:\n    Py_DECREF(index);\n    return 0;\n}\n\nint\n_Py_Gid_Converter(PyObject *obj, gid_t *p)\n{\n    gid_t gid;\n    PyObject *index;\n    int overflow;\n    long result;\n    unsigned long uresult;\n\n    index = _PyNumber_Index(obj);\n    if (index == NULL) {\n        PyErr_Format(PyExc_TypeError,\n                     \"gid should be integer, not %.200s\",\n                     _PyType_Name(Py_TYPE(obj)));\n        return 0;\n    }\n\n    /*\n     * Handling gid_t is complicated for two reasons:\n     *  * Although gid_t is (always?) unsigned, it still\n     *    accepts -1.\n     *  * We don't know its size in advance--it may be\n     *    bigger than an int, or it may be smaller than\n     *    a long.\n     *\n     * So a bit of defensive programming is in order.\n     * Start with interpreting the value passed\n     * in as a signed long and see if it works.\n     */\n\n    result = PyLong_AsLongAndOverflow(index, &overflow);\n\n    if (!overflow) {\n        gid = (gid_t)result;\n\n        if (result == -1) {\n            if (PyErr_Occurred())\n                goto fail;\n            /* It's a legitimate -1, we're done. */\n            goto success;\n        }\n\n        /* Any other negative number is disallowed. */\n        if (result < 0) {\n            goto underflow;\n        }\n\n        /* Ensure the value wasn't truncated. */\n        if (sizeof(gid_t) < sizeof(long) &&\n            (long)gid != result)\n            goto underflow;\n        goto success;\n    }\n\n    if (overflow < 0)\n        goto underflow;\n\n    /*\n     * Okay, the value overflowed a signed long.  If it\n     * fits in an *unsigned* long, it may still be okay,\n     * as gid_t may be unsigned long on this platform.\n     */\n    uresult = PyLong_AsUnsignedLong(index);\n    if (PyErr_Occurred()) {\n        if (PyErr_ExceptionMatches(PyExc_OverflowError))\n            goto overflow;\n        goto fail;\n    }\n\n    gid = (gid_t)uresult;\n\n    /*\n     * If gid == (gid_t)-1, the user actually passed in ULONG_MAX,\n     * but this value would get interpreted as (gid_t)-1  by chown\n     * and its siblings.   That's not what the user meant!  So we\n     * throw an overflow exception instead.   (We already\n     * handled a real -1 with PyLong_AsLongAndOverflow() above.)\n     */\n    if (gid == (gid_t)-1)\n        goto overflow;\n\n    /* Ensure the value wasn't truncated. */\n    if (sizeof(gid_t) < sizeof(long) &&\n        (unsigned long)gid != uresult)\n        goto overflow;\n    /* fallthrough */\n\nsuccess:\n    Py_DECREF(index);\n    *p = gid;\n    return 1;\n\nunderflow:\n    PyErr_SetString(PyExc_OverflowError,\n                    \"gid is less than minimum\");\n    goto fail;\n\noverflow:\n    PyErr_SetString(PyExc_OverflowError,\n                    \"gid is greater than maximum\");\n    /* fallthrough */\n\nfail:\n    Py_DECREF(index);\n    return 0;\n}\n#endif /* MS_WINDOWS */\n\n\nstatic PyObject *\n_PyLong_FromDev(dev_t dev)\n{\n#ifdef NODEV\n    if (dev == NODEV) {\n        return PyLong_FromLongLong((long long)dev);\n    }\n#endif\n    return PyLong_FromUnsignedLongLong((unsigned long long)dev);\n}\n\n\n#if (defined(HAVE_MKNOD) && defined(HAVE_MAKEDEV)) || defined(HAVE_DEVICE_MACROS)\nstatic int\n_Py_Dev_Converter(PyObject *obj, void *p)\n{\n#ifdef NODEV\n    if (PyLong_Check(obj) && _PyLong_IsNegative((PyLongObject *)obj)) {\n        int overflow;\n        long long result = PyLong_AsLongLongAndOverflow(obj, &overflow);\n        if (result == -1 && PyErr_Occurred()) {\n            return 0;\n        }\n        if (!overflow && result == (long long)NODEV) {\n            *((dev_t *)p) = NODEV;\n            return 1;\n        }\n    }\n#endif\n\n    unsigned long long result = PyLong_AsUnsignedLongLong(obj);\n    if (result == (unsigned long long)-1 && PyErr_Occurred()) {\n        return 0;\n    }\n    if ((unsigned long long)(dev_t)result != result) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"Python int too large to convert to C dev_t\");\n        return 0;\n    }\n    *((dev_t *)p) = (dev_t)result;\n    return 1;\n}\n#endif /* (HAVE_MKNOD && HAVE_MAKEDEV) || HAVE_DEVICE_MACROS */\n\n\n#ifdef AT_FDCWD\n/*\n * Why the (int) cast?  Solaris 10 defines AT_FDCWD as 0xffd19553 (-3041965);\n * without the int cast, the value gets interpreted as uint (4291925331),\n * which doesn't play nicely with all the initializer lines in this file that\n * look like this:\n *      int dir_fd = DEFAULT_DIR_FD;\n */\n#define DEFAULT_DIR_FD (int)AT_FDCWD\n#else\n#define DEFAULT_DIR_FD (-100)\n#endif\n\nstatic int\n_fd_converter(PyObject *o, int *p)\n{\n    int overflow;\n    long long_value;\n\n    if (PyBool_Check(o)) {\n        if (PyErr_WarnEx(PyExc_RuntimeWarning,\n                \"bool is used as a file descriptor\", 1))\n        {\n            return 0;\n        }\n    }\n    PyObject *index = _PyNumber_Index(o);\n    if (index == NULL) {\n        return 0;\n    }\n\n    assert(PyLong_Check(index));\n    long_value = PyLong_AsLongAndOverflow(index, &overflow);\n    Py_DECREF(index);\n    assert(!PyErr_Occurred());\n    if (overflow > 0 || long_value > INT_MAX) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"fd is greater than maximum\");\n        return 0;\n    }\n    if (overflow < 0 || long_value < INT_MIN) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"fd is less than minimum\");\n        return 0;\n    }\n\n    *p = (int)long_value;\n    return 1;\n}\n\nstatic int\ndir_fd_converter(PyObject *o, void *p)\n{\n    if (o == Py_None) {\n        *(int *)p = DEFAULT_DIR_FD;\n        return 1;\n    }\n    else if (PyIndex_Check(o)) {\n        return _fd_converter(o, (int *)p);\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"argument should be integer or None, not %.200s\",\n                     _PyType_Name(Py_TYPE(o)));\n        return 0;\n    }\n}\n\ntypedef struct {\n    PyObject *billion;\n    PyObject *DirEntryType;\n    PyObject *ScandirIteratorType;\n#if defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDPARAM)\n    PyObject *SchedParamType;\n#endif\n    newfunc statresult_new_orig;\n    PyObject *StatResultType;\n    PyObject *StatVFSResultType;\n    PyObject *TerminalSizeType;\n    PyObject *TimesResultType;\n    PyObject *UnameResultType;\n#if defined(HAVE_WAITID)\n    PyObject *WaitidResultType;\n#endif\n#if defined(HAVE_WAIT3) || defined(HAVE_WAIT4)\n    PyObject *struct_rusage;\n#endif\n    PyObject *st_mode;\n#ifndef MS_WINDOWS\n    // times() clock frequency in hertz; used by os.times()\n    long ticks_per_second;\n#endif\n} _posixstate;\n\n\nstatic inline _posixstate*\nget_posix_state(PyObject *module)\n{\n    void *state = _PyModule_GetState(module);\n    assert(state != NULL);\n    return (_posixstate *)state;\n}\n\n/*\n * A PyArg_ParseTuple \"converter\" function\n * that handles filesystem paths in the manner\n * preferred by the os module.\n *\n * path_converter accepts (Unicode) strings and their\n * subclasses, and bytes and their subclasses.  What\n * it does with the argument depends on path.make_wide:\n *\n *   * If path.make_wide is nonzero, if we get a (Unicode)\n *     string we extract the wchar_t * and return it; if we\n *     get bytes we decode to wchar_t * and return that.\n *\n *   * If path.make_wide is zero, if we get bytes we extract\n *     the char_t * and return it; if we get a (Unicode)\n *     string we encode to char_t * and return that.\n *\n * path_converter also optionally accepts signed\n * integers (representing open file descriptors) instead\n * of path strings.\n *\n * Input fields:\n *   path.nullable\n *     If nonzero, the path is permitted to be None.\n *   path.nonstrict\n *     If nonzero, the path is permitted to contain\n *     embedded null characters and have any length.\n *   path.make_wide\n *     If nonzero, the converter always uses wide, decoding if necessary, else\n *     it always uses narrow, encoding if necessary. The default value is\n *     nonzero on Windows, else zero.\n *   path.suppress_value_error\n *     If nonzero, raising ValueError is suppressed.\n *   path.allow_fd\n *     If nonzero, the path is permitted to be a file handle\n *     (a signed int) instead of a string.\n *   path.function_name\n *     If non-NULL, path_converter will use that as the name\n *     of the function in error messages.\n *     (If path.function_name is NULL it omits the function name.)\n *   path.argument_name\n *     If non-NULL, path_converter will use that as the name\n *     of the parameter in error messages.\n *     (If path.argument_name is NULL it uses \"path\".)\n *\n * Output fields:\n *   path.wide\n *     Points to the path if it was expressed as Unicode\n *     or if it was bytes and decoded to Unicode.\n *   path.narrow\n *     Points to the path if it was expressed as bytes,\n *     or if it was Unicode and encoded to bytes.\n *   path.fd\n *     Contains a file descriptor if path.accept_fd was true\n *     and the caller provided a signed integer instead of any\n *     sort of string.\n *\n *     WARNING: if your \"path\" parameter is optional, and is\n *     unspecified, path_converter will never get called.\n *     So if you set allow_fd, you *MUST* initialize path.fd = -1\n *     yourself!\n *   path.value_error\n *     If nonzero, then suppress_value_error was specified and a ValueError\n *     occurred.\n *   path.length\n *     The length of the path in characters, if specified as\n *     a string.\n *   path.object\n *     The original object passed in (if get a PathLike object,\n *     the result of PyOS_FSPath() is treated as the original object).\n *     Own a reference to the object.\n *   path.cleanup\n *     For internal use only.  May point to a temporary object.\n *     (Pay no attention to the man behind the curtain.)\n *\n *   At most one of path.wide or path.narrow will be non-NULL.\n *   If path was None and path.nullable was set,\n *     or if path was an integer and path.allow_fd was set,\n *     both path.wide and path.narrow will be NULL\n *     and path.length will be 0.\n *\n *   path_converter takes care to not write to the path_t\n *   unless it's successful.  However it must reset the\n *   \"cleanup\" field each time it's called.\n *\n * Use as follows:\n *      path_t path;\n *      memset(&path, 0, sizeof(path));\n *      PyArg_ParseTuple(args, \"O&\", path_converter, &path);\n *      // ... use values from path ...\n *      path_cleanup(&path);\n *\n * (Note that if PyArg_Parse fails you don't need to call\n * path_cleanup().  However it is safe to do so.)\n */\ntypedef struct {\n    // Input fields\n    const char *function_name;\n    const char *argument_name;\n    int nullable;\n    int nonstrict;\n    int make_wide;\n    int suppress_value_error;\n    int allow_fd;\n    // Output fields\n    const wchar_t *wide;\n    const char *narrow;\n    int fd;\n    int value_error;\n    Py_ssize_t length;\n    PyObject *object;\n    PyObject *cleanup;\n} path_t;\n\n#define PATH_T_INITIALIZE(function_name, argument_name, nullable, nonstrict, \\\n                          make_wide, suppress_value_error, allow_fd) \\\n    {function_name, argument_name, nullable, nonstrict, make_wide, \\\n     suppress_value_error, allow_fd, NULL, NULL, -1, 0, 0, NULL, NULL}\n#ifdef MS_WINDOWS\n#define PATH_T_INITIALIZE_P(function_name, argument_name, nullable, \\\n                            nonstrict, suppress_value_error, allow_fd) \\\n    PATH_T_INITIALIZE(function_name, argument_name, nullable, nonstrict, 1, \\\n                      suppress_value_error, allow_fd)\n#else\n#define PATH_T_INITIALIZE_P(function_name, argument_name, nullable, \\\n                            nonstrict, suppress_value_error, allow_fd) \\\n    PATH_T_INITIALIZE(function_name, argument_name, nullable, nonstrict, 0, \\\n                      suppress_value_error, allow_fd)\n#endif\n\nstatic void\npath_cleanup(path_t *path)\n{\n    wchar_t *wide = (wchar_t *)path->wide;\n    path->wide = NULL;\n    PyMem_Free(wide);\n    Py_CLEAR(path->object);\n    Py_CLEAR(path->cleanup);\n}\n\nstatic int\npath_converter(PyObject *o, void *p)\n{\n    path_t *path = (path_t *)p;\n    PyObject *bytes = NULL;\n    Py_ssize_t length = 0;\n    int is_index, is_bytes, is_unicode;\n    const char *narrow;\n    PyObject *wo = NULL;\n    wchar_t *wide = NULL;\n\n#define FORMAT_EXCEPTION(exc, fmt) \\\n    PyErr_Format(exc, \"%s%s\" fmt, \\\n        path->function_name ? path->function_name : \"\", \\\n        path->function_name ? \": \"                : \"\", \\\n        path->argument_name ? path->argument_name : \"path\")\n\n    /* Py_CLEANUP_SUPPORTED support */\n    if (o == NULL) {\n        path_cleanup(path);\n        return 1;\n    }\n\n    /* Ensure it's always safe to call path_cleanup(). */\n    path->object = path->cleanup = NULL;\n    /* path->object owns a reference to the original object */\n    Py_INCREF(o);\n\n    if ((o == Py_None) && path->nullable) {\n        path->wide = NULL;\n        path->narrow = NULL;\n        path->fd = -1;\n        goto success_exit;\n    }\n\n    /* Only call this here so that we don't treat the return value of\n       os.fspath() as an fd or buffer. */\n    is_index = path->allow_fd && PyIndex_Check(o);\n    is_bytes = PyBytes_Check(o);\n    is_unicode = PyUnicode_Check(o);\n\n    if (!is_index && !is_unicode && !is_bytes) {\n        /* Inline PyOS_FSPath() for better error messages. */\n        PyObject *func, *res;\n\n        func = _PyObject_LookupSpecial(o, &_Py_ID(__fspath__));\n        if ((NULL == func) || (func == Py_None)) {\n            goto error_format;\n        }\n        res = _PyObject_CallNoArgs(func);\n        Py_DECREF(func);\n        if (NULL == res) {\n            goto error_exit;\n        }\n        else if (PyUnicode_Check(res)) {\n            is_unicode = 1;\n        }\n        else if (PyBytes_Check(res)) {\n            is_bytes = 1;\n        }\n        else {\n            PyErr_Format(PyExc_TypeError,\n                 \"expected %.200s.__fspath__() to return str or bytes, \"\n                 \"not %.200s\", _PyType_Name(Py_TYPE(o)),\n                 _PyType_Name(Py_TYPE(res)));\n            Py_DECREF(res);\n            goto error_exit;\n        }\n\n        /* still owns a reference to the original object */\n        Py_SETREF(o, res);\n    }\n\n    if (is_unicode) {\n        if (path->make_wide) {\n            wide = PyUnicode_AsWideCharString(o, &length);\n            if (!wide) {\n                goto error_exit;\n            }\n#ifdef MS_WINDOWS\n            if (!path->nonstrict && length > 32767) {\n                FORMAT_EXCEPTION(PyExc_ValueError, \"%s too long for Windows\");\n                goto error_exit;\n            }\n#endif\n            if (!path->nonstrict && wcslen(wide) != (size_t)length) {\n                FORMAT_EXCEPTION(PyExc_ValueError,\n                                 \"embedded null character in %s\");\n                goto error_exit;\n            }\n\n            path->wide = wide;\n            path->narrow = NULL;\n            path->fd = -1;\n            wide = NULL;\n            goto success_exit;\n        }\n        bytes = PyUnicode_EncodeFSDefault(o);\n        if (!bytes) {\n            goto error_exit;\n        }\n    }\n    else if (is_bytes) {\n        bytes = Py_NewRef(o);\n    }\n    else if (is_index) {\n        if (!_fd_converter(o, &path->fd)) {\n            goto error_exit;\n        }\n        path->wide = NULL;\n        path->narrow = NULL;\n        goto success_exit;\n    }\n    else {\n error_format:\n        PyErr_Format(PyExc_TypeError, \"%s%s%s should be %s, not %.200s\",\n            path->function_name ? path->function_name : \"\",\n            path->function_name ? \": \"                : \"\",\n            path->argument_name ? path->argument_name : \"path\",\n            path->allow_fd && path->nullable ? \"string, bytes, os.PathLike, \"\n                                               \"integer or None\" :\n            path->allow_fd ? \"string, bytes, os.PathLike or integer\" :\n            path->nullable ? \"string, bytes, os.PathLike or None\" :\n                             \"string, bytes or os.PathLike\",\n            _PyType_Name(Py_TYPE(o)));\n        goto error_exit;\n    }\n\n    length = PyBytes_GET_SIZE(bytes);\n    narrow = PyBytes_AS_STRING(bytes);\n    if (!path->nonstrict && strlen(narrow) != (size_t)length) {\n        FORMAT_EXCEPTION(PyExc_ValueError, \"embedded null character in %s\");\n        goto error_exit;\n    }\n\n    if (path->make_wide) {\n        wo = PyUnicode_DecodeFSDefaultAndSize(narrow, length);\n        if (!wo) {\n            goto error_exit;\n        }\n\n        wide = PyUnicode_AsWideCharString(wo, &length);\n        Py_DECREF(wo);\n        if (!wide) {\n            goto error_exit;\n        }\n#ifdef MS_WINDOWS\n        if (!path->nonstrict && length > 32767) {\n            FORMAT_EXCEPTION(PyExc_ValueError, \"%s too long for Windows\");\n            goto error_exit;\n        }\n#endif\n        if (!path->nonstrict && wcslen(wide) != (size_t)length) {\n            FORMAT_EXCEPTION(PyExc_ValueError,\n                             \"embedded null character in %s\");\n            goto error_exit;\n        }\n        path->wide = wide;\n        path->narrow = NULL;\n        Py_DECREF(bytes);\n        wide = NULL;\n    }\n    else {\n        path->wide = NULL;\n        path->narrow = narrow;\n        if (bytes == o) {\n            /* Still a reference owned by path->object, don't have to\n            worry about path->narrow is used after free. */\n            Py_DECREF(bytes);\n        }\n        else {\n            path->cleanup = bytes;\n        }\n    }\n    path->fd = -1;\n\n success_exit:\n    path->value_error = 0;\n    path->length = length;\n    path->object = o;\n    return Py_CLEANUP_SUPPORTED;\n\n error_exit:\n    Py_XDECREF(o);\n    Py_XDECREF(bytes);\n    PyMem_Free(wide);\n    if (!path->suppress_value_error ||\n        !PyErr_ExceptionMatches(PyExc_ValueError))\n    {\n        return 0;\n    }\n    PyErr_Clear();\n    path->wide = NULL;\n    path->narrow = NULL;\n    path->fd = -1;\n    path->value_error = 1;\n    path->length = 0;\n    path->object = NULL;\n    return Py_CLEANUP_SUPPORTED;\n}\n\nstatic void\nargument_unavailable_error(const char *function_name, const char *argument_name)\n{\n    PyErr_Format(PyExc_NotImplementedError,\n        \"%s%s%s unavailable on this platform\",\n        (function_name != NULL) ? function_name : \"\",\n        (function_name != NULL) ? \": \": \"\",\n        argument_name);\n}\n\nstatic int\ndir_fd_unavailable(PyObject *o, void *p)\n{\n    int dir_fd;\n    if (!dir_fd_converter(o, &dir_fd))\n        return 0;\n    if (dir_fd != DEFAULT_DIR_FD) {\n        argument_unavailable_error(NULL, \"dir_fd\");\n        return 0;\n    }\n    *(int *)p = dir_fd;\n    return 1;\n}\n\nstatic int\nfd_specified(const char *function_name, int fd)\n{\n    if (fd == -1)\n        return 0;\n\n    argument_unavailable_error(function_name, \"fd\");\n    return 1;\n}\n\nstatic int\nfollow_symlinks_specified(const char *function_name, int follow_symlinks)\n{\n    if (follow_symlinks)\n        return 0;\n\n    argument_unavailable_error(function_name, \"follow_symlinks\");\n    return 1;\n}\n\nstatic int\npath_and_dir_fd_invalid(const char *function_name, path_t *path, int dir_fd)\n{\n    if (!path->wide && (dir_fd != DEFAULT_DIR_FD) && !path->narrow) {\n        PyErr_Format(PyExc_ValueError,\n                     \"%s: can't specify dir_fd without matching path\",\n                     function_name);\n        return 1;\n    }\n    return 0;\n}\n\nstatic int\ndir_fd_and_fd_invalid(const char *function_name, int dir_fd, int fd)\n{\n    if ((dir_fd != DEFAULT_DIR_FD) && (fd != -1)) {\n        PyErr_Format(PyExc_ValueError,\n                     \"%s: can't specify both dir_fd and fd\",\n                     function_name);\n        return 1;\n    }\n    return 0;\n}\n\nstatic int\nfd_and_follow_symlinks_invalid(const char *function_name, int fd,\n                               int follow_symlinks)\n{\n    if ((fd > 0) && (!follow_symlinks)) {\n        PyErr_Format(PyExc_ValueError,\n                     \"%s: cannot use fd and follow_symlinks together\",\n                     function_name);\n        return 1;\n    }\n    return 0;\n}\n\nstatic int\ndir_fd_and_follow_symlinks_invalid(const char *function_name, int dir_fd,\n                                   int follow_symlinks)\n{\n    if ((dir_fd != DEFAULT_DIR_FD) && (!follow_symlinks)) {\n        PyErr_Format(PyExc_ValueError,\n                     \"%s: cannot use dir_fd and follow_symlinks together\",\n                     function_name);\n        return 1;\n    }\n    return 0;\n}\n\n#ifdef MS_WINDOWS\n    typedef long long Py_off_t;\n#else\n    typedef off_t Py_off_t;\n#endif\n\nstatic int\nPy_off_t_converter(PyObject *arg, void *addr)\n{\n#ifdef HAVE_LARGEFILE_SUPPORT\n    *((Py_off_t *)addr) = PyLong_AsLongLong(arg);\n#else\n    *((Py_off_t *)addr) = PyLong_AsLong(arg);\n#endif\n    if (PyErr_Occurred())\n        return 0;\n    return 1;\n}\n\nstatic PyObject *\nPyLong_FromPy_off_t(Py_off_t offset)\n{\n#ifdef HAVE_LARGEFILE_SUPPORT\n    return PyLong_FromLongLong(offset);\n#else\n    return PyLong_FromLong(offset);\n#endif\n}\n\n#ifdef HAVE_SIGSET_T\n/* Convert an iterable of integers to a sigset.\n   Return 1 on success, return 0 and raise an exception on error. */\nint\n_Py_Sigset_Converter(PyObject *obj, void *addr)\n{\n    sigset_t *mask = (sigset_t *)addr;\n    PyObject *iterator, *item;\n    long signum;\n    int overflow;\n\n    // The extra parens suppress the unreachable-code warning with clang on MacOS\n    if (sigemptyset(mask) < (0)) {\n        /* Probably only if mask == NULL. */\n        PyErr_SetFromErrno(PyExc_OSError);\n        return 0;\n    }\n\n    iterator = PyObject_GetIter(obj);\n    if (iterator == NULL) {\n        return 0;\n    }\n\n    while ((item = PyIter_Next(iterator)) != NULL) {\n        signum = PyLong_AsLongAndOverflow(item, &overflow);\n        Py_DECREF(item);\n        if (signum <= 0 || signum >= Py_NSIG) {\n            if (overflow || signum != -1 || !PyErr_Occurred()) {\n                PyErr_Format(PyExc_ValueError,\n                             \"signal number %ld out of range [1; %i]\",\n                             signum, Py_NSIG - 1);\n            }\n            goto error;\n        }\n        if (sigaddset(mask, (int)signum)) {\n            if (errno != EINVAL) {\n                /* Probably impossible */\n                PyErr_SetFromErrno(PyExc_OSError);\n                goto error;\n            }\n            /* For backwards compatibility, allow idioms such as\n             * `range(1, NSIG)` but warn about invalid signal numbers\n             */\n            const char msg[] =\n                \"invalid signal number %ld, please use valid_signals()\";\n            if (PyErr_WarnFormat(PyExc_RuntimeWarning, 1, msg, signum)) {\n                goto error;\n            }\n        }\n    }\n    if (!PyErr_Occurred()) {\n        Py_DECREF(iterator);\n        return 1;\n    }\n\nerror:\n    Py_DECREF(iterator);\n    return 0;\n}\n#endif /* HAVE_SIGSET_T */\n\n/* Return a dictionary corresponding to the POSIX environment table */\n#if defined(WITH_NEXT_FRAMEWORK) || (defined(__APPLE__) && defined(Py_ENABLE_SHARED))\n/* On Darwin/MacOSX a shared library or framework has no access to\n** environ directly, we must obtain it with _NSGetEnviron(). See also\n** man environ(7).\n*/\n#include <crt_externs.h>\n#define USE_DARWIN_NS_GET_ENVIRON 1\n#elif !defined(_MSC_VER) && (!defined(__WATCOMC__) || defined(__QNX__) || defined(__VXWORKS__))\nextern char **environ;\n#endif /* !_MSC_VER */\n\nstatic PyObject *\nconvertenviron(void)\n{\n    PyObject *d;\n#ifdef MS_WINDOWS\n    wchar_t **e;\n#else\n    char **e;\n#endif\n\n    d = PyDict_New();\n    if (d == NULL)\n        return NULL;\n#ifdef MS_WINDOWS\n    /* _wenviron must be initialized in this way if the program is started\n       through main() instead of wmain(). */\n    (void)_wgetenv(L\"\");\n    e = _wenviron;\n#elif defined(USE_DARWIN_NS_GET_ENVIRON)\n    /* environ is not accessible as an extern in a shared object on OSX; use\n       _NSGetEnviron to resolve it. The value changes if you add environment\n       variables between calls to Py_Initialize, so don't cache the value. */\n    e = *_NSGetEnviron();\n#else\n    e = environ;\n#endif\n    if (e == NULL)\n        return d;\n    for (; *e != NULL; e++) {\n        PyObject *k;\n        PyObject *v;\n#ifdef MS_WINDOWS\n        const wchar_t *p = wcschr(*e, L'=');\n#else\n        const char *p = strchr(*e, '=');\n#endif\n        if (p == NULL)\n            continue;\n#ifdef MS_WINDOWS\n        k = PyUnicode_FromWideChar(*e, (Py_ssize_t)(p-*e));\n#else\n        k = PyBytes_FromStringAndSize(*e, (int)(p-*e));\n#endif\n        if (k == NULL) {\n            Py_DECREF(d);\n            return NULL;\n        }\n#ifdef MS_WINDOWS\n        v = PyUnicode_FromWideChar(p+1, wcslen(p+1));\n#else\n        v = PyBytes_FromStringAndSize(p+1, strlen(p+1));\n#endif\n        if (v == NULL) {\n            Py_DECREF(k);\n            Py_DECREF(d);\n            return NULL;\n        }\n        if (PyDict_SetDefaultRef(d, k, v, NULL) < 0) {\n            Py_DECREF(v);\n            Py_DECREF(k);\n            Py_DECREF(d);\n            return NULL;\n        }\n        Py_DECREF(k);\n        Py_DECREF(v);\n    }\n    return d;\n}\n\n/* Set a POSIX-specific error from errno, and return NULL */\n\nstatic PyObject *\nposix_error(void)\n{\n    return PyErr_SetFromErrno(PyExc_OSError);\n}\n\n#ifdef MS_WINDOWS\nstatic PyObject *\nwin32_error(const char* function, const char* filename)\n{\n    /* XXX We should pass the function name along in the future.\n       (winreg.c also wants to pass the function name.)\n       This would however require an additional param to the\n       Windows error object, which is non-trivial.\n    */\n    errno = GetLastError();\n    if (filename)\n        return PyErr_SetFromWindowsErrWithFilename(errno, filename);\n    else\n        return PyErr_SetFromWindowsErr(errno);\n}\n\nstatic PyObject *\nwin32_error_object_err(const char* function, PyObject* filename, DWORD err)\n{\n    /* XXX - see win32_error for comments on 'function' */\n    if (filename)\n        return PyErr_SetExcFromWindowsErrWithFilenameObject(\n                    PyExc_OSError,\n                    err,\n                    filename);\n    else\n        return PyErr_SetFromWindowsErr(err);\n}\n\nstatic PyObject *\nwin32_error_object(const char* function, PyObject* filename)\n{\n    errno = GetLastError();\n    return win32_error_object_err(function, filename, errno);\n}\n\n#endif /* MS_WINDOWS */\n\nstatic PyObject *\nposix_path_object_error(PyObject *path)\n{\n    return PyErr_SetFromErrnoWithFilenameObject(PyExc_OSError, path);\n}\n\nstatic PyObject *\npath_object_error(PyObject *path)\n{\n#ifdef MS_WINDOWS\n    return PyErr_SetExcFromWindowsErrWithFilenameObject(\n                PyExc_OSError, 0, path);\n#else\n    return posix_path_object_error(path);\n#endif\n}\n\nstatic PyObject *\npath_object_error2(PyObject *path, PyObject *path2)\n{\n#ifdef MS_WINDOWS\n    return PyErr_SetExcFromWindowsErrWithFilenameObjects(\n                PyExc_OSError, 0, path, path2);\n#else\n    return PyErr_SetFromErrnoWithFilenameObjects(PyExc_OSError, path, path2);\n#endif\n}\n\nstatic PyObject *\npath_error(path_t *path)\n{\n    return path_object_error(path->object);\n}\n\nstatic PyObject *\nposix_path_error(path_t *path)\n{\n    return posix_path_object_error(path->object);\n}\n\nstatic PyObject *\npath_error2(path_t *path, path_t *path2)\n{\n    return path_object_error2(path->object, path2->object);\n}\n\n\n/* POSIX generic methods */\n\nstatic PyObject *\nposix_fildes_fd(int fd, int (*func)(int))\n{\n    int res;\n    int async_err = 0;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        _Py_BEGIN_SUPPRESS_IPH\n        res = (*func)(fd);\n        _Py_END_SUPPRESS_IPH\n        Py_END_ALLOW_THREADS\n    } while (res != 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    if (res != 0)\n        return (!async_err) ? posix_error() : NULL;\n    Py_RETURN_NONE;\n}\n\n\n#ifdef MS_WINDOWS\n/* This is a reimplementation of the C library's chdir function,\n   but one that produces Win32 errors instead of DOS error codes.\n   chdir is essentially a wrapper around SetCurrentDirectory; however,\n   it also needs to set \"magic\" environment variables indicating\n   the per-drive current directory, which are of the form =<drive>: */\nstatic BOOL __stdcall\nwin32_wchdir(LPCWSTR path)\n{\n    wchar_t path_buf[MAX_PATH], *new_path = path_buf;\n    int result;\n    wchar_t env[4] = L\"=x:\";\n\n    if(!SetCurrentDirectoryW(path))\n        return FALSE;\n    result = GetCurrentDirectoryW(Py_ARRAY_LENGTH(path_buf), new_path);\n    if (!result)\n        return FALSE;\n    if (result > Py_ARRAY_LENGTH(path_buf)) {\n        new_path = PyMem_RawMalloc(result * sizeof(wchar_t));\n        if (!new_path) {\n            SetLastError(ERROR_OUTOFMEMORY);\n            return FALSE;\n        }\n        result = GetCurrentDirectoryW(result, new_path);\n        if (!result) {\n            PyMem_RawFree(new_path);\n            return FALSE;\n        }\n    }\n    int is_unc_like_path = (wcsncmp(new_path, L\"\\\\\\\\\", 2) == 0 ||\n                            wcsncmp(new_path, L\"//\", 2) == 0);\n    if (!is_unc_like_path) {\n        env[1] = new_path[0];\n        result = SetEnvironmentVariableW(env, new_path);\n    }\n    if (new_path != path_buf)\n        PyMem_RawFree(new_path);\n    return result ? TRUE : FALSE;\n}\n#endif\n\n#ifdef MS_WINDOWS\n/* The CRT of Windows has a number of flaws wrt. its stat() implementation:\n   - time stamps are restricted to second resolution\n   - file modification times suffer from forth-and-back conversions between\n     UTC and local time\n   Therefore, we implement our own stat, based on the Win32 API directly.\n*/\n#define HAVE_STAT_NSEC 1\n#define HAVE_STRUCT_STAT_ST_FILE_ATTRIBUTES 1\n#define HAVE_STRUCT_STAT_ST_REPARSE_TAG 1\n\nstatic void\nfind_data_to_file_info(WIN32_FIND_DATAW *pFileData,\n                       BY_HANDLE_FILE_INFORMATION *info,\n                       ULONG *reparse_tag)\n{\n    memset(info, 0, sizeof(*info));\n    info->dwFileAttributes = pFileData->dwFileAttributes;\n    info->ftCreationTime   = pFileData->ftCreationTime;\n    info->ftLastAccessTime = pFileData->ftLastAccessTime;\n    info->ftLastWriteTime  = pFileData->ftLastWriteTime;\n    info->nFileSizeHigh    = pFileData->nFileSizeHigh;\n    info->nFileSizeLow     = pFileData->nFileSizeLow;\n/*  info->nNumberOfLinks   = 1; */\n    if (pFileData->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)\n        *reparse_tag = pFileData->dwReserved0;\n    else\n        *reparse_tag = 0;\n}\n\nstatic BOOL\nattributes_from_dir(LPCWSTR pszFile, BY_HANDLE_FILE_INFORMATION *info, ULONG *reparse_tag)\n{\n    HANDLE hFindFile;\n    WIN32_FIND_DATAW FileData;\n    LPCWSTR filename = pszFile;\n    size_t n = wcslen(pszFile);\n    if (n && (pszFile[n - 1] == L'\\\\' || pszFile[n - 1] == L'/')) {\n        // cannot use PyMem_Malloc here because we do not hold the GIL\n        filename = (LPCWSTR)malloc((n + 1) * sizeof(filename[0]));\n        if(!filename) {\n            SetLastError(ERROR_NOT_ENOUGH_MEMORY);\n            return FALSE;\n        }\n        wcsncpy_s((LPWSTR)filename, n + 1, pszFile, n);\n        while (--n > 0 && (filename[n] == L'\\\\' || filename[n] == L'/')) {\n            ((LPWSTR)filename)[n] = L'\\0';\n        }\n        if (!n || (n == 1 && filename[1] == L':')) {\n            // Nothing left to query\n            free((void *)filename);\n            return FALSE;\n        }\n    }\n    hFindFile = FindFirstFileW(filename, &FileData);\n    if (pszFile != filename) {\n        free((void *)filename);\n    }\n    if (hFindFile == INVALID_HANDLE_VALUE) {\n        return FALSE;\n    }\n    FindClose(hFindFile);\n    find_data_to_file_info(&FileData, info, reparse_tag);\n    return TRUE;\n}\n\n\nstatic void\nupdate_st_mode_from_path(const wchar_t *path, DWORD attr,\n                         struct _Py_stat_struct *result)\n{\n    if (!(attr & FILE_ATTRIBUTE_DIRECTORY)) {\n        /* Fix the file execute permissions. This hack sets S_IEXEC if\n           the filename has an extension that is commonly used by files\n           that CreateProcessW can execute. A real implementation calls\n           GetSecurityInfo, OpenThreadToken/OpenProcessToken, and\n           AccessCheck to check for generic read, write, and execute\n           access. */\n        const wchar_t *fileExtension = wcsrchr(path, '.');\n        if (fileExtension) {\n            if (_wcsicmp(fileExtension, L\".exe\") == 0 ||\n                _wcsicmp(fileExtension, L\".bat\") == 0 ||\n                _wcsicmp(fileExtension, L\".cmd\") == 0 ||\n                _wcsicmp(fileExtension, L\".com\") == 0) {\n                result->st_mode |= 0111;\n            }\n        }\n    }\n}\n\n\nstatic int\nwin32_xstat_slow_impl(const wchar_t *path, struct _Py_stat_struct *result,\n                      BOOL traverse)\n{\n    HANDLE hFile;\n    BY_HANDLE_FILE_INFORMATION fileInfo;\n    FILE_BASIC_INFO basicInfo;\n    FILE_BASIC_INFO *pBasicInfo = NULL;\n    FILE_ID_INFO idInfo;\n    FILE_ID_INFO *pIdInfo = NULL;\n    FILE_ATTRIBUTE_TAG_INFO tagInfo = { 0 };\n    DWORD fileType, error;\n    BOOL isUnhandledTag = FALSE;\n    int retval = 0;\n\n    DWORD access = FILE_READ_ATTRIBUTES;\n    DWORD flags = FILE_FLAG_BACKUP_SEMANTICS; /* Allow opening directories. */\n    if (!traverse) {\n        flags |= FILE_FLAG_OPEN_REPARSE_POINT;\n    }\n\n    hFile = CreateFileW(path, access, 0, NULL, OPEN_EXISTING, flags, NULL);\n    if (hFile == INVALID_HANDLE_VALUE) {\n        /* Either the path doesn't exist, or the caller lacks access. */\n        error = GetLastError();\n        switch (error) {\n        case ERROR_ACCESS_DENIED:     /* Cannot sync or read attributes. */\n        case ERROR_SHARING_VIOLATION: /* It's a paging file. */\n            /* Try reading the parent directory. */\n            if (!attributes_from_dir(path, &fileInfo, &tagInfo.ReparseTag)) {\n                /* Cannot read the parent directory. */\n                switch (GetLastError()) {\n                case ERROR_FILE_NOT_FOUND: /* File cannot be found */\n                case ERROR_PATH_NOT_FOUND: /* File parent directory cannot be found */\n                case ERROR_NOT_READY: /* Drive exists but unavailable */\n                case ERROR_BAD_NET_NAME: /* Remote drive unavailable */\n                    break;\n                /* Restore the error from CreateFileW(). */\n                default:\n                    SetLastError(error);\n                }\n\n                return -1;\n            }\n            if (fileInfo.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {\n                if (traverse ||\n                    !IsReparseTagNameSurrogate(tagInfo.ReparseTag)) {\n                    /* The stat call has to traverse but cannot, so fail. */\n                    SetLastError(error);\n                    return -1;\n                }\n            }\n            break;\n\n        case ERROR_INVALID_PARAMETER:\n            /* \\\\.\\con requires read or write access. */\n            hFile = CreateFileW(path, access | GENERIC_READ,\n                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,\n                        OPEN_EXISTING, flags, NULL);\n            if (hFile == INVALID_HANDLE_VALUE) {\n                SetLastError(error);\n                return -1;\n            }\n            break;\n\n        case ERROR_CANT_ACCESS_FILE:\n            /* bpo37834: open unhandled reparse points if traverse fails. */\n            if (traverse) {\n                traverse = FALSE;\n                isUnhandledTag = TRUE;\n                hFile = CreateFileW(path, access, 0, NULL, OPEN_EXISTING,\n                            flags | FILE_FLAG_OPEN_REPARSE_POINT, NULL);\n            }\n            if (hFile == INVALID_HANDLE_VALUE) {\n                SetLastError(error);\n                return -1;\n            }\n            break;\n\n        default:\n            return -1;\n        }\n    }\n\n    if (hFile != INVALID_HANDLE_VALUE) {\n        /* Handle types other than files on disk. */\n        fileType = GetFileType(hFile);\n        if (fileType != FILE_TYPE_DISK) {\n            if (fileType == FILE_TYPE_UNKNOWN && GetLastError() != 0) {\n                retval = -1;\n                goto cleanup;\n            }\n            DWORD fileAttributes = GetFileAttributesW(path);\n            memset(result, 0, sizeof(*result));\n            if (fileAttributes != INVALID_FILE_ATTRIBUTES &&\n                fileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n                /* \\\\.\\pipe\\ or \\\\.\\mailslot\\ */\n                result->st_mode = _S_IFDIR;\n            } else if (fileType == FILE_TYPE_CHAR) {\n                /* \\\\.\\nul */\n                result->st_mode = _S_IFCHR;\n            } else if (fileType == FILE_TYPE_PIPE) {\n                /* \\\\.\\pipe\\spam */\n                result->st_mode = _S_IFIFO;\n            }\n            /* FILE_TYPE_UNKNOWN, e.g. \\\\.\\mailslot\\waitfor.exe\\spam */\n            goto cleanup;\n        }\n\n        /* Query the reparse tag, and traverse a non-link. */\n        if (!traverse) {\n            if (!GetFileInformationByHandleEx(hFile, FileAttributeTagInfo,\n                    &tagInfo, sizeof(tagInfo))) {\n                /* Allow devices that do not support FileAttributeTagInfo. */\n                switch (GetLastError()) {\n                case ERROR_INVALID_PARAMETER:\n                case ERROR_INVALID_FUNCTION:\n                case ERROR_NOT_SUPPORTED:\n                    tagInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;\n                    tagInfo.ReparseTag = 0;\n                    break;\n                default:\n                    retval = -1;\n                    goto cleanup;\n                }\n            } else if (tagInfo.FileAttributes &\n                         FILE_ATTRIBUTE_REPARSE_POINT) {\n                if (IsReparseTagNameSurrogate(tagInfo.ReparseTag)) {\n                    if (isUnhandledTag) {\n                        /* Traversing previously failed for either this link\n                           or its target. */\n                        SetLastError(ERROR_CANT_ACCESS_FILE);\n                        retval = -1;\n                        goto cleanup;\n                    }\n                /* Traverse a non-link, but not if traversing already failed\n                   for an unhandled tag. */\n                } else if (!isUnhandledTag) {\n                    CloseHandle(hFile);\n                    return win32_xstat_slow_impl(path, result, TRUE);\n                }\n            }\n        }\n\n        if (!GetFileInformationByHandle(hFile, &fileInfo) ||\n            !GetFileInformationByHandleEx(hFile, FileBasicInfo,\n                                          &basicInfo, sizeof(basicInfo))) {\n            switch (GetLastError()) {\n            case ERROR_INVALID_PARAMETER:\n            case ERROR_INVALID_FUNCTION:\n            case ERROR_NOT_SUPPORTED:\n                /* Volumes and physical disks are block devices, e.g.\n                   \\\\.\\C: and \\\\.\\PhysicalDrive0. */\n                memset(result, 0, sizeof(*result));\n                result->st_mode = 0x6000; /* S_IFBLK */\n                goto cleanup;\n            }\n            retval = -1;\n            goto cleanup;\n        }\n\n        /* Successfully got FileBasicInfo, so we'll pass it along */\n        pBasicInfo = &basicInfo;\n\n        if (GetFileInformationByHandleEx(hFile, FileIdInfo, &idInfo, sizeof(idInfo))) {\n            /* Successfully got FileIdInfo, so pass it along */\n            pIdInfo = &idInfo;\n        }\n    }\n\n    _Py_attribute_data_to_stat(&fileInfo, tagInfo.ReparseTag, pBasicInfo, pIdInfo, result);\n    update_st_mode_from_path(path, fileInfo.dwFileAttributes, result);\n\ncleanup:\n    if (hFile != INVALID_HANDLE_VALUE) {\n        /* Preserve last error if we are failing */\n        error = retval ? GetLastError() : 0;\n        if (!CloseHandle(hFile)) {\n            retval = -1;\n        } else if (retval) {\n            /* Restore last error */\n            SetLastError(error);\n        }\n    }\n\n    return retval;\n}\n\nstatic int\nwin32_xstat_impl(const wchar_t *path, struct _Py_stat_struct *result,\n                 BOOL traverse)\n{\n    FILE_STAT_BASIC_INFORMATION statInfo;\n    if (_Py_GetFileInformationByName(path, FileStatBasicByNameInfo,\n                                     &statInfo, sizeof(statInfo))) {\n        if (// Cannot use fast path for reparse points ...\n            !(statInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)\n            // ... unless it's a name surrogate (symlink) and we're not following\n            || (!traverse && IsReparseTagNameSurrogate(statInfo.ReparseTag))\n        ) {\n            _Py_stat_basic_info_to_stat(&statInfo, result);\n            update_st_mode_from_path(path, statInfo.FileAttributes, result);\n            return 0;\n        }\n    } else {\n        switch(GetLastError()) {\n        case ERROR_FILE_NOT_FOUND:\n        case ERROR_PATH_NOT_FOUND:\n        case ERROR_NOT_READY:\n        case ERROR_BAD_NET_NAME:\n            /* These errors aren't worth retrying with the slow path */\n            return -1;\n        case ERROR_NOT_SUPPORTED:\n            /* indicates the API couldn't be loaded */\n            break;\n        }\n    }\n\n    return win32_xstat_slow_impl(path, result, traverse);\n}\n\nstatic int\nwin32_xstat(const wchar_t *path, struct _Py_stat_struct *result, BOOL traverse)\n{\n    /* Protocol violation: we explicitly clear errno, instead of\n       setting it to a POSIX error. Callers should use GetLastError. */\n    int code = win32_xstat_impl(path, result, traverse);\n    errno = 0;\n\n    /* ctime is only deprecated from 3.12, so we copy birthtime across */\n    result->st_ctime = result->st_birthtime;\n    result->st_ctime_nsec = result->st_birthtime_nsec;\n    return code;\n}\n/* About the following functions: win32_lstat_w, win32_stat, win32_stat_w\n\n   In Posix, stat automatically traverses symlinks and returns the stat\n   structure for the target.  In Windows, the equivalent GetFileAttributes by\n   default does not traverse symlinks and instead returns attributes for\n   the symlink.\n\n   Instead, we will open the file (which *does* traverse symlinks by default)\n   and GetFileInformationByHandle(). */\n\nstatic int\nwin32_lstat(const wchar_t* path, struct _Py_stat_struct *result)\n{\n    return win32_xstat(path, result, FALSE);\n}\n\nstatic int\nwin32_stat(const wchar_t* path, struct _Py_stat_struct *result)\n{\n    return win32_xstat(path, result, TRUE);\n}\n\n#endif /* MS_WINDOWS */\n\nPyDoc_STRVAR(stat_result__doc__,\n\"stat_result: Result from stat, fstat, or lstat.\\n\\n\\\nThis object may be accessed either as a tuple of\\n\\\n  (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)\\n\\\nor via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.\\n\\\n\\n\\\nPosix/windows: If your platform supports st_blksize, st_blocks, st_rdev,\\n\\\nor st_flags, they are available as attributes only.\\n\\\n\\n\\\nSee os.stat for more information.\");\n\nstatic PyStructSequence_Field stat_result_fields[] = {\n    {\"st_mode\",    \"protection bits\"},\n    {\"st_ino\",     \"inode\"},\n    {\"st_dev\",     \"device\"},\n    {\"st_nlink\",   \"number of hard links\"},\n    {\"st_uid\",     \"user ID of owner\"},\n    {\"st_gid\",     \"group ID of owner\"},\n    {\"st_size\",    \"total size, in bytes\"},\n    /* The NULL is replaced with PyStructSequence_UnnamedField later. */\n    {NULL,   \"integer time of last access\"},\n    {NULL,   \"integer time of last modification\"},\n    {NULL,   \"integer time of last change\"},\n    {\"st_atime\",   \"time of last access\"},\n    {\"st_mtime\",   \"time of last modification\"},\n    {\"st_ctime\",   \"time of last change\"},\n    {\"st_atime_ns\",   \"time of last access in nanoseconds\"},\n    {\"st_mtime_ns\",   \"time of last modification in nanoseconds\"},\n    {\"st_ctime_ns\",   \"time of last change in nanoseconds\"},\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n    {\"st_blksize\", \"blocksize for filesystem I/O\"},\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_BLOCKS\n    {\"st_blocks\",  \"number of blocks allocated\"},\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_RDEV\n    {\"st_rdev\",    \"device type (if inode device)\"},\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_FLAGS\n    {\"st_flags\",   \"user defined flags for file\"},\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_GEN\n    {\"st_gen\",    \"generation number\"},\n#endif\n#if defined(HAVE_STRUCT_STAT_ST_BIRTHTIME) || defined(MS_WINDOWS)\n    {\"st_birthtime\",   \"time of creation\"},\n#endif\n#ifdef MS_WINDOWS\n    {\"st_birthtime_ns\", \"time of creation in nanoseconds\"},\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_FILE_ATTRIBUTES\n    {\"st_file_attributes\", \"Windows file attribute bits\"},\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_FSTYPE\n    {\"st_fstype\",  \"Type of filesystem\"},\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_REPARSE_TAG\n    {\"st_reparse_tag\", \"Windows reparse tag\"},\n#endif\n    {0}\n};\n\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n#define ST_BLKSIZE_IDX 16\n#else\n#define ST_BLKSIZE_IDX 15\n#endif\n\n#ifdef HAVE_STRUCT_STAT_ST_BLOCKS\n#define ST_BLOCKS_IDX (ST_BLKSIZE_IDX+1)\n#else\n#define ST_BLOCKS_IDX ST_BLKSIZE_IDX\n#endif\n\n#ifdef HAVE_STRUCT_STAT_ST_RDEV\n#define ST_RDEV_IDX (ST_BLOCKS_IDX+1)\n#else\n#define ST_RDEV_IDX ST_BLOCKS_IDX\n#endif\n\n#ifdef HAVE_STRUCT_STAT_ST_FLAGS\n#define ST_FLAGS_IDX (ST_RDEV_IDX+1)\n#else\n#define ST_FLAGS_IDX ST_RDEV_IDX\n#endif\n\n#ifdef HAVE_STRUCT_STAT_ST_GEN\n#define ST_GEN_IDX (ST_FLAGS_IDX+1)\n#else\n#define ST_GEN_IDX ST_FLAGS_IDX\n#endif\n\n#if defined(HAVE_STRUCT_STAT_ST_BIRTHTIME) || defined(MS_WINDOWS)\n#define ST_BIRTHTIME_IDX (ST_GEN_IDX+1)\n#else\n#define ST_BIRTHTIME_IDX ST_GEN_IDX\n#endif\n\n#ifdef MS_WINDOWS\n#define ST_BIRTHTIME_NS_IDX (ST_BIRTHTIME_IDX+1)\n#else\n#define ST_BIRTHTIME_NS_IDX ST_BIRTHTIME_IDX\n#endif\n\n#if defined(HAVE_STRUCT_STAT_ST_FILE_ATTRIBUTES) || defined(MS_WINDOWS)\n#define ST_FILE_ATTRIBUTES_IDX (ST_BIRTHTIME_NS_IDX+1)\n#else\n#define ST_FILE_ATTRIBUTES_IDX ST_BIRTHTIME_NS_IDX\n#endif\n\n#ifdef HAVE_STRUCT_STAT_ST_FSTYPE\n#define ST_FSTYPE_IDX (ST_FILE_ATTRIBUTES_IDX+1)\n#else\n#define ST_FSTYPE_IDX ST_FILE_ATTRIBUTES_IDX\n#endif\n\n#ifdef HAVE_STRUCT_STAT_ST_REPARSE_TAG\n#define ST_REPARSE_TAG_IDX (ST_FSTYPE_IDX+1)\n#else\n#define ST_REPARSE_TAG_IDX ST_FSTYPE_IDX\n#endif\n\nstatic PyStructSequence_Desc stat_result_desc = {\n    \"stat_result\", /* name */\n    stat_result__doc__, /* doc */\n    stat_result_fields,\n    10\n};\n\nPyDoc_STRVAR(statvfs_result__doc__,\n\"statvfs_result: Result from statvfs or fstatvfs.\\n\\n\\\nThis object may be accessed either as a tuple of\\n\\\n  (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),\\n\\\nor via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.\\n\\\n\\n\\\nSee os.statvfs for more information.\");\n\nstatic PyStructSequence_Field statvfs_result_fields[] = {\n    {\"f_bsize\",  },\n    {\"f_frsize\", },\n    {\"f_blocks\", },\n    {\"f_bfree\",  },\n    {\"f_bavail\", },\n    {\"f_files\",  },\n    {\"f_ffree\",  },\n    {\"f_favail\", },\n    {\"f_flag\",   },\n    {\"f_namemax\",},\n    {\"f_fsid\",   },\n    {0}\n};\n\nstatic PyStructSequence_Desc statvfs_result_desc = {\n    \"statvfs_result\", /* name */\n    statvfs_result__doc__, /* doc */\n    statvfs_result_fields,\n    10\n};\n\n#if defined(HAVE_WAITID)\nPyDoc_STRVAR(waitid_result__doc__,\n\"waitid_result: Result from waitid.\\n\\n\\\nThis object may be accessed either as a tuple of\\n\\\n  (si_pid, si_uid, si_signo, si_status, si_code),\\n\\\nor via the attributes si_pid, si_uid, and so on.\\n\\\n\\n\\\nSee os.waitid for more information.\");\n\nstatic PyStructSequence_Field waitid_result_fields[] = {\n    {\"si_pid\",  },\n    {\"si_uid\", },\n    {\"si_signo\", },\n    {\"si_status\",  },\n    {\"si_code\", },\n    {0}\n};\n\nstatic PyStructSequence_Desc waitid_result_desc = {\n    \"waitid_result\", /* name */\n    waitid_result__doc__, /* doc */\n    waitid_result_fields,\n    5\n};\n#endif\n\nstatic PyObject *\nstatresult_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyStructSequence *result;\n    int i;\n\n    // ht_module doesn't get set in PyStructSequence_NewType(),\n    // so we can't use PyType_GetModule().\n    PyObject *mod = PyImport_GetModule(MODNAME_OBJ);\n    if (mod == NULL) {\n        return NULL;\n    }\n    _posixstate *state = get_posix_state(mod);\n    Py_DECREF(mod);\n    if (state == NULL) {\n        return NULL;\n    }\n#define structseq_new state->statresult_new_orig\n\n    result = (PyStructSequence*)structseq_new(type, args, kwds);\n    if (!result)\n        return NULL;\n    /* If we have been initialized from a tuple,\n       st_?time might be set to None. Initialize it\n       from the int slots.  */\n    for (i = 7; i <= 9; i++) {\n        if (result->ob_item[i+3] == Py_None) {\n            Py_DECREF(Py_None);\n            result->ob_item[i+3] = Py_NewRef(result->ob_item[i]);\n        }\n    }\n    return (PyObject*)result;\n}\n\nstatic int\n_posix_clear(PyObject *module)\n{\n    _posixstate *state = get_posix_state(module);\n    Py_CLEAR(state->billion);\n    Py_CLEAR(state->DirEntryType);\n    Py_CLEAR(state->ScandirIteratorType);\n#if defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDPARAM)\n    Py_CLEAR(state->SchedParamType);\n#endif\n    Py_CLEAR(state->StatResultType);\n    Py_CLEAR(state->StatVFSResultType);\n    Py_CLEAR(state->TerminalSizeType);\n    Py_CLEAR(state->TimesResultType);\n    Py_CLEAR(state->UnameResultType);\n#if defined(HAVE_WAITID)\n    Py_CLEAR(state->WaitidResultType);\n#endif\n#if defined(HAVE_WAIT3) || defined(HAVE_WAIT4)\n    Py_CLEAR(state->struct_rusage);\n#endif\n    Py_CLEAR(state->st_mode);\n    return 0;\n}\n\nstatic int\n_posix_traverse(PyObject *module, visitproc visit, void *arg)\n{\n    _posixstate *state = get_posix_state(module);\n    Py_VISIT(state->billion);\n    Py_VISIT(state->DirEntryType);\n    Py_VISIT(state->ScandirIteratorType);\n#if defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDPARAM)\n    Py_VISIT(state->SchedParamType);\n#endif\n    Py_VISIT(state->StatResultType);\n    Py_VISIT(state->StatVFSResultType);\n    Py_VISIT(state->TerminalSizeType);\n    Py_VISIT(state->TimesResultType);\n    Py_VISIT(state->UnameResultType);\n#if defined(HAVE_WAITID)\n    Py_VISIT(state->WaitidResultType);\n#endif\n#if defined(HAVE_WAIT3) || defined(HAVE_WAIT4)\n    Py_VISIT(state->struct_rusage);\n#endif\n    Py_VISIT(state->st_mode);\n    return 0;\n}\n\nstatic void\n_posix_free(void *module)\n{\n   _posix_clear((PyObject *)module);\n}\n\nstatic int\nfill_time(PyObject *module, PyObject *v, int s_index, int f_index, int ns_index, time_t sec, unsigned long nsec)\n{\n    assert(!PyErr_Occurred());\n\n    int res = -1;\n    PyObject *s_in_ns = NULL;\n    PyObject *ns_total = NULL;\n    PyObject *float_s = NULL;\n\n    PyObject *s = _PyLong_FromTime_t(sec);\n    PyObject *ns_fractional = PyLong_FromUnsignedLong(nsec);\n    if (!(s && ns_fractional)) {\n        goto exit;\n    }\n\n    s_in_ns = PyNumber_Multiply(s, get_posix_state(module)->billion);\n    if (!s_in_ns) {\n        goto exit;\n    }\n\n    ns_total = PyNumber_Add(s_in_ns, ns_fractional);\n    if (!ns_total)\n        goto exit;\n\n    float_s = PyFloat_FromDouble(sec + 1e-9*nsec);\n    if (!float_s) {\n        goto exit;\n    }\n\n    if (s_index >= 0) {\n        PyStructSequence_SET_ITEM(v, s_index, s);\n        s = NULL;\n    }\n    if (f_index >= 0) {\n        PyStructSequence_SET_ITEM(v, f_index, float_s);\n        float_s = NULL;\n    }\n    if (ns_index >= 0) {\n        PyStructSequence_SET_ITEM(v, ns_index, ns_total);\n        ns_total = NULL;\n    }\n\n    assert(!PyErr_Occurred());\n    res = 0;\n\nexit:\n    Py_XDECREF(s);\n    Py_XDECREF(ns_fractional);\n    Py_XDECREF(s_in_ns);\n    Py_XDECREF(ns_total);\n    Py_XDECREF(float_s);\n    return res;\n}\n\n#ifdef MS_WINDOWS\nstatic PyObject*\n_pystat_l128_from_l64_l64(uint64_t low, uint64_t high)\n{\n    PyObject *o_low = PyLong_FromUnsignedLongLong(low);\n    if (!o_low || !high) {\n        return o_low;\n    }\n    PyObject *o_high = PyLong_FromUnsignedLongLong(high);\n    PyObject *l64 = o_high ? PyLong_FromLong(64) : NULL;\n    if (!l64) {\n        Py_XDECREF(o_high);\n        Py_DECREF(o_low);\n        return NULL;\n    }\n    Py_SETREF(o_high, PyNumber_Lshift(o_high, l64));\n    Py_DECREF(l64);\n    if (!o_high) {\n        Py_DECREF(o_low);\n        return NULL;\n    }\n    Py_SETREF(o_low, PyNumber_Add(o_low, o_high));\n    Py_DECREF(o_high);\n    return o_low;\n}\n#endif\n\n/* pack a system stat C structure into the Python stat tuple\n   (used by posix_stat() and posix_fstat()) */\nstatic PyObject*\n_pystat_fromstructstat(PyObject *module, STRUCT_STAT *st)\n{\n    assert(!PyErr_Occurred());\n\n    PyObject *StatResultType = get_posix_state(module)->StatResultType;\n    PyObject *v = PyStructSequence_New((PyTypeObject *)StatResultType);\n    if (v == NULL) {\n        return NULL;\n    }\n\n#define SET_ITEM(pos, expr) \\\n    do { \\\n        PyObject *obj = (expr); \\\n        if (obj == NULL) { \\\n            goto error; \\\n        } \\\n        PyStructSequence_SET_ITEM(v, (pos), obj); \\\n    } while (0)\n\n    SET_ITEM(0, PyLong_FromLong((long)st->st_mode));\n#ifdef MS_WINDOWS\n    SET_ITEM(1, _pystat_l128_from_l64_l64(st->st_ino, st->st_ino_high));\n    SET_ITEM(2, PyLong_FromUnsignedLongLong(st->st_dev));\n#else\n    static_assert(sizeof(unsigned long long) >= sizeof(st->st_ino),\n                  \"stat.st_ino is larger than unsigned long long\");\n    SET_ITEM(1, PyLong_FromUnsignedLongLong(st->st_ino));\n    SET_ITEM(2, _PyLong_FromDev(st->st_dev));\n#endif\n    SET_ITEM(3, PyLong_FromLong((long)st->st_nlink));\n#if defined(MS_WINDOWS)\n    SET_ITEM(4, PyLong_FromLong(0));\n    SET_ITEM(5, PyLong_FromLong(0));\n#else\n    SET_ITEM(4, _PyLong_FromUid(st->st_uid));\n    SET_ITEM(5, _PyLong_FromGid(st->st_gid));\n#endif\n    static_assert(sizeof(long long) >= sizeof(st->st_size),\n                  \"stat.st_size is larger than long long\");\n    SET_ITEM(6, PyLong_FromLongLong(st->st_size));\n\n    // Set st_atime, st_mtime and st_ctime\n    unsigned long ansec, mnsec, cnsec;\n#if defined(HAVE_STAT_TV_NSEC)\n    ansec = st->st_atim.tv_nsec;\n    mnsec = st->st_mtim.tv_nsec;\n    cnsec = st->st_ctim.tv_nsec;\n#elif defined(HAVE_STAT_TV_NSEC2)\n    ansec = st->st_atimespec.tv_nsec;\n    mnsec = st->st_mtimespec.tv_nsec;\n    cnsec = st->st_ctimespec.tv_nsec;\n#elif defined(HAVE_STAT_NSEC)\n    ansec = st->st_atime_nsec;\n    mnsec = st->st_mtime_nsec;\n    cnsec = st->st_ctime_nsec;\n#else\n    ansec = mnsec = cnsec = 0;\n#endif\n    if (fill_time(module, v, 7, 10, 13, st->st_atime, ansec) < 0) {\n        goto error;\n    }\n    if (fill_time(module, v, 8, 11, 14, st->st_mtime, mnsec) < 0) {\n        goto error;\n    }\n    if (fill_time(module, v, 9, 12, 15, st->st_ctime, cnsec) < 0) {\n        goto error;\n    }\n\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n    SET_ITEM(ST_BLKSIZE_IDX, PyLong_FromLong((long)st->st_blksize));\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_BLOCKS\n    SET_ITEM(ST_BLOCKS_IDX, PyLong_FromLong((long)st->st_blocks));\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_RDEV\n    SET_ITEM(ST_RDEV_IDX, PyLong_FromLong((long)st->st_rdev));\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_GEN\n    SET_ITEM(ST_GEN_IDX, PyLong_FromLong((long)st->st_gen));\n#endif\n#if defined(HAVE_STRUCT_STAT_ST_BIRTHTIME)\n    {\n      unsigned long bsec, bnsec;\n      bsec = (long)st->st_birthtime;\n#ifdef HAVE_STAT_TV_NSEC2\n      bnsec = st->st_birthtimespec.tv_nsec;\n#else\n      bnsec = 0;\n#endif\n      SET_ITEM(ST_BIRTHTIME_IDX, PyFloat_FromDouble(bsec + bnsec * 1e-9));\n    }\n#elif defined(MS_WINDOWS)\n    if (fill_time(module, v, -1, ST_BIRTHTIME_IDX, ST_BIRTHTIME_NS_IDX,\n                  st->st_birthtime, st->st_birthtime_nsec) < 0) {\n        goto error;\n    }\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_FLAGS\n    SET_ITEM(ST_FLAGS_IDX, PyLong_FromLong((long)st->st_flags));\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_FILE_ATTRIBUTES\n    SET_ITEM(ST_FILE_ATTRIBUTES_IDX,\n             PyLong_FromUnsignedLong(st->st_file_attributes));\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_FSTYPE\n   SET_ITEM(ST_FSTYPE_IDX, PyUnicode_FromString(st->st_fstype));\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_REPARSE_TAG\n    SET_ITEM(ST_REPARSE_TAG_IDX, PyLong_FromUnsignedLong(st->st_reparse_tag));\n#endif\n\n    assert(!PyErr_Occurred());\n    return v;\n\nerror:\n    Py_DECREF(v);\n    return NULL;\n\n#undef SET_ITEM\n}\n\n/* POSIX methods */\n\n\nstatic PyObject *\nposix_do_stat(PyObject *module, const char *function_name, path_t *path,\n              int dir_fd, int follow_symlinks)\n{\n    STRUCT_STAT st;\n    int result;\n\n#ifdef HAVE_FSTATAT\n    int fstatat_unavailable = 0;\n#endif\n\n#if !defined(MS_WINDOWS) && !defined(HAVE_FSTATAT) && !defined(HAVE_LSTAT)\n    if (follow_symlinks_specified(function_name, follow_symlinks))\n        return NULL;\n#endif\n\n    if (path_and_dir_fd_invalid(\"stat\", path, dir_fd) ||\n        dir_fd_and_fd_invalid(\"stat\", dir_fd, path->fd) ||\n        fd_and_follow_symlinks_invalid(\"stat\", path->fd, follow_symlinks))\n        return NULL;\n\n    Py_BEGIN_ALLOW_THREADS\n    if (path->fd != -1)\n        result = FSTAT(path->fd, &st);\n#ifdef MS_WINDOWS\n    else if (follow_symlinks)\n        result = win32_stat(path->wide, &st);\n    else\n        result = win32_lstat(path->wide, &st);\n#else\n    else\n#if defined(HAVE_LSTAT)\n    if ((!follow_symlinks) && (dir_fd == DEFAULT_DIR_FD))\n        result = LSTAT(path->narrow, &st);\n    else\n#endif /* HAVE_LSTAT */\n#ifdef HAVE_FSTATAT\n    if ((dir_fd != DEFAULT_DIR_FD) || !follow_symlinks) {\n        if (HAVE_FSTATAT_RUNTIME) {\n            result = fstatat(dir_fd, path->narrow, &st,\n                         follow_symlinks ? 0 : AT_SYMLINK_NOFOLLOW);\n\n        } else {\n            fstatat_unavailable = 1;\n        }\n    } else\n#endif /* HAVE_FSTATAT */\n        result = STAT(path->narrow, &st);\n#endif /* MS_WINDOWS */\n    Py_END_ALLOW_THREADS\n\n#ifdef HAVE_FSTATAT\n    if (fstatat_unavailable) {\n        argument_unavailable_error(\"stat\", \"dir_fd\");\n        return NULL;\n    }\n#endif\n\n    if (result != 0) {\n        return path_error(path);\n    }\n\n    return _pystat_fromstructstat(module, &st);\n}\n\n/*[python input]\n\nfor s in \"\"\"\n\nFACCESSAT\nFCHMODAT\nFCHOWNAT\nFSTATAT\nLINKAT\nMKDIRAT\nMKFIFOAT\nMKNODAT\nOPENAT\nREADLINKAT\nSYMLINKAT\nUNLINKAT\n\n\"\"\".strip().split():\n    s = s.strip()\n    print(\"\"\"\n#ifdef HAVE_{s}\n    #define {s}_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define {s}_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\"\"\".rstrip().format(s=s))\n\nfor s in \"\"\"\n\nFCHDIR\nFCHMOD\nFCHOWN\nFDOPENDIR\nFEXECVE\nFPATHCONF\nFSTATVFS\nFTRUNCATE\n\n\"\"\".strip().split():\n    s = s.strip()\n    print(\"\"\"\n#ifdef HAVE_{s}\n    #define PATH_HAVE_{s} 1\n#else\n    #define PATH_HAVE_{s} 0\n#endif\n\n\"\"\".rstrip().format(s=s))\n[python start generated code]*/\n\n#ifdef HAVE_FACCESSAT\n    #define FACCESSAT_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define FACCESSAT_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\n#ifdef HAVE_FCHMODAT\n    #define FCHMODAT_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define FCHMODAT_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\n#ifdef HAVE_FCHOWNAT\n    #define FCHOWNAT_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define FCHOWNAT_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\n#ifdef HAVE_FSTATAT\n    #define FSTATAT_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define FSTATAT_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\n#ifdef HAVE_LINKAT\n    #define LINKAT_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define LINKAT_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\n#ifdef HAVE_MKDIRAT\n    #define MKDIRAT_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define MKDIRAT_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\n#ifdef HAVE_MKFIFOAT\n    #define MKFIFOAT_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define MKFIFOAT_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\n#ifdef HAVE_MKNODAT\n    #define MKNODAT_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define MKNODAT_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\n#ifdef HAVE_OPENAT\n    #define OPENAT_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define OPENAT_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\n#ifdef HAVE_READLINKAT\n    #define READLINKAT_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define READLINKAT_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\n#ifdef HAVE_SYMLINKAT\n    #define SYMLINKAT_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define SYMLINKAT_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\n#ifdef HAVE_UNLINKAT\n    #define UNLINKAT_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define UNLINKAT_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\n#ifdef HAVE_FCHDIR\n    #define PATH_HAVE_FCHDIR 1\n#else\n    #define PATH_HAVE_FCHDIR 0\n#endif\n\n#ifdef HAVE_FCHMOD\n    #define PATH_HAVE_FCHMOD 1\n#else\n    #define PATH_HAVE_FCHMOD 0\n#endif\n\n#ifdef HAVE_FCHOWN\n    #define PATH_HAVE_FCHOWN 1\n#else\n    #define PATH_HAVE_FCHOWN 0\n#endif\n\n#ifdef HAVE_FDOPENDIR\n    #define PATH_HAVE_FDOPENDIR 1\n#else\n    #define PATH_HAVE_FDOPENDIR 0\n#endif\n\n#ifdef HAVE_FEXECVE\n    #define PATH_HAVE_FEXECVE 1\n#else\n    #define PATH_HAVE_FEXECVE 0\n#endif\n\n#ifdef HAVE_FPATHCONF\n    #define PATH_HAVE_FPATHCONF 1\n#else\n    #define PATH_HAVE_FPATHCONF 0\n#endif\n\n#ifdef HAVE_FSTATVFS\n    #define PATH_HAVE_FSTATVFS 1\n#else\n    #define PATH_HAVE_FSTATVFS 0\n#endif\n\n#ifdef HAVE_FTRUNCATE\n    #define PATH_HAVE_FTRUNCATE 1\n#else\n    #define PATH_HAVE_FTRUNCATE 0\n#endif\n/*[python end generated code: output=4bd4f6f7d41267f1 input=80b4c890b6774ea5]*/\n\n#ifdef MS_WINDOWS\n    #undef PATH_HAVE_FTRUNCATE\n    #define PATH_HAVE_FTRUNCATE 1\n    #undef PATH_HAVE_FCHMOD\n    #define PATH_HAVE_FCHMOD 1\n#endif\n\n/*[python input]\n\nclass path_t_converter(CConverter):\n\n    type = \"path_t\"\n    impl_by_reference = True\n    parse_by_reference = True\n\n    converter = 'path_converter'\n\n    def converter_init(self, *, allow_fd=False, make_wide=None,\n                       nonstrict=False, nullable=False,\n                       suppress_value_error=False):\n        # right now path_t doesn't support default values.\n        # to support a default value, you'll need to override initialize().\n        if self.default not in (unspecified, None):\n            fail(\"Can't specify a default to the path_t converter!\")\n\n        if self.c_default not in (None, 'Py_None'):\n            raise RuntimeError(\"Can't specify a c_default to the path_t converter!\")\n\n        self.nullable = nullable\n        self.nonstrict = nonstrict\n        self.make_wide = make_wide\n        self.suppress_value_error = suppress_value_error\n        self.allow_fd = allow_fd\n\n    def pre_render(self):\n        def strify(value):\n            if isinstance(value, str):\n                return value\n            return str(int(bool(value)))\n\n        # add self.py_name here when merging with posixmodule conversion\n        if self.make_wide is None:\n            self.c_default = 'PATH_T_INITIALIZE_P(\"{}\", \"{}\", {}, {}, {}, {})'.format(\n                self.function.name,\n                self.name,\n                strify(self.nullable),\n                strify(self.nonstrict),\n                strify(self.suppress_value_error),\n                strify(self.allow_fd),\n            )\n        else:\n            self.c_default = 'PATH_T_INITIALIZE(\"{}\", \"{}\", {}, {}, {}, {}, {})'.format(\n                self.function.name,\n                self.name,\n                strify(self.nullable),\n                strify(self.nonstrict),\n                strify(self.make_wide),\n                strify(self.suppress_value_error),\n                strify(self.allow_fd),\n            )\n\n    def cleanup(self):\n        return \"path_cleanup(&\" + self.name + \");\\n\"\n\n\nclass dir_fd_converter(CConverter):\n    type = 'int'\n\n    def converter_init(self, requires=None):\n        if self.default in (unspecified, None):\n            self.c_default = 'DEFAULT_DIR_FD'\n        if isinstance(requires, str):\n            self.converter = requires.upper() + '_DIR_FD_CONVERTER'\n        else:\n            self.converter = 'dir_fd_converter'\n\nclass uid_t_converter(CConverter):\n    type = \"uid_t\"\n    converter = '_Py_Uid_Converter'\n\nclass gid_t_converter(CConverter):\n    type = \"gid_t\"\n    converter = '_Py_Gid_Converter'\n\nclass dev_t_converter(CConverter):\n    type = 'dev_t'\n    converter = '_Py_Dev_Converter'\n\nclass dev_t_return_converter(unsigned_long_return_converter):\n    type = 'dev_t'\n    conversion_fn = '_PyLong_FromDev'\n    unsigned_cast = '(dev_t)'\n\nclass FSConverter_converter(CConverter):\n    type = 'PyObject *'\n    converter = 'PyUnicode_FSConverter'\n    def converter_init(self):\n        if self.default is not unspecified:\n            fail(\"FSConverter_converter does not support default values\")\n        self.c_default = 'NULL'\n\n    def cleanup(self):\n        return \"Py_XDECREF(\" + self.name + \");\\n\"\n\nclass pid_t_converter(CConverter):\n    type = 'pid_t'\n    format_unit = '\" _Py_PARSE_PID \"'\n\nclass idtype_t_converter(int_converter):\n    type = 'idtype_t'\n\nclass id_t_converter(CConverter):\n    type = 'id_t'\n    format_unit = '\" _Py_PARSE_PID \"'\n\nclass intptr_t_converter(CConverter):\n    type = 'intptr_t'\n    format_unit = '\" _Py_PARSE_INTPTR \"'\n\nclass Py_off_t_converter(CConverter):\n    type = 'Py_off_t'\n    converter = 'Py_off_t_converter'\n\nclass Py_off_t_return_converter(long_return_converter):\n    type = 'Py_off_t'\n    conversion_fn = 'PyLong_FromPy_off_t'\n\nclass path_confname_converter(CConverter):\n    type=\"int\"\n    converter=\"conv_path_confname\"\n\nclass confstr_confname_converter(path_confname_converter):\n    converter='conv_confstr_confname'\n\nclass sysconf_confname_converter(path_confname_converter):\n    converter=\"conv_sysconf_confname\"\n\n[python start generated code]*/\n/*[python end generated code: output=da39a3ee5e6b4b0d input=577cb476e5d64960]*/\n\n/*[clinic input]\n\nos.stat\n\n    path : path_t(allow_fd=True)\n        Path to be examined; can be string, bytes, a path-like object or\n        open-file-descriptor int.\n\n    *\n\n    dir_fd : dir_fd(requires='fstatat') = None\n        If not None, it should be a file descriptor open to a directory,\n        and path should be a relative string; path will then be relative to\n        that directory.\n\n    follow_symlinks: bool = True\n        If False, and the last element of the path is a symbolic link,\n        stat will examine the symbolic link itself instead of the file\n        the link points to.\n\nPerform a stat system call on the given path.\n\ndir_fd and follow_symlinks may not be implemented\n  on your platform.  If they are unavailable, using them will raise a\n  NotImplementedError.\n\nIt's an error to use dir_fd or follow_symlinks when specifying path as\n  an open file descriptor.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_stat_impl(PyObject *module, path_t *path, int dir_fd, int follow_symlinks)\n/*[clinic end generated code: output=7d4976e6f18a59c5 input=01d362ebcc06996b]*/\n{\n    return posix_do_stat(module, \"stat\", path, dir_fd, follow_symlinks);\n}\n\n\n/*[clinic input]\nos.lstat\n\n    path : path_t\n\n    *\n\n    dir_fd : dir_fd(requires='fstatat') = None\n\nPerform a stat system call on the given path, without following symbolic links.\n\nLike stat(), but do not follow symbolic links.\nEquivalent to stat(path, follow_symlinks=False).\n[clinic start generated code]*/\n\nstatic PyObject *\nos_lstat_impl(PyObject *module, path_t *path, int dir_fd)\n/*[clinic end generated code: output=ef82a5d35ce8ab37 input=0b7474765927b925]*/\n{\n    int follow_symlinks = 0;\n    return posix_do_stat(module, \"lstat\", path, dir_fd, follow_symlinks);\n}\n\n\n/*[clinic input]\nos.access -> bool\n\n    path: path_t\n        Path to be tested; can be string, bytes, or a path-like object.\n\n    mode: int\n        Operating-system mode bitfield.  Can be F_OK to test existence,\n        or the inclusive-OR of R_OK, W_OK, and X_OK.\n\n    *\n\n    dir_fd : dir_fd(requires='faccessat') = None\n        If not None, it should be a file descriptor open to a directory,\n        and path should be relative; path will then be relative to that\n        directory.\n\n    effective_ids: bool = False\n        If True, access will use the effective uid/gid instead of\n        the real uid/gid.\n\n    follow_symlinks: bool = True\n        If False, and the last element of the path is a symbolic link,\n        access will examine the symbolic link itself instead of the file\n        the link points to.\n\nUse the real uid/gid to test for access to a path.\n\n{parameters}\ndir_fd, effective_ids, and follow_symlinks may not be implemented\n  on your platform.  If they are unavailable, using them will raise a\n  NotImplementedError.\n\nNote that most operations will use the effective uid/gid, therefore this\n  routine can be used in a suid/sgid environment to test if the invoking user\n  has the specified access to the path.\n\n[clinic start generated code]*/\n\nstatic int\nos_access_impl(PyObject *module, path_t *path, int mode, int dir_fd,\n               int effective_ids, int follow_symlinks)\n/*[clinic end generated code: output=cf84158bc90b1a77 input=3ffe4e650ee3bf20]*/\n{\n    int return_value;\n\n#ifdef MS_WINDOWS\n    DWORD attr;\n#else\n    int result;\n#endif\n\n#ifdef HAVE_FACCESSAT\n    int faccessat_unavailable = 0;\n#endif\n\n#ifndef HAVE_FACCESSAT\n    if (follow_symlinks_specified(\"access\", follow_symlinks))\n        return -1;\n\n    if (effective_ids) {\n        argument_unavailable_error(\"access\", \"effective_ids\");\n        return -1;\n    }\n#endif\n\n#ifdef MS_WINDOWS\n    Py_BEGIN_ALLOW_THREADS\n    attr = GetFileAttributesW(path->wide);\n    Py_END_ALLOW_THREADS\n\n    /*\n     * Access is possible if\n     *   * we didn't get a -1, and\n     *     * write access wasn't requested,\n     *     * or the file isn't read-only,\n     *     * or it's a directory.\n     * (Directories cannot be read-only on Windows.)\n    */\n    return_value = (attr != INVALID_FILE_ATTRIBUTES) &&\n            (!(mode & 2) ||\n            !(attr & FILE_ATTRIBUTE_READONLY) ||\n            (attr & FILE_ATTRIBUTE_DIRECTORY));\n#else\n\n    Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_FACCESSAT\n    if ((dir_fd != DEFAULT_DIR_FD) ||\n        effective_ids ||\n        !follow_symlinks) {\n\n        if (HAVE_FACCESSAT_RUNTIME) {\n            int flags = 0;\n            if (!follow_symlinks)\n                flags |= AT_SYMLINK_NOFOLLOW;\n            if (effective_ids)\n                flags |= AT_EACCESS;\n            result = faccessat(dir_fd, path->narrow, mode, flags);\n        } else {\n            faccessat_unavailable = 1;\n        }\n    }\n    else\n#endif\n        result = access(path->narrow, mode);\n    Py_END_ALLOW_THREADS\n\n#ifdef HAVE_FACCESSAT\n    if (faccessat_unavailable) {\n        if (dir_fd != DEFAULT_DIR_FD) {\n            argument_unavailable_error(\"access\", \"dir_fd\");\n            return -1;\n        }\n        if (follow_symlinks_specified(\"access\", follow_symlinks))\n            return -1;\n\n        if (effective_ids) {\n            argument_unavailable_error(\"access\", \"effective_ids\");\n            return -1;\n        }\n        /* should be unreachable */\n        return -1;\n    }\n#endif\n    return_value = !result;\n#endif\n\n    return return_value;\n}\n\n#ifndef F_OK\n#define F_OK 0\n#endif\n#ifndef R_OK\n#define R_OK 4\n#endif\n#ifndef W_OK\n#define W_OK 2\n#endif\n#ifndef X_OK\n#define X_OK 1\n#endif\n\n\n#ifdef HAVE_TTYNAME\n/*[clinic input]\nos.ttyname\n\n    fd: int\n        Integer file descriptor handle.\n\n    /\n\nReturn the name of the terminal device connected to 'fd'.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_ttyname_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=c424d2e9d1cd636a input=9ff5a58b08115c55]*/\n{\n\n    long size = sysconf(_SC_TTY_NAME_MAX);\n    if (size == -1) {\n        return posix_error();\n    }\n    char *buffer = (char *)PyMem_RawMalloc(size);\n    if (buffer == NULL) {\n        return PyErr_NoMemory();\n    }\n    int ret = ttyname_r(fd, buffer, size);\n    if (ret != 0) {\n        PyMem_RawFree(buffer);\n        errno = ret;\n        return posix_error();\n    }\n    PyObject *res = PyUnicode_DecodeFSDefault(buffer);\n    PyMem_RawFree(buffer);\n    return res;\n}\n#endif\n\n#ifdef HAVE_CTERMID\n/*[clinic input]\nos.ctermid\n\nReturn the name of the controlling terminal for this process.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_ctermid_impl(PyObject *module)\n/*[clinic end generated code: output=02f017e6c9e620db input=3b87fdd52556382d]*/\n{\n    char *ret;\n    char buffer[L_ctermid];\n\n#ifdef USE_CTERMID_R\n    ret = ctermid_r(buffer);\n#else\n    ret = ctermid(buffer);\n#endif\n    if (ret == NULL)\n        return posix_error();\n    return PyUnicode_DecodeFSDefault(buffer);\n}\n#endif /* HAVE_CTERMID */\n\n\n/*[clinic input]\nos.chdir\n\n    path: path_t(allow_fd='PATH_HAVE_FCHDIR')\n\nChange the current working directory to the specified path.\n\npath may always be specified as a string.\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_chdir_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=3be6400eee26eaae input=1a4a15b4d12cb15d]*/\n{\n    int result;\n\n    if (PySys_Audit(\"os.chdir\", \"(O)\", path->object) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n#ifdef MS_WINDOWS\n    /* on unix, success = 0, on windows, success = !0 */\n    result = !win32_wchdir(path->wide);\n#else\n#ifdef HAVE_FCHDIR\n    if (path->fd != -1)\n        result = fchdir(path->fd);\n    else\n#endif\n        result = chdir(path->narrow);\n#endif\n    Py_END_ALLOW_THREADS\n\n    if (result) {\n        return path_error(path);\n    }\n\n    Py_RETURN_NONE;\n}\n\n\n#ifdef HAVE_FCHDIR\n/*[clinic input]\nos.fchdir\n\n    fd: fildes\n\nChange to the directory of the given file descriptor.\n\nfd must be opened on a directory, not a file.\nEquivalent to os.chdir(fd).\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_fchdir_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=42e064ec4dc00ab0 input=18e816479a2fa985]*/\n{\n    if (PySys_Audit(\"os.chdir\", \"(i)\", fd) < 0) {\n        return NULL;\n    }\n    return posix_fildes_fd(fd, fchdir);\n}\n#endif /* HAVE_FCHDIR */\n\n#ifdef MS_WINDOWS\n# define CHMOD_DEFAULT_FOLLOW_SYMLINKS 0\n#else\n# define CHMOD_DEFAULT_FOLLOW_SYMLINKS 1\n#endif\n\n#ifdef MS_WINDOWS\nstatic int\nwin32_lchmod(LPCWSTR path, int mode)\n{\n    DWORD attr = GetFileAttributesW(path);\n    if (attr == INVALID_FILE_ATTRIBUTES) {\n        return 0;\n    }\n    if (mode & _S_IWRITE) {\n        attr &= ~FILE_ATTRIBUTE_READONLY;\n    }\n    else {\n        attr |= FILE_ATTRIBUTE_READONLY;\n    }\n    return SetFileAttributesW(path, attr);\n}\n\nstatic int\nwin32_hchmod(HANDLE hfile, int mode)\n{\n    FILE_BASIC_INFO info;\n    if (!GetFileInformationByHandleEx(hfile, FileBasicInfo,\n                                      &info, sizeof(info)))\n    {\n        return 0;\n    }\n    if (mode & _S_IWRITE) {\n        info.FileAttributes &= ~FILE_ATTRIBUTE_READONLY;\n    }\n    else {\n        info.FileAttributes |= FILE_ATTRIBUTE_READONLY;\n    }\n    return SetFileInformationByHandle(hfile, FileBasicInfo,\n                                      &info, sizeof(info));\n}\n\nstatic int\nwin32_fchmod(int fd, int mode)\n{\n    HANDLE hfile = _Py_get_osfhandle_noraise(fd);\n    if (hfile == INVALID_HANDLE_VALUE) {\n        SetLastError(ERROR_INVALID_HANDLE);\n        return 0;\n    }\n    return win32_hchmod(hfile, mode);\n}\n\n#endif /* MS_WINDOWS */\n\n/*[clinic input]\nos.chmod\n\n    path: path_t(allow_fd='PATH_HAVE_FCHMOD')\n        Path to be modified.  May always be specified as a str, bytes, or a path-like object.\n        On some platforms, path may also be specified as an open file descriptor.\n        If this functionality is unavailable, using it raises an exception.\n\n    mode: int\n        Operating-system mode bitfield.\n        Be careful when using number literals for *mode*. The conventional UNIX notation for\n        numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\n        Python.\n\n    *\n\n    dir_fd : dir_fd(requires='fchmodat') = None\n        If not None, it should be a file descriptor open to a directory,\n        and path should be relative; path will then be relative to that\n        directory.\n\n    follow_symlinks: bool(c_default=\"CHMOD_DEFAULT_FOLLOW_SYMLINKS\", \\\n                          py_default=\"(os.name != 'nt')\") = CHMOD_DEFAULT_FOLLOW_SYMLINKS\n        If False, and the last element of the path is a symbolic link,\n        chmod will modify the symbolic link itself instead of the file\n        the link points to.\n\nChange the access permissions of a file.\n\nIt is an error to use dir_fd or follow_symlinks when specifying path as\n  an open file descriptor.\ndir_fd and follow_symlinks may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_chmod_impl(PyObject *module, path_t *path, int mode, int dir_fd,\n              int follow_symlinks)\n/*[clinic end generated code: output=5cf6a94915cc7bff input=fcf115d174b9f3d8]*/\n{\n    int result;\n\n#ifdef HAVE_FCHMODAT\n    int fchmodat_nofollow_unsupported = 0;\n    int fchmodat_unsupported = 0;\n#endif\n\n#if !(defined(HAVE_FCHMODAT) || defined(HAVE_LCHMOD) || defined(MS_WINDOWS))\n    if (follow_symlinks_specified(\"chmod\", follow_symlinks))\n        return NULL;\n#endif\n\n    if (PySys_Audit(\"os.chmod\", \"Oii\", path->object, mode,\n                    dir_fd == DEFAULT_DIR_FD ? -1 : dir_fd) < 0) {\n        return NULL;\n    }\n\n#ifdef MS_WINDOWS\n    result = 0;\n    Py_BEGIN_ALLOW_THREADS\n    if (path->fd != -1) {\n        result = win32_fchmod(path->fd, mode);\n    }\n    else if (follow_symlinks) {\n        HANDLE hfile = CreateFileW(path->wide,\n                                   FILE_READ_ATTRIBUTES|FILE_WRITE_ATTRIBUTES,\n                                   0, NULL,\n                                   OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n        if (hfile != INVALID_HANDLE_VALUE) {\n            result = win32_hchmod(hfile, mode);\n            (void)CloseHandle(hfile);\n        }\n    }\n    else {\n        result = win32_lchmod(path->wide, mode);\n    }\n    Py_END_ALLOW_THREADS\n    if (!result) {\n        return path_error(path);\n    }\n#else /* MS_WINDOWS */\n    Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_FCHMOD\n    if (path->fd != -1)\n        result = fchmod(path->fd, mode);\n    else\n#endif /* HAVE_CHMOD */\n#ifdef HAVE_LCHMOD\n    if ((!follow_symlinks) && (dir_fd == DEFAULT_DIR_FD))\n        result = lchmod(path->narrow, mode);\n    else\n#endif /* HAVE_LCHMOD */\n#ifdef HAVE_FCHMODAT\n    if ((dir_fd != DEFAULT_DIR_FD) || !follow_symlinks) {\n        if (HAVE_FCHMODAT_RUNTIME) {\n            /*\n             * fchmodat() doesn't currently support AT_SYMLINK_NOFOLLOW!\n             * The documentation specifically shows how to use it,\n             * and then says it isn't implemented yet.\n             * (true on linux with glibc 2.15, and openindiana 3.x)\n             *\n             * Once it is supported, os.chmod will automatically\n             * support dir_fd and follow_symlinks=False.  (Hopefully.)\n             * Until then, we need to be careful what exception we raise.\n             */\n            result = fchmodat(dir_fd, path->narrow, mode,\n                              follow_symlinks ? 0 : AT_SYMLINK_NOFOLLOW);\n            /*\n             * But wait!  We can't throw the exception without allowing threads,\n             * and we can't do that in this nested scope.  (Macro trickery, sigh.)\n             */\n            fchmodat_nofollow_unsupported =\n                             result &&\n                             ((errno == ENOTSUP) || (errno == EOPNOTSUPP)) &&\n                             !follow_symlinks;\n        } else {\n            fchmodat_unsupported = 1;\n            fchmodat_nofollow_unsupported = 1;\n\n            result = -1;\n        }\n    }\n    else\n#endif /* HAVE_FHCMODAT */\n    {\n#ifdef HAVE_CHMOD\n        result = chmod(path->narrow, mode);\n#elif defined(__wasi__)\n        // WASI SDK 15.0 does not support chmod.\n        // Ignore missing syscall for now.\n        result = 0;\n#else\n        result = -1;\n        errno = ENOSYS;\n#endif\n    }\n    Py_END_ALLOW_THREADS\n\n    if (result) {\n#ifdef HAVE_FCHMODAT\n        if (fchmodat_unsupported) {\n            if (dir_fd != DEFAULT_DIR_FD) {\n                argument_unavailable_error(\"chmod\", \"dir_fd\");\n                return NULL;\n            }\n        }\n\n        if (fchmodat_nofollow_unsupported) {\n            if (dir_fd != DEFAULT_DIR_FD)\n                dir_fd_and_follow_symlinks_invalid(\"chmod\",\n                                                   dir_fd, follow_symlinks);\n            else\n                follow_symlinks_specified(\"chmod\", follow_symlinks);\n            return NULL;\n        }\n        else\n#endif /* HAVE_FCHMODAT */\n        return path_error(path);\n    }\n#endif /* MS_WINDOWS */\n\n    Py_RETURN_NONE;\n}\n\n\n#if defined(HAVE_FCHMOD) || defined(MS_WINDOWS)\n/*[clinic input]\nos.fchmod\n\n    fd: int\n        The file descriptor of the file to be modified.\n    mode: int\n        Operating-system mode bitfield.\n        Be careful when using number literals for *mode*. The conventional UNIX notation for\n        numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\n        Python.\n\nChange the access permissions of the file given by file descriptor fd.\n\nEquivalent to os.chmod(fd, mode).\n[clinic start generated code]*/\n\nstatic PyObject *\nos_fchmod_impl(PyObject *module, int fd, int mode)\n/*[clinic end generated code: output=afd9bc05b4e426b3 input=b5594618bbbc22df]*/\n{\n    int res;\n\n    if (PySys_Audit(\"os.chmod\", \"iii\", fd, mode, -1) < 0) {\n        return NULL;\n    }\n\n#ifdef MS_WINDOWS\n    res = 0;\n    Py_BEGIN_ALLOW_THREADS\n    res = win32_fchmod(fd, mode);\n    Py_END_ALLOW_THREADS\n    if (!res) {\n        return PyErr_SetFromWindowsErr(0);\n    }\n#else /* MS_WINDOWS */\n    int async_err = 0;\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        res = fchmod(fd, mode);\n        Py_END_ALLOW_THREADS\n    } while (res != 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    if (res != 0)\n        return (!async_err) ? posix_error() : NULL;\n#endif /* MS_WINDOWS */\n\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_FCHMOD || MS_WINDOWS */\n\n\n#if defined(HAVE_LCHMOD) || defined(MS_WINDOWS)\n/*[clinic input]\nos.lchmod\n\n    path: path_t\n    mode: int\n\nChange the access permissions of a file, without following symbolic links.\n\nIf path is a symlink, this affects the link itself rather than the target.\nEquivalent to chmod(path, mode, follow_symlinks=False).\"\n[clinic start generated code]*/\n\nstatic PyObject *\nos_lchmod_impl(PyObject *module, path_t *path, int mode)\n/*[clinic end generated code: output=082344022b51a1d5 input=90c5663c7465d24f]*/\n{\n    int res;\n    if (PySys_Audit(\"os.chmod\", \"Oii\", path->object, mode, -1) < 0) {\n        return NULL;\n    }\n#ifdef MS_WINDOWS\n    Py_BEGIN_ALLOW_THREADS\n    res = win32_lchmod(path->wide, mode);\n    Py_END_ALLOW_THREADS\n    if (!res) {\n        path_error(path);\n        return NULL;\n    }\n#else /* MS_WINDOWS */\n    Py_BEGIN_ALLOW_THREADS\n    res = lchmod(path->narrow, mode);\n    Py_END_ALLOW_THREADS\n    if (res < 0) {\n        path_error(path);\n        return NULL;\n    }\n#endif /* MS_WINDOWS */\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_LCHMOD || MS_WINDOWS */\n\n\n#ifdef HAVE_CHFLAGS\n/*[clinic input]\nos.chflags\n\n    path: path_t\n    flags: unsigned_long(bitwise=True)\n    follow_symlinks: bool=True\n\nSet file flags.\n\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, chflags will change flags on the symbolic link itself instead of the\n  file the link points to.\nfollow_symlinks may not be implemented on your platform.  If it is\nunavailable, using it will raise a NotImplementedError.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_chflags_impl(PyObject *module, path_t *path, unsigned long flags,\n                int follow_symlinks)\n/*[clinic end generated code: output=85571c6737661ce9 input=0327e29feb876236]*/\n{\n    int result;\n\n#ifndef HAVE_LCHFLAGS\n    if (follow_symlinks_specified(\"chflags\", follow_symlinks))\n        return NULL;\n#endif\n\n    if (PySys_Audit(\"os.chflags\", \"Ok\", path->object, flags) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_LCHFLAGS\n    if (!follow_symlinks)\n        result = lchflags(path->narrow, flags);\n    else\n#endif\n        result = chflags(path->narrow, flags);\n    Py_END_ALLOW_THREADS\n\n    if (result)\n        return path_error(path);\n\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_CHFLAGS */\n\n\n#ifdef HAVE_LCHFLAGS\n/*[clinic input]\nos.lchflags\n\n    path: path_t\n    flags: unsigned_long(bitwise=True)\n\nSet file flags.\n\nThis function will not follow symbolic links.\nEquivalent to chflags(path, flags, follow_symlinks=False).\n[clinic start generated code]*/\n\nstatic PyObject *\nos_lchflags_impl(PyObject *module, path_t *path, unsigned long flags)\n/*[clinic end generated code: output=30ae958695c07316 input=f9f82ea8b585ca9d]*/\n{\n    int res;\n    if (PySys_Audit(\"os.chflags\", \"Ok\", path->object, flags) < 0) {\n        return NULL;\n    }\n    Py_BEGIN_ALLOW_THREADS\n    res = lchflags(path->narrow, flags);\n    Py_END_ALLOW_THREADS\n    if (res < 0) {\n        return path_error(path);\n    }\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_LCHFLAGS */\n\n\n#ifdef HAVE_CHROOT\n/*[clinic input]\nos.chroot\n    path: path_t\n\nChange root directory to path.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_chroot_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=de80befc763a4475 input=14822965652c3dc3]*/\n{\n    int res;\n    Py_BEGIN_ALLOW_THREADS\n    res = chroot(path->narrow);\n    Py_END_ALLOW_THREADS\n    if (res < 0)\n        return path_error(path);\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_CHROOT */\n\n\n#ifdef HAVE_FSYNC\n/*[clinic input]\nos.fsync\n\n    fd: fildes\n\nForce write of fd to disk.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_fsync_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=4a10d773f52b3584 input=21c3645c056967f2]*/\n{\n    return posix_fildes_fd(fd, fsync);\n}\n#endif /* HAVE_FSYNC */\n\n\n#ifdef HAVE_SYNC\n/*[clinic input]\nos.sync\n\nForce write of everything to disk.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sync_impl(PyObject *module)\n/*[clinic end generated code: output=2796b1f0818cd71c input=84749fe5e9b404ff]*/\n{\n    Py_BEGIN_ALLOW_THREADS\n    sync();\n    Py_END_ALLOW_THREADS\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SYNC */\n\n\n#ifdef HAVE_FDATASYNC\n#ifdef __hpux\nextern int fdatasync(int); /* On HP-UX, in libc but not in unistd.h */\n#endif\n\n/*[clinic input]\nos.fdatasync\n\n    fd: fildes\n\nForce write of fd to disk without forcing update of metadata.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_fdatasync_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=b4b9698b5d7e26dd input=bc74791ee54dd291]*/\n{\n    return posix_fildes_fd(fd, fdatasync);\n}\n#endif /* HAVE_FDATASYNC */\n\n\n#ifdef HAVE_CHOWN\n/*[clinic input]\nos.chown\n\n    path : path_t(allow_fd='PATH_HAVE_FCHOWN')\n        Path to be examined; can be string, bytes, a path-like object, or open-file-descriptor int.\n\n    uid: uid_t\n\n    gid: gid_t\n\n    *\n\n    dir_fd : dir_fd(requires='fchownat') = None\n        If not None, it should be a file descriptor open to a directory,\n        and path should be relative; path will then be relative to that\n        directory.\n\n    follow_symlinks: bool = True\n        If False, and the last element of the path is a symbolic link,\n        stat will examine the symbolic link itself instead of the file\n        the link points to.\n\nChange the owner and group id of path to the numeric uid and gid.\\\n\npath may always be specified as a string.\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, chown will modify the symbolic link itself instead of the file the\n  link points to.\nIt is an error to use dir_fd or follow_symlinks when specifying path as\n  an open file descriptor.\ndir_fd and follow_symlinks may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_chown_impl(PyObject *module, path_t *path, uid_t uid, gid_t gid,\n              int dir_fd, int follow_symlinks)\n/*[clinic end generated code: output=4beadab0db5f70cd input=b08c5ec67996a97d]*/\n{\n    int result;\n\n#if defined(HAVE_FCHOWNAT)\n    int fchownat_unsupported = 0;\n#endif\n\n#if !(defined(HAVE_LCHOWN) || defined(HAVE_FCHOWNAT))\n    if (follow_symlinks_specified(\"chown\", follow_symlinks))\n        return NULL;\n#endif\n    if (dir_fd_and_fd_invalid(\"chown\", dir_fd, path->fd) ||\n        fd_and_follow_symlinks_invalid(\"chown\", path->fd, follow_symlinks))\n        return NULL;\n\n    if (PySys_Audit(\"os.chown\", \"OIIi\", path->object, uid, gid,\n                    dir_fd == DEFAULT_DIR_FD ? -1 : dir_fd) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_FCHOWN\n    if (path->fd != -1)\n        result = fchown(path->fd, uid, gid);\n    else\n#endif\n#ifdef HAVE_LCHOWN\n    if ((!follow_symlinks) && (dir_fd == DEFAULT_DIR_FD))\n        result = lchown(path->narrow, uid, gid);\n    else\n#endif\n#ifdef HAVE_FCHOWNAT\n    if ((dir_fd != DEFAULT_DIR_FD) || (!follow_symlinks)) {\n      if (HAVE_FCHOWNAT_RUNTIME) {\n        result = fchownat(dir_fd, path->narrow, uid, gid,\n                          follow_symlinks ? 0 : AT_SYMLINK_NOFOLLOW);\n      } else {\n         fchownat_unsupported = 1;\n      }\n    } else\n#endif\n        result = chown(path->narrow, uid, gid);\n    Py_END_ALLOW_THREADS\n\n#ifdef HAVE_FCHOWNAT\n    if (fchownat_unsupported) {\n        /* This would be incorrect if the current platform\n         * doesn't support lchown.\n         */\n        argument_unavailable_error(NULL, \"dir_fd\");\n        return NULL;\n    }\n#endif\n\n    if (result)\n        return path_error(path);\n\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_CHOWN */\n\n\n#ifdef HAVE_FCHOWN\n/*[clinic input]\nos.fchown\n\n    fd: int\n    uid: uid_t\n    gid: gid_t\n\nChange the owner and group id of the file specified by file descriptor.\n\nEquivalent to os.chown(fd, uid, gid).\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_fchown_impl(PyObject *module, int fd, uid_t uid, gid_t gid)\n/*[clinic end generated code: output=97d21cbd5a4350a6 input=3af544ba1b13a0d7]*/\n{\n    int res;\n    int async_err = 0;\n\n    if (PySys_Audit(\"os.chown\", \"iIIi\", fd, uid, gid, -1) < 0) {\n        return NULL;\n    }\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        res = fchown(fd, uid, gid);\n        Py_END_ALLOW_THREADS\n    } while (res != 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    if (res != 0)\n        return (!async_err) ? posix_error() : NULL;\n\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_FCHOWN */\n\n\n#ifdef HAVE_LCHOWN\n/*[clinic input]\nos.lchown\n\n    path : path_t\n    uid: uid_t\n    gid: gid_t\n\nChange the owner and group id of path to the numeric uid and gid.\n\nThis function will not follow symbolic links.\nEquivalent to os.chown(path, uid, gid, follow_symlinks=False).\n[clinic start generated code]*/\n\nstatic PyObject *\nos_lchown_impl(PyObject *module, path_t *path, uid_t uid, gid_t gid)\n/*[clinic end generated code: output=25eaf6af412fdf2f input=b1c6014d563a7161]*/\n{\n    int res;\n    if (PySys_Audit(\"os.chown\", \"OIIi\", path->object, uid, gid, -1) < 0) {\n        return NULL;\n    }\n    Py_BEGIN_ALLOW_THREADS\n    res = lchown(path->narrow, uid, gid);\n    Py_END_ALLOW_THREADS\n    if (res < 0) {\n        return path_error(path);\n    }\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_LCHOWN */\n\n\nstatic PyObject *\nposix_getcwd(int use_bytes)\n{\n#ifdef MS_WINDOWS\n    wchar_t wbuf[MAXPATHLEN];\n    wchar_t *wbuf2 = wbuf;\n    DWORD len;\n\n    Py_BEGIN_ALLOW_THREADS\n    len = GetCurrentDirectoryW(Py_ARRAY_LENGTH(wbuf), wbuf);\n    /* If the buffer is large enough, len does not include the\n       terminating \\0. If the buffer is too small, len includes\n       the space needed for the terminator. */\n    if (len >= Py_ARRAY_LENGTH(wbuf)) {\n        if (len <= PY_SSIZE_T_MAX / sizeof(wchar_t)) {\n            wbuf2 = PyMem_RawMalloc(len * sizeof(wchar_t));\n        }\n        else {\n            wbuf2 = NULL;\n        }\n        if (wbuf2) {\n            len = GetCurrentDirectoryW(len, wbuf2);\n        }\n    }\n    Py_END_ALLOW_THREADS\n\n    if (!wbuf2) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    if (!len) {\n        PyErr_SetFromWindowsErr(0);\n        if (wbuf2 != wbuf)\n            PyMem_RawFree(wbuf2);\n        return NULL;\n    }\n\n    PyObject *resobj = PyUnicode_FromWideChar(wbuf2, len);\n    if (wbuf2 != wbuf) {\n        PyMem_RawFree(wbuf2);\n    }\n\n    if (use_bytes) {\n        if (resobj == NULL) {\n            return NULL;\n        }\n        Py_SETREF(resobj, PyUnicode_EncodeFSDefault(resobj));\n    }\n\n    return resobj;\n#else\n    const size_t chunk = 1024;\n\n    char *buf = NULL;\n    char *cwd = NULL;\n    size_t buflen = 0;\n\n    Py_BEGIN_ALLOW_THREADS\n    do {\n        char *newbuf;\n        if (buflen <= PY_SSIZE_T_MAX - chunk) {\n            buflen += chunk;\n            newbuf = PyMem_RawRealloc(buf, buflen);\n        }\n        else {\n            newbuf = NULL;\n        }\n        if (newbuf == NULL) {\n            PyMem_RawFree(buf);\n            buf = NULL;\n            break;\n        }\n        buf = newbuf;\n\n        cwd = getcwd(buf, buflen);\n    } while (cwd == NULL && errno == ERANGE);\n    Py_END_ALLOW_THREADS\n\n    if (buf == NULL) {\n        return PyErr_NoMemory();\n    }\n    if (cwd == NULL) {\n        posix_error();\n        PyMem_RawFree(buf);\n        return NULL;\n    }\n\n    PyObject *obj;\n    if (use_bytes) {\n        obj = PyBytes_FromStringAndSize(buf, strlen(buf));\n    }\n    else {\n        obj = PyUnicode_DecodeFSDefault(buf);\n    }\n#ifdef __linux__\n    if (buf[0] != '/') {\n        /*\n         * On Linux >= 2.6.36 with glibc < 2.27, getcwd() can return a\n         * relative pathname starting with '(unreachable)'. We detect this\n         * and fail with ENOENT, matching newer glibc behaviour.\n         */\n        errno = ENOENT;\n        path_object_error(obj);\n        PyMem_RawFree(buf);\n        return NULL;\n    }\n#endif\n    assert(buf[0] == '/');\n    PyMem_RawFree(buf);\n\n    return obj;\n#endif   /* !MS_WINDOWS */\n}\n\n\n/*[clinic input]\nos.getcwd\n\nReturn a unicode string representing the current working directory.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getcwd_impl(PyObject *module)\n/*[clinic end generated code: output=21badfae2ea99ddc input=f069211bb70e3d39]*/\n{\n    return posix_getcwd(0);\n}\n\n\n/*[clinic input]\nos.getcwdb\n\nReturn a bytes string representing the current working directory.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getcwdb_impl(PyObject *module)\n/*[clinic end generated code: output=3dd47909480e4824 input=f6f6a378dad3d9cb]*/\n{\n    return posix_getcwd(1);\n}\n\n\n#if ((!defined(HAVE_LINK)) && defined(MS_WINDOWS))\n#define HAVE_LINK 1\n#endif\n\n#ifdef HAVE_LINK\n/*[clinic input]\n\nos.link\n\n    src : path_t\n    dst : path_t\n    *\n    src_dir_fd : dir_fd = None\n    dst_dir_fd : dir_fd = None\n    follow_symlinks: bool = True\n\nCreate a hard link to a file.\n\nIf either src_dir_fd or dst_dir_fd is not None, it should be a file\n  descriptor open to a directory, and the respective path string (src or dst)\n  should be relative; the path will then be relative to that directory.\nIf follow_symlinks is False, and the last element of src is a symbolic\n  link, link will create a link to the symbolic link itself instead of the\n  file the link points to.\nsrc_dir_fd, dst_dir_fd, and follow_symlinks may not be implemented on your\n  platform.  If they are unavailable, using them will raise a\n  NotImplementedError.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_link_impl(PyObject *module, path_t *src, path_t *dst, int src_dir_fd,\n             int dst_dir_fd, int follow_symlinks)\n/*[clinic end generated code: output=7f00f6007fd5269a input=b0095ebbcbaa7e04]*/\n{\n#ifdef MS_WINDOWS\n    BOOL result = FALSE;\n#else\n    int result;\n#endif\n#if defined(HAVE_LINKAT)\n    int linkat_unavailable = 0;\n#endif\n\n#ifndef HAVE_LINKAT\n    if ((src_dir_fd != DEFAULT_DIR_FD) || (dst_dir_fd != DEFAULT_DIR_FD)) {\n        argument_unavailable_error(\"link\", \"src_dir_fd and dst_dir_fd\");\n        return NULL;\n    }\n#endif\n\n#ifndef MS_WINDOWS\n    if ((src->narrow && dst->wide) || (src->wide && dst->narrow)) {\n        PyErr_SetString(PyExc_NotImplementedError,\n                        \"link: src and dst must be the same type\");\n        return NULL;\n    }\n#endif\n\n    if (PySys_Audit(\"os.link\", \"OOii\", src->object, dst->object,\n                    src_dir_fd == DEFAULT_DIR_FD ? -1 : src_dir_fd,\n                    dst_dir_fd == DEFAULT_DIR_FD ? -1 : dst_dir_fd) < 0) {\n        return NULL;\n    }\n\n#ifdef MS_WINDOWS\n    Py_BEGIN_ALLOW_THREADS\n    result = CreateHardLinkW(dst->wide, src->wide, NULL);\n    Py_END_ALLOW_THREADS\n\n    if (!result)\n        return path_error2(src, dst);\n#else\n    Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_LINKAT\n    if ((src_dir_fd != DEFAULT_DIR_FD) ||\n        (dst_dir_fd != DEFAULT_DIR_FD) ||\n        (!follow_symlinks)) {\n\n        if (HAVE_LINKAT_RUNTIME) {\n\n            result = linkat(src_dir_fd, src->narrow,\n                dst_dir_fd, dst->narrow,\n                follow_symlinks ? AT_SYMLINK_FOLLOW : 0);\n\n        }\n#ifdef __APPLE__\n        else {\n            if (src_dir_fd == DEFAULT_DIR_FD && dst_dir_fd == DEFAULT_DIR_FD) {\n                /* See issue 41355: This matches the behaviour of !HAVE_LINKAT */\n                result = link(src->narrow, dst->narrow);\n            } else {\n                linkat_unavailable = 1;\n            }\n        }\n#endif\n    }\n    else\n#endif /* HAVE_LINKAT */\n        result = link(src->narrow, dst->narrow);\n    Py_END_ALLOW_THREADS\n\n#ifdef HAVE_LINKAT\n    if (linkat_unavailable) {\n        /* Either or both dir_fd arguments were specified */\n        if (src_dir_fd  != DEFAULT_DIR_FD) {\n            argument_unavailable_error(\"link\", \"src_dir_fd\");\n        } else {\n            argument_unavailable_error(\"link\", \"dst_dir_fd\");\n        }\n        return NULL;\n    }\n#endif\n\n    if (result)\n        return path_error2(src, dst);\n#endif /* MS_WINDOWS */\n\n    Py_RETURN_NONE;\n}\n#endif\n\n\n#if defined(MS_WINDOWS) && !defined(HAVE_OPENDIR)\nstatic PyObject *\n_listdir_windows_no_opendir(path_t *path, PyObject *list)\n{\n    PyObject *v;\n    HANDLE hFindFile = INVALID_HANDLE_VALUE;\n    BOOL result, return_bytes;\n    wchar_t namebuf[MAX_PATH+4]; /* Overallocate for \"\\*.*\" */\n    /* only claim to have space for MAX_PATH */\n    Py_ssize_t len = Py_ARRAY_LENGTH(namebuf)-4;\n    wchar_t *wnamebuf = NULL;\n\n    WIN32_FIND_DATAW wFileData;\n    const wchar_t *po_wchars;\n\n    if (!path->wide) { /* Default arg: \".\" */\n        po_wchars = L\".\";\n        len = 1;\n        return_bytes = 0;\n    } else {\n        po_wchars = path->wide;\n        len = wcslen(path->wide);\n        return_bytes = PyBytes_Check(path->object);\n    }\n    /* The +5 is so we can append \"\\\\*.*\\0\" */\n    wnamebuf = PyMem_New(wchar_t, len + 5);\n    if (!wnamebuf) {\n        PyErr_NoMemory();\n        goto exit;\n    }\n    wcscpy(wnamebuf, po_wchars);\n    if (len > 0) {\n        wchar_t wch = wnamebuf[len-1];\n        if (wch != SEP && wch != ALTSEP && wch != L':')\n            wnamebuf[len++] = SEP;\n        wcscpy(wnamebuf + len, L\"*.*\");\n    }\n    if ((list = PyList_New(0)) == NULL) {\n        goto exit;\n    }\n    Py_BEGIN_ALLOW_THREADS\n    hFindFile = FindFirstFileW(wnamebuf, &wFileData);\n    Py_END_ALLOW_THREADS\n    if (hFindFile == INVALID_HANDLE_VALUE) {\n        int error = GetLastError();\n        if (error == ERROR_FILE_NOT_FOUND)\n            goto exit;\n        path_error(path);\n        Py_CLEAR(list);\n        goto exit;\n    }\n    do {\n        /* Skip over . and .. */\n        if (wcscmp(wFileData.cFileName, L\".\") != 0 &&\n            wcscmp(wFileData.cFileName, L\"..\") != 0) {\n            v = PyUnicode_FromWideChar(wFileData.cFileName,\n                                       wcslen(wFileData.cFileName));\n            if (return_bytes && v) {\n                Py_SETREF(v, PyUnicode_EncodeFSDefault(v));\n            }\n            if (v == NULL) {\n                Py_CLEAR(list);\n                break;\n            }\n            if (PyList_Append(list, v) != 0) {\n                Py_DECREF(v);\n                Py_CLEAR(list);\n                break;\n            }\n            Py_DECREF(v);\n        }\n        Py_BEGIN_ALLOW_THREADS\n        result = FindNextFileW(hFindFile, &wFileData);\n        Py_END_ALLOW_THREADS\n        /* FindNextFile sets error to ERROR_NO_MORE_FILES if\n           it got to the end of the directory. */\n        if (!result && GetLastError() != ERROR_NO_MORE_FILES) {\n            path_error(path);\n            Py_CLEAR(list);\n            goto exit;\n        }\n    } while (result == TRUE);\n\nexit:\n    if (hFindFile != INVALID_HANDLE_VALUE) {\n        if (FindClose(hFindFile) == FALSE) {\n            if (list != NULL) {\n                path_error(path);\n                Py_CLEAR(list);\n            }\n        }\n    }\n    PyMem_Free(wnamebuf);\n\n    return list;\n}  /* end of _listdir_windows_no_opendir */\n\n#else  /* thus POSIX, ie: not (MS_WINDOWS and not HAVE_OPENDIR) */\n\nstatic PyObject *\n_posix_listdir(path_t *path, PyObject *list)\n{\n    PyObject *v;\n    DIR *dirp = NULL;\n    struct dirent *ep;\n    int return_str; /* if false, return bytes */\n#ifdef HAVE_FDOPENDIR\n    int fd = -1;\n#endif\n\n    errno = 0;\n#ifdef HAVE_FDOPENDIR\n    if (path->fd != -1) {\n      if (HAVE_FDOPENDIR_RUNTIME) {\n        /* closedir() closes the FD, so we duplicate it */\n        fd = _Py_dup(path->fd);\n        if (fd == -1)\n            return NULL;\n\n        return_str = 1;\n\n        Py_BEGIN_ALLOW_THREADS\n        dirp = fdopendir(fd);\n        Py_END_ALLOW_THREADS\n      } else {\n        PyErr_SetString(PyExc_TypeError,\n            \"listdir: path should be string, bytes, os.PathLike or None, not int\");\n        return NULL;\n      }\n    }\n    else\n#endif\n    {\n        const char *name;\n        if (path->narrow) {\n            name = path->narrow;\n            /* only return bytes if they specified a bytes object */\n            return_str = !PyBytes_Check(path->object);\n        }\n        else {\n            name = \".\";\n            return_str = 1;\n        }\n\n        Py_BEGIN_ALLOW_THREADS\n        dirp = opendir(name);\n        Py_END_ALLOW_THREADS\n    }\n\n    if (dirp == NULL) {\n        path_error(path);\n        list = NULL;\n#ifdef HAVE_FDOPENDIR\n        if (fd != -1) {\n            Py_BEGIN_ALLOW_THREADS\n            close(fd);\n            Py_END_ALLOW_THREADS\n        }\n#endif\n        goto exit;\n    }\n    if ((list = PyList_New(0)) == NULL) {\n        goto exit;\n    }\n    for (;;) {\n        errno = 0;\n        Py_BEGIN_ALLOW_THREADS\n        ep = readdir(dirp);\n        Py_END_ALLOW_THREADS\n        if (ep == NULL) {\n            if (errno == 0) {\n                break;\n            } else {\n                path_error(path);\n                Py_CLEAR(list);\n                goto exit;\n            }\n        }\n        if (ep->d_name[0] == '.' &&\n            (NAMLEN(ep) == 1 ||\n             (ep->d_name[1] == '.' && NAMLEN(ep) == 2)))\n            continue;\n        if (return_str)\n            v = PyUnicode_DecodeFSDefaultAndSize(ep->d_name, NAMLEN(ep));\n        else\n            v = PyBytes_FromStringAndSize(ep->d_name, NAMLEN(ep));\n        if (v == NULL) {\n            Py_CLEAR(list);\n            break;\n        }\n        if (PyList_Append(list, v) != 0) {\n            Py_DECREF(v);\n            Py_CLEAR(list);\n            break;\n        }\n        Py_DECREF(v);\n    }\n\nexit:\n    if (dirp != NULL) {\n        Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_FDOPENDIR\n        if (fd > -1)\n            rewinddir(dirp);\n#endif\n        closedir(dirp);\n        Py_END_ALLOW_THREADS\n    }\n\n    return list;\n}  /* end of _posix_listdir */\n#endif  /* which OS */\n\n\n/*[clinic input]\nos.listdir\n\n    path : path_t(nullable=True, allow_fd='PATH_HAVE_FDOPENDIR') = None\n\nReturn a list containing the names of the files in the directory.\n\npath can be specified as either str, bytes, or a path-like object.  If path is bytes,\n  the filenames returned will also be bytes; in all other circumstances\n  the filenames returned will be str.\nIf path is None, uses the path='.'.\nOn some platforms, path may also be specified as an open file descriptor;\\\n  the file descriptor must refer to a directory.\n  If this functionality is unavailable, using it raises NotImplementedError.\n\nThe list is in arbitrary order.  It does not include the special\nentries '.' and '..' even if they are present in the directory.\n\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_listdir_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=293045673fcd1a75 input=e3f58030f538295d]*/\n{\n    if (PySys_Audit(\"os.listdir\", \"O\",\n                    path->object ? path->object : Py_None) < 0) {\n        return NULL;\n    }\n#if defined(MS_WINDOWS) && !defined(HAVE_OPENDIR)\n    return _listdir_windows_no_opendir(path, NULL);\n#else\n    return _posix_listdir(path, NULL);\n#endif\n}\n\n\n#ifdef MS_WINDOWS\n\n/*[clinic input]\nos.listdrives\n\nReturn a list containing the names of drives in the system.\n\nA drive name typically looks like 'C:\\\\'.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_listdrives_impl(PyObject *module)\n/*[clinic end generated code: output=aaece9dacdf682b5 input=1af9ccc9e583798e]*/\n{\n    /* Number of possible drives is limited, so 256 should always be enough.\n       On the day when it is not, listmounts() will have to be used. */\n    wchar_t buffer[256];\n    DWORD buflen = Py_ARRAY_LENGTH(buffer);\n    PyObject *result = NULL;\n    if (PySys_Audit(\"os.listdrives\", NULL) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS;\n    buflen = GetLogicalDriveStringsW(buflen, buffer);\n    Py_END_ALLOW_THREADS;\n\n    if (!buflen) {\n        PyErr_SetFromWindowsErr(0);\n        return NULL;\n    } else if (buflen >= Py_ARRAY_LENGTH(buffer)) {\n        PyErr_SetFromWindowsErr(ERROR_MORE_DATA);\n        return NULL;\n    }\n\n    /* buflen includes a null terminator, so remove it */\n    PyObject *str = PyUnicode_FromWideChar(buffer, buflen - 1);\n    if (str) {\n        PyObject *nullchar = PyUnicode_FromStringAndSize(\"\\0\", 1);\n        if (nullchar) {\n            result = PyUnicode_Split(str, nullchar, -1);\n            Py_DECREF(nullchar);\n        }\n        Py_DECREF(str);\n    }\n    return result;\n}\n\n/*[clinic input]\nos.listvolumes\n\nReturn a list containing the volumes in the system.\n\nVolumes are typically represented as a GUID path.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_listvolumes_impl(PyObject *module)\n/*[clinic end generated code: output=534e10ea2bf9d386 input=f6e4e70371f11e99]*/\n{\n    PyObject *result = PyList_New(0);\n    HANDLE find = INVALID_HANDLE_VALUE;\n    wchar_t buffer[MAX_PATH + 1];\n    if (!result) {\n        return NULL;\n    }\n    if (PySys_Audit(\"os.listvolumes\", NULL) < 0) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    int err = 0;\n    Py_BEGIN_ALLOW_THREADS;\n    find = FindFirstVolumeW(buffer, Py_ARRAY_LENGTH(buffer));\n    if (find == INVALID_HANDLE_VALUE) {\n        err = GetLastError();\n    }\n    Py_END_ALLOW_THREADS;\n\n    while (!err) {\n        PyObject *s = PyUnicode_FromWideChar(buffer, -1);\n        if (!s || PyList_Append(result, s) < 0) {\n            Py_XDECREF(s);\n            Py_CLEAR(result);\n            break;\n        }\n        Py_DECREF(s);\n\n        Py_BEGIN_ALLOW_THREADS;\n        if (!FindNextVolumeW(find, buffer, Py_ARRAY_LENGTH(buffer))) {\n            err = GetLastError();\n        }\n        Py_END_ALLOW_THREADS;\n    }\n\n    if (find != INVALID_HANDLE_VALUE) {\n        Py_BEGIN_ALLOW_THREADS;\n        FindVolumeClose(find);\n        Py_END_ALLOW_THREADS;\n    }\n    if (err && err != ERROR_NO_MORE_FILES) {\n        PyErr_SetFromWindowsErr(err);\n        Py_XDECREF(result);\n        result = NULL;\n    }\n    return result;\n}\n\n\n/*[clinic input]\nos.listmounts\n\n    volume: path_t\n\nReturn a list containing mount points for a particular volume.\n\n'volume' should be a GUID path as returned from os.listvolumes.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_listmounts_impl(PyObject *module, path_t *volume)\n/*[clinic end generated code: output=06da49679de4512e input=a8a27178e3f67845]*/\n{\n    wchar_t default_buffer[MAX_PATH + 1];\n    DWORD buflen = Py_ARRAY_LENGTH(default_buffer);\n    LPWSTR buffer = default_buffer;\n    DWORD attributes;\n    PyObject *str = NULL;\n    PyObject *nullchar = NULL;\n    PyObject *result = NULL;\n\n    /* Ensure we have a valid volume path before continuing */\n    Py_BEGIN_ALLOW_THREADS\n    attributes = GetFileAttributesW(volume->wide);\n    Py_END_ALLOW_THREADS\n    if (attributes == INVALID_FILE_ATTRIBUTES &&\n        GetLastError() == ERROR_UNRECOGNIZED_VOLUME)\n    {\n        return PyErr_SetFromWindowsErr(ERROR_UNRECOGNIZED_VOLUME);\n    }\n\n    if (PySys_Audit(\"os.listmounts\", \"O\", volume->object) < 0) {\n        return NULL;\n    }\n\n    while (1) {\n        BOOL success;\n        Py_BEGIN_ALLOW_THREADS\n        success = GetVolumePathNamesForVolumeNameW(volume->wide, buffer,\n                                                   buflen, &buflen);\n        Py_END_ALLOW_THREADS\n        if (success) {\n            break;\n        }\n        if (GetLastError() != ERROR_MORE_DATA) {\n            PyErr_SetFromWindowsErr(0);\n            goto exit;\n        }\n        if (buffer != default_buffer) {\n            PyMem_Free((void *)buffer);\n        }\n        buffer = (wchar_t*)PyMem_Malloc(sizeof(wchar_t) * buflen);\n        if (!buffer) {\n            PyErr_NoMemory();\n            goto exit;\n        }\n    }\n    if (buflen < 2) {\n        result = PyList_New(0);\n        goto exit;\n    }\n    // buflen includes two null terminators, one for the last string\n    // and one for the array of strings.\n    str = PyUnicode_FromWideChar(buffer, buflen - 2);\n    nullchar = PyUnicode_FromStringAndSize(\"\\0\", 1);\n    if (str && nullchar) {\n        result = PyUnicode_Split(str, nullchar, -1);\n    }\nexit:\n    if (buffer != default_buffer) {\n        PyMem_Free(buffer);\n    }\n    Py_XDECREF(nullchar);\n    Py_XDECREF(str);\n    return result;\n}\n\n\n/*[clinic input]\nos._path_isdevdrive\n\n    path: path_t\n\nDetermines whether the specified path is on a Windows Dev Drive.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos__path_isdevdrive_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=1f437ea6677433a2 input=ee83e4996a48e23d]*/\n{\n#ifndef PERSISTENT_VOLUME_STATE_DEV_VOLUME\n    /* This flag will be documented at\n       https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/ns-ntifs-_file_fs_persistent_volume_information\n       after release, and will be available in the latest WinSDK.\n       We include the flag to avoid a specific version dependency\n       on the latest WinSDK. */\n    const int PERSISTENT_VOLUME_STATE_DEV_VOLUME = 0x00002000;\n#endif\n    int err = 0;\n    PyObject *r = NULL;\n    wchar_t volume[MAX_PATH];\n\n    Py_BEGIN_ALLOW_THREADS\n    if (!GetVolumePathNameW(path->wide, volume, MAX_PATH)) {\n        /* invalid path of some kind */\n        /* Note that this also includes the case where a volume is mounted\n           in a path longer than 260 characters. This is likely to be rare\n           and problematic for other reasons, so a (soft) failure in this\n           check seems okay. */\n        err = GetLastError();\n    } else if (GetDriveTypeW(volume) != DRIVE_FIXED) {\n        /* only care about local dev drives */\n        r = Py_False;\n    } else {\n        HANDLE hVolume = CreateFileW(\n            volume,\n            FILE_READ_ATTRIBUTES,\n            FILE_SHARE_READ | FILE_SHARE_WRITE,\n            NULL,\n            OPEN_EXISTING,\n            FILE_FLAG_BACKUP_SEMANTICS,\n            NULL\n        );\n        if (hVolume == INVALID_HANDLE_VALUE) {\n            err = GetLastError();\n        } else {\n            FILE_FS_PERSISTENT_VOLUME_INFORMATION volumeState = {0};\n            volumeState.Version = 1;\n            volumeState.FlagMask = PERSISTENT_VOLUME_STATE_DEV_VOLUME;\n            if (!DeviceIoControl(\n                hVolume,\n                FSCTL_QUERY_PERSISTENT_VOLUME_STATE,\n                &volumeState,\n                sizeof(volumeState),\n                &volumeState,\n                sizeof(volumeState),\n                NULL,\n                NULL\n            )) {\n                err = GetLastError();\n            }\n            CloseHandle(hVolume);\n            if (err == ERROR_INVALID_PARAMETER) {\n                /* not supported on this platform */\n                r = Py_False;\n            } else if (!err) {\n                r = (volumeState.VolumeFlags & PERSISTENT_VOLUME_STATE_DEV_VOLUME)\n                    ? Py_True : Py_False;\n            }\n        }\n    }\n    Py_END_ALLOW_THREADS\n\n    if (err) {\n        PyErr_SetFromWindowsErr(err);\n        return NULL;\n    }\n\n    if (r) {\n        return Py_NewRef(r);\n    }\n\n    return NULL;\n}\n\n\nint\n_PyOS_getfullpathname(const wchar_t *path, wchar_t **abspath_p)\n{\n    wchar_t woutbuf[MAX_PATH], *woutbufp = woutbuf;\n    DWORD result;\n\n    result = GetFullPathNameW(path,\n                              Py_ARRAY_LENGTH(woutbuf), woutbuf,\n                              NULL);\n    if (!result) {\n        return -1;\n    }\n\n    if (result >= Py_ARRAY_LENGTH(woutbuf)) {\n        if ((size_t)result <= (size_t)PY_SSIZE_T_MAX / sizeof(wchar_t)) {\n            woutbufp = PyMem_RawMalloc((size_t)result * sizeof(wchar_t));\n        }\n        else {\n            woutbufp = NULL;\n        }\n        if (!woutbufp) {\n            *abspath_p = NULL;\n            return 0;\n        }\n\n        result = GetFullPathNameW(path, result, woutbufp, NULL);\n        if (!result) {\n            PyMem_RawFree(woutbufp);\n            return -1;\n        }\n    }\n\n    if (woutbufp != woutbuf) {\n        *abspath_p = woutbufp;\n        return 0;\n    }\n\n    *abspath_p = _PyMem_RawWcsdup(woutbufp);\n    return 0;\n}\n\n\n/* A helper function for abspath on win32 */\n/*[clinic input]\nos._getfullpathname\n\n    path: path_t\n    /\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos__getfullpathname_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=bb8679d56845bc9b input=332ed537c29d0a3e]*/\n{\n    wchar_t *abspath;\n\n    if (_PyOS_getfullpathname(path->wide, &abspath) < 0) {\n        return win32_error_object(\"GetFullPathNameW\", path->object);\n    }\n    if (abspath == NULL) {\n        return PyErr_NoMemory();\n    }\n\n    PyObject *str = PyUnicode_FromWideChar(abspath, wcslen(abspath));\n    PyMem_RawFree(abspath);\n    if (str == NULL) {\n        return NULL;\n    }\n    if (PyBytes_Check(path->object)) {\n        Py_SETREF(str, PyUnicode_EncodeFSDefault(str));\n    }\n    return str;\n}\n\n\n/*[clinic input]\nos._getfinalpathname\n\n    path: path_t\n    /\n\nA helper function for samepath on windows.\n[clinic start generated code]*/\n\nstatic PyObject *\nos__getfinalpathname_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=621a3c79bc29ebfa input=2b6b6c7cbad5fb84]*/\n{\n    HANDLE hFile;\n    wchar_t buf[MAXPATHLEN], *target_path = buf;\n    int buf_size = Py_ARRAY_LENGTH(buf);\n    int result_length;\n    PyObject *result;\n\n    Py_BEGIN_ALLOW_THREADS\n    hFile = CreateFileW(\n        path->wide,\n        0, /* desired access */\n        0, /* share mode */\n        NULL, /* security attributes */\n        OPEN_EXISTING,\n        /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */\n        FILE_FLAG_BACKUP_SEMANTICS,\n        NULL);\n    Py_END_ALLOW_THREADS\n\n    if (hFile == INVALID_HANDLE_VALUE) {\n        return win32_error_object(\"CreateFileW\", path->object);\n    }\n\n    /* We have a good handle to the target, use it to determine the\n       target path name. */\n    while (1) {\n        Py_BEGIN_ALLOW_THREADS\n        result_length = GetFinalPathNameByHandleW(hFile, target_path,\n                                                  buf_size, VOLUME_NAME_DOS);\n        Py_END_ALLOW_THREADS\n\n        if (!result_length) {\n            result = win32_error_object(\"GetFinalPathNameByHandleW\",\n                                         path->object);\n            goto cleanup;\n        }\n\n        if (result_length < buf_size) {\n            break;\n        }\n\n        wchar_t *tmp;\n        tmp = PyMem_Realloc(target_path != buf ? target_path : NULL,\n                            result_length * sizeof(*tmp));\n        if (!tmp) {\n            result = PyErr_NoMemory();\n            goto cleanup;\n        }\n\n        buf_size = result_length;\n        target_path = tmp;\n    }\n\n    result = PyUnicode_FromWideChar(target_path, result_length);\n    if (result && PyBytes_Check(path->object)) {\n        Py_SETREF(result, PyUnicode_EncodeFSDefault(result));\n    }\n\ncleanup:\n    if (target_path != buf) {\n        PyMem_Free(target_path);\n    }\n    CloseHandle(hFile);\n    return result;\n}\n\n/*[clinic input]\nos._findfirstfile\n    path: path_t\n    /\nA function to get the real file name without accessing the file in Windows.\n[clinic start generated code]*/\n\nstatic PyObject *\nos__findfirstfile_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=106dd3f0779c83dd input=0734dff70f60e1a8]*/\n{\n    PyObject *result;\n    HANDLE hFindFile;\n    WIN32_FIND_DATAW wFileData;\n    WCHAR *wRealFileName;\n\n    Py_BEGIN_ALLOW_THREADS\n    hFindFile = FindFirstFileW(path->wide, &wFileData);\n    Py_END_ALLOW_THREADS\n\n    if (hFindFile == INVALID_HANDLE_VALUE) {\n        path_error(path);\n        return NULL;\n    }\n\n    wRealFileName = wFileData.cFileName;\n    result = PyUnicode_FromWideChar(wRealFileName, wcslen(wRealFileName));\n    FindClose(hFindFile);\n    return result;\n}\n\n\n/*[clinic input]\nos._getvolumepathname\n\n    path: path_t\n\nA helper function for ismount on Win32.\n[clinic start generated code]*/\n\nstatic PyObject *\nos__getvolumepathname_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=804c63fd13a1330b input=722b40565fa21552]*/\n{\n    PyObject *result;\n    wchar_t *mountpath=NULL;\n    size_t buflen;\n    BOOL ret;\n\n    /* Volume path should be shorter than entire path */\n    buflen = Py_MAX(path->length, MAX_PATH);\n\n    if (buflen > PY_DWORD_MAX) {\n        PyErr_SetString(PyExc_OverflowError, \"path too long\");\n        return NULL;\n    }\n\n    mountpath = PyMem_New(wchar_t, buflen);\n    if (mountpath == NULL)\n        return PyErr_NoMemory();\n\n    Py_BEGIN_ALLOW_THREADS\n    ret = GetVolumePathNameW(path->wide, mountpath,\n                             Py_SAFE_DOWNCAST(buflen, size_t, DWORD));\n    Py_END_ALLOW_THREADS\n\n    if (!ret) {\n        result = win32_error_object(\"_getvolumepathname\", path->object);\n        goto exit;\n    }\n    result = PyUnicode_FromWideChar(mountpath, wcslen(mountpath));\n    if (PyBytes_Check(path->object))\n        Py_SETREF(result, PyUnicode_EncodeFSDefault(result));\n\nexit:\n    PyMem_Free(mountpath);\n    return result;\n}\n\n\n/*[clinic input]\nos._path_splitroot\n\n    path: path_t\n\nRemoves everything after the root on Win32.\n[clinic start generated code]*/\n\nstatic PyObject *\nos__path_splitroot_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=ab7f1a88b654581c input=dc93b1d3984cffb6]*/\n{\n    wchar_t *buffer;\n    wchar_t *end;\n    PyObject *result = NULL;\n    HRESULT ret;\n\n    buffer = (wchar_t*)PyMem_Malloc(sizeof(wchar_t) * (wcslen(path->wide) + 1));\n    if (!buffer) {\n        return NULL;\n    }\n    wcscpy(buffer, path->wide);\n    for (wchar_t *p = wcschr(buffer, L'/'); p; p = wcschr(p, L'/')) {\n        *p = L'\\\\';\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    ret = PathCchSkipRoot(buffer, &end);\n    Py_END_ALLOW_THREADS\n    if (FAILED(ret)) {\n        result = Py_BuildValue(\"sO\", \"\", path->object);\n    } else if (end != buffer) {\n        size_t rootLen = (size_t)(end - buffer);\n        result = Py_BuildValue(\"NN\",\n            PyUnicode_FromWideChar(path->wide, rootLen),\n            PyUnicode_FromWideChar(path->wide + rootLen, -1)\n        );\n    } else {\n        result = Py_BuildValue(\"Os\", path->object, \"\");\n    }\n    PyMem_Free(buffer);\n\n    return result;\n}\n\n\n#define PY_IFREG  1 // Regular file\n#define PY_IFDIR  2 // Directory\n#define PY_IFLNK  4 // Symlink\n#define PY_IFMNT  8 // Mount Point (junction)\n#define PY_IFLRP 16 // Link Reparse Point (name-surrogate, symlink, junction)\n#define PY_IFRRP 32 // Regular Reparse Point\n\nstatic inline BOOL\n_testInfo(DWORD attributes, DWORD reparseTag, BOOL diskDevice, int testedType)\n{\n    switch (testedType) {\n    case PY_IFREG:\n        return diskDevice && attributes &&\n               !(attributes & FILE_ATTRIBUTE_DIRECTORY);\n    case PY_IFDIR:\n        return attributes & FILE_ATTRIBUTE_DIRECTORY;\n    case PY_IFLNK:\n        return (attributes & FILE_ATTRIBUTE_REPARSE_POINT) &&\n               reparseTag == IO_REPARSE_TAG_SYMLINK;\n    case PY_IFMNT:\n        return (attributes & FILE_ATTRIBUTE_REPARSE_POINT) &&\n               reparseTag == IO_REPARSE_TAG_MOUNT_POINT;\n    case PY_IFLRP:\n        return (attributes & FILE_ATTRIBUTE_REPARSE_POINT) &&\n               IsReparseTagNameSurrogate(reparseTag);\n    case PY_IFRRP:\n        return (attributes & FILE_ATTRIBUTE_REPARSE_POINT) &&\n               reparseTag && !IsReparseTagNameSurrogate(reparseTag);\n    }\n\n    return FALSE;\n}\n\nstatic BOOL\n_testFileTypeByHandle(HANDLE hfile, int testedType, BOOL diskOnly)\n{\n    assert(testedType == PY_IFREG || testedType == PY_IFDIR ||\n           testedType == PY_IFLNK || testedType == PY_IFMNT ||\n           testedType == PY_IFLRP || testedType == PY_IFRRP);\n\n    BOOL diskDevice = GetFileType(hfile) == FILE_TYPE_DISK;\n    if (diskOnly && !diskDevice) {\n        return FALSE;\n    }\n    if (testedType != PY_IFREG && testedType != PY_IFDIR) {\n        FILE_ATTRIBUTE_TAG_INFO info;\n        return GetFileInformationByHandleEx(hfile, FileAttributeTagInfo, &info,\n                                            sizeof(info)) &&\n               _testInfo(info.FileAttributes, info.ReparseTag, diskDevice,\n                         testedType);\n    }\n    FILE_BASIC_INFO info;\n    return GetFileInformationByHandleEx(hfile, FileBasicInfo, &info,\n                                        sizeof(info)) &&\n           _testInfo(info.FileAttributes, 0, diskDevice, testedType);\n}\n\nstatic BOOL\n_testFileTypeByName(LPCWSTR path, int testedType)\n{\n    assert(testedType == PY_IFREG || testedType == PY_IFDIR ||\n           testedType == PY_IFLNK || testedType == PY_IFMNT ||\n           testedType == PY_IFLRP || testedType == PY_IFRRP);\n\n    FILE_STAT_BASIC_INFORMATION info;\n    if (_Py_GetFileInformationByName(path, FileStatBasicByNameInfo, &info,\n                                     sizeof(info)))\n    {\n        BOOL diskDevice = info.DeviceType == FILE_DEVICE_DISK ||\n                          info.DeviceType == FILE_DEVICE_VIRTUAL_DISK ||\n                          info.DeviceType == FILE_DEVICE_CD_ROM;\n        BOOL result = _testInfo(info.FileAttributes, info.ReparseTag,\n                                diskDevice, testedType);\n        if (!result || (testedType != PY_IFREG && testedType != PY_IFDIR) ||\n            !(info.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))\n        {\n            return result;\n        }\n    }\n    else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(\n                GetLastError()))\n    {\n        return FALSE;\n    }\n\n    DWORD flags = FILE_FLAG_BACKUP_SEMANTICS;\n    if (testedType != PY_IFREG && testedType != PY_IFDIR) {\n        flags |= FILE_FLAG_OPEN_REPARSE_POINT;\n    }\n    HANDLE hfile = CreateFileW(path, FILE_READ_ATTRIBUTES, 0, NULL,\n                               OPEN_EXISTING, flags, NULL);\n    if (hfile != INVALID_HANDLE_VALUE) {\n        BOOL result = _testFileTypeByHandle(hfile, testedType, FALSE);\n        CloseHandle(hfile);\n        return result;\n    }\n\n    switch (GetLastError()) {\n    case ERROR_ACCESS_DENIED:\n    case ERROR_SHARING_VIOLATION:\n    case ERROR_CANT_ACCESS_FILE:\n    case ERROR_INVALID_PARAMETER:\n        int rc;\n        STRUCT_STAT st;\n        if (testedType == PY_IFREG || testedType == PY_IFDIR) {\n            rc = STAT(path, &st);\n        }\n        else {\n            // PY_IFRRP is not generally supported in this case, except for\n            // unhandled reparse points such as IO_REPARSE_TAG_APPEXECLINK.\n            rc = LSTAT(path, &st);\n        }\n        if (!rc) {\n            return _testInfo(st.st_file_attributes, st.st_reparse_tag,\n                             st.st_mode & S_IFREG, testedType);\n        }\n    }\n\n    return FALSE;\n}\n\n\nstatic BOOL\n_testFileExistsByName(LPCWSTR path, BOOL followLinks)\n{\n    FILE_STAT_BASIC_INFORMATION info;\n    if (_Py_GetFileInformationByName(path, FileStatBasicByNameInfo, &info,\n                                     sizeof(info)))\n    {\n        if (!(info.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) ||\n            !followLinks && IsReparseTagNameSurrogate(info.ReparseTag))\n        {\n            return TRUE;\n        }\n    }\n    else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(\n                    GetLastError()))\n    {\n        return FALSE;\n    }\n\n    DWORD flags = FILE_FLAG_BACKUP_SEMANTICS;\n    if (!followLinks) {\n        flags |= FILE_FLAG_OPEN_REPARSE_POINT;\n    }\n    HANDLE hfile = CreateFileW(path, FILE_READ_ATTRIBUTES, 0, NULL,\n                               OPEN_EXISTING, flags, NULL);\n    if (hfile != INVALID_HANDLE_VALUE) {\n        if (followLinks) {\n            CloseHandle(hfile);\n            return TRUE;\n        }\n        // Regular Reparse Points (PY_IFRRP) have to be traversed.\n        BOOL result = _testFileTypeByHandle(hfile, PY_IFRRP, FALSE);\n        CloseHandle(hfile);\n        if (!result) {\n            return TRUE;\n        }\n        hfile = CreateFileW(path, FILE_READ_ATTRIBUTES, 0, NULL, OPEN_EXISTING,\n                            FILE_FLAG_BACKUP_SEMANTICS, NULL);\n        if (hfile != INVALID_HANDLE_VALUE) {\n            CloseHandle(hfile);\n            return TRUE;\n        }\n    }\n\n    switch (GetLastError()) {\n    case ERROR_ACCESS_DENIED:\n    case ERROR_SHARING_VIOLATION:\n    case ERROR_CANT_ACCESS_FILE:\n    case ERROR_INVALID_PARAMETER:\n        STRUCT_STAT _st;\n        return followLinks ? !STAT(path, &_st): !LSTAT(path, &_st);\n    }\n\n    return FALSE;\n}\n\n\nstatic BOOL\n_testFileExists(path_t *path, BOOL followLinks)\n{\n    BOOL result = FALSE;\n    if (path->value_error) {\n        return FALSE;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    if (path->fd != -1) {\n        HANDLE hfile = _Py_get_osfhandle_noraise(path->fd);\n        if (hfile != INVALID_HANDLE_VALUE) {\n            if (GetFileType(hfile) != FILE_TYPE_UNKNOWN || !GetLastError()) {\n                result = TRUE;\n            }\n        }\n    }\n    else if (path->wide) {\n        result = _testFileExistsByName(path->wide, followLinks);\n    }\n    Py_END_ALLOW_THREADS\n\n    return result;\n}\n\n\nstatic BOOL\n_testFileType(path_t *path, int testedType)\n{\n    BOOL result = FALSE;\n    if (path->value_error) {\n        return FALSE;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    if (path->fd != -1) {\n        HANDLE hfile = _Py_get_osfhandle_noraise(path->fd);\n        if (hfile != INVALID_HANDLE_VALUE) {\n            result = _testFileTypeByHandle(hfile, testedType, TRUE);\n        }\n    }\n    else if (path->wide) {\n        result = _testFileTypeByName(path->wide, testedType);\n    }\n    Py_END_ALLOW_THREADS\n\n    return result;\n}\n\n\n/*[clinic input]\nos._path_exists -> bool\n\n    path: path_t(allow_fd=True, suppress_value_error=True)\n    /\n\nTest whether a path exists.  Returns False for broken symbolic links.\n\n[clinic start generated code]*/\n\nstatic int\nos__path_exists_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=8da13acf666e16ba input=29198507a6082a57]*/\n{\n    return _testFileExists(path, TRUE);\n}\n\n\n/*[clinic input]\nos._path_lexists -> bool\n\n    path: path_t(allow_fd=True, suppress_value_error=True)\n    /\n\nTest whether a path exists.  Returns True for broken symbolic links.\n\n[clinic start generated code]*/\n\nstatic int\nos__path_lexists_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=e7240ed5fc45bff3 input=03d9fed8bc6ce96f]*/\n{\n    return _testFileExists(path, FALSE);\n}\n\n\n/*[clinic input]\nos._path_isdir -> bool\n\n    s as path: path_t(allow_fd=True, suppress_value_error=True)\n\nReturn true if the pathname refers to an existing directory.\n\n[clinic start generated code]*/\n\nstatic int\nos__path_isdir_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=d5786196f9e2fa7a input=132a3b5301aecf79]*/\n{\n    return _testFileType(path, PY_IFDIR);\n}\n\n\n/*[clinic input]\nos._path_isfile -> bool\n\n    path: path_t(allow_fd=True, suppress_value_error=True)\n\nTest whether a path is a regular file\n\n[clinic start generated code]*/\n\nstatic int\nos__path_isfile_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=5c3073bc212b9863 input=4ac1fd350b30a39e]*/\n{\n    return _testFileType(path, PY_IFREG);\n}\n\n\n/*[clinic input]\nos._path_islink -> bool\n\n    path: path_t(allow_fd=True, suppress_value_error=True)\n\nTest whether a path is a symbolic link\n\n[clinic start generated code]*/\n\nstatic int\nos__path_islink_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=30da7bda8296adcc input=7510ce05b547debb]*/\n{\n    return _testFileType(path, PY_IFLNK);\n}\n\n\n/*[clinic input]\nos._path_isjunction -> bool\n\n    path: path_t(allow_fd=True, suppress_value_error=True)\n\nTest whether a path is a junction\n\n[clinic start generated code]*/\n\nstatic int\nos__path_isjunction_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=e1d17a9dd18a9945 input=7dcb8bc4e972fcaf]*/\n{\n    return _testFileType(path, PY_IFMNT);\n}\n\n#undef PY_IFREG\n#undef PY_IFDIR\n#undef PY_IFLNK\n#undef PY_IFMNT\n#undef PY_IFLRP\n#undef PY_IFRRP\n\n#endif /* MS_WINDOWS */\n\n\n/*[clinic input]\nos._path_splitroot_ex\n\n    path: path_t(make_wide=True, nonstrict=True)\n\nSplit a pathname into drive, root and tail.\n\nThe tail contains anything after the root.\n[clinic start generated code]*/\n\nstatic PyObject *\nos__path_splitroot_ex_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=4b0072b6cdf4b611 input=6eb76e9173412c92]*/\n{\n    Py_ssize_t drvsize, rootsize;\n    PyObject *drv = NULL, *root = NULL, *tail = NULL, *result = NULL;\n\n    const wchar_t *buffer = path->wide;\n    _Py_skiproot(buffer, path->length, &drvsize, &rootsize);\n    drv = PyUnicode_FromWideChar(buffer, drvsize);\n    if (drv == NULL) {\n        goto exit;\n    }\n    root = PyUnicode_FromWideChar(&buffer[drvsize], rootsize);\n    if (root == NULL) {\n        goto exit;\n    }\n    tail = PyUnicode_FromWideChar(&buffer[drvsize + rootsize],\n                                  path->length - drvsize - rootsize);\n    if (tail == NULL) {\n        goto exit;\n    }\n    if (PyBytes_Check(path->object)) {\n        Py_SETREF(drv, PyUnicode_EncodeFSDefault(drv));\n        if (drv == NULL) {\n            goto exit;\n        }\n        Py_SETREF(root, PyUnicode_EncodeFSDefault(root));\n        if (root == NULL) {\n            goto exit;\n        }\n        Py_SETREF(tail, PyUnicode_EncodeFSDefault(tail));\n        if (tail == NULL) {\n            goto exit;\n        }\n    }\n    result = PyTuple_Pack(3, drv, root, tail);\nexit:\n    Py_XDECREF(drv);\n    Py_XDECREF(root);\n    Py_XDECREF(tail);\n    return result;\n}\n\n\n/*[clinic input]\nos._path_normpath\n\n    path: path_t(make_wide=True, nonstrict=True)\n\nNormalize path, eliminating double slashes, etc.\n[clinic start generated code]*/\n\nstatic PyObject *\nos__path_normpath_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=d353e7ed9410c044 input=3d4ac23b06332dcb]*/\n{\n    PyObject *result;\n    Py_ssize_t norm_len;\n    wchar_t *norm_path = _Py_normpath_and_size((wchar_t *)path->wide,\n                                               path->length, &norm_len);\n    if (!norm_len) {\n        result = PyUnicode_FromOrdinal('.');\n    }\n    else {\n        result = PyUnicode_FromWideChar(norm_path, norm_len);\n    }\n    if (PyBytes_Check(path->object)) {\n        Py_SETREF(result, PyUnicode_EncodeFSDefault(result));\n    }\n    return result;\n}\n\n/*[clinic input]\nos.mkdir\n\n    path : path_t\n\n    mode: int = 0o777\n\n    *\n\n    dir_fd : dir_fd(requires='mkdirat') = None\n\n# \"mkdir(path, mode=0o777, *, dir_fd=None)\\n\\n\\\n\nCreate a directory.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.\n\nThe mode argument is ignored on Windows. Where it is used, the current umask\nvalue is first masked out.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_mkdir_impl(PyObject *module, path_t *path, int mode, int dir_fd)\n/*[clinic end generated code: output=a70446903abe821f input=a61722e1576fab03]*/\n{\n    int result;\n#ifdef MS_WINDOWS\n    int error = 0;\n    int pathError = 0;\n    SECURITY_ATTRIBUTES secAttr = { sizeof(secAttr) };\n    SECURITY_ATTRIBUTES *pSecAttr = NULL;\n#endif\n#ifdef HAVE_MKDIRAT\n    int mkdirat_unavailable = 0;\n#endif\n\n    if (PySys_Audit(\"os.mkdir\", \"Oii\", path->object, mode,\n                    dir_fd == DEFAULT_DIR_FD ? -1 : dir_fd) < 0) {\n        return NULL;\n    }\n\n#ifdef MS_WINDOWS\n    Py_BEGIN_ALLOW_THREADS\n    if (mode == 0700 /* 0o700 */) {\n        ULONG sdSize;\n        pSecAttr = &secAttr;\n        // Set a discretionary ACL (D) that is protected (P) and includes\n        // inheritable (OICI) entries that allow (A) full control (FA) to\n        // SYSTEM (SY), Administrators (BA), and the owner (OW).\n        if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(\n            L\"D:P(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)(A;OICI;FA;;;OW)\",\n            SDDL_REVISION_1,\n            &secAttr.lpSecurityDescriptor,\n            &sdSize\n        )) {\n            error = GetLastError();\n        }\n    }\n    if (!error) {\n        result = CreateDirectoryW(path->wide, pSecAttr);\n        if (secAttr.lpSecurityDescriptor &&\n            // uncommonly, LocalFree returns non-zero on error, but still uses\n            // GetLastError() to see what the error code is\n            LocalFree(secAttr.lpSecurityDescriptor)) {\n            error = GetLastError();\n        }\n    }\n    Py_END_ALLOW_THREADS\n\n    if (error) {\n        return PyErr_SetFromWindowsErr(error);\n    }\n    if (!result) {\n        return path_error(path);\n    }\n#else\n    Py_BEGIN_ALLOW_THREADS\n#if HAVE_MKDIRAT\n    if (dir_fd != DEFAULT_DIR_FD) {\n      if (HAVE_MKDIRAT_RUNTIME) {\n        result = mkdirat(dir_fd, path->narrow, mode);\n\n      } else {\n        mkdirat_unavailable = 1;\n      }\n    } else\n#endif\n#if defined(__WATCOMC__) && !defined(__QNX__)\n        result = mkdir(path->narrow);\n#else\n        result = mkdir(path->narrow, mode);\n#endif\n    Py_END_ALLOW_THREADS\n\n#if HAVE_MKDIRAT\n    if (mkdirat_unavailable) {\n        argument_unavailable_error(NULL, \"dir_fd\");\n        return NULL;\n    }\n#endif\n\n    if (result < 0)\n        return path_error(path);\n#endif /* MS_WINDOWS */\n    Py_RETURN_NONE;\n}\n\n\n/* sys/resource.h is needed for at least: wait3(), wait4(), broken nice. */\n#if defined(HAVE_SYS_RESOURCE_H)\n#include <sys/resource.h>\n#endif\n\n\n#ifdef HAVE_NICE\n/*[clinic input]\nos.nice\n\n    increment: int\n    /\n\nAdd increment to the priority of process and return the new priority.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_nice_impl(PyObject *module, int increment)\n/*[clinic end generated code: output=9dad8a9da8109943 input=864be2d402a21da2]*/\n{\n    int value;\n\n    /* There are two flavours of 'nice': one that returns the new\n       priority (as required by almost all standards out there) and the\n       Linux/FreeBSD one, which returns '0' on success and advices\n       the use of getpriority() to get the new priority.\n\n       If we are of the nice family that returns the new priority, we\n       need to clear errno before the call, and check if errno is filled\n       before calling posix_error() on a returnvalue of -1, because the\n       -1 may be the actual new priority! */\n\n    errno = 0;\n    value = nice(increment);\n#if defined(HAVE_BROKEN_NICE) && defined(HAVE_GETPRIORITY)\n    if (value == 0)\n        value = getpriority(PRIO_PROCESS, 0);\n#endif\n    if (value == -1 && errno != 0)\n        /* either nice() or getpriority() returned an error */\n        return posix_error();\n    return PyLong_FromLong((long) value);\n}\n#endif /* HAVE_NICE */\n\n\n#ifdef HAVE_GETPRIORITY\n/*[clinic input]\nos.getpriority\n\n    which: int\n    who: int\n\nReturn program scheduling priority.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getpriority_impl(PyObject *module, int which, int who)\n/*[clinic end generated code: output=c41b7b63c7420228 input=9be615d40e2544ef]*/\n{\n    int retval;\n\n    errno = 0;\n    retval = getpriority(which, who);\n    if (errno != 0)\n        return posix_error();\n    return PyLong_FromLong((long)retval);\n}\n#endif /* HAVE_GETPRIORITY */\n\n\n#ifdef HAVE_SETPRIORITY\n/*[clinic input]\nos.setpriority\n\n    which: int\n    who: int\n    priority: int\n\nSet program scheduling priority.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setpriority_impl(PyObject *module, int which, int who, int priority)\n/*[clinic end generated code: output=3d910d95a7771eb2 input=710ccbf65b9dc513]*/\n{\n    int retval;\n\n    retval = setpriority(which, who, priority);\n    if (retval == -1)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SETPRIORITY */\n\n\nstatic PyObject *\ninternal_rename(path_t *src, path_t *dst, int src_dir_fd, int dst_dir_fd, int is_replace)\n{\n    const char *function_name = is_replace ? \"replace\" : \"rename\";\n    int dir_fd_specified;\n\n#ifdef HAVE_RENAMEAT\n    int renameat_unavailable = 0;\n#endif\n\n#ifdef MS_WINDOWS\n    BOOL result;\n    int flags = is_replace ? MOVEFILE_REPLACE_EXISTING : 0;\n#else\n    int result;\n#endif\n\n    dir_fd_specified = (src_dir_fd != DEFAULT_DIR_FD) ||\n                       (dst_dir_fd != DEFAULT_DIR_FD);\n#ifndef HAVE_RENAMEAT\n    if (dir_fd_specified) {\n        argument_unavailable_error(function_name, \"src_dir_fd and dst_dir_fd\");\n        return NULL;\n    }\n#endif\n\n    if (PySys_Audit(\"os.rename\", \"OOii\", src->object, dst->object,\n                    src_dir_fd == DEFAULT_DIR_FD ? -1 : src_dir_fd,\n                    dst_dir_fd == DEFAULT_DIR_FD ? -1 : dst_dir_fd) < 0) {\n        return NULL;\n    }\n\n#ifdef MS_WINDOWS\n    Py_BEGIN_ALLOW_THREADS\n    result = MoveFileExW(src->wide, dst->wide, flags);\n    Py_END_ALLOW_THREADS\n\n    if (!result)\n        return path_error2(src, dst);\n\n#else\n    if ((src->narrow && dst->wide) || (src->wide && dst->narrow)) {\n        PyErr_Format(PyExc_ValueError,\n                     \"%s: src and dst must be the same type\", function_name);\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_RENAMEAT\n    if (dir_fd_specified) {\n        if (HAVE_RENAMEAT_RUNTIME) {\n            result = renameat(src_dir_fd, src->narrow, dst_dir_fd, dst->narrow);\n        } else {\n            renameat_unavailable = 1;\n        }\n    } else\n#endif\n    result = rename(src->narrow, dst->narrow);\n    Py_END_ALLOW_THREADS\n\n\n#ifdef HAVE_RENAMEAT\n    if (renameat_unavailable) {\n        argument_unavailable_error(function_name, \"src_dir_fd and dst_dir_fd\");\n        return NULL;\n    }\n#endif\n\n    if (result)\n        return path_error2(src, dst);\n#endif\n    Py_RETURN_NONE;\n}\n\n\n/*[clinic input]\nos.rename\n\n    src : path_t\n    dst : path_t\n    *\n    src_dir_fd : dir_fd = None\n    dst_dir_fd : dir_fd = None\n\nRename a file or directory.\n\nIf either src_dir_fd or dst_dir_fd is not None, it should be a file\n  descriptor open to a directory, and the respective path string (src or dst)\n  should be relative; the path will then be relative to that directory.\nsrc_dir_fd and dst_dir_fd, may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_rename_impl(PyObject *module, path_t *src, path_t *dst, int src_dir_fd,\n               int dst_dir_fd)\n/*[clinic end generated code: output=59e803072cf41230 input=faa61c847912c850]*/\n{\n    return internal_rename(src, dst, src_dir_fd, dst_dir_fd, 0);\n}\n\n\n/*[clinic input]\nos.replace = os.rename\n\nRename a file or directory, overwriting the destination.\n\nIf either src_dir_fd or dst_dir_fd is not None, it should be a file\n  descriptor open to a directory, and the respective path string (src or dst)\n  should be relative; the path will then be relative to that directory.\nsrc_dir_fd and dst_dir_fd, may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_replace_impl(PyObject *module, path_t *src, path_t *dst, int src_dir_fd,\n                int dst_dir_fd)\n/*[clinic end generated code: output=1968c02e7857422b input=c003f0def43378ef]*/\n{\n    return internal_rename(src, dst, src_dir_fd, dst_dir_fd, 1);\n}\n\n\n/*[clinic input]\nos.rmdir\n\n    path: path_t\n    *\n    dir_fd: dir_fd(requires='unlinkat') = None\n\nRemove a directory.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_rmdir_impl(PyObject *module, path_t *path, int dir_fd)\n/*[clinic end generated code: output=080eb54f506e8301 input=38c8b375ca34a7e2]*/\n{\n    int result;\n#ifdef HAVE_UNLINKAT\n    int unlinkat_unavailable = 0;\n#endif\n\n    if (PySys_Audit(\"os.rmdir\", \"Oi\", path->object,\n                    dir_fd == DEFAULT_DIR_FD ? -1 : dir_fd) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n#ifdef MS_WINDOWS\n    /* Windows, success=1, UNIX, success=0 */\n    result = !RemoveDirectoryW(path->wide);\n#else\n#ifdef HAVE_UNLINKAT\n    if (dir_fd != DEFAULT_DIR_FD) {\n      if (HAVE_UNLINKAT_RUNTIME) {\n        result = unlinkat(dir_fd, path->narrow, AT_REMOVEDIR);\n      } else {\n        unlinkat_unavailable = 1;\n        result = -1;\n      }\n    } else\n#endif\n        result = rmdir(path->narrow);\n#endif\n    Py_END_ALLOW_THREADS\n\n#ifdef HAVE_UNLINKAT\n    if (unlinkat_unavailable) {\n        argument_unavailable_error(\"rmdir\", \"dir_fd\");\n        return NULL;\n    }\n#endif\n\n    if (result)\n        return path_error(path);\n\n    Py_RETURN_NONE;\n}\n\n\n#ifdef HAVE_SYSTEM\n#ifdef MS_WINDOWS\n/*[clinic input]\nos.system -> long\n\n    command: Py_UNICODE\n\nExecute the command in a subshell.\n[clinic start generated code]*/\n\nstatic long\nos_system_impl(PyObject *module, const wchar_t *command)\n/*[clinic end generated code: output=dd528cbd5943a679 input=303f5ce97df606b0]*/\n{\n    long result;\n\n    if (PySys_Audit(\"os.system\", \"(u)\", command) < 0) {\n        return -1;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    _Py_BEGIN_SUPPRESS_IPH\n    result = _wsystem(command);\n    _Py_END_SUPPRESS_IPH\n    Py_END_ALLOW_THREADS\n    return result;\n}\n#else /* MS_WINDOWS */\n/*[clinic input]\nos.system -> long\n\n    command: FSConverter\n\nExecute the command in a subshell.\n[clinic start generated code]*/\n\nstatic long\nos_system_impl(PyObject *module, PyObject *command)\n/*[clinic end generated code: output=290fc437dd4f33a0 input=86a58554ba6094af]*/\n{\n    long result;\n    const char *bytes = PyBytes_AsString(command);\n\n    if (PySys_Audit(\"os.system\", \"(O)\", command) < 0) {\n        return -1;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    result = system(bytes);\n    Py_END_ALLOW_THREADS\n    return result;\n}\n#endif\n#endif /* HAVE_SYSTEM */\n\n\n#ifdef HAVE_UMASK\n/*[clinic input]\nos.umask\n\n    mask: int\n    /\n\nSet the current numeric umask and return the previous umask.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_umask_impl(PyObject *module, int mask)\n/*[clinic end generated code: output=a2e33ce3bc1a6e33 input=ab6bfd9b24d8a7e8]*/\n{\n    int i = (int)umask(mask);\n    if (i < 0)\n        return posix_error();\n    return PyLong_FromLong((long)i);\n}\n#endif\n\n#ifdef MS_WINDOWS\n\n/* override the default DeleteFileW behavior so that directory\nsymlinks can be removed with this function, the same as with\nUnix symlinks */\nBOOL WINAPI Py_DeleteFileW(LPCWSTR lpFileName)\n{\n    WIN32_FILE_ATTRIBUTE_DATA info;\n    WIN32_FIND_DATAW find_data;\n    HANDLE find_data_handle;\n    int is_directory = 0;\n    int is_link = 0;\n\n    if (GetFileAttributesExW(lpFileName, GetFileExInfoStandard, &info)) {\n        is_directory = info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;\n\n        /* Get WIN32_FIND_DATA structure for the path to determine if\n           it is a symlink */\n        if(is_directory &&\n           info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {\n            find_data_handle = FindFirstFileW(lpFileName, &find_data);\n\n            if(find_data_handle != INVALID_HANDLE_VALUE) {\n                /* IO_REPARSE_TAG_SYMLINK if it is a symlink and\n                   IO_REPARSE_TAG_MOUNT_POINT if it is a junction point. */\n                is_link = find_data.dwReserved0 == IO_REPARSE_TAG_SYMLINK ||\n                          find_data.dwReserved0 == IO_REPARSE_TAG_MOUNT_POINT;\n                FindClose(find_data_handle);\n            }\n        }\n    }\n\n    if (is_directory && is_link)\n        return RemoveDirectoryW(lpFileName);\n\n    return DeleteFileW(lpFileName);\n}\n#endif /* MS_WINDOWS */\n\n\n/*[clinic input]\nos.unlink\n\n    path: path_t\n    *\n    dir_fd: dir_fd(requires='unlinkat')=None\n\nRemove a file (same as remove()).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_unlink_impl(PyObject *module, path_t *path, int dir_fd)\n/*[clinic end generated code: output=621797807b9963b1 input=d7bcde2b1b2a2552]*/\n{\n    int result;\n#ifdef HAVE_UNLINKAT\n    int unlinkat_unavailable = 0;\n#endif\n\n    if (PySys_Audit(\"os.remove\", \"Oi\", path->object,\n                    dir_fd == DEFAULT_DIR_FD ? -1 : dir_fd) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    _Py_BEGIN_SUPPRESS_IPH\n#ifdef MS_WINDOWS\n    /* Windows, success=1, UNIX, success=0 */\n    result = !Py_DeleteFileW(path->wide);\n#else\n#ifdef HAVE_UNLINKAT\n    if (dir_fd != DEFAULT_DIR_FD) {\n      if (HAVE_UNLINKAT_RUNTIME) {\n\n        result = unlinkat(dir_fd, path->narrow, 0);\n      } else {\n        unlinkat_unavailable = 1;\n      }\n    } else\n#endif /* HAVE_UNLINKAT */\n        result = unlink(path->narrow);\n#endif\n    _Py_END_SUPPRESS_IPH\n    Py_END_ALLOW_THREADS\n\n#ifdef HAVE_UNLINKAT\n    if (unlinkat_unavailable) {\n        argument_unavailable_error(NULL, \"dir_fd\");\n        return NULL;\n    }\n#endif\n\n    if (result)\n        return path_error(path);\n\n    Py_RETURN_NONE;\n}\n\n\n/*[clinic input]\nos.remove = os.unlink\n\nRemove a file (same as unlink()).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_remove_impl(PyObject *module, path_t *path, int dir_fd)\n/*[clinic end generated code: output=a8535b28f0068883 input=e05c5ab55cd30983]*/\n{\n    return os_unlink_impl(module, path, dir_fd);\n}\n\n\nstatic PyStructSequence_Field uname_result_fields[] = {\n    {\"sysname\",    \"operating system name\"},\n    {\"nodename\",   \"name of machine on network (implementation-defined)\"},\n    {\"release\",    \"operating system release\"},\n    {\"version\",    \"operating system version\"},\n    {\"machine\",    \"hardware identifier\"},\n    {NULL}\n};\n\nPyDoc_STRVAR(uname_result__doc__,\n\"uname_result: Result from os.uname().\\n\\n\\\nThis object may be accessed either as a tuple of\\n\\\n  (sysname, nodename, release, version, machine),\\n\\\nor via the attributes sysname, nodename, release, version, and machine.\\n\\\n\\n\\\nSee os.uname for more information.\");\n\nstatic PyStructSequence_Desc uname_result_desc = {\n    MODNAME \".uname_result\", /* name */\n    uname_result__doc__, /* doc */\n    uname_result_fields,\n    5\n};\n\n#ifdef HAVE_UNAME\n/*[clinic input]\nos.uname\n\nReturn an object identifying the current operating system.\n\nThe object behaves like a named tuple with the following fields:\n  (sysname, nodename, release, version, machine)\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_uname_impl(PyObject *module)\n/*[clinic end generated code: output=e6a49cf1a1508a19 input=e68bd246db3043ed]*/\n{\n    struct utsname u;\n    int res;\n    PyObject *value;\n\n    Py_BEGIN_ALLOW_THREADS\n    res = uname(&u);\n    Py_END_ALLOW_THREADS\n    if (res < 0)\n        return posix_error();\n\n    PyObject *UnameResultType = get_posix_state(module)->UnameResultType;\n    value = PyStructSequence_New((PyTypeObject *)UnameResultType);\n    if (value == NULL)\n        return NULL;\n\n#define SET(i, field) \\\n    { \\\n    PyObject *o = PyUnicode_DecodeFSDefault(field); \\\n    if (!o) { \\\n        Py_DECREF(value); \\\n        return NULL; \\\n    } \\\n    PyStructSequence_SET_ITEM(value, i, o); \\\n    } \\\n\n    SET(0, u.sysname);\n    SET(1, u.nodename);\n    SET(2, u.release);\n    SET(3, u.version);\n    SET(4, u.machine);\n\n#undef SET\n\n    return value;\n}\n#endif /* HAVE_UNAME */\n\n\n\ntypedef struct {\n    int    now;\n    time_t atime_s;\n    long   atime_ns;\n    time_t mtime_s;\n    long   mtime_ns;\n} utime_t;\n\n/*\n * these macros assume that \"ut\" is a pointer to a utime_t\n * they also intentionally leak the declaration of a pointer named \"time\"\n */\n#define UTIME_TO_TIMESPEC \\\n    struct timespec ts[2]; \\\n    struct timespec *time; \\\n    if (ut->now) \\\n        time = NULL; \\\n    else { \\\n        ts[0].tv_sec = ut->atime_s; \\\n        ts[0].tv_nsec = ut->atime_ns; \\\n        ts[1].tv_sec = ut->mtime_s; \\\n        ts[1].tv_nsec = ut->mtime_ns; \\\n        time = ts; \\\n    } \\\n\n#define UTIME_TO_TIMEVAL \\\n    struct timeval tv[2]; \\\n    struct timeval *time; \\\n    if (ut->now) \\\n        time = NULL; \\\n    else { \\\n        tv[0].tv_sec = ut->atime_s; \\\n        tv[0].tv_usec = ut->atime_ns / 1000; \\\n        tv[1].tv_sec = ut->mtime_s; \\\n        tv[1].tv_usec = ut->mtime_ns / 1000; \\\n        time = tv; \\\n    } \\\n\n#define UTIME_TO_UTIMBUF \\\n    struct utimbuf u; \\\n    struct utimbuf *time; \\\n    if (ut->now) \\\n        time = NULL; \\\n    else { \\\n        u.actime = ut->atime_s; \\\n        u.modtime = ut->mtime_s; \\\n        time = &u; \\\n    }\n\n#define UTIME_TO_TIME_T \\\n    time_t timet[2]; \\\n    time_t *time; \\\n    if (ut->now) \\\n        time = NULL; \\\n    else { \\\n        timet[0] = ut->atime_s; \\\n        timet[1] = ut->mtime_s; \\\n        time = timet; \\\n    } \\\n\n\n#if defined(HAVE_FUTIMESAT) || defined(HAVE_UTIMENSAT)\n\nstatic int\nutime_dir_fd(utime_t *ut, int dir_fd, const char *path, int follow_symlinks)\n{\n#if defined(__APPLE__) &&  defined(HAVE_UTIMENSAT)\n    if (HAVE_UTIMENSAT_RUNTIME) {\n        int flags = follow_symlinks ? 0 : AT_SYMLINK_NOFOLLOW;\n        UTIME_TO_TIMESPEC;\n        return utimensat(dir_fd, path, time, flags);\n    }  else {\n        errno = ENOSYS;\n        return -1;\n    }\n#elif defined(HAVE_UTIMENSAT)\n    int flags = follow_symlinks ? 0 : AT_SYMLINK_NOFOLLOW;\n    UTIME_TO_TIMESPEC;\n    return utimensat(dir_fd, path, time, flags);\n#elif defined(HAVE_FUTIMESAT)\n    UTIME_TO_TIMEVAL;\n    /*\n     * follow_symlinks will never be false here;\n     * we only allow !follow_symlinks and dir_fd together\n     * if we have utimensat()\n     */\n    assert(follow_symlinks);\n    return futimesat(dir_fd, path, time);\n#endif\n}\n\n    #define FUTIMENSAT_DIR_FD_CONVERTER dir_fd_converter\n#else\n    #define FUTIMENSAT_DIR_FD_CONVERTER dir_fd_unavailable\n#endif\n\n#if defined(HAVE_FUTIMES) || defined(HAVE_FUTIMENS)\n\nstatic int\nutime_fd(utime_t *ut, int fd)\n{\n#ifdef HAVE_FUTIMENS\n\n    if (HAVE_FUTIMENS_RUNTIME) {\n\n    UTIME_TO_TIMESPEC;\n    return futimens(fd, time);\n\n    } else\n#ifndef HAVE_FUTIMES\n    {\n        /* Not sure if this can happen */\n        PyErr_SetString(\n            PyExc_RuntimeError,\n            \"neither futimens nor futimes are supported\"\n            \" on this system\");\n        return -1;\n    }\n#endif\n\n#endif\n#ifdef HAVE_FUTIMES\n    {\n    UTIME_TO_TIMEVAL;\n    return futimes(fd, time);\n    }\n#endif\n}\n\n    #define PATH_UTIME_HAVE_FD 1\n#else\n    #define PATH_UTIME_HAVE_FD 0\n#endif\n\n#if defined(HAVE_UTIMENSAT) || defined(HAVE_LUTIMES)\n#  define UTIME_HAVE_NOFOLLOW_SYMLINKS\n#endif\n\n#ifdef UTIME_HAVE_NOFOLLOW_SYMLINKS\n\nstatic int\nutime_nofollow_symlinks(utime_t *ut, const char *path)\n{\n#ifdef HAVE_UTIMENSAT\n    if (HAVE_UTIMENSAT_RUNTIME) {\n        UTIME_TO_TIMESPEC;\n        return utimensat(DEFAULT_DIR_FD, path, time, AT_SYMLINK_NOFOLLOW);\n    } else\n#ifndef HAVE_LUTIMES\n    {\n        /* Not sure if this can happen */\n        PyErr_SetString(\n            PyExc_RuntimeError,\n            \"neither utimensat nor lutimes are supported\"\n            \" on this system\");\n        return -1;\n    }\n#endif\n#endif\n\n#ifdef HAVE_LUTIMES\n    {\n    UTIME_TO_TIMEVAL;\n    return lutimes(path, time);\n    }\n#endif\n}\n\n#endif\n\n#ifndef MS_WINDOWS\n\nstatic int\nutime_default(utime_t *ut, const char *path)\n{\n#if defined(__APPLE__) && defined(HAVE_UTIMENSAT)\n    if (HAVE_UTIMENSAT_RUNTIME) {\n        UTIME_TO_TIMESPEC;\n        return utimensat(DEFAULT_DIR_FD, path, time, 0);\n    } else {\n        UTIME_TO_TIMEVAL;\n        return utimes(path, time);\n    }\n#elif defined(HAVE_UTIMENSAT)\n    UTIME_TO_TIMESPEC;\n    return utimensat(DEFAULT_DIR_FD, path, time, 0);\n#elif defined(HAVE_UTIMES)\n    UTIME_TO_TIMEVAL;\n    return utimes(path, time);\n#elif defined(HAVE_UTIME_H)\n    UTIME_TO_UTIMBUF;\n    return utime(path, time);\n#else\n    UTIME_TO_TIME_T;\n    return utime(path, time);\n#endif\n}\n\n#endif\n\nstatic int\nsplit_py_long_to_s_and_ns(PyObject *module, PyObject *py_long, time_t *s, long *ns)\n{\n    int result = 0;\n    PyObject *divmod;\n    divmod = PyNumber_Divmod(py_long, get_posix_state(module)->billion);\n    if (!divmod)\n        goto exit;\n    if (!PyTuple_Check(divmod) || PyTuple_GET_SIZE(divmod) != 2) {\n        PyErr_Format(PyExc_TypeError,\n                     \"%.200s.__divmod__() must return a 2-tuple, not %.200s\",\n                     _PyType_Name(Py_TYPE(py_long)), _PyType_Name(Py_TYPE(divmod)));\n        goto exit;\n    }\n    *s = _PyLong_AsTime_t(PyTuple_GET_ITEM(divmod, 0));\n    if ((*s == -1) && PyErr_Occurred())\n        goto exit;\n    *ns = PyLong_AsLong(PyTuple_GET_ITEM(divmod, 1));\n    if ((*ns == -1) && PyErr_Occurred())\n        goto exit;\n\n    result = 1;\nexit:\n    Py_XDECREF(divmod);\n    return result;\n}\n\n\n/*[clinic input]\nos.utime\n\n    path: path_t(allow_fd='PATH_UTIME_HAVE_FD')\n    times: object = None\n    *\n    ns: object = NULL\n    dir_fd: dir_fd(requires='futimensat') = None\n    follow_symlinks: bool=True\n\n# \"utime(path, times=None, *[, ns], dir_fd=None, follow_symlinks=True)\\n\\\n\nSet the access and modified time of path.\n\npath may always be specified as a string.\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.\n\nIf times is not None, it must be a tuple (atime, mtime);\n    atime and mtime should be expressed as float seconds since the epoch.\nIf ns is specified, it must be a tuple (atime_ns, mtime_ns);\n    atime_ns and mtime_ns should be expressed as integer nanoseconds\n    since the epoch.\nIf times is None and ns is unspecified, utime uses the current time.\nSpecifying tuples for both times and ns is an error.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, utime will modify the symbolic link itself instead of the file the\n  link points to.\nIt is an error to use dir_fd or follow_symlinks when specifying path\n  as an open file descriptor.\ndir_fd and follow_symlinks may not be available on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_utime_impl(PyObject *module, path_t *path, PyObject *times, PyObject *ns,\n              int dir_fd, int follow_symlinks)\n/*[clinic end generated code: output=cfcac69d027b82cf input=2fbd62a2f228f8f4]*/\n{\n#ifdef MS_WINDOWS\n    HANDLE hFile;\n    FILETIME atime, mtime;\n#else\n    int result;\n#endif\n\n    utime_t utime;\n\n    memset(&utime, 0, sizeof(utime_t));\n\n    if (times != Py_None && ns) {\n        PyErr_SetString(PyExc_ValueError,\n                     \"utime: you may specify either 'times'\"\n                     \" or 'ns' but not both\");\n        return NULL;\n    }\n\n    if (times != Py_None) {\n        time_t a_sec, m_sec;\n        long a_nsec, m_nsec;\n        if (!PyTuple_CheckExact(times) || (PyTuple_Size(times) != 2)) {\n            PyErr_SetString(PyExc_TypeError,\n                         \"utime: 'times' must be either\"\n                         \" a tuple of two ints or None\");\n            return NULL;\n        }\n        utime.now = 0;\n        if (_PyTime_ObjectToTimespec(PyTuple_GET_ITEM(times, 0),\n                                     &a_sec, &a_nsec, _PyTime_ROUND_FLOOR) == -1 ||\n            _PyTime_ObjectToTimespec(PyTuple_GET_ITEM(times, 1),\n                                     &m_sec, &m_nsec, _PyTime_ROUND_FLOOR) == -1) {\n            return NULL;\n        }\n        utime.atime_s = a_sec;\n        utime.atime_ns = a_nsec;\n        utime.mtime_s = m_sec;\n        utime.mtime_ns = m_nsec;\n    }\n    else if (ns) {\n        if (!PyTuple_CheckExact(ns) || (PyTuple_Size(ns) != 2)) {\n            PyErr_SetString(PyExc_TypeError,\n                         \"utime: 'ns' must be a tuple of two ints\");\n            return NULL;\n        }\n        utime.now = 0;\n        if (!split_py_long_to_s_and_ns(module, PyTuple_GET_ITEM(ns, 0),\n                                      &utime.atime_s, &utime.atime_ns) ||\n            !split_py_long_to_s_and_ns(module, PyTuple_GET_ITEM(ns, 1),\n                                       &utime.mtime_s, &utime.mtime_ns)) {\n            return NULL;\n        }\n    }\n    else {\n        /* times and ns are both None/unspecified. use \"now\". */\n        utime.now = 1;\n    }\n\n#if !defined(UTIME_HAVE_NOFOLLOW_SYMLINKS)\n    if (follow_symlinks_specified(\"utime\", follow_symlinks))\n        return NULL;\n#endif\n\n    if (path_and_dir_fd_invalid(\"utime\", path, dir_fd) ||\n        dir_fd_and_fd_invalid(\"utime\", dir_fd, path->fd) ||\n        fd_and_follow_symlinks_invalid(\"utime\", path->fd, follow_symlinks))\n        return NULL;\n\n#if !defined(HAVE_UTIMENSAT)\n    if ((dir_fd != DEFAULT_DIR_FD) && (!follow_symlinks)) {\n        PyErr_SetString(PyExc_ValueError,\n                     \"utime: cannot use dir_fd and follow_symlinks \"\n                     \"together on this platform\");\n        return NULL;\n    }\n#endif\n\n    if (PySys_Audit(\"os.utime\", \"OOOi\", path->object, times, ns ? ns : Py_None,\n                    dir_fd == DEFAULT_DIR_FD ? -1 : dir_fd) < 0) {\n        return NULL;\n    }\n\n#ifdef MS_WINDOWS\n    Py_BEGIN_ALLOW_THREADS\n    hFile = CreateFileW(path->wide, FILE_WRITE_ATTRIBUTES, 0,\n                        NULL, OPEN_EXISTING,\n                        FILE_FLAG_BACKUP_SEMANTICS, NULL);\n    Py_END_ALLOW_THREADS\n    if (hFile == INVALID_HANDLE_VALUE) {\n        path_error(path);\n        return NULL;\n    }\n\n    if (utime.now) {\n        GetSystemTimeAsFileTime(&mtime);\n        atime = mtime;\n    }\n    else {\n        _Py_time_t_to_FILE_TIME(utime.atime_s, utime.atime_ns, &atime);\n        _Py_time_t_to_FILE_TIME(utime.mtime_s, utime.mtime_ns, &mtime);\n    }\n    if (!SetFileTime(hFile, NULL, &atime, &mtime)) {\n        path_error(path);\n        CloseHandle(hFile);\n        return NULL;\n    }\n    CloseHandle(hFile);\n#else /* MS_WINDOWS */\n    Py_BEGIN_ALLOW_THREADS\n\n#ifdef UTIME_HAVE_NOFOLLOW_SYMLINKS\n    if ((!follow_symlinks) && (dir_fd == DEFAULT_DIR_FD))\n        result = utime_nofollow_symlinks(&utime, path->narrow);\n    else\n#endif\n\n#if defined(HAVE_FUTIMESAT) || defined(HAVE_UTIMENSAT)\n    if ((dir_fd != DEFAULT_DIR_FD) || (!follow_symlinks)) {\n        result = utime_dir_fd(&utime, dir_fd, path->narrow, follow_symlinks);\n\n    } else\n#endif\n\n#if defined(HAVE_FUTIMES) || defined(HAVE_FUTIMENS)\n    if (path->fd != -1)\n        result = utime_fd(&utime, path->fd);\n    else\n#endif\n\n    result = utime_default(&utime, path->narrow);\n\n    Py_END_ALLOW_THREADS\n\n#if defined(__APPLE__) && defined(HAVE_UTIMENSAT)\n    /* See utime_dir_fd implementation */\n    if (result == -1 && errno == ENOSYS) {\n        argument_unavailable_error(NULL, \"dir_fd\");\n        return NULL;\n    }\n#endif\n\n    if (result < 0) {\n        path_error(path);\n        return NULL;\n    }\n\n#endif /* MS_WINDOWS */\n\n    Py_RETURN_NONE;\n}\n\n/* Process operations */\n\n\n/*[clinic input]\nos._exit\n\n    status: int\n\nExit to the system with specified status, without normal exit processing.\n[clinic start generated code]*/\n\nstatic PyObject *\nos__exit_impl(PyObject *module, int status)\n/*[clinic end generated code: output=116e52d9c2260d54 input=5e6d57556b0c4a62]*/\n{\n    _exit(status);\n    return NULL; /* Make gcc -Wall happy */\n}\n\n#if defined(HAVE_WEXECV) || defined(HAVE_WSPAWNV)\n#define EXECV_CHAR wchar_t\n#else\n#define EXECV_CHAR char\n#endif\n\n#if defined(HAVE_EXECV) || defined(HAVE_SPAWNV) || defined(HAVE_RTPSPAWN)\nstatic void\nfree_string_array(EXECV_CHAR **array, Py_ssize_t count)\n{\n    Py_ssize_t i;\n    for (i = 0; i < count; i++)\n        PyMem_Free(array[i]);\n    PyMem_Free(array);\n}\n\nstatic int\nfsconvert_strdup(PyObject *o, EXECV_CHAR **out)\n{\n    Py_ssize_t size;\n    PyObject *ub;\n    int result = 0;\n#if defined(HAVE_WEXECV) || defined(HAVE_WSPAWNV)\n    if (!PyUnicode_FSDecoder(o, &ub))\n        return 0;\n    *out = PyUnicode_AsWideCharString(ub, &size);\n    if (*out)\n        result = 1;\n#else\n    if (!PyUnicode_FSConverter(o, &ub))\n        return 0;\n    size = PyBytes_GET_SIZE(ub);\n    *out = PyMem_Malloc(size + 1);\n    if (*out) {\n        memcpy(*out, PyBytes_AS_STRING(ub), size + 1);\n        result = 1;\n    } else\n        PyErr_NoMemory();\n#endif\n    Py_DECREF(ub);\n    return result;\n}\n#endif\n\n#if defined(HAVE_EXECV) || defined (HAVE_FEXECVE) || defined(HAVE_RTPSPAWN)\nstatic EXECV_CHAR**\nparse_envlist(PyObject* env, Py_ssize_t *envc_ptr)\n{\n    Py_ssize_t i, pos, envc;\n    PyObject *keys=NULL, *vals=NULL;\n    PyObject *key2, *val2, *keyval;\n    EXECV_CHAR **envlist;\n\n    i = PyMapping_Size(env);\n    if (i < 0)\n        return NULL;\n    envlist = PyMem_NEW(EXECV_CHAR *, i + 1);\n    if (envlist == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    envc = 0;\n    keys = PyMapping_Keys(env);\n    if (!keys)\n        goto error;\n    vals = PyMapping_Values(env);\n    if (!vals)\n        goto error;\n    if (!PyList_Check(keys) || !PyList_Check(vals)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"env.keys() or env.values() is not a list\");\n        goto error;\n    }\n\n    for (pos = 0; pos < i; pos++) {\n        PyObject *key = PyList_GetItem(keys, pos);  // Borrowed ref.\n        if (key == NULL) {\n            goto error;\n        }\n        PyObject *val = PyList_GetItem(vals, pos);  // Borrowed ref.\n        if (val == NULL) {\n            goto error;\n        }\n\n#if defined(HAVE_WEXECV) || defined(HAVE_WSPAWNV)\n        if (!PyUnicode_FSDecoder(key, &key2))\n            goto error;\n        if (!PyUnicode_FSDecoder(val, &val2)) {\n            Py_DECREF(key2);\n            goto error;\n        }\n        /* Search from index 1 because on Windows starting '=' is allowed for\n           defining hidden environment variables. */\n        if (PyUnicode_GET_LENGTH(key2) == 0 ||\n            PyUnicode_FindChar(key2, '=', 1, PyUnicode_GET_LENGTH(key2), 1) != -1)\n        {\n            PyErr_SetString(PyExc_ValueError, \"illegal environment variable name\");\n            Py_DECREF(key2);\n            Py_DECREF(val2);\n            goto error;\n        }\n        keyval = PyUnicode_FromFormat(\"%U=%U\", key2, val2);\n#else\n        if (!PyUnicode_FSConverter(key, &key2))\n            goto error;\n        if (!PyUnicode_FSConverter(val, &val2)) {\n            Py_DECREF(key2);\n            goto error;\n        }\n        if (PyBytes_GET_SIZE(key2) == 0 ||\n            strchr(PyBytes_AS_STRING(key2) + 1, '=') != NULL)\n        {\n            PyErr_SetString(PyExc_ValueError, \"illegal environment variable name\");\n            Py_DECREF(key2);\n            Py_DECREF(val2);\n            goto error;\n        }\n        keyval = PyBytes_FromFormat(\"%s=%s\", PyBytes_AS_STRING(key2),\n                                             PyBytes_AS_STRING(val2));\n#endif\n        Py_DECREF(key2);\n        Py_DECREF(val2);\n        if (!keyval)\n            goto error;\n\n        if (!fsconvert_strdup(keyval, &envlist[envc++])) {\n            Py_DECREF(keyval);\n            goto error;\n        }\n\n        Py_DECREF(keyval);\n    }\n    Py_DECREF(vals);\n    Py_DECREF(keys);\n\n    envlist[envc] = 0;\n    *envc_ptr = envc;\n    return envlist;\n\nerror:\n    Py_XDECREF(keys);\n    Py_XDECREF(vals);\n    free_string_array(envlist, envc);\n    return NULL;\n}\n\nstatic EXECV_CHAR**\nparse_arglist(PyObject* argv, Py_ssize_t *argc)\n{\n    int i;\n    EXECV_CHAR **argvlist = PyMem_NEW(EXECV_CHAR *, *argc+1);\n    if (argvlist == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    for (i = 0; i < *argc; i++) {\n        PyObject* item = PySequence_ITEM(argv, i);\n        if (item == NULL)\n            goto fail;\n        if (!fsconvert_strdup(item, &argvlist[i])) {\n            Py_DECREF(item);\n            goto fail;\n        }\n        Py_DECREF(item);\n    }\n    argvlist[*argc] = NULL;\n    return argvlist;\nfail:\n    *argc = i;\n    free_string_array(argvlist, *argc);\n    return NULL;\n}\n\n#endif\n\n\n#ifdef HAVE_EXECV\n/*[clinic input]\nos.execv\n\n    path: path_t\n        Path of executable file.\n    argv: object\n        Tuple or list of strings.\n    /\n\nExecute an executable path with arguments, replacing current process.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_execv_impl(PyObject *module, path_t *path, PyObject *argv)\n/*[clinic end generated code: output=3b52fec34cd0dafd input=9bac31efae07dac7]*/\n{\n    EXECV_CHAR **argvlist;\n    Py_ssize_t argc;\n\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    if (!_PyInterpreterState_HasFeature(interp, Py_RTFLAGS_EXEC)) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"exec not supported for isolated subinterpreters\");\n        return NULL;\n    }\n\n    /* execv has two arguments: (path, argv), where\n       argv is a list or tuple of strings. */\n\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"execv() arg 2 must be a tuple or list\");\n        return NULL;\n    }\n    argc = PySequence_Size(argv);\n    if (argc < 1) {\n        PyErr_SetString(PyExc_ValueError, \"execv() arg 2 must not be empty\");\n        return NULL;\n    }\n\n    argvlist = parse_arglist(argv, &argc);\n    if (argvlist == NULL) {\n        return NULL;\n    }\n    if (!argvlist[0][0]) {\n        PyErr_SetString(PyExc_ValueError,\n            \"execv() arg 2 first element cannot be empty\");\n        free_string_array(argvlist, argc);\n        return NULL;\n    }\n\n    if (PySys_Audit(\"os.exec\", \"OOO\", path->object, argv, Py_None) < 0) {\n        free_string_array(argvlist, argc);\n        return NULL;\n    }\n\n    _Py_BEGIN_SUPPRESS_IPH\n#ifdef HAVE_WEXECV\n    _wexecv(path->wide, argvlist);\n#else\n    execv(path->narrow, argvlist);\n#endif\n    _Py_END_SUPPRESS_IPH\n\n    /* If we get here it's definitely an error */\n\n    posix_error();\n    free_string_array(argvlist, argc);\n    return NULL;\n}\n\n\n/*[clinic input]\nos.execve\n\n    path: path_t(allow_fd='PATH_HAVE_FEXECVE')\n        Path of executable file.\n    argv: object\n        Tuple or list of strings.\n    env: object\n        Dictionary of strings mapping to strings.\n\nExecute an executable path with arguments, replacing current process.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_execve_impl(PyObject *module, path_t *path, PyObject *argv, PyObject *env)\n/*[clinic end generated code: output=ff9fa8e4da8bde58 input=626804fa092606d9]*/\n{\n    EXECV_CHAR **argvlist = NULL;\n    EXECV_CHAR **envlist;\n    Py_ssize_t argc, envc;\n\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    if (!_PyInterpreterState_HasFeature(interp, Py_RTFLAGS_EXEC)) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"exec not supported for isolated subinterpreters\");\n        return NULL;\n    }\n\n    /* execve has three arguments: (path, argv, env), where\n       argv is a list or tuple of strings and env is a dictionary\n       like posix.environ. */\n\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"execve: argv must be a tuple or list\");\n        goto fail_0;\n    }\n    argc = PySequence_Size(argv);\n    if (argc < 1) {\n        PyErr_SetString(PyExc_ValueError, \"execve: argv must not be empty\");\n        return NULL;\n    }\n\n    if (!PyMapping_Check(env)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"execve: environment must be a mapping object\");\n        goto fail_0;\n    }\n\n    argvlist = parse_arglist(argv, &argc);\n    if (argvlist == NULL) {\n        goto fail_0;\n    }\n    if (!argvlist[0][0]) {\n        PyErr_SetString(PyExc_ValueError,\n            \"execve: argv first element cannot be empty\");\n        goto fail_0;\n    }\n\n    envlist = parse_envlist(env, &envc);\n    if (envlist == NULL)\n        goto fail_0;\n\n    if (PySys_Audit(\"os.exec\", \"OOO\", path->object, argv, env) < 0) {\n        goto fail_1;\n    }\n\n    _Py_BEGIN_SUPPRESS_IPH\n#ifdef HAVE_FEXECVE\n    if (path->fd > -1)\n        fexecve(path->fd, argvlist, envlist);\n    else\n#endif\n#ifdef HAVE_WEXECV\n        _wexecve(path->wide, argvlist, envlist);\n#else\n        execve(path->narrow, argvlist, envlist);\n#endif\n    _Py_END_SUPPRESS_IPH\n\n    /* If we get here it's definitely an error */\n\n    posix_path_error(path);\n  fail_1:\n    free_string_array(envlist, envc);\n  fail_0:\n    if (argvlist)\n        free_string_array(argvlist, argc);\n    return NULL;\n}\n\n#endif /* HAVE_EXECV */\n\n#ifdef HAVE_POSIX_SPAWN\n\nenum posix_spawn_file_actions_identifier {\n    POSIX_SPAWN_OPEN,\n    POSIX_SPAWN_CLOSE,\n    POSIX_SPAWN_DUP2\n#ifdef HAVE_POSIX_SPAWN_FILE_ACTIONS_ADDCLOSEFROM_NP\n    ,POSIX_SPAWN_CLOSEFROM\n#endif\n};\n\n#if defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDPARAM)\nstatic int\nconvert_sched_param(PyObject *module, PyObject *param, struct sched_param *res);\n#endif\n\nstatic int\nparse_posix_spawn_flags(PyObject *module, const char *func_name, PyObject *setpgroup,\n                        int resetids, int setsid, PyObject *setsigmask,\n                        PyObject *setsigdef, PyObject *scheduler,\n                        posix_spawnattr_t *attrp)\n{\n    long all_flags = 0;\n\n    errno = posix_spawnattr_init(attrp);\n    if (errno) {\n        posix_error();\n        return -1;\n    }\n\n    if (setpgroup) {\n        pid_t pgid = PyLong_AsPid(setpgroup);\n        if (pgid == (pid_t)-1 && PyErr_Occurred()) {\n            goto fail;\n        }\n        errno = posix_spawnattr_setpgroup(attrp, pgid);\n        if (errno) {\n            posix_error();\n            goto fail;\n        }\n        all_flags |= POSIX_SPAWN_SETPGROUP;\n    }\n\n    if (resetids) {\n        all_flags |= POSIX_SPAWN_RESETIDS;\n    }\n\n    if (setsid) {\n#ifdef HAVE_POSIX_SPAWN_SETSID_RUNTIME\n        if (HAVE_POSIX_SPAWN_SETSID_RUNTIME) {\n#endif\n#ifdef POSIX_SPAWN_SETSID\n        all_flags |= POSIX_SPAWN_SETSID;\n#elif defined(POSIX_SPAWN_SETSID_NP)\n        all_flags |= POSIX_SPAWN_SETSID_NP;\n#else\n        argument_unavailable_error(func_name, \"setsid\");\n        return -1;\n#endif\n\n#ifdef HAVE_POSIX_SPAWN_SETSID_RUNTIME\n        } else {\n            argument_unavailable_error(func_name, \"setsid\");\n            return -1;\n        }\n#endif /* HAVE_POSIX_SPAWN_SETSID_RUNTIME */\n\n    }\n\n#ifdef HAVE_SIGSET_T\n   if (setsigmask) {\n        sigset_t set;\n        if (!_Py_Sigset_Converter(setsigmask, &set)) {\n            goto fail;\n        }\n        errno = posix_spawnattr_setsigmask(attrp, &set);\n        if (errno) {\n            posix_error();\n            goto fail;\n        }\n        all_flags |= POSIX_SPAWN_SETSIGMASK;\n    }\n\n    if (setsigdef) {\n        sigset_t set;\n        if (!_Py_Sigset_Converter(setsigdef, &set)) {\n            goto fail;\n        }\n        errno = posix_spawnattr_setsigdefault(attrp, &set);\n        if (errno) {\n            posix_error();\n            goto fail;\n        }\n        all_flags |= POSIX_SPAWN_SETSIGDEF;\n    }\n#else\n    if (setsigmask || setsigdef) {\n        PyErr_SetString(PyExc_NotImplementedError,\n                        \"sigset is not supported on this platform\");\n        goto fail;\n    }\n#endif\n\n    if (scheduler) {\n#ifdef POSIX_SPAWN_SETSCHEDULER\n        PyObject *py_schedpolicy;\n        PyObject *schedparam_obj;\n        struct sched_param schedparam;\n\n        if (!PyArg_ParseTuple(scheduler, \"OO\"\n                        \";A scheduler tuple must have two elements\",\n                        &py_schedpolicy, &schedparam_obj)) {\n            goto fail;\n        }\n        if (!convert_sched_param(module, schedparam_obj, &schedparam)) {\n            goto fail;\n        }\n        if (py_schedpolicy != Py_None) {\n            int schedpolicy = PyLong_AsInt(py_schedpolicy);\n\n            if (schedpolicy == -1 && PyErr_Occurred()) {\n                goto fail;\n            }\n            errno = posix_spawnattr_setschedpolicy(attrp, schedpolicy);\n            if (errno) {\n                posix_error();\n                goto fail;\n            }\n            all_flags |= POSIX_SPAWN_SETSCHEDULER;\n        }\n        errno = posix_spawnattr_setschedparam(attrp, &schedparam);\n        if (errno) {\n            posix_error();\n            goto fail;\n        }\n        all_flags |= POSIX_SPAWN_SETSCHEDPARAM;\n#else\n        PyErr_SetString(PyExc_NotImplementedError,\n                \"The scheduler option is not supported in this system.\");\n        goto fail;\n#endif\n    }\n\n    errno = posix_spawnattr_setflags(attrp, all_flags);\n    if (errno) {\n        posix_error();\n        goto fail;\n    }\n\n    return 0;\n\nfail:\n    (void)posix_spawnattr_destroy(attrp);\n    return -1;\n}\n\nstatic int\nparse_file_actions(PyObject *file_actions,\n                   posix_spawn_file_actions_t *file_actionsp,\n                   PyObject *temp_buffer)\n{\n    PyObject *seq;\n    PyObject *file_action = NULL;\n    PyObject *tag_obj;\n\n    seq = PySequence_Fast(file_actions,\n                          \"file_actions must be a sequence or None\");\n    if (seq == NULL) {\n        return -1;\n    }\n\n    errno = posix_spawn_file_actions_init(file_actionsp);\n    if (errno) {\n        posix_error();\n        Py_DECREF(seq);\n        return -1;\n    }\n\n    for (Py_ssize_t i = 0; i < PySequence_Fast_GET_SIZE(seq); ++i) {\n        file_action = PySequence_Fast_GET_ITEM(seq, i);\n        Py_INCREF(file_action);\n        if (!PyTuple_Check(file_action) || !PyTuple_GET_SIZE(file_action)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"Each file_actions element must be a non-empty tuple\");\n            goto fail;\n        }\n        long tag = PyLong_AsLong(PyTuple_GET_ITEM(file_action, 0));\n        if (tag == -1 && PyErr_Occurred()) {\n            goto fail;\n        }\n\n        /* Populate the file_actions object */\n        switch (tag) {\n            case POSIX_SPAWN_OPEN: {\n                int fd, oflag;\n                PyObject *path;\n                unsigned long mode;\n                if (!PyArg_ParseTuple(file_action, \"OiO&ik\"\n                        \";A open file_action tuple must have 5 elements\",\n                        &tag_obj, &fd, PyUnicode_FSConverter, &path,\n                        &oflag, &mode))\n                {\n                    goto fail;\n                }\n                if (PyList_Append(temp_buffer, path)) {\n                    Py_DECREF(path);\n                    goto fail;\n                }\n                errno = posix_spawn_file_actions_addopen(file_actionsp,\n                        fd, PyBytes_AS_STRING(path), oflag, (mode_t)mode);\n                if (errno) {\n                    posix_error();\n                    Py_DECREF(path);\n                    goto fail;\n                }\n                Py_DECREF(path);\n                break;\n            }\n            case POSIX_SPAWN_CLOSE: {\n                int fd;\n                if (!PyArg_ParseTuple(file_action, \"Oi\"\n                        \";A close file_action tuple must have 2 elements\",\n                        &tag_obj, &fd))\n                {\n                    goto fail;\n                }\n                errno = posix_spawn_file_actions_addclose(file_actionsp, fd);\n                if (errno) {\n                    posix_error();\n                    goto fail;\n                }\n                break;\n            }\n            case POSIX_SPAWN_DUP2: {\n                int fd1, fd2;\n                if (!PyArg_ParseTuple(file_action, \"Oii\"\n                        \";A dup2 file_action tuple must have 3 elements\",\n                        &tag_obj, &fd1, &fd2))\n                {\n                    goto fail;\n                }\n                errno = posix_spawn_file_actions_adddup2(file_actionsp,\n                                                         fd1, fd2);\n                if (errno) {\n                    posix_error();\n                    goto fail;\n                }\n                break;\n            }\n#ifdef HAVE_POSIX_SPAWN_FILE_ACTIONS_ADDCLOSEFROM_NP\n            case POSIX_SPAWN_CLOSEFROM: {\n                int fd;\n                if (!PyArg_ParseTuple(file_action, \"Oi\"\n                        \";A closefrom file_action tuple must have 2 elements\",\n                        &tag_obj, &fd))\n                {\n                    goto fail;\n                }\n                errno = posix_spawn_file_actions_addclosefrom_np(file_actionsp,\n                                                                 fd);\n                if (errno) {\n                    posix_error();\n                    goto fail;\n                }\n                break;\n            }\n#endif\n            default: {\n                PyErr_SetString(PyExc_TypeError,\n                                \"Unknown file_actions identifier\");\n                goto fail;\n            }\n        }\n        Py_DECREF(file_action);\n    }\n\n    Py_DECREF(seq);\n    return 0;\n\nfail:\n    Py_DECREF(seq);\n    Py_DECREF(file_action);\n    (void)posix_spawn_file_actions_destroy(file_actionsp);\n    return -1;\n}\n\n\nstatic PyObject *\npy_posix_spawn(int use_posix_spawnp, PyObject *module, path_t *path, PyObject *argv,\n               PyObject *env, PyObject *file_actions,\n               PyObject *setpgroup, int resetids, int setsid, PyObject *setsigmask,\n               PyObject *setsigdef, PyObject *scheduler)\n{\n    const char *func_name = use_posix_spawnp ? \"posix_spawnp\" : \"posix_spawn\";\n    EXECV_CHAR **argvlist = NULL;\n    EXECV_CHAR **envlist = NULL;\n    posix_spawn_file_actions_t file_actions_buf;\n    posix_spawn_file_actions_t *file_actionsp = NULL;\n    posix_spawnattr_t attr;\n    posix_spawnattr_t *attrp = NULL;\n    Py_ssize_t argc, envc;\n    PyObject *result = NULL;\n    PyObject *temp_buffer = NULL;\n    pid_t pid;\n    int err_code;\n\n    /* posix_spawn and posix_spawnp have three arguments: (path, argv, env), where\n       argv is a list or tuple of strings and env is a dictionary\n       like posix.environ. */\n\n    if (!PyList_Check(argv) && !PyTuple_Check(argv)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"%s: argv must be a tuple or list\", func_name);\n        goto exit;\n    }\n    argc = PySequence_Size(argv);\n    if (argc < 1) {\n        PyErr_Format(PyExc_ValueError,\n                     \"%s: argv must not be empty\", func_name);\n        return NULL;\n    }\n\n    if (!PyMapping_Check(env) && env != Py_None) {\n        PyErr_Format(PyExc_TypeError,\n                     \"%s: environment must be a mapping object or None\", func_name);\n        goto exit;\n    }\n\n    argvlist = parse_arglist(argv, &argc);\n    if (argvlist == NULL) {\n        goto exit;\n    }\n    if (!argvlist[0][0]) {\n        PyErr_Format(PyExc_ValueError,\n                     \"%s: argv first element cannot be empty\", func_name);\n        goto exit;\n    }\n\n#ifdef USE_DARWIN_NS_GET_ENVIRON\n    // There is no environ global in this situation.\n    char **environ = NULL;\n#endif\n\n    if (env == Py_None) {\n#ifdef USE_DARWIN_NS_GET_ENVIRON\n        environ = *_NSGetEnviron();\n#endif\n        envlist = environ;\n    } else {\n        envlist = parse_envlist(env, &envc);\n        if (envlist == NULL) {\n            goto exit;\n        }\n    }\n\n    if (file_actions != NULL && file_actions != Py_None) {\n        /* There is a bug in old versions of glibc that makes some of the\n         * helper functions for manipulating file actions not copy the provided\n         * buffers. The problem is that posix_spawn_file_actions_addopen does not\n         * copy the value of path for some old versions of glibc (<2.20).\n         * The use of temp_buffer here is a workaround that keeps the\n         * python objects that own the buffers alive until posix_spawn gets called.\n         * Check https://bugs.python.org/issue33630 and\n         * https://sourceware.org/bugzilla/show_bug.cgi?id=17048 for more info.*/\n        temp_buffer = PyList_New(0);\n        if (!temp_buffer) {\n            goto exit;\n        }\n        if (parse_file_actions(file_actions, &file_actions_buf, temp_buffer)) {\n            goto exit;\n        }\n        file_actionsp = &file_actions_buf;\n    }\n\n    if (parse_posix_spawn_flags(module, func_name, setpgroup, resetids, setsid,\n                                setsigmask, setsigdef, scheduler, &attr)) {\n        goto exit;\n    }\n    attrp = &attr;\n\n    if (PySys_Audit(\"os.posix_spawn\", \"OOO\", path->object, argv, env) < 0) {\n        goto exit;\n    }\n\n    _Py_BEGIN_SUPPRESS_IPH\n#ifdef HAVE_POSIX_SPAWNP\n    if (use_posix_spawnp) {\n        err_code = posix_spawnp(&pid, path->narrow,\n                                file_actionsp, attrp, argvlist, envlist);\n    }\n    else\n#endif /* HAVE_POSIX_SPAWNP */\n    {\n        err_code = posix_spawn(&pid, path->narrow,\n                               file_actionsp, attrp, argvlist, envlist);\n    }\n    _Py_END_SUPPRESS_IPH\n\n    if (err_code) {\n        errno = err_code;\n        PyErr_SetFromErrnoWithFilenameObject(PyExc_OSError, path->object);\n        goto exit;\n    }\n#ifdef _Py_MEMORY_SANITIZER\n    __msan_unpoison(&pid, sizeof(pid));\n#endif\n    result = PyLong_FromPid(pid);\n\nexit:\n    if (file_actionsp) {\n        (void)posix_spawn_file_actions_destroy(file_actionsp);\n    }\n    if (attrp) {\n        (void)posix_spawnattr_destroy(attrp);\n    }\n    if (envlist && envlist != environ) {\n        free_string_array(envlist, envc);\n    }\n    if (argvlist) {\n        free_string_array(argvlist, argc);\n    }\n    Py_XDECREF(temp_buffer);\n    return result;\n}\n\n\n/*[clinic input]\n\nos.posix_spawn\n    path: path_t\n        Path of executable file.\n    argv: object\n        Tuple or list of strings.\n    env: object\n        Dictionary of strings mapping to strings.\n    /\n    *\n    file_actions: object(c_default='NULL') = ()\n        A sequence of file action tuples.\n    setpgroup: object = NULL\n        The pgroup to use with the POSIX_SPAWN_SETPGROUP flag.\n    resetids: bool = False\n        If the value is `true` the POSIX_SPAWN_RESETIDS will be activated.\n    setsid: bool = False\n        If the value is `true` the POSIX_SPAWN_SETSID or POSIX_SPAWN_SETSID_NP will be activated.\n    setsigmask: object(c_default='NULL') = ()\n        The sigmask to use with the POSIX_SPAWN_SETSIGMASK flag.\n    setsigdef: object(c_default='NULL') = ()\n        The sigmask to use with the POSIX_SPAWN_SETSIGDEF flag.\n    scheduler: object = NULL\n        A tuple with the scheduler policy (optional) and parameters.\n\nExecute the program specified by path in a new process.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_posix_spawn_impl(PyObject *module, path_t *path, PyObject *argv,\n                    PyObject *env, PyObject *file_actions,\n                    PyObject *setpgroup, int resetids, int setsid,\n                    PyObject *setsigmask, PyObject *setsigdef,\n                    PyObject *scheduler)\n/*[clinic end generated code: output=14a1098c566bc675 input=808aed1090d84e33]*/\n{\n    return py_posix_spawn(0, module, path, argv, env, file_actions,\n                          setpgroup, resetids, setsid, setsigmask, setsigdef,\n                          scheduler);\n}\n #endif /* HAVE_POSIX_SPAWN */\n\n\n\n#ifdef HAVE_POSIX_SPAWNP\n/*[clinic input]\n\nos.posix_spawnp\n    path: path_t\n        Path of executable file.\n    argv: object\n        Tuple or list of strings.\n    env: object\n        Dictionary of strings mapping to strings.\n    /\n    *\n    file_actions: object(c_default='NULL') = ()\n        A sequence of file action tuples.\n    setpgroup: object = NULL\n        The pgroup to use with the POSIX_SPAWN_SETPGROUP flag.\n    resetids: bool = False\n        If the value is `True` the POSIX_SPAWN_RESETIDS will be activated.\n    setsid: bool = False\n        If the value is `True` the POSIX_SPAWN_SETSID or POSIX_SPAWN_SETSID_NP will be activated.\n    setsigmask: object(c_default='NULL') = ()\n        The sigmask to use with the POSIX_SPAWN_SETSIGMASK flag.\n    setsigdef: object(c_default='NULL') = ()\n        The sigmask to use with the POSIX_SPAWN_SETSIGDEF flag.\n    scheduler: object = NULL\n        A tuple with the scheduler policy (optional) and parameters.\n\nExecute the program specified by path in a new process.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_posix_spawnp_impl(PyObject *module, path_t *path, PyObject *argv,\n                     PyObject *env, PyObject *file_actions,\n                     PyObject *setpgroup, int resetids, int setsid,\n                     PyObject *setsigmask, PyObject *setsigdef,\n                     PyObject *scheduler)\n/*[clinic end generated code: output=7b9aaefe3031238d input=9e89e616116752a1]*/\n{\n    return py_posix_spawn(1, module, path, argv, env, file_actions,\n                          setpgroup, resetids, setsid, setsigmask, setsigdef,\n                          scheduler);\n}\n#endif /* HAVE_POSIX_SPAWNP */\n\n#ifdef HAVE_RTPSPAWN\nstatic intptr_t\n_rtp_spawn(int mode, const char *rtpFileName, const char *argv[],\n               const char  *envp[])\n{\n     RTP_ID rtpid;\n     int status;\n     pid_t res;\n     int async_err = 0;\n\n     /* Set priority=100 and uStackSize=16 MiB (0x1000000) for new processes.\n        uStackSize=0 cannot be used, the default stack size is too small for\n        Python. */\n     if (envp) {\n         rtpid = rtpSpawn(rtpFileName, argv, envp,\n                          100, 0x1000000, 0, VX_FP_TASK);\n     }\n     else {\n         rtpid = rtpSpawn(rtpFileName, argv, (const char **)environ,\n                          100, 0x1000000, 0, VX_FP_TASK);\n     }\n     if ((rtpid != RTP_ID_ERROR) && (mode == _P_WAIT)) {\n         do {\n             res = waitpid((pid_t)rtpid, &status, 0);\n         } while (res < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n\n         if (res < 0)\n             return RTP_ID_ERROR;\n         return ((intptr_t)status);\n     }\n     return ((intptr_t)rtpid);\n}\n#endif\n\n#if defined(HAVE_SPAWNV) || defined(HAVE_WSPAWNV) || defined(HAVE_RTPSPAWN)\n/*[clinic input]\nos.spawnv\n\n    mode: int\n        Mode of process creation.\n    path: path_t\n        Path of executable file.\n    argv: object\n        Tuple or list of strings.\n    /\n\nExecute the program specified by path in a new process.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_spawnv_impl(PyObject *module, int mode, path_t *path, PyObject *argv)\n/*[clinic end generated code: output=71cd037a9d96b816 input=43224242303291be]*/\n{\n    EXECV_CHAR **argvlist;\n    int i;\n    Py_ssize_t argc;\n    intptr_t spawnval;\n    PyObject *(*getitem)(PyObject *, Py_ssize_t);\n\n    /* spawnv has three arguments: (mode, path, argv), where\n       argv is a list or tuple of strings. */\n\n    if (PyList_Check(argv)) {\n        argc = PyList_Size(argv);\n        getitem = PyList_GetItem;\n    }\n    else if (PyTuple_Check(argv)) {\n        argc = PyTuple_Size(argv);\n        getitem = PyTuple_GetItem;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"spawnv() arg 2 must be a tuple or list\");\n        return NULL;\n    }\n    if (argc == 0) {\n        PyErr_SetString(PyExc_ValueError,\n            \"spawnv() arg 2 cannot be empty\");\n        return NULL;\n    }\n\n    argvlist = PyMem_NEW(EXECV_CHAR *, argc+1);\n    if (argvlist == NULL) {\n        return PyErr_NoMemory();\n    }\n    for (i = 0; i < argc; i++) {\n        if (!fsconvert_strdup((*getitem)(argv, i),\n                              &argvlist[i])) {\n            free_string_array(argvlist, i);\n            PyErr_SetString(\n                PyExc_TypeError,\n                \"spawnv() arg 2 must contain only strings\");\n            return NULL;\n        }\n        if (i == 0 && !argvlist[0][0]) {\n            free_string_array(argvlist, i + 1);\n            PyErr_SetString(\n                PyExc_ValueError,\n                \"spawnv() arg 2 first element cannot be empty\");\n            return NULL;\n        }\n    }\n    argvlist[argc] = NULL;\n\n#if !defined(HAVE_RTPSPAWN)\n    if (mode == _OLD_P_OVERLAY)\n        mode = _P_OVERLAY;\n#endif\n\n    if (PySys_Audit(\"os.spawn\", \"iOOO\", mode, path->object, argv,\n                    Py_None) < 0) {\n        free_string_array(argvlist, argc);\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    _Py_BEGIN_SUPPRESS_IPH\n#ifdef HAVE_WSPAWNV\n    spawnval = _wspawnv(mode, path->wide, argvlist);\n#elif defined(HAVE_RTPSPAWN)\n    spawnval = _rtp_spawn(mode, path->narrow, (const char **)argvlist, NULL);\n#else\n    spawnval = _spawnv(mode, path->narrow, argvlist);\n#endif\n    _Py_END_SUPPRESS_IPH\n    Py_END_ALLOW_THREADS\n\n    int saved_errno = errno;\n    free_string_array(argvlist, argc);\n\n    if (spawnval == -1) {\n        errno = saved_errno;\n        posix_error();\n        return NULL;\n    }\n    return Py_BuildValue(_Py_PARSE_INTPTR, spawnval);\n}\n\n/*[clinic input]\nos.spawnve\n\n    mode: int\n        Mode of process creation.\n    path: path_t\n        Path of executable file.\n    argv: object\n        Tuple or list of strings.\n    env: object\n        Dictionary of strings mapping to strings.\n    /\n\nExecute the program specified by path in a new process.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_spawnve_impl(PyObject *module, int mode, path_t *path, PyObject *argv,\n                PyObject *env)\n/*[clinic end generated code: output=30fe85be56fe37ad input=3e40803ee7c4c586]*/\n{\n    EXECV_CHAR **argvlist;\n    EXECV_CHAR **envlist;\n    PyObject *res = NULL;\n    Py_ssize_t argc, i, envc;\n    intptr_t spawnval;\n    PyObject *(*getitem)(PyObject *, Py_ssize_t);\n    Py_ssize_t lastarg = 0;\n\n    /* spawnve has four arguments: (mode, path, argv, env), where\n       argv is a list or tuple of strings and env is a dictionary\n       like posix.environ. */\n\n    if (PyList_Check(argv)) {\n        argc = PyList_Size(argv);\n        getitem = PyList_GetItem;\n    }\n    else if (PyTuple_Check(argv)) {\n        argc = PyTuple_Size(argv);\n        getitem = PyTuple_GetItem;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"spawnve() arg 2 must be a tuple or list\");\n        goto fail_0;\n    }\n    if (argc == 0) {\n        PyErr_SetString(PyExc_ValueError,\n            \"spawnve() arg 2 cannot be empty\");\n        goto fail_0;\n    }\n    if (!PyMapping_Check(env)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"spawnve() arg 3 must be a mapping object\");\n        goto fail_0;\n    }\n\n    argvlist = PyMem_NEW(EXECV_CHAR *, argc+1);\n    if (argvlist == NULL) {\n        PyErr_NoMemory();\n        goto fail_0;\n    }\n    for (i = 0; i < argc; i++) {\n        if (!fsconvert_strdup((*getitem)(argv, i),\n                              &argvlist[i]))\n        {\n            lastarg = i;\n            goto fail_1;\n        }\n        if (i == 0 && !argvlist[0][0]) {\n            lastarg = i + 1;\n            PyErr_SetString(\n                PyExc_ValueError,\n                \"spawnv() arg 2 first element cannot be empty\");\n            goto fail_1;\n        }\n    }\n    lastarg = argc;\n    argvlist[argc] = NULL;\n\n    envlist = parse_envlist(env, &envc);\n    if (envlist == NULL)\n        goto fail_1;\n\n#if !defined(HAVE_RTPSPAWN)\n    if (mode == _OLD_P_OVERLAY)\n        mode = _P_OVERLAY;\n#endif\n\n    if (PySys_Audit(\"os.spawn\", \"iOOO\", mode, path->object, argv, env) < 0) {\n        goto fail_2;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    _Py_BEGIN_SUPPRESS_IPH\n#ifdef HAVE_WSPAWNV\n    spawnval = _wspawnve(mode, path->wide, argvlist, envlist);\n#elif defined(HAVE_RTPSPAWN)\n    spawnval = _rtp_spawn(mode, path->narrow, (const char **)argvlist,\n                           (const char **)envlist);\n#else\n    spawnval = _spawnve(mode, path->narrow, argvlist, envlist);\n#endif\n    _Py_END_SUPPRESS_IPH\n    Py_END_ALLOW_THREADS\n\n    if (spawnval == -1)\n        (void) posix_error();\n    else\n        res = Py_BuildValue(_Py_PARSE_INTPTR, spawnval);\n\n  fail_2:\n    while (--envc >= 0) {\n        PyMem_Free(envlist[envc]);\n    }\n    PyMem_Free(envlist);\n  fail_1:\n    free_string_array(argvlist, lastarg);\n  fail_0:\n    return res;\n}\n\n#endif /* HAVE_SPAWNV */\n\n#ifdef HAVE_FORK\n\n/* Helper function to validate arguments.\n   Returns 0 on success.  non-zero on failure with a TypeError raised.\n   If obj is non-NULL it must be callable.  */\nstatic int\ncheck_null_or_callable(PyObject *obj, const char* obj_name)\n{\n    if (obj && !PyCallable_Check(obj)) {\n        PyErr_Format(PyExc_TypeError, \"'%s' must be callable, not %s\",\n                     obj_name, _PyType_Name(Py_TYPE(obj)));\n        return -1;\n    }\n    return 0;\n}\n\n/*[clinic input]\nos.register_at_fork\n\n    *\n    before: object=NULL\n        A callable to be called in the parent before the fork() syscall.\n    after_in_child: object=NULL\n        A callable to be called in the child after fork().\n    after_in_parent: object=NULL\n        A callable to be called in the parent after fork().\n\nRegister callables to be called when forking a new process.\n\n'before' callbacks are called in reverse order.\n'after_in_child' and 'after_in_parent' callbacks are called in order.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_register_at_fork_impl(PyObject *module, PyObject *before,\n                         PyObject *after_in_child, PyObject *after_in_parent)\n/*[clinic end generated code: output=5398ac75e8e97625 input=cd1187aa85d2312e]*/\n{\n    PyInterpreterState *interp;\n\n    if (!before && !after_in_child && !after_in_parent) {\n        PyErr_SetString(PyExc_TypeError, \"At least one argument is required.\");\n        return NULL;\n    }\n    if (check_null_or_callable(before, \"before\") ||\n        check_null_or_callable(after_in_child, \"after_in_child\") ||\n        check_null_or_callable(after_in_parent, \"after_in_parent\")) {\n        return NULL;\n    }\n    interp = _PyInterpreterState_GET();\n\n    if (register_at_forker(&interp->before_forkers, before)) {\n        return NULL;\n    }\n    if (register_at_forker(&interp->after_forkers_child, after_in_child)) {\n        return NULL;\n    }\n    if (register_at_forker(&interp->after_forkers_parent, after_in_parent)) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_FORK */\n\n#if defined(HAVE_FORK1) || defined(HAVE_FORKPTY) || defined(HAVE_FORK)\n// Common code to raise a warning if we detect there is more than one thread\n// running in the process. Best effort, silent if unable to count threads.\n// Constraint: Quick. Never overcounts. Never leaves an error set.\n//\n// This should only be called from the parent process after\n// PyOS_AfterFork_Parent().\nstatic void\nwarn_about_fork_with_threads(const char* name)\n{\n    // It's not safe to issue the warning while the world is stopped, because\n    // other threads might be holding locks that we need, which would deadlock.\n    assert(!_PyRuntime.stoptheworld.world_stopped);\n\n    // TODO: Consider making an `os` module API to return the current number\n    // of threads in the process. That'd presumably use this platform code but\n    // raise an error rather than using the inaccurate fallback.\n    Py_ssize_t num_python_threads = 0;\n#if defined(__APPLE__) && defined(HAVE_GETPID)\n    mach_port_t macos_self = mach_task_self();\n    mach_port_t macos_task;\n    if (task_for_pid(macos_self, getpid(), &macos_task) == KERN_SUCCESS) {\n        thread_array_t macos_threads;\n        mach_msg_type_number_t macos_n_threads;\n        if (task_threads(macos_task, &macos_threads,\n                         &macos_n_threads) == KERN_SUCCESS) {\n            num_python_threads = macos_n_threads;\n        }\n    }\n#elif defined(__linux__)\n    // Linux /proc/self/stat 20th field is the number of threads.\n    FILE* proc_stat = fopen(\"/proc/self/stat\", \"r\");\n    if (proc_stat) {\n        size_t n;\n        // Size chosen arbitrarily. ~60% more bytes than a 20th column index\n        // observed on the author's workstation.\n        char stat_line[160];\n        n = fread(&stat_line, 1, 159, proc_stat);\n        stat_line[n] = '\\0';\n        fclose(proc_stat);\n\n        char *saveptr = NULL;\n        char *field = strtok_r(stat_line, \" \", &saveptr);\n        unsigned int idx;\n        for (idx = 19; idx && field; --idx) {\n            field = strtok_r(NULL, \" \", &saveptr);\n        }\n        if (idx == 0 && field) {  // found the 20th field\n            num_python_threads = atoi(field);  // 0 on error\n        }\n    }\n#endif\n    if (num_python_threads <= 0) {\n        // Fall back to just the number our threading module knows about.\n        // An incomplete view of the world, but better than nothing.\n        PyObject *threading = PyImport_GetModule(&_Py_ID(threading));\n        if (!threading) {\n            PyErr_Clear();\n            return;\n        }\n        PyObject *threading_active =\n                PyObject_GetAttr(threading, &_Py_ID(_active));\n        if (!threading_active) {\n            PyErr_Clear();\n            Py_DECREF(threading);\n            return;\n        }\n        PyObject *threading_limbo =\n                PyObject_GetAttr(threading, &_Py_ID(_limbo));\n        if (!threading_limbo) {\n            PyErr_Clear();\n            Py_DECREF(threading);\n            Py_DECREF(threading_active);\n            return;\n        }\n        Py_DECREF(threading);\n        // Duplicating what threading.active_count() does but without holding\n        // threading._active_limbo_lock so our count could be inaccurate if\n        // these dicts are mid-update from another thread.  Not a big deal.\n        // Worst case if someone replaced threading._active or threading._limbo\n        // with non-dicts, we get -1 from *Length() below and undercount.\n        // Nobody should, but we're best effort so we clear errors and move on.\n        num_python_threads = (PyMapping_Length(threading_active)\n                              + PyMapping_Length(threading_limbo));\n        PyErr_Clear();\n        Py_DECREF(threading_active);\n        Py_DECREF(threading_limbo);\n    }\n    if (num_python_threads > 1) {\n        PyErr_WarnFormat(\n                PyExc_DeprecationWarning, 1,\n#ifdef HAVE_GETPID\n                \"This process (pid=%d) is multi-threaded, \"\n#else\n                \"This process is multi-threaded, \"\n#endif\n                \"use of %s() may lead to deadlocks in the child.\",\n#ifdef HAVE_GETPID\n                getpid(),\n#endif\n                name);\n        PyErr_Clear();\n    }\n}\n#endif  // HAVE_FORK1 || HAVE_FORKPTY || HAVE_FORK\n\n#ifdef HAVE_FORK1\n/*[clinic input]\nos.fork1\n\nFork a child process with a single multiplexed (i.e., not bound) thread.\n\nReturn 0 to child process and PID of child to parent process.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_fork1_impl(PyObject *module)\n/*[clinic end generated code: output=0de8e67ce2a310bc input=12db02167893926e]*/\n{\n    pid_t pid;\n\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    if (_PyInterpreterState_GetFinalizing(interp) != NULL) {\n        PyErr_SetString(PyExc_PythonFinalizationError,\n                        \"can't fork at interpreter shutdown\");\n        return NULL;\n    }\n    if (!_Py_IsMainInterpreter(interp)) {\n        PyErr_SetString(PyExc_RuntimeError, \"fork not supported for subinterpreters\");\n        return NULL;\n    }\n    PyOS_BeforeFork();\n    pid = fork1();\n    int saved_errno = errno;\n    if (pid == 0) {\n        /* child: this clobbers and resets the import lock. */\n        PyOS_AfterFork_Child();\n    } else {\n        /* parent: release the import lock. */\n        PyOS_AfterFork_Parent();\n        // After PyOS_AfterFork_Parent() starts the world to avoid deadlock.\n        warn_about_fork_with_threads(\"fork1\");\n    }\n    if (pid == -1) {\n        errno = saved_errno;\n        return posix_error();\n    }\n    return PyLong_FromPid(pid);\n}\n#endif /* HAVE_FORK1 */\n\n\n#ifdef HAVE_FORK\n/*[clinic input]\nos.fork\n\nFork a child process.\n\nReturn 0 to child process and PID of child to parent process.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_fork_impl(PyObject *module)\n/*[clinic end generated code: output=3626c81f98985d49 input=13c956413110eeaa]*/\n{\n    pid_t pid;\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    if (_PyInterpreterState_GetFinalizing(interp) != NULL) {\n        PyErr_SetString(PyExc_PythonFinalizationError,\n                        \"can't fork at interpreter shutdown\");\n        return NULL;\n    }\n    if (!_PyInterpreterState_HasFeature(interp, Py_RTFLAGS_FORK)) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"fork not supported for isolated subinterpreters\");\n        return NULL;\n    }\n    if (PySys_Audit(\"os.fork\", NULL) < 0) {\n        return NULL;\n    }\n    PyOS_BeforeFork();\n    pid = fork();\n    int saved_errno = errno;\n    if (pid == 0) {\n        /* child: this clobbers and resets the import lock. */\n        PyOS_AfterFork_Child();\n    } else {\n        /* parent: release the import lock. */\n        PyOS_AfterFork_Parent();\n        // After PyOS_AfterFork_Parent() starts the world to avoid deadlock.\n        warn_about_fork_with_threads(\"fork\");\n    }\n    if (pid == -1) {\n        errno = saved_errno;\n        return posix_error();\n    }\n    return PyLong_FromPid(pid);\n}\n#endif /* HAVE_FORK */\n\n\n#ifdef HAVE_SCHED_H\n#ifdef HAVE_SCHED_GET_PRIORITY_MAX\n/*[clinic input]\nos.sched_get_priority_max\n\n    policy: int\n\nGet the maximum scheduling priority for policy.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sched_get_priority_max_impl(PyObject *module, int policy)\n/*[clinic end generated code: output=9e465c6e43130521 input=2097b7998eca6874]*/\n{\n    int max;\n\n    max = sched_get_priority_max(policy);\n    if (max < 0)\n        return posix_error();\n    return PyLong_FromLong(max);\n}\n\n\n/*[clinic input]\nos.sched_get_priority_min\n\n    policy: int\n\nGet the minimum scheduling priority for policy.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sched_get_priority_min_impl(PyObject *module, int policy)\n/*[clinic end generated code: output=7595c1138cc47a6d input=21bc8fa0d70983bf]*/\n{\n    int min = sched_get_priority_min(policy);\n    if (min < 0)\n        return posix_error();\n    return PyLong_FromLong(min);\n}\n#endif /* HAVE_SCHED_GET_PRIORITY_MAX */\n\n\n#ifdef HAVE_SCHED_SETSCHEDULER\n/*[clinic input]\nos.sched_getscheduler\n    pid: pid_t\n    /\n\nGet the scheduling policy for the process identified by pid.\n\nPassing 0 for pid returns the scheduling policy for the calling process.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sched_getscheduler_impl(PyObject *module, pid_t pid)\n/*[clinic end generated code: output=dce4c0bd3f1b34c8 input=8d99dac505485ac8]*/\n{\n    int policy;\n\n    policy = sched_getscheduler(pid);\n    if (policy < 0)\n        return posix_error();\n    return PyLong_FromLong(policy);\n}\n#endif /* HAVE_SCHED_SETSCHEDULER */\n\n\n#if defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDPARAM)\n/*[clinic input]\nclass os.sched_param \"PyObject *\" \"SchedParamType\"\n\n@classmethod\nos.sched_param.__new__\n\n    sched_priority: object\n        A scheduling parameter.\n\nCurrently has only one field: sched_priority\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sched_param_impl(PyTypeObject *type, PyObject *sched_priority)\n/*[clinic end generated code: output=48f4067d60f48c13 input=eb42909a2c0e3e6c]*/\n{\n    PyObject *res;\n\n    res = PyStructSequence_New(type);\n    if (!res)\n        return NULL;\n    PyStructSequence_SET_ITEM(res, 0, Py_NewRef(sched_priority));\n    return res;\n}\n\nPyDoc_VAR(os_sched_param__doc__);\n\nstatic PyStructSequence_Field sched_param_fields[] = {\n    {\"sched_priority\", \"the scheduling priority\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc sched_param_desc = {\n    \"sched_param\", /* name */\n    os_sched_param__doc__, /* doc */\n    sched_param_fields,\n    1\n};\n\nstatic int\nconvert_sched_param(PyObject *module, PyObject *param, struct sched_param *res)\n{\n    long priority;\n\n    if (!Py_IS_TYPE(param, (PyTypeObject *)get_posix_state(module)->SchedParamType)) {\n        PyErr_SetString(PyExc_TypeError, \"must have a sched_param object\");\n        return 0;\n    }\n    priority = PyLong_AsLong(PyStructSequence_GET_ITEM(param, 0));\n    if (priority == -1 && PyErr_Occurred())\n        return 0;\n    if (priority > INT_MAX || priority < INT_MIN) {\n        PyErr_SetString(PyExc_OverflowError, \"sched_priority out of range\");\n        return 0;\n    }\n    res->sched_priority = Py_SAFE_DOWNCAST(priority, long, int);\n    return 1;\n}\n#endif /* defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDPARAM) */\n\n\n#ifdef HAVE_SCHED_SETSCHEDULER\n/*[clinic input]\nos.sched_setscheduler\n\n    pid: pid_t\n    policy: int\n    param as param_obj: object\n    /\n\nSet the scheduling policy for the process identified by pid.\n\nIf pid is 0, the calling process is changed.\nparam is an instance of sched_param.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sched_setscheduler_impl(PyObject *module, pid_t pid, int policy,\n                           PyObject *param_obj)\n/*[clinic end generated code: output=cde27faa55dc993e input=73013d731bd8fbe9]*/\n{\n    struct sched_param param;\n    if (!convert_sched_param(module, param_obj, &param)) {\n        return NULL;\n    }\n\n    /*\n    ** sched_setscheduler() returns 0 in Linux, but the previous\n    ** scheduling policy under Solaris/Illumos, and others.\n    ** On error, -1 is returned in all Operating Systems.\n    */\n    if (sched_setscheduler(pid, policy, &param) == -1)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif  /* HAVE_SCHED_SETSCHEDULER*/\n\n\n#ifdef HAVE_SCHED_SETPARAM\n/*[clinic input]\nos.sched_getparam\n    pid: pid_t\n    /\n\nReturns scheduling parameters for the process identified by pid.\n\nIf pid is 0, returns parameters for the calling process.\nReturn value is an instance of sched_param.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sched_getparam_impl(PyObject *module, pid_t pid)\n/*[clinic end generated code: output=b194e8708dcf2db8 input=18a1ef9c2efae296]*/\n{\n    struct sched_param param;\n    PyObject *result;\n    PyObject *priority;\n\n    if (sched_getparam(pid, &param))\n        return posix_error();\n    PyObject *SchedParamType = get_posix_state(module)->SchedParamType;\n    result = PyStructSequence_New((PyTypeObject *)SchedParamType);\n    if (!result)\n        return NULL;\n    priority = PyLong_FromLong(param.sched_priority);\n    if (!priority) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    PyStructSequence_SET_ITEM(result, 0, priority);\n    return result;\n}\n\n\n/*[clinic input]\nos.sched_setparam\n    pid: pid_t\n    param as param_obj: object\n    /\n\nSet scheduling parameters for the process identified by pid.\n\nIf pid is 0, sets parameters for the calling process.\nparam should be an instance of sched_param.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sched_setparam_impl(PyObject *module, pid_t pid, PyObject *param_obj)\n/*[clinic end generated code: output=f19fe020a53741c1 input=27b98337c8b2dcc7]*/\n{\n    struct sched_param param;\n    if (!convert_sched_param(module, param_obj, &param)) {\n        return NULL;\n    }\n\n    if (sched_setparam(pid, &param))\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SCHED_SETPARAM */\n\n\n#ifdef HAVE_SCHED_RR_GET_INTERVAL\n/*[clinic input]\nos.sched_rr_get_interval -> double\n    pid: pid_t\n    /\n\nReturn the round-robin quantum for the process identified by pid, in seconds.\n\nValue returned is a float.\n[clinic start generated code]*/\n\nstatic double\nos_sched_rr_get_interval_impl(PyObject *module, pid_t pid)\n/*[clinic end generated code: output=7e2d935833ab47dc input=2a973da15cca6fae]*/\n{\n    struct timespec interval;\n    if (sched_rr_get_interval(pid, &interval)) {\n        posix_error();\n        return -1.0;\n    }\n#ifdef _Py_MEMORY_SANITIZER\n    __msan_unpoison(&interval, sizeof(interval));\n#endif\n    return (double)interval.tv_sec + 1e-9*interval.tv_nsec;\n}\n#endif /* HAVE_SCHED_RR_GET_INTERVAL */\n\n\n/*[clinic input]\nos.sched_yield\n\nVoluntarily relinquish the CPU.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sched_yield_impl(PyObject *module)\n/*[clinic end generated code: output=902323500f222cac input=e54d6f98189391d4]*/\n{\n    int result;\n    Py_BEGIN_ALLOW_THREADS\n    result = sched_yield();\n    Py_END_ALLOW_THREADS\n    if (result < 0) {\n        return posix_error();\n    }\n    Py_RETURN_NONE;\n}\n\n#ifdef HAVE_SCHED_SETAFFINITY\n/* The minimum number of CPUs allocated in a cpu_set_t */\nstatic const int NCPUS_START = sizeof(unsigned long) * CHAR_BIT;\n\n/*[clinic input]\nos.sched_setaffinity\n    pid: pid_t\n    mask : object\n    /\n\nSet the CPU affinity of the process identified by pid to mask.\n\nmask should be an iterable of integers identifying CPUs.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sched_setaffinity_impl(PyObject *module, pid_t pid, PyObject *mask)\n/*[clinic end generated code: output=882d7dd9a229335b input=a0791a597c7085ba]*/\n{\n    int ncpus;\n    size_t setsize;\n    cpu_set_t *cpu_set = NULL;\n    PyObject *iterator = NULL, *item;\n\n    iterator = PyObject_GetIter(mask);\n    if (iterator == NULL)\n        return NULL;\n\n    ncpus = NCPUS_START;\n    setsize = CPU_ALLOC_SIZE(ncpus);\n    cpu_set = CPU_ALLOC(ncpus);\n    if (cpu_set == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n    CPU_ZERO_S(setsize, cpu_set);\n\n    while ((item = PyIter_Next(iterator))) {\n        long cpu;\n        if (!PyLong_Check(item)) {\n            PyErr_Format(PyExc_TypeError,\n                        \"expected an iterator of ints, \"\n                        \"but iterator yielded %R\",\n                        Py_TYPE(item));\n            Py_DECREF(item);\n            goto error;\n        }\n        cpu = PyLong_AsLong(item);\n        Py_DECREF(item);\n        if (cpu < 0) {\n            if (!PyErr_Occurred())\n                PyErr_SetString(PyExc_ValueError, \"negative CPU number\");\n            goto error;\n        }\n        if (cpu > INT_MAX - 1) {\n            PyErr_SetString(PyExc_OverflowError, \"CPU number too large\");\n            goto error;\n        }\n        if (cpu >= ncpus) {\n            /* Grow CPU mask to fit the CPU number */\n            int newncpus = ncpus;\n            cpu_set_t *newmask;\n            size_t newsetsize;\n            while (newncpus <= cpu) {\n                if (newncpus > INT_MAX / 2)\n                    newncpus = cpu + 1;\n                else\n                    newncpus = newncpus * 2;\n            }\n            newmask = CPU_ALLOC(newncpus);\n            if (newmask == NULL) {\n                PyErr_NoMemory();\n                goto error;\n            }\n            newsetsize = CPU_ALLOC_SIZE(newncpus);\n            CPU_ZERO_S(newsetsize, newmask);\n            memcpy(newmask, cpu_set, setsize);\n            CPU_FREE(cpu_set);\n            setsize = newsetsize;\n            cpu_set = newmask;\n            ncpus = newncpus;\n        }\n        CPU_SET_S(cpu, setsize, cpu_set);\n    }\n    if (PyErr_Occurred()) {\n        goto error;\n    }\n    Py_CLEAR(iterator);\n\n    if (sched_setaffinity(pid, setsize, cpu_set)) {\n        posix_error();\n        goto error;\n    }\n    CPU_FREE(cpu_set);\n    Py_RETURN_NONE;\n\nerror:\n    if (cpu_set)\n        CPU_FREE(cpu_set);\n    Py_XDECREF(iterator);\n    return NULL;\n}\n\n\n/*[clinic input]\nos.sched_getaffinity\n    pid: pid_t\n    /\n\nReturn the affinity of the process identified by pid (or the current process if zero).\n\nThe affinity is returned as a set of CPU identifiers.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sched_getaffinity_impl(PyObject *module, pid_t pid)\n/*[clinic end generated code: output=f726f2c193c17a4f input=983ce7cb4a565980]*/\n{\n    int ncpus = NCPUS_START;\n    size_t setsize;\n    cpu_set_t *mask;\n\n    while (1) {\n        setsize = CPU_ALLOC_SIZE(ncpus);\n        mask = CPU_ALLOC(ncpus);\n        if (mask == NULL) {\n            return PyErr_NoMemory();\n        }\n        if (sched_getaffinity(pid, setsize, mask) == 0) {\n            break;\n        }\n        CPU_FREE(mask);\n        if (errno != EINVAL) {\n            return posix_error();\n        }\n        if (ncpus > INT_MAX / 2) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"could not allocate a large enough CPU set\");\n            return NULL;\n        }\n        ncpus *= 2;\n    }\n\n    PyObject *res = PySet_New(NULL);\n    if (res == NULL) {\n        goto error;\n    }\n\n    int cpu = 0;\n    int count = CPU_COUNT_S(setsize, mask);\n    for (; count; cpu++) {\n        if (CPU_ISSET_S(cpu, setsize, mask)) {\n            PyObject *cpu_num = PyLong_FromLong(cpu);\n            --count;\n            if (cpu_num == NULL) {\n                goto error;\n            }\n            if (PySet_Add(res, cpu_num)) {\n                Py_DECREF(cpu_num);\n                goto error;\n            }\n            Py_DECREF(cpu_num);\n        }\n    }\n    CPU_FREE(mask);\n    return res;\n\nerror:\n    if (mask) {\n        CPU_FREE(mask);\n    }\n    Py_XDECREF(res);\n    return NULL;\n}\n#endif /* HAVE_SCHED_SETAFFINITY */\n\n#endif /* HAVE_SCHED_H */\n\n\n#ifdef HAVE_POSIX_OPENPT\n/*[clinic input]\nos.posix_openpt -> int\n\n    oflag: int\n    /\n\nOpen and return a file descriptor for a master pseudo-terminal device.\n\nPerforms a posix_openpt() C function call. The oflag argument is used to\nset file status flags and file access modes as specified in the manual page\nof posix_openpt() of your system.\n[clinic start generated code]*/\n\nstatic int\nos_posix_openpt_impl(PyObject *module, int oflag)\n/*[clinic end generated code: output=ee0bc2624305fc79 input=0de33d0e29693caa]*/\n{\n    int fd;\n\n#if defined(O_CLOEXEC)\n    oflag |= O_CLOEXEC;\n#endif\n\n    fd = posix_openpt(oflag);\n    if (fd == -1) {\n        posix_error();\n        return -1;\n    }\n\n    // Just in case, likely a no-op given O_CLOEXEC above.\n    if (_Py_set_inheritable(fd, 0, NULL) < 0) {\n        close(fd);\n        return -1;\n    }\n\n    return fd;\n}\n#endif /* HAVE_POSIX_OPENPT */\n\n#ifdef HAVE_GRANTPT\n/*[clinic input]\nos.grantpt\n\n    fd: fildes\n        File descriptor of a master pseudo-terminal device.\n    /\n\nGrant access to the slave pseudo-terminal device.\n\nPerforms a grantpt() C function call.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_grantpt_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=dfd580015cf548ab input=0668e3b96760e849]*/\n{\n    int ret;\n    int saved_errno;\n    PyOS_sighandler_t sig_saved;\n\n    sig_saved = PyOS_setsig(SIGCHLD, SIG_DFL);\n\n    ret = grantpt(fd);\n    if (ret == -1)\n        saved_errno = errno;\n\n    PyOS_setsig(SIGCHLD, sig_saved);\n\n    if (ret == -1) {\n        errno = saved_errno;\n        return posix_error();\n    }\n\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_GRANTPT */\n\n#ifdef HAVE_UNLOCKPT\n/*[clinic input]\nos.unlockpt\n\n    fd: fildes\n        File descriptor of a master pseudo-terminal device.\n    /\n\nUnlock a pseudo-terminal master/slave pair.\n\nPerforms an unlockpt() C function call.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_unlockpt_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=e08d354dec12d30c input=de7ab1f59f69a2b4]*/\n{\n    if (unlockpt(fd) == -1)\n        return posix_error();\n\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_UNLOCKPT */\n\n#if defined(HAVE_PTSNAME) || defined(HAVE_PTSNAME_R)\n/*[clinic input]\nos.ptsname\n\n    fd: fildes\n        File descriptor of a master pseudo-terminal device.\n    /\n\nReturn the name of the slave pseudo-terminal device.\n\nIf the ptsname_r() C function is available, it is called;\notherwise, performs a ptsname() C function call.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_ptsname_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=ef300fadc5675872 input=1369ccc0546f3130]*/\n{\n#ifdef HAVE_PTSNAME_R\n    int ret;\n    char name[MAXPATHLEN+1];\n\n    ret = ptsname_r(fd, name, sizeof(name));\n    if (ret != 0) {\n        errno = ret;\n        return posix_error();\n    }\n#else\n    char *name;\n\n    name = ptsname(fd);\n    /* POSIX manpage: Upon failure, ptsname() shall return a null pointer and may set errno.\n       *MAY* set errno? Hmm... */\n    if (name == NULL)\n        return posix_error();\n#endif /* HAVE_PTSNAME_R */\n\n    return PyUnicode_DecodeFSDefault(name);\n}\n#endif /* defined(HAVE_PTSNAME) || defined(HAVE_PTSNAME_R) */\n\n/* AIX uses /dev/ptc but is otherwise the same as /dev/ptmx */\n#if defined(HAVE_DEV_PTC) && !defined(HAVE_DEV_PTMX)\n#  define DEV_PTY_FILE \"/dev/ptc\"\n#  define HAVE_DEV_PTMX\n#else\n#  define DEV_PTY_FILE \"/dev/ptmx\"\n#endif\n\n#if defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY) || defined(HAVE_LOGIN_TTY) || defined(HAVE_DEV_PTMX)\n#ifdef HAVE_PTY_H\n#include <pty.h>\n#ifdef HAVE_UTMP_H\n#include <utmp.h>\n#endif /* HAVE_UTMP_H */\n#elif defined(HAVE_LIBUTIL_H)\n#include <libutil.h>\n#elif defined(HAVE_UTIL_H)\n#include <util.h>\n#endif /* HAVE_PTY_H */\n#ifdef HAVE_STROPTS_H\n#include <stropts.h>\n#endif\n#endif /* defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY) || defined(HAVE_LOGIN_TTY) || defined(HAVE_DEV_PTMX) */\n\n\n#if defined(HAVE_OPENPTY) || defined(HAVE__GETPTY) || defined(HAVE_DEV_PTMX)\n/*[clinic input]\nos.openpty\n\nOpen a pseudo-terminal.\n\nReturn a tuple of (master_fd, slave_fd) containing open file descriptors\nfor both the master and slave ends.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_openpty_impl(PyObject *module)\n/*[clinic end generated code: output=98841ce5ec9cef3c input=f3d99fd99e762907]*/\n{\n    int master_fd = -1, slave_fd = -1;\n#ifndef HAVE_OPENPTY\n    char * slave_name;\n#endif\n#if defined(HAVE_DEV_PTMX) && !defined(HAVE_OPENPTY) && !defined(HAVE__GETPTY)\n    PyOS_sighandler_t sig_saved;\n#if defined(__sun) && defined(__SVR4)\n    extern char *ptsname(int fildes);\n#endif\n#endif\n\n#ifdef HAVE_OPENPTY\n    if (openpty(&master_fd, &slave_fd, NULL, NULL, NULL) != 0)\n        goto posix_error;\n\n    if (_Py_set_inheritable(master_fd, 0, NULL) < 0)\n        goto error;\n    if (_Py_set_inheritable(slave_fd, 0, NULL) < 0)\n        goto error;\n\n#elif defined(HAVE__GETPTY)\n    slave_name = _getpty(&master_fd, O_RDWR, 0666, 0);\n    if (slave_name == NULL)\n        goto posix_error;\n    if (_Py_set_inheritable(master_fd, 0, NULL) < 0)\n        goto error;\n\n    slave_fd = _Py_open(slave_name, O_RDWR);\n    if (slave_fd < 0)\n        goto error;\n\n#else\n    master_fd = open(DEV_PTY_FILE, O_RDWR | O_NOCTTY); /* open master */\n    if (master_fd < 0)\n        goto posix_error;\n\n    sig_saved = PyOS_setsig(SIGCHLD, SIG_DFL);\n\n    /* change permission of slave */\n    if (grantpt(master_fd) < 0) {\n        int saved_errno = errno;\n        PyOS_setsig(SIGCHLD, sig_saved);\n        errno = saved_errno;\n        goto posix_error;\n    }\n\n    /* unlock slave */\n    if (unlockpt(master_fd) < 0) {\n        int saved_errno = errno;\n        PyOS_setsig(SIGCHLD, sig_saved);\n        errno = saved_errno;\n        goto posix_error;\n    }\n\n    PyOS_setsig(SIGCHLD, sig_saved);\n\n    slave_name = ptsname(master_fd); /* get name of slave */\n    if (slave_name == NULL)\n        goto posix_error;\n\n    slave_fd = _Py_open(slave_name, O_RDWR | O_NOCTTY); /* open slave */\n    if (slave_fd == -1)\n        goto error;\n\n    if (_Py_set_inheritable(master_fd, 0, NULL) < 0)\n        goto posix_error;\n\n#if !defined(__CYGWIN__) && !defined(__ANDROID__) && !defined(HAVE_DEV_PTC)\n    ioctl(slave_fd, I_PUSH, \"ptem\"); /* push ptem */\n    ioctl(slave_fd, I_PUSH, \"ldterm\"); /* push ldterm */\n#ifndef __hpux\n    ioctl(slave_fd, I_PUSH, \"ttcompat\"); /* push ttcompat */\n#endif /* __hpux */\n#endif /* HAVE_CYGWIN */\n#endif /* HAVE_OPENPTY */\n\n    return Py_BuildValue(\"(ii)\", master_fd, slave_fd);\n\nposix_error:\n    posix_error();\nerror:\n    if (master_fd != -1)\n        close(master_fd);\n    if (slave_fd != -1)\n        close(slave_fd);\n    return NULL;\n}\n#endif /* defined(HAVE_OPENPTY) || defined(HAVE__GETPTY) || defined(HAVE_DEV_PTMX) */\n\n\n#if defined(HAVE_SETSID) && defined(TIOCSCTTY)\n#define HAVE_FALLBACK_LOGIN_TTY 1\n#endif /* defined(HAVE_SETSID) && defined(TIOCSCTTY) */\n\n#if defined(HAVE_LOGIN_TTY) || defined(HAVE_FALLBACK_LOGIN_TTY)\n/*[clinic input]\nos.login_tty\n\n    fd: fildes\n    /\n\nPrepare the tty of which fd is a file descriptor for a new login session.\n\nMake the calling process a session leader; make the tty the\ncontrolling tty, the stdin, the stdout, and the stderr of the\ncalling process; close fd.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_login_tty_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=495a79911b4cc1bc input=5f298565099903a2]*/\n{\n#ifdef HAVE_LOGIN_TTY\n    if (login_tty(fd) == -1) {\n        return posix_error();\n    }\n#else /* defined(HAVE_FALLBACK_LOGIN_TTY) */\n    /* Establish a new session. */\n    if (setsid() == -1) {\n        return posix_error();\n    }\n\n    /* The tty becomes the controlling terminal. */\n    if (ioctl(fd, TIOCSCTTY, (char *)NULL) == -1) {\n        return posix_error();\n    }\n\n    /* The tty becomes stdin/stdout/stderr */\n    if (dup2(fd, 0) == -1 || dup2(fd, 1) == -1 || dup2(fd, 2) == -1) {\n        return posix_error();\n    }\n    if (fd > 2) {\n        close(fd);\n    }\n#endif /* HAVE_LOGIN_TTY */\n    Py_RETURN_NONE;\n}\n#endif /* defined(HAVE_LOGIN_TTY) || defined(HAVE_FALLBACK_LOGIN_TTY) */\n\n\n#ifdef HAVE_FORKPTY\n/*[clinic input]\nos.forkpty\n\nFork a new process with a new pseudo-terminal as controlling tty.\n\nReturns a tuple of (pid, master_fd).\nLike fork(), return pid of 0 to the child process,\nand pid of child to the parent process.\nTo both, return fd of newly opened pseudo-terminal.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_forkpty_impl(PyObject *module)\n/*[clinic end generated code: output=60d0a5c7512e4087 input=f1f7f4bae3966010]*/\n{\n    int master_fd = -1;\n    pid_t pid;\n\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    if (_PyInterpreterState_GetFinalizing(interp) != NULL) {\n        PyErr_SetString(PyExc_PythonFinalizationError,\n                        \"can't fork at interpreter shutdown\");\n        return NULL;\n    }\n    if (!_Py_IsMainInterpreter(interp)) {\n        PyErr_SetString(PyExc_RuntimeError, \"fork not supported for subinterpreters\");\n        return NULL;\n    }\n    if (PySys_Audit(\"os.forkpty\", NULL) < 0) {\n        return NULL;\n    }\n    PyOS_BeforeFork();\n    pid = forkpty(&master_fd, NULL, NULL, NULL);\n    if (pid == 0) {\n        /* child: this clobbers and resets the import lock. */\n        PyOS_AfterFork_Child();\n    } else {\n        /* parent: release the import lock. */\n        PyOS_AfterFork_Parent();\n        // After PyOS_AfterFork_Parent() starts the world to avoid deadlock.\n        warn_about_fork_with_threads(\"forkpty\");\n    }\n    if (pid == -1) {\n        return posix_error();\n    }\n    return Py_BuildValue(\"(Ni)\", PyLong_FromPid(pid), master_fd);\n}\n#endif /* HAVE_FORKPTY */\n\n\n#ifdef HAVE_GETEGID\n/*[clinic input]\nos.getegid\n\nReturn the current process's effective group id.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getegid_impl(PyObject *module)\n/*[clinic end generated code: output=67d9be7ac68898a2 input=1596f79ad1107d5d]*/\n{\n    return _PyLong_FromGid(getegid());\n}\n#endif /* HAVE_GETEGID */\n\n\n#ifdef HAVE_GETEUID\n/*[clinic input]\nos.geteuid\n\nReturn the current process's effective user id.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_geteuid_impl(PyObject *module)\n/*[clinic end generated code: output=ea1b60f0d6abb66e input=4644c662d3bd9f19]*/\n{\n    return _PyLong_FromUid(geteuid());\n}\n#endif /* HAVE_GETEUID */\n\n\n#ifdef HAVE_GETGID\n/*[clinic input]\nos.getgid\n\nReturn the current process's group id.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getgid_impl(PyObject *module)\n/*[clinic end generated code: output=4f28ebc9d3e5dfcf input=58796344cd87c0f6]*/\n{\n    return _PyLong_FromGid(getgid());\n}\n#endif /* HAVE_GETGID */\n\n\n#if defined(HAVE_GETPID)\n/*[clinic input]\nos.getpid\n\nReturn the current process id.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getpid_impl(PyObject *module)\n/*[clinic end generated code: output=9ea6fdac01ed2b3c input=5a9a00f0ab68aa00]*/\n{\n#if !defined(MS_WINDOWS) || defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_SYSTEM)\n    return PyLong_FromPid(getpid());\n#else\n    return PyLong_FromUnsignedLong(GetCurrentProcessId());\n#endif\n}\n#endif /* defined(HAVE_GETPID) */\n\n#ifdef NGROUPS_MAX\n#define MAX_GROUPS NGROUPS_MAX\n#else\n    /* defined to be 16 on Solaris7, so this should be a small number */\n#define MAX_GROUPS 64\n#endif\n\n#ifdef HAVE_GETGROUPLIST\n\n#ifdef __APPLE__\n/*[clinic input]\nos.getgrouplist\n\n    user: str\n        username to lookup\n    group as basegid: int\n        base group id of the user\n    /\n\nReturns a list of groups to which a user belongs.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getgrouplist_impl(PyObject *module, const char *user, int basegid)\n/*[clinic end generated code: output=6e734697b8c26de0 input=f8d870374b09a490]*/\n#else\n/*[clinic input]\nos.getgrouplist\n\n    user: str\n        username to lookup\n    group as basegid: gid_t\n        base group id of the user\n    /\n\nReturns a list of groups to which a user belongs.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getgrouplist_impl(PyObject *module, const char *user, gid_t basegid)\n/*[clinic end generated code: output=0ebd7fb70115575b input=cc61d5c20b08958d]*/\n#endif\n{\n    int i, ngroups;\n    PyObject *list;\n#ifdef __APPLE__\n    int *groups;\n#else\n    gid_t *groups;\n#endif\n\n    /*\n     * NGROUPS_MAX is defined by POSIX.1 as the maximum\n     * number of supplimental groups a users can belong to.\n     * We have to increment it by one because\n     * getgrouplist() returns both the supplemental groups\n     * and the primary group, i.e. all of the groups the\n     * user belongs to.\n     */\n    ngroups = 1 + MAX_GROUPS;\n\n    while (1) {\n#ifdef __APPLE__\n        groups = PyMem_New(int, ngroups);\n#else\n        groups = PyMem_New(gid_t, ngroups);\n#endif\n        if (groups == NULL) {\n            return PyErr_NoMemory();\n        }\n\n        int old_ngroups = ngroups;\n        if (getgrouplist(user, basegid, groups, &ngroups) != -1) {\n            /* Success */\n            break;\n        }\n\n        /* getgrouplist() fails if the group list is too small */\n        PyMem_Free(groups);\n\n        if (ngroups > old_ngroups) {\n            /* If the group list is too small, the glibc implementation of\n               getgrouplist() sets ngroups to the total number of groups and\n               returns -1. */\n        }\n        else {\n            /* Double the group list size */\n            if (ngroups > INT_MAX / 2) {\n                return PyErr_NoMemory();\n            }\n            ngroups *= 2;\n        }\n\n        /* Retry getgrouplist() with a larger group list */\n    }\n\n#ifdef _Py_MEMORY_SANITIZER\n    /* Clang memory sanitizer libc intercepts don't know getgrouplist. */\n    __msan_unpoison(&ngroups, sizeof(ngroups));\n    __msan_unpoison(groups, ngroups*sizeof(*groups));\n#endif\n\n    list = PyList_New(ngroups);\n    if (list == NULL) {\n        PyMem_Free(groups);\n        return NULL;\n    }\n\n    for (i = 0; i < ngroups; i++) {\n#ifdef __APPLE__\n        PyObject *o = PyLong_FromUnsignedLong((unsigned long)groups[i]);\n#else\n        PyObject *o = _PyLong_FromGid(groups[i]);\n#endif\n        if (o == NULL) {\n            Py_DECREF(list);\n            PyMem_Free(groups);\n            return NULL;\n        }\n        PyList_SET_ITEM(list, i, o);\n    }\n\n    PyMem_Free(groups);\n\n    return list;\n}\n#endif /* HAVE_GETGROUPLIST */\n\n\n#ifdef HAVE_GETGROUPS\n/*[clinic input]\nos.getgroups\n\nReturn list of supplemental group IDs for the process.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getgroups_impl(PyObject *module)\n/*[clinic end generated code: output=42b0c17758561b56 input=d3f109412e6a155c]*/\n{\n    // Call getgroups with length 0 to get the actual number of groups\n    int n = getgroups(0, NULL);\n    if (n < 0) {\n        return posix_error();\n    }\n\n    if (n == 0) {\n        return PyList_New(0);\n    }\n\n    gid_t *grouplist = PyMem_New(gid_t, n);\n    if (grouplist == NULL) {\n        return PyErr_NoMemory();\n    }\n\n    n = getgroups(n, grouplist);\n    if (n == -1) {\n        posix_error();\n        PyMem_Free(grouplist);\n        return NULL;\n    }\n\n    PyObject *result = PyList_New(n);\n    if (result == NULL) {\n        goto error;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        PyObject *group = _PyLong_FromGid(grouplist[i]);\n        if (group == NULL) {\n            goto error;\n        }\n        PyList_SET_ITEM(result, i, group);\n    }\n    PyMem_Free(grouplist);\n\n    return result;\n\nerror:\n    PyMem_Free(grouplist);\n    Py_XDECREF(result);\n    return NULL;\n}\n#endif /* HAVE_GETGROUPS */\n\n#ifdef HAVE_INITGROUPS\n#ifdef __APPLE__\n/*[clinic input]\nos.initgroups\n\n    username as oname: FSConverter\n    gid: int\n    /\n\nInitialize the group access list.\n\nCall the system initgroups() to initialize the group access list with all of\nthe groups of which the specified username is a member, plus the specified\ngroup id.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_initgroups_impl(PyObject *module, PyObject *oname, int gid)\n/*[clinic end generated code: output=7f074d30a425fd3a input=df3d54331b0af204]*/\n#else\n/*[clinic input]\nos.initgroups\n\n    username as oname: FSConverter\n    gid: gid_t\n    /\n\nInitialize the group access list.\n\nCall the system initgroups() to initialize the group access list with all of\nthe groups of which the specified username is a member, plus the specified\ngroup id.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_initgroups_impl(PyObject *module, PyObject *oname, gid_t gid)\n/*[clinic end generated code: output=59341244521a9e3f input=0cb91bdc59a4c564]*/\n#endif\n{\n    const char *username = PyBytes_AS_STRING(oname);\n\n    if (initgroups(username, gid) == -1)\n        return PyErr_SetFromErrno(PyExc_OSError);\n\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_INITGROUPS */\n\n\n#ifdef HAVE_GETPGID\n/*[clinic input]\nos.getpgid\n\n    pid: pid_t\n\nCall the system call getpgid(), and return the result.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getpgid_impl(PyObject *module, pid_t pid)\n/*[clinic end generated code: output=1db95a97be205d18 input=39d710ae3baaf1c7]*/\n{\n    pid_t pgid = getpgid(pid);\n    if (pgid < 0)\n        return posix_error();\n    return PyLong_FromPid(pgid);\n}\n#endif /* HAVE_GETPGID */\n\n\n#ifdef HAVE_GETPGRP\n/*[clinic input]\nos.getpgrp\n\nReturn the current process group id.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getpgrp_impl(PyObject *module)\n/*[clinic end generated code: output=c4fc381e51103cf3 input=6846fb2bb9a3705e]*/\n{\n#ifdef GETPGRP_HAVE_ARG\n    return PyLong_FromPid(getpgrp(0));\n#else /* GETPGRP_HAVE_ARG */\n    return PyLong_FromPid(getpgrp());\n#endif /* GETPGRP_HAVE_ARG */\n}\n#endif /* HAVE_GETPGRP */\n\n\n#ifdef HAVE_SETPGRP\n/*[clinic input]\nos.setpgrp\n\nMake the current process the leader of its process group.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setpgrp_impl(PyObject *module)\n/*[clinic end generated code: output=2554735b0a60f0a0 input=1f0619fcb5731e7e]*/\n{\n#ifdef SETPGRP_HAVE_ARG\n    if (setpgrp(0, 0) < 0)\n#else /* SETPGRP_HAVE_ARG */\n    if (setpgrp() < 0)\n#endif /* SETPGRP_HAVE_ARG */\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SETPGRP */\n\n#ifdef HAVE_GETPPID\n\n#ifdef MS_WINDOWS\n#include <winternl.h>\n#include <ProcessSnapshot.h>\n\n// The structure definition in winternl.h may be incomplete.\n// This structure is the full version from the MSDN documentation.\ntypedef struct _PROCESS_BASIC_INFORMATION_FULL {\n    NTSTATUS ExitStatus;\n    PVOID PebBaseAddress;\n    ULONG_PTR AffinityMask;\n    LONG BasePriority;\n    ULONG_PTR UniqueProcessId;\n    ULONG_PTR InheritedFromUniqueProcessId;\n} PROCESS_BASIC_INFORMATION_FULL;\n\ntypedef NTSTATUS (NTAPI *PNT_QUERY_INFORMATION_PROCESS) (\n    IN    HANDLE           ProcessHandle,\n    IN    PROCESSINFOCLASS ProcessInformationClass,\n    OUT   PVOID            ProcessInformation,\n    IN    ULONG            ProcessInformationLength,\n    OUT   PULONG           ReturnLength OPTIONAL);\n\n// This function returns the process ID of the parent process.\n// Returns 0 on failure.\nstatic ULONG\nwin32_getppid_fast(void)\n{\n    NTSTATUS status;\n    HMODULE ntdll;\n    PNT_QUERY_INFORMATION_PROCESS pNtQueryInformationProcess;\n    PROCESS_BASIC_INFORMATION_FULL basic_information;\n    static ULONG cached_ppid = 0;\n\n    if (cached_ppid) {\n        // No need to query the kernel again.\n        return cached_ppid;\n    }\n\n    ntdll = GetModuleHandleW(L\"ntdll.dll\");\n    if (!ntdll) {\n        return 0;\n    }\n\n    pNtQueryInformationProcess = (PNT_QUERY_INFORMATION_PROCESS) GetProcAddress(ntdll, \"NtQueryInformationProcess\");\n    if (!pNtQueryInformationProcess) {\n        return 0;\n    }\n\n    status = pNtQueryInformationProcess(GetCurrentProcess(),\n                                        ProcessBasicInformation,\n                                        &basic_information,\n                                        sizeof(basic_information),\n                                        NULL);\n\n    if (!NT_SUCCESS(status)) {\n        return 0;\n    }\n\n    // Perform sanity check on the parent process ID we received from NtQueryInformationProcess.\n    // The check covers values which exceed the 32-bit range (if running on x64) as well as\n    // zero and (ULONG) -1.\n\n    if (basic_information.InheritedFromUniqueProcessId == 0 ||\n        basic_information.InheritedFromUniqueProcessId >= ULONG_MAX)\n    {\n        return 0;\n    }\n\n    // Now that we have reached this point, the BasicInformation.InheritedFromUniqueProcessId\n    // structure member contains a ULONG_PTR which represents the process ID of our parent\n    // process. This process ID will be correctly returned even if the parent process has\n    // exited or been terminated.\n\n    cached_ppid = (ULONG) basic_information.InheritedFromUniqueProcessId;\n    return cached_ppid;\n}\n\nstatic PyObject*\nwin32_getppid(void)\n{\n    DWORD error;\n    PyObject* result = NULL;\n    HANDLE process = GetCurrentProcess();\n    HPSS snapshot = NULL;\n    ULONG pid;\n\n    pid = win32_getppid_fast();\n    if (pid != 0) {\n        return PyLong_FromUnsignedLong(pid);\n    }\n\n    // If failure occurs in win32_getppid_fast(), fall back to using the PSS API.\n\n    error = PssCaptureSnapshot(process, PSS_CAPTURE_NONE, 0, &snapshot);\n    if (error != ERROR_SUCCESS) {\n        return PyErr_SetFromWindowsErr(error);\n    }\n\n    PSS_PROCESS_INFORMATION info;\n    error = PssQuerySnapshot(snapshot, PSS_QUERY_PROCESS_INFORMATION, &info,\n                             sizeof(info));\n    if (error == ERROR_SUCCESS) {\n        result = PyLong_FromUnsignedLong(info.ParentProcessId);\n    }\n    else {\n        result = PyErr_SetFromWindowsErr(error);\n    }\n\n    PssFreeSnapshot(process, snapshot);\n    return result;\n}\n#endif /*MS_WINDOWS*/\n\n\n/*[clinic input]\nos.getppid\n\nReturn the parent's process id.\n\nIf the parent process has already exited, Windows machines will still\nreturn its id; others systems will return the id of the 'init' process (1).\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getppid_impl(PyObject *module)\n/*[clinic end generated code: output=43b2a946a8c603b4 input=e637cb87539c030e]*/\n{\n#ifdef MS_WINDOWS\n    return win32_getppid();\n#else\n    return PyLong_FromPid(getppid());\n#endif\n}\n#endif /* HAVE_GETPPID */\n\n\n#ifdef HAVE_GETLOGIN\n/*[clinic input]\nos.getlogin\n\nReturn the actual login name.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getlogin_impl(PyObject *module)\n/*[clinic end generated code: output=a32e66a7e5715dac input=2a21ab1e917163df]*/\n{\n    PyObject *result = NULL;\n#ifdef MS_WINDOWS\n    wchar_t user_name[UNLEN + 1];\n    DWORD num_chars = Py_ARRAY_LENGTH(user_name);\n\n    if (GetUserNameW(user_name, &num_chars)) {\n        /* num_chars is the number of unicode chars plus null terminator */\n        result = PyUnicode_FromWideChar(user_name, num_chars - 1);\n    }\n    else\n        result = PyErr_SetFromWindowsErr(GetLastError());\n#else\n    char *name;\n    int old_errno = errno;\n\n    errno = 0;\n    name = getlogin();\n    if (name == NULL) {\n        if (errno)\n            posix_error();\n        else\n            PyErr_SetString(PyExc_OSError, \"unable to determine login name\");\n    }\n    else\n        result = PyUnicode_DecodeFSDefault(name);\n    errno = old_errno;\n#endif\n    return result;\n}\n#endif /* HAVE_GETLOGIN */\n\n\n#ifdef HAVE_GETUID\n/*[clinic input]\nos.getuid\n\nReturn the current process's user id.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getuid_impl(PyObject *module)\n/*[clinic end generated code: output=415c0b401ebed11a input=b53c8b35f110a516]*/\n{\n    return _PyLong_FromUid(getuid());\n}\n#endif /* HAVE_GETUID */\n\n\n#ifdef MS_WINDOWS\n#define HAVE_KILL\n#endif /* MS_WINDOWS */\n\n#ifdef HAVE_KILL\n/*[clinic input]\nos.kill\n\n    pid: pid_t\n    signal: Py_ssize_t\n    /\n\nKill a process with a signal.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_kill_impl(PyObject *module, pid_t pid, Py_ssize_t signal)\n/*[clinic end generated code: output=8e346a6701c88568 input=61a36b86ca275ab9]*/\n{\n    if (PySys_Audit(\"os.kill\", \"in\", pid, signal) < 0) {\n        return NULL;\n    }\n#ifndef MS_WINDOWS\n    if (kill(pid, (int)signal) == -1) {\n        return posix_error();\n    }\n\n    // Check immediately if the signal was sent to the current process.\n    // Don't micro-optimize pid == getpid(), since PyErr_SetString() check\n    // is cheap.\n    if (PyErr_CheckSignals()) {\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n#else /* !MS_WINDOWS */\n    PyObject *result;\n    DWORD sig = (DWORD)signal;\n    DWORD err;\n    HANDLE handle;\n\n#ifdef HAVE_WINDOWS_CONSOLE_IO\n    /* Console processes which share a common console can be sent CTRL+C or\n       CTRL+BREAK events, provided they handle said events. */\n    if (sig == CTRL_C_EVENT || sig == CTRL_BREAK_EVENT) {\n        if (GenerateConsoleCtrlEvent(sig, (DWORD)pid) == 0) {\n            err = GetLastError();\n            PyErr_SetFromWindowsErr(err);\n        }\n        else {\n            Py_RETURN_NONE;\n        }\n    }\n#endif /* HAVE_WINDOWS_CONSOLE_IO */\n\n    /* If the signal is outside of what GenerateConsoleCtrlEvent can use,\n       attempt to open and terminate the process. */\n    handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)pid);\n    if (handle == NULL) {\n        err = GetLastError();\n        return PyErr_SetFromWindowsErr(err);\n    }\n\n    if (TerminateProcess(handle, sig) == 0) {\n        err = GetLastError();\n        result = PyErr_SetFromWindowsErr(err);\n    } else {\n        result = Py_NewRef(Py_None);\n    }\n\n    CloseHandle(handle);\n    return result;\n#endif /* !MS_WINDOWS */\n}\n#endif /* HAVE_KILL */\n\n\n#ifdef HAVE_KILLPG\n/*[clinic input]\nos.killpg\n\n    pgid: pid_t\n    signal: int\n    /\n\nKill a process group with a signal.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_killpg_impl(PyObject *module, pid_t pgid, int signal)\n/*[clinic end generated code: output=6dbcd2f1fdf5fdba input=38b5449eb8faec19]*/\n{\n    if (PySys_Audit(\"os.killpg\", \"ii\", pgid, signal) < 0) {\n        return NULL;\n    }\n    /* XXX some man pages make the `pgid` parameter an int, others\n       a pid_t. Since getpgrp() returns a pid_t, we assume killpg should\n       take the same type. Moreover, pid_t is always at least as wide as\n       int (else compilation of this module fails), which is safe. */\n    if (killpg(pgid, signal) == -1)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_KILLPG */\n\n\n#ifdef HAVE_PLOCK\n#ifdef HAVE_SYS_LOCK_H\n#include <sys/lock.h>\n#endif\n\n/*[clinic input]\nos.plock\n    op: int\n    /\n\nLock program segments into memory.\");\n[clinic start generated code]*/\n\nstatic PyObject *\nos_plock_impl(PyObject *module, int op)\n/*[clinic end generated code: output=81424167033b168e input=e6e5e348e1525f60]*/\n{\n    if (plock(op) == -1)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_PLOCK */\n\n\n#ifdef HAVE_SETUID\n/*[clinic input]\nos.setuid\n\n    uid: uid_t\n    /\n\nSet the current process's user id.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setuid_impl(PyObject *module, uid_t uid)\n/*[clinic end generated code: output=a0a41fd0d1ec555f input=c921a3285aa22256]*/\n{\n    if (setuid(uid) < 0)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SETUID */\n\n\n#ifdef HAVE_SETEUID\n/*[clinic input]\nos.seteuid\n\n    euid: uid_t\n    /\n\nSet the current process's effective user id.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_seteuid_impl(PyObject *module, uid_t euid)\n/*[clinic end generated code: output=102e3ad98361519a input=ba93d927e4781aa9]*/\n{\n    if (seteuid(euid) < 0)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SETEUID */\n\n\n#ifdef HAVE_SETEGID\n/*[clinic input]\nos.setegid\n\n    egid: gid_t\n    /\n\nSet the current process's effective group id.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setegid_impl(PyObject *module, gid_t egid)\n/*[clinic end generated code: output=4e4b825a6a10258d input=4080526d0ccd6ce3]*/\n{\n    if (setegid(egid) < 0)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SETEGID */\n\n\n#ifdef HAVE_SETREUID\n/*[clinic input]\nos.setreuid\n\n    ruid: uid_t\n    euid: uid_t\n    /\n\nSet the current process's real and effective user ids.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setreuid_impl(PyObject *module, uid_t ruid, uid_t euid)\n/*[clinic end generated code: output=62d991210006530a input=0ca8978de663880c]*/\n{\n    if (setreuid(ruid, euid) < 0) {\n        return posix_error();\n    } else {\n        Py_RETURN_NONE;\n    }\n}\n#endif /* HAVE_SETREUID */\n\n\n#ifdef HAVE_SETREGID\n/*[clinic input]\nos.setregid\n\n    rgid: gid_t\n    egid: gid_t\n    /\n\nSet the current process's real and effective group ids.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setregid_impl(PyObject *module, gid_t rgid, gid_t egid)\n/*[clinic end generated code: output=aa803835cf5342f3 input=c59499f72846db78]*/\n{\n    if (setregid(rgid, egid) < 0)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SETREGID */\n\n\n#ifdef HAVE_SETGID\n/*[clinic input]\nos.setgid\n    gid: gid_t\n    /\n\nSet the current process's group id.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setgid_impl(PyObject *module, gid_t gid)\n/*[clinic end generated code: output=bdccd7403f6ad8c3 input=27d30c4059045dc6]*/\n{\n    if (setgid(gid) < 0)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SETGID */\n\n\n#ifdef HAVE_SETGROUPS\n/*[clinic input]\nos.setgroups\n\n    groups: object\n    /\n\nSet the groups of the current process to list.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setgroups(PyObject *module, PyObject *groups)\n/*[clinic end generated code: output=3fcb32aad58c5ecd input=fa742ca3daf85a7e]*/\n{\n    if (!PySequence_Check(groups)) {\n        PyErr_SetString(PyExc_TypeError, \"setgroups argument must be a sequence\");\n        return NULL;\n    }\n    Py_ssize_t len = PySequence_Size(groups);\n    if (len < 0) {\n        return NULL;\n    }\n    if (len > MAX_GROUPS) {\n        PyErr_SetString(PyExc_ValueError, \"too many groups\");\n        return NULL;\n    }\n\n    gid_t *grouplist = PyMem_New(gid_t, len);\n    if (grouplist == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    for (Py_ssize_t i = 0; i < len; i++) {\n        PyObject *elem;\n        elem = PySequence_GetItem(groups, i);\n        if (!elem) {\n            PyMem_Free(grouplist);\n            return NULL;\n        }\n        if (!PyLong_Check(elem)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"groups must be integers\");\n            Py_DECREF(elem);\n            PyMem_Free(grouplist);\n            return NULL;\n        } else {\n            if (!_Py_Gid_Converter(elem, &grouplist[i])) {\n                Py_DECREF(elem);\n                PyMem_Free(grouplist);\n                return NULL;\n            }\n        }\n        Py_DECREF(elem);\n    }\n\n    if (setgroups(len, grouplist) < 0) {\n        posix_error();\n        PyMem_Free(grouplist);\n        return NULL;\n    }\n    PyMem_Free(grouplist);\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SETGROUPS */\n\n#if defined(HAVE_WAIT3) || defined(HAVE_WAIT4)\nstatic PyObject *\nwait_helper(PyObject *module, pid_t pid, int status, struct rusage *ru)\n{\n    PyObject *result;\n    PyObject *struct_rusage;\n\n    if (pid == -1)\n        return posix_error();\n\n    // If wait succeeded but no child was ready to report status, ru will not\n    // have been populated.\n    if (pid == 0) {\n        memset(ru, 0, sizeof(*ru));\n    }\n\n    struct_rusage = _PyImport_GetModuleAttrString(\"resource\", \"struct_rusage\");\n    if (struct_rusage == NULL)\n        return NULL;\n\n    /* XXX(nnorwitz): Copied (w/mods) from resource.c, there should be only one. */\n    result = PyStructSequence_New((PyTypeObject*) struct_rusage);\n    Py_DECREF(struct_rusage);\n    if (!result)\n        return NULL;\n\n    int pos = 0;\n\n#ifndef doubletime\n#define doubletime(TV) ((double)(TV).tv_sec + (TV).tv_usec * 0.000001)\n#endif\n\n#define SET_RESULT(CALL)                                     \\\n    do {                                                     \\\n        PyObject *item = (CALL);                             \\\n        if (item == NULL) {                                  \\\n            Py_DECREF(result);                               \\\n            return NULL;                                     \\\n        }                                                    \\\n        PyStructSequence_SET_ITEM(result, pos++, item);      \\\n    } while(0)\n\n    SET_RESULT(PyFloat_FromDouble(doubletime(ru->ru_utime)));\n    SET_RESULT(PyFloat_FromDouble(doubletime(ru->ru_stime)));\n    SET_RESULT(PyLong_FromLong(ru->ru_maxrss));\n    SET_RESULT(PyLong_FromLong(ru->ru_ixrss));\n    SET_RESULT(PyLong_FromLong(ru->ru_idrss));\n    SET_RESULT(PyLong_FromLong(ru->ru_isrss));\n    SET_RESULT(PyLong_FromLong(ru->ru_minflt));\n    SET_RESULT(PyLong_FromLong(ru->ru_majflt));\n    SET_RESULT(PyLong_FromLong(ru->ru_nswap));\n    SET_RESULT(PyLong_FromLong(ru->ru_inblock));\n    SET_RESULT(PyLong_FromLong(ru->ru_oublock));\n    SET_RESULT(PyLong_FromLong(ru->ru_msgsnd));\n    SET_RESULT(PyLong_FromLong(ru->ru_msgrcv));\n    SET_RESULT(PyLong_FromLong(ru->ru_nsignals));\n    SET_RESULT(PyLong_FromLong(ru->ru_nvcsw));\n    SET_RESULT(PyLong_FromLong(ru->ru_nivcsw));\n#undef SET_RESULT\n\n    return Py_BuildValue(\"NiN\", PyLong_FromPid(pid), status, result);\n}\n#endif /* HAVE_WAIT3 || HAVE_WAIT4 */\n\n\n#ifdef HAVE_WAIT3\n/*[clinic input]\nos.wait3\n\n    options: int\nWait for completion of a child process.\n\nReturns a tuple of information about the child process:\n  (pid, status, rusage)\n[clinic start generated code]*/\n\nstatic PyObject *\nos_wait3_impl(PyObject *module, int options)\n/*[clinic end generated code: output=92c3224e6f28217a input=8ac4c56956b61710]*/\n{\n    pid_t pid;\n    struct rusage ru;\n    int async_err = 0;\n    WAIT_TYPE status;\n    WAIT_STATUS_INT(status) = 0;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        pid = wait3(&status, options, &ru);\n        Py_END_ALLOW_THREADS\n    } while (pid < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    if (pid < 0)\n        return (!async_err) ? posix_error() : NULL;\n\n    return wait_helper(module, pid, WAIT_STATUS_INT(status), &ru);\n}\n#endif /* HAVE_WAIT3 */\n\n\n#ifdef HAVE_WAIT4\n/*[clinic input]\n\nos.wait4\n\n    pid: pid_t\n    options: int\n\nWait for completion of a specific child process.\n\nReturns a tuple of information about the child process:\n  (pid, status, rusage)\n[clinic start generated code]*/\n\nstatic PyObject *\nos_wait4_impl(PyObject *module, pid_t pid, int options)\n/*[clinic end generated code: output=66195aa507b35f70 input=d11deed0750600ba]*/\n{\n    pid_t res;\n    struct rusage ru;\n    int async_err = 0;\n    WAIT_TYPE status;\n    WAIT_STATUS_INT(status) = 0;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        res = wait4(pid, &status, options, &ru);\n        Py_END_ALLOW_THREADS\n    } while (res < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    if (res < 0)\n        return (!async_err) ? posix_error() : NULL;\n\n    return wait_helper(module, res, WAIT_STATUS_INT(status), &ru);\n}\n#endif /* HAVE_WAIT4 */\n\n\n#if defined(HAVE_WAITID)\n/*[clinic input]\nos.waitid\n\n    idtype: idtype_t\n        Must be one of be P_PID, P_PGID or P_ALL.\n    id: id_t\n        The id to wait on.\n    options: int\n        Constructed from the ORing of one or more of WEXITED, WSTOPPED\n        or WCONTINUED and additionally may be ORed with WNOHANG or WNOWAIT.\n    /\n\nReturns the result of waiting for a process or processes.\n\nReturns either waitid_result or None if WNOHANG is specified and there are\nno children in a waitable state.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_waitid_impl(PyObject *module, idtype_t idtype, id_t id, int options)\n/*[clinic end generated code: output=5d2e1c0bde61f4d8 input=d8e7f76e052b7920]*/\n{\n    PyObject *result;\n    int res;\n    int async_err = 0;\n    siginfo_t si;\n    si.si_pid = 0;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        res = waitid(idtype, id, &si, options);\n        Py_END_ALLOW_THREADS\n    } while (res < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    if (res < 0)\n        return (!async_err) ? posix_error() : NULL;\n\n    if (si.si_pid == 0)\n        Py_RETURN_NONE;\n\n    PyObject *WaitidResultType = get_posix_state(module)->WaitidResultType;\n    result = PyStructSequence_New((PyTypeObject *)WaitidResultType);\n    if (!result)\n        return NULL;\n\n    int pos = 0;\n\n#define SET_RESULT(CALL)                                     \\\n    do {                                                     \\\n        PyObject *item = (CALL);                             \\\n        if (item == NULL) {                                  \\\n            Py_DECREF(result);                               \\\n            return NULL;                                     \\\n        }                                                    \\\n        PyStructSequence_SET_ITEM(result, pos++, item);      \\\n    } while(0)\n\n    SET_RESULT(PyLong_FromPid(si.si_pid));\n    SET_RESULT(_PyLong_FromUid(si.si_uid));\n    SET_RESULT(PyLong_FromLong((long)(si.si_signo)));\n    SET_RESULT(PyLong_FromLong((long)(si.si_status)));\n    SET_RESULT(PyLong_FromLong((long)(si.si_code)));\n\n#undef SET_RESULT\n\n    return result;\n}\n#endif /* defined(HAVE_WAITID) */\n\n\n#if defined(HAVE_WAITPID)\n/*[clinic input]\nos.waitpid\n    pid: pid_t\n    options: int\n    /\n\nWait for completion of a given child process.\n\nReturns a tuple of information regarding the child process:\n    (pid, status)\n\nThe options argument is ignored on Windows.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_waitpid_impl(PyObject *module, pid_t pid, int options)\n/*[clinic end generated code: output=5c37c06887a20270 input=0bf1666b8758fda3]*/\n{\n    pid_t res;\n    int async_err = 0;\n    WAIT_TYPE status;\n    WAIT_STATUS_INT(status) = 0;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        res = waitpid(pid, &status, options);\n        Py_END_ALLOW_THREADS\n    } while (res < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    if (res < 0)\n        return (!async_err) ? posix_error() : NULL;\n\n    return Py_BuildValue(\"Ni\", PyLong_FromPid(res), WAIT_STATUS_INT(status));\n}\n#elif defined(HAVE_CWAIT)\n/* MS C has a variant of waitpid() that's usable for most purposes. */\n/*[clinic input]\nos.waitpid\n    pid: intptr_t\n    options: int\n    /\n\nWait for completion of a given process.\n\nReturns a tuple of information regarding the process:\n    (pid, status << 8)\n\nThe options argument is ignored on Windows.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_waitpid_impl(PyObject *module, intptr_t pid, int options)\n/*[clinic end generated code: output=be836b221271d538 input=40f2440c515410f8]*/\n{\n    int status;\n    intptr_t res;\n    int async_err = 0;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        _Py_BEGIN_SUPPRESS_IPH\n        res = _cwait(&status, pid, options);\n        _Py_END_SUPPRESS_IPH\n        Py_END_ALLOW_THREADS\n    } while (res < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    if (res < 0)\n        return (!async_err) ? posix_error() : NULL;\n\n    unsigned long long ustatus = (unsigned int)status;\n\n    /* shift the status left a byte so this is more like the POSIX waitpid */\n    return Py_BuildValue(_Py_PARSE_INTPTR \"K\", res, ustatus << 8);\n}\n#endif\n\n\n#ifdef HAVE_WAIT\n/*[clinic input]\nos.wait\n\nWait for completion of a child process.\n\nReturns a tuple of information about the child process:\n    (pid, status)\n[clinic start generated code]*/\n\nstatic PyObject *\nos_wait_impl(PyObject *module)\n/*[clinic end generated code: output=6bc419ac32fb364b input=03b0182d4a4700ce]*/\n{\n    pid_t pid;\n    int async_err = 0;\n    WAIT_TYPE status;\n    WAIT_STATUS_INT(status) = 0;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        pid = wait(&status);\n        Py_END_ALLOW_THREADS\n    } while (pid < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    if (pid < 0)\n        return (!async_err) ? posix_error() : NULL;\n\n    return Py_BuildValue(\"Ni\", PyLong_FromPid(pid), WAIT_STATUS_INT(status));\n}\n#endif /* HAVE_WAIT */\n\n#if defined(__linux__) && defined(__NR_pidfd_open)\n/*[clinic input]\nos.pidfd_open\n  pid: pid_t\n  flags: unsigned_int = 0\n\nReturn a file descriptor referring to the process *pid*.\n\nThe descriptor can be used to perform process management without races and\nsignals.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_pidfd_open_impl(PyObject *module, pid_t pid, unsigned int flags)\n/*[clinic end generated code: output=5c7252698947dc41 input=c3fd99ce947ccfef]*/\n{\n    int fd = syscall(__NR_pidfd_open, pid, flags);\n    if (fd < 0) {\n        return posix_error();\n    }\n    return PyLong_FromLong(fd);\n}\n#endif\n\n\n#ifdef HAVE_SETNS\n/*[clinic input]\nos.setns\n  fd: fildes\n    A file descriptor to a namespace.\n  nstype: int = 0\n    Type of namespace.\n\nMove the calling thread into different namespaces.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setns_impl(PyObject *module, int fd, int nstype)\n/*[clinic end generated code: output=5dbd055bfb66ecd0 input=42787871226bf3ee]*/\n{\n    int res;\n\n    Py_BEGIN_ALLOW_THREADS\n    res = setns(fd, nstype);\n    Py_END_ALLOW_THREADS\n\n    if (res != 0) {\n        return posix_error();\n    }\n\n    Py_RETURN_NONE;\n}\n#endif\n\n\n#ifdef HAVE_UNSHARE\n/*[clinic input]\nos.unshare\n  flags: int\n    Namespaces to be unshared.\n\nDisassociate parts of a process (or thread) execution context.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_unshare_impl(PyObject *module, int flags)\n/*[clinic end generated code: output=1b3177906dd237ee input=9e065db3232b8b1b]*/\n{\n    int res;\n\n    Py_BEGIN_ALLOW_THREADS\n    res = unshare(flags);\n    Py_END_ALLOW_THREADS\n\n    if (res != 0) {\n        return posix_error();\n    }\n\n    Py_RETURN_NONE;\n}\n#endif\n\n\n#if defined(HAVE_READLINK) || defined(MS_WINDOWS)\n/*[clinic input]\nos.readlink\n\n    path: path_t\n    *\n    dir_fd: dir_fd(requires='readlinkat') = None\n\nReturn a string representing the path to which the symbolic link points.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\nand path should be relative; path will then be relative to that directory.\n\ndir_fd may not be implemented on your platform.  If it is unavailable,\nusing it will raise a NotImplementedError.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_readlink_impl(PyObject *module, path_t *path, int dir_fd)\n/*[clinic end generated code: output=d21b732a2e814030 input=113c87e0db1ecaf2]*/\n{\n#if defined(HAVE_READLINK)\n    char buffer[MAXPATHLEN+1];\n    ssize_t length;\n#ifdef HAVE_READLINKAT\n    int readlinkat_unavailable = 0;\n#endif\n\n    Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_READLINKAT\n    if (dir_fd != DEFAULT_DIR_FD) {\n        if (HAVE_READLINKAT_RUNTIME) {\n            length = readlinkat(dir_fd, path->narrow, buffer, MAXPATHLEN);\n        } else {\n            readlinkat_unavailable = 1;\n        }\n    } else\n#endif\n        length = readlink(path->narrow, buffer, MAXPATHLEN);\n    Py_END_ALLOW_THREADS\n\n#ifdef HAVE_READLINKAT\n    if (readlinkat_unavailable) {\n        argument_unavailable_error(NULL, \"dir_fd\");\n        return NULL;\n    }\n#endif\n\n    if (length < 0) {\n        return path_error(path);\n    }\n    buffer[length] = '\\0';\n\n    if (PyUnicode_Check(path->object))\n        return PyUnicode_DecodeFSDefaultAndSize(buffer, length);\n    else\n        return PyBytes_FromStringAndSize(buffer, length);\n#elif defined(MS_WINDOWS)\n    DWORD n_bytes_returned;\n    DWORD io_result = 0;\n    HANDLE reparse_point_handle;\n    char target_buffer[_Py_MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n    _Py_REPARSE_DATA_BUFFER *rdb = (_Py_REPARSE_DATA_BUFFER *)target_buffer;\n    PyObject *result = NULL;\n\n    /* First get a handle to the reparse point */\n    Py_BEGIN_ALLOW_THREADS\n    reparse_point_handle = CreateFileW(\n        path->wide,\n        0,\n        0,\n        0,\n        OPEN_EXISTING,\n        FILE_FLAG_OPEN_REPARSE_POINT|FILE_FLAG_BACKUP_SEMANTICS,\n        0);\n    if (reparse_point_handle != INVALID_HANDLE_VALUE) {\n        /* New call DeviceIoControl to read the reparse point */\n        io_result = DeviceIoControl(\n            reparse_point_handle,\n            FSCTL_GET_REPARSE_POINT,\n            0, 0, /* in buffer */\n            target_buffer, sizeof(target_buffer),\n            &n_bytes_returned,\n            0 /* we're not using OVERLAPPED_IO */\n            );\n        CloseHandle(reparse_point_handle);\n    }\n    Py_END_ALLOW_THREADS\n\n    if (io_result == 0) {\n        return path_error(path);\n    }\n\n    wchar_t *name = NULL;\n    Py_ssize_t nameLen = 0;\n    if (rdb->ReparseTag == IO_REPARSE_TAG_SYMLINK)\n    {\n        name = (wchar_t *)((char*)rdb->SymbolicLinkReparseBuffer.PathBuffer +\n                           rdb->SymbolicLinkReparseBuffer.SubstituteNameOffset);\n        nameLen = rdb->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof(wchar_t);\n    }\n    else if (rdb->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)\n    {\n        name = (wchar_t *)((char*)rdb->MountPointReparseBuffer.PathBuffer +\n                           rdb->MountPointReparseBuffer.SubstituteNameOffset);\n        nameLen = rdb->MountPointReparseBuffer.SubstituteNameLength / sizeof(wchar_t);\n    }\n    else\n    {\n        PyErr_SetString(PyExc_ValueError, \"not a symbolic link\");\n    }\n    if (name) {\n        if (nameLen > 4 && wcsncmp(name, L\"\\\\??\\\\\", 4) == 0) {\n            /* Our buffer is mutable, so this is okay */\n            name[1] = L'\\\\';\n        }\n        result = PyUnicode_FromWideChar(name, nameLen);\n        if (result && PyBytes_Check(path->object)) {\n            Py_SETREF(result, PyUnicode_EncodeFSDefault(result));\n        }\n    }\n    return result;\n#endif\n}\n#endif /* defined(HAVE_READLINK) || defined(MS_WINDOWS) */\n\n#if defined(MS_WINDOWS)\n\n/* Remove the last portion of the path - return 0 on success */\nstatic int\n_dirnameW(WCHAR *path)\n{\n    WCHAR *ptr;\n    size_t length = wcsnlen_s(path, MAX_PATH);\n    if (length == MAX_PATH) {\n        return -1;\n    }\n\n    /* walk the path from the end until a backslash is encountered */\n    for(ptr = path + length; ptr != path; ptr--) {\n        if (*ptr == L'\\\\' || *ptr == L'/') {\n            break;\n        }\n    }\n    *ptr = 0;\n    return 0;\n}\n\n#endif\n\n#ifdef HAVE_SYMLINK\n\n#if defined(MS_WINDOWS)\n\n/* Is this path absolute? */\nstatic int\n_is_absW(const WCHAR *path)\n{\n    return path[0] == L'\\\\' || path[0] == L'/' ||\n        (path[0] && path[1] == L':');\n}\n\n/* join root and rest with a backslash - return 0 on success */\nstatic int\n_joinW(WCHAR *dest_path, const WCHAR *root, const WCHAR *rest)\n{\n    if (_is_absW(rest)) {\n        return wcscpy_s(dest_path, MAX_PATH, rest);\n    }\n\n    if (wcscpy_s(dest_path, MAX_PATH, root)) {\n        return -1;\n    }\n\n    if (dest_path[0] && wcscat_s(dest_path, MAX_PATH, L\"\\\\\")) {\n        return -1;\n    }\n\n    return wcscat_s(dest_path, MAX_PATH, rest);\n}\n\n/* Return True if the path at src relative to dest is a directory */\nstatic int\n_check_dirW(LPCWSTR src, LPCWSTR dest)\n{\n    WIN32_FILE_ATTRIBUTE_DATA src_info;\n    WCHAR dest_parent[MAX_PATH];\n    WCHAR src_resolved[MAX_PATH] = L\"\";\n\n    /* dest_parent = os.path.dirname(dest) */\n    if (wcscpy_s(dest_parent, MAX_PATH, dest) ||\n        _dirnameW(dest_parent)) {\n        return 0;\n    }\n    /* src_resolved = os.path.join(dest_parent, src) */\n    if (_joinW(src_resolved, dest_parent, src)) {\n        return 0;\n    }\n    return (\n        GetFileAttributesExW(src_resolved, GetFileExInfoStandard, &src_info)\n        && src_info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY\n    );\n}\n#endif\n\n\n/*[clinic input]\nos.symlink\n    src: path_t\n    dst: path_t\n    target_is_directory: bool = False\n    *\n    dir_fd: dir_fd(requires='symlinkat')=None\n\n# \"symlink(src, dst, target_is_directory=False, *, dir_fd=None)\\n\\n\\\n\nCreate a symbolic link pointing to src named dst.\n\ntarget_is_directory is required on Windows if the target is to be\n  interpreted as a directory.  (On Windows, symlink requires\n  Windows 6.0 or greater, and raises a NotImplementedError otherwise.)\n  target_is_directory is ignored on non-Windows platforms.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_symlink_impl(PyObject *module, path_t *src, path_t *dst,\n                int target_is_directory, int dir_fd)\n/*[clinic end generated code: output=08ca9f3f3cf960f6 input=e820ec4472547bc3]*/\n{\n#ifdef MS_WINDOWS\n    DWORD result;\n    DWORD flags = 0;\n\n    /* Assumed true, set to false if detected to not be available. */\n    static int windows_has_symlink_unprivileged_flag = TRUE;\n#else\n    int result;\n#ifdef HAVE_SYMLINKAT\n    int symlinkat_unavailable = 0;\n#endif\n#endif\n\n    if (PySys_Audit(\"os.symlink\", \"OOi\", src->object, dst->object,\n                    dir_fd == DEFAULT_DIR_FD ? -1 : dir_fd) < 0) {\n        return NULL;\n    }\n\n#ifdef MS_WINDOWS\n\n    if (windows_has_symlink_unprivileged_flag) {\n        /* Allow non-admin symlinks if system allows it. */\n        flags |= SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    _Py_BEGIN_SUPPRESS_IPH\n    /* if src is a directory, ensure flags==1 (target_is_directory bit) */\n    if (target_is_directory || _check_dirW(src->wide, dst->wide)) {\n        flags |= SYMBOLIC_LINK_FLAG_DIRECTORY;\n    }\n\n    result = CreateSymbolicLinkW(dst->wide, src->wide, flags);\n    _Py_END_SUPPRESS_IPH\n    Py_END_ALLOW_THREADS\n\n    if (windows_has_symlink_unprivileged_flag && !result &&\n        ERROR_INVALID_PARAMETER == GetLastError()) {\n\n        Py_BEGIN_ALLOW_THREADS\n        _Py_BEGIN_SUPPRESS_IPH\n        /* This error might be caused by\n        SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE not being supported.\n        Try again, and update windows_has_symlink_unprivileged_flag if we\n        are successful this time.\n\n        NOTE: There is a risk of a race condition here if there are other\n        conditions than the flag causing ERROR_INVALID_PARAMETER, and\n        another process (or thread) changes that condition in between our\n        calls to CreateSymbolicLink.\n        */\n        flags &= ~(SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE);\n        result = CreateSymbolicLinkW(dst->wide, src->wide, flags);\n        _Py_END_SUPPRESS_IPH\n        Py_END_ALLOW_THREADS\n\n        if (result || ERROR_INVALID_PARAMETER != GetLastError()) {\n            windows_has_symlink_unprivileged_flag = FALSE;\n        }\n    }\n\n    if (!result)\n        return path_error2(src, dst);\n\n#else\n\n    if ((src->narrow && dst->wide) || (src->wide && dst->narrow)) {\n        PyErr_SetString(PyExc_ValueError,\n            \"symlink: src and dst must be the same type\");\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_SYMLINKAT\n    if (dir_fd != DEFAULT_DIR_FD) {\n        if (HAVE_SYMLINKAT_RUNTIME) {\n            result = symlinkat(src->narrow, dir_fd, dst->narrow);\n        } else {\n            symlinkat_unavailable = 1;\n        }\n    } else\n#endif\n        result = symlink(src->narrow, dst->narrow);\n    Py_END_ALLOW_THREADS\n\n#ifdef HAVE_SYMLINKAT\n    if (symlinkat_unavailable) {\n          argument_unavailable_error(NULL, \"dir_fd\");\n          return NULL;\n    }\n#endif\n\n    if (result)\n        return path_error2(src, dst);\n#endif\n\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SYMLINK */\n\n\nstatic PyStructSequence_Field times_result_fields[] = {\n    {\"user\",    \"user time\"},\n    {\"system\",   \"system time\"},\n    {\"children_user\",    \"user time of children\"},\n    {\"children_system\",    \"system time of children\"},\n    {\"elapsed\",    \"elapsed time since an arbitrary point in the past\"},\n    {NULL}\n};\n\nPyDoc_STRVAR(times_result__doc__,\n\"times_result: Result from os.times().\\n\\n\\\nThis object may be accessed either as a tuple of\\n\\\n  (user, system, children_user, children_system, elapsed),\\n\\\nor via the attributes user, system, children_user, children_system,\\n\\\nand elapsed.\\n\\\n\\n\\\nSee os.times for more information.\");\n\nstatic PyStructSequence_Desc times_result_desc = {\n    \"times_result\", /* name */\n    times_result__doc__, /* doc */\n    times_result_fields,\n    5\n};\n\nstatic PyObject *\nbuild_times_result(PyObject *module, double user, double system,\n    double children_user, double children_system,\n    double elapsed)\n{\n    PyObject *TimesResultType = get_posix_state(module)->TimesResultType;\n    PyObject *value = PyStructSequence_New((PyTypeObject *)TimesResultType);\n    if (value == NULL)\n        return NULL;\n\n#define SET(i, field) \\\n    { \\\n    PyObject *o = PyFloat_FromDouble(field); \\\n    if (!o) { \\\n        Py_DECREF(value); \\\n        return NULL; \\\n    } \\\n    PyStructSequence_SET_ITEM(value, i, o); \\\n    } \\\n\n    SET(0, user);\n    SET(1, system);\n    SET(2, children_user);\n    SET(3, children_system);\n    SET(4, elapsed);\n\n#undef SET\n\n    return value;\n}\n\n\n/*[clinic input]\nos.times\n\nReturn a collection containing process timing information.\n\nThe object returned behaves like a named tuple with these fields:\n  (utime, stime, cutime, cstime, elapsed_time)\nAll fields are floating point numbers.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_times_impl(PyObject *module)\n/*[clinic end generated code: output=35f640503557d32a input=2bf9df3d6ab2e48b]*/\n{\n#ifdef MS_WINDOWS\n    FILETIME create, exit, kernel, user;\n    HANDLE hProc;\n    hProc = GetCurrentProcess();\n    GetProcessTimes(hProc, &create, &exit, &kernel, &user);\n    /* The fields of a FILETIME structure are the hi and lo part\n       of a 64-bit value expressed in 100 nanosecond units.\n       1e7 is one second in such units; 1e-7 the inverse.\n       429.4967296 is 2**32 / 1e7 or 2**32 * 1e-7.\n    */\n    return build_times_result(module,\n        (double)(user.dwHighDateTime*429.4967296 +\n                 user.dwLowDateTime*1e-7),\n        (double)(kernel.dwHighDateTime*429.4967296 +\n                 kernel.dwLowDateTime*1e-7),\n        (double)0,\n        (double)0,\n        (double)0);\n#else /* MS_WINDOWS */\n    _posixstate *state = get_posix_state(module);\n    long ticks_per_second = state->ticks_per_second;\n\n    struct tms process;\n    clock_t elapsed;\n    errno = 0;\n    elapsed = times(&process);\n    if (elapsed == (clock_t) -1) {\n        return posix_error();\n    }\n\n    return build_times_result(module,\n        (double)process.tms_utime / ticks_per_second,\n        (double)process.tms_stime / ticks_per_second,\n        (double)process.tms_cutime / ticks_per_second,\n        (double)process.tms_cstime / ticks_per_second,\n        (double)elapsed / ticks_per_second);\n#endif /* MS_WINDOWS */\n}\n\n\n#if defined(HAVE_TIMERFD_CREATE)\n#define ONE_SECOND_IN_NS (1000 * 1000 * 1000)\n#define EXTRACT_NSEC(value)  (long)( ( (double)(value) - (time_t)(value) ) * 1e9)\n#define CONVERT_SEC_AND_NSEC_TO_DOUBLE(sec, nsec) ( (double)(sec) + (double)(nsec) * 1e-9 )\n\nstatic PyObject *\nbuild_itimerspec(const struct itimerspec* curr_value)\n{\n    double _value = CONVERT_SEC_AND_NSEC_TO_DOUBLE(curr_value->it_value.tv_sec,\n                                                          curr_value->it_value.tv_nsec);\n    PyObject *value = PyFloat_FromDouble(_value);\n    if (value == NULL) {\n        return NULL;\n    }\n    double _interval = CONVERT_SEC_AND_NSEC_TO_DOUBLE(curr_value->it_interval.tv_sec,\n                                                   curr_value->it_interval.tv_nsec);\n    PyObject *interval = PyFloat_FromDouble(_interval);\n    if (interval == NULL) {\n        Py_DECREF(value);\n        return NULL;\n    }\n    PyObject *tuple = PyTuple_Pack(2, value, interval);\n    Py_DECREF(interval);\n    Py_DECREF(value);\n    return tuple;\n}\n\nstatic PyObject *\nbuild_itimerspec_ns(const struct itimerspec* curr_value)\n{\n    PyTime_t value, interval;\n    if (_PyTime_FromTimespec(&value, &curr_value->it_value) < 0) {\n        return NULL;\n    }\n    if (_PyTime_FromTimespec(&interval, &curr_value->it_interval) < 0) {\n        return NULL;\n    }\n    return Py_BuildValue(\"LL\", value, interval);\n}\n\n/*[clinic input]\nos.timerfd_create\n\n    clockid: int\n        A valid clock ID constant as timer file descriptor.\n\n        time.CLOCK_REALTIME\n        time.CLOCK_MONOTONIC\n        time.CLOCK_BOOTTIME\n    /\n    *\n    flags: int = 0\n        0 or a bit mask of os.TFD_NONBLOCK or os.TFD_CLOEXEC.\n\n        os.TFD_NONBLOCK\n            If *TFD_NONBLOCK* is set as a flag, read doesn't blocks.\n            If *TFD_NONBLOCK* is not set as a flag, read block until the timer fires.\n\n        os.TFD_CLOEXEC\n            If *TFD_CLOEXEC* is set as a flag, enable the close-on-exec flag\n\nCreate and return a timer file descriptor.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_timerfd_create_impl(PyObject *module, int clockid, int flags)\n/*[clinic end generated code: output=1caae80fb168004a input=64b7020c5ac0b8f4]*/\n\n{\n    int fd;\n    Py_BEGIN_ALLOW_THREADS\n    flags |= TFD_CLOEXEC;  // PEP 446: always create non-inheritable FD\n    fd = timerfd_create(clockid, flags);\n    Py_END_ALLOW_THREADS\n    if (fd == -1) {\n        return PyErr_SetFromErrno(PyExc_OSError);\n    }\n    return PyLong_FromLong(fd);\n}\n\n/*[clinic input]\nos.timerfd_settime\n\n    fd: fildes\n        A timer file descriptor.\n    /\n    *\n    flags: int = 0\n        0 or a bit mask of TFD_TIMER_ABSTIME or TFD_TIMER_CANCEL_ON_SET.\n    initial as initial_double: double = 0.0\n        The initial expiration time, in seconds.\n    interval as interval_double: double = 0.0\n        The timer's interval, in seconds.\n\nAlter a timer file descriptor's internal timer in seconds.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_timerfd_settime_impl(PyObject *module, int fd, int flags,\n                        double initial_double, double interval_double)\n/*[clinic end generated code: output=df4c1bce6859224e input=81d2c0d7e936e8a7]*/\n{\n    PyTime_t initial, interval;\n    if (_PyTime_FromSecondsDouble(initial_double, _PyTime_ROUND_FLOOR,\n                                  &initial) < 0) {\n        return NULL;\n    }\n    if (_PyTime_FromSecondsDouble(interval_double, _PyTime_ROUND_FLOOR,\n                                  &interval) < 0) {\n        return NULL;\n    }\n\n    struct itimerspec new_value, old_value;\n    if (_PyTime_AsTimespec(initial, &new_value.it_value) < 0) {\n        PyErr_SetString(PyExc_ValueError, \"invalid initial value\");\n        return NULL;\n    }\n    if (_PyTime_AsTimespec(interval, &new_value.it_interval) < 0) {\n        PyErr_SetString(PyExc_ValueError, \"invalid interval value\");\n        return NULL;\n    }\n\n    int result;\n    Py_BEGIN_ALLOW_THREADS\n    result = timerfd_settime(fd, flags, &new_value, &old_value);\n    Py_END_ALLOW_THREADS\n    if (result == -1) {\n        return PyErr_SetFromErrno(PyExc_OSError);\n    }\n    return build_itimerspec(&old_value);\n}\n\n\n/*[clinic input]\nos.timerfd_settime_ns\n\n    fd: fildes\n        A timer file descriptor.\n    /\n    *\n    flags: int = 0\n        0 or a bit mask of TFD_TIMER_ABSTIME or TFD_TIMER_CANCEL_ON_SET.\n    initial: long_long = 0\n        initial expiration timing in seconds.\n    interval: long_long = 0\n        interval for the timer in seconds.\n\nAlter a timer file descriptor's internal timer in nanoseconds.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_timerfd_settime_ns_impl(PyObject *module, int fd, int flags,\n                           long long initial, long long interval)\n/*[clinic end generated code: output=6273ec7d7b4cc0b3 input=261e105d6e42f5bc]*/\n{\n    struct itimerspec new_value;\n    struct itimerspec old_value;\n    int result;\n    if (_PyTime_AsTimespec(initial, &new_value.it_value) < 0) {\n        PyErr_SetString(PyExc_ValueError, \"invalid initial value\");\n        return NULL;\n    }\n    if (_PyTime_AsTimespec(interval, &new_value.it_interval) < 0) {\n        PyErr_SetString(PyExc_ValueError, \"invalid interval value\");\n        return NULL;\n    }\n    Py_BEGIN_ALLOW_THREADS\n    result = timerfd_settime(fd, flags, &new_value, &old_value);\n    Py_END_ALLOW_THREADS\n    if (result == -1) {\n        return PyErr_SetFromErrno(PyExc_OSError);\n    }\n    return build_itimerspec_ns(&old_value);\n}\n\n/*[clinic input]\nos.timerfd_gettime\n\n    fd: fildes\n        A timer file descriptor.\n    /\n\nReturn a tuple of a timer file descriptor's (interval, next expiration) in float seconds.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_timerfd_gettime_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=ec5a94a66cfe6ab4 input=8148e3430870da1c]*/\n{\n    struct itimerspec curr_value;\n    int result;\n    Py_BEGIN_ALLOW_THREADS\n    result = timerfd_gettime(fd, &curr_value);\n    Py_END_ALLOW_THREADS\n    if (result == -1) {\n        return PyErr_SetFromErrno(PyExc_OSError);\n    }\n    return build_itimerspec(&curr_value);\n}\n\n\n/*[clinic input]\nos.timerfd_gettime_ns\n\n    fd: fildes\n        A timer file descriptor.\n    /\n\nReturn a tuple of a timer file descriptor's (interval, next expiration) in nanoseconds.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_timerfd_gettime_ns_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=580633a4465f39fe input=a825443e4c6b40ac]*/\n{\n    struct itimerspec curr_value;\n    int result;\n    Py_BEGIN_ALLOW_THREADS\n    result = timerfd_gettime(fd, &curr_value);\n    Py_END_ALLOW_THREADS\n    if (result == -1) {\n        return PyErr_SetFromErrno(PyExc_OSError);\n    }\n    return build_itimerspec_ns(&curr_value);\n}\n\n#undef ONE_SECOND_IN_NS\n#undef EXTRACT_NSEC\n\n#endif  /* HAVE_TIMERFD_CREATE */\n\n#ifdef HAVE_GETSID\n/*[clinic input]\nos.getsid\n\n    pid: pid_t\n    /\n\nCall the system call getsid(pid) and return the result.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getsid_impl(PyObject *module, pid_t pid)\n/*[clinic end generated code: output=112deae56b306460 input=eeb2b923a30ce04e]*/\n{\n    int sid;\n    sid = getsid(pid);\n    if (sid < 0)\n        return posix_error();\n    return PyLong_FromLong((long)sid);\n}\n#endif /* HAVE_GETSID */\n\n\n#ifdef HAVE_SETSID\n/*[clinic input]\nos.setsid\n\nCall the system call setsid().\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setsid_impl(PyObject *module)\n/*[clinic end generated code: output=e2ddedd517086d77 input=5fff45858e2f0776]*/\n{\n    if (setsid() < 0)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SETSID */\n\n\n#ifdef HAVE_SETPGID\n/*[clinic input]\nos.setpgid\n\n    pid: pid_t\n    pgrp: pid_t\n    /\n\nCall the system call setpgid(pid, pgrp).\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setpgid_impl(PyObject *module, pid_t pid, pid_t pgrp)\n/*[clinic end generated code: output=6461160319a43d6a input=fceb395eca572e1a]*/\n{\n    if (setpgid(pid, pgrp) < 0)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SETPGID */\n\n\n#ifdef HAVE_TCGETPGRP\n/*[clinic input]\nos.tcgetpgrp\n\n    fd: int\n    /\n\nReturn the process group associated with the terminal specified by fd.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_tcgetpgrp_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=f865e88be86c272b input=7f6c18eac10ada86]*/\n{\n    pid_t pgid = tcgetpgrp(fd);\n    if (pgid < 0)\n        return posix_error();\n    return PyLong_FromPid(pgid);\n}\n#endif /* HAVE_TCGETPGRP */\n\n\n#ifdef HAVE_TCSETPGRP\n/*[clinic input]\nos.tcsetpgrp\n\n    fd: int\n    pgid: pid_t\n    /\n\nSet the process group associated with the terminal specified by fd.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_tcsetpgrp_impl(PyObject *module, int fd, pid_t pgid)\n/*[clinic end generated code: output=f1821a381b9daa39 input=5bdc997c6a619020]*/\n{\n    if (tcsetpgrp(fd, pgid) < 0)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_TCSETPGRP */\n\n/* Functions acting on file descriptors */\n\n#ifdef O_CLOEXEC\nextern int _Py_open_cloexec_works;\n#endif\n\n\n/*[clinic input]\nos.open -> int\n    path: path_t\n    flags: int\n    mode: int = 0o777\n    *\n    dir_fd: dir_fd(requires='openat') = None\n\n# \"open(path, flags, mode=0o777, *, dir_fd=None)\\n\\n\\\n\nOpen a file for low level IO.  Returns a file descriptor (integer).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.\n[clinic start generated code]*/\n\nstatic int\nos_open_impl(PyObject *module, path_t *path, int flags, int mode, int dir_fd)\n/*[clinic end generated code: output=abc7227888c8bc73 input=ad8623b29acd2934]*/\n{\n    int fd;\n    int async_err = 0;\n#ifdef HAVE_OPENAT\n    int openat_unavailable = 0;\n#endif\n\n#ifdef O_CLOEXEC\n    int *atomic_flag_works = &_Py_open_cloexec_works;\n#elif !defined(MS_WINDOWS)\n    int *atomic_flag_works = NULL;\n#endif\n\n#ifdef MS_WINDOWS\n    flags |= O_NOINHERIT;\n#elif defined(O_CLOEXEC)\n    flags |= O_CLOEXEC;\n#endif\n\n    if (PySys_Audit(\"open\", \"OOi\", path->object, Py_None, flags) < 0) {\n        return -1;\n    }\n\n    _Py_BEGIN_SUPPRESS_IPH\n    do {\n        Py_BEGIN_ALLOW_THREADS\n#ifdef MS_WINDOWS\n        fd = _wopen(path->wide, flags, mode);\n#else\n#ifdef HAVE_OPENAT\n        if (dir_fd != DEFAULT_DIR_FD) {\n            if (HAVE_OPENAT_RUNTIME) {\n                fd = openat(dir_fd, path->narrow, flags, mode);\n\n            } else {\n                openat_unavailable = 1;\n                fd = -1;\n            }\n        } else\n#endif /* HAVE_OPENAT */\n            fd = open(path->narrow, flags, mode);\n#endif /* !MS_WINDOWS */\n        Py_END_ALLOW_THREADS\n    } while (fd < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    _Py_END_SUPPRESS_IPH\n\n#ifdef HAVE_OPENAT\n    if (openat_unavailable) {\n        argument_unavailable_error(NULL, \"dir_fd\");\n        return -1;\n    }\n#endif\n\n    if (fd < 0) {\n        if (!async_err)\n            PyErr_SetFromErrnoWithFilenameObject(PyExc_OSError, path->object);\n        return -1;\n    }\n\n#ifndef MS_WINDOWS\n    if (_Py_set_inheritable(fd, 0, atomic_flag_works) < 0) {\n        close(fd);\n        return -1;\n    }\n#endif\n\n    return fd;\n}\n\n\n/*[clinic input]\nos.close\n\n    fd: int\n\nClose a file descriptor.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_close_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=2fe4e93602822c14 input=2bc42451ca5c3223]*/\n{\n    int res;\n    /* We do not want to retry upon EINTR: see http://lwn.net/Articles/576478/\n     * and http://linux.derkeiler.com/Mailing-Lists/Kernel/2005-09/3000.html\n     * for more details.\n     */\n    Py_BEGIN_ALLOW_THREADS\n    _Py_BEGIN_SUPPRESS_IPH\n    res = close(fd);\n    _Py_END_SUPPRESS_IPH\n    Py_END_ALLOW_THREADS\n    if (res < 0)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nos.closerange\n\n    fd_low: int\n    fd_high: int\n    /\n\nCloses all file descriptors in [fd_low, fd_high), ignoring errors.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_closerange_impl(PyObject *module, int fd_low, int fd_high)\n/*[clinic end generated code: output=0ce5c20fcda681c2 input=5855a3d053ebd4ec]*/\n{\n    Py_BEGIN_ALLOW_THREADS\n    _Py_closerange(fd_low, fd_high - 1);\n    Py_END_ALLOW_THREADS\n    Py_RETURN_NONE;\n}\n\n\n/*[clinic input]\nos.dup -> int\n\n    fd: int\n    /\n\nReturn a duplicate of a file descriptor.\n[clinic start generated code]*/\n\nstatic int\nos_dup_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=486f4860636b2a9f input=6f10f7ea97f7852a]*/\n{\n    return _Py_dup(fd);\n}\n\n// dup2() is either provided by libc or dup2.c with AC_REPLACE_FUNCS().\n// dup2.c provides working dup2() if and only if F_DUPFD is available.\n#if (defined(HAVE_DUP3) || defined(F_DUPFD) || defined(MS_WINDOWS))\n/*[clinic input]\nos.dup2 -> int\n    fd: int\n    fd2: int\n    inheritable: bool=True\n\nDuplicate file descriptor.\n[clinic start generated code]*/\n\nstatic int\nos_dup2_impl(PyObject *module, int fd, int fd2, int inheritable)\n/*[clinic end generated code: output=bc059d34a73404d1 input=c3cddda8922b038d]*/\n{\n    int res = 0;\n#if defined(HAVE_DUP3) && \\\n    !(defined(HAVE_FCNTL_H) && defined(F_DUP2FD_CLOEXEC))\n    /* dup3() is available on Linux 2.6.27+ and glibc 2.9 */\n    static int dup3_works = -1;\n#endif\n\n    /* dup2() can fail with EINTR if the target FD is already open, because it\n     * then has to be closed. See os_close_impl() for why we don't handle EINTR\n     * upon close(), and therefore below.\n     */\n#ifdef MS_WINDOWS\n    Py_BEGIN_ALLOW_THREADS\n    _Py_BEGIN_SUPPRESS_IPH\n    res = dup2(fd, fd2);\n    _Py_END_SUPPRESS_IPH\n    Py_END_ALLOW_THREADS\n    if (res < 0) {\n        posix_error();\n        return -1;\n    }\n    res = fd2; // msvcrt dup2 returns 0 on success.\n\n    /* Character files like console cannot be make non-inheritable */\n    if (!inheritable && _Py_set_inheritable(fd2, 0, NULL) < 0) {\n        close(fd2);\n        return -1;\n    }\n\n#elif defined(HAVE_FCNTL_H) && defined(F_DUP2FD_CLOEXEC)\n    Py_BEGIN_ALLOW_THREADS\n    if (!inheritable)\n        res = fcntl(fd, F_DUP2FD_CLOEXEC, fd2);\n    else\n        res = dup2(fd, fd2);\n    Py_END_ALLOW_THREADS\n    if (res < 0) {\n        posix_error();\n        return -1;\n    }\n\n#else\n\n#ifdef HAVE_DUP3\n    if (!inheritable && dup3_works != 0) {\n        Py_BEGIN_ALLOW_THREADS\n        res = dup3(fd, fd2, O_CLOEXEC);\n        Py_END_ALLOW_THREADS\n        if (res < 0) {\n            if (dup3_works == -1)\n                dup3_works = (errno != ENOSYS);\n            if (dup3_works) {\n                posix_error();\n                return -1;\n            }\n        }\n    }\n\n    if (inheritable || dup3_works == 0)\n    {\n#endif\n        Py_BEGIN_ALLOW_THREADS\n        res = dup2(fd, fd2);\n        Py_END_ALLOW_THREADS\n        if (res < 0) {\n            posix_error();\n            return -1;\n        }\n\n        if (!inheritable && _Py_set_inheritable(fd2, 0, NULL) < 0) {\n            close(fd2);\n            return -1;\n        }\n#ifdef HAVE_DUP3\n    }\n#endif\n\n#endif\n\n    return res;\n}\n#endif\n\n\n#ifdef HAVE_LOCKF\n/*[clinic input]\nos.lockf\n\n    fd: int\n        An open file descriptor.\n    command: int\n        One of F_LOCK, F_TLOCK, F_ULOCK or F_TEST.\n    length: Py_off_t\n        The number of bytes to lock, starting at the current position.\n    /\n\nApply, test or remove a POSIX lock on an open file descriptor.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_lockf_impl(PyObject *module, int fd, int command, Py_off_t length)\n/*[clinic end generated code: output=af7051f3e7c29651 input=65da41d2106e9b79]*/\n{\n    int res;\n\n    if (PySys_Audit(\"os.lockf\", \"iiL\", fd, command, length) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    res = lockf(fd, command, length);\n    Py_END_ALLOW_THREADS\n\n    if (res < 0)\n        return posix_error();\n\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_LOCKF */\n\n\n/*[clinic input]\nos.lseek -> Py_off_t\n\n    fd: int\n        An open file descriptor, as returned by os.open().\n    position: Py_off_t\n        Position, interpreted relative to 'whence'.\n    whence as how: int\n        The relative position to seek from. Valid values are:\n        - SEEK_SET: seek from the start of the file.\n        - SEEK_CUR: seek from the current file position.\n        - SEEK_END: seek from the end of the file.\n    /\n\nSet the position of a file descriptor.  Return the new position.\n\nThe return value is the number of bytes relative to the beginning of the file.\n[clinic start generated code]*/\n\nstatic Py_off_t\nos_lseek_impl(PyObject *module, int fd, Py_off_t position, int how)\n/*[clinic end generated code: output=971e1efb6b30bd2f input=f096e754c5367504]*/\n{\n    Py_off_t result;\n\n#ifdef SEEK_SET\n    /* Turn 0, 1, 2 into SEEK_{SET,CUR,END} */\n    switch (how) {\n        case 0: how = SEEK_SET; break;\n        case 1: how = SEEK_CUR; break;\n        case 2: how = SEEK_END; break;\n    }\n#endif /* SEEK_END */\n\n    Py_BEGIN_ALLOW_THREADS\n    _Py_BEGIN_SUPPRESS_IPH\n#ifdef MS_WINDOWS\n    result = _lseeki64(fd, position, how);\n#else\n    result = lseek(fd, position, how);\n#endif\n    _Py_END_SUPPRESS_IPH\n    Py_END_ALLOW_THREADS\n    if (result < 0)\n        posix_error();\n\n    return result;\n}\n\n\n/*[clinic input]\nos.read\n    fd: int\n    length: Py_ssize_t\n    /\n\nRead from a file descriptor.  Returns a bytes object.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_read_impl(PyObject *module, int fd, Py_ssize_t length)\n/*[clinic end generated code: output=dafbe9a5cddb987b input=1df2eaa27c0bf1d3]*/\n{\n    Py_ssize_t n;\n    PyObject *buffer;\n\n    if (length < 0) {\n        errno = EINVAL;\n        return posix_error();\n    }\n\n    length = Py_MIN(length, _PY_READ_MAX);\n\n    buffer = PyBytes_FromStringAndSize((char *)NULL, length);\n    if (buffer == NULL)\n        return NULL;\n\n    n = _Py_read(fd, PyBytes_AS_STRING(buffer), length);\n    if (n == -1) {\n        Py_DECREF(buffer);\n        return NULL;\n    }\n\n    if (n != length)\n        _PyBytes_Resize(&buffer, n);\n\n    return buffer;\n}\n\n#if (defined(HAVE_SENDFILE) && (defined(__FreeBSD__) || defined(__DragonFly__) \\\n                                || defined(__APPLE__))) \\\n    || defined(HAVE_READV) || defined(HAVE_PREADV) || defined (HAVE_PREADV2) \\\n    || defined(HAVE_WRITEV) || defined(HAVE_PWRITEV) || defined (HAVE_PWRITEV2)\nstatic int\niov_setup(struct iovec **iov, Py_buffer **buf, PyObject *seq, Py_ssize_t cnt, int type)\n{\n    Py_ssize_t i, j;\n\n    *iov = PyMem_New(struct iovec, cnt);\n    if (*iov == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n\n    *buf = PyMem_New(Py_buffer, cnt);\n    if (*buf == NULL) {\n        PyMem_Free(*iov);\n        PyErr_NoMemory();\n        return -1;\n    }\n\n    for (i = 0; i < cnt; i++) {\n        PyObject *item = PySequence_GetItem(seq, i);\n        if (item == NULL)\n            goto fail;\n        if (PyObject_GetBuffer(item, &(*buf)[i], type) == -1) {\n            Py_DECREF(item);\n            goto fail;\n        }\n        Py_DECREF(item);\n        (*iov)[i].iov_base = (*buf)[i].buf;\n        (*iov)[i].iov_len = (*buf)[i].len;\n    }\n    return 0;\n\nfail:\n    PyMem_Free(*iov);\n    for (j = 0; j < i; j++) {\n        PyBuffer_Release(&(*buf)[j]);\n    }\n    PyMem_Free(*buf);\n    return -1;\n}\n\nstatic void\niov_cleanup(struct iovec *iov, Py_buffer *buf, int cnt)\n{\n    int i;\n    PyMem_Free(iov);\n    for (i = 0; i < cnt; i++) {\n        PyBuffer_Release(&buf[i]);\n    }\n    PyMem_Free(buf);\n}\n#endif\n\n\n#ifdef HAVE_READV\n/*[clinic input]\nos.readv -> Py_ssize_t\n\n    fd: int\n    buffers: object\n    /\n\nRead from a file descriptor fd into an iterable of buffers.\n\nThe buffers should be mutable buffers accepting bytes.\nreadv will transfer data into each buffer until it is full\nand then move on to the next buffer in the sequence to hold\nthe rest of the data.\n\nreadv returns the total number of bytes read,\nwhich may be less than the total capacity of all the buffers.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\nos_readv_impl(PyObject *module, int fd, PyObject *buffers)\n/*[clinic end generated code: output=792da062d3fcebdb input=e679eb5dbfa0357d]*/\n{\n    Py_ssize_t cnt, n;\n    int async_err = 0;\n    struct iovec *iov;\n    Py_buffer *buf;\n\n    if (!PySequence_Check(buffers)) {\n        PyErr_SetString(PyExc_TypeError,\n            \"readv() arg 2 must be a sequence\");\n        return -1;\n    }\n\n    cnt = PySequence_Size(buffers);\n    if (cnt < 0)\n        return -1;\n\n    if (iov_setup(&iov, &buf, buffers, cnt, PyBUF_WRITABLE) < 0)\n        return -1;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        n = readv(fd, iov, cnt);\n        Py_END_ALLOW_THREADS\n    } while (n < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n\n    int saved_errno = errno;\n    iov_cleanup(iov, buf, cnt);\n    if (n < 0) {\n        if (!async_err) {\n            errno = saved_errno;\n            posix_error();\n        }\n        return -1;\n    }\n\n    return n;\n}\n#endif /* HAVE_READV */\n\n\n#ifdef HAVE_PREAD\n/*[clinic input]\nos.pread\n\n    fd: int\n    length: Py_ssize_t\n    offset: Py_off_t\n    /\n\nRead a number of bytes from a file descriptor starting at a particular offset.\n\nRead length bytes from file descriptor fd, starting at offset bytes from\nthe beginning of the file.  The file offset remains unchanged.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_pread_impl(PyObject *module, int fd, Py_ssize_t length, Py_off_t offset)\n/*[clinic end generated code: output=3f875c1eef82e32f input=85cb4a5589627144]*/\n{\n    Py_ssize_t n;\n    int async_err = 0;\n    PyObject *buffer;\n\n    if (length < 0) {\n        errno = EINVAL;\n        return posix_error();\n    }\n    buffer = PyBytes_FromStringAndSize((char *)NULL, length);\n    if (buffer == NULL)\n        return NULL;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        _Py_BEGIN_SUPPRESS_IPH\n        n = pread(fd, PyBytes_AS_STRING(buffer), length, offset);\n        _Py_END_SUPPRESS_IPH\n        Py_END_ALLOW_THREADS\n    } while (n < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n\n    if (n < 0) {\n        if (!async_err) {\n            posix_error();\n        }\n        Py_DECREF(buffer);\n        return NULL;\n    }\n    if (n != length)\n        _PyBytes_Resize(&buffer, n);\n    return buffer;\n}\n#endif /* HAVE_PREAD */\n\n#if defined(HAVE_PREADV) || defined (HAVE_PREADV2)\n/*[clinic input]\nos.preadv -> Py_ssize_t\n\n    fd: int\n    buffers: object\n    offset: Py_off_t\n    flags: int = 0\n    /\n\nReads from a file descriptor into a number of mutable bytes-like objects.\n\nCombines the functionality of readv() and pread(). As readv(), it will\ntransfer data into each buffer until it is full and then move on to the next\nbuffer in the sequence to hold the rest of the data. Its fourth argument,\nspecifies the file offset at which the input operation is to be performed. It\nwill return the total number of bytes read (which can be less than the total\ncapacity of all the objects).\n\nThe flags argument contains a bitwise OR of zero or more of the following flags:\n\n- RWF_HIPRI\n- RWF_NOWAIT\n\nUsing non-zero flags requires Linux 4.6 or newer.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\nos_preadv_impl(PyObject *module, int fd, PyObject *buffers, Py_off_t offset,\n               int flags)\n/*[clinic end generated code: output=26fc9c6e58e7ada5 input=4173919dc1f7ed99]*/\n{\n    Py_ssize_t cnt, n;\n    int async_err = 0;\n    struct iovec *iov;\n    Py_buffer *buf;\n\n    if (!PySequence_Check(buffers)) {\n        PyErr_SetString(PyExc_TypeError,\n            \"preadv2() arg 2 must be a sequence\");\n        return -1;\n    }\n\n    cnt = PySequence_Size(buffers);\n    if (cnt < 0) {\n        return -1;\n    }\n\n#ifndef HAVE_PREADV2\n    if(flags != 0) {\n        argument_unavailable_error(\"preadv2\", \"flags\");\n        return -1;\n    }\n#endif\n\n    if (iov_setup(&iov, &buf, buffers, cnt, PyBUF_WRITABLE) < 0) {\n        return -1;\n    }\n#ifdef HAVE_PREADV2\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        _Py_BEGIN_SUPPRESS_IPH\n        n = preadv2(fd, iov, cnt, offset, flags);\n        _Py_END_SUPPRESS_IPH\n        Py_END_ALLOW_THREADS\n    } while (n < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n#else\n    do {\n#if defined(__APPLE__) && defined(__clang__)\n/* This entire function will be removed from the module dict when the API\n * is not available.\n */\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunguarded-availability\"\n#pragma clang diagnostic ignored \"-Wunguarded-availability-new\"\n#endif\n        Py_BEGIN_ALLOW_THREADS\n        _Py_BEGIN_SUPPRESS_IPH\n        n = preadv(fd, iov, cnt, offset);\n        _Py_END_SUPPRESS_IPH\n        Py_END_ALLOW_THREADS\n    } while (n < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n\n#if defined(__APPLE__) && defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n#endif\n\n    int saved_errno = errno;\n    iov_cleanup(iov, buf, cnt);\n    if (n < 0) {\n        if (!async_err) {\n            errno = saved_errno;\n            posix_error();\n        }\n        return -1;\n    }\n\n    return n;\n}\n#endif /* HAVE_PREADV */\n\n\n/*[clinic input]\nos.write -> Py_ssize_t\n\n    fd: int\n    data: Py_buffer\n    /\n\nWrite a bytes object to a file descriptor.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\nos_write_impl(PyObject *module, int fd, Py_buffer *data)\n/*[clinic end generated code: output=e4ef5bc904b58ef9 input=3207e28963234f3c]*/\n{\n    return _Py_write(fd, data->buf, data->len);\n}\n\n#ifdef HAVE_SENDFILE\n#ifdef __APPLE__\n/*[clinic input]\nos.sendfile\n\n    out_fd: int\n    in_fd: int\n    offset: Py_off_t\n    count as sbytes: Py_off_t\n    headers: object(c_default=\"NULL\") = ()\n    trailers: object(c_default=\"NULL\") = ()\n    flags: int = 0\n\nCopy count bytes from file descriptor in_fd to file descriptor out_fd.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sendfile_impl(PyObject *module, int out_fd, int in_fd, Py_off_t offset,\n                 Py_off_t sbytes, PyObject *headers, PyObject *trailers,\n                 int flags)\n/*[clinic end generated code: output=81c4bcd143f5c82b input=b0d72579d4c69afa]*/\n#elif defined(__FreeBSD__) || defined(__DragonFly__)\n/*[clinic input]\nos.sendfile\n\n    out_fd: int\n    in_fd: int\n    offset: Py_off_t\n    count: Py_ssize_t\n    headers: object(c_default=\"NULL\") = ()\n    trailers: object(c_default=\"NULL\") = ()\n    flags: int = 0\n\nCopy count bytes from file descriptor in_fd to file descriptor out_fd.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sendfile_impl(PyObject *module, int out_fd, int in_fd, Py_off_t offset,\n                 Py_ssize_t count, PyObject *headers, PyObject *trailers,\n                 int flags)\n/*[clinic end generated code: output=329ea009bdd55afc input=338adb8ff84ae8cd]*/\n#else\n/*[clinic input]\nos.sendfile\n\n    out_fd: int\n    in_fd: int\n    offset as offobj: object\n    count: Py_ssize_t\n\nCopy count bytes from file descriptor in_fd to file descriptor out_fd.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_sendfile_impl(PyObject *module, int out_fd, int in_fd, PyObject *offobj,\n                 Py_ssize_t count)\n/*[clinic end generated code: output=ae81216e40f167d8 input=76d64058c74477ba]*/\n#endif\n{\n    Py_ssize_t ret;\n    int async_err = 0;\n\n#if defined(__FreeBSD__) || defined(__DragonFly__) || defined(__APPLE__)\n#ifndef __APPLE__\n    off_t sbytes;\n#endif\n    Py_buffer *hbuf, *tbuf;\n    struct sf_hdtr sf;\n\n    sf.headers = NULL;\n    sf.trailers = NULL;\n\n    if (headers != NULL) {\n        if (!PySequence_Check(headers)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"sendfile() headers must be a sequence\");\n            return NULL;\n        } else {\n            Py_ssize_t i = PySequence_Size(headers);\n            if (i < 0)\n                return NULL;\n            if (i > INT_MAX) {\n                PyErr_SetString(PyExc_OverflowError,\n                    \"sendfile() header is too large\");\n                return NULL;\n            }\n            if (i > 0) {\n                sf.hdr_cnt = (int)i;\n                if (iov_setup(&(sf.headers), &hbuf,\n                              headers, sf.hdr_cnt, PyBUF_SIMPLE) < 0)\n                    return NULL;\n#ifdef __APPLE__\n                for (i = 0; i < sf.hdr_cnt; i++) {\n                    Py_ssize_t blen = sf.headers[i].iov_len;\n# define OFF_T_MAX 0x7fffffffffffffff\n                    if (sbytes >= OFF_T_MAX - blen) {\n                        PyErr_SetString(PyExc_OverflowError,\n                            \"sendfile() header is too large\");\n                        return NULL;\n                    }\n                    sbytes += blen;\n                }\n#endif\n            }\n        }\n    }\n    if (trailers != NULL) {\n        if (!PySequence_Check(trailers)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"sendfile() trailers must be a sequence\");\n            return NULL;\n        } else {\n            Py_ssize_t i = PySequence_Size(trailers);\n            if (i < 0)\n                return NULL;\n            if (i > INT_MAX) {\n                PyErr_SetString(PyExc_OverflowError,\n                    \"sendfile() trailer is too large\");\n                return NULL;\n            }\n            if (i > 0) {\n                sf.trl_cnt = (int)i;\n                if (iov_setup(&(sf.trailers), &tbuf,\n                              trailers, sf.trl_cnt, PyBUF_SIMPLE) < 0)\n                    return NULL;\n            }\n        }\n    }\n\n    _Py_BEGIN_SUPPRESS_IPH\n    do {\n        Py_BEGIN_ALLOW_THREADS\n#ifdef __APPLE__\n        ret = sendfile(in_fd, out_fd, offset, &sbytes, &sf, flags);\n#else\n        ret = sendfile(in_fd, out_fd, offset, count, &sf, &sbytes, flags);\n#endif\n        Py_END_ALLOW_THREADS\n    } while (ret < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    _Py_END_SUPPRESS_IPH\n\n    int saved_errno = errno;\n    if (sf.headers != NULL)\n        iov_cleanup(sf.headers, hbuf, sf.hdr_cnt);\n    if (sf.trailers != NULL)\n        iov_cleanup(sf.trailers, tbuf, sf.trl_cnt);\n\n    if (ret < 0) {\n        if ((saved_errno == EAGAIN) || (saved_errno == EBUSY)) {\n            if (sbytes != 0) {\n                // some data has been sent\n                goto done;\n            }\n            // no data has been sent; upper application is supposed\n            // to retry on EAGAIN or EBUSY\n        }\n        if (!async_err) {\n            errno = saved_errno;\n            posix_error();\n        }\n        return NULL;\n    }\n    goto done;\n\ndone:\n    #if !defined(HAVE_LARGEFILE_SUPPORT)\n        return PyLong_FromLong(sbytes);\n    #else\n        return PyLong_FromLongLong(sbytes);\n    #endif\n\n#else\n#ifdef __linux__\n    if (offobj == Py_None) {\n        do {\n            Py_BEGIN_ALLOW_THREADS\n            ret = sendfile(out_fd, in_fd, NULL, count);\n            Py_END_ALLOW_THREADS\n        } while (ret < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n        if (ret < 0)\n            return (!async_err) ? posix_error() : NULL;\n        return PyLong_FromSsize_t(ret);\n    }\n#endif\n    off_t offset;\n    if (!Py_off_t_converter(offobj, &offset))\n        return NULL;\n\n#if defined(__sun) && defined(__SVR4)\n    // On Solaris, sendfile raises EINVAL rather than returning 0\n    // when the offset is equal or bigger than the in_fd size.\n    struct stat st;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        ret = fstat(in_fd, &st);\n        Py_END_ALLOW_THREADS\n    } while (ret != 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    if (ret < 0)\n        return (!async_err) ? posix_error() : NULL;\n\n    if (offset >= st.st_size) {\n        return PyLong_FromLong(0);\n    }\n\n    // On illumos specifically sendfile() may perform a partial write but\n    // return -1/an error (in one confirmed case the destination socket\n    // had a 5 second timeout set and errno was EAGAIN) and it's on the client\n    // code to check if the offset parameter was modified by sendfile().\n    //\n    // We need this variable to track said change.\n    off_t original_offset = offset;\n#endif\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        ret = sendfile(out_fd, in_fd, &offset, count);\n#if defined(__sun) && defined(__SVR4)\n        // This handles illumos-specific sendfile() partial write behavior,\n        // see a comment above for more details.\n        if (ret < 0 && offset != original_offset) {\n            ret = offset - original_offset;\n        }\n#endif\n        Py_END_ALLOW_THREADS\n    } while (ret < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    if (ret < 0)\n        return (!async_err) ? posix_error() : NULL;\n    return PyLong_FromSsize_t(ret);\n#endif\n}\n#endif /* HAVE_SENDFILE */\n\n\n#if defined(__APPLE__)\n/*[clinic input]\nos._fcopyfile\n\n    in_fd: int\n    out_fd: int\n    flags: int\n    /\n\nEfficiently copy content or metadata of 2 regular file descriptors (macOS).\n[clinic start generated code]*/\n\nstatic PyObject *\nos__fcopyfile_impl(PyObject *module, int in_fd, int out_fd, int flags)\n/*[clinic end generated code: output=c9d1a35a992e401b input=1e34638a86948795]*/\n{\n    int ret;\n\n    Py_BEGIN_ALLOW_THREADS\n    ret = fcopyfile(in_fd, out_fd, NULL, flags);\n    Py_END_ALLOW_THREADS\n    if (ret < 0)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif\n\n\n/*[clinic input]\nos.fstat\n\n    fd : int\n\nPerform a stat system call on the given file descriptor.\n\nLike stat(), but for an open file descriptor.\nEquivalent to os.stat(fd).\n[clinic start generated code]*/\n\nstatic PyObject *\nos_fstat_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=efc038cb5f654492 input=27e0e0ebbe5600c9]*/\n{\n    STRUCT_STAT st;\n    int res;\n    int async_err = 0;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        res = FSTAT(fd, &st);\n        Py_END_ALLOW_THREADS\n    } while (res != 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n    if (res != 0) {\n#ifdef MS_WINDOWS\n        return PyErr_SetFromWindowsErr(0);\n#else\n        return (!async_err) ? posix_error() : NULL;\n#endif\n    }\n\n    return _pystat_fromstructstat(module, &st);\n}\n\n\n/*[clinic input]\nos.isatty -> bool\n    fd: int\n    /\n\nReturn True if the fd is connected to a terminal.\n\nReturn True if the file descriptor is an open file descriptor\nconnected to the slave end of a terminal.\n[clinic start generated code]*/\n\nstatic int\nos_isatty_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=6a48c8b4e644ca00 input=08ce94aa1eaf7b5e]*/\n{\n    int return_value;\n    Py_BEGIN_ALLOW_THREADS\n    _Py_BEGIN_SUPPRESS_IPH\n    return_value = isatty(fd);\n    _Py_END_SUPPRESS_IPH\n    Py_END_ALLOW_THREADS\n    return return_value;\n}\n\n\n#ifdef HAVE_PIPE\n/*[clinic input]\nos.pipe\n\nCreate a pipe.\n\nReturns a tuple of two file descriptors:\n  (read_fd, write_fd)\n[clinic start generated code]*/\n\nstatic PyObject *\nos_pipe_impl(PyObject *module)\n/*[clinic end generated code: output=ff9b76255793b440 input=02535e8c8fa6c4d4]*/\n{\n    int fds[2];\n#ifdef MS_WINDOWS\n    HANDLE read, write;\n    SECURITY_ATTRIBUTES attr;\n    BOOL ok;\n#else\n    int res;\n#endif\n\n#ifdef MS_WINDOWS\n    attr.nLength = sizeof(attr);\n    attr.lpSecurityDescriptor = NULL;\n    attr.bInheritHandle = FALSE;\n\n    Py_BEGIN_ALLOW_THREADS\n    ok = CreatePipe(&read, &write, &attr, 0);\n    if (ok) {\n        fds[0] = _Py_open_osfhandle_noraise(read, _O_RDONLY | _O_NOINHERIT);\n        fds[1] = _Py_open_osfhandle_noraise(write, _O_WRONLY | _O_NOINHERIT);\n        if (fds[0] == -1 || fds[1] == -1) {\n            CloseHandle(read);\n            CloseHandle(write);\n            ok = 0;\n        }\n    }\n    Py_END_ALLOW_THREADS\n\n    if (!ok)\n        return PyErr_SetFromWindowsErr(0);\n#else\n\n#ifdef HAVE_PIPE2\n    Py_BEGIN_ALLOW_THREADS\n    res = pipe2(fds, O_CLOEXEC);\n    Py_END_ALLOW_THREADS\n\n    if (res != 0 && errno == ENOSYS)\n    {\n#endif\n        Py_BEGIN_ALLOW_THREADS\n        res = pipe(fds);\n        Py_END_ALLOW_THREADS\n\n        if (res == 0) {\n            if (_Py_set_inheritable(fds[0], 0, NULL) < 0) {\n                close(fds[0]);\n                close(fds[1]);\n                return NULL;\n            }\n            if (_Py_set_inheritable(fds[1], 0, NULL) < 0) {\n                close(fds[0]);\n                close(fds[1]);\n                return NULL;\n            }\n        }\n#ifdef HAVE_PIPE2\n    }\n#endif\n\n    if (res != 0)\n        return PyErr_SetFromErrno(PyExc_OSError);\n#endif /* !MS_WINDOWS */\n    return Py_BuildValue(\"(ii)\", fds[0], fds[1]);\n}\n#endif  /* HAVE_PIPE */\n\n\n#ifdef HAVE_PIPE2\n/*[clinic input]\nos.pipe2\n\n    flags: int\n    /\n\nCreate a pipe with flags set atomically.\n\nReturns a tuple of two file descriptors:\n  (read_fd, write_fd)\n\nflags can be constructed by ORing together one or more of these values:\nO_NONBLOCK, O_CLOEXEC.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_pipe2_impl(PyObject *module, int flags)\n/*[clinic end generated code: output=25751fb43a45540f input=f261b6e7e63c6817]*/\n{\n    int fds[2];\n    int res;\n\n    res = pipe2(fds, flags);\n    if (res != 0)\n        return posix_error();\n    return Py_BuildValue(\"(ii)\", fds[0], fds[1]);\n}\n#endif /* HAVE_PIPE2 */\n\n\n#ifdef HAVE_WRITEV\n/*[clinic input]\nos.writev -> Py_ssize_t\n    fd: int\n    buffers: object\n    /\n\nIterate over buffers, and write the contents of each to a file descriptor.\n\nReturns the total number of bytes written.\nbuffers must be a sequence of bytes-like objects.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\nos_writev_impl(PyObject *module, int fd, PyObject *buffers)\n/*[clinic end generated code: output=56565cfac3aac15b input=5b8d17fe4189d2fe]*/\n{\n    Py_ssize_t cnt;\n    Py_ssize_t result;\n    int async_err = 0;\n    struct iovec *iov;\n    Py_buffer *buf;\n\n    if (!PySequence_Check(buffers)) {\n        PyErr_SetString(PyExc_TypeError,\n            \"writev() arg 2 must be a sequence\");\n        return -1;\n    }\n    cnt = PySequence_Size(buffers);\n    if (cnt < 0)\n        return -1;\n\n    if (iov_setup(&iov, &buf, buffers, cnt, PyBUF_SIMPLE) < 0) {\n        return -1;\n    }\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        result = writev(fd, iov, cnt);\n        Py_END_ALLOW_THREADS\n    } while (result < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n\n    if (result < 0 && !async_err)\n        posix_error();\n\n    iov_cleanup(iov, buf, cnt);\n    return result;\n}\n#endif /* HAVE_WRITEV */\n\n\n#ifdef HAVE_PWRITE\n/*[clinic input]\nos.pwrite -> Py_ssize_t\n\n    fd: int\n    buffer: Py_buffer\n    offset: Py_off_t\n    /\n\nWrite bytes to a file descriptor starting at a particular offset.\n\nWrite buffer to fd, starting at offset bytes from the beginning of\nthe file.  Returns the number of bytes written.  Does not change the\ncurrent file offset.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\nos_pwrite_impl(PyObject *module, int fd, Py_buffer *buffer, Py_off_t offset)\n/*[clinic end generated code: output=c74da630758ee925 input=614acbc7e5a0339a]*/\n{\n    Py_ssize_t size;\n    int async_err = 0;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        _Py_BEGIN_SUPPRESS_IPH\n        size = pwrite(fd, buffer->buf, (size_t)buffer->len, offset);\n        _Py_END_SUPPRESS_IPH\n        Py_END_ALLOW_THREADS\n    } while (size < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n\n    if (size < 0 && !async_err)\n        posix_error();\n    return size;\n}\n#endif /* HAVE_PWRITE */\n\n#if defined(HAVE_PWRITEV) || defined (HAVE_PWRITEV2)\n/*[clinic input]\nos.pwritev -> Py_ssize_t\n\n    fd: int\n    buffers: object\n    offset: Py_off_t\n    flags: int = 0\n    /\n\nWrites the contents of bytes-like objects to a file descriptor at a given offset.\n\nCombines the functionality of writev() and pwrite(). All buffers must be a sequence\nof bytes-like objects. Buffers are processed in array order. Entire contents of first\nbuffer is written before proceeding to second, and so on. The operating system may\nset a limit (sysconf() value SC_IOV_MAX) on the number of buffers that can be used.\nThis function writes the contents of each object to the file descriptor and returns\nthe total number of bytes written.\n\nThe flags argument contains a bitwise OR of zero or more of the following flags:\n\n- RWF_DSYNC\n- RWF_SYNC\n- RWF_APPEND\n\nUsing non-zero flags requires Linux 4.7 or newer.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\nos_pwritev_impl(PyObject *module, int fd, PyObject *buffers, Py_off_t offset,\n                int flags)\n/*[clinic end generated code: output=e3dd3e9d11a6a5c7 input=35358c327e1a2a8e]*/\n{\n    Py_ssize_t cnt;\n    Py_ssize_t result;\n    int async_err = 0;\n    struct iovec *iov;\n    Py_buffer *buf;\n\n    if (!PySequence_Check(buffers)) {\n        PyErr_SetString(PyExc_TypeError,\n            \"pwritev() arg 2 must be a sequence\");\n        return -1;\n    }\n\n    cnt = PySequence_Size(buffers);\n    if (cnt < 0) {\n        return -1;\n    }\n\n#ifndef HAVE_PWRITEV2\n    if(flags != 0) {\n        argument_unavailable_error(\"pwritev2\", \"flags\");\n        return -1;\n    }\n#endif\n\n    if (iov_setup(&iov, &buf, buffers, cnt, PyBUF_SIMPLE) < 0) {\n        return -1;\n    }\n#ifdef HAVE_PWRITEV2\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        _Py_BEGIN_SUPPRESS_IPH\n        result = pwritev2(fd, iov, cnt, offset, flags);\n        _Py_END_SUPPRESS_IPH\n        Py_END_ALLOW_THREADS\n    } while (result < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n#else\n\n#if defined(__APPLE__) && defined(__clang__)\n/* This entire function will be removed from the module dict when the API\n * is not available.\n */\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunguarded-availability\"\n#pragma clang diagnostic ignored \"-Wunguarded-availability-new\"\n#endif\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        _Py_BEGIN_SUPPRESS_IPH\n        result = pwritev(fd, iov, cnt, offset);\n        _Py_END_SUPPRESS_IPH\n        Py_END_ALLOW_THREADS\n    } while (result < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n\n#if defined(__APPLE__) && defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n#endif\n\n    if (result < 0) {\n        if (!async_err) {\n            posix_error();\n        }\n        result = -1;\n    }\n    iov_cleanup(iov, buf, cnt);\n\n    return result;\n}\n#endif /* HAVE_PWRITEV */\n\n#ifdef HAVE_COPY_FILE_RANGE\n/*[clinic input]\n\nos.copy_file_range\n    src: int\n        Source file descriptor.\n    dst: int\n        Destination file descriptor.\n    count: Py_ssize_t\n        Number of bytes to copy.\n    offset_src: object = None\n        Starting offset in src.\n    offset_dst: object = None\n        Starting offset in dst.\n\nCopy count bytes from one file descriptor to another.\n\nIf offset_src is None, then src is read from the current position;\nrespectively for offset_dst.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_copy_file_range_impl(PyObject *module, int src, int dst, Py_ssize_t count,\n                        PyObject *offset_src, PyObject *offset_dst)\n/*[clinic end generated code: output=1a91713a1d99fc7a input=42fdce72681b25a9]*/\n{\n    off_t offset_src_val, offset_dst_val;\n    off_t *p_offset_src = NULL;\n    off_t *p_offset_dst = NULL;\n    Py_ssize_t ret;\n    int async_err = 0;\n    /* The flags argument is provided to allow\n     * for future extensions and currently must be to 0. */\n    int flags = 0;\n\n\n    if (count < 0) {\n        PyErr_SetString(PyExc_ValueError, \"negative value for 'count' not allowed\");\n        return NULL;\n    }\n\n    if (offset_src != Py_None) {\n        if (!Py_off_t_converter(offset_src, &offset_src_val)) {\n            return NULL;\n        }\n        p_offset_src = &offset_src_val;\n    }\n\n    if (offset_dst != Py_None) {\n        if (!Py_off_t_converter(offset_dst, &offset_dst_val)) {\n            return NULL;\n        }\n        p_offset_dst = &offset_dst_val;\n    }\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        ret = copy_file_range(src, p_offset_src, dst, p_offset_dst, count, flags);\n        Py_END_ALLOW_THREADS\n    } while (ret < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n\n    if (ret < 0) {\n        return (!async_err) ? posix_error() : NULL;\n    }\n\n    return PyLong_FromSsize_t(ret);\n}\n#endif /* HAVE_COPY_FILE_RANGE*/\n\n#if (defined(HAVE_SPLICE) && !defined(_AIX))\n/*[clinic input]\n\nos.splice\n    src: int\n        Source file descriptor.\n    dst: int\n        Destination file descriptor.\n    count: Py_ssize_t\n        Number of bytes to copy.\n    offset_src: object = None\n        Starting offset in src.\n    offset_dst: object = None\n        Starting offset in dst.\n    flags: unsigned_int = 0\n        Flags to modify the semantics of the call.\n\nTransfer count bytes from one pipe to a descriptor or vice versa.\n\nIf offset_src is None, then src is read from the current position;\nrespectively for offset_dst. The offset associated to the file\ndescriptor that refers to a pipe must be None.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_splice_impl(PyObject *module, int src, int dst, Py_ssize_t count,\n               PyObject *offset_src, PyObject *offset_dst,\n               unsigned int flags)\n/*[clinic end generated code: output=d0386f25a8519dc5 input=047527c66c6d2e0a]*/\n{\n    off_t offset_src_val, offset_dst_val;\n    off_t *p_offset_src = NULL;\n    off_t *p_offset_dst = NULL;\n    Py_ssize_t ret;\n    int async_err = 0;\n\n    if (count < 0) {\n        PyErr_SetString(PyExc_ValueError, \"negative value for 'count' not allowed\");\n        return NULL;\n    }\n\n    if (offset_src != Py_None) {\n        if (!Py_off_t_converter(offset_src, &offset_src_val)) {\n            return NULL;\n        }\n        p_offset_src = &offset_src_val;\n    }\n\n    if (offset_dst != Py_None) {\n        if (!Py_off_t_converter(offset_dst, &offset_dst_val)) {\n            return NULL;\n        }\n        p_offset_dst = &offset_dst_val;\n    }\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        ret = splice(src, p_offset_src, dst, p_offset_dst, count, flags);\n        Py_END_ALLOW_THREADS\n    } while (ret < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));\n\n    if (ret < 0) {\n        return (!async_err) ? posix_error() : NULL;\n    }\n\n    return PyLong_FromSsize_t(ret);\n}\n#endif /* HAVE_SPLICE*/\n\n#ifdef HAVE_MKFIFO\n/*[clinic input]\nos.mkfifo\n\n    path: path_t\n    mode: int=0o666\n    *\n    dir_fd: dir_fd(requires='mkfifoat')=None\n\nCreate a \"fifo\" (a POSIX named pipe).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_mkfifo_impl(PyObject *module, path_t *path, int mode, int dir_fd)\n/*[clinic end generated code: output=ce41cfad0e68c940 input=73032e98a36e0e19]*/\n{\n    int result;\n    int async_err = 0;\n#ifdef HAVE_MKFIFOAT\n    int mkfifoat_unavailable = 0;\n#endif\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_MKFIFOAT\n        if (dir_fd != DEFAULT_DIR_FD) {\n            if (HAVE_MKFIFOAT_RUNTIME) {\n                result = mkfifoat(dir_fd, path->narrow, mode);\n\n            } else {\n                mkfifoat_unavailable = 1;\n                result = 0;\n            }\n        } else\n#endif\n            result = mkfifo(path->narrow, mode);\n        Py_END_ALLOW_THREADS\n    } while (result != 0 && errno == EINTR &&\n             !(async_err = PyErr_CheckSignals()));\n\n#ifdef HAVE_MKFIFOAT\n    if (mkfifoat_unavailable) {\n        argument_unavailable_error(NULL, \"dir_fd\");\n        return NULL;\n    }\n#endif\n\n    if (result != 0)\n        return (!async_err) ? posix_error() : NULL;\n\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_MKFIFO */\n\n\n#if defined(HAVE_MKNOD) && defined(HAVE_MAKEDEV)\n/*[clinic input]\nos.mknod\n\n    path: path_t\n    mode: int=0o600\n    device: dev_t=0\n    *\n    dir_fd: dir_fd(requires='mknodat')=None\n\nCreate a node in the file system.\n\nCreate a node in the file system (file, device special file or named pipe)\nat path.  mode specifies both the permissions to use and the\ntype of node to be created, being combined (bitwise OR) with one of\nS_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO.  If S_IFCHR or S_IFBLK is set on mode,\ndevice defines the newly created device special file (probably using\nos.makedev()).  Otherwise device is ignored.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_mknod_impl(PyObject *module, path_t *path, int mode, dev_t device,\n              int dir_fd)\n/*[clinic end generated code: output=92e55d3ca8917461 input=ee44531551a4d83b]*/\n{\n    int result;\n    int async_err = 0;\n#ifdef HAVE_MKNODAT\n    int mknodat_unavailable = 0;\n#endif\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_MKNODAT\n        if (dir_fd != DEFAULT_DIR_FD) {\n            if (HAVE_MKNODAT_RUNTIME) {\n                result = mknodat(dir_fd, path->narrow, mode, device);\n\n            } else {\n                mknodat_unavailable = 1;\n                result = 0;\n            }\n        } else\n#endif\n            result = mknod(path->narrow, mode, device);\n        Py_END_ALLOW_THREADS\n    } while (result != 0 && errno == EINTR &&\n             !(async_err = PyErr_CheckSignals()));\n#ifdef HAVE_MKNODAT\n    if (mknodat_unavailable) {\n        argument_unavailable_error(NULL, \"dir_fd\");\n        return NULL;\n    }\n#endif\n    if (result != 0)\n        return (!async_err) ? posix_error() : NULL;\n\n    Py_RETURN_NONE;\n}\n#endif /* defined(HAVE_MKNOD) && defined(HAVE_MAKEDEV) */\n\n\n#ifdef HAVE_DEVICE_MACROS\nstatic PyObject *\nmajor_minor_conv(unsigned int value)\n{\n#ifdef NODEV\n    if (value == (unsigned int)NODEV) {\n        return PyLong_FromLong((int)NODEV);\n    }\n#endif\n    return PyLong_FromUnsignedLong(value);\n}\n\nstatic int\nmajor_minor_check(dev_t value)\n{\n#ifdef NODEV\n    if (value == NODEV) {\n        return 1;\n    }\n#endif\n    return (dev_t)(unsigned int)value == value;\n}\n\n/*[clinic input]\nos.major\n\n    device: dev_t\n    /\n\nExtracts a device major number from a raw device number.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_major_impl(PyObject *module, dev_t device)\n/*[clinic end generated code: output=4071ffee17647891 input=b1a0a14ec9448229]*/\n{\n    return major_minor_conv(major(device));\n}\n\n\n/*[clinic input]\nos.minor\n\n    device: dev_t\n    /\n\nExtracts a device minor number from a raw device number.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_minor_impl(PyObject *module, dev_t device)\n/*[clinic end generated code: output=306cb78e3bc5004f input=2f686e463682a9da]*/\n{\n    return major_minor_conv(minor(device));\n}\n\n\n/*[clinic input]\nos.makedev -> dev_t\n\n    major: dev_t\n    minor: dev_t\n    /\n\nComposes a raw device number from the major and minor device numbers.\n[clinic start generated code]*/\n\nstatic dev_t\nos_makedev_impl(PyObject *module, dev_t major, dev_t minor)\n/*[clinic end generated code: output=cad6125c51f5af80 input=2146126ec02e55c1]*/\n{\n    if (!major_minor_check(major) || !major_minor_check(minor)) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"Python int too large to convert to C unsigned int\");\n        return (dev_t)-1;\n    }\n    return makedev(major, minor);\n}\n#endif /* HAVE_DEVICE_MACROS */\n\n\n#if defined HAVE_FTRUNCATE || defined MS_WINDOWS\n/*[clinic input]\nos.ftruncate\n\n    fd: int\n    length: Py_off_t\n    /\n\nTruncate a file, specified by file descriptor, to a specific length.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_ftruncate_impl(PyObject *module, int fd, Py_off_t length)\n/*[clinic end generated code: output=fba15523721be7e4 input=63b43641e52818f2]*/\n{\n    int result;\n    int async_err = 0;\n\n    if (PySys_Audit(\"os.truncate\", \"in\", fd, length) < 0) {\n        return NULL;\n    }\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        _Py_BEGIN_SUPPRESS_IPH\n#ifdef MS_WINDOWS\n        result = _chsize_s(fd, length);\n#else\n        result = ftruncate(fd, length);\n#endif\n        _Py_END_SUPPRESS_IPH\n        Py_END_ALLOW_THREADS\n    } while (result != 0 && errno == EINTR &&\n             !(async_err = PyErr_CheckSignals()));\n    if (result != 0)\n        return (!async_err) ? posix_error() : NULL;\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_FTRUNCATE || MS_WINDOWS */\n\n\n#if defined HAVE_TRUNCATE || defined MS_WINDOWS\n/*[clinic input]\nos.truncate\n    path: path_t(allow_fd='PATH_HAVE_FTRUNCATE')\n    length: Py_off_t\n\nTruncate a file, specified by path, to a specific length.\n\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_truncate_impl(PyObject *module, path_t *path, Py_off_t length)\n/*[clinic end generated code: output=43009c8df5c0a12b input=77229cf0b50a9b77]*/\n{\n    int result;\n#ifdef MS_WINDOWS\n    int fd;\n#endif\n\n    if (path->fd != -1)\n        return os_ftruncate_impl(module, path->fd, length);\n\n    if (PySys_Audit(\"os.truncate\", \"On\", path->object, length) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    _Py_BEGIN_SUPPRESS_IPH\n#ifdef MS_WINDOWS\n    fd = _wopen(path->wide, _O_WRONLY | _O_BINARY | _O_NOINHERIT);\n    if (fd < 0)\n        result = -1;\n    else {\n        result = _chsize_s(fd, length);\n        close(fd);\n        if (result < 0)\n            errno = result;\n    }\n#else\n    result = truncate(path->narrow, length);\n#endif\n    _Py_END_SUPPRESS_IPH\n    Py_END_ALLOW_THREADS\n    if (result < 0)\n        return posix_path_error(path);\n\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_TRUNCATE || MS_WINDOWS */\n\n\n/* Issue #22396: On 32-bit AIX platform, the prototypes of os.posix_fadvise()\n   and os.posix_fallocate() in system headers are wrong if _LARGE_FILES is\n   defined, which is the case in Python on AIX. AIX bug report:\n   http://www-01.ibm.com/support/docview.wss?uid=isg1IV56170 */\n#if defined(_AIX) && defined(_LARGE_FILES) && !defined(__64BIT__)\n#  define POSIX_FADVISE_AIX_BUG\n#endif\n\n\n/* GH-111804: Due to posix_fallocate() not having consistent semantics across\n   OSs, support was dropped in WASI preview2. */\n#if defined(HAVE_POSIX_FALLOCATE) && !defined(POSIX_FADVISE_AIX_BUG) && \\\n    !defined(__wasi__)\n/*[clinic input]\nos.posix_fallocate\n\n    fd: int\n    offset: Py_off_t\n    length: Py_off_t\n    /\n\nEnsure a file has allocated at least a particular number of bytes on disk.\n\nEnsure that the file specified by fd encompasses a range of bytes\nstarting at offset bytes from the beginning and continuing for length bytes.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_posix_fallocate_impl(PyObject *module, int fd, Py_off_t offset,\n                        Py_off_t length)\n/*[clinic end generated code: output=73f107139564aa9d input=d7a2ef0ab2ca52fb]*/\n{\n    int result;\n    int async_err = 0;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        result = posix_fallocate(fd, offset, length);\n        Py_END_ALLOW_THREADS\n    } while (result == EINTR && !(async_err = PyErr_CheckSignals()));\n\n    if (result == 0)\n        Py_RETURN_NONE;\n\n    if (async_err)\n        return NULL;\n\n    errno = result;\n    return posix_error();\n}\n#endif /* HAVE_POSIX_FALLOCATE) && !POSIX_FADVISE_AIX_BUG && !defined(__wasi__) */\n\n\n#if defined(HAVE_POSIX_FADVISE) && !defined(POSIX_FADVISE_AIX_BUG)\n/*[clinic input]\nos.posix_fadvise\n\n    fd: int\n    offset: Py_off_t\n    length: Py_off_t\n    advice: int\n    /\n\nAnnounce an intention to access data in a specific pattern.\n\nAnnounce an intention to access data in a specific pattern, thus allowing\nthe kernel to make optimizations.\nThe advice applies to the region of the file specified by fd starting at\noffset and continuing for length bytes.\nadvice is one of POSIX_FADV_NORMAL, POSIX_FADV_SEQUENTIAL,\nPOSIX_FADV_RANDOM, POSIX_FADV_NOREUSE, POSIX_FADV_WILLNEED, or\nPOSIX_FADV_DONTNEED.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_posix_fadvise_impl(PyObject *module, int fd, Py_off_t offset,\n                      Py_off_t length, int advice)\n/*[clinic end generated code: output=412ef4aa70c98642 input=0fbe554edc2f04b5]*/\n{\n    int result;\n    int async_err = 0;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        result = posix_fadvise(fd, offset, length, advice);\n        Py_END_ALLOW_THREADS\n    } while (result == EINTR && !(async_err = PyErr_CheckSignals()));\n\n    if (result == 0)\n        Py_RETURN_NONE;\n\n    if (async_err)\n        return NULL;\n\n    errno = result;\n    return posix_error();\n}\n#endif /* HAVE_POSIX_FADVISE && !POSIX_FADVISE_AIX_BUG */\n\n\n#ifdef MS_WINDOWS\nstatic PyObject*\nwin32_putenv(PyObject *name, PyObject *value)\n{\n    /* Search from index 1 because on Windows starting '=' is allowed for\n       defining hidden environment variables. */\n    if (PyUnicode_GET_LENGTH(name) == 0 ||\n        PyUnicode_FindChar(name, '=', 1, PyUnicode_GET_LENGTH(name), 1) != -1)\n    {\n        PyErr_SetString(PyExc_ValueError, \"illegal environment variable name\");\n        return NULL;\n    }\n    PyObject *unicode;\n    if (value != NULL) {\n        unicode = PyUnicode_FromFormat(\"%U=%U\", name, value);\n    }\n    else {\n        unicode = PyUnicode_FromFormat(\"%U=\", name);\n    }\n    if (unicode == NULL) {\n        return NULL;\n    }\n\n    Py_ssize_t size;\n    wchar_t *env = PyUnicode_AsWideCharString(unicode, &size);\n    Py_DECREF(unicode);\n\n    if (env == NULL) {\n        return NULL;\n    }\n    if (size > _MAX_ENV) {\n        PyErr_Format(PyExc_ValueError,\n                     \"the environment variable is longer than %u characters\",\n                     _MAX_ENV);\n        PyMem_Free(env);\n        return NULL;\n    }\n    if (wcslen(env) != (size_t)size) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"embedded null character\");\n        PyMem_Free(env);\n        return NULL;\n    }\n\n    /* _wputenv() and SetEnvironmentVariableW() update the environment in the\n       Process Environment Block (PEB). _wputenv() also updates CRT 'environ'\n       and '_wenviron' variables, whereas SetEnvironmentVariableW() does not.\n\n       Prefer _wputenv() to be compatible with C libraries using CRT\n       variables and CRT functions using these variables (ex: getenv()). */\n    int err = _wputenv(env);\n\n    if (err) {\n        posix_error();\n        PyMem_Free(env);\n        return NULL;\n    }\n    PyMem_Free(env);\n\n    Py_RETURN_NONE;\n}\n#endif\n\n\n#ifdef MS_WINDOWS\n/*[clinic input]\nos.putenv\n\n    name: unicode\n    value: unicode\n    /\n\nChange or add an environment variable.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_putenv_impl(PyObject *module, PyObject *name, PyObject *value)\n/*[clinic end generated code: output=d29a567d6b2327d2 input=ba586581c2e6105f]*/\n{\n    if (PySys_Audit(\"os.putenv\", \"OO\", name, value) < 0) {\n        return NULL;\n    }\n    return win32_putenv(name, value);\n}\n#else\n/*[clinic input]\nos.putenv\n\n    name: FSConverter\n    value: FSConverter\n    /\n\nChange or add an environment variable.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_putenv_impl(PyObject *module, PyObject *name, PyObject *value)\n/*[clinic end generated code: output=d29a567d6b2327d2 input=a97bc6152f688d31]*/\n{\n    const char *name_string = PyBytes_AS_STRING(name);\n    const char *value_string = PyBytes_AS_STRING(value);\n\n    if (strchr(name_string, '=') != NULL) {\n        PyErr_SetString(PyExc_ValueError, \"illegal environment variable name\");\n        return NULL;\n    }\n\n    if (PySys_Audit(\"os.putenv\", \"OO\", name, value) < 0) {\n        return NULL;\n    }\n\n    if (setenv(name_string, value_string, 1)) {\n        return posix_error();\n    }\n    Py_RETURN_NONE;\n}\n#endif  /* !defined(MS_WINDOWS) */\n\n\n#ifdef MS_WINDOWS\n/*[clinic input]\nos.unsetenv\n    name: unicode\n    /\n\nDelete an environment variable.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_unsetenv_impl(PyObject *module, PyObject *name)\n/*[clinic end generated code: output=54c4137ab1834f02 input=4d6a1747cc526d2f]*/\n{\n    if (PySys_Audit(\"os.unsetenv\", \"(O)\", name) < 0) {\n        return NULL;\n    }\n    return win32_putenv(name, NULL);\n}\n#else\n/*[clinic input]\nos.unsetenv\n    name: FSConverter\n    /\n\nDelete an environment variable.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_unsetenv_impl(PyObject *module, PyObject *name)\n/*[clinic end generated code: output=54c4137ab1834f02 input=2bb5288a599c7107]*/\n{\n    if (PySys_Audit(\"os.unsetenv\", \"(O)\", name) < 0) {\n        return NULL;\n    }\n#ifdef HAVE_BROKEN_UNSETENV\n    unsetenv(PyBytes_AS_STRING(name));\n#else\n    int err = unsetenv(PyBytes_AS_STRING(name));\n    if (err) {\n        return posix_error();\n    }\n#endif\n\n    Py_RETURN_NONE;\n}\n#endif /* !MS_WINDOWS */\n\n\n/*[clinic input]\nos.strerror\n\n    code: int\n    /\n\nTranslate an error code to a message string.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_strerror_impl(PyObject *module, int code)\n/*[clinic end generated code: output=baebf09fa02a78f2 input=75a8673d97915a91]*/\n{\n    char *message = strerror(code);\n    if (message == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"strerror() argument out of range\");\n        return NULL;\n    }\n    return PyUnicode_DecodeLocale(message, \"surrogateescape\");\n}\n\n\n#ifdef HAVE_SYS_WAIT_H\n#ifdef WCOREDUMP\n/*[clinic input]\nos.WCOREDUMP -> bool\n\n    status: int\n    /\n\nReturn True if the process returning status was dumped to a core file.\n[clinic start generated code]*/\n\nstatic int\nos_WCOREDUMP_impl(PyObject *module, int status)\n/*[clinic end generated code: output=1a584b147b16bd18 input=8b05e7ab38528d04]*/\n{\n    WAIT_TYPE wait_status;\n    WAIT_STATUS_INT(wait_status) = status;\n    return WCOREDUMP(wait_status);\n}\n#endif /* WCOREDUMP */\n\n\n#ifdef WIFCONTINUED\n/*[clinic input]\nos.WIFCONTINUED -> bool\n\n    status: int\n\nReturn True if a particular process was continued from a job control stop.\n\nReturn True if the process returning status was continued from a\njob control stop.\n[clinic start generated code]*/\n\nstatic int\nos_WIFCONTINUED_impl(PyObject *module, int status)\n/*[clinic end generated code: output=1e35295d844364bd input=e777e7d38eb25bd9]*/\n{\n    WAIT_TYPE wait_status;\n    WAIT_STATUS_INT(wait_status) = status;\n    return WIFCONTINUED(wait_status);\n}\n#endif /* WIFCONTINUED */\n\n\n#ifdef WIFSTOPPED\n/*[clinic input]\nos.WIFSTOPPED -> bool\n\n    status: int\n\nReturn True if the process returning status was stopped.\n[clinic start generated code]*/\n\nstatic int\nos_WIFSTOPPED_impl(PyObject *module, int status)\n/*[clinic end generated code: output=fdb57122a5c9b4cb input=043cb7f1289ef904]*/\n{\n    WAIT_TYPE wait_status;\n    WAIT_STATUS_INT(wait_status) = status;\n    return WIFSTOPPED(wait_status);\n}\n#endif /* WIFSTOPPED */\n\n\n#ifdef WIFSIGNALED\n/*[clinic input]\nos.WIFSIGNALED -> bool\n\n    status: int\n\nReturn True if the process returning status was terminated by a signal.\n[clinic start generated code]*/\n\nstatic int\nos_WIFSIGNALED_impl(PyObject *module, int status)\n/*[clinic end generated code: output=d1dde4dcc819a5f5 input=d55ba7cc9ce5dc43]*/\n{\n    WAIT_TYPE wait_status;\n    WAIT_STATUS_INT(wait_status) = status;\n    return WIFSIGNALED(wait_status);\n}\n#endif /* WIFSIGNALED */\n\n\n#ifdef WIFEXITED\n/*[clinic input]\nos.WIFEXITED -> bool\n\n    status: int\n\nReturn True if the process returning status exited via the exit() system call.\n[clinic start generated code]*/\n\nstatic int\nos_WIFEXITED_impl(PyObject *module, int status)\n/*[clinic end generated code: output=01c09d6ebfeea397 input=d63775a6791586c0]*/\n{\n    WAIT_TYPE wait_status;\n    WAIT_STATUS_INT(wait_status) = status;\n    return WIFEXITED(wait_status);\n}\n#endif /* WIFEXITED */\n\n\n#ifdef WEXITSTATUS\n/*[clinic input]\nos.WEXITSTATUS -> int\n\n    status: int\n\nReturn the process return code from status.\n[clinic start generated code]*/\n\nstatic int\nos_WEXITSTATUS_impl(PyObject *module, int status)\n/*[clinic end generated code: output=6e3efbba11f6488d input=e1fb4944e377585b]*/\n{\n    WAIT_TYPE wait_status;\n    WAIT_STATUS_INT(wait_status) = status;\n    return WEXITSTATUS(wait_status);\n}\n#endif /* WEXITSTATUS */\n\n\n#ifdef WTERMSIG\n/*[clinic input]\nos.WTERMSIG -> int\n\n    status: int\n\nReturn the signal that terminated the process that provided the status value.\n[clinic start generated code]*/\n\nstatic int\nos_WTERMSIG_impl(PyObject *module, int status)\n/*[clinic end generated code: output=172f7dfc8dcfc3ad input=727fd7f84ec3f243]*/\n{\n    WAIT_TYPE wait_status;\n    WAIT_STATUS_INT(wait_status) = status;\n    return WTERMSIG(wait_status);\n}\n#endif /* WTERMSIG */\n\n\n#ifdef WSTOPSIG\n/*[clinic input]\nos.WSTOPSIG -> int\n\n    status: int\n\nReturn the signal that stopped the process that provided the status value.\n[clinic start generated code]*/\n\nstatic int\nos_WSTOPSIG_impl(PyObject *module, int status)\n/*[clinic end generated code: output=0ab7586396f5d82b input=46ebf1d1b293c5c1]*/\n{\n    WAIT_TYPE wait_status;\n    WAIT_STATUS_INT(wait_status) = status;\n    return WSTOPSIG(wait_status);\n}\n#endif /* WSTOPSIG */\n#endif /* HAVE_SYS_WAIT_H */\n\n\n#if defined(HAVE_FSTATVFS) && defined(HAVE_SYS_STATVFS_H)\n#ifdef _SCO_DS\n/* SCO OpenServer 5.0 and later requires _SVID3 before it reveals the\n   needed definitions in sys/statvfs.h */\n#define _SVID3\n#endif\n#include <sys/statvfs.h>\n\n#ifdef __APPLE__\n/* On macOS struct statvfs uses 32-bit integers for block counts,\n * resulting in overflow when filesystems are larger than 4TB. Therefore\n * os.statvfs is implemented in terms of statfs(2).\n */\n\nstatic PyObject*\n_pystatvfs_fromstructstatfs(PyObject *module, struct statfs st) {\n    PyObject *StatVFSResultType = get_posix_state(module)->StatVFSResultType;\n    PyObject *v = PyStructSequence_New((PyTypeObject *)StatVFSResultType);\n    if (v == NULL) {\n        return NULL;\n    }\n\n    long flags = 0;\n    if (st.f_flags & MNT_RDONLY) {\n        flags |= ST_RDONLY;\n    }\n    if (st.f_flags & MNT_NOSUID) {\n        flags |= ST_NOSUID;\n    }\n\n    _Static_assert(sizeof(st.f_blocks) == sizeof(long long), \"assuming large file\");\n\n#define SET_ITEM(SEQ, INDEX, EXPR)                       \\\n    do {                                                 \\\n        PyObject *obj = (EXPR);                          \\\n        if (obj == NULL) {                               \\\n            Py_DECREF((SEQ));                            \\\n            return NULL;                                 \\\n        }                                                \\\n        PyStructSequence_SET_ITEM((SEQ), (INDEX), obj);  \\\n    } while (0)\n\n    SET_ITEM(v, 0, PyLong_FromLong((long) st.f_iosize));\n    SET_ITEM(v, 1, PyLong_FromLong((long) st.f_bsize));\n    SET_ITEM(v, 2, PyLong_FromLongLong((long long) st.f_blocks));\n    SET_ITEM(v, 3, PyLong_FromLongLong((long long) st.f_bfree));\n    SET_ITEM(v, 4, PyLong_FromLongLong((long long) st.f_bavail));\n    SET_ITEM(v, 5, PyLong_FromLongLong((long long) st.f_files));\n    SET_ITEM(v, 6, PyLong_FromLongLong((long long) st.f_ffree));\n    SET_ITEM(v, 7, PyLong_FromLongLong((long long) st.f_ffree));\n    SET_ITEM(v, 8, PyLong_FromLong((long) flags));\n\n    SET_ITEM(v, 9, PyLong_FromLong((long) NAME_MAX));\n    SET_ITEM(v, 10, PyLong_FromUnsignedLong(st.f_fsid.val[0]));\n\n#undef SET_ITEM\n\n    return v;\n}\n\n#else\n\n\n\nstatic PyObject*\n_pystatvfs_fromstructstatvfs(PyObject *module, struct statvfs st) {\n    PyObject *StatVFSResultType = get_posix_state(module)->StatVFSResultType;\n    PyObject *v = PyStructSequence_New((PyTypeObject *)StatVFSResultType);\n    if (v == NULL)\n        return NULL;\n\n    int pos = 0;\n\n#define SET_RESULT(CALL)                                     \\\n    do {                                                     \\\n        PyObject *item = (CALL);                             \\\n        if (item == NULL) {                                  \\\n            Py_DECREF(v);                                    \\\n            return NULL;                                     \\\n        }                                                    \\\n        PyStructSequence_SET_ITEM(v, pos++, item);           \\\n    } while(0)\n\n#if !defined(HAVE_LARGEFILE_SUPPORT)\n    SET_RESULT(PyLong_FromLong((long) st.f_bsize));\n    SET_RESULT(PyLong_FromLong((long) st.f_frsize));\n    SET_RESULT(PyLong_FromLong((long) st.f_blocks));\n    SET_RESULT(PyLong_FromLong((long) st.f_bfree));\n    SET_RESULT(PyLong_FromLong((long) st.f_bavail));\n    SET_RESULT(PyLong_FromLong((long) st.f_files));\n    SET_RESULT(PyLong_FromLong((long) st.f_ffree));\n    SET_RESULT(PyLong_FromLong((long) st.f_favail));\n    SET_RESULT(PyLong_FromLong((long) st.f_flag));\n    SET_RESULT(PyLong_FromLong((long) st.f_namemax));\n#else\n    SET_RESULT(PyLong_FromLong((long) st.f_bsize));\n    SET_RESULT(PyLong_FromLong((long) st.f_frsize));\n    SET_RESULT(PyLong_FromLongLong((long long) st.f_blocks));\n    SET_RESULT(PyLong_FromLongLong((long long) st.f_bfree));\n    SET_RESULT(PyLong_FromLongLong((long long) st.f_bavail));\n    SET_RESULT(PyLong_FromLongLong((long long) st.f_files));\n    SET_RESULT(PyLong_FromLongLong((long long) st.f_ffree));\n    SET_RESULT(PyLong_FromLongLong((long long) st.f_favail));\n    SET_RESULT(PyLong_FromLong((long) st.f_flag));\n    SET_RESULT(PyLong_FromLong((long) st.f_namemax));\n#endif\n/* The _ALL_SOURCE feature test macro defines f_fsid as a structure\n * (issue #32390). */\n#if defined(_AIX) && defined(_ALL_SOURCE)\n    SET_RESULT(PyLong_FromUnsignedLong(st.f_fsid.val[0]));\n#else\n    SET_RESULT(PyLong_FromUnsignedLong(st.f_fsid));\n#endif\n\n#undef SET_RESULT\n\n    return v;\n}\n\n#endif\n\n\n/*[clinic input]\nos.fstatvfs\n    fd: int\n    /\n\nPerform an fstatvfs system call on the given fd.\n\nEquivalent to statvfs(fd).\n[clinic start generated code]*/\n\nstatic PyObject *\nos_fstatvfs_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=53547cf0cc55e6c5 input=d8122243ac50975e]*/\n{\n    int result;\n    int async_err = 0;\n#ifdef __APPLE__\n    struct statfs st;\n    /* On macOS os.fstatvfs is implemented using fstatfs(2) because\n     * the former uses 32-bit values for block counts.\n     */\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        result = fstatfs(fd, &st);\n        Py_END_ALLOW_THREADS\n    } while (result != 0 && errno == EINTR &&\n             !(async_err = PyErr_CheckSignals()));\n    if (result != 0)\n        return (!async_err) ? posix_error() : NULL;\n\n    return _pystatvfs_fromstructstatfs(module, st);\n#else\n    struct statvfs st;\n\n    do {\n        Py_BEGIN_ALLOW_THREADS\n        result = fstatvfs(fd, &st);\n        Py_END_ALLOW_THREADS\n    } while (result != 0 && errno == EINTR &&\n             !(async_err = PyErr_CheckSignals()));\n    if (result != 0)\n        return (!async_err) ? posix_error() : NULL;\n\n    return _pystatvfs_fromstructstatvfs(module, st);\n#endif\n}\n#endif /* defined(HAVE_FSTATVFS) && defined(HAVE_SYS_STATVFS_H) */\n\n\n#if defined(HAVE_STATVFS) && defined(HAVE_SYS_STATVFS_H)\n#include <sys/statvfs.h>\n/*[clinic input]\nos.statvfs\n\n    path: path_t(allow_fd='PATH_HAVE_FSTATVFS')\n\nPerform a statvfs system call on the given path.\n\npath may always be specified as a string.\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_statvfs_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=87106dd1beb8556e input=3f5c35791c669bd9]*/\n{\n    int result;\n\n#ifdef __APPLE__\n    /* On macOS os.statvfs is implemented using statfs(2)/fstatfs(2) because\n     * the former uses 32-bit values for block counts.\n     */\n    struct statfs st;\n\n    Py_BEGIN_ALLOW_THREADS\n    if (path->fd != -1) {\n        result = fstatfs(path->fd, &st);\n    }\n    else\n        result = statfs(path->narrow, &st);\n    Py_END_ALLOW_THREADS\n\n    if (result) {\n        return path_error(path);\n    }\n\n    return _pystatvfs_fromstructstatfs(module, st);\n\n#else\n    struct statvfs st;\n\n    Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_FSTATVFS\n    if (path->fd != -1) {\n        result = fstatvfs(path->fd, &st);\n    }\n    else\n#endif\n        result = statvfs(path->narrow, &st);\n    Py_END_ALLOW_THREADS\n\n    if (result) {\n        return path_error(path);\n    }\n\n    return _pystatvfs_fromstructstatvfs(module, st);\n#endif\n}\n#endif /* defined(HAVE_STATVFS) && defined(HAVE_SYS_STATVFS_H) */\n\n\n#ifdef MS_WINDOWS\n/*[clinic input]\nos._getdiskusage\n\n    path: path_t\n\nReturn disk usage statistics about the given path as a (total, free) tuple.\n[clinic start generated code]*/\n\nstatic PyObject *\nos__getdiskusage_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=3bd3991f5e5c5dfb input=6af8d1b7781cc042]*/\n{\n    BOOL retval;\n    ULARGE_INTEGER _, total, free;\n    DWORD err = 0;\n\n    Py_BEGIN_ALLOW_THREADS\n    retval = GetDiskFreeSpaceExW(path->wide, &_, &total, &free);\n    Py_END_ALLOW_THREADS\n    if (retval == 0) {\n        if (GetLastError() == ERROR_DIRECTORY) {\n            wchar_t *dir_path = NULL;\n\n            dir_path = PyMem_New(wchar_t, path->length + 1);\n            if (dir_path == NULL) {\n                return PyErr_NoMemory();\n            }\n\n            wcscpy_s(dir_path, path->length + 1, path->wide);\n\n            if (_dirnameW(dir_path) != -1) {\n                Py_BEGIN_ALLOW_THREADS\n                retval = GetDiskFreeSpaceExW(dir_path, &_, &total, &free);\n                Py_END_ALLOW_THREADS\n            }\n            /* Record the last error in case it's modified by PyMem_Free. */\n            err = GetLastError();\n            PyMem_Free(dir_path);\n            if (retval) {\n                goto success;\n            }\n        }\n        return PyErr_SetFromWindowsErr(err);\n    }\n\nsuccess:\n    return Py_BuildValue(\"(LL)\", total.QuadPart, free.QuadPart);\n}\n#endif /* MS_WINDOWS */\n\n\n/* This is used for fpathconf(), pathconf(), confstr() and sysconf().\n * It maps strings representing configuration variable names to\n * integer values, allowing those functions to be called with the\n * magic names instead of polluting the module's namespace with tons of\n * rarely-used constants.  There are three separate tables that use\n * these definitions.\n *\n * This code is always included, even if none of the interfaces that\n * need it are included.  The #if hackery needed to avoid it would be\n * sufficiently pervasive that it's not worth the loss of readability.\n */\nstruct constdef {\n    const char *name;\n    int value;\n};\n\nstatic int\nconv_confname(PyObject *arg, int *valuep, struct constdef *table,\n              size_t tablesize)\n{\n    if (PyLong_Check(arg)) {\n        int value = PyLong_AsInt(arg);\n        if (value == -1 && PyErr_Occurred())\n            return 0;\n        *valuep = value;\n        return 1;\n    }\n    else {\n        /* look up the value in the table using a binary search */\n        size_t lo = 0;\n        size_t mid;\n        size_t hi = tablesize;\n        int cmp;\n        const char *confname;\n        if (!PyUnicode_Check(arg)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"configuration names must be strings or integers\");\n            return 0;\n        }\n        confname = PyUnicode_AsUTF8(arg);\n        if (confname == NULL)\n            return 0;\n        while (lo < hi) {\n            mid = (lo + hi) / 2;\n            cmp = strcmp(confname, table[mid].name);\n            if (cmp < 0)\n                hi = mid;\n            else if (cmp > 0)\n                lo = mid + 1;\n            else {\n                *valuep = table[mid].value;\n                return 1;\n            }\n        }\n        PyErr_SetString(PyExc_ValueError, \"unrecognized configuration name\");\n        return 0;\n    }\n}\n\n\n#if defined(HAVE_FPATHCONF) || defined(HAVE_PATHCONF)\nstatic struct constdef  posix_constants_pathconf[] = {\n#ifdef _PC_ABI_AIO_XFER_MAX\n    {\"PC_ABI_AIO_XFER_MAX\",     _PC_ABI_AIO_XFER_MAX},\n#endif\n#ifdef _PC_ABI_ASYNC_IO\n    {\"PC_ABI_ASYNC_IO\", _PC_ABI_ASYNC_IO},\n#endif\n#ifdef _PC_ASYNC_IO\n    {\"PC_ASYNC_IO\",     _PC_ASYNC_IO},\n#endif\n#ifdef _PC_CHOWN_RESTRICTED\n    {\"PC_CHOWN_RESTRICTED\",     _PC_CHOWN_RESTRICTED},\n#endif\n#ifdef _PC_FILESIZEBITS\n    {\"PC_FILESIZEBITS\", _PC_FILESIZEBITS},\n#endif\n#ifdef _PC_LAST\n    {\"PC_LAST\", _PC_LAST},\n#endif\n#ifdef _PC_LINK_MAX\n    {\"PC_LINK_MAX\",     _PC_LINK_MAX},\n#endif\n#ifdef _PC_MAX_CANON\n    {\"PC_MAX_CANON\",    _PC_MAX_CANON},\n#endif\n#ifdef _PC_MAX_INPUT\n    {\"PC_MAX_INPUT\",    _PC_MAX_INPUT},\n#endif\n#ifdef _PC_NAME_MAX\n    {\"PC_NAME_MAX\",     _PC_NAME_MAX},\n#endif\n#ifdef _PC_NO_TRUNC\n    {\"PC_NO_TRUNC\",     _PC_NO_TRUNC},\n#endif\n#ifdef _PC_PATH_MAX\n    {\"PC_PATH_MAX\",     _PC_PATH_MAX},\n#endif\n#ifdef _PC_PIPE_BUF\n    {\"PC_PIPE_BUF\",     _PC_PIPE_BUF},\n#endif\n#ifdef _PC_PRIO_IO\n    {\"PC_PRIO_IO\",      _PC_PRIO_IO},\n#endif\n#ifdef _PC_SOCK_MAXBUF\n    {\"PC_SOCK_MAXBUF\",  _PC_SOCK_MAXBUF},\n#endif\n#ifdef _PC_SYNC_IO\n    {\"PC_SYNC_IO\",      _PC_SYNC_IO},\n#endif\n#ifdef _PC_VDISABLE\n    {\"PC_VDISABLE\",     _PC_VDISABLE},\n#endif\n#ifdef _PC_ACL_ENABLED\n    {\"PC_ACL_ENABLED\",  _PC_ACL_ENABLED},\n#endif\n#ifdef _PC_MIN_HOLE_SIZE\n    {\"PC_MIN_HOLE_SIZE\",    _PC_MIN_HOLE_SIZE},\n#endif\n#ifdef _PC_ALLOC_SIZE_MIN\n    {\"PC_ALLOC_SIZE_MIN\",   _PC_ALLOC_SIZE_MIN},\n#endif\n#ifdef _PC_REC_INCR_XFER_SIZE\n    {\"PC_REC_INCR_XFER_SIZE\",   _PC_REC_INCR_XFER_SIZE},\n#endif\n#ifdef _PC_REC_MAX_XFER_SIZE\n    {\"PC_REC_MAX_XFER_SIZE\",    _PC_REC_MAX_XFER_SIZE},\n#endif\n#ifdef _PC_REC_MIN_XFER_SIZE\n    {\"PC_REC_MIN_XFER_SIZE\",    _PC_REC_MIN_XFER_SIZE},\n#endif\n#ifdef _PC_REC_XFER_ALIGN\n    {\"PC_REC_XFER_ALIGN\",   _PC_REC_XFER_ALIGN},\n#endif\n#ifdef _PC_SYMLINK_MAX\n    {\"PC_SYMLINK_MAX\",  _PC_SYMLINK_MAX},\n#endif\n#ifdef _PC_XATTR_ENABLED\n    {\"PC_XATTR_ENABLED\",    _PC_XATTR_ENABLED},\n#endif\n#ifdef _PC_XATTR_EXISTS\n    {\"PC_XATTR_EXISTS\", _PC_XATTR_EXISTS},\n#endif\n#ifdef _PC_TIMESTAMP_RESOLUTION\n    {\"PC_TIMESTAMP_RESOLUTION\", _PC_TIMESTAMP_RESOLUTION},\n#endif\n};\n\nstatic int\nconv_path_confname(PyObject *arg, int *valuep)\n{\n    return conv_confname(arg, valuep, posix_constants_pathconf,\n                         sizeof(posix_constants_pathconf)\n                           / sizeof(struct constdef));\n}\n#endif\n\n\n#ifdef HAVE_FPATHCONF\n/*[clinic input]\nos.fpathconf -> long\n\n    fd: fildes\n    name: path_confname\n    /\n\nReturn the configuration limit name for the file descriptor fd.\n\nIf there is no limit, return -1.\n[clinic start generated code]*/\n\nstatic long\nos_fpathconf_impl(PyObject *module, int fd, int name)\n/*[clinic end generated code: output=d5b7042425fc3e21 input=5b8d2471cfaae186]*/\n{\n    long limit;\n\n    errno = 0;\n    limit = fpathconf(fd, name);\n    if (limit == -1 && errno != 0)\n        posix_error();\n\n    return limit;\n}\n#endif /* HAVE_FPATHCONF */\n\n\n#ifdef HAVE_PATHCONF\n/*[clinic input]\nos.pathconf -> long\n    path: path_t(allow_fd='PATH_HAVE_FPATHCONF')\n    name: path_confname\n\nReturn the configuration limit name for the file or directory path.\n\nIf there is no limit, return -1.\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.\n[clinic start generated code]*/\n\nstatic long\nos_pathconf_impl(PyObject *module, path_t *path, int name)\n/*[clinic end generated code: output=5bedee35b293a089 input=bc3e2a985af27e5e]*/\n{\n    long limit;\n\n    errno = 0;\n#ifdef HAVE_FPATHCONF\n    if (path->fd != -1)\n        limit = fpathconf(path->fd, name);\n    else\n#endif\n        limit = pathconf(path->narrow, name);\n    if (limit == -1 && errno != 0) {\n        if (errno == EINVAL)\n            /* could be a path or name problem */\n            posix_error();\n        else\n            path_error(path);\n    }\n\n    return limit;\n}\n#endif /* HAVE_PATHCONF */\n\n#ifdef HAVE_CONFSTR\nstatic struct constdef posix_constants_confstr[] = {\n#ifdef _CS_ARCHITECTURE\n    {\"CS_ARCHITECTURE\", _CS_ARCHITECTURE},\n#endif\n#ifdef _CS_GNU_LIBC_VERSION\n    {\"CS_GNU_LIBC_VERSION\",     _CS_GNU_LIBC_VERSION},\n#endif\n#ifdef _CS_GNU_LIBPTHREAD_VERSION\n    {\"CS_GNU_LIBPTHREAD_VERSION\",       _CS_GNU_LIBPTHREAD_VERSION},\n#endif\n#ifdef _CS_HOSTNAME\n    {\"CS_HOSTNAME\",     _CS_HOSTNAME},\n#endif\n#ifdef _CS_HW_PROVIDER\n    {\"CS_HW_PROVIDER\",  _CS_HW_PROVIDER},\n#endif\n#ifdef _CS_HW_SERIAL\n    {\"CS_HW_SERIAL\",    _CS_HW_SERIAL},\n#endif\n#ifdef _CS_INITTAB_NAME\n    {\"CS_INITTAB_NAME\", _CS_INITTAB_NAME},\n#endif\n#ifdef _CS_LFS64_CFLAGS\n    {\"CS_LFS64_CFLAGS\", _CS_LFS64_CFLAGS},\n#endif\n#ifdef _CS_LFS64_LDFLAGS\n    {\"CS_LFS64_LDFLAGS\",        _CS_LFS64_LDFLAGS},\n#endif\n#ifdef _CS_LFS64_LIBS\n    {\"CS_LFS64_LIBS\",   _CS_LFS64_LIBS},\n#endif\n#ifdef _CS_LFS64_LINTFLAGS\n    {\"CS_LFS64_LINTFLAGS\",      _CS_LFS64_LINTFLAGS},\n#endif\n#ifdef _CS_LFS_CFLAGS\n    {\"CS_LFS_CFLAGS\",   _CS_LFS_CFLAGS},\n#endif\n#ifdef _CS_LFS_LDFLAGS\n    {\"CS_LFS_LDFLAGS\",  _CS_LFS_LDFLAGS},\n#endif\n#ifdef _CS_LFS_LIBS\n    {\"CS_LFS_LIBS\",     _CS_LFS_LIBS},\n#endif\n#ifdef _CS_LFS_LINTFLAGS\n    {\"CS_LFS_LINTFLAGS\",        _CS_LFS_LINTFLAGS},\n#endif\n#ifdef _CS_MACHINE\n    {\"CS_MACHINE\",      _CS_MACHINE},\n#endif\n#ifdef _CS_PATH\n    {\"CS_PATH\", _CS_PATH},\n#endif\n#ifdef _CS_RELEASE\n    {\"CS_RELEASE\",      _CS_RELEASE},\n#endif\n#ifdef _CS_SRPC_DOMAIN\n    {\"CS_SRPC_DOMAIN\",  _CS_SRPC_DOMAIN},\n#endif\n#ifdef _CS_SYSNAME\n    {\"CS_SYSNAME\",      _CS_SYSNAME},\n#endif\n#ifdef _CS_VERSION\n    {\"CS_VERSION\",      _CS_VERSION},\n#endif\n#ifdef _CS_XBS5_ILP32_OFF32_CFLAGS\n    {\"CS_XBS5_ILP32_OFF32_CFLAGS\",      _CS_XBS5_ILP32_OFF32_CFLAGS},\n#endif\n#ifdef _CS_XBS5_ILP32_OFF32_LDFLAGS\n    {\"CS_XBS5_ILP32_OFF32_LDFLAGS\",     _CS_XBS5_ILP32_OFF32_LDFLAGS},\n#endif\n#ifdef _CS_XBS5_ILP32_OFF32_LIBS\n    {\"CS_XBS5_ILP32_OFF32_LIBS\",        _CS_XBS5_ILP32_OFF32_LIBS},\n#endif\n#ifdef _CS_XBS5_ILP32_OFF32_LINTFLAGS\n    {\"CS_XBS5_ILP32_OFF32_LINTFLAGS\",   _CS_XBS5_ILP32_OFF32_LINTFLAGS},\n#endif\n#ifdef _CS_XBS5_ILP32_OFFBIG_CFLAGS\n    {\"CS_XBS5_ILP32_OFFBIG_CFLAGS\",     _CS_XBS5_ILP32_OFFBIG_CFLAGS},\n#endif\n#ifdef _CS_XBS5_ILP32_OFFBIG_LDFLAGS\n    {\"CS_XBS5_ILP32_OFFBIG_LDFLAGS\",    _CS_XBS5_ILP32_OFFBIG_LDFLAGS},\n#endif\n#ifdef _CS_XBS5_ILP32_OFFBIG_LIBS\n    {\"CS_XBS5_ILP32_OFFBIG_LIBS\",       _CS_XBS5_ILP32_OFFBIG_LIBS},\n#endif\n#ifdef _CS_XBS5_ILP32_OFFBIG_LINTFLAGS\n    {\"CS_XBS5_ILP32_OFFBIG_LINTFLAGS\",  _CS_XBS5_ILP32_OFFBIG_LINTFLAGS},\n#endif\n#ifdef _CS_XBS5_LP64_OFF64_CFLAGS\n    {\"CS_XBS5_LP64_OFF64_CFLAGS\",       _CS_XBS5_LP64_OFF64_CFLAGS},\n#endif\n#ifdef _CS_XBS5_LP64_OFF64_LDFLAGS\n    {\"CS_XBS5_LP64_OFF64_LDFLAGS\",      _CS_XBS5_LP64_OFF64_LDFLAGS},\n#endif\n#ifdef _CS_XBS5_LP64_OFF64_LIBS\n    {\"CS_XBS5_LP64_OFF64_LIBS\", _CS_XBS5_LP64_OFF64_LIBS},\n#endif\n#ifdef _CS_XBS5_LP64_OFF64_LINTFLAGS\n    {\"CS_XBS5_LP64_OFF64_LINTFLAGS\",    _CS_XBS5_LP64_OFF64_LINTFLAGS},\n#endif\n#ifdef _CS_XBS5_LPBIG_OFFBIG_CFLAGS\n    {\"CS_XBS5_LPBIG_OFFBIG_CFLAGS\",     _CS_XBS5_LPBIG_OFFBIG_CFLAGS},\n#endif\n#ifdef _CS_XBS5_LPBIG_OFFBIG_LDFLAGS\n    {\"CS_XBS5_LPBIG_OFFBIG_LDFLAGS\",    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS},\n#endif\n#ifdef _CS_XBS5_LPBIG_OFFBIG_LIBS\n    {\"CS_XBS5_LPBIG_OFFBIG_LIBS\",       _CS_XBS5_LPBIG_OFFBIG_LIBS},\n#endif\n#ifdef _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS\n    {\"CS_XBS5_LPBIG_OFFBIG_LINTFLAGS\",  _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS},\n#endif\n#ifdef _MIPS_CS_AVAIL_PROCESSORS\n    {\"MIPS_CS_AVAIL_PROCESSORS\",        _MIPS_CS_AVAIL_PROCESSORS},\n#endif\n#ifdef _MIPS_CS_BASE\n    {\"MIPS_CS_BASE\",    _MIPS_CS_BASE},\n#endif\n#ifdef _MIPS_CS_HOSTID\n    {\"MIPS_CS_HOSTID\",  _MIPS_CS_HOSTID},\n#endif\n#ifdef _MIPS_CS_HW_NAME\n    {\"MIPS_CS_HW_NAME\", _MIPS_CS_HW_NAME},\n#endif\n#ifdef _MIPS_CS_NUM_PROCESSORS\n    {\"MIPS_CS_NUM_PROCESSORS\",  _MIPS_CS_NUM_PROCESSORS},\n#endif\n#ifdef _MIPS_CS_OSREL_MAJ\n    {\"MIPS_CS_OSREL_MAJ\",       _MIPS_CS_OSREL_MAJ},\n#endif\n#ifdef _MIPS_CS_OSREL_MIN\n    {\"MIPS_CS_OSREL_MIN\",       _MIPS_CS_OSREL_MIN},\n#endif\n#ifdef _MIPS_CS_OSREL_PATCH\n    {\"MIPS_CS_OSREL_PATCH\",     _MIPS_CS_OSREL_PATCH},\n#endif\n#ifdef _MIPS_CS_OS_NAME\n    {\"MIPS_CS_OS_NAME\", _MIPS_CS_OS_NAME},\n#endif\n#ifdef _MIPS_CS_OS_PROVIDER\n    {\"MIPS_CS_OS_PROVIDER\",     _MIPS_CS_OS_PROVIDER},\n#endif\n#ifdef _MIPS_CS_PROCESSORS\n    {\"MIPS_CS_PROCESSORS\",      _MIPS_CS_PROCESSORS},\n#endif\n#ifdef _MIPS_CS_SERIAL\n    {\"MIPS_CS_SERIAL\",  _MIPS_CS_SERIAL},\n#endif\n#ifdef _MIPS_CS_VENDOR\n    {\"MIPS_CS_VENDOR\",  _MIPS_CS_VENDOR},\n#endif\n};\n\nstatic int\nconv_confstr_confname(PyObject *arg, int *valuep)\n{\n    return conv_confname(arg, valuep, posix_constants_confstr,\n                         sizeof(posix_constants_confstr)\n                           / sizeof(struct constdef));\n}\n\n\n/*[clinic input]\nos.confstr\n\n    name: confstr_confname\n    /\n\nReturn a string-valued system configuration variable.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_confstr_impl(PyObject *module, int name)\n/*[clinic end generated code: output=bfb0b1b1e49b9383 input=18fb4d0567242e65]*/\n{\n    PyObject *result = NULL;\n    char buffer[255];\n    size_t len;\n\n    errno = 0;\n    len = confstr(name, buffer, sizeof(buffer));\n    if (len == 0) {\n        if (errno) {\n            posix_error();\n            return NULL;\n        }\n        else {\n            Py_RETURN_NONE;\n        }\n    }\n\n    if (len >= sizeof(buffer)) {\n        size_t len2;\n        char *buf = PyMem_Malloc(len);\n        if (buf == NULL)\n            return PyErr_NoMemory();\n        len2 = confstr(name, buf, len);\n        assert(len == len2);\n        result = PyUnicode_DecodeFSDefaultAndSize(buf, len2-1);\n        PyMem_Free(buf);\n    }\n    else\n        result = PyUnicode_DecodeFSDefaultAndSize(buffer, len-1);\n    return result;\n}\n#endif /* HAVE_CONFSTR */\n\n\n#ifdef HAVE_SYSCONF\nstatic struct constdef posix_constants_sysconf[] = {\n#ifdef _SC_2_CHAR_TERM\n    {\"SC_2_CHAR_TERM\",  _SC_2_CHAR_TERM},\n#endif\n#ifdef _SC_2_C_BIND\n    {\"SC_2_C_BIND\",     _SC_2_C_BIND},\n#endif\n#ifdef _SC_2_C_DEV\n    {\"SC_2_C_DEV\",      _SC_2_C_DEV},\n#endif\n#ifdef _SC_2_C_VERSION\n    {\"SC_2_C_VERSION\",  _SC_2_C_VERSION},\n#endif\n#ifdef _SC_2_FORT_DEV\n    {\"SC_2_FORT_DEV\",   _SC_2_FORT_DEV},\n#endif\n#ifdef _SC_2_FORT_RUN\n    {\"SC_2_FORT_RUN\",   _SC_2_FORT_RUN},\n#endif\n#ifdef _SC_2_LOCALEDEF\n    {\"SC_2_LOCALEDEF\",  _SC_2_LOCALEDEF},\n#endif\n#ifdef _SC_2_SW_DEV\n    {\"SC_2_SW_DEV\",     _SC_2_SW_DEV},\n#endif\n#ifdef _SC_2_UPE\n    {\"SC_2_UPE\",        _SC_2_UPE},\n#endif\n#ifdef _SC_2_VERSION\n    {\"SC_2_VERSION\",    _SC_2_VERSION},\n#endif\n#ifdef _SC_ABI_ASYNCHRONOUS_IO\n    {\"SC_ABI_ASYNCHRONOUS_IO\",  _SC_ABI_ASYNCHRONOUS_IO},\n#endif\n#ifdef _SC_ACL\n    {\"SC_ACL\",  _SC_ACL},\n#endif\n#ifdef _SC_AIO_LISTIO_MAX\n    {\"SC_AIO_LISTIO_MAX\",       _SC_AIO_LISTIO_MAX},\n#endif\n#ifdef _SC_AIO_MAX\n    {\"SC_AIO_MAX\",      _SC_AIO_MAX},\n#endif\n#ifdef _SC_AIO_PRIO_DELTA_MAX\n    {\"SC_AIO_PRIO_DELTA_MAX\",   _SC_AIO_PRIO_DELTA_MAX},\n#endif\n#ifdef _SC_ARG_MAX\n    {\"SC_ARG_MAX\",      _SC_ARG_MAX},\n#endif\n#ifdef _SC_ASYNCHRONOUS_IO\n    {\"SC_ASYNCHRONOUS_IO\",      _SC_ASYNCHRONOUS_IO},\n#endif\n#ifdef _SC_ATEXIT_MAX\n    {\"SC_ATEXIT_MAX\",   _SC_ATEXIT_MAX},\n#endif\n#ifdef _SC_AUDIT\n    {\"SC_AUDIT\",        _SC_AUDIT},\n#endif\n#ifdef _SC_AVPHYS_PAGES\n    {\"SC_AVPHYS_PAGES\", _SC_AVPHYS_PAGES},\n#endif\n#ifdef _SC_BC_BASE_MAX\n    {\"SC_BC_BASE_MAX\",  _SC_BC_BASE_MAX},\n#endif\n#ifdef _SC_BC_DIM_MAX\n    {\"SC_BC_DIM_MAX\",   _SC_BC_DIM_MAX},\n#endif\n#ifdef _SC_BC_SCALE_MAX\n    {\"SC_BC_SCALE_MAX\", _SC_BC_SCALE_MAX},\n#endif\n#ifdef _SC_BC_STRING_MAX\n    {\"SC_BC_STRING_MAX\",        _SC_BC_STRING_MAX},\n#endif\n#ifdef _SC_CAP\n    {\"SC_CAP\",  _SC_CAP},\n#endif\n#ifdef _SC_CHARCLASS_NAME_MAX\n    {\"SC_CHARCLASS_NAME_MAX\",   _SC_CHARCLASS_NAME_MAX},\n#endif\n#ifdef _SC_CHAR_BIT\n    {\"SC_CHAR_BIT\",     _SC_CHAR_BIT},\n#endif\n#ifdef _SC_CHAR_MAX\n    {\"SC_CHAR_MAX\",     _SC_CHAR_MAX},\n#endif\n#ifdef _SC_CHAR_MIN\n    {\"SC_CHAR_MIN\",     _SC_CHAR_MIN},\n#endif\n#ifdef _SC_CHILD_MAX\n    {\"SC_CHILD_MAX\",    _SC_CHILD_MAX},\n#endif\n#ifdef _SC_CLK_TCK\n    {\"SC_CLK_TCK\",      _SC_CLK_TCK},\n#endif\n#ifdef _SC_COHER_BLKSZ\n    {\"SC_COHER_BLKSZ\",  _SC_COHER_BLKSZ},\n#endif\n#ifdef _SC_COLL_WEIGHTS_MAX\n    {\"SC_COLL_WEIGHTS_MAX\",     _SC_COLL_WEIGHTS_MAX},\n#endif\n#ifdef _SC_DCACHE_ASSOC\n    {\"SC_DCACHE_ASSOC\", _SC_DCACHE_ASSOC},\n#endif\n#ifdef _SC_DCACHE_BLKSZ\n    {\"SC_DCACHE_BLKSZ\", _SC_DCACHE_BLKSZ},\n#endif\n#ifdef _SC_DCACHE_LINESZ\n    {\"SC_DCACHE_LINESZ\",        _SC_DCACHE_LINESZ},\n#endif\n#ifdef _SC_DCACHE_SZ\n    {\"SC_DCACHE_SZ\",    _SC_DCACHE_SZ},\n#endif\n#ifdef _SC_DCACHE_TBLKSZ\n    {\"SC_DCACHE_TBLKSZ\",        _SC_DCACHE_TBLKSZ},\n#endif\n#ifdef _SC_DELAYTIMER_MAX\n    {\"SC_DELAYTIMER_MAX\",       _SC_DELAYTIMER_MAX},\n#endif\n#ifdef _SC_EQUIV_CLASS_MAX\n    {\"SC_EQUIV_CLASS_MAX\",      _SC_EQUIV_CLASS_MAX},\n#endif\n#ifdef _SC_EXPR_NEST_MAX\n    {\"SC_EXPR_NEST_MAX\",        _SC_EXPR_NEST_MAX},\n#endif\n#ifdef _SC_FSYNC\n    {\"SC_FSYNC\",        _SC_FSYNC},\n#endif\n#ifdef _SC_GETGR_R_SIZE_MAX\n    {\"SC_GETGR_R_SIZE_MAX\",     _SC_GETGR_R_SIZE_MAX},\n#endif\n#ifdef _SC_GETPW_R_SIZE_MAX\n    {\"SC_GETPW_R_SIZE_MAX\",     _SC_GETPW_R_SIZE_MAX},\n#endif\n#ifdef _SC_ICACHE_ASSOC\n    {\"SC_ICACHE_ASSOC\", _SC_ICACHE_ASSOC},\n#endif\n#ifdef _SC_ICACHE_BLKSZ\n    {\"SC_ICACHE_BLKSZ\", _SC_ICACHE_BLKSZ},\n#endif\n#ifdef _SC_ICACHE_LINESZ\n    {\"SC_ICACHE_LINESZ\",        _SC_ICACHE_LINESZ},\n#endif\n#ifdef _SC_ICACHE_SZ\n    {\"SC_ICACHE_SZ\",    _SC_ICACHE_SZ},\n#endif\n#ifdef _SC_INF\n    {\"SC_INF\",  _SC_INF},\n#endif\n#ifdef _SC_INT_MAX\n    {\"SC_INT_MAX\",      _SC_INT_MAX},\n#endif\n#ifdef _SC_INT_MIN\n    {\"SC_INT_MIN\",      _SC_INT_MIN},\n#endif\n#ifdef _SC_IOV_MAX\n    {\"SC_IOV_MAX\",      _SC_IOV_MAX},\n#endif\n#ifdef _SC_IP_SECOPTS\n    {\"SC_IP_SECOPTS\",   _SC_IP_SECOPTS},\n#endif\n#ifdef _SC_JOB_CONTROL\n    {\"SC_JOB_CONTROL\",  _SC_JOB_CONTROL},\n#endif\n#ifdef _SC_KERN_POINTERS\n    {\"SC_KERN_POINTERS\",        _SC_KERN_POINTERS},\n#endif\n#ifdef _SC_KERN_SIM\n    {\"SC_KERN_SIM\",     _SC_KERN_SIM},\n#endif\n#ifdef _SC_LINE_MAX\n    {\"SC_LINE_MAX\",     _SC_LINE_MAX},\n#endif\n#ifdef _SC_LOGIN_NAME_MAX\n    {\"SC_LOGIN_NAME_MAX\",       _SC_LOGIN_NAME_MAX},\n#endif\n#ifdef _SC_LOGNAME_MAX\n    {\"SC_LOGNAME_MAX\",  _SC_LOGNAME_MAX},\n#endif\n#ifdef _SC_LONG_BIT\n    {\"SC_LONG_BIT\",     _SC_LONG_BIT},\n#endif\n#ifdef _SC_MAC\n    {\"SC_MAC\",  _SC_MAC},\n#endif\n#ifdef _SC_MAPPED_FILES\n    {\"SC_MAPPED_FILES\", _SC_MAPPED_FILES},\n#endif\n#ifdef _SC_MAXPID\n    {\"SC_MAXPID\",       _SC_MAXPID},\n#endif\n#ifdef _SC_MB_LEN_MAX\n    {\"SC_MB_LEN_MAX\",   _SC_MB_LEN_MAX},\n#endif\n#ifdef _SC_MEMLOCK\n    {\"SC_MEMLOCK\",      _SC_MEMLOCK},\n#endif\n#ifdef _SC_MEMLOCK_RANGE\n    {\"SC_MEMLOCK_RANGE\",        _SC_MEMLOCK_RANGE},\n#endif\n#ifdef _SC_MEMORY_PROTECTION\n    {\"SC_MEMORY_PROTECTION\",    _SC_MEMORY_PROTECTION},\n#endif\n#ifdef _SC_MESSAGE_PASSING\n    {\"SC_MESSAGE_PASSING\",      _SC_MESSAGE_PASSING},\n#endif\n#ifdef _SC_MMAP_FIXED_ALIGNMENT\n    {\"SC_MMAP_FIXED_ALIGNMENT\", _SC_MMAP_FIXED_ALIGNMENT},\n#endif\n#ifdef _SC_MQ_OPEN_MAX\n    {\"SC_MQ_OPEN_MAX\",  _SC_MQ_OPEN_MAX},\n#endif\n#ifdef _SC_MQ_PRIO_MAX\n    {\"SC_MQ_PRIO_MAX\",  _SC_MQ_PRIO_MAX},\n#endif\n#ifdef _SC_NACLS_MAX\n    {\"SC_NACLS_MAX\",    _SC_NACLS_MAX},\n#endif\n#ifdef _SC_NGROUPS_MAX\n    {\"SC_NGROUPS_MAX\",  _SC_NGROUPS_MAX},\n#endif\n#ifdef _SC_NL_ARGMAX\n    {\"SC_NL_ARGMAX\",    _SC_NL_ARGMAX},\n#endif\n#ifdef _SC_NL_LANGMAX\n    {\"SC_NL_LANGMAX\",   _SC_NL_LANGMAX},\n#endif\n#ifdef _SC_NL_MSGMAX\n    {\"SC_NL_MSGMAX\",    _SC_NL_MSGMAX},\n#endif\n#ifdef _SC_NL_NMAX\n    {\"SC_NL_NMAX\",      _SC_NL_NMAX},\n#endif\n#ifdef _SC_NL_SETMAX\n    {\"SC_NL_SETMAX\",    _SC_NL_SETMAX},\n#endif\n#ifdef _SC_NL_TEXTMAX\n    {\"SC_NL_TEXTMAX\",   _SC_NL_TEXTMAX},\n#endif\n#ifdef _SC_NPROCESSORS_CONF\n    {\"SC_NPROCESSORS_CONF\",     _SC_NPROCESSORS_CONF},\n#endif\n#ifdef _SC_NPROCESSORS_ONLN\n    {\"SC_NPROCESSORS_ONLN\",     _SC_NPROCESSORS_ONLN},\n#endif\n#ifdef _SC_NPROC_CONF\n    {\"SC_NPROC_CONF\",   _SC_NPROC_CONF},\n#endif\n#ifdef _SC_NPROC_ONLN\n    {\"SC_NPROC_ONLN\",   _SC_NPROC_ONLN},\n#endif\n#ifdef _SC_NZERO\n    {\"SC_NZERO\",        _SC_NZERO},\n#endif\n#ifdef _SC_OPEN_MAX\n    {\"SC_OPEN_MAX\",     _SC_OPEN_MAX},\n#endif\n#ifdef _SC_PAGESIZE\n    {\"SC_PAGESIZE\",     _SC_PAGESIZE},\n#endif\n#ifdef _SC_PAGE_SIZE\n    {\"SC_PAGE_SIZE\",    _SC_PAGE_SIZE},\n#endif\n#ifdef _SC_AIX_REALMEM\n    {\"SC_AIX_REALMEM\", _SC_AIX_REALMEM},\n#endif\n#ifdef _SC_PASS_MAX\n    {\"SC_PASS_MAX\",     _SC_PASS_MAX},\n#endif\n#ifdef _SC_PHYS_PAGES\n    {\"SC_PHYS_PAGES\",   _SC_PHYS_PAGES},\n#endif\n#ifdef _SC_PII\n    {\"SC_PII\",  _SC_PII},\n#endif\n#ifdef _SC_PII_INTERNET\n    {\"SC_PII_INTERNET\", _SC_PII_INTERNET},\n#endif\n#ifdef _SC_PII_INTERNET_DGRAM\n    {\"SC_PII_INTERNET_DGRAM\",   _SC_PII_INTERNET_DGRAM},\n#endif\n#ifdef _SC_PII_INTERNET_STREAM\n    {\"SC_PII_INTERNET_STREAM\",  _SC_PII_INTERNET_STREAM},\n#endif\n#ifdef _SC_PII_OSI\n    {\"SC_PII_OSI\",      _SC_PII_OSI},\n#endif\n#ifdef _SC_PII_OSI_CLTS\n    {\"SC_PII_OSI_CLTS\", _SC_PII_OSI_CLTS},\n#endif\n#ifdef _SC_PII_OSI_COTS\n    {\"SC_PII_OSI_COTS\", _SC_PII_OSI_COTS},\n#endif\n#ifdef _SC_PII_OSI_M\n    {\"SC_PII_OSI_M\",    _SC_PII_OSI_M},\n#endif\n#ifdef _SC_PII_SOCKET\n    {\"SC_PII_SOCKET\",   _SC_PII_SOCKET},\n#endif\n#ifdef _SC_PII_XTI\n    {\"SC_PII_XTI\",      _SC_PII_XTI},\n#endif\n#ifdef _SC_POLL\n    {\"SC_POLL\", _SC_POLL},\n#endif\n#ifdef _SC_PRIORITIZED_IO\n    {\"SC_PRIORITIZED_IO\",       _SC_PRIORITIZED_IO},\n#endif\n#ifdef _SC_PRIORITY_SCHEDULING\n    {\"SC_PRIORITY_SCHEDULING\",  _SC_PRIORITY_SCHEDULING},\n#endif\n#ifdef _SC_REALTIME_SIGNALS\n    {\"SC_REALTIME_SIGNALS\",     _SC_REALTIME_SIGNALS},\n#endif\n#ifdef _SC_RE_DUP_MAX\n    {\"SC_RE_DUP_MAX\",   _SC_RE_DUP_MAX},\n#endif\n#ifdef _SC_RTSIG_MAX\n    {\"SC_RTSIG_MAX\",    _SC_RTSIG_MAX},\n#endif\n#ifdef _SC_SAVED_IDS\n    {\"SC_SAVED_IDS\",    _SC_SAVED_IDS},\n#endif\n#ifdef _SC_SCHAR_MAX\n    {\"SC_SCHAR_MAX\",    _SC_SCHAR_MAX},\n#endif\n#ifdef _SC_SCHAR_MIN\n    {\"SC_SCHAR_MIN\",    _SC_SCHAR_MIN},\n#endif\n#ifdef _SC_SELECT\n    {\"SC_SELECT\",       _SC_SELECT},\n#endif\n#ifdef _SC_SEMAPHORES\n    {\"SC_SEMAPHORES\",   _SC_SEMAPHORES},\n#endif\n#ifdef _SC_SEM_NSEMS_MAX\n    {\"SC_SEM_NSEMS_MAX\",        _SC_SEM_NSEMS_MAX},\n#endif\n#ifdef _SC_SEM_VALUE_MAX\n    {\"SC_SEM_VALUE_MAX\",        _SC_SEM_VALUE_MAX},\n#endif\n#ifdef _SC_SHARED_MEMORY_OBJECTS\n    {\"SC_SHARED_MEMORY_OBJECTS\",        _SC_SHARED_MEMORY_OBJECTS},\n#endif\n#ifdef _SC_SHRT_MAX\n    {\"SC_SHRT_MAX\",     _SC_SHRT_MAX},\n#endif\n#ifdef _SC_SHRT_MIN\n    {\"SC_SHRT_MIN\",     _SC_SHRT_MIN},\n#endif\n#ifdef _SC_SIGQUEUE_MAX\n    {\"SC_SIGQUEUE_MAX\", _SC_SIGQUEUE_MAX},\n#endif\n#ifdef _SC_SIGRT_MAX\n    {\"SC_SIGRT_MAX\",    _SC_SIGRT_MAX},\n#endif\n#ifdef _SC_SIGRT_MIN\n    {\"SC_SIGRT_MIN\",    _SC_SIGRT_MIN},\n#endif\n#ifdef _SC_SOFTPOWER\n    {\"SC_SOFTPOWER\",    _SC_SOFTPOWER},\n#endif\n#ifdef _SC_SPLIT_CACHE\n    {\"SC_SPLIT_CACHE\",  _SC_SPLIT_CACHE},\n#endif\n#ifdef _SC_SSIZE_MAX\n    {\"SC_SSIZE_MAX\",    _SC_SSIZE_MAX},\n#endif\n#ifdef _SC_STACK_PROT\n    {\"SC_STACK_PROT\",   _SC_STACK_PROT},\n#endif\n#ifdef _SC_STREAM_MAX\n    {\"SC_STREAM_MAX\",   _SC_STREAM_MAX},\n#endif\n#ifdef _SC_SYNCHRONIZED_IO\n    {\"SC_SYNCHRONIZED_IO\",      _SC_SYNCHRONIZED_IO},\n#endif\n#ifdef _SC_THREADS\n    {\"SC_THREADS\",      _SC_THREADS},\n#endif\n#ifdef _SC_THREAD_ATTR_STACKADDR\n    {\"SC_THREAD_ATTR_STACKADDR\",        _SC_THREAD_ATTR_STACKADDR},\n#endif\n#ifdef _SC_THREAD_ATTR_STACKSIZE\n    {\"SC_THREAD_ATTR_STACKSIZE\",        _SC_THREAD_ATTR_STACKSIZE},\n#endif\n#ifdef _SC_THREAD_DESTRUCTOR_ITERATIONS\n    {\"SC_THREAD_DESTRUCTOR_ITERATIONS\", _SC_THREAD_DESTRUCTOR_ITERATIONS},\n#endif\n#ifdef _SC_THREAD_KEYS_MAX\n    {\"SC_THREAD_KEYS_MAX\",      _SC_THREAD_KEYS_MAX},\n#endif\n#ifdef _SC_THREAD_PRIORITY_SCHEDULING\n    {\"SC_THREAD_PRIORITY_SCHEDULING\",   _SC_THREAD_PRIORITY_SCHEDULING},\n#endif\n#ifdef _SC_THREAD_PRIO_INHERIT\n    {\"SC_THREAD_PRIO_INHERIT\",  _SC_THREAD_PRIO_INHERIT},\n#endif\n#ifdef _SC_THREAD_PRIO_PROTECT\n    {\"SC_THREAD_PRIO_PROTECT\",  _SC_THREAD_PRIO_PROTECT},\n#endif\n#ifdef _SC_THREAD_PROCESS_SHARED\n    {\"SC_THREAD_PROCESS_SHARED\",        _SC_THREAD_PROCESS_SHARED},\n#endif\n#ifdef _SC_THREAD_SAFE_FUNCTIONS\n    {\"SC_THREAD_SAFE_FUNCTIONS\",        _SC_THREAD_SAFE_FUNCTIONS},\n#endif\n#ifdef _SC_THREAD_STACK_MIN\n    {\"SC_THREAD_STACK_MIN\",     _SC_THREAD_STACK_MIN},\n#endif\n#ifdef _SC_THREAD_THREADS_MAX\n    {\"SC_THREAD_THREADS_MAX\",   _SC_THREAD_THREADS_MAX},\n#endif\n#ifdef _SC_TIMERS\n    {\"SC_TIMERS\",       _SC_TIMERS},\n#endif\n#ifdef _SC_TIMER_MAX\n    {\"SC_TIMER_MAX\",    _SC_TIMER_MAX},\n#endif\n#ifdef _SC_TTY_NAME_MAX\n    {\"SC_TTY_NAME_MAX\", _SC_TTY_NAME_MAX},\n#endif\n#ifdef _SC_TZNAME_MAX\n    {\"SC_TZNAME_MAX\",   _SC_TZNAME_MAX},\n#endif\n#ifdef _SC_T_IOV_MAX\n    {\"SC_T_IOV_MAX\",    _SC_T_IOV_MAX},\n#endif\n#ifdef _SC_UCHAR_MAX\n    {\"SC_UCHAR_MAX\",    _SC_UCHAR_MAX},\n#endif\n#ifdef _SC_UINT_MAX\n    {\"SC_UINT_MAX\",     _SC_UINT_MAX},\n#endif\n#ifdef _SC_UIO_MAXIOV\n    {\"SC_UIO_MAXIOV\",   _SC_UIO_MAXIOV},\n#endif\n#ifdef _SC_ULONG_MAX\n    {\"SC_ULONG_MAX\",    _SC_ULONG_MAX},\n#endif\n#ifdef _SC_USHRT_MAX\n    {\"SC_USHRT_MAX\",    _SC_USHRT_MAX},\n#endif\n#ifdef _SC_VERSION\n    {\"SC_VERSION\",      _SC_VERSION},\n#endif\n#ifdef _SC_WORD_BIT\n    {\"SC_WORD_BIT\",     _SC_WORD_BIT},\n#endif\n#ifdef _SC_XBS5_ILP32_OFF32\n    {\"SC_XBS5_ILP32_OFF32\",     _SC_XBS5_ILP32_OFF32},\n#endif\n#ifdef _SC_XBS5_ILP32_OFFBIG\n    {\"SC_XBS5_ILP32_OFFBIG\",    _SC_XBS5_ILP32_OFFBIG},\n#endif\n#ifdef _SC_XBS5_LP64_OFF64\n    {\"SC_XBS5_LP64_OFF64\",      _SC_XBS5_LP64_OFF64},\n#endif\n#ifdef _SC_XBS5_LPBIG_OFFBIG\n    {\"SC_XBS5_LPBIG_OFFBIG\",    _SC_XBS5_LPBIG_OFFBIG},\n#endif\n#ifdef _SC_XOPEN_CRYPT\n    {\"SC_XOPEN_CRYPT\",  _SC_XOPEN_CRYPT},\n#endif\n#ifdef _SC_XOPEN_ENH_I18N\n    {\"SC_XOPEN_ENH_I18N\",       _SC_XOPEN_ENH_I18N},\n#endif\n#ifdef _SC_XOPEN_LEGACY\n    {\"SC_XOPEN_LEGACY\", _SC_XOPEN_LEGACY},\n#endif\n#ifdef _SC_XOPEN_REALTIME\n    {\"SC_XOPEN_REALTIME\",       _SC_XOPEN_REALTIME},\n#endif\n#ifdef _SC_XOPEN_REALTIME_THREADS\n    {\"SC_XOPEN_REALTIME_THREADS\",       _SC_XOPEN_REALTIME_THREADS},\n#endif\n#ifdef _SC_XOPEN_SHM\n    {\"SC_XOPEN_SHM\",    _SC_XOPEN_SHM},\n#endif\n#ifdef _SC_XOPEN_UNIX\n    {\"SC_XOPEN_UNIX\",   _SC_XOPEN_UNIX},\n#endif\n#ifdef _SC_XOPEN_VERSION\n    {\"SC_XOPEN_VERSION\",        _SC_XOPEN_VERSION},\n#endif\n#ifdef _SC_XOPEN_XCU_VERSION\n    {\"SC_XOPEN_XCU_VERSION\",    _SC_XOPEN_XCU_VERSION},\n#endif\n#ifdef _SC_XOPEN_XPG2\n    {\"SC_XOPEN_XPG2\",   _SC_XOPEN_XPG2},\n#endif\n#ifdef _SC_XOPEN_XPG3\n    {\"SC_XOPEN_XPG3\",   _SC_XOPEN_XPG3},\n#endif\n#ifdef _SC_XOPEN_XPG4\n    {\"SC_XOPEN_XPG4\",   _SC_XOPEN_XPG4},\n#endif\n#ifdef _SC_MINSIGSTKSZ\n    {\"SC_MINSIGSTKSZ\",   _SC_MINSIGSTKSZ},\n#endif\n};\n\nstatic int\nconv_sysconf_confname(PyObject *arg, int *valuep)\n{\n    return conv_confname(arg, valuep, posix_constants_sysconf,\n                         sizeof(posix_constants_sysconf)\n                           / sizeof(struct constdef));\n}\n\n\n/*[clinic input]\nos.sysconf -> long\n    name: sysconf_confname\n    /\n\nReturn an integer-valued system configuration variable.\n[clinic start generated code]*/\n\nstatic long\nos_sysconf_impl(PyObject *module, int name)\n/*[clinic end generated code: output=3662f945fc0cc756 input=279e3430a33f29e4]*/\n{\n    long value;\n\n    errno = 0;\n    value = sysconf(name);\n    if (value == -1 && errno != 0)\n        posix_error();\n    return value;\n}\n#endif /* HAVE_SYSCONF */\n\n\n/* This code is used to ensure that the tables of configuration value names\n * are in sorted order as required by conv_confname(), and also to build\n * the exported dictionaries that are used to publish information about the\n * names available on the host platform.\n *\n * Sorting the table at runtime ensures that the table is properly ordered\n * when used, even for platforms we're not able to test on.  It also makes\n * it easier to add additional entries to the tables.\n */\n\nstatic int\ncmp_constdefs(const void *v1,  const void *v2)\n{\n    const struct constdef *c1 =\n    (const struct constdef *) v1;\n    const struct constdef *c2 =\n    (const struct constdef *) v2;\n\n    return strcmp(c1->name, c2->name);\n}\n\nstatic int\nsetup_confname_table(struct constdef *table, size_t tablesize,\n                     const char *tablename, PyObject *module)\n{\n    PyObject *d = NULL;\n    size_t i;\n\n    qsort(table, tablesize, sizeof(struct constdef), cmp_constdefs);\n    d = PyDict_New();\n    if (d == NULL)\n        return -1;\n\n    for (i=0; i < tablesize; ++i) {\n        PyObject *o = PyLong_FromLong(table[i].value);\n        if (o == NULL || PyDict_SetItemString(d, table[i].name, o) == -1) {\n            Py_XDECREF(o);\n            Py_DECREF(d);\n            return -1;\n        }\n        Py_DECREF(o);\n    }\n    return PyModule_Add(module, tablename, d);\n}\n\n/* Return -1 on failure, 0 on success. */\nstatic int\nsetup_confname_tables(PyObject *module)\n{\n#if defined(HAVE_FPATHCONF) || defined(HAVE_PATHCONF)\n    if (setup_confname_table(posix_constants_pathconf,\n                             sizeof(posix_constants_pathconf)\n                               / sizeof(struct constdef),\n                             \"pathconf_names\", module))\n        return -1;\n#endif\n#ifdef HAVE_CONFSTR\n    if (setup_confname_table(posix_constants_confstr,\n                             sizeof(posix_constants_confstr)\n                               / sizeof(struct constdef),\n                             \"confstr_names\", module))\n        return -1;\n#endif\n#ifdef HAVE_SYSCONF\n    if (setup_confname_table(posix_constants_sysconf,\n                             sizeof(posix_constants_sysconf)\n                               / sizeof(struct constdef),\n                             \"sysconf_names\", module))\n        return -1;\n#endif\n    return 0;\n}\n\n\n/*[clinic input]\nos.abort\n\nAbort the interpreter immediately.\n\nThis function 'dumps core' or otherwise fails in the hardest way possible\non the hosting operating system.  This function never returns.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_abort_impl(PyObject *module)\n/*[clinic end generated code: output=dcf52586dad2467c input=cf2c7d98bc504047]*/\n{\n    abort();\n    /*NOTREACHED*/\n#ifndef __clang__\n    /* Issue #28152: abort() is declared with __attribute__((__noreturn__)).\n       GCC emits a warning without \"return NULL;\" (compiler bug?), but Clang\n       is smarter and emits a warning on the return. */\n    Py_FatalError(\"abort() called from Python code didn't abort!\");\n    return NULL;\n#endif\n}\n\n#ifdef MS_WINDOWS\n/* Grab ShellExecute dynamically from shell32 */\nstatic int has_ShellExecute = -1;\nstatic HINSTANCE (CALLBACK *Py_ShellExecuteW)(HWND, LPCWSTR, LPCWSTR, LPCWSTR,\n                                              LPCWSTR, INT);\nstatic int\ncheck_ShellExecute(void)\n{\n    HINSTANCE hShell32;\n\n    /* only recheck */\n    if (-1 == has_ShellExecute) {\n        Py_BEGIN_ALLOW_THREADS\n        /* Security note: this call is not vulnerable to \"DLL hijacking\".\n           SHELL32 is part of \"KnownDLLs\" and so Windows always load\n           the system SHELL32.DLL, even if there is another SHELL32.DLL\n           in the DLL search path. */\n        hShell32 = LoadLibraryW(L\"SHELL32\");\n        if (hShell32) {\n            *(FARPROC*)&Py_ShellExecuteW = GetProcAddress(hShell32,\n                                            \"ShellExecuteW\");\n            has_ShellExecute = Py_ShellExecuteW != NULL;\n        } else {\n            has_ShellExecute = 0;\n        }\n        Py_END_ALLOW_THREADS\n    }\n    return has_ShellExecute;\n}\n\n\n/*[clinic input]\nos.startfile\n    filepath: path_t\n    operation: Py_UNICODE = NULL\n    arguments: Py_UNICODE = NULL\n    cwd: path_t(nullable=True) = None\n    show_cmd: int = 1\n\nStart a file with its associated application.\n\nWhen \"operation\" is not specified or \"open\", this acts like\ndouble-clicking the file in Explorer, or giving the file name as an\nargument to the DOS \"start\" command: the file is opened with whatever\napplication (if any) its extension is associated.\nWhen another \"operation\" is given, it specifies what should be done with\nthe file.  A typical operation is \"print\".\n\n\"arguments\" is passed to the application, but should be omitted if the\nfile is a document.\n\n\"cwd\" is the working directory for the operation. If \"filepath\" is\nrelative, it will be resolved against this directory. This argument\nshould usually be an absolute path.\n\n\"show_cmd\" can be used to override the recommended visibility option.\nSee the Windows ShellExecute documentation for values.\n\nstartfile returns as soon as the associated application is launched.\nThere is no option to wait for the application to close, and no way\nto retrieve the application's exit status.\n\nThe filepath is relative to the current directory.  If you want to use\nan absolute path, make sure the first character is not a slash (\"/\");\nthe underlying Win32 ShellExecute function doesn't work if it is.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_startfile_impl(PyObject *module, path_t *filepath,\n                  const wchar_t *operation, const wchar_t *arguments,\n                  path_t *cwd, int show_cmd)\n/*[clinic end generated code: output=1c6f2f3340e31ffa input=8248997b80669622]*/\n{\n    HINSTANCE rc;\n\n    if(!check_ShellExecute()) {\n        /* If the OS doesn't have ShellExecute, return a\n           NotImplementedError. */\n        return PyErr_Format(PyExc_NotImplementedError,\n            \"startfile not available on this platform\");\n    }\n\n    if (PySys_Audit(\"os.startfile\", \"Ou\", filepath->object, operation) < 0) {\n        return NULL;\n    }\n    if (PySys_Audit(\"os.startfile/2\", \"OuuOi\", filepath->object, operation,\n                    arguments, cwd->object ? cwd->object : Py_None,\n                    show_cmd) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    rc = Py_ShellExecuteW((HWND)0, operation, filepath->wide,\n                          arguments, cwd->wide, show_cmd);\n    Py_END_ALLOW_THREADS\n\n    if (rc <= (HINSTANCE)32) {\n        win32_error_object(\"startfile\", filepath->object);\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n#endif /* MS_WINDOWS */\n\n\n#ifdef HAVE_GETLOADAVG\n/*[clinic input]\nos.getloadavg\n\nReturn average recent system load information.\n\nReturn the number of processes in the system run queue averaged over\nthe last 1, 5, and 15 minutes as a tuple of three floats.\nRaises OSError if the load average was unobtainable.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getloadavg_impl(PyObject *module)\n/*[clinic end generated code: output=9ad3a11bfb4f4bd2 input=3d6d826b76d8a34e]*/\n{\n    double loadavg[3];\n    if (getloadavg(loadavg, 3)!=3) {\n        PyErr_SetString(PyExc_OSError, \"Load averages are unobtainable\");\n        return NULL;\n    } else\n        return Py_BuildValue(\"ddd\", loadavg[0], loadavg[1], loadavg[2]);\n}\n#endif /* HAVE_GETLOADAVG */\n\n\n/*[clinic input]\nos.device_encoding\n    fd: int\n\nReturn a string describing the encoding of a terminal's file descriptor.\n\nThe file descriptor must be attached to a terminal.\nIf the device is not a terminal, return None.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_device_encoding_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=e0d294bbab7e8c2b input=9e1d4a42b66df312]*/\n{\n    return _Py_device_encoding(fd);\n}\n\n\n#ifdef HAVE_SETRESUID\n/*[clinic input]\nos.setresuid\n\n    ruid: uid_t\n    euid: uid_t\n    suid: uid_t\n    /\n\nSet the current process's real, effective, and saved user ids.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setresuid_impl(PyObject *module, uid_t ruid, uid_t euid, uid_t suid)\n/*[clinic end generated code: output=834a641e15373e97 input=9e33cb79a82792f3]*/\n{\n    if (setresuid(ruid, euid, suid) < 0)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SETRESUID */\n\n\n#ifdef HAVE_SETRESGID\n/*[clinic input]\nos.setresgid\n\n    rgid: gid_t\n    egid: gid_t\n    sgid: gid_t\n    /\n\nSet the current process's real, effective, and saved group ids.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setresgid_impl(PyObject *module, gid_t rgid, gid_t egid, gid_t sgid)\n/*[clinic end generated code: output=6aa402f3d2e514a9 input=33e9e0785ef426b1]*/\n{\n    if (setresgid(rgid, egid, sgid) < 0)\n        return posix_error();\n    Py_RETURN_NONE;\n}\n#endif /* HAVE_SETRESGID */\n\n\n#ifdef HAVE_GETRESUID\n/*[clinic input]\nos.getresuid\n\nReturn a tuple of the current process's real, effective, and saved user ids.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getresuid_impl(PyObject *module)\n/*[clinic end generated code: output=8e0becff5dece5bf input=41ccfa8e1f6517ad]*/\n{\n    uid_t ruid, euid, suid;\n    if (getresuid(&ruid, &euid, &suid) < 0)\n        return posix_error();\n    return Py_BuildValue(\"(NNN)\", _PyLong_FromUid(ruid),\n                                  _PyLong_FromUid(euid),\n                                  _PyLong_FromUid(suid));\n}\n#endif /* HAVE_GETRESUID */\n\n\n#ifdef HAVE_GETRESGID\n/*[clinic input]\nos.getresgid\n\nReturn a tuple of the current process's real, effective, and saved group ids.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getresgid_impl(PyObject *module)\n/*[clinic end generated code: output=2719c4bfcf27fb9f input=517e68db9ca32df6]*/\n{\n    gid_t rgid, egid, sgid;\n    if (getresgid(&rgid, &egid, &sgid) < 0)\n        return posix_error();\n    return Py_BuildValue(\"(NNN)\", _PyLong_FromGid(rgid),\n                                  _PyLong_FromGid(egid),\n                                  _PyLong_FromGid(sgid));\n}\n#endif /* HAVE_GETRESGID */\n\n\n#ifdef USE_XATTRS\n/*[clinic input]\nos.getxattr\n\n    path: path_t(allow_fd=True)\n    attribute: path_t\n    *\n    follow_symlinks: bool = True\n\nReturn the value of extended attribute attribute on path.\n\npath may be either a string, a path-like object, or an open file descriptor.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, getxattr will examine the symbolic link itself instead of the file\n  the link points to.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getxattr_impl(PyObject *module, path_t *path, path_t *attribute,\n                 int follow_symlinks)\n/*[clinic end generated code: output=5f2f44200a43cff2 input=025789491708f7eb]*/\n{\n    Py_ssize_t i;\n    PyObject *buffer = NULL;\n\n    if (fd_and_follow_symlinks_invalid(\"getxattr\", path->fd, follow_symlinks))\n        return NULL;\n\n    if (PySys_Audit(\"os.getxattr\", \"OO\", path->object, attribute->object) < 0) {\n        return NULL;\n    }\n\n    for (i = 0; ; i++) {\n        void *ptr;\n        ssize_t result;\n        static const Py_ssize_t buffer_sizes[] = {128, XATTR_SIZE_MAX, 0};\n        Py_ssize_t buffer_size = buffer_sizes[i];\n        if (!buffer_size) {\n            path_error(path);\n            return NULL;\n        }\n        buffer = PyBytes_FromStringAndSize(NULL, buffer_size);\n        if (!buffer)\n            return NULL;\n        ptr = PyBytes_AS_STRING(buffer);\n\n        Py_BEGIN_ALLOW_THREADS;\n        if (path->fd >= 0)\n            result = fgetxattr(path->fd, attribute->narrow, ptr, buffer_size);\n        else if (follow_symlinks)\n            result = getxattr(path->narrow, attribute->narrow, ptr, buffer_size);\n        else\n            result = lgetxattr(path->narrow, attribute->narrow, ptr, buffer_size);\n        Py_END_ALLOW_THREADS;\n\n        if (result < 0) {\n            if (errno == ERANGE) {\n                Py_DECREF(buffer);\n                continue;\n            }\n            path_error(path);\n            Py_DECREF(buffer);\n            return NULL;\n        }\n\n        if (result != buffer_size) {\n            /* Can only shrink. */\n            _PyBytes_Resize(&buffer, result);\n        }\n        break;\n    }\n\n    return buffer;\n}\n\n\n/*[clinic input]\nos.setxattr\n\n    path: path_t(allow_fd=True)\n    attribute: path_t\n    value: Py_buffer\n    flags: int = 0\n    *\n    follow_symlinks: bool = True\n\nSet extended attribute attribute on path to value.\n\npath may be either a string, a path-like object,  or an open file descriptor.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, setxattr will modify the symbolic link itself instead of the file\n  the link points to.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_setxattr_impl(PyObject *module, path_t *path, path_t *attribute,\n                 Py_buffer *value, int flags, int follow_symlinks)\n/*[clinic end generated code: output=98b83f63fdde26bb input=c17c0103009042f0]*/\n{\n    ssize_t result;\n\n    if (fd_and_follow_symlinks_invalid(\"setxattr\", path->fd, follow_symlinks))\n        return NULL;\n\n    if (PySys_Audit(\"os.setxattr\", \"OOy#i\", path->object, attribute->object,\n                    value->buf, value->len, flags) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS;\n    if (path->fd > -1)\n        result = fsetxattr(path->fd, attribute->narrow,\n                           value->buf, value->len, flags);\n    else if (follow_symlinks)\n        result = setxattr(path->narrow, attribute->narrow,\n                           value->buf, value->len, flags);\n    else\n        result = lsetxattr(path->narrow, attribute->narrow,\n                           value->buf, value->len, flags);\n    Py_END_ALLOW_THREADS;\n\n    if (result) {\n        path_error(path);\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\n\n/*[clinic input]\nos.removexattr\n\n    path: path_t(allow_fd=True)\n    attribute: path_t\n    *\n    follow_symlinks: bool = True\n\nRemove extended attribute attribute on path.\n\npath may be either a string, a path-like object, or an open file descriptor.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, removexattr will modify the symbolic link itself instead of the file\n  the link points to.\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_removexattr_impl(PyObject *module, path_t *path, path_t *attribute,\n                    int follow_symlinks)\n/*[clinic end generated code: output=521a51817980cda6 input=3d9a7d36fe2f7c4e]*/\n{\n    ssize_t result;\n\n    if (fd_and_follow_symlinks_invalid(\"removexattr\", path->fd, follow_symlinks))\n        return NULL;\n\n    if (PySys_Audit(\"os.removexattr\", \"OO\", path->object, attribute->object) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS;\n    if (path->fd > -1)\n        result = fremovexattr(path->fd, attribute->narrow);\n    else if (follow_symlinks)\n        result = removexattr(path->narrow, attribute->narrow);\n    else\n        result = lremovexattr(path->narrow, attribute->narrow);\n    Py_END_ALLOW_THREADS;\n\n    if (result) {\n        return path_error(path);\n    }\n\n    Py_RETURN_NONE;\n}\n\n\n/*[clinic input]\nos.listxattr\n\n    path: path_t(allow_fd=True, nullable=True) = None\n    *\n    follow_symlinks: bool = True\n\nReturn a list of extended attributes on path.\n\npath may be either None, a string, a path-like object, or an open file descriptor.\nif path is None, listxattr will examine the current directory.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, listxattr will examine the symbolic link itself instead of the file\n  the link points to.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_listxattr_impl(PyObject *module, path_t *path, int follow_symlinks)\n/*[clinic end generated code: output=bebdb4e2ad0ce435 input=9826edf9fdb90869]*/\n{\n    Py_ssize_t i;\n    PyObject *result = NULL;\n    const char *name;\n    char *buffer = NULL;\n\n    if (fd_and_follow_symlinks_invalid(\"listxattr\", path->fd, follow_symlinks))\n        goto exit;\n\n    if (PySys_Audit(\"os.listxattr\", \"(O)\",\n                    path->object ? path->object : Py_None) < 0) {\n        return NULL;\n    }\n\n    name = path->narrow ? path->narrow : \".\";\n\n    for (i = 0; ; i++) {\n        const char *start, *trace, *end;\n        ssize_t length;\n        static const Py_ssize_t buffer_sizes[] = { 256, XATTR_LIST_MAX, 0 };\n        Py_ssize_t buffer_size = buffer_sizes[i];\n        if (!buffer_size) {\n            /* ERANGE */\n            path_error(path);\n            break;\n        }\n        buffer = PyMem_Malloc(buffer_size);\n        if (!buffer) {\n            PyErr_NoMemory();\n            break;\n        }\n\n        Py_BEGIN_ALLOW_THREADS;\n        if (path->fd > -1)\n            length = flistxattr(path->fd, buffer, buffer_size);\n        else if (follow_symlinks)\n            length = listxattr(name, buffer, buffer_size);\n        else\n            length = llistxattr(name, buffer, buffer_size);\n        Py_END_ALLOW_THREADS;\n\n        if (length < 0) {\n            if (errno == ERANGE) {\n                PyMem_Free(buffer);\n                buffer = NULL;\n                continue;\n            }\n            path_error(path);\n            break;\n        }\n\n        result = PyList_New(0);\n        if (!result) {\n            goto exit;\n        }\n\n        end = buffer + length;\n        for (trace = start = buffer; trace != end; trace++) {\n            if (!*trace) {\n                int error;\n                PyObject *attribute = PyUnicode_DecodeFSDefaultAndSize(start,\n                                                                 trace - start);\n                if (!attribute) {\n                    Py_SETREF(result, NULL);\n                    goto exit;\n                }\n                error = PyList_Append(result, attribute);\n                Py_DECREF(attribute);\n                if (error) {\n                    Py_SETREF(result, NULL);\n                    goto exit;\n                }\n                start = trace + 1;\n            }\n        }\n    break;\n    }\nexit:\n    if (buffer)\n        PyMem_Free(buffer);\n    return result;\n}\n#endif /* USE_XATTRS */\n\n\n/*[clinic input]\nos.urandom\n\n    size: Py_ssize_t\n    /\n\nReturn a bytes object containing random bytes suitable for cryptographic use.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_urandom_impl(PyObject *module, Py_ssize_t size)\n/*[clinic end generated code: output=42c5cca9d18068e9 input=4067cdb1b6776c29]*/\n{\n    PyObject *bytes;\n    int result;\n\n    if (size < 0)\n        return PyErr_Format(PyExc_ValueError,\n                            \"negative argument not allowed\");\n    bytes = PyBytes_FromStringAndSize(NULL, size);\n    if (bytes == NULL)\n        return NULL;\n\n    result = _PyOS_URandom(PyBytes_AS_STRING(bytes), PyBytes_GET_SIZE(bytes));\n    if (result == -1) {\n        Py_DECREF(bytes);\n        return NULL;\n    }\n    return bytes;\n}\n\n#ifdef HAVE_MEMFD_CREATE\n/*[clinic input]\nos.memfd_create\n\n    name: FSConverter\n    flags: unsigned_int(bitwise=True, c_default=\"MFD_CLOEXEC\") = MFD_CLOEXEC\n\n[clinic start generated code]*/\n\nstatic PyObject *\nos_memfd_create_impl(PyObject *module, PyObject *name, unsigned int flags)\n/*[clinic end generated code: output=6681ede983bdb9a6 input=a42cfc199bcd56e9]*/\n{\n    int fd;\n    const char *bytes = PyBytes_AS_STRING(name);\n    Py_BEGIN_ALLOW_THREADS\n    fd = memfd_create(bytes, flags);\n    Py_END_ALLOW_THREADS\n    if (fd == -1) {\n        return PyErr_SetFromErrno(PyExc_OSError);\n    }\n    return PyLong_FromLong(fd);\n}\n#endif\n\n#if defined(HAVE_EVENTFD) && defined(EFD_CLOEXEC)\n/*[clinic input]\nos.eventfd\n\n    initval: unsigned_int\n    flags: int(c_default=\"EFD_CLOEXEC\") = EFD_CLOEXEC\n\nCreates and returns an event notification file descriptor.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_eventfd_impl(PyObject *module, unsigned int initval, int flags)\n/*[clinic end generated code: output=ce9c9bbd1446f2de input=66203e3c50c4028b]*/\n\n{\n    /* initval is limited to uint32_t, internal counter is uint64_t */\n    int fd;\n    Py_BEGIN_ALLOW_THREADS\n    fd = eventfd(initval, flags);\n    Py_END_ALLOW_THREADS\n    if (fd == -1) {\n        return PyErr_SetFromErrno(PyExc_OSError);\n    }\n    return PyLong_FromLong(fd);\n}\n\n/*[clinic input]\nos.eventfd_read\n\n    fd: fildes\n\nRead eventfd value\n[clinic start generated code]*/\n\nstatic PyObject *\nos_eventfd_read_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=8f2c7b59a3521fd1 input=110f8b57fa596afe]*/\n{\n    eventfd_t value;\n    int result;\n    Py_BEGIN_ALLOW_THREADS\n    result = eventfd_read(fd, &value);\n    Py_END_ALLOW_THREADS\n    if (result == -1) {\n        return PyErr_SetFromErrno(PyExc_OSError);\n    }\n    return PyLong_FromUnsignedLongLong(value);\n}\n\n/*[clinic input]\nos.eventfd_write\n\n    fd: fildes\n    value: unsigned_long_long\n\nWrite eventfd value.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_eventfd_write_impl(PyObject *module, int fd, unsigned long long value)\n/*[clinic end generated code: output=bebd9040bbf987f5 input=156de8555be5a949]*/\n{\n    int result;\n    Py_BEGIN_ALLOW_THREADS\n    result = eventfd_write(fd, value);\n    Py_END_ALLOW_THREADS\n    if (result == -1) {\n        return PyErr_SetFromErrno(PyExc_OSError);\n    }\n    Py_RETURN_NONE;\n}\n#endif  /* HAVE_EVENTFD && EFD_CLOEXEC */\n\n/* Terminal size querying */\n\nPyDoc_STRVAR(TerminalSize_docstring,\n    \"A tuple of (columns, lines) for holding terminal window size\");\n\nstatic PyStructSequence_Field TerminalSize_fields[] = {\n    {\"columns\", \"width of the terminal window in characters\"},\n    {\"lines\", \"height of the terminal window in characters\"},\n    {NULL, NULL}\n};\n\nstatic PyStructSequence_Desc TerminalSize_desc = {\n    \"os.terminal_size\",\n    TerminalSize_docstring,\n    TerminalSize_fields,\n    2,\n};\n\n#if defined(TERMSIZE_USE_CONIO) || defined(TERMSIZE_USE_IOCTL)\n/*[clinic input]\nos.get_terminal_size\n\n    fd: int(c_default=\"fileno(stdout)\", py_default=\"<unrepresentable>\") = -1\n    /\n\nReturn the size of the terminal window as (columns, lines).\n\nThe optional argument fd (default standard output) specifies\nwhich file descriptor should be queried.\n\nIf the file descriptor is not connected to a terminal, an OSError\nis thrown.\n\nThis function will only be defined if an implementation is\navailable for this system.\n\nshutil.get_terminal_size is the high-level function which should\nnormally be used, os.get_terminal_size is the low-level implementation.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_get_terminal_size_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=fbab93acef980508 input=ead5679b82ddb920]*/\n{\n    int columns, lines;\n    PyObject *termsize;\n\n    /* Under some conditions stdout may not be connected and\n     * fileno(stdout) may point to an invalid file descriptor. For example\n     * GUI apps don't have valid standard streams by default.\n     *\n     * If this happens, and the optional fd argument is not present,\n     * the ioctl below will fail returning EBADF. This is what we want.\n     */\n\n#ifdef TERMSIZE_USE_IOCTL\n    {\n        struct winsize w;\n        if (ioctl(fd, TIOCGWINSZ, &w))\n            return PyErr_SetFromErrno(PyExc_OSError);\n        columns = w.ws_col;\n        lines = w.ws_row;\n    }\n#endif /* TERMSIZE_USE_IOCTL */\n\n#ifdef TERMSIZE_USE_CONIO\n    {\n        HANDLE handle;\n        CONSOLE_SCREEN_BUFFER_INFO csbi;\n        handle = _Py_get_osfhandle(fd);\n        if (handle == INVALID_HANDLE_VALUE)\n            return NULL;\n\n        if (!GetConsoleScreenBufferInfo(handle, &csbi))\n            return PyErr_SetFromWindowsErr(0);\n\n        columns = csbi.srWindow.Right - csbi.srWindow.Left + 1;\n        lines = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;\n    }\n#endif /* TERMSIZE_USE_CONIO */\n\n    PyObject *TerminalSizeType = get_posix_state(module)->TerminalSizeType;\n    termsize = PyStructSequence_New((PyTypeObject *)TerminalSizeType);\n    if (termsize == NULL)\n        return NULL;\n\n    int pos = 0;\n\n#define SET_TERMSIZE(CALL)                                   \\\n    do {                                                     \\\n        PyObject *item = (CALL);                             \\\n        if (item == NULL) {                                  \\\n            Py_DECREF(termsize);                             \\\n            return NULL;                                     \\\n        }                                                    \\\n        PyStructSequence_SET_ITEM(termsize, pos++, item);    \\\n    } while(0)\n\n    SET_TERMSIZE(PyLong_FromLong(columns));\n    SET_TERMSIZE(PyLong_FromLong(lines));\n#undef SET_TERMSIZE\n\n    return termsize;\n}\n#endif /* defined(TERMSIZE_USE_CONIO) || defined(TERMSIZE_USE_IOCTL) */\n\n/*[clinic input]\nos.cpu_count\n\nReturn the number of logical CPUs in the system.\n\nReturn None if indeterminable.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_cpu_count_impl(PyObject *module)\n/*[clinic end generated code: output=5fc29463c3936a9c input=ba2f6f8980a0e2eb]*/\n{\n    const PyConfig *config = _Py_GetConfig();\n    if (config->cpu_count > 0) {\n        return PyLong_FromLong(config->cpu_count);\n    }\n\n    int ncpu = 0;\n#ifdef MS_WINDOWS\n# ifdef MS_WINDOWS_DESKTOP\n    ncpu = GetActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n# else\n    ncpu = 0;\n# endif\n\n#elif defined(__hpux)\n    ncpu = mpctl(MPC_GETNUMSPUS, NULL, NULL);\n\n#elif defined(HAVE_SYSCONF) && defined(_SC_NPROCESSORS_ONLN)\n    ncpu = sysconf(_SC_NPROCESSORS_ONLN);\n\n#elif defined(__VXWORKS__)\n    ncpu = _Py_popcount32(vxCpuEnabledGet());\n\n#elif defined(__DragonFly__) || \\\n      defined(__OpenBSD__)   || \\\n      defined(__FreeBSD__)   || \\\n      defined(__NetBSD__)    || \\\n      defined(__APPLE__)\n    ncpu = 0;\n    size_t len = sizeof(ncpu);\n    int mib[2] = {CTL_HW, HW_NCPU};\n    if (sysctl(mib, 2, &ncpu, &len, NULL, 0) != 0) {\n        ncpu = 0;\n    }\n#endif\n\n    if (ncpu < 1) {\n        Py_RETURN_NONE;\n    }\n    return PyLong_FromLong(ncpu);\n}\n\n\n/*[clinic input]\nos.get_inheritable -> bool\n\n    fd: int\n    /\n\nGet the close-on-exe flag of the specified file descriptor.\n[clinic start generated code]*/\n\nstatic int\nos_get_inheritable_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=0445e20e149aa5b8 input=89ac008dc9ab6b95]*/\n{\n    int return_value;\n    _Py_BEGIN_SUPPRESS_IPH\n    return_value = _Py_get_inheritable(fd);\n    _Py_END_SUPPRESS_IPH\n    return return_value;\n}\n\n\n/*[clinic input]\nos.set_inheritable\n    fd: int\n    inheritable: int\n    /\n\nSet the inheritable flag of the specified file descriptor.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_set_inheritable_impl(PyObject *module, int fd, int inheritable)\n/*[clinic end generated code: output=f1b1918a2f3c38c2 input=9ceaead87a1e2402]*/\n{\n    int result;\n\n    _Py_BEGIN_SUPPRESS_IPH\n    result = _Py_set_inheritable(fd, inheritable, NULL);\n    _Py_END_SUPPRESS_IPH\n    if (result < 0)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n\n#ifdef MS_WINDOWS\n#ifndef HANDLE_FLAG_INHERIT\n#define HANDLE_FLAG_INHERIT 0x00000001\n#endif\n\n/*[clinic input]\nos.get_handle_inheritable -> bool\n    handle: intptr_t\n    /\n\nGet the close-on-exe flag of the specified file descriptor.\n[clinic start generated code]*/\n\nstatic int\nos_get_handle_inheritable_impl(PyObject *module, intptr_t handle)\n/*[clinic end generated code: output=36be5afca6ea84d8 input=cfe99f9c05c70ad1]*/\n{\n    DWORD flags;\n\n    if (!GetHandleInformation((HANDLE)handle, &flags)) {\n        PyErr_SetFromWindowsErr(0);\n        return -1;\n    }\n\n    return flags & HANDLE_FLAG_INHERIT;\n}\n\n\n/*[clinic input]\nos.set_handle_inheritable\n    handle: intptr_t\n    inheritable: bool\n    /\n\nSet the inheritable flag of the specified handle.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_set_handle_inheritable_impl(PyObject *module, intptr_t handle,\n                               int inheritable)\n/*[clinic end generated code: output=021d74fe6c96baa3 input=7a7641390d8364fc]*/\n{\n    DWORD flags = inheritable ? HANDLE_FLAG_INHERIT : 0;\n    if (!SetHandleInformation((HANDLE)handle, HANDLE_FLAG_INHERIT, flags)) {\n        PyErr_SetFromWindowsErr(0);\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n#endif /* MS_WINDOWS */\n\n/*[clinic input]\nos.get_blocking -> bool\n    fd: int\n    /\n\nGet the blocking mode of the file descriptor.\n\nReturn False if the O_NONBLOCK flag is set, True if the flag is cleared.\n[clinic start generated code]*/\n\nstatic int\nos_get_blocking_impl(PyObject *module, int fd)\n/*[clinic end generated code: output=336a12ad76a61482 input=f4afb59d51560179]*/\n{\n    int blocking;\n\n    _Py_BEGIN_SUPPRESS_IPH\n    blocking = _Py_get_blocking(fd);\n    _Py_END_SUPPRESS_IPH\n    return blocking;\n}\n\n/*[clinic input]\nos.set_blocking\n    fd: int\n    blocking: bool\n    /\n\nSet the blocking mode of the specified file descriptor.\n\nSet the O_NONBLOCK flag if blocking is False,\nclear the O_NONBLOCK flag otherwise.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_set_blocking_impl(PyObject *module, int fd, int blocking)\n/*[clinic end generated code: output=384eb43aa0762a9d input=7e9dfc9b14804dd4]*/\n{\n    int result;\n\n    _Py_BEGIN_SUPPRESS_IPH\n    result = _Py_set_blocking(fd, blocking);\n    _Py_END_SUPPRESS_IPH\n    if (result < 0)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n\n/*[clinic input]\nclass os.DirEntry \"DirEntry *\" \"DirEntryType\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=3c18c7a448247980]*/\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *name;\n    PyObject *path;\n    PyObject *stat;\n    PyObject *lstat;\n#ifdef MS_WINDOWS\n    struct _Py_stat_struct win32_lstat;\n    uint64_t win32_file_index;\n    uint64_t win32_file_index_high;\n    int got_file_index;\n#else /* POSIX */\n#ifdef HAVE_DIRENT_D_TYPE\n    unsigned char d_type;\n#endif\n    ino_t d_ino;\n    int dir_fd;\n#endif\n} DirEntry;\n\nstatic void\nDirEntry_dealloc(DirEntry *entry)\n{\n    PyTypeObject *tp = Py_TYPE(entry);\n    Py_XDECREF(entry->name);\n    Py_XDECREF(entry->path);\n    Py_XDECREF(entry->stat);\n    Py_XDECREF(entry->lstat);\n    freefunc free_func = PyType_GetSlot(tp, Py_tp_free);\n    free_func(entry);\n    Py_DECREF(tp);\n}\n\n/* Forward reference */\nstatic int\nDirEntry_test_mode(PyTypeObject *defining_class, DirEntry *self,\n                   int follow_symlinks, unsigned short mode_bits);\n\n/*[clinic input]\nos.DirEntry.is_symlink -> bool\n    defining_class: defining_class\n    /\n\nReturn True if the entry is a symbolic link; cached per entry.\n[clinic start generated code]*/\n\nstatic int\nos_DirEntry_is_symlink_impl(DirEntry *self, PyTypeObject *defining_class)\n/*[clinic end generated code: output=293096d589b6d47c input=e9acc5ee4d511113]*/\n{\n#ifdef MS_WINDOWS\n    return (self->win32_lstat.st_mode & S_IFMT) == S_IFLNK;\n#elif defined(HAVE_DIRENT_D_TYPE)\n    /* POSIX */\n    if (self->d_type != DT_UNKNOWN)\n        return self->d_type == DT_LNK;\n    else\n        return DirEntry_test_mode(defining_class, self, 0, S_IFLNK);\n#else\n    /* POSIX without d_type */\n    return DirEntry_test_mode(defining_class, self, 0, S_IFLNK);\n#endif\n}\n\n/*[clinic input]\nos.DirEntry.is_junction -> bool\n\nReturn True if the entry is a junction; cached per entry.\n[clinic start generated code]*/\n\nstatic int\nos_DirEntry_is_junction_impl(DirEntry *self)\n/*[clinic end generated code: output=97f64d5d99eeccb5 input=4fc8e701eea118a1]*/\n{\n#ifdef MS_WINDOWS\n    return self->win32_lstat.st_reparse_tag == IO_REPARSE_TAG_MOUNT_POINT;\n#else\n    return 0;\n#endif\n}\n\nstatic PyObject *\nDirEntry_fetch_stat(PyObject *module, DirEntry *self, int follow_symlinks)\n{\n    int result;\n    STRUCT_STAT st;\n    PyObject *ub;\n\n#ifdef MS_WINDOWS\n    if (!PyUnicode_FSDecoder(self->path, &ub))\n        return NULL;\n    wchar_t *path = PyUnicode_AsWideCharString(ub, NULL);\n    Py_DECREF(ub);\n#else /* POSIX */\n    if (!PyUnicode_FSConverter(self->path, &ub))\n        return NULL;\n    const char *path = PyBytes_AS_STRING(ub);\n    if (self->dir_fd != DEFAULT_DIR_FD) {\n#ifdef HAVE_FSTATAT\n      if (HAVE_FSTATAT_RUNTIME) {\n        Py_BEGIN_ALLOW_THREADS\n        result = fstatat(self->dir_fd, path, &st,\n                         follow_symlinks ? 0 : AT_SYMLINK_NOFOLLOW);\n        Py_END_ALLOW_THREADS\n      } else\n\n#endif /* HAVE_FSTATAT */\n      {\n        Py_DECREF(ub);\n        PyErr_SetString(PyExc_NotImplementedError, \"can't fetch stat\");\n        return NULL;\n      }\n    }\n    else\n#endif\n    {\n        Py_BEGIN_ALLOW_THREADS\n        if (follow_symlinks) {\n            result = STAT(path, &st);\n        }\n        else {\n            result = LSTAT(path, &st);\n        }\n        Py_END_ALLOW_THREADS\n    }\n\n    int saved_errno = errno;\n#if defined(MS_WINDOWS)\n    PyMem_Free(path);\n#else\n    Py_DECREF(ub);\n#endif\n\n    if (result != 0) {\n        errno = saved_errno;\n        path_object_error(self->path);\n        return NULL;\n    }\n\n    return _pystat_fromstructstat(module, &st);\n}\n\nstatic PyObject *\nDirEntry_get_lstat(PyTypeObject *defining_class, DirEntry *self)\n{\n    if (!self->lstat) {\n        PyObject *module = PyType_GetModule(defining_class);\n#ifdef MS_WINDOWS\n        self->lstat = _pystat_fromstructstat(module, &self->win32_lstat);\n#else /* POSIX */\n        self->lstat = DirEntry_fetch_stat(module, self, 0);\n#endif\n    }\n    return Py_XNewRef(self->lstat);\n}\n\n/*[clinic input]\nos.DirEntry.stat\n    defining_class: defining_class\n    /\n    *\n    follow_symlinks: bool = True\n\nReturn stat_result object for the entry; cached per entry.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_DirEntry_stat_impl(DirEntry *self, PyTypeObject *defining_class,\n                      int follow_symlinks)\n/*[clinic end generated code: output=23f803e19c3e780e input=e816273c4e67ee98]*/\n{\n    if (!follow_symlinks) {\n        return DirEntry_get_lstat(defining_class, self);\n    }\n\n    if (!self->stat) {\n        int result = os_DirEntry_is_symlink_impl(self, defining_class);\n        if (result == -1) {\n            return NULL;\n        }\n        if (result) {\n            PyObject *module = PyType_GetModule(defining_class);\n            self->stat = DirEntry_fetch_stat(module, self, 1);\n        }\n        else {\n            self->stat = DirEntry_get_lstat(defining_class, self);\n        }\n    }\n\n    return Py_XNewRef(self->stat);\n}\n\n/* Set exception and return -1 on error, 0 for False, 1 for True */\nstatic int\nDirEntry_test_mode(PyTypeObject *defining_class, DirEntry *self,\n                   int follow_symlinks, unsigned short mode_bits)\n{\n    PyObject *stat = NULL;\n    PyObject *st_mode = NULL;\n    long mode;\n    int result;\n#if defined(MS_WINDOWS) || defined(HAVE_DIRENT_D_TYPE)\n    int is_symlink;\n    int need_stat;\n#endif\n#ifdef MS_WINDOWS\n    unsigned long dir_bits;\n#endif\n\n#ifdef MS_WINDOWS\n    is_symlink = (self->win32_lstat.st_mode & S_IFMT) == S_IFLNK;\n    need_stat = follow_symlinks && is_symlink;\n#elif defined(HAVE_DIRENT_D_TYPE)\n    is_symlink = self->d_type == DT_LNK;\n    need_stat = self->d_type == DT_UNKNOWN || (follow_symlinks && is_symlink);\n#endif\n\n#if defined(MS_WINDOWS) || defined(HAVE_DIRENT_D_TYPE)\n    if (need_stat) {\n#endif\n        stat = os_DirEntry_stat_impl(self, defining_class, follow_symlinks);\n        if (!stat) {\n            if (PyErr_ExceptionMatches(PyExc_FileNotFoundError)) {\n                /* If file doesn't exist (anymore), then return False\n                   (i.e., say it's not a file/directory) */\n                PyErr_Clear();\n                return 0;\n            }\n            goto error;\n        }\n        _posixstate* state = get_posix_state(PyType_GetModule(defining_class));\n        st_mode = PyObject_GetAttr(stat, state->st_mode);\n        if (!st_mode)\n            goto error;\n\n        mode = PyLong_AsLong(st_mode);\n        if (mode == -1 && PyErr_Occurred())\n            goto error;\n        Py_CLEAR(st_mode);\n        Py_CLEAR(stat);\n        result = (mode & S_IFMT) == mode_bits;\n#if defined(MS_WINDOWS) || defined(HAVE_DIRENT_D_TYPE)\n    }\n    else if (is_symlink) {\n        assert(mode_bits != S_IFLNK);\n        result = 0;\n    }\n    else {\n        assert(mode_bits == S_IFDIR || mode_bits == S_IFREG);\n#ifdef MS_WINDOWS\n        dir_bits = self->win32_lstat.st_file_attributes & FILE_ATTRIBUTE_DIRECTORY;\n        if (mode_bits == S_IFDIR)\n            result = dir_bits != 0;\n        else\n            result = dir_bits == 0;\n#else /* POSIX */\n        if (mode_bits == S_IFDIR)\n            result = self->d_type == DT_DIR;\n        else\n            result = self->d_type == DT_REG;\n#endif\n    }\n#endif\n\n    return result;\n\nerror:\n    Py_XDECREF(st_mode);\n    Py_XDECREF(stat);\n    return -1;\n}\n\n/*[clinic input]\nos.DirEntry.is_dir -> bool\n    defining_class: defining_class\n    /\n    *\n    follow_symlinks: bool = True\n\nReturn True if the entry is a directory; cached per entry.\n[clinic start generated code]*/\n\nstatic int\nos_DirEntry_is_dir_impl(DirEntry *self, PyTypeObject *defining_class,\n                        int follow_symlinks)\n/*[clinic end generated code: output=0cd453b9c0987fdf input=1a4ffd6dec9920cb]*/\n{\n    return DirEntry_test_mode(defining_class, self, follow_symlinks, S_IFDIR);\n}\n\n/*[clinic input]\nos.DirEntry.is_file -> bool\n    defining_class: defining_class\n    /\n    *\n    follow_symlinks: bool = True\n\nReturn True if the entry is a file; cached per entry.\n[clinic start generated code]*/\n\nstatic int\nos_DirEntry_is_file_impl(DirEntry *self, PyTypeObject *defining_class,\n                         int follow_symlinks)\n/*[clinic end generated code: output=f7c277ab5ba80908 input=0a64c5a12e802e3b]*/\n{\n    return DirEntry_test_mode(defining_class, self, follow_symlinks, S_IFREG);\n}\n\n/*[clinic input]\nos.DirEntry.inode\n\nReturn inode of the entry; cached per entry.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_DirEntry_inode_impl(DirEntry *self)\n/*[clinic end generated code: output=156bb3a72162440e input=3ee7b872ae8649f0]*/\n{\n#ifdef MS_WINDOWS\n    if (!self->got_file_index) {\n        PyObject *unicode;\n        STRUCT_STAT stat;\n        int result;\n\n        if (!PyUnicode_FSDecoder(self->path, &unicode))\n            return NULL;\n        wchar_t *path = PyUnicode_AsWideCharString(unicode, NULL);\n        Py_DECREF(unicode);\n        result = LSTAT(path, &stat);\n\n        int saved_errno = errno;\n        PyMem_Free(path);\n\n        if (result != 0) {\n            errno = saved_errno;\n            return path_object_error(self->path);\n        }\n\n        self->win32_file_index = stat.st_ino;\n        self->win32_file_index_high = stat.st_ino_high;\n        self->got_file_index = 1;\n    }\n    return _pystat_l128_from_l64_l64(self->win32_file_index, self->win32_file_index_high);\n#else /* POSIX */\n    static_assert(sizeof(unsigned long long) >= sizeof(self->d_ino),\n                  \"DirEntry.d_ino is larger than unsigned long long\");\n    return PyLong_FromUnsignedLongLong(self->d_ino);\n#endif\n}\n\nstatic PyObject *\nDirEntry_repr(DirEntry *self)\n{\n    return PyUnicode_FromFormat(\"<DirEntry %R>\", self->name);\n}\n\n/*[clinic input]\nos.DirEntry.__fspath__\n\nReturns the path for the entry.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_DirEntry___fspath___impl(DirEntry *self)\n/*[clinic end generated code: output=6dd7f7ef752e6f4f input=3c49d0cf38df4fac]*/\n{\n    return Py_NewRef(self->path);\n}\n\nstatic PyMemberDef DirEntry_members[] = {\n    {\"name\", Py_T_OBJECT_EX, offsetof(DirEntry, name), Py_READONLY,\n     \"the entry's base filename, relative to scandir() \\\"path\\\" argument\"},\n    {\"path\", Py_T_OBJECT_EX, offsetof(DirEntry, path), Py_READONLY,\n     \"the entry's full path name; equivalent to os.path.join(scandir_path, entry.name)\"},\n    {NULL}\n};\n\n#include \"clinic/posixmodule.c.h\"\n\nstatic PyMethodDef DirEntry_methods[] = {\n    OS_DIRENTRY_IS_DIR_METHODDEF\n    OS_DIRENTRY_IS_FILE_METHODDEF\n    OS_DIRENTRY_IS_SYMLINK_METHODDEF\n    OS_DIRENTRY_IS_JUNCTION_METHODDEF\n    OS_DIRENTRY_STAT_METHODDEF\n    OS_DIRENTRY_INODE_METHODDEF\n    OS_DIRENTRY___FSPATH___METHODDEF\n    {\"__class_getitem__\",       Py_GenericAlias,\n    METH_O|METH_CLASS,          PyDoc_STR(\"See PEP 585\")},\n    {NULL}\n};\n\nstatic PyType_Slot DirEntryType_slots[] = {\n    {Py_tp_dealloc, DirEntry_dealloc},\n    {Py_tp_repr, DirEntry_repr},\n    {Py_tp_methods, DirEntry_methods},\n    {Py_tp_members, DirEntry_members},\n    {0, 0},\n};\n\nstatic PyType_Spec DirEntryType_spec = {\n    MODNAME \".DirEntry\",\n    sizeof(DirEntry),\n    0,\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,\n    DirEntryType_slots\n};\n\n\n#ifdef MS_WINDOWS\n\nstatic wchar_t *\njoin_path_filenameW(const wchar_t *path_wide, const wchar_t *filename)\n{\n    Py_ssize_t path_len;\n    Py_ssize_t size;\n    wchar_t *result;\n    wchar_t ch;\n\n    if (!path_wide) { /* Default arg: \".\" */\n        path_wide = L\".\";\n        path_len = 1;\n    }\n    else {\n        path_len = wcslen(path_wide);\n    }\n\n    /* The +1's are for the path separator and the NUL */\n    size = path_len + 1 + wcslen(filename) + 1;\n    result = PyMem_New(wchar_t, size);\n    if (!result) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    wcscpy(result, path_wide);\n    if (path_len > 0) {\n        ch = result[path_len - 1];\n        if (ch != SEP && ch != ALTSEP && ch != L':')\n            result[path_len++] = SEP;\n        wcscpy(result + path_len, filename);\n    }\n    return result;\n}\n\nstatic PyObject *\nDirEntry_from_find_data(PyObject *module, path_t *path, WIN32_FIND_DATAW *dataW)\n{\n    DirEntry *entry;\n    BY_HANDLE_FILE_INFORMATION file_info;\n    ULONG reparse_tag;\n    wchar_t *joined_path;\n\n    PyObject *DirEntryType = get_posix_state(module)->DirEntryType;\n    entry = PyObject_New(DirEntry, (PyTypeObject *)DirEntryType);\n    if (!entry)\n        return NULL;\n    entry->name = NULL;\n    entry->path = NULL;\n    entry->stat = NULL;\n    entry->lstat = NULL;\n    entry->got_file_index = 0;\n\n    entry->name = PyUnicode_FromWideChar(dataW->cFileName, -1);\n    if (!entry->name)\n        goto error;\n    int return_bytes = path->wide && PyBytes_Check(path->object);\n    if (return_bytes) {\n        Py_SETREF(entry->name, PyUnicode_EncodeFSDefault(entry->name));\n        if (!entry->name)\n            goto error;\n    }\n\n    joined_path = join_path_filenameW(path->wide, dataW->cFileName);\n    if (!joined_path)\n        goto error;\n\n    entry->path = PyUnicode_FromWideChar(joined_path, -1);\n    PyMem_Free(joined_path);\n    if (!entry->path)\n        goto error;\n    if (return_bytes) {\n        Py_SETREF(entry->path, PyUnicode_EncodeFSDefault(entry->path));\n        if (!entry->path)\n            goto error;\n    }\n\n    find_data_to_file_info(dataW, &file_info, &reparse_tag);\n    _Py_attribute_data_to_stat(&file_info, reparse_tag, NULL, NULL, &entry->win32_lstat);\n\n    /* ctime is only deprecated from 3.12, so we copy birthtime across */\n    entry->win32_lstat.st_ctime = entry->win32_lstat.st_birthtime;\n    entry->win32_lstat.st_ctime_nsec = entry->win32_lstat.st_birthtime_nsec;\n\n    return (PyObject *)entry;\n\nerror:\n    Py_DECREF(entry);\n    return NULL;\n}\n\n#else /* POSIX */\n\nstatic char *\njoin_path_filename(const char *path_narrow, const char* filename, Py_ssize_t filename_len)\n{\n    Py_ssize_t path_len;\n    Py_ssize_t size;\n    char *result;\n\n    if (!path_narrow) { /* Default arg: \".\" */\n        path_narrow = \".\";\n        path_len = 1;\n    }\n    else {\n        path_len = strlen(path_narrow);\n    }\n\n    if (filename_len == -1)\n        filename_len = strlen(filename);\n\n    /* The +1's are for the path separator and the NUL */\n    size = path_len + 1 + filename_len + 1;\n    result = PyMem_New(char, size);\n    if (!result) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    strcpy(result, path_narrow);\n    if (path_len > 0 && result[path_len - 1] != '/')\n        result[path_len++] = '/';\n    strcpy(result + path_len, filename);\n    return result;\n}\n\nstatic PyObject *\nDirEntry_from_posix_info(PyObject *module, path_t *path, const char *name,\n                         Py_ssize_t name_len, ino_t d_ino\n#ifdef HAVE_DIRENT_D_TYPE\n                         , unsigned char d_type\n#endif\n                         )\n{\n    DirEntry *entry;\n    char *joined_path;\n\n    PyObject *DirEntryType = get_posix_state(module)->DirEntryType;\n    entry = PyObject_New(DirEntry, (PyTypeObject *)DirEntryType);\n    if (!entry)\n        return NULL;\n    entry->name = NULL;\n    entry->path = NULL;\n    entry->stat = NULL;\n    entry->lstat = NULL;\n\n    if (path->fd != -1) {\n        entry->dir_fd = path->fd;\n        joined_path = NULL;\n    }\n    else {\n        entry->dir_fd = DEFAULT_DIR_FD;\n        joined_path = join_path_filename(path->narrow, name, name_len);\n        if (!joined_path)\n            goto error;\n    }\n\n    if (!path->narrow || !PyBytes_Check(path->object)) {\n        entry->name = PyUnicode_DecodeFSDefaultAndSize(name, name_len);\n        if (joined_path)\n            entry->path = PyUnicode_DecodeFSDefault(joined_path);\n    }\n    else {\n        entry->name = PyBytes_FromStringAndSize(name, name_len);\n        if (joined_path)\n            entry->path = PyBytes_FromString(joined_path);\n    }\n    PyMem_Free(joined_path);\n    if (!entry->name)\n        goto error;\n\n    if (path->fd != -1) {\n        entry->path = Py_NewRef(entry->name);\n    }\n    else if (!entry->path)\n        goto error;\n\n#ifdef HAVE_DIRENT_D_TYPE\n    entry->d_type = d_type;\n#endif\n    entry->d_ino = d_ino;\n\n    return (PyObject *)entry;\n\nerror:\n    Py_XDECREF(entry);\n    return NULL;\n}\n\n#endif\n\n\ntypedef struct {\n    PyObject_HEAD\n    path_t path;\n#ifdef MS_WINDOWS\n    HANDLE handle;\n    WIN32_FIND_DATAW file_data;\n    int first_time;\n#else /* POSIX */\n    DIR *dirp;\n#endif\n#ifdef HAVE_FDOPENDIR\n    int fd;\n#endif\n} ScandirIterator;\n\n#ifdef MS_WINDOWS\n\nstatic int\nScandirIterator_is_closed(ScandirIterator *iterator)\n{\n    return iterator->handle == INVALID_HANDLE_VALUE;\n}\n\nstatic void\nScandirIterator_closedir(ScandirIterator *iterator)\n{\n    HANDLE handle = iterator->handle;\n\n    if (handle == INVALID_HANDLE_VALUE)\n        return;\n\n    iterator->handle = INVALID_HANDLE_VALUE;\n    Py_BEGIN_ALLOW_THREADS\n    FindClose(handle);\n    Py_END_ALLOW_THREADS\n}\n\nstatic PyObject *\nScandirIterator_iternext(ScandirIterator *iterator)\n{\n    WIN32_FIND_DATAW *file_data = &iterator->file_data;\n    BOOL success;\n    PyObject *entry;\n\n    /* Happens if the iterator is iterated twice, or closed explicitly */\n    if (iterator->handle == INVALID_HANDLE_VALUE)\n        return NULL;\n\n    while (1) {\n        if (!iterator->first_time) {\n            Py_BEGIN_ALLOW_THREADS\n            success = FindNextFileW(iterator->handle, file_data);\n            Py_END_ALLOW_THREADS\n            if (!success) {\n                /* Error or no more files */\n                if (GetLastError() != ERROR_NO_MORE_FILES)\n                    path_error(&iterator->path);\n                break;\n            }\n        }\n        iterator->first_time = 0;\n\n        /* Skip over . and .. */\n        if (wcscmp(file_data->cFileName, L\".\") != 0 &&\n            wcscmp(file_data->cFileName, L\"..\") != 0)\n        {\n            PyObject *module = PyType_GetModule(Py_TYPE(iterator));\n            entry = DirEntry_from_find_data(module, &iterator->path, file_data);\n            if (!entry)\n                break;\n            return entry;\n        }\n\n        /* Loop till we get a non-dot directory or finish iterating */\n    }\n\n    /* Error or no more files */\n    ScandirIterator_closedir(iterator);\n    return NULL;\n}\n\n#else /* POSIX */\n\nstatic int\nScandirIterator_is_closed(ScandirIterator *iterator)\n{\n    return !iterator->dirp;\n}\n\nstatic void\nScandirIterator_closedir(ScandirIterator *iterator)\n{\n    DIR *dirp = iterator->dirp;\n\n    if (!dirp)\n        return;\n\n    iterator->dirp = NULL;\n    Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_FDOPENDIR\n    if (iterator->path.fd != -1)\n        rewinddir(dirp);\n#endif\n    closedir(dirp);\n    Py_END_ALLOW_THREADS\n    return;\n}\n\nstatic PyObject *\nScandirIterator_iternext(ScandirIterator *iterator)\n{\n    struct dirent *direntp;\n    Py_ssize_t name_len;\n    int is_dot;\n    PyObject *entry;\n\n    /* Happens if the iterator is iterated twice, or closed explicitly */\n    if (!iterator->dirp)\n        return NULL;\n\n    while (1) {\n        errno = 0;\n        Py_BEGIN_ALLOW_THREADS\n        direntp = readdir(iterator->dirp);\n        Py_END_ALLOW_THREADS\n\n        if (!direntp) {\n            /* Error or no more files */\n            if (errno != 0)\n                path_error(&iterator->path);\n            break;\n        }\n\n        /* Skip over . and .. */\n        name_len = NAMLEN(direntp);\n        is_dot = direntp->d_name[0] == '.' &&\n                 (name_len == 1 || (direntp->d_name[1] == '.' && name_len == 2));\n        if (!is_dot) {\n            PyObject *module = PyType_GetModule(Py_TYPE(iterator));\n            entry = DirEntry_from_posix_info(module,\n                                             &iterator->path, direntp->d_name,\n                                             name_len, direntp->d_ino\n#ifdef HAVE_DIRENT_D_TYPE\n                                             , direntp->d_type\n#endif\n                                            );\n            if (!entry)\n                break;\n            return entry;\n        }\n\n        /* Loop till we get a non-dot directory or finish iterating */\n    }\n\n    /* Error or no more files */\n    ScandirIterator_closedir(iterator);\n    return NULL;\n}\n\n#endif\n\nstatic PyObject *\nScandirIterator_close(ScandirIterator *self, PyObject *args)\n{\n    ScandirIterator_closedir(self);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nScandirIterator_enter(PyObject *self, PyObject *args)\n{\n    return Py_NewRef(self);\n}\n\nstatic PyObject *\nScandirIterator_exit(ScandirIterator *self, PyObject *args)\n{\n    ScandirIterator_closedir(self);\n    Py_RETURN_NONE;\n}\n\nstatic void\nScandirIterator_finalize(ScandirIterator *iterator)\n{\n\n    /* Save the current exception, if any. */\n    PyObject *exc = PyErr_GetRaisedException();\n\n    if (!ScandirIterator_is_closed(iterator)) {\n        ScandirIterator_closedir(iterator);\n\n        if (PyErr_ResourceWarning((PyObject *)iterator, 1,\n                                  \"unclosed scandir iterator %R\", iterator)) {\n            /* Spurious errors can appear at shutdown */\n            if (PyErr_ExceptionMatches(PyExc_Warning)) {\n                PyErr_WriteUnraisable((PyObject *) iterator);\n            }\n        }\n    }\n\n    path_cleanup(&iterator->path);\n\n    /* Restore the saved exception. */\n    PyErr_SetRaisedException(exc);\n}\n\nstatic void\nScandirIterator_dealloc(ScandirIterator *iterator)\n{\n    PyTypeObject *tp = Py_TYPE(iterator);\n    if (PyObject_CallFinalizerFromDealloc((PyObject *)iterator) < 0)\n        return;\n\n    freefunc free_func = PyType_GetSlot(tp, Py_tp_free);\n    free_func(iterator);\n    Py_DECREF(tp);\n}\n\nstatic PyMethodDef ScandirIterator_methods[] = {\n    {\"__enter__\", (PyCFunction)ScandirIterator_enter, METH_NOARGS},\n    {\"__exit__\", (PyCFunction)ScandirIterator_exit, METH_VARARGS},\n    {\"close\", (PyCFunction)ScandirIterator_close, METH_NOARGS},\n    {NULL}\n};\n\nstatic PyType_Slot ScandirIteratorType_slots[] = {\n    {Py_tp_dealloc, ScandirIterator_dealloc},\n    {Py_tp_finalize, ScandirIterator_finalize},\n    {Py_tp_iter, PyObject_SelfIter},\n    {Py_tp_iternext, ScandirIterator_iternext},\n    {Py_tp_methods, ScandirIterator_methods},\n    {0, 0},\n};\n\nstatic PyType_Spec ScandirIteratorType_spec = {\n    MODNAME \".ScandirIterator\",\n    sizeof(ScandirIterator),\n    0,\n    // bpo-40549: Py_TPFLAGS_BASETYPE should not be used, since\n    // PyType_GetModule(Py_TYPE(self)) doesn't work on a subclass instance.\n    (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_FINALIZE\n        | Py_TPFLAGS_DISALLOW_INSTANTIATION),\n    ScandirIteratorType_slots\n};\n\n/*[clinic input]\nos.scandir\n\n    path : path_t(nullable=True, allow_fd='PATH_HAVE_FDOPENDIR') = None\n\nReturn an iterator of DirEntry objects for given path.\n\npath can be specified as either str, bytes, or a path-like object.  If path\nis bytes, the names of yielded DirEntry objects will also be bytes; in\nall other circumstances they will be str.\n\nIf path is None, uses the path='.'.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_scandir_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=6eb2668b675ca89e input=6bdd312708fc3bb0]*/\n{\n    ScandirIterator *iterator;\n#ifdef MS_WINDOWS\n    wchar_t *path_strW;\n#else\n    const char *path_str;\n#ifdef HAVE_FDOPENDIR\n    int fd = -1;\n#endif\n#endif\n\n    if (PySys_Audit(\"os.scandir\", \"O\",\n                    path->object ? path->object : Py_None) < 0) {\n        return NULL;\n    }\n\n    PyObject *ScandirIteratorType = get_posix_state(module)->ScandirIteratorType;\n    iterator = PyObject_New(ScandirIterator, (PyTypeObject *)ScandirIteratorType);\n    if (!iterator)\n        return NULL;\n\n#ifdef MS_WINDOWS\n    iterator->handle = INVALID_HANDLE_VALUE;\n#else\n    iterator->dirp = NULL;\n#endif\n\n    /* Move the ownership to iterator->path */\n    memcpy(&iterator->path, path, sizeof(path_t));\n    memset(path, 0, sizeof(path_t));\n\n#ifdef MS_WINDOWS\n    iterator->first_time = 1;\n\n    path_strW = join_path_filenameW(iterator->path.wide, L\"*.*\");\n    if (!path_strW)\n        goto error;\n\n    Py_BEGIN_ALLOW_THREADS\n    iterator->handle = FindFirstFileW(path_strW, &iterator->file_data);\n    Py_END_ALLOW_THREADS\n\n    if (iterator->handle == INVALID_HANDLE_VALUE) {\n        path_error(&iterator->path);\n        PyMem_Free(path_strW);\n        goto error;\n    }\n    PyMem_Free(path_strW);\n#else /* POSIX */\n    errno = 0;\n#ifdef HAVE_FDOPENDIR\n    if (iterator->path.fd != -1) {\n      if (HAVE_FDOPENDIR_RUNTIME) {\n        /* closedir() closes the FD, so we duplicate it */\n        fd = _Py_dup(iterator->path.fd);\n        if (fd == -1)\n            goto error;\n\n        Py_BEGIN_ALLOW_THREADS\n        iterator->dirp = fdopendir(fd);\n        Py_END_ALLOW_THREADS\n      } else {\n        PyErr_SetString(PyExc_TypeError,\n            \"scandir: path should be string, bytes, os.PathLike or None, not int\");\n        return NULL;\n      }\n    }\n    else\n#endif\n    {\n        if (iterator->path.narrow)\n            path_str = iterator->path.narrow;\n        else\n            path_str = \".\";\n\n        Py_BEGIN_ALLOW_THREADS\n        iterator->dirp = opendir(path_str);\n        Py_END_ALLOW_THREADS\n    }\n\n    if (!iterator->dirp) {\n        path_error(&iterator->path);\n#ifdef HAVE_FDOPENDIR\n        if (fd != -1) {\n            Py_BEGIN_ALLOW_THREADS\n            close(fd);\n            Py_END_ALLOW_THREADS\n        }\n#endif\n        goto error;\n    }\n#endif\n\n    return (PyObject *)iterator;\n\nerror:\n    Py_DECREF(iterator);\n    return NULL;\n}\n\n/*\n    Return the file system path representation of the object.\n\n    If the object is str or bytes, then allow it to pass through with\n    an incremented refcount. If the object defines __fspath__(), then\n    return the result of that method. All other types raise a TypeError.\n*/\nPyObject *\nPyOS_FSPath(PyObject *path)\n{\n    /* For error message reasons, this function is manually inlined in\n       path_converter(). */\n    PyObject *func = NULL;\n    PyObject *path_repr = NULL;\n\n    if (PyUnicode_Check(path) || PyBytes_Check(path)) {\n        return Py_NewRef(path);\n    }\n\n    func = _PyObject_LookupSpecial(path, &_Py_ID(__fspath__));\n    if ((NULL == func) || (func == Py_None)) {\n        return PyErr_Format(PyExc_TypeError,\n                            \"expected str, bytes or os.PathLike object, \"\n                            \"not %.200s\",\n                            _PyType_Name(Py_TYPE(path)));\n    }\n\n    path_repr = _PyObject_CallNoArgs(func);\n    Py_DECREF(func);\n    if (NULL == path_repr) {\n        return NULL;\n    }\n\n    if (!(PyUnicode_Check(path_repr) || PyBytes_Check(path_repr))) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected %.200s.__fspath__() to return str or bytes, \"\n                     \"not %.200s\", _PyType_Name(Py_TYPE(path)),\n                     _PyType_Name(Py_TYPE(path_repr)));\n        Py_DECREF(path_repr);\n        return NULL;\n    }\n\n    return path_repr;\n}\n\n/*[clinic input]\nos.fspath\n\n    path: object\n\nReturn the file system path representation of the object.\n\nIf the object is str or bytes, then allow it to pass through as-is. If the\nobject defines __fspath__(), then return the result of that method. All other\ntypes raise a TypeError.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_fspath_impl(PyObject *module, PyObject *path)\n/*[clinic end generated code: output=c3c3b78ecff2914f input=e357165f7b22490f]*/\n{\n    return PyOS_FSPath(path);\n}\n\n#ifdef HAVE_GETRANDOM_SYSCALL\n/*[clinic input]\nos.getrandom\n\n    size: Py_ssize_t\n    flags: int=0\n\nObtain a series of random bytes.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_getrandom_impl(PyObject *module, Py_ssize_t size, int flags)\n/*[clinic end generated code: output=b3a618196a61409c input=59bafac39c594947]*/\n{\n    PyObject *bytes;\n    Py_ssize_t n;\n\n    if (size < 0) {\n        errno = EINVAL;\n        return posix_error();\n    }\n\n    bytes = PyBytes_FromStringAndSize(NULL, size);\n    if (bytes == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    while (1) {\n        n = syscall(SYS_getrandom,\n                    PyBytes_AS_STRING(bytes),\n                    PyBytes_GET_SIZE(bytes),\n                    flags);\n        if (n < 0 && errno == EINTR) {\n            if (PyErr_CheckSignals() < 0) {\n                goto error;\n            }\n\n            /* getrandom() was interrupted by a signal: retry */\n            continue;\n        }\n        break;\n    }\n\n    if (n < 0) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        goto error;\n    }\n\n    if (n != size) {\n        _PyBytes_Resize(&bytes, n);\n    }\n\n    return bytes;\n\nerror:\n    Py_DECREF(bytes);\n    return NULL;\n}\n#endif   /* HAVE_GETRANDOM_SYSCALL */\n\n#if defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_APP) || defined(MS_WINDOWS_SYSTEM)\n\n/* bpo-36085: Helper functions for managing DLL search directories\n * on win32\n */\n\n/*[clinic input]\nos._add_dll_directory\n\n    path: path_t\n\nAdd a path to the DLL search path.\n\nThis search path is used when resolving dependencies for imported\nextension modules (the module itself is resolved through sys.path),\nand also by ctypes.\n\nReturns an opaque value that may be passed to os.remove_dll_directory\nto remove this directory from the search path.\n[clinic start generated code]*/\n\nstatic PyObject *\nos__add_dll_directory_impl(PyObject *module, path_t *path)\n/*[clinic end generated code: output=80b025daebb5d683 input=1de3e6c13a5808c8]*/\n{\n    DLL_DIRECTORY_COOKIE cookie = 0;\n    DWORD err = 0;\n\n    if (PySys_Audit(\"os.add_dll_directory\", \"(O)\", path->object) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    if (!(cookie = AddDllDirectory(path->wide))) {\n        err = GetLastError();\n    }\n    Py_END_ALLOW_THREADS\n\n    if (err) {\n        return win32_error_object_err(\"add_dll_directory\",\n                                      path->object, err);\n    }\n\n    return PyCapsule_New(cookie, \"DLL directory cookie\", NULL);\n}\n\n/*[clinic input]\nos._remove_dll_directory\n\n    cookie: object\n\nRemoves a path from the DLL search path.\n\nThe parameter is an opaque value that was returned from\nos.add_dll_directory. You can only remove directories that you added\nyourself.\n[clinic start generated code]*/\n\nstatic PyObject *\nos__remove_dll_directory_impl(PyObject *module, PyObject *cookie)\n/*[clinic end generated code: output=594350433ae535bc input=c1d16a7e7d9dc5dc]*/\n{\n    DLL_DIRECTORY_COOKIE cookieValue;\n    DWORD err = 0;\n\n    if (!PyCapsule_IsValid(cookie, \"DLL directory cookie\")) {\n        PyErr_SetString(PyExc_TypeError,\n            \"Provided cookie was not returned from os.add_dll_directory\");\n        return NULL;\n    }\n\n    cookieValue = (DLL_DIRECTORY_COOKIE)PyCapsule_GetPointer(\n        cookie, \"DLL directory cookie\");\n\n    Py_BEGIN_ALLOW_THREADS\n    if (!RemoveDllDirectory(cookieValue)) {\n        err = GetLastError();\n    }\n    Py_END_ALLOW_THREADS\n\n    if (err) {\n        return win32_error_object_err(\"remove_dll_directory\",\n                                      NULL, err);\n    }\n\n    if (PyCapsule_SetName(cookie, NULL)) {\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\n#endif /* MS_WINDOWS_APP || MS_WINDOWS_SYSTEM */\n\n\n/* Only check if WIFEXITED is available: expect that it comes\n   with WEXITSTATUS, WIFSIGNALED, etc.\n\n   os.waitstatus_to_exitcode() is implemented in C and not in Python, so\n   subprocess can safely call it during late Python finalization without\n   risking that used os attributes were set to None by finalize_modules(). */\n#if defined(WIFEXITED) || defined(MS_WINDOWS)\n/*[clinic input]\nos.waitstatus_to_exitcode\n\n    status as status_obj: object\n\nConvert a wait status to an exit code.\n\nOn Unix:\n\n* If WIFEXITED(status) is true, return WEXITSTATUS(status).\n* If WIFSIGNALED(status) is true, return -WTERMSIG(status).\n* Otherwise, raise a ValueError.\n\nOn Windows, return status shifted right by 8 bits.\n\nOn Unix, if the process is being traced or if waitpid() was called with\nWUNTRACED option, the caller must first check if WIFSTOPPED(status) is true.\nThis function must not be called if WIFSTOPPED(status) is true.\n[clinic start generated code]*/\n\nstatic PyObject *\nos_waitstatus_to_exitcode_impl(PyObject *module, PyObject *status_obj)\n/*[clinic end generated code: output=db50b1b0ba3c7153 input=7fe2d7fdaea3db42]*/\n{\n#ifndef MS_WINDOWS\n    int status = PyLong_AsInt(status_obj);\n    if (status == -1 && PyErr_Occurred()) {\n        return NULL;\n    }\n\n    WAIT_TYPE wait_status;\n    WAIT_STATUS_INT(wait_status) = status;\n    int exitcode;\n    if (WIFEXITED(wait_status)) {\n        exitcode = WEXITSTATUS(wait_status);\n        /* Sanity check to provide warranty on the function behavior.\n           It should not occur in practice */\n        if (exitcode < 0) {\n            PyErr_Format(PyExc_ValueError, \"invalid WEXITSTATUS: %i\", exitcode);\n            return NULL;\n        }\n    }\n    else if (WIFSIGNALED(wait_status)) {\n        int signum = WTERMSIG(wait_status);\n        /* Sanity check to provide warranty on the function behavior.\n           It should not occurs in practice */\n        if (signum <= 0) {\n            PyErr_Format(PyExc_ValueError, \"invalid WTERMSIG: %i\", signum);\n            return NULL;\n        }\n        exitcode = -signum;\n    } else if (WIFSTOPPED(wait_status)) {\n        /* Status only received if the process is being traced\n           or if waitpid() was called with WUNTRACED option. */\n        int signum = WSTOPSIG(wait_status);\n        PyErr_Format(PyExc_ValueError,\n                     \"process stopped by delivery of signal %i\",\n                     signum);\n        return NULL;\n    }\n    else {\n        PyErr_Format(PyExc_ValueError, \"invalid wait status: %i\", status);\n        return NULL;\n    }\n    return PyLong_FromLong(exitcode);\n#else\n    /* Windows implementation: see os.waitpid() implementation\n       which uses _cwait(). */\n    unsigned long long status = PyLong_AsUnsignedLongLong(status_obj);\n    if (status == (unsigned long long)-1 && PyErr_Occurred()) {\n        return NULL;\n    }\n\n    unsigned long long exitcode = (status >> 8);\n    /* ExitProcess() accepts an UINT type:\n       reject exit code which doesn't fit in an UINT */\n    if (exitcode > UINT_MAX) {\n        PyErr_Format(PyExc_ValueError, \"invalid exit code: %llu\", exitcode);\n        return NULL;\n    }\n    return PyLong_FromUnsignedLong((unsigned long)exitcode);\n#endif\n}\n#endif\n\n#if defined(MS_WINDOWS)\n/*[clinic input]\nos._supports_virtual_terminal\n\nChecks if virtual terminal is supported in windows\n[clinic start generated code]*/\n\nstatic PyObject *\nos__supports_virtual_terminal_impl(PyObject *module)\n/*[clinic end generated code: output=bd0556a6d9d99fe6 input=0752c98e5d321542]*/\n{\n    DWORD mode = 0;\n    HANDLE handle = GetStdHandle(STD_ERROR_HANDLE);\n    if (!GetConsoleMode(handle, &mode)) {\n        Py_RETURN_FALSE;\n    }\n    return PyBool_FromLong(mode & ENABLE_VIRTUAL_TERMINAL_PROCESSING);\n}\n#endif\n\n/*[clinic input]\nos._inputhook\n\nCalls PyOS_CallInputHook droppong the GIL first\n[clinic start generated code]*/\n\nstatic PyObject *\nos__inputhook_impl(PyObject *module)\n/*[clinic end generated code: output=525aca4ef3c6149f input=fc531701930d064f]*/\n{\n     int result = 0;\n     if (PyOS_InputHook) {\n         Py_BEGIN_ALLOW_THREADS;\n         result = PyOS_InputHook();\n         Py_END_ALLOW_THREADS;\n     }\n     return PyLong_FromLong(result);\n}\n\n/*[clinic input]\nos._is_inputhook_installed\n\nChecks if PyOS_CallInputHook is set\n[clinic start generated code]*/\n\nstatic PyObject *\nos__is_inputhook_installed_impl(PyObject *module)\n/*[clinic end generated code: output=3b3eab4f672c689a input=ff177c9938dd76d8]*/\n{\n    return PyBool_FromLong(PyOS_InputHook != NULL);\n}\n\nstatic PyMethodDef posix_methods[] = {\n\n    OS_STAT_METHODDEF\n    OS_ACCESS_METHODDEF\n    OS_TTYNAME_METHODDEF\n    OS_CHDIR_METHODDEF\n    OS_CHFLAGS_METHODDEF\n    OS_CHMOD_METHODDEF\n    OS_FCHMOD_METHODDEF\n    OS_LCHMOD_METHODDEF\n    OS_CHOWN_METHODDEF\n    OS_FCHOWN_METHODDEF\n    OS_LCHOWN_METHODDEF\n    OS_LCHFLAGS_METHODDEF\n    OS_CHROOT_METHODDEF\n    OS_CTERMID_METHODDEF\n    OS_GETCWD_METHODDEF\n    OS_GETCWDB_METHODDEF\n    OS_LINK_METHODDEF\n    OS_LISTDIR_METHODDEF\n    OS_LISTDRIVES_METHODDEF\n    OS_LISTMOUNTS_METHODDEF\n    OS_LISTVOLUMES_METHODDEF\n    OS_LSTAT_METHODDEF\n    OS_MKDIR_METHODDEF\n    OS_NICE_METHODDEF\n    OS_GETPRIORITY_METHODDEF\n    OS_SETPRIORITY_METHODDEF\n    OS_POSIX_SPAWN_METHODDEF\n    OS_POSIX_SPAWNP_METHODDEF\n    OS_READLINK_METHODDEF\n    OS_COPY_FILE_RANGE_METHODDEF\n    OS_SPLICE_METHODDEF\n    OS_RENAME_METHODDEF\n    OS_REPLACE_METHODDEF\n    OS_RMDIR_METHODDEF\n    OS_SYMLINK_METHODDEF\n    OS_SYSTEM_METHODDEF\n    OS_UMASK_METHODDEF\n    OS_UNAME_METHODDEF\n    OS_UNLINK_METHODDEF\n    OS_REMOVE_METHODDEF\n    OS_UTIME_METHODDEF\n    OS_TIMES_METHODDEF\n    OS__EXIT_METHODDEF\n    OS__FCOPYFILE_METHODDEF\n    OS_EXECV_METHODDEF\n    OS_EXECVE_METHODDEF\n    OS_SPAWNV_METHODDEF\n    OS_SPAWNVE_METHODDEF\n    OS_FORK1_METHODDEF\n    OS_FORK_METHODDEF\n    OS_REGISTER_AT_FORK_METHODDEF\n    OS_SCHED_GET_PRIORITY_MAX_METHODDEF\n    OS_SCHED_GET_PRIORITY_MIN_METHODDEF\n    OS_SCHED_GETPARAM_METHODDEF\n    OS_SCHED_GETSCHEDULER_METHODDEF\n    OS_SCHED_RR_GET_INTERVAL_METHODDEF\n    OS_SCHED_SETPARAM_METHODDEF\n    OS_SCHED_SETSCHEDULER_METHODDEF\n    OS_SCHED_YIELD_METHODDEF\n    OS_SCHED_SETAFFINITY_METHODDEF\n    OS_SCHED_GETAFFINITY_METHODDEF\n    OS_POSIX_OPENPT_METHODDEF\n    OS_GRANTPT_METHODDEF\n    OS_UNLOCKPT_METHODDEF\n    OS_PTSNAME_METHODDEF\n    OS_OPENPTY_METHODDEF\n    OS_LOGIN_TTY_METHODDEF\n    OS_FORKPTY_METHODDEF\n    OS_GETEGID_METHODDEF\n    OS_GETEUID_METHODDEF\n    OS_GETGID_METHODDEF\n    OS_GETGROUPLIST_METHODDEF\n    OS_GETGROUPS_METHODDEF\n    OS_GETPID_METHODDEF\n    OS_GETPGRP_METHODDEF\n    OS_GETPPID_METHODDEF\n    OS_GETUID_METHODDEF\n    OS_GETLOGIN_METHODDEF\n    OS_KILL_METHODDEF\n    OS_KILLPG_METHODDEF\n    OS_PLOCK_METHODDEF\n    OS_STARTFILE_METHODDEF\n    OS_SETUID_METHODDEF\n    OS_SETEUID_METHODDEF\n    OS_SETREUID_METHODDEF\n    OS_SETGID_METHODDEF\n    OS_SETEGID_METHODDEF\n    OS_SETREGID_METHODDEF\n    OS_SETGROUPS_METHODDEF\n    OS_INITGROUPS_METHODDEF\n    OS_GETPGID_METHODDEF\n    OS_SETPGRP_METHODDEF\n    OS_WAIT_METHODDEF\n    OS_WAIT3_METHODDEF\n    OS_WAIT4_METHODDEF\n    OS_WAITID_METHODDEF\n    OS_WAITPID_METHODDEF\n    OS_PIDFD_OPEN_METHODDEF\n    OS_GETSID_METHODDEF\n    OS_SETSID_METHODDEF\n    OS_SETPGID_METHODDEF\n    OS_TCGETPGRP_METHODDEF\n    OS_TCSETPGRP_METHODDEF\n    OS_OPEN_METHODDEF\n    OS_CLOSE_METHODDEF\n    OS_CLOSERANGE_METHODDEF\n    OS_DEVICE_ENCODING_METHODDEF\n    OS_DUP_METHODDEF\n    OS_DUP2_METHODDEF\n    OS_LOCKF_METHODDEF\n    OS_LSEEK_METHODDEF\n    OS_READ_METHODDEF\n    OS_READV_METHODDEF\n    OS_PREAD_METHODDEF\n    OS_PREADV_METHODDEF\n    OS_WRITE_METHODDEF\n    OS_WRITEV_METHODDEF\n    OS_PWRITE_METHODDEF\n    OS_PWRITEV_METHODDEF\n    OS_SENDFILE_METHODDEF\n    OS_FSTAT_METHODDEF\n    OS_ISATTY_METHODDEF\n    OS_PIPE_METHODDEF\n    OS_PIPE2_METHODDEF\n    OS_MKFIFO_METHODDEF\n    OS_MKNOD_METHODDEF\n    OS_MAJOR_METHODDEF\n    OS_MINOR_METHODDEF\n    OS_MAKEDEV_METHODDEF\n    OS_FTRUNCATE_METHODDEF\n    OS_TRUNCATE_METHODDEF\n    OS_POSIX_FALLOCATE_METHODDEF\n    OS_POSIX_FADVISE_METHODDEF\n    OS_PUTENV_METHODDEF\n    OS_UNSETENV_METHODDEF\n    OS_STRERROR_METHODDEF\n    OS_FCHDIR_METHODDEF\n    OS_FSYNC_METHODDEF\n    OS_SYNC_METHODDEF\n    OS_FDATASYNC_METHODDEF\n    OS_WCOREDUMP_METHODDEF\n    OS_WIFCONTINUED_METHODDEF\n    OS_WIFSTOPPED_METHODDEF\n    OS_WIFSIGNALED_METHODDEF\n    OS_WIFEXITED_METHODDEF\n    OS_WEXITSTATUS_METHODDEF\n    OS_WTERMSIG_METHODDEF\n    OS_WSTOPSIG_METHODDEF\n    OS_FSTATVFS_METHODDEF\n    OS_STATVFS_METHODDEF\n    OS_CONFSTR_METHODDEF\n    OS_SYSCONF_METHODDEF\n    OS_FPATHCONF_METHODDEF\n    OS_PATHCONF_METHODDEF\n    OS_ABORT_METHODDEF\n    OS__GETFULLPATHNAME_METHODDEF\n    OS__GETDISKUSAGE_METHODDEF\n    OS__GETFINALPATHNAME_METHODDEF\n    OS__FINDFIRSTFILE_METHODDEF\n    OS__GETVOLUMEPATHNAME_METHODDEF\n    OS__PATH_SPLITROOT_METHODDEF\n    OS__PATH_SPLITROOT_EX_METHODDEF\n    OS__PATH_NORMPATH_METHODDEF\n    OS_GETLOADAVG_METHODDEF\n    OS_URANDOM_METHODDEF\n    OS_SETRESUID_METHODDEF\n    OS_SETRESGID_METHODDEF\n    OS_GETRESUID_METHODDEF\n    OS_GETRESGID_METHODDEF\n\n    OS_GETXATTR_METHODDEF\n    OS_SETXATTR_METHODDEF\n    OS_REMOVEXATTR_METHODDEF\n    OS_LISTXATTR_METHODDEF\n\n    OS_GET_TERMINAL_SIZE_METHODDEF\n    OS_CPU_COUNT_METHODDEF\n    OS_GET_INHERITABLE_METHODDEF\n    OS_SET_INHERITABLE_METHODDEF\n    OS_GET_HANDLE_INHERITABLE_METHODDEF\n    OS_SET_HANDLE_INHERITABLE_METHODDEF\n    OS_GET_BLOCKING_METHODDEF\n    OS_SET_BLOCKING_METHODDEF\n    OS_SCANDIR_METHODDEF\n    OS_FSPATH_METHODDEF\n    OS_GETRANDOM_METHODDEF\n    OS_MEMFD_CREATE_METHODDEF\n    OS_EVENTFD_METHODDEF\n    OS_EVENTFD_READ_METHODDEF\n    OS_EVENTFD_WRITE_METHODDEF\n    OS__ADD_DLL_DIRECTORY_METHODDEF\n    OS__REMOVE_DLL_DIRECTORY_METHODDEF\n    OS_WAITSTATUS_TO_EXITCODE_METHODDEF\n    OS_SETNS_METHODDEF\n    OS_UNSHARE_METHODDEF\n    OS_TIMERFD_CREATE_METHODDEF\n    OS_TIMERFD_SETTIME_METHODDEF\n    OS_TIMERFD_SETTIME_NS_METHODDEF\n    OS_TIMERFD_GETTIME_METHODDEF\n    OS_TIMERFD_GETTIME_NS_METHODDEF\n\n    OS__PATH_ISDEVDRIVE_METHODDEF\n    OS__PATH_ISDIR_METHODDEF\n    OS__PATH_ISFILE_METHODDEF\n    OS__PATH_ISLINK_METHODDEF\n    OS__PATH_ISJUNCTION_METHODDEF\n    OS__PATH_EXISTS_METHODDEF\n    OS__PATH_LEXISTS_METHODDEF\n\n    OS__SUPPORTS_VIRTUAL_TERMINAL_METHODDEF\n    OS__INPUTHOOK_METHODDEF\n    OS__IS_INPUTHOOK_INSTALLED_METHODDEF\n    {NULL,              NULL}            /* Sentinel */\n};\n\nstatic int\nall_ins(PyObject *m)\n{\n#ifdef F_OK\n    if (PyModule_AddIntMacro(m, F_OK)) return -1;\n#endif\n#ifdef R_OK\n    if (PyModule_AddIntMacro(m, R_OK)) return -1;\n#endif\n#ifdef W_OK\n    if (PyModule_AddIntMacro(m, W_OK)) return -1;\n#endif\n#ifdef X_OK\n    if (PyModule_AddIntMacro(m, X_OK)) return -1;\n#endif\n#ifdef NGROUPS_MAX\n    if (PyModule_AddIntMacro(m, NGROUPS_MAX)) return -1;\n#endif\n#ifdef TMP_MAX\n    if (PyModule_AddIntMacro(m, TMP_MAX)) return -1;\n#endif\n#ifdef WCONTINUED\n    if (PyModule_AddIntMacro(m, WCONTINUED)) return -1;\n#endif\n#ifdef WNOHANG\n    if (PyModule_AddIntMacro(m, WNOHANG)) return -1;\n#endif\n#ifdef WUNTRACED\n    if (PyModule_AddIntMacro(m, WUNTRACED)) return -1;\n#endif\n#ifdef O_RDONLY\n    if (PyModule_AddIntMacro(m, O_RDONLY)) return -1;\n#endif\n#ifdef O_WRONLY\n    if (PyModule_AddIntMacro(m, O_WRONLY)) return -1;\n#endif\n#ifdef O_RDWR\n    if (PyModule_AddIntMacro(m, O_RDWR)) return -1;\n#endif\n#ifdef O_NDELAY\n    if (PyModule_AddIntMacro(m, O_NDELAY)) return -1;\n#endif\n#ifdef O_NONBLOCK\n    if (PyModule_AddIntMacro(m, O_NONBLOCK)) return -1;\n#endif\n#ifdef O_APPEND\n    if (PyModule_AddIntMacro(m, O_APPEND)) return -1;\n#endif\n#ifdef O_DSYNC\n    if (PyModule_AddIntMacro(m, O_DSYNC)) return -1;\n#endif\n#ifdef O_RSYNC\n    if (PyModule_AddIntMacro(m, O_RSYNC)) return -1;\n#endif\n#ifdef O_SYNC\n    if (PyModule_AddIntMacro(m, O_SYNC)) return -1;\n#endif\n#ifdef O_NOCTTY\n    if (PyModule_AddIntMacro(m, O_NOCTTY)) return -1;\n#endif\n#ifdef O_CREAT\n    if (PyModule_AddIntMacro(m, O_CREAT)) return -1;\n#endif\n#ifdef O_EXCL\n    if (PyModule_AddIntMacro(m, O_EXCL)) return -1;\n#endif\n#ifdef O_TRUNC\n    if (PyModule_AddIntMacro(m, O_TRUNC)) return -1;\n#endif\n#ifdef O_BINARY\n    if (PyModule_AddIntMacro(m, O_BINARY)) return -1;\n#endif\n#ifdef O_TEXT\n    if (PyModule_AddIntMacro(m, O_TEXT)) return -1;\n#endif\n#ifdef O_XATTR\n    if (PyModule_AddIntMacro(m, O_XATTR)) return -1;\n#endif\n#ifdef O_LARGEFILE\n    if (PyModule_AddIntMacro(m, O_LARGEFILE)) return -1;\n#endif\n#ifndef __GNU__\n#ifdef O_SHLOCK\n    if (PyModule_AddIntMacro(m, O_SHLOCK)) return -1;\n#endif\n#ifdef O_EXLOCK\n    if (PyModule_AddIntMacro(m, O_EXLOCK)) return -1;\n#endif\n#endif\n#ifdef O_EXEC\n    if (PyModule_AddIntMacro(m, O_EXEC)) return -1;\n#endif\n#ifdef O_SEARCH\n    if (PyModule_AddIntMacro(m, O_SEARCH)) return -1;\n#endif\n#ifdef O_PATH\n    if (PyModule_AddIntMacro(m, O_PATH)) return -1;\n#endif\n#ifdef O_TTY_INIT\n    if (PyModule_AddIntMacro(m, O_TTY_INIT)) return -1;\n#endif\n#ifdef O_TMPFILE\n    if (PyModule_AddIntMacro(m, O_TMPFILE)) return -1;\n#endif\n#ifdef PRIO_PROCESS\n    if (PyModule_AddIntMacro(m, PRIO_PROCESS)) return -1;\n#endif\n#ifdef PRIO_PGRP\n    if (PyModule_AddIntMacro(m, PRIO_PGRP)) return -1;\n#endif\n#ifdef PRIO_USER\n    if (PyModule_AddIntMacro(m, PRIO_USER)) return -1;\n#endif\n#ifdef PRIO_DARWIN_THREAD\n    if (PyModule_AddIntMacro(m, PRIO_DARWIN_THREAD)) return -1;\n#endif\n#ifdef PRIO_DARWIN_PROCESS\n    if (PyModule_AddIntMacro(m, PRIO_DARWIN_PROCESS)) return -1;\n#endif\n#ifdef PRIO_DARWIN_BG\n    if (PyModule_AddIntMacro(m, PRIO_DARWIN_BG)) return -1;\n#endif\n#ifdef PRIO_DARWIN_NONUI\n    if (PyModule_AddIntMacro(m, PRIO_DARWIN_NONUI)) return -1;\n#endif\n#ifdef O_CLOEXEC\n    if (PyModule_AddIntMacro(m, O_CLOEXEC)) return -1;\n#endif\n#ifdef O_ACCMODE\n    if (PyModule_AddIntMacro(m, O_ACCMODE)) return -1;\n#endif\n#ifdef O_EVTONLY\n    if (PyModule_AddIntMacro(m, O_EVTONLY)) return -1;\n#endif\n#ifdef O_FSYNC\n    if (PyModule_AddIntMacro(m, O_FSYNC)) return -1;\n#endif\n#ifdef O_SYMLINK\n    if (PyModule_AddIntMacro(m, O_SYMLINK)) return -1;\n#endif\n\n#ifdef SEEK_HOLE\n    if (PyModule_AddIntMacro(m, SEEK_HOLE)) return -1;\n#endif\n#ifdef SEEK_DATA\n    if (PyModule_AddIntMacro(m, SEEK_DATA)) return -1;\n#endif\n\n/* MS Windows */\n#ifdef O_NOINHERIT\n    /* Don't inherit in child processes. */\n    if (PyModule_AddIntMacro(m, O_NOINHERIT)) return -1;\n#endif\n#ifdef _O_SHORT_LIVED\n    /* Optimize for short life (keep in memory). */\n    /* MS forgot to define this one with a non-underscore form too. */\n    if (PyModule_AddIntConstant(m, \"O_SHORT_LIVED\", _O_SHORT_LIVED)) return -1;\n#endif\n#ifdef O_TEMPORARY\n    /* Automatically delete when last handle is closed. */\n    if (PyModule_AddIntMacro(m, O_TEMPORARY)) return -1;\n#endif\n#ifdef O_RANDOM\n    /* Optimize for random access. */\n    if (PyModule_AddIntMacro(m, O_RANDOM)) return -1;\n#endif\n#ifdef O_SEQUENTIAL\n    /* Optimize for sequential access. */\n    if (PyModule_AddIntMacro(m, O_SEQUENTIAL)) return -1;\n#endif\n\n/* GNU extensions. */\n#ifdef O_ASYNC\n    /* Send a SIGIO signal whenever input or output\n       becomes available on file descriptor */\n    if (PyModule_AddIntMacro(m, O_ASYNC)) return -1;\n#endif\n#ifdef O_DIRECT\n    /* Direct disk access. */\n    if (PyModule_AddIntMacro(m, O_DIRECT)) return -1;\n#endif\n#ifdef O_DIRECTORY\n    /* Must be a directory.      */\n    if (PyModule_AddIntMacro(m, O_DIRECTORY)) return -1;\n#endif\n#ifdef O_NOFOLLOW\n    /* Do not follow links.      */\n    if (PyModule_AddIntMacro(m, O_NOFOLLOW)) return -1;\n#endif\n#ifdef O_NOFOLLOW_ANY\n    if (PyModule_AddIntMacro(m, O_NOFOLLOW_ANY)) return -1;\n#endif\n#ifdef O_NOLINKS\n    /* Fails if link count of the named file is greater than 1 */\n    if (PyModule_AddIntMacro(m, O_NOLINKS)) return -1;\n#endif\n#ifdef O_NOATIME\n    /* Do not update the access time. */\n    if (PyModule_AddIntMacro(m, O_NOATIME)) return -1;\n#endif\n\n    /* These come from sysexits.h */\n#ifdef EX_OK\n    if (PyModule_AddIntMacro(m, EX_OK)) return -1;\n#endif /* EX_OK */\n#ifdef EX_USAGE\n    if (PyModule_AddIntMacro(m, EX_USAGE)) return -1;\n#endif /* EX_USAGE */\n#ifdef EX_DATAERR\n    if (PyModule_AddIntMacro(m, EX_DATAERR)) return -1;\n#endif /* EX_DATAERR */\n#ifdef EX_NOINPUT\n    if (PyModule_AddIntMacro(m, EX_NOINPUT)) return -1;\n#endif /* EX_NOINPUT */\n#ifdef EX_NOUSER\n    if (PyModule_AddIntMacro(m, EX_NOUSER)) return -1;\n#endif /* EX_NOUSER */\n#ifdef EX_NOHOST\n    if (PyModule_AddIntMacro(m, EX_NOHOST)) return -1;\n#endif /* EX_NOHOST */\n#ifdef EX_UNAVAILABLE\n    if (PyModule_AddIntMacro(m, EX_UNAVAILABLE)) return -1;\n#endif /* EX_UNAVAILABLE */\n#ifdef EX_SOFTWARE\n    if (PyModule_AddIntMacro(m, EX_SOFTWARE)) return -1;\n#endif /* EX_SOFTWARE */\n#ifdef EX_OSERR\n    if (PyModule_AddIntMacro(m, EX_OSERR)) return -1;\n#endif /* EX_OSERR */\n#ifdef EX_OSFILE\n    if (PyModule_AddIntMacro(m, EX_OSFILE)) return -1;\n#endif /* EX_OSFILE */\n#ifdef EX_CANTCREAT\n    if (PyModule_AddIntMacro(m, EX_CANTCREAT)) return -1;\n#endif /* EX_CANTCREAT */\n#ifdef EX_IOERR\n    if (PyModule_AddIntMacro(m, EX_IOERR)) return -1;\n#endif /* EX_IOERR */\n#ifdef EX_TEMPFAIL\n    if (PyModule_AddIntMacro(m, EX_TEMPFAIL)) return -1;\n#endif /* EX_TEMPFAIL */\n#ifdef EX_PROTOCOL\n    if (PyModule_AddIntMacro(m, EX_PROTOCOL)) return -1;\n#endif /* EX_PROTOCOL */\n#ifdef EX_NOPERM\n    if (PyModule_AddIntMacro(m, EX_NOPERM)) return -1;\n#endif /* EX_NOPERM */\n#ifdef EX_CONFIG\n    if (PyModule_AddIntMacro(m, EX_CONFIG)) return -1;\n#endif /* EX_CONFIG */\n#ifdef EX_NOTFOUND\n    if (PyModule_AddIntMacro(m, EX_NOTFOUND)) return -1;\n#endif /* EX_NOTFOUND */\n\n    /* statvfs */\n#ifdef ST_RDONLY\n    if (PyModule_AddIntMacro(m, ST_RDONLY)) return -1;\n#endif /* ST_RDONLY */\n#ifdef ST_NOSUID\n    if (PyModule_AddIntMacro(m, ST_NOSUID)) return -1;\n#endif /* ST_NOSUID */\n\n       /* GNU extensions */\n#ifdef ST_NODEV\n    if (PyModule_AddIntMacro(m, ST_NODEV)) return -1;\n#endif /* ST_NODEV */\n#ifdef ST_NOEXEC\n    if (PyModule_AddIntMacro(m, ST_NOEXEC)) return -1;\n#endif /* ST_NOEXEC */\n#ifdef ST_SYNCHRONOUS\n    if (PyModule_AddIntMacro(m, ST_SYNCHRONOUS)) return -1;\n#endif /* ST_SYNCHRONOUS */\n#ifdef ST_MANDLOCK\n    if (PyModule_AddIntMacro(m, ST_MANDLOCK)) return -1;\n#endif /* ST_MANDLOCK */\n#ifdef ST_WRITE\n    if (PyModule_AddIntMacro(m, ST_WRITE)) return -1;\n#endif /* ST_WRITE */\n#ifdef ST_APPEND\n    if (PyModule_AddIntMacro(m, ST_APPEND)) return -1;\n#endif /* ST_APPEND */\n#ifdef ST_NOATIME\n    if (PyModule_AddIntMacro(m, ST_NOATIME)) return -1;\n#endif /* ST_NOATIME */\n#ifdef ST_NODIRATIME\n    if (PyModule_AddIntMacro(m, ST_NODIRATIME)) return -1;\n#endif /* ST_NODIRATIME */\n#ifdef ST_RELATIME\n    if (PyModule_AddIntMacro(m, ST_RELATIME)) return -1;\n#endif /* ST_RELATIME */\n\n    /* FreeBSD sendfile() constants */\n#ifdef SF_NODISKIO\n    if (PyModule_AddIntMacro(m, SF_NODISKIO)) return -1;\n#endif\n    /* is obsolete since the 11.x release */\n#ifdef SF_MNOWAIT\n    if (PyModule_AddIntMacro(m, SF_MNOWAIT)) return -1;\n#endif\n#ifdef SF_SYNC\n    if (PyModule_AddIntMacro(m, SF_SYNC)) return -1;\n#endif\n#ifdef SF_NOCACHE\n    if (PyModule_AddIntMacro(m, SF_NOCACHE)) return -1;\n#endif\n\n#ifdef TFD_NONBLOCK\n    if (PyModule_AddIntMacro(m, TFD_NONBLOCK)) return -1;\n#endif\n#ifdef TFD_CLOEXEC\n    if (PyModule_AddIntMacro(m, TFD_CLOEXEC)) return -1;\n#endif\n#ifdef TFD_TIMER_ABSTIME\n    if (PyModule_AddIntMacro(m, TFD_TIMER_ABSTIME)) return -1;\n#endif\n#ifdef TFD_TIMER_CANCEL_ON_SET\n    if (PyModule_AddIntMacro(m, TFD_TIMER_CANCEL_ON_SET)) return -1;\n#endif\n\n    /* constants for posix_fadvise */\n#ifdef POSIX_FADV_NORMAL\n    if (PyModule_AddIntMacro(m, POSIX_FADV_NORMAL)) return -1;\n#endif\n#ifdef POSIX_FADV_SEQUENTIAL\n    if (PyModule_AddIntMacro(m, POSIX_FADV_SEQUENTIAL)) return -1;\n#endif\n#ifdef POSIX_FADV_RANDOM\n    if (PyModule_AddIntMacro(m, POSIX_FADV_RANDOM)) return -1;\n#endif\n#ifdef POSIX_FADV_NOREUSE\n    if (PyModule_AddIntMacro(m, POSIX_FADV_NOREUSE)) return -1;\n#endif\n#ifdef POSIX_FADV_WILLNEED\n    if (PyModule_AddIntMacro(m, POSIX_FADV_WILLNEED)) return -1;\n#endif\n#ifdef POSIX_FADV_DONTNEED\n    if (PyModule_AddIntMacro(m, POSIX_FADV_DONTNEED)) return -1;\n#endif\n\n    /* constants for waitid */\n#if defined(HAVE_SYS_WAIT_H) && defined(HAVE_WAITID)\n    if (PyModule_AddIntMacro(m, P_PID)) return -1;\n    if (PyModule_AddIntMacro(m, P_PGID)) return -1;\n    if (PyModule_AddIntMacro(m, P_ALL)) return -1;\n#ifdef P_PIDFD\n    if (PyModule_AddIntMacro(m, P_PIDFD)) return -1;\n#endif\n#ifdef PIDFD_NONBLOCK\n    if (PyModule_AddIntMacro(m, PIDFD_NONBLOCK)) return -1;\n#endif\n#endif\n#ifdef WEXITED\n    if (PyModule_AddIntMacro(m, WEXITED)) return -1;\n#endif\n#ifdef WNOWAIT\n    if (PyModule_AddIntMacro(m, WNOWAIT)) return -1;\n#endif\n#ifdef WSTOPPED\n    if (PyModule_AddIntMacro(m, WSTOPPED)) return -1;\n#endif\n#ifdef CLD_EXITED\n    if (PyModule_AddIntMacro(m, CLD_EXITED)) return -1;\n#endif\n#ifdef CLD_KILLED\n    if (PyModule_AddIntMacro(m, CLD_KILLED)) return -1;\n#endif\n#ifdef CLD_DUMPED\n    if (PyModule_AddIntMacro(m, CLD_DUMPED)) return -1;\n#endif\n#ifdef CLD_TRAPPED\n    if (PyModule_AddIntMacro(m, CLD_TRAPPED)) return -1;\n#endif\n#ifdef CLD_STOPPED\n    if (PyModule_AddIntMacro(m, CLD_STOPPED)) return -1;\n#endif\n#ifdef CLD_CONTINUED\n    if (PyModule_AddIntMacro(m, CLD_CONTINUED)) return -1;\n#endif\n\n    /* constants for lockf */\n#ifdef F_LOCK\n    if (PyModule_AddIntMacro(m, F_LOCK)) return -1;\n#endif\n#ifdef F_TLOCK\n    if (PyModule_AddIntMacro(m, F_TLOCK)) return -1;\n#endif\n#ifdef F_ULOCK\n    if (PyModule_AddIntMacro(m, F_ULOCK)) return -1;\n#endif\n#ifdef F_TEST\n    if (PyModule_AddIntMacro(m, F_TEST)) return -1;\n#endif\n\n#ifdef RWF_DSYNC\n    if (PyModule_AddIntConstant(m, \"RWF_DSYNC\", RWF_DSYNC)) return -1;\n#endif\n#ifdef RWF_HIPRI\n    if (PyModule_AddIntConstant(m, \"RWF_HIPRI\", RWF_HIPRI)) return -1;\n#endif\n#ifdef RWF_SYNC\n    if (PyModule_AddIntConstant(m, \"RWF_SYNC\", RWF_SYNC)) return -1;\n#endif\n#ifdef RWF_NOWAIT\n    if (PyModule_AddIntConstant(m, \"RWF_NOWAIT\", RWF_NOWAIT)) return -1;\n#endif\n#ifdef RWF_APPEND\n    if (PyModule_AddIntConstant(m, \"RWF_APPEND\", RWF_APPEND)) return -1;\n#endif\n\n/* constants for splice */\n#if defined(HAVE_SPLICE) && defined(__linux__)\n    if (PyModule_AddIntConstant(m, \"SPLICE_F_MOVE\", SPLICE_F_MOVE)) return -1;\n    if (PyModule_AddIntConstant(m, \"SPLICE_F_NONBLOCK\", SPLICE_F_NONBLOCK)) return -1;\n    if (PyModule_AddIntConstant(m, \"SPLICE_F_MORE\", SPLICE_F_MORE)) return -1;\n#endif\n\n/* constants for posix_spawn */\n#ifdef HAVE_POSIX_SPAWN\n    if (PyModule_AddIntConstant(m, \"POSIX_SPAWN_OPEN\", POSIX_SPAWN_OPEN)) return -1;\n    if (PyModule_AddIntConstant(m, \"POSIX_SPAWN_CLOSE\", POSIX_SPAWN_CLOSE)) return -1;\n    if (PyModule_AddIntConstant(m, \"POSIX_SPAWN_DUP2\", POSIX_SPAWN_DUP2)) return -1;\n#ifdef HAVE_POSIX_SPAWN_FILE_ACTIONS_ADDCLOSEFROM_NP\n    if (PyModule_AddIntMacro(m, POSIX_SPAWN_CLOSEFROM)) return -1;\n#endif\n#endif\n\n#if defined(HAVE_SPAWNV) || defined (HAVE_RTPSPAWN)\n    if (PyModule_AddIntConstant(m, \"P_WAIT\", _P_WAIT)) return -1;\n    if (PyModule_AddIntConstant(m, \"P_NOWAIT\", _P_NOWAIT)) return -1;\n    if (PyModule_AddIntConstant(m, \"P_NOWAITO\", _P_NOWAITO)) return -1;\n#endif\n#ifdef HAVE_SPAWNV\n    if (PyModule_AddIntConstant(m, \"P_OVERLAY\", _OLD_P_OVERLAY)) return -1;\n    if (PyModule_AddIntConstant(m, \"P_DETACH\", _P_DETACH)) return -1;\n#endif\n\n#ifdef HAVE_SCHED_H\n#ifdef SCHED_OTHER\n    if (PyModule_AddIntMacro(m, SCHED_OTHER)) return -1;\n#endif\n#ifdef SCHED_FIFO\n    if (PyModule_AddIntMacro(m, SCHED_FIFO)) return -1;\n#endif\n#ifdef SCHED_RR\n    if (PyModule_AddIntMacro(m, SCHED_RR)) return -1;\n#endif\n#ifdef SCHED_SPORADIC\n    if (PyModule_AddIntMacro(m, SCHED_SPORADIC)) return -1;\n#endif\n#ifdef SCHED_BATCH\n    if (PyModule_AddIntMacro(m, SCHED_BATCH)) return -1;\n#endif\n#ifdef SCHED_IDLE\n    if (PyModule_AddIntMacro(m, SCHED_IDLE)) return -1;\n#endif\n#ifdef SCHED_RESET_ON_FORK\n    if (PyModule_AddIntMacro(m, SCHED_RESET_ON_FORK)) return -1;\n#endif\n#ifdef SCHED_SYS\n    if (PyModule_AddIntMacro(m, SCHED_SYS)) return -1;\n#endif\n#ifdef SCHED_IA\n    if (PyModule_AddIntMacro(m, SCHED_IA)) return -1;\n#endif\n#ifdef SCHED_FSS\n    if (PyModule_AddIntMacro(m, SCHED_FSS)) return -1;\n#endif\n#ifdef SCHED_FX\n    if (PyModule_AddIntConstant(m, \"SCHED_FX\", SCHED_FSS)) return -1;\n#endif\n\n/* constants for namespaces */\n#if defined(HAVE_SETNS) || defined(HAVE_UNSHARE)\n#ifdef CLONE_FS\n    if (PyModule_AddIntMacro(m, CLONE_FS)) return -1;\n#endif\n#ifdef CLONE_FILES\n    if (PyModule_AddIntMacro(m, CLONE_FILES)) return -1;\n#endif\n#ifdef CLONE_NEWNS\n    if (PyModule_AddIntMacro(m, CLONE_NEWNS)) return -1;\n#endif\n#ifdef CLONE_NEWCGROUP\n    if (PyModule_AddIntMacro(m, CLONE_NEWCGROUP)) return -1;\n#endif\n#ifdef CLONE_NEWUTS\n    if (PyModule_AddIntMacro(m, CLONE_NEWUTS)) return -1;\n#endif\n#ifdef CLONE_NEWIPC\n    if (PyModule_AddIntMacro(m, CLONE_NEWIPC)) return -1;\n#endif\n#ifdef CLONE_NEWUSER\n    if (PyModule_AddIntMacro(m, CLONE_NEWUSER)) return -1;\n#endif\n#ifdef CLONE_NEWPID\n    if (PyModule_AddIntMacro(m, CLONE_NEWPID)) return -1;\n#endif\n#ifdef CLONE_NEWNET\n    if (PyModule_AddIntMacro(m, CLONE_NEWNET)) return -1;\n#endif\n#ifdef CLONE_NEWTIME\n    if (PyModule_AddIntMacro(m, CLONE_NEWTIME)) return -1;\n#endif\n#ifdef CLONE_SYSVSEM\n    if (PyModule_AddIntMacro(m, CLONE_SYSVSEM)) return -1;\n#endif\n#ifdef CLONE_THREAD\n    if (PyModule_AddIntMacro(m, CLONE_THREAD)) return -1;\n#endif\n#ifdef CLONE_SIGHAND\n    if (PyModule_AddIntMacro(m, CLONE_SIGHAND)) return -1;\n#endif\n#ifdef CLONE_VM\n    if (PyModule_AddIntMacro(m, CLONE_VM)) return -1;\n#endif\n#endif\n\n#endif\n\n#ifdef USE_XATTRS\n    if (PyModule_AddIntMacro(m, XATTR_CREATE)) return -1;\n    if (PyModule_AddIntMacro(m, XATTR_REPLACE)) return -1;\n    if (PyModule_AddIntMacro(m, XATTR_SIZE_MAX)) return -1;\n#endif\n\n#if HAVE_DECL_RTLD_LAZY\n    if (PyModule_AddIntMacro(m, RTLD_LAZY)) return -1;\n#endif\n#if HAVE_DECL_RTLD_NOW\n    if (PyModule_AddIntMacro(m, RTLD_NOW)) return -1;\n#endif\n#if HAVE_DECL_RTLD_GLOBAL\n    if (PyModule_AddIntMacro(m, RTLD_GLOBAL)) return -1;\n#endif\n#if HAVE_DECL_RTLD_LOCAL\n    if (PyModule_AddIntMacro(m, RTLD_LOCAL)) return -1;\n#endif\n#if HAVE_DECL_RTLD_NODELETE\n    if (PyModule_AddIntMacro(m, RTLD_NODELETE)) return -1;\n#endif\n#if HAVE_DECL_RTLD_NOLOAD\n    if (PyModule_AddIntMacro(m, RTLD_NOLOAD)) return -1;\n#endif\n#if HAVE_DECL_RTLD_DEEPBIND\n    if (PyModule_AddIntMacro(m, RTLD_DEEPBIND)) return -1;\n#endif\n#if HAVE_DECL_RTLD_MEMBER\n    if (PyModule_AddIntMacro(m, RTLD_MEMBER)) return -1;\n#endif\n\n#ifdef HAVE_GETRANDOM_SYSCALL\n    if (PyModule_AddIntMacro(m, GRND_RANDOM)) return -1;\n    if (PyModule_AddIntMacro(m, GRND_NONBLOCK)) return -1;\n#endif\n#ifdef HAVE_MEMFD_CREATE\n    if (PyModule_AddIntMacro(m, MFD_CLOEXEC)) return -1;\n    if (PyModule_AddIntMacro(m, MFD_ALLOW_SEALING)) return -1;\n#ifdef MFD_HUGETLB\n    if (PyModule_AddIntMacro(m, MFD_HUGETLB)) return -1;\n#endif\n#ifdef MFD_HUGE_SHIFT\n    if (PyModule_AddIntMacro(m, MFD_HUGE_SHIFT)) return -1;\n#endif\n#ifdef MFD_HUGE_MASK\n    if (PyModule_AddIntMacro(m, MFD_HUGE_MASK)) return -1;\n#endif\n#ifdef MFD_HUGE_64KB\n    if (PyModule_AddIntMacro(m, MFD_HUGE_64KB)) return -1;\n#endif\n#ifdef MFD_HUGE_512KB\n    if (PyModule_AddIntMacro(m, MFD_HUGE_512KB)) return -1;\n#endif\n#ifdef MFD_HUGE_1MB\n    if (PyModule_AddIntMacro(m, MFD_HUGE_1MB)) return -1;\n#endif\n#ifdef MFD_HUGE_2MB\n    if (PyModule_AddIntMacro(m, MFD_HUGE_2MB)) return -1;\n#endif\n#ifdef MFD_HUGE_8MB\n    if (PyModule_AddIntMacro(m, MFD_HUGE_8MB)) return -1;\n#endif\n#ifdef MFD_HUGE_16MB\n    if (PyModule_AddIntMacro(m, MFD_HUGE_16MB)) return -1;\n#endif\n#ifdef MFD_HUGE_32MB\n    if (PyModule_AddIntMacro(m, MFD_HUGE_32MB)) return -1;\n#endif\n#ifdef MFD_HUGE_256MB\n    if (PyModule_AddIntMacro(m, MFD_HUGE_256MB)) return -1;\n#endif\n#ifdef MFD_HUGE_512MB\n    if (PyModule_AddIntMacro(m, MFD_HUGE_512MB)) return -1;\n#endif\n#ifdef MFD_HUGE_1GB\n    if (PyModule_AddIntMacro(m, MFD_HUGE_1GB)) return -1;\n#endif\n#ifdef MFD_HUGE_2GB\n    if (PyModule_AddIntMacro(m, MFD_HUGE_2GB)) return -1;\n#endif\n#ifdef MFD_HUGE_16GB\n    if (PyModule_AddIntMacro(m, MFD_HUGE_16GB)) return -1;\n#endif\n#endif /* HAVE_MEMFD_CREATE */\n\n#if defined(HAVE_EVENTFD) && defined(EFD_CLOEXEC)\n    if (PyModule_AddIntMacro(m, EFD_CLOEXEC)) return -1;\n#ifdef EFD_NONBLOCK\n    if (PyModule_AddIntMacro(m, EFD_NONBLOCK)) return -1;\n#endif\n#ifdef EFD_SEMAPHORE\n    if (PyModule_AddIntMacro(m, EFD_SEMAPHORE)) return -1;\n#endif\n#endif  /* HAVE_EVENTFD && EFD_CLOEXEC */\n\n#if defined(__APPLE__)\n    if (PyModule_AddIntConstant(m, \"_COPYFILE_DATA\", COPYFILE_DATA)) return -1;\n    if (PyModule_AddIntConstant(m, \"_COPYFILE_STAT\", COPYFILE_STAT)) return -1;\n    if (PyModule_AddIntConstant(m, \"_COPYFILE_ACL\", COPYFILE_ACL)) return -1;\n    if (PyModule_AddIntConstant(m, \"_COPYFILE_XATTR\", COPYFILE_XATTR)) return -1;\n#endif\n\n#ifdef MS_WINDOWS\n    if (PyModule_AddIntConstant(m, \"_LOAD_LIBRARY_SEARCH_DEFAULT_DIRS\", LOAD_LIBRARY_SEARCH_DEFAULT_DIRS)) return -1;\n    if (PyModule_AddIntConstant(m, \"_LOAD_LIBRARY_SEARCH_APPLICATION_DIR\", LOAD_LIBRARY_SEARCH_APPLICATION_DIR)) return -1;\n    if (PyModule_AddIntConstant(m, \"_LOAD_LIBRARY_SEARCH_SYSTEM32\", LOAD_LIBRARY_SEARCH_SYSTEM32)) return -1;\n    if (PyModule_AddIntConstant(m, \"_LOAD_LIBRARY_SEARCH_USER_DIRS\", LOAD_LIBRARY_SEARCH_USER_DIRS)) return -1;\n    if (PyModule_AddIntConstant(m, \"_LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR\", LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR)) return -1;\n#endif\n\n    return 0;\n}\n\n\n\n#define PROBE(name, test) \\\n   static int name(void)  \\\n   {                      \\\n      if (test) {        \\\n          return 1;       \\\n      } else {            \\\n          return 0;       \\\n      }                   \\\n   }\n\n#ifdef HAVE_FSTATAT\nPROBE(probe_fstatat, HAVE_FSTATAT_RUNTIME)\n#endif\n\n#ifdef HAVE_FACCESSAT\nPROBE(probe_faccessat, HAVE_FACCESSAT_RUNTIME)\n#endif\n\n#ifdef HAVE_FCHMODAT\nPROBE(probe_fchmodat, HAVE_FCHMODAT_RUNTIME)\n#endif\n\n#ifdef HAVE_FCHOWNAT\nPROBE(probe_fchownat, HAVE_FCHOWNAT_RUNTIME)\n#endif\n\n#ifdef HAVE_LINKAT\nPROBE(probe_linkat, HAVE_LINKAT_RUNTIME)\n#endif\n\n#ifdef HAVE_FDOPENDIR\nPROBE(probe_fdopendir, HAVE_FDOPENDIR_RUNTIME)\n#endif\n\n#ifdef HAVE_MKDIRAT\nPROBE(probe_mkdirat, HAVE_MKDIRAT_RUNTIME)\n#endif\n\n#ifdef HAVE_MKFIFOAT\nPROBE(probe_mkfifoat, HAVE_MKFIFOAT_RUNTIME)\n#endif\n\n#ifdef HAVE_MKNODAT\nPROBE(probe_mknodat, HAVE_MKNODAT_RUNTIME)\n#endif\n\n#ifdef HAVE_RENAMEAT\nPROBE(probe_renameat, HAVE_RENAMEAT_RUNTIME)\n#endif\n\n#ifdef HAVE_UNLINKAT\nPROBE(probe_unlinkat, HAVE_UNLINKAT_RUNTIME)\n#endif\n\n#ifdef HAVE_OPENAT\nPROBE(probe_openat, HAVE_OPENAT_RUNTIME)\n#endif\n\n#ifdef HAVE_READLINKAT\nPROBE(probe_readlinkat, HAVE_READLINKAT_RUNTIME)\n#endif\n\n#ifdef HAVE_SYMLINKAT\nPROBE(probe_symlinkat, HAVE_SYMLINKAT_RUNTIME)\n#endif\n\n#ifdef HAVE_FUTIMENS\nPROBE(probe_futimens, HAVE_FUTIMENS_RUNTIME)\n#endif\n\n#ifdef HAVE_UTIMENSAT\nPROBE(probe_utimensat, HAVE_UTIMENSAT_RUNTIME)\n#endif\n\n\n\n\nstatic const struct have_function {\n    const char * const label;\n    int (*probe)(void);\n} have_functions[] = {\n\n#ifdef HAVE_EVENTFD\n    {\"HAVE_EVENTFD\", NULL},\n#endif\n\n#ifdef HAVE_TIMERFD_CREATE\n    {\"HAVE_TIMERFD_CREATE\", NULL},\n#endif\n\n#ifdef HAVE_FACCESSAT\n    { \"HAVE_FACCESSAT\", probe_faccessat },\n#endif\n\n#ifdef HAVE_FCHDIR\n    { \"HAVE_FCHDIR\", NULL },\n#endif\n\n#ifdef HAVE_FCHMOD\n    { \"HAVE_FCHMOD\", NULL },\n#endif\n\n#ifdef HAVE_FCHMODAT\n    { \"HAVE_FCHMODAT\", probe_fchmodat },\n#endif\n\n#ifdef HAVE_FCHOWN\n    { \"HAVE_FCHOWN\", NULL },\n#endif\n\n#ifdef HAVE_FCHOWNAT\n    { \"HAVE_FCHOWNAT\", probe_fchownat },\n#endif\n\n#ifdef HAVE_FEXECVE\n    { \"HAVE_FEXECVE\", NULL },\n#endif\n\n#ifdef HAVE_FDOPENDIR\n    { \"HAVE_FDOPENDIR\", probe_fdopendir },\n#endif\n\n#ifdef HAVE_FPATHCONF\n    { \"HAVE_FPATHCONF\", NULL },\n#endif\n\n#ifdef HAVE_FSTATAT\n    { \"HAVE_FSTATAT\", probe_fstatat },\n#endif\n\n#ifdef HAVE_FSTATVFS\n    { \"HAVE_FSTATVFS\", NULL },\n#endif\n\n#if defined HAVE_FTRUNCATE || defined MS_WINDOWS\n    { \"HAVE_FTRUNCATE\", NULL },\n#endif\n\n#ifdef HAVE_FUTIMENS\n    { \"HAVE_FUTIMENS\", probe_futimens },\n#endif\n\n#ifdef HAVE_FUTIMES\n    { \"HAVE_FUTIMES\", NULL },\n#endif\n\n#ifdef HAVE_FUTIMESAT\n    { \"HAVE_FUTIMESAT\", NULL },\n#endif\n\n#ifdef HAVE_LINKAT\n    { \"HAVE_LINKAT\", probe_linkat },\n#endif\n\n#ifdef HAVE_LCHFLAGS\n    { \"HAVE_LCHFLAGS\", NULL },\n#endif\n\n#ifdef HAVE_LCHMOD\n    { \"HAVE_LCHMOD\", NULL },\n#endif\n\n#ifdef HAVE_LCHOWN\n    { \"HAVE_LCHOWN\", NULL },\n#endif\n\n#ifdef HAVE_LSTAT\n    { \"HAVE_LSTAT\", NULL },\n#endif\n\n#ifdef HAVE_LUTIMES\n    { \"HAVE_LUTIMES\", NULL },\n#endif\n\n#ifdef HAVE_MEMFD_CREATE\n    { \"HAVE_MEMFD_CREATE\", NULL },\n#endif\n\n#ifdef HAVE_MKDIRAT\n    { \"HAVE_MKDIRAT\", probe_mkdirat },\n#endif\n\n#ifdef HAVE_MKFIFOAT\n    { \"HAVE_MKFIFOAT\", probe_mkfifoat },\n#endif\n\n#ifdef HAVE_MKNODAT\n    { \"HAVE_MKNODAT\", probe_mknodat },\n#endif\n\n#ifdef HAVE_OPENAT\n    { \"HAVE_OPENAT\", probe_openat },\n#endif\n\n#ifdef HAVE_READLINKAT\n    { \"HAVE_READLINKAT\", probe_readlinkat },\n#endif\n\n#ifdef HAVE_RENAMEAT\n    { \"HAVE_RENAMEAT\", probe_renameat },\n#endif\n\n#ifdef HAVE_SYMLINKAT\n    { \"HAVE_SYMLINKAT\", probe_symlinkat },\n#endif\n\n#ifdef HAVE_UNLINKAT\n    { \"HAVE_UNLINKAT\", probe_unlinkat },\n#endif\n\n#ifdef HAVE_UTIMENSAT\n    { \"HAVE_UTIMENSAT\", probe_utimensat },\n#endif\n\n#ifdef MS_WINDOWS\n    { \"MS_WINDOWS\", NULL },\n#endif\n\n    { NULL, NULL }\n};\n\n\nstatic int\nposixmodule_exec(PyObject *m)\n{\n    _posixstate *state = get_posix_state(m);\n\n#if defined(HAVE_PWRITEV)\n    if (HAVE_PWRITEV_RUNTIME) {} else {\n        PyObject* dct = PyModule_GetDict(m);\n\n        if (dct == NULL) {\n            return -1;\n        }\n\n        if (PyDict_PopString(dct, \"pwritev\", NULL) < 0) {\n            return -1;\n        }\n        if (PyDict_PopString(dct, \"preadv\", NULL) < 0) {\n            return -1;\n        }\n    }\n#endif\n\n    /* Initialize environ dictionary */\n    if (PyModule_Add(m, \"environ\", convertenviron()) != 0) {\n        return -1;\n    }\n\n    if (all_ins(m))\n        return -1;\n\n    if (setup_confname_tables(m))\n        return -1;\n\n    if (PyModule_AddObjectRef(m, \"error\", PyExc_OSError) < 0) {\n        return -1;\n    }\n\n#if defined(HAVE_WAITID)\n    waitid_result_desc.name = MODNAME \".waitid_result\";\n    state->WaitidResultType = (PyObject *)PyStructSequence_NewType(&waitid_result_desc);\n    if (PyModule_AddObjectRef(m, \"waitid_result\", state->WaitidResultType) < 0) {\n        return -1;\n    }\n#endif\n\n    stat_result_desc.name = \"os.stat_result\"; /* see issue #19209 */\n    stat_result_desc.fields[7].name = PyStructSequence_UnnamedField;\n    stat_result_desc.fields[8].name = PyStructSequence_UnnamedField;\n    stat_result_desc.fields[9].name = PyStructSequence_UnnamedField;\n    state->StatResultType = (PyObject *)PyStructSequence_NewType(&stat_result_desc);\n    if (PyModule_AddObjectRef(m, \"stat_result\", state->StatResultType) < 0) {\n        return -1;\n    }\n    state->statresult_new_orig = ((PyTypeObject *)state->StatResultType)->tp_new;\n    ((PyTypeObject *)state->StatResultType)->tp_new = statresult_new;\n\n    statvfs_result_desc.name = \"os.statvfs_result\"; /* see issue #19209 */\n    state->StatVFSResultType = (PyObject *)PyStructSequence_NewType(&statvfs_result_desc);\n    if (PyModule_AddObjectRef(m, \"statvfs_result\", state->StatVFSResultType) < 0) {\n        return -1;\n    }\n\n#if defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDPARAM)\n    sched_param_desc.name = MODNAME \".sched_param\";\n    state->SchedParamType = (PyObject *)PyStructSequence_NewType(&sched_param_desc);\n    if (PyModule_AddObjectRef(m, \"sched_param\", state->SchedParamType) < 0) {\n        return -1;\n    }\n    ((PyTypeObject *)state->SchedParamType)->tp_new = os_sched_param;\n#endif\n\n    /* initialize TerminalSize_info */\n    state->TerminalSizeType = (PyObject *)PyStructSequence_NewType(&TerminalSize_desc);\n    if (PyModule_AddObjectRef(m, \"terminal_size\", state->TerminalSizeType) < 0) {\n        return -1;\n    }\n\n    /* initialize scandir types */\n    PyObject *ScandirIteratorType = PyType_FromModuleAndSpec(m, &ScandirIteratorType_spec, NULL);\n    if (ScandirIteratorType == NULL) {\n        return -1;\n    }\n    state->ScandirIteratorType = ScandirIteratorType;\n\n    state->DirEntryType = PyType_FromModuleAndSpec(m, &DirEntryType_spec, NULL);\n    if (PyModule_AddObjectRef(m, \"DirEntry\", state->DirEntryType) < 0) {\n        return -1;\n    }\n\n    times_result_desc.name = MODNAME \".times_result\";\n    state->TimesResultType = (PyObject *)PyStructSequence_NewType(&times_result_desc);\n    if (PyModule_AddObjectRef(m, \"times_result\", state->TimesResultType) < 0) {\n        return -1;\n    }\n\n    state->UnameResultType = (PyObject *)PyStructSequence_NewType(&uname_result_desc);\n    if (PyModule_AddObjectRef(m, \"uname_result\", state->UnameResultType) < 0) {\n        return -1;\n    }\n\n    if ((state->billion = PyLong_FromLong(1000000000)) == NULL)\n        return -1;\n#if defined(HAVE_WAIT3) || defined(HAVE_WAIT4)\n    state->struct_rusage = PyUnicode_InternFromString(\"struct_rusage\");\n    if (state->struct_rusage == NULL)\n        return -1;\n#endif\n    state->st_mode = PyUnicode_InternFromString(\"st_mode\");\n    if (state->st_mode == NULL)\n        return -1;\n\n    /* suppress \"function not used\" warnings */\n    {\n    int ignored;\n    fd_specified(\"\", -1);\n    follow_symlinks_specified(\"\", 1);\n    dir_fd_and_follow_symlinks_invalid(\"chmod\", DEFAULT_DIR_FD, 1);\n    dir_fd_converter(Py_None, &ignored);\n    dir_fd_unavailable(Py_None, &ignored);\n    }\n\n    /*\n     * provide list of locally available functions\n     * so os.py can populate support_* lists\n     */\n    PyObject *list = PyList_New(0);\n    if (!list) {\n        return -1;\n    }\n    for (const struct have_function *trace = have_functions; trace->label; trace++) {\n        PyObject *unicode;\n        if (trace->probe && !trace->probe()) continue;\n        unicode = PyUnicode_DecodeASCII(trace->label, strlen(trace->label), NULL);\n        if (!unicode)\n            return -1;\n        if (PyList_Append(list, unicode))\n            return -1;\n        Py_DECREF(unicode);\n    }\n\n#ifndef MS_WINDOWS\n    if (_Py_GetTicksPerSecond(&state->ticks_per_second) < 0) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"cannot read ticks_per_second\");\n        return -1;\n    }\n    assert(state->ticks_per_second >= 1);\n#endif\n\n    return PyModule_Add(m, \"_have_functions\", list);\n}\n\n\nstatic PyModuleDef_Slot posixmodile_slots[] = {\n    {Py_mod_exec, posixmodule_exec},\n    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},\n    {Py_mod_gil, Py_MOD_GIL_NOT_USED},\n    {0, NULL}\n};\n\nstatic struct PyModuleDef posixmodule = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = MODNAME,\n    .m_doc = posix__doc__,\n    .m_size = sizeof(_posixstate),\n    .m_methods = posix_methods,\n    .m_slots = posixmodile_slots,\n    .m_traverse = _posix_traverse,\n    .m_clear = _posix_clear,\n    .m_free = _posix_free,\n};\n\nPyMODINIT_FUNC\nINITFUNC(void)\n{\n    return PyModuleDef_Init(&posixmodule);\n}\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "/usr/include/fcntl.h"},
                          "contents": {"text": "/* Copyright (C) 1991-2024 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <https://www.gnu.org/licenses/>.  */\n\n/*\n *\tPOSIX Standard: 6.5 File Control Operations\t<fcntl.h>\n */\n\n#ifndef\t_FCNTL_H\n#define\t_FCNTL_H\t1\n\n#include <features.h>\n\n/* This must be early so <bits/fcntl.h> can define types winningly.  */\n__BEGIN_DECLS\n\n/* Get __mode_t, __dev_t and __off_t  .*/\n#include <bits/types.h>\n\n/* Get the definitions of O_*, F_*, FD_*: all the\n   numbers and flag bits for `open', `fcntl', et al.  */\n#include <bits/fcntl.h>\n\n/* Detect if open needs mode as a third argument (or for openat as a fourth\n   argument).  */\n#ifdef __O_TMPFILE\n# define __OPEN_NEEDS_MODE(oflag) \\\n  (((oflag) & O_CREAT) != 0 || ((oflag) & __O_TMPFILE) == __O_TMPFILE)\n#else\n# define __OPEN_NEEDS_MODE(oflag) (((oflag) & O_CREAT) != 0)\n#endif\n\n/* POSIX.1-2001 specifies that these types are defined by <fcntl.h>.\n   Earlier POSIX standards permitted any type ending in `_t' to be defined\n   by any POSIX header, so we don't conditionalize the definitions here.  */\n#ifndef __mode_t_defined\ntypedef __mode_t mode_t;\n# define __mode_t_defined\n#endif\n\n#ifndef __off_t_defined\n# ifndef __USE_FILE_OFFSET64\ntypedef __off_t off_t;\n# else\ntypedef __off64_t off_t;\n# endif\n# define __off_t_defined\n#endif\n\n#if defined __USE_LARGEFILE64 && !defined __off64_t_defined\ntypedef __off64_t off64_t;\n# define __off64_t_defined\n#endif\n\n#ifndef __pid_t_defined\ntypedef __pid_t pid_t;\n# define __pid_t_defined\n#endif\n\n/* For XPG all symbols from <sys/stat.h> should also be available.  */\n#ifdef __USE_XOPEN2K8\n# include <bits/types/struct_timespec.h>\n#endif\n#if defined __USE_XOPEN || defined __USE_XOPEN2K8\n# include <bits/stat.h>\n\n# define S_IFMT\t\t__S_IFMT\n# define S_IFDIR\t__S_IFDIR\n# define S_IFCHR\t__S_IFCHR\n# define S_IFBLK\t__S_IFBLK\n# define S_IFREG\t__S_IFREG\n# ifdef __S_IFIFO\n#  define S_IFIFO\t__S_IFIFO\n# endif\n# ifdef __S_IFLNK\n#  define S_IFLNK\t__S_IFLNK\n# endif\n# if (defined __USE_UNIX98 || defined __USE_XOPEN2K8) && defined __S_IFSOCK\n#  define S_IFSOCK\t__S_IFSOCK\n# endif\n\n/* Protection bits.  */\n\n# define S_ISUID\t__S_ISUID       /* Set user ID on execution.  */\n# define S_ISGID\t__S_ISGID       /* Set group ID on execution.  */\n\n# if defined __USE_MISC || defined __USE_XOPEN\n/* Save swapped text after use (sticky bit).  This is pretty well obsolete.  */\n#  define S_ISVTX\t__S_ISVTX\n# endif\n\n# define S_IRUSR\t__S_IREAD       /* Read by owner.  */\n# define S_IWUSR\t__S_IWRITE      /* Write by owner.  */\n# define S_IXUSR\t__S_IEXEC       /* Execute by owner.  */\n/* Read, write, and execute by owner.  */\n# define S_IRWXU\t(__S_IREAD|__S_IWRITE|__S_IEXEC)\n\n# define S_IRGRP\t(S_IRUSR >> 3)  /* Read by group.  */\n# define S_IWGRP\t(S_IWUSR >> 3)  /* Write by group.  */\n# define S_IXGRP\t(S_IXUSR >> 3)  /* Execute by group.  */\n/* Read, write, and execute by group.  */\n# define S_IRWXG\t(S_IRWXU >> 3)\n\n# define S_IROTH\t(S_IRGRP >> 3)  /* Read by others.  */\n# define S_IWOTH\t(S_IWGRP >> 3)  /* Write by others.  */\n# define S_IXOTH\t(S_IXGRP >> 3)  /* Execute by others.  */\n/* Read, write, and execute by others.  */\n# define S_IRWXO\t(S_IRWXG >> 3)\n#endif\n\n#ifdef\t__USE_MISC\n# ifndef R_OK\t\t\t/* Verbatim from <unistd.h>.  Ugh.  */\n/* Values for the second argument to access.\n   These may be OR'd together.  */\n#  define R_OK\t4\t\t/* Test for read permission.  */\n#  define W_OK\t2\t\t/* Test for write permission.  */\n#  define X_OK\t1\t\t/* Test for execute permission.  */\n#  define F_OK\t0\t\t/* Test for existence.  */\n# endif\n#endif /* Use misc.  */\n\n/* XPG wants the following symbols.   <stdio.h> has the same definitions.  */\n#if defined __USE_XOPEN || defined __USE_XOPEN2K8\n# define SEEK_SET\t0\t/* Seek from beginning of file.  */\n# define SEEK_CUR\t1\t/* Seek from current position.  */\n# define SEEK_END\t2\t/* Seek from end of file.  */\n#endif\t/* XPG */\n\n/* The constants AT_REMOVEDIR and AT_EACCESS have the same value.  AT_EACCESS\n   is meaningful only to faccessat, while AT_REMOVEDIR is meaningful only to\n   unlinkat.  The two functions do completely different things and therefore,\n   the flags can be allowed to overlap.  For example, passing AT_REMOVEDIR to\n   faccessat would be undefined behavior and thus treating it equivalent to\n   AT_EACCESS is valid undefined behavior.  */\n#ifdef __USE_ATFILE\n# define AT_FDCWD\t\t-100\t/* Special value used to indicate\n\t\t\t\t\t   the *at functions should use the\n\t\t\t\t\t   current working directory. */\n# define AT_SYMLINK_NOFOLLOW\t0x100\t/* Do not follow symbolic links.  */\n# define AT_REMOVEDIR\t\t0x200\t/* Remove directory instead of\n\t\t\t\t\t   unlinking file.  */\n# define AT_SYMLINK_FOLLOW\t0x400\t/* Follow symbolic links.  */\n# ifdef __USE_GNU\n#  define AT_NO_AUTOMOUNT\t0x800\t/* Suppress terminal automount\n\t\t\t\t\t   traversal.  */\n#  define AT_EMPTY_PATH\t\t0x1000\t/* Allow empty relative pathname.  */\n#  define AT_STATX_SYNC_TYPE\t0x6000\n#  define AT_STATX_SYNC_AS_STAT\t0x0000\n#  define AT_STATX_FORCE_SYNC\t0x2000\n#  define AT_STATX_DONT_SYNC\t0x4000\n#  define AT_RECURSIVE\t\t0x8000\t/* Apply to the entire subtree.  */\n# endif\n# define AT_EACCESS\t\t0x200\t/* Test access permitted for\n\t\t\t\t\t   effective IDs, not real IDs.  */\n#endif\n\n/* Do the file control operation described by CMD on FD.\n   The remaining arguments are interpreted depending on CMD.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\n#ifndef __USE_TIME64_REDIRECTS\n# ifndef __USE_FILE_OFFSET64\nextern int fcntl (int __fd, int __cmd, ...);\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (fcntl, (int __fd, int __cmd, ...), fcntl64);\n#  else\n#   define fcntl fcntl64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int fcntl64 (int __fd, int __cmd, ...);\n# endif\n#else /* __USE_TIME64_REDIRECTS */\n# ifdef __REDIRECT\nextern int __REDIRECT_NTH (fcntl, (int __fd, int __request, ...),\n\t\t\t   __fcntl_time64);\nextern int __REDIRECT_NTH (fcntl64, (int __fd, int __request, ...),\n\t\t\t   __fcntl_time64);\n# else\nextern int __fcntl_time64 (int __fd, int __request, ...) __THROW;\n#  define fcntl64 __fcntl_time64\n#  define fcntl __fcntl_time64\n# endif\n#endif\n\n/* Open FILE and return a new file descriptor for it, or -1 on error.\n   OFLAG determines the type of access used.  If O_CREAT or O_TMPFILE is set\n   in OFLAG, the third argument is taken as a `mode_t', the mode of the\n   created file.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\n#ifndef __USE_FILE_OFFSET64\nextern int open (const char *__file, int __oflag, ...) __nonnull ((1));\n#else\n# ifdef __REDIRECT\nextern int __REDIRECT (open, (const char *__file, int __oflag, ...), open64)\n     __nonnull ((1));\n# else\n#  define open open64\n# endif\n#endif\n#ifdef __USE_LARGEFILE64\nextern int open64 (const char *__file, int __oflag, ...) __nonnull ((1));\n#endif\n\n#ifdef __USE_ATFILE\n/* Similar to `open' but a relative path name is interpreted relative to\n   the directory for which FD is a descriptor.\n\n   NOTE: some other `openat' implementation support additional functionality\n   through this interface, especially using the O_XATTR flag.  This is not\n   yet supported here.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int openat (int __fd, const char *__file, int __oflag, ...)\n     __nonnull ((2));\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (openat, (int __fd, const char *__file, int __oflag,\n\t\t\t\t...), openat64) __nonnull ((2));\n#  else\n#   define openat openat64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int openat64 (int __fd, const char *__file, int __oflag, ...)\n     __nonnull ((2));\n# endif\n#endif\n\n/* Create and open FILE, with mode MODE.  This takes an `int' MODE\n   argument because that is what `mode_t' will be widened to.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\n#ifndef __USE_FILE_OFFSET64\nextern int creat (const char *__file, mode_t __mode) __nonnull ((1));\n#else\n# ifdef __REDIRECT\nextern int __REDIRECT (creat, (const char *__file, mode_t __mode),\n\t\t       creat64) __nonnull ((1));\n# else\n#  define creat creat64\n# endif\n#endif\n#ifdef __USE_LARGEFILE64\nextern int creat64 (const char *__file, mode_t __mode) __nonnull ((1));\n#endif\n\n#if !defined F_LOCK && (defined __USE_MISC || (defined __USE_XOPEN_EXTENDED \\\n\t\t\t\t\t       && !defined __USE_POSIX))\n/* NOTE: These declarations also appear in <unistd.h>; be sure to keep both\n   files consistent.  Some systems have them there and some here, and some\n   software depends on the macros being defined without including both.  */\n\n/* `lockf' is a simpler interface to the locking facilities of `fcntl'.\n   LEN is always relative to the current file position.\n   The CMD argument is one of the following.  */\n\n# define F_ULOCK 0\t/* Unlock a previously locked region.  */\n# define F_LOCK  1\t/* Lock a region for exclusive use.  */\n# define F_TLOCK 2\t/* Test and lock a region for exclusive use.  */\n# define F_TEST  3\t/* Test a region for other processes locks.  */\n\n# ifndef __USE_FILE_OFFSET64\nextern int lockf (int __fd, int __cmd, off_t __len);\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (lockf, (int __fd, int __cmd, __off64_t __len), lockf64);\n#  else\n#   define lockf lockf64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int lockf64 (int __fd, int __cmd, off64_t __len);\n# endif\n#endif\n\n#ifdef __USE_XOPEN2K\n/* Advice the system about the expected behaviour of the application with\n   respect to the file associated with FD.  */\n# ifndef __USE_FILE_OFFSET64\nextern int posix_fadvise (int __fd, off_t __offset, off_t __len,\n\t\t\t  int __advise) __THROW;\n# else\n # ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (posix_fadvise, (int __fd, __off64_t __offset,\n\t\t\t\t\t   __off64_t __len, int __advise),\n\t\t\t   posix_fadvise64);\n#  else\n#   define posix_fadvise posix_fadvise64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,\n\t\t\t    int __advise) __THROW;\n# endif\n\n\n/* Reserve storage for the data of the file associated with FD.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int posix_fallocate (int __fd, off_t __offset, off_t __len);\n# else\n # ifdef __REDIRECT\nextern int __REDIRECT (posix_fallocate, (int __fd, __off64_t __offset,\n\t\t\t\t\t __off64_t __len),\n\t\t       posix_fallocate64);\n#  else\n#   define posix_fallocate posix_fallocate64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);\n# endif\n#endif\n\n\n/* Define some inlines helping to catch common problems.  */\n#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function \\\n    && defined __va_arg_pack_len\n# include <bits/fcntl2.h>\n#endif\n\n__END_DECLS\n\n#endif /* fcntl.h  */\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-null-argument",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 85959,
                                       "gcc/analyzer/saved_diagnostic/snode": 4187,
                                       "gcc/analyzer/saved_diagnostic/sval": "(const char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 49},
                        "level": "warning",
                        "message": {"text": "use of NULL 'path.narrow' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 10226,
                                                                       "startColumn": 18,
                                                                       "endColumn": 60},
                                                            "contextRegion": {"startLine": 10226,
                                                                              "snippet": {"text": "        length = readlink(path->narrow, buffer, MAXPATHLEN);\n"}}},
                                       "logicalLocations": [{"name": "os_readlink_impl",
                                                             "fullyQualifiedName": "os_readlink_impl",
                                                             "decoratedName": "os_readlink_impl",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6181,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 12},
                                                                                                         "contextRegion": {"startLine": 6181,
                                                                                                                           "snippet": {"text": "os_readlink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_readlink",
                                                                                                          "fullyQualifiedName": "os_readlink",
                                                                                                          "decoratedName": "os_readlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_readlink'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6211,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 16},
                                                                                                         "contextRegion": {"startLine": 6211,
                                                                                                                           "snippet": {"text": "    path_t path = PATH_T_INITIALIZE_P(\"readlink\", \"path\", 0, 0, 0, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_readlink",
                                                                                                          "fullyQualifiedName": "os_readlink",
                                                                                                          "decoratedName": "os_readlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1961,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6218,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 6218,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_readlink",
                                                                                                          "fullyQualifiedName": "os_readlink",
                                                                                                          "decoratedName": "os_readlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_readlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 6045,
                                                                                                                                 "dst_idx": 6161,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_cleanup' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1243,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1243,
                                                                                                                           "snippet": {"text": "path_cleanup(path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_cleanup'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1248,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1248,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->object);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1250,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 2},
                                                                                                         "contextRegion": {"startLine": 1250,
                                                                                                                           "snippet": {"text": "}\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6171,
                                                                                                                                 "dst_idx": 6046,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'path_converter' from 'path_cleanup'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1962,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6218,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 6218,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_readlink",
                                                                                                          "fullyQualifiedName": "os_readlink",
                                                                                                          "decoratedName": "os_readlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_readlink' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1962,
                                                                                                                                 "dst_idx": 1964,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6218,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6218,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_readlink",
                                                                                                          "fullyQualifiedName": "os_readlink",
                                                                                                          "decoratedName": "os_readlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1962,
                                                                                                                                 "dst_idx": 1964,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6221,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6221,
                                                                                                                           "snippet": {"text": "    if (!noptargs) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_readlink",
                                                                                                          "fullyQualifiedName": "os_readlink",
                                                                                                          "decoratedName": "os_readlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1969,
                                                                                                                                 "dst_idx": 4184,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6228,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 59},
                                                                                                         "contextRegion": {"startLine": 6228,
                                                                                                                           "snippet": {"text": "    return_value = os_readlink_impl(module, &path, dir_fd);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_readlink",
                                                                                                          "fullyQualifiedName": "os_readlink",
                                                                                                          "decoratedName": "os_readlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'os_readlink_impl' from 'os_readlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10206,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 17},
                                                                                                         "contextRegion": {"startLine": 10206,
                                                                                                                           "snippet": {"text": "os_readlink_impl(PyObject *module, path_t *path, int dir_fd)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_readlink_impl",
                                                                                                          "fullyQualifiedName": "os_readlink_impl",
                                                                                                          "decoratedName": "os_readlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_readlink_impl'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4185,
                                                                                                                                 "dst_idx": 4187,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10218,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 10218,
                                                                                                                           "snippet": {"text": "    if (dir_fd != DEFAULT_DIR_FD) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_readlink_impl",
                                                                                                          "fullyQualifiedName": "os_readlink_impl",
                                                                                                          "decoratedName": "os_readlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'dir_fd == -100')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4185,
                                                                                                                                 "dst_idx": 4187,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10226,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 60},
                                                                                                         "contextRegion": {"startLine": 10226,
                                                                                                                           "snippet": {"text": "        length = readlink(path->narrow, buffer, MAXPATHLEN);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_readlink_impl",
                                                                                                          "fullyQualifiedName": "os_readlink_impl",
                                                                                                          "decoratedName": "os_readlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10226,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 60},
                                                                                                         "contextRegion": {"startLine": 10226,
                                                                                                                           "snippet": {"text": "        length = readlink(path->narrow, buffer, MAXPATHLEN);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_readlink_impl",
                                                                                                          "fullyQualifiedName": "os_readlink_impl",
                                                                                                          "decoratedName": "os_readlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10226,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 60},
                                                                                                         "contextRegion": {"startLine": 10226,
                                                                                                                           "snippet": {"text": "        length = readlink(path->narrow, buffer, MAXPATHLEN);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_readlink_impl",
                                                                                                          "fullyQualifiedName": "os_readlink_impl",
                                                                                                          "decoratedName": "os_readlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('*path.narrow') NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 20}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/unistd.h"},
                                                                   "region": {"startLine": 838,
                                                                              "startColumn": 16,
                                                                              "endColumn": 24},
                                                                   "contextRegion": {"startLine": 838,
                                                                                     "snippet": {"text": "extern ssize_t readlink (const char *__restrict __path,\n"}}},
                                              "message": {"text": "argument 1 of 'readlink' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-null-argument",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 83137,
                                       "gcc/analyzer/saved_diagnostic/snode": 4178,
                                       "gcc/analyzer/saved_diagnostic/sval": "(const char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 42},
                        "level": "warning",
                        "message": {"text": "use of NULL 'dst.narrow' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 10499,
                                                                       "startColumn": 22,
                                                                       "endColumn": 65},
                                                            "contextRegion": {"startLine": 10499,
                                                                              "snippet": {"text": "            result = symlinkat(src->narrow, dir_fd, dst->narrow);\n"}}},
                                       "logicalLocations": [{"name": "os_symlink_impl",
                                                             "fullyQualifiedName": "os_symlink_impl",
                                                             "decoratedName": "os_symlink_impl",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6265,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 6265,
                                                                                                                           "snippet": {"text": "os_symlink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_symlink'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6295,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 6295,
                                                                                                                           "snippet": {"text": "    path_t src = PATH_T_INITIALIZE_P(\"symlink\", \"src\", 0, 0, 0, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6296,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 6296,
                                                                                                                           "snippet": {"text": "    path_t dst = PATH_T_INITIALIZE_P(\"symlink\", \"dst\", 0, 0, 0, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1930,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6304,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6304,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &src)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_symlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 6045,
                                                                                                                                 "dst_idx": 6161,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_cleanup' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1243,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1243,
                                                                                                                           "snippet": {"text": "path_cleanup(path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_cleanup'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1248,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1248,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->object);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1250,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 2},
                                                                                                         "contextRegion": {"startLine": 1250,
                                                                                                                           "snippet": {"text": "}\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6171,
                                                                                                                                 "dst_idx": 6046,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'path_converter' from 'path_cleanup'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1931,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6304,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6304,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &src)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_symlink' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1931,
                                                                                                                                 "dst_idx": 1933,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6304,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6304,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &src)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1931,
                                                                                                                                 "dst_idx": 1933,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1933,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_symlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6044,
                                                                                                                                 "dst_idx": 6047,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1270,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1270,
                                                                                                                           "snippet": {"text": "    if (o == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'o' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6044,
                                                                                                                                 "dst_idx": 6047,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1276,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 37},
                                                                                                         "contextRegion": {"startLine": 1276,
                                                                                                                           "snippet": {"text": "    path->object = path->cleanup = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1278,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1278,
                                                                                                                           "snippet": {"text": "    Py_INCREF(o);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'Py_INCREF' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "path_converter",
                                                                                                                                     "fullyQualifiedName": "path_converter",
                                                                                                                                     "decoratedName": "path_converter",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 2,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6047,
                                                                                                                                 "dst_idx": 6048,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 820,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 820,
                                                                                                                           "snippet": {"text": "    if (new_refcnt == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'new_refcnt != 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "path_converter",
                                                                                                                                     "fullyQualifiedName": "path_converter",
                                                                                                                                     "decoratedName": "path_converter",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 2,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6047,
                                                                                                                                 "dst_idx": 6048,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 825,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 52},
                                                                                                         "contextRegion": {"startLine": 825,
                                                                                                                           "snippet": {"text": "    op->ob_refcnt_split[PY_BIG_ENDIAN] = new_refcnt;\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 22},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(23)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CONSOLIDATED_CFG_EDGES"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1280,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1280,
                                                                                                                           "snippet": {"text": "    if ((o == Py_None) && path->nullable) {\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 23},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(24)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CONSOLIDATED_CFG_EDGES"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1281,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 23},
                                                                                                         "contextRegion": {"startLine": 1281,
                                                                                                                           "snippet": {"text": "        path->wide = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 24},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(25)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1282,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 25},
                                                                                                         "contextRegion": {"startLine": 1282,
                                                                                                                           "snippet": {"text": "        path->narrow = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'dst.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 25},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(26)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1934,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_symlink' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 26},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(27)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1934,
                                                                                                                                 "dst_idx": 1936,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 27},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(28)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1934,
                                                                                                                                 "dst_idx": 1936,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6310,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6310,
                                                                                                                           "snippet": {"text": "    if (!noptargs) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 28},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(29)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1947,
                                                                                                                                 "dst_idx": 4167,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6330,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 84},
                                                                                                         "contextRegion": {"startLine": 6330,
                                                                                                                           "snippet": {"text": "    return_value = os_symlink_impl(module, &src, &dst, target_is_directory, dir_fd);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'os_symlink_impl' from 'os_symlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 29},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(30)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10419,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 16},
                                                                                                         "contextRegion": {"startLine": 10419,
                                                                                                                           "snippet": {"text": "os_symlink_impl(PyObject *module, path_t *src, path_t *dst,\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_symlink_impl'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 30},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(31)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4170,
                                                                                                                                 "dst_idx": 4172,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10436,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 10436,
                                                                                                                           "snippet": {"text": "    if (PySys_Audit(\"os.symlink\", \"OOi\", src->object, dst->object,\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 31},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(32)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4170,
                                                                                                                                 "dst_idx": 4172,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10489,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 21},
                                                                                                         "contextRegion": {"startLine": 10489,
                                                                                                                           "snippet": {"text": "    if ((src->narrow && dst->wide) || (src->wide && dst->narrow)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 32},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(33)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4177,
                                                                                                                                 "dst_idx": 4178,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10497,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 10497,
                                                                                                                           "snippet": {"text": "    if (dir_fd != DEFAULT_DIR_FD) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'dir_fd != -100')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 33},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(34)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4177,
                                                                                                                                 "dst_idx": 4178,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10499,
                                                                                                                    "startColumn": 22,
                                                                                                                    "endColumn": 65},
                                                                                                         "contextRegion": {"startLine": 10499,
                                                                                                                           "snippet": {"text": "            result = symlinkat(src->narrow, dir_fd, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 34},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(35)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10499,
                                                                                                                    "startColumn": 22,
                                                                                                                    "endColumn": 65},
                                                                                                         "contextRegion": {"startLine": 10499,
                                                                                                                           "snippet": {"text": "            result = symlinkat(src->narrow, dir_fd, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'dst.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 35},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(36)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10499,
                                                                                                                    "startColumn": 22,
                                                                                                                    "endColumn": 65},
                                                                                                         "contextRegion": {"startLine": 10499,
                                                                                                                           "snippet": {"text": "            result = symlinkat(src->narrow, dir_fd, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 3 ('*dst.narrow') NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 36}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/unistd.h"},
                                                                   "region": {"startLine": 847,
                                                                              "startColumn": 12,
                                                                              "endColumn": 21},
                                                                   "contextRegion": {"startLine": 847,
                                                                                     "snippet": {"text": "extern int symlinkat (const char *__from, int __tofd,\n"}}},
                                              "message": {"text": "argument 3 of 'symlinkat' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-null-argument",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 83098,
                                       "gcc/analyzer/saved_diagnostic/snode": 4179,
                                       "gcc/analyzer/saved_diagnostic/sval": "(const char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 41},
                        "level": "warning",
                        "message": {"text": "use of NULL 'src.narrow' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 10505,
                                                                       "startColumn": 18,
                                                                       "endColumn": 51},
                                                            "contextRegion": {"startLine": 10505,
                                                                              "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                       "logicalLocations": [{"name": "os_symlink_impl",
                                                             "fullyQualifiedName": "os_symlink_impl",
                                                             "decoratedName": "os_symlink_impl",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6265,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 6265,
                                                                                                                           "snippet": {"text": "os_symlink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_symlink'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6295,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 6295,
                                                                                                                           "snippet": {"text": "    path_t src = PATH_T_INITIALIZE_P(\"symlink\", \"src\", 0, 0, 0, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6296,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 6296,
                                                                                                                           "snippet": {"text": "    path_t dst = PATH_T_INITIALIZE_P(\"symlink\", \"dst\", 0, 0, 0, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1930,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6304,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6304,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &src)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_symlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 6045,
                                                                                                                                 "dst_idx": 6161,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_cleanup' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1243,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1243,
                                                                                                                           "snippet": {"text": "path_cleanup(path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_cleanup'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1248,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1248,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->object);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1250,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 2},
                                                                                                         "contextRegion": {"startLine": 1250,
                                                                                                                           "snippet": {"text": "}\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6171,
                                                                                                                                 "dst_idx": 6046,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'path_converter' from 'path_cleanup'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1931,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6304,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6304,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &src)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_symlink' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1931,
                                                                                                                                 "dst_idx": 1933,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6304,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6304,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &src)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1931,
                                                                                                                                 "dst_idx": 1933,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1933,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_symlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 6045,
                                                                                                                                 "dst_idx": 6161,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_cleanup' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1243,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1243,
                                                                                                                           "snippet": {"text": "path_cleanup(path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_cleanup'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1248,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1248,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->object);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 22},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(23)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1250,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 2},
                                                                                                         "contextRegion": {"startLine": 1250,
                                                                                                                           "snippet": {"text": "}\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 23},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(24)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6171,
                                                                                                                                 "dst_idx": 6046,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'path_converter' from 'path_cleanup'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 24},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(25)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1934,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_symlink' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 25},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(26)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1934,
                                                                                                                                 "dst_idx": 1936,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 26},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(27)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1934,
                                                                                                                                 "dst_idx": 1936,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6310,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6310,
                                                                                                                           "snippet": {"text": "    if (!noptargs) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 27},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(28)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1947,
                                                                                                                                 "dst_idx": 4167,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6330,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 84},
                                                                                                         "contextRegion": {"startLine": 6330,
                                                                                                                           "snippet": {"text": "    return_value = os_symlink_impl(module, &src, &dst, target_is_directory, dir_fd);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'os_symlink_impl' from 'os_symlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 28},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(29)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10419,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 16},
                                                                                                         "contextRegion": {"startLine": 10419,
                                                                                                                           "snippet": {"text": "os_symlink_impl(PyObject *module, path_t *src, path_t *dst,\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_symlink_impl'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 29},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(30)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4168,
                                                                                                                                 "dst_idx": 4169,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10436,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endLine": 10437,
                                                                                                                    "endColumn": 60},
                                                                                                         "contextRegion": {"startLine": 10436,
                                                                                                                           "endLine": 10437,
                                                                                                                           "snippet": {"text": "    if (PySys_Audit(\"os.symlink\", \"OOi\", src->object, dst->object,\n                    dir_fd == DEFAULT_DIR_FD ? -1 : dir_fd) < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'dir_fd == -100')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 30},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(31)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4168,
                                                                                                                                 "dst_idx": 4169,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 31},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(32)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4170,
                                                                                                                                 "dst_idx": 4172,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10436,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 10436,
                                                                                                                           "snippet": {"text": "    if (PySys_Audit(\"os.symlink\", \"OOi\", src->object, dst->object,\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 32},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(33)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4170,
                                                                                                                                 "dst_idx": 4172,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10489,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 21},
                                                                                                         "contextRegion": {"startLine": 10489,
                                                                                                                           "snippet": {"text": "    if ((src->narrow && dst->wide) || (src->wide && dst->narrow)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 33},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(34)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10489,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 21},
                                                                                                         "contextRegion": {"startLine": 10489,
                                                                                                                           "snippet": {"text": "    if ((src->narrow && dst->wide) || (src->wide && dst->narrow)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 34},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(35)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CONSOLIDATED_CFG_EDGES"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10489,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 10489,
                                                                                                                           "snippet": {"text": "    if ((src->narrow && dst->wide) || (src->wide && dst->narrow)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 35},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(36)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CONSOLIDATED_CFG_EDGES"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10495,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 10495,
                                                                                                                           "snippet": {"text": "    Py_BEGIN_ALLOW_THREADS\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 36},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(37)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4177,
                                                                                                                                 "dst_idx": 4179,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10497,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 10497,
                                                                                                                           "snippet": {"text": "    if (dir_fd != DEFAULT_DIR_FD) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'dir_fd == -100')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 37},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(38)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4177,
                                                                                                                                 "dst_idx": 4179,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10505,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 51},
                                                                                                         "contextRegion": {"startLine": 10505,
                                                                                                                           "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 38},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(39)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10505,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 51},
                                                                                                         "contextRegion": {"startLine": 10505,
                                                                                                                           "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 39},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(40)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10505,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 51},
                                                                                                         "contextRegion": {"startLine": 10505,
                                                                                                                           "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 40},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(41)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10505,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 51},
                                                                                                         "contextRegion": {"startLine": 10505,
                                                                                                                           "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 2 ('*dst.narrow') NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 41}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/unistd.h"},
                                                                   "region": {"startLine": 832,
                                                                              "startColumn": 12,
                                                                              "endColumn": 19},
                                                                   "contextRegion": {"startLine": 832,
                                                                                     "snippet": {"text": "extern int symlink (const char *__from, const char *__to)\n"}}},
                                              "message": {"text": "argument 2 of 'symlink' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-null-argument",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 83098,
                                       "gcc/analyzer/saved_diagnostic/snode": 4179,
                                       "gcc/analyzer/saved_diagnostic/sval": "(const char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 40},
                        "level": "warning",
                        "message": {"text": "use of NULL 'src.narrow' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 10505,
                                                                       "startColumn": 18,
                                                                       "endColumn": 51},
                                                            "contextRegion": {"startLine": 10505,
                                                                              "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                       "logicalLocations": [{"name": "os_symlink_impl",
                                                             "fullyQualifiedName": "os_symlink_impl",
                                                             "decoratedName": "os_symlink_impl",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6265,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 6265,
                                                                                                                           "snippet": {"text": "os_symlink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_symlink'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6295,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 6295,
                                                                                                                           "snippet": {"text": "    path_t src = PATH_T_INITIALIZE_P(\"symlink\", \"src\", 0, 0, 0, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6296,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 6296,
                                                                                                                           "snippet": {"text": "    path_t dst = PATH_T_INITIALIZE_P(\"symlink\", \"dst\", 0, 0, 0, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1930,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6304,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6304,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &src)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_symlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 6045,
                                                                                                                                 "dst_idx": 6161,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_cleanup' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1243,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1243,
                                                                                                                           "snippet": {"text": "path_cleanup(path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_cleanup'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1248,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1248,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->object);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1250,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 2},
                                                                                                         "contextRegion": {"startLine": 1250,
                                                                                                                           "snippet": {"text": "}\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6171,
                                                                                                                                 "dst_idx": 6046,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'path_converter' from 'path_cleanup'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1931,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6304,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6304,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &src)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_symlink' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1931,
                                                                                                                                 "dst_idx": 1933,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6304,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6304,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &src)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1931,
                                                                                                                                 "dst_idx": 1933,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1933,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_symlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 6045,
                                                                                                                                 "dst_idx": 6161,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_cleanup' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1243,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1243,
                                                                                                                           "snippet": {"text": "path_cleanup(path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_cleanup'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1248,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1248,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->object);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 22},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(23)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1250,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 2},
                                                                                                         "contextRegion": {"startLine": 1250,
                                                                                                                           "snippet": {"text": "}\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 23},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(24)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6171,
                                                                                                                                 "dst_idx": 6046,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'path_converter' from 'path_cleanup'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 24},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(25)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1934,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_symlink' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 25},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(26)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1934,
                                                                                                                                 "dst_idx": 1936,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 26},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(27)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1934,
                                                                                                                                 "dst_idx": 1936,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6310,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6310,
                                                                                                                           "snippet": {"text": "    if (!noptargs) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 27},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(28)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1947,
                                                                                                                                 "dst_idx": 4167,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6330,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 84},
                                                                                                         "contextRegion": {"startLine": 6330,
                                                                                                                           "snippet": {"text": "    return_value = os_symlink_impl(module, &src, &dst, target_is_directory, dir_fd);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'os_symlink_impl' from 'os_symlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 28},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(29)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10419,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 16},
                                                                                                         "contextRegion": {"startLine": 10419,
                                                                                                                           "snippet": {"text": "os_symlink_impl(PyObject *module, path_t *src, path_t *dst,\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_symlink_impl'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 29},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(30)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4168,
                                                                                                                                 "dst_idx": 4169,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10436,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endLine": 10437,
                                                                                                                    "endColumn": 60},
                                                                                                         "contextRegion": {"startLine": 10436,
                                                                                                                           "endLine": 10437,
                                                                                                                           "snippet": {"text": "    if (PySys_Audit(\"os.symlink\", \"OOi\", src->object, dst->object,\n                    dir_fd == DEFAULT_DIR_FD ? -1 : dir_fd) < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'dir_fd == -100')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 30},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(31)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4168,
                                                                                                                                 "dst_idx": 4169,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 31},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(32)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4170,
                                                                                                                                 "dst_idx": 4172,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10436,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 10436,
                                                                                                                           "snippet": {"text": "    if (PySys_Audit(\"os.symlink\", \"OOi\", src->object, dst->object,\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 32},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(33)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4170,
                                                                                                                                 "dst_idx": 4172,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10489,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 21},
                                                                                                         "contextRegion": {"startLine": 10489,
                                                                                                                           "snippet": {"text": "    if ((src->narrow && dst->wide) || (src->wide && dst->narrow)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 33},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(34)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10489,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 21},
                                                                                                         "contextRegion": {"startLine": 10489,
                                                                                                                           "snippet": {"text": "    if ((src->narrow && dst->wide) || (src->wide && dst->narrow)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 34},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(35)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CONSOLIDATED_CFG_EDGES"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10489,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 10489,
                                                                                                                           "snippet": {"text": "    if ((src->narrow && dst->wide) || (src->wide && dst->narrow)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 35},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(36)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CONSOLIDATED_CFG_EDGES"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10495,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 10495,
                                                                                                                           "snippet": {"text": "    Py_BEGIN_ALLOW_THREADS\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 36},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(37)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4177,
                                                                                                                                 "dst_idx": 4179,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10497,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 10497,
                                                                                                                           "snippet": {"text": "    if (dir_fd != DEFAULT_DIR_FD) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'dir_fd == -100')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 37},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(38)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4177,
                                                                                                                                 "dst_idx": 4179,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10505,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 51},
                                                                                                         "contextRegion": {"startLine": 10505,
                                                                                                                           "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 38},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(39)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10505,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 51},
                                                                                                         "contextRegion": {"startLine": 10505,
                                                                                                                           "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 39},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(40)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10505,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 51},
                                                                                                         "contextRegion": {"startLine": 10505,
                                                                                                                           "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 40},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(41)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10505,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 51},
                                                                                                         "contextRegion": {"startLine": 10505,
                                                                                                                           "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('*src.narrow') NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 41}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/unistd.h"},
                                                                   "region": {"startLine": 832,
                                                                              "startColumn": 12,
                                                                              "endColumn": 19},
                                                                   "contextRegion": {"startLine": 832,
                                                                                     "snippet": {"text": "extern int symlink (const char *__from, const char *__to)\n"}}},
                                              "message": {"text": "argument 1 of 'symlink' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-null-argument",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 83138,
                                       "gcc/analyzer/saved_diagnostic/snode": 4179,
                                       "gcc/analyzer/saved_diagnostic/sval": "(const char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 43},
                        "level": "warning",
                        "message": {"text": "use of NULL 'dst.narrow' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 10505,
                                                                       "startColumn": 18,
                                                                       "endColumn": 51},
                                                            "contextRegion": {"startLine": 10505,
                                                                              "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                       "logicalLocations": [{"name": "os_symlink_impl",
                                                             "fullyQualifiedName": "os_symlink_impl",
                                                             "decoratedName": "os_symlink_impl",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6265,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 6265,
                                                                                                                           "snippet": {"text": "os_symlink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_symlink'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6295,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 6295,
                                                                                                                           "snippet": {"text": "    path_t src = PATH_T_INITIALIZE_P(\"symlink\", \"src\", 0, 0, 0, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6296,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 6296,
                                                                                                                           "snippet": {"text": "    path_t dst = PATH_T_INITIALIZE_P(\"symlink\", \"dst\", 0, 0, 0, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'src.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1930,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6304,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6304,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &src)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_symlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 6045,
                                                                                                                                 "dst_idx": 6161,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_cleanup' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1243,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1243,
                                                                                                                           "snippet": {"text": "path_cleanup(path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_cleanup'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1248,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1248,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->object);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1250,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 2},
                                                                                                         "contextRegion": {"startLine": 1250,
                                                                                                                           "snippet": {"text": "}\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6171,
                                                                                                                                 "dst_idx": 6046,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'path_converter' from 'path_cleanup'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1931,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6304,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6304,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &src)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_symlink' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1931,
                                                                                                                                 "dst_idx": 1933,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6304,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6304,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &src)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1931,
                                                                                                                                 "dst_idx": 1933,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1933,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_symlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6044,
                                                                                                                                 "dst_idx": 6047,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1270,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1270,
                                                                                                                           "snippet": {"text": "    if (o == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'o' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6044,
                                                                                                                                 "dst_idx": 6047,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1276,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 37},
                                                                                                         "contextRegion": {"startLine": 1276,
                                                                                                                           "snippet": {"text": "    path->object = path->cleanup = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1278,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1278,
                                                                                                                           "snippet": {"text": "    Py_INCREF(o);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'Py_INCREF' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "path_converter",
                                                                                                                                     "fullyQualifiedName": "path_converter",
                                                                                                                                     "decoratedName": "path_converter",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 2,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6047,
                                                                                                                                 "dst_idx": 6048,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 820,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 820,
                                                                                                                           "snippet": {"text": "    if (new_refcnt == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'new_refcnt != 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "path_converter",
                                                                                                                                     "fullyQualifiedName": "path_converter",
                                                                                                                                     "decoratedName": "path_converter",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 2,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6047,
                                                                                                                                 "dst_idx": 6048,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 825,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 52},
                                                                                                         "contextRegion": {"startLine": 825,
                                                                                                                           "snippet": {"text": "    op->ob_refcnt_split[PY_BIG_ENDIAN] = new_refcnt;\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 22},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(23)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CONSOLIDATED_CFG_EDGES"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1280,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1280,
                                                                                                                           "snippet": {"text": "    if ((o == Py_None) && path->nullable) {\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 23},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(24)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CONSOLIDATED_CFG_EDGES"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1281,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 23},
                                                                                                         "contextRegion": {"startLine": 1281,
                                                                                                                           "snippet": {"text": "        path->wide = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 24},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(25)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1282,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 25},
                                                                                                         "contextRegion": {"startLine": 1282,
                                                                                                                           "snippet": {"text": "        path->narrow = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'dst.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 25},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(26)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1934,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_symlink' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 26},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(27)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1934,
                                                                                                                                 "dst_idx": 1936,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6307,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6307,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[1], &dst)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 27},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(28)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1934,
                                                                                                                                 "dst_idx": 1936,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6310,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6310,
                                                                                                                           "snippet": {"text": "    if (!noptargs) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 28},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(29)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1947,
                                                                                                                                 "dst_idx": 4167,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6330,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 84},
                                                                                                         "contextRegion": {"startLine": 6330,
                                                                                                                           "snippet": {"text": "    return_value = os_symlink_impl(module, &src, &dst, target_is_directory, dir_fd);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink",
                                                                                                          "fullyQualifiedName": "os_symlink",
                                                                                                          "decoratedName": "os_symlink",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'os_symlink_impl' from 'os_symlink'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 29},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(30)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10419,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 16},
                                                                                                         "contextRegion": {"startLine": 10419,
                                                                                                                           "snippet": {"text": "os_symlink_impl(PyObject *module, path_t *src, path_t *dst,\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_symlink_impl'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 30},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(31)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4170,
                                                                                                                                 "dst_idx": 4172,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10436,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 10436,
                                                                                                                           "snippet": {"text": "    if (PySys_Audit(\"os.symlink\", \"OOi\", src->object, dst->object,\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 31},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(32)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4170,
                                                                                                                                 "dst_idx": 4172,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10489,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 21},
                                                                                                         "contextRegion": {"startLine": 10489,
                                                                                                                           "snippet": {"text": "    if ((src->narrow && dst->wide) || (src->wide && dst->narrow)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 32},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(33)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4177,
                                                                                                                                 "dst_idx": 4179,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10497,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 10497,
                                                                                                                           "snippet": {"text": "    if (dir_fd != DEFAULT_DIR_FD) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'dir_fd == -100')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 33},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(34)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4177,
                                                                                                                                 "dst_idx": 4179,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10505,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 51},
                                                                                                         "contextRegion": {"startLine": 10505,
                                                                                                                           "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 34},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(35)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10505,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 51},
                                                                                                         "contextRegion": {"startLine": 10505,
                                                                                                                           "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'dst.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 35},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(36)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10505,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 51},
                                                                                                         "contextRegion": {"startLine": 10505,
                                                                                                                           "snippet": {"text": "        result = symlink(src->narrow, dst->narrow);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_symlink_impl",
                                                                                                          "fullyQualifiedName": "os_symlink_impl",
                                                                                                          "decoratedName": "os_symlink_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 2 ('*dst.narrow') NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 36}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/unistd.h"},
                                                                   "region": {"startLine": 832,
                                                                              "startColumn": 12,
                                                                              "endColumn": 19},
                                                                   "contextRegion": {"startLine": 832,
                                                                                     "snippet": {"text": "extern int symlink (const char *__from, const char *__to)\n"}}},
                                              "message": {"text": "argument 2 of 'symlink' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-null-argument",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 75482,
                                       "gcc/analyzer/saved_diagnostic/snode": 4019,
                                       "gcc/analyzer/saved_diagnostic/sval": "(const char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 33},
                        "level": "warning",
                        "message": {"text": "use of NULL 'path.narrow' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 11040,
                                                                       "startColumn": 18,
                                                                       "endColumn": 49},
                                                            "contextRegion": {"startLine": 11040,
                                                                              "snippet": {"text": "            fd = open(path->narrow, flags, mode);\n"}}},
                                       "logicalLocations": [{"name": "os_open_impl",
                                                             "fullyQualifiedName": "os_open_impl",
                                                             "decoratedName": "os_open_impl",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6908,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 8},
                                                                                                         "contextRegion": {"startLine": 6908,
                                                                                                                           "snippet": {"text": "os_open(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_open",
                                                                                                          "fullyQualifiedName": "os_open",
                                                                                                          "decoratedName": "os_open",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_open'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6938,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 16},
                                                                                                         "contextRegion": {"startLine": 6938,
                                                                                                                           "snippet": {"text": "    path_t path = PATH_T_INITIALIZE_P(\"open\", \"path\", 0, 0, 0, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_open",
                                                                                                          "fullyQualifiedName": "os_open",
                                                                                                          "decoratedName": "os_open",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1759,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6948,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 6948,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_open",
                                                                                                          "fullyQualifiedName": "os_open",
                                                                                                          "decoratedName": "os_open",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_open'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 6045,
                                                                                                                                 "dst_idx": 6161,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_cleanup' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1243,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1243,
                                                                                                                           "snippet": {"text": "path_cleanup(path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_cleanup'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1248,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1248,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->object);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1250,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 2},
                                                                                                         "contextRegion": {"startLine": 1250,
                                                                                                                           "snippet": {"text": "}\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6171,
                                                                                                                                 "dst_idx": 6046,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'path_converter' from 'path_cleanup'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1760,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6948,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 6948,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_open",
                                                                                                          "fullyQualifiedName": "os_open",
                                                                                                          "decoratedName": "os_open",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_open' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1760,
                                                                                                                                 "dst_idx": 1762,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6948,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 6948,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_open",
                                                                                                          "fullyQualifiedName": "os_open",
                                                                                                          "decoratedName": "os_open",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1760,
                                                                                                                                 "dst_idx": 1762,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6951,
                                                                                                                    "startColumn": 13,
                                                                                                                    "endColumn": 34},
                                                                                                         "contextRegion": {"startLine": 6951,
                                                                                                                           "snippet": {"text": "    flags = PyLong_AsInt(args[1]);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_open",
                                                                                                          "fullyQualifiedName": "os_open",
                                                                                                          "decoratedName": "os_open",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1777,
                                                                                                                                 "dst_idx": 4013,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 6975,
                                                                                                                    "startColumn": 21,
                                                                                                                    "endColumn": 69},
                                                                                                         "contextRegion": {"startLine": 6975,
                                                                                                                           "snippet": {"text": "    _return_value = os_open_impl(module, &path, flags, mode, dir_fd);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_open",
                                                                                                          "fullyQualifiedName": "os_open",
                                                                                                          "decoratedName": "os_open",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'os_open_impl' from 'os_open'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 10998,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 10998,
                                                                                                                           "snippet": {"text": "os_open_impl(PyObject *module, path_t *path, int flags, int mode, int dir_fd)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_open_impl",
                                                                                                          "fullyQualifiedName": "os_open_impl",
                                                                                                          "decoratedName": "os_open_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_open_impl'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4014,
                                                                                                                                 "dst_idx": 4016,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11019,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 11019,
                                                                                                                           "snippet": {"text": "    if (PySys_Audit(\"open\", \"OOi\", path->object, Py_None, flags) < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_open_impl",
                                                                                                          "fullyQualifiedName": "os_open_impl",
                                                                                                          "decoratedName": "os_open_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4014,
                                                                                                                                 "dst_idx": 4016,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"logicalLocations": [{"name": "os_open_impl",
                                                                                                          "fullyQualifiedName": "os_open_impl",
                                                                                                          "decoratedName": "os_open_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4017,
                                                                                                                                 "dst_idx": 4019,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11030,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 11030,
                                                                                                                           "snippet": {"text": "        if (dir_fd != DEFAULT_DIR_FD) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_open_impl",
                                                                                                          "fullyQualifiedName": "os_open_impl",
                                                                                                          "decoratedName": "os_open_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'dir_fd == -100')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4017,
                                                                                                                                 "dst_idx": 4019,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11040,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 49},
                                                                                                         "contextRegion": {"startLine": 11040,
                                                                                                                           "snippet": {"text": "            fd = open(path->narrow, flags, mode);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_open_impl",
                                                                                                          "fullyQualifiedName": "os_open_impl",
                                                                                                          "decoratedName": "os_open_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11040,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 49},
                                                                                                         "contextRegion": {"startLine": 11040,
                                                                                                                           "snippet": {"text": "            fd = open(path->narrow, flags, mode);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_open_impl",
                                                                                                          "fullyQualifiedName": "os_open_impl",
                                                                                                          "decoratedName": "os_open_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11040,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 49},
                                                                                                         "contextRegion": {"startLine": 11040,
                                                                                                                           "snippet": {"text": "            fd = open(path->narrow, flags, mode);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_open_impl",
                                                                                                          "fullyQualifiedName": "os_open_impl",
                                                                                                          "decoratedName": "os_open_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('*path.narrow') NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 22}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/fcntl.h"},
                                                                   "region": {"startLine": 212,
                                                                              "startColumn": 12,
                                                                              "endColumn": 13},
                                                                   "contextRegion": {"startLine": 212,
                                                                                     "snippet": {"text": "extern int __REDIRECT (open, (const char *__file, int __oflag, ...), open64)\n"}}},
                                              "message": {"text": "argument 1 of 'open' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-fd-leak",
                        "taxa": [{"id": "775",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "file-descriptor",
                                       "gcc/analyzer/saved_diagnostic/enode": 72940,
                                       "gcc/analyzer/saved_diagnostic/snode": 4007,
                                       "gcc/analyzer/saved_diagnostic/sval": "CONJURED(res_30 = dup2 (fd_21(D), fd2_22(D));, res_30)",
                                       "gcc/analyzer/saved_diagnostic/state": "fd-valid-read-write",
                                       "gcc/analyzer/saved_diagnostic/idx": 31},
                        "level": "warning",
                        "message": {"text": "leak of file descriptor 'res'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 11220,
                                                                       "startColumn": 13,
                                                                       "endColumn": 23},
                                                            "contextRegion": {"startLine": 11220,
                                                                              "snippet": {"text": "            close(fd2);\n"}}},
                                       "logicalLocations": [{"name": "os_dup2_impl",
                                                             "fullyQualifiedName": "os_dup2_impl",
                                                             "decoratedName": "os_dup2_impl",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 7130,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 8},
                                                                                                         "contextRegion": {"startLine": 7130,
                                                                                                                           "snippet": {"text": "os_dup2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2",
                                                                                                          "fullyQualifiedName": "os_dup2",
                                                                                                          "decoratedName": "os_dup2",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_dup2'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1693,
                                                                                                                                 "dst_idx": 1696,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 7166,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 7166,
                                                                                                                           "snippet": {"text": "    if (!args) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2",
                                                                                                          "fullyQualifiedName": "os_dup2",
                                                                                                          "decoratedName": "os_dup2",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1693,
                                                                                                                                 "dst_idx": 1696,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 7169,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 31},
                                                                                                         "contextRegion": {"startLine": 7169,
                                                                                                                           "snippet": {"text": "    fd = PyLong_AsInt(args[0]);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2",
                                                                                                          "fullyQualifiedName": "os_dup2",
                                                                                                          "decoratedName": "os_dup2",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1704,
                                                                                                                                 "dst_idx": 1706,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 7181,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 7181,
                                                                                                                           "snippet": {"text": "    if (inheritable < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2",
                                                                                                          "fullyQualifiedName": "os_dup2",
                                                                                                          "decoratedName": "os_dup2",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'inheritable >= 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1704,
                                                                                                                                 "dst_idx": 1706,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 7184,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 7184,
                                                                                                                           "snippet": {"text": "skip_optional_pos:\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2",
                                                                                                          "fullyQualifiedName": "os_dup2",
                                                                                                          "decoratedName": "os_dup2",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1706,
                                                                                                                                 "dst_idx": 3989,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 7185,
                                                                                                                    "startColumn": 21,
                                                                                                                    "endColumn": 63},
                                                                                                         "contextRegion": {"startLine": 7185,
                                                                                                                           "snippet": {"text": "    _return_value = os_dup2_impl(module, fd, fd2, inheritable);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2",
                                                                                                          "fullyQualifiedName": "os_dup2",
                                                                                                          "decoratedName": "os_dup2",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'os_dup2_impl' from 'os_dup2'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11147,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 11147,
                                                                                                                           "snippet": {"text": "os_dup2_impl(PyObject *module, int fd, int fd2, int inheritable)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_dup2_impl'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3990,
                                                                                                                                 "dst_idx": 3991,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11194,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 11194,
                                                                                                                           "snippet": {"text": "    if (!inheritable && dup3_works != 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'inheritable == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3990,
                                                                                                                                 "dst_idx": 3991,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11194,
                                                                                                                    "startColumn": 25,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 11194,
                                                                                                                           "snippet": {"text": "    if (!inheritable && dup3_works != 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3991,
                                                                                                                                 "dst_idx": 3999,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11194,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 11194,
                                                                                                                           "snippet": {"text": "    if (!inheritable && dup3_works != 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3991,
                                                                                                                                 "dst_idx": 3999,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11208,
                                                                                                                    "startColumn": 24,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 11208,
                                                                                                                           "snippet": {"text": "    if (inheritable || dup3_works == 0)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3999,
                                                                                                                                 "dst_idx": 4000,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11208,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 39},
                                                                                                         "contextRegion": {"startLine": 11208,
                                                                                                                           "snippet": {"text": "    if (inheritable || dup3_works == 0)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3999,
                                                                                                                                 "dst_idx": 4000,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11211,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 11211,
                                                                                                                           "snippet": {"text": "        Py_BEGIN_ALLOW_THREADS\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11212,
                                                                                                                    "startColumn": 15,
                                                                                                                    "endColumn": 28},
                                                                                                         "contextRegion": {"startLine": 11212,
                                                                                                                           "snippet": {"text": "        res = dup2(fd, fd2);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "opened here"}},
                                                                       "kinds": ["acquire",
                                                                                 "resource"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11214,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 11214,
                                                                                                                           "snippet": {"text": "        if (res < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "assuming 'res' is a valid file descriptor (>= 0)"}},
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4000,
                                                                                                                                 "dst_idx": 4002,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11214,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 11214,
                                                                                                                           "snippet": {"text": "        if (res < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'res >= 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 4000,
                                                                                                                                 "dst_idx": 4002,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11219,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 11219,
                                                                                                                           "snippet": {"text": "        if (!inheritable && _Py_set_inheritable(fd2, 0, NULL) < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CONSOLIDATED_CFG_EDGES"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11219,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 11219,
                                                                                                                           "snippet": {"text": "        if (!inheritable && _Py_set_inheritable(fd2, 0, NULL) < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CONSOLIDATED_CFG_EDGES"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11220,
                                                                                                                    "startColumn": 13,
                                                                                                                    "endColumn": 23},
                                                                                                         "contextRegion": {"startLine": 11220,
                                                                                                                           "snippet": {"text": "            close(fd2);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 11220,
                                                                                                                    "startColumn": 13,
                                                                                                                    "endColumn": 23},
                                                                                                         "contextRegion": {"startLine": 11220,
                                                                                                                           "snippet": {"text": "            close(fd2);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_dup2_impl",
                                                                                                          "fullyQualifiedName": "os_dup2_impl",
                                                                                                          "decoratedName": "os_dup2_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'res' leaks here; was opened at (14)"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 20}]}]}]},
                       {"ruleId": "-Wanalyzer-null-argument",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 68011,
                                       "gcc/analyzer/saved_diagnostic/snode": 3708,
                                       "gcc/analyzer/saved_diagnostic/sval": "(const char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 22},
                        "level": "warning",
                        "message": {"text": "use of NULL 'path.narrow' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 12459,
                                                                       "startColumn": 22,
                                                                       "endColumn": 48},
                                                            "contextRegion": {"startLine": 12459,
                                                                              "snippet": {"text": "            result = mkfifo(path->narrow, mode);\n"}}},
                                       "logicalLocations": [{"name": "os_mkfifo_impl",
                                                             "fullyQualifiedName": "os_mkfifo_impl",
                                                             "decoratedName": "os_mkfifo_impl",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8496,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 8496,
                                                                                                                           "snippet": {"text": "os_mkfifo(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mkfifo",
                                                                                                          "fullyQualifiedName": "os_mkfifo",
                                                                                                          "decoratedName": "os_mkfifo",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_mkfifo'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8526,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 16},
                                                                                                         "contextRegion": {"startLine": 8526,
                                                                                                                           "snippet": {"text": "    path_t path = PATH_T_INITIALIZE_P(\"mkfifo\", \"path\", 0, 0, 0, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mkfifo",
                                                                                                          "fullyQualifiedName": "os_mkfifo",
                                                                                                          "decoratedName": "os_mkfifo",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1353,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8534,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 8534,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mkfifo",
                                                                                                          "fullyQualifiedName": "os_mkfifo",
                                                                                                          "decoratedName": "os_mkfifo",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_mkfifo'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 6045,
                                                                                                                                 "dst_idx": 6161,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_cleanup' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1243,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1243,
                                                                                                                           "snippet": {"text": "path_cleanup(path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_cleanup'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1248,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1248,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->object);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1250,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 2},
                                                                                                         "contextRegion": {"startLine": 1250,
                                                                                                                           "snippet": {"text": "}\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6171,
                                                                                                                                 "dst_idx": 6046,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'path_converter' from 'path_cleanup'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1354,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8534,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 8534,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mkfifo",
                                                                                                          "fullyQualifiedName": "os_mkfifo",
                                                                                                          "decoratedName": "os_mkfifo",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_mkfifo' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1354,
                                                                                                                                 "dst_idx": 1356,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8534,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 8534,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mkfifo",
                                                                                                          "fullyQualifiedName": "os_mkfifo",
                                                                                                          "decoratedName": "os_mkfifo",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1354,
                                                                                                                                 "dst_idx": 1356,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8537,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 8537,
                                                                                                                           "snippet": {"text": "    if (!noptargs) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mkfifo",
                                                                                                          "fullyQualifiedName": "os_mkfifo",
                                                                                                          "decoratedName": "os_mkfifo",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1368,
                                                                                                                                 "dst_idx": 3704,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8557,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 63},
                                                                                                         "contextRegion": {"startLine": 8557,
                                                                                                                           "snippet": {"text": "    return_value = os_mkfifo_impl(module, &path, mode, dir_fd);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mkfifo",
                                                                                                          "fullyQualifiedName": "os_mkfifo",
                                                                                                          "decoratedName": "os_mkfifo",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'os_mkfifo_impl' from 'os_mkfifo'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12437,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 12437,
                                                                                                                           "snippet": {"text": "os_mkfifo_impl(PyObject *module, path_t *path, int mode, int dir_fd)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mkfifo_impl",
                                                                                                          "fullyQualifiedName": "os_mkfifo_impl",
                                                                                                          "decoratedName": "os_mkfifo_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_mkfifo_impl'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3706,
                                                                                                                                 "dst_idx": 3708,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12449,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 12449,
                                                                                                                           "snippet": {"text": "        if (dir_fd != DEFAULT_DIR_FD) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mkfifo_impl",
                                                                                                          "fullyQualifiedName": "os_mkfifo_impl",
                                                                                                          "decoratedName": "os_mkfifo_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'dir_fd == -100')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3706,
                                                                                                                                 "dst_idx": 3708,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12459,
                                                                                                                    "startColumn": 22,
                                                                                                                    "endColumn": 48},
                                                                                                         "contextRegion": {"startLine": 12459,
                                                                                                                           "snippet": {"text": "            result = mkfifo(path->narrow, mode);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mkfifo_impl",
                                                                                                          "fullyQualifiedName": "os_mkfifo_impl",
                                                                                                          "decoratedName": "os_mkfifo_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12459,
                                                                                                                    "startColumn": 22,
                                                                                                                    "endColumn": 48},
                                                                                                         "contextRegion": {"startLine": 12459,
                                                                                                                           "snippet": {"text": "            result = mkfifo(path->narrow, mode);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mkfifo_impl",
                                                                                                          "fullyQualifiedName": "os_mkfifo_impl",
                                                                                                          "decoratedName": "os_mkfifo_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12459,
                                                                                                                    "startColumn": 22,
                                                                                                                    "endColumn": 48},
                                                                                                         "contextRegion": {"startLine": 12459,
                                                                                                                           "snippet": {"text": "            result = mkfifo(path->narrow, mode);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mkfifo_impl",
                                                                                                          "fullyQualifiedName": "os_mkfifo_impl",
                                                                                                          "decoratedName": "os_mkfifo_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('*path.narrow') NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 20}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/sys/stat.h"},
                                                                   "region": {"startLine": 418,
                                                                              "startColumn": 12,
                                                                              "endColumn": 18},
                                                                   "contextRegion": {"startLine": 418,
                                                                                     "snippet": {"text": "extern int mkfifo (const char *__path, __mode_t __mode)\n"}}},
                                              "message": {"text": "argument 1 of 'mkfifo' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-null-argument",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 65244,
                                       "gcc/analyzer/saved_diagnostic/snode": 3693,
                                       "gcc/analyzer/saved_diagnostic/sval": "(const char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 15},
                        "level": "warning",
                        "message": {"text": "use of NULL 'path.narrow' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 12528,
                                                                       "startColumn": 22,
                                                                       "endColumn": 55},
                                                            "contextRegion": {"startLine": 12528,
                                                                              "snippet": {"text": "            result = mknod(path->narrow, mode, device);\n"}}},
                                       "logicalLocations": [{"name": "os_mknod_impl",
                                                             "fullyQualifiedName": "os_mknod_impl",
                                                             "decoratedName": "os_mknod_impl",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8596,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 8596,
                                                                                                                           "snippet": {"text": "os_mknod(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod",
                                                                                                          "fullyQualifiedName": "os_mknod",
                                                                                                          "decoratedName": "os_mknod",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_mknod'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8626,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 16},
                                                                                                         "contextRegion": {"startLine": 8626,
                                                                                                                           "snippet": {"text": "    path_t path = PATH_T_INITIALIZE_P(\"mknod\", \"path\", 0, 0, 0, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod",
                                                                                                          "fullyQualifiedName": "os_mknod",
                                                                                                          "decoratedName": "os_mknod",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1316,
                                                                                                                                 "dst_idx": 1319,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8632,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 8632,
                                                                                                                           "snippet": {"text": "    if (!args) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod",
                                                                                                          "fullyQualifiedName": "os_mknod",
                                                                                                          "decoratedName": "os_mknod",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1316,
                                                                                                                                 "dst_idx": 1319,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8635,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 8635,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod",
                                                                                                          "fullyQualifiedName": "os_mknod",
                                                                                                          "decoratedName": "os_mknod",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1319,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8635,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 8635,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod",
                                                                                                          "fullyQualifiedName": "os_mknod",
                                                                                                          "decoratedName": "os_mknod",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_mknod'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 6045,
                                                                                                                                 "dst_idx": 6161,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_cleanup' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1243,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1243,
                                                                                                                           "snippet": {"text": "path_cleanup(path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_cleanup'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1248,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1248,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->object);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1250,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 2},
                                                                                                         "contextRegion": {"startLine": 1250,
                                                                                                                           "snippet": {"text": "}\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6171,
                                                                                                                                 "dst_idx": 6046,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'path_converter' from 'path_cleanup'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1320,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8635,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 8635,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod",
                                                                                                          "fullyQualifiedName": "os_mknod",
                                                                                                          "decoratedName": "os_mknod",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_mknod' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1320,
                                                                                                                                 "dst_idx": 1322,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8635,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 8635,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod",
                                                                                                          "fullyQualifiedName": "os_mknod",
                                                                                                          "decoratedName": "os_mknod",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1320,
                                                                                                                                 "dst_idx": 1322,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8638,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 8638,
                                                                                                                           "snippet": {"text": "    if (!noptargs) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod",
                                                                                                          "fullyQualifiedName": "os_mknod",
                                                                                                          "decoratedName": "os_mknod",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1340,
                                                                                                                                 "dst_idx": 3689,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8666,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 70},
                                                                                                         "contextRegion": {"startLine": 8666,
                                                                                                                           "snippet": {"text": "    return_value = os_mknod_impl(module, &path, mode, device, dir_fd);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod",
                                                                                                          "fullyQualifiedName": "os_mknod",
                                                                                                          "decoratedName": "os_mknod",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'os_mknod_impl' from 'os_mknod'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12505,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 14},
                                                                                                         "contextRegion": {"startLine": 12505,
                                                                                                                           "snippet": {"text": "os_mknod_impl(PyObject *module, path_t *path, int mode, dev_t device,\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod_impl",
                                                                                                          "fullyQualifiedName": "os_mknod_impl",
                                                                                                          "decoratedName": "os_mknod_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_mknod_impl'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3691,
                                                                                                                                 "dst_idx": 3693,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12518,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 12518,
                                                                                                                           "snippet": {"text": "        if (dir_fd != DEFAULT_DIR_FD) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod_impl",
                                                                                                          "fullyQualifiedName": "os_mknod_impl",
                                                                                                          "decoratedName": "os_mknod_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'dir_fd == -100')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3691,
                                                                                                                                 "dst_idx": 3693,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12528,
                                                                                                                    "startColumn": 22,
                                                                                                                    "endColumn": 55},
                                                                                                         "contextRegion": {"startLine": 12528,
                                                                                                                           "snippet": {"text": "            result = mknod(path->narrow, mode, device);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod_impl",
                                                                                                          "fullyQualifiedName": "os_mknod_impl",
                                                                                                          "decoratedName": "os_mknod_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12528,
                                                                                                                    "startColumn": 22,
                                                                                                                    "endColumn": 55},
                                                                                                         "contextRegion": {"startLine": 12528,
                                                                                                                           "snippet": {"text": "            result = mknod(path->narrow, mode, device);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod_impl",
                                                                                                          "fullyQualifiedName": "os_mknod_impl",
                                                                                                          "decoratedName": "os_mknod_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12528,
                                                                                                                    "startColumn": 22,
                                                                                                                    "endColumn": 55},
                                                                                                         "contextRegion": {"startLine": 12528,
                                                                                                                           "snippet": {"text": "            result = mknod(path->narrow, mode, device);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_mknod_impl",
                                                                                                          "fullyQualifiedName": "os_mknod_impl",
                                                                                                          "decoratedName": "os_mknod_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('*path.narrow') NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 22}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/sys/stat.h"},
                                                                   "region": {"startLine": 404,
                                                                              "startColumn": 12,
                                                                              "endColumn": 17},
                                                                   "contextRegion": {"startLine": 404,
                                                                                     "snippet": {"text": "extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)\n"}}},
                                              "message": {"text": "argument 1 of 'mknod' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-null-argument",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 61344,
                                       "gcc/analyzer/saved_diagnostic/snode": 3656,
                                       "gcc/analyzer/saved_diagnostic/sval": "(const char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 10},
                        "level": "warning",
                        "message": {"text": "use of NULL 'path.narrow' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 12709,
                                                                       "startColumn": 14,
                                                                       "endColumn": 44},
                                                            "contextRegion": {"startLine": 12709,
                                                                              "snippet": {"text": "    result = truncate(path->narrow, length);\n"}}},
                                       "logicalLocations": [{"name": "os_truncate_impl",
                                                             "fullyQualifiedName": "os_truncate_impl",
                                                             "decoratedName": "os_truncate_impl",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8839,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 12},
                                                                                                         "contextRegion": {"startLine": 8839,
                                                                                                                           "snippet": {"text": "os_truncate(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate",
                                                                                                          "fullyQualifiedName": "os_truncate",
                                                                                                          "decoratedName": "os_truncate",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_truncate'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8868,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 16},
                                                                                                         "contextRegion": {"startLine": 8868,
                                                                                                                           "snippet": {"text": "    path_t path = PATH_T_INITIALIZE_P(\"truncate\", \"path\", 0, 0, 0, PATH_HAVE_FTRUNCATE);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate",
                                                                                                          "fullyQualifiedName": "os_truncate",
                                                                                                          "decoratedName": "os_truncate",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1248,
                                                                                                                                 "dst_idx": 1251,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8872,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 8872,
                                                                                                                           "snippet": {"text": "    if (!args) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate",
                                                                                                          "fullyQualifiedName": "os_truncate",
                                                                                                          "decoratedName": "os_truncate",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1248,
                                                                                                                                 "dst_idx": 1251,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8875,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 8875,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate",
                                                                                                          "fullyQualifiedName": "os_truncate",
                                                                                                          "decoratedName": "os_truncate",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1251,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8875,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 8875,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate",
                                                                                                          "fullyQualifiedName": "os_truncate",
                                                                                                          "decoratedName": "os_truncate",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_truncate'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 6045,
                                                                                                                                 "dst_idx": 6161,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_cleanup' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1243,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1243,
                                                                                                                           "snippet": {"text": "path_cleanup(path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_cleanup'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1248,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1248,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->object);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1250,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 2},
                                                                                                         "contextRegion": {"startLine": 1250,
                                                                                                                           "snippet": {"text": "}\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6171,
                                                                                                                                 "dst_idx": 6046,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'path_converter' from 'path_cleanup'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1252,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8875,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 8875,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate",
                                                                                                          "fullyQualifiedName": "os_truncate",
                                                                                                          "decoratedName": "os_truncate",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_truncate' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1252,
                                                                                                                                 "dst_idx": 1254,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8875,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 8875,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate",
                                                                                                          "fullyQualifiedName": "os_truncate",
                                                                                                          "decoratedName": "os_truncate",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1252,
                                                                                                                                 "dst_idx": 1254,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8878,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 46},
                                                                                                         "contextRegion": {"startLine": 8878,
                                                                                                                           "snippet": {"text": "    if (!Py_off_t_converter(args[1], &length)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate",
                                                                                                          "fullyQualifiedName": "os_truncate",
                                                                                                          "decoratedName": "os_truncate",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8878,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 8878,
                                                                                                                           "snippet": {"text": "    if (!Py_off_t_converter(args[1], &length)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate",
                                                                                                          "fullyQualifiedName": "os_truncate",
                                                                                                          "decoratedName": "os_truncate",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'Py_off_t_converter' from 'os_truncate'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "os_truncate",
                                                                                                                                     "fullyQualifiedName": "os_truncate",
                                                                                                                                     "decoratedName": "os_truncate",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 1,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1254,
                                                                                                                                 "dst_idx": 1256,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1561,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1561,
                                                                                                                           "snippet": {"text": "    if (PyErr_Occurred())\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_off_t_converter",
                                                                                                          "fullyQualifiedName": "Py_off_t_converter",
                                                                                                          "decoratedName": "Py_off_t_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1254,
                                                                                                                                 "dst_idx": 1256,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8881,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 59},
                                                                                                         "contextRegion": {"startLine": 8881,
                                                                                                                           "snippet": {"text": "    return_value = os_truncate_impl(module, &path, length);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate",
                                                                                                          "fullyQualifiedName": "os_truncate",
                                                                                                          "decoratedName": "os_truncate",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1256,
                                                                                                                                 "dst_idx": 3651,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 8881,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 59},
                                                                                                         "contextRegion": {"startLine": 8881,
                                                                                                                           "snippet": {"text": "    return_value = os_truncate_impl(module, &path, length);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate",
                                                                                                          "fullyQualifiedName": "os_truncate",
                                                                                                          "decoratedName": "os_truncate",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'os_truncate_impl' from 'os_truncate'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12681,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 17},
                                                                                                         "contextRegion": {"startLine": 12681,
                                                                                                                           "snippet": {"text": "os_truncate_impl(PyObject *module, path_t *path, Py_off_t length)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate_impl",
                                                                                                          "fullyQualifiedName": "os_truncate_impl",
                                                                                                          "decoratedName": "os_truncate_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_truncate_impl'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3652,
                                                                                                                                 "dst_idx": 3655,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12689,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 12689,
                                                                                                                           "snippet": {"text": "    if (path->fd != -1)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate_impl",
                                                                                                          "fullyQualifiedName": "os_truncate_impl",
                                                                                                          "decoratedName": "os_truncate_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 22},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(23)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3652,
                                                                                                                                 "dst_idx": 3655,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12692,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 63},
                                                                                                         "contextRegion": {"startLine": 12692,
                                                                                                                           "snippet": {"text": "    if (PySys_Audit(\"os.truncate\", \"On\", path->object, length) < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate_impl",
                                                                                                          "fullyQualifiedName": "os_truncate_impl",
                                                                                                          "decoratedName": "os_truncate_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 23},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(24)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3655,
                                                                                                                                 "dst_idx": 3656,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12692,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 12692,
                                                                                                                           "snippet": {"text": "    if (PySys_Audit(\"os.truncate\", \"On\", path->object, length) < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate_impl",
                                                                                                          "fullyQualifiedName": "os_truncate_impl",
                                                                                                          "decoratedName": "os_truncate_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 24},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(25)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3655,
                                                                                                                                 "dst_idx": 3656,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12696,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 12696,
                                                                                                                           "snippet": {"text": "    Py_BEGIN_ALLOW_THREADS\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate_impl",
                                                                                                          "fullyQualifiedName": "os_truncate_impl",
                                                                                                          "decoratedName": "os_truncate_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 25},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(26)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12709,
                                                                                                                    "startColumn": 14,
                                                                                                                    "endColumn": 44},
                                                                                                         "contextRegion": {"startLine": 12709,
                                                                                                                           "snippet": {"text": "    result = truncate(path->narrow, length);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate_impl",
                                                                                                          "fullyQualifiedName": "os_truncate_impl",
                                                                                                          "decoratedName": "os_truncate_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 26},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(27)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 12709,
                                                                                                                    "startColumn": 14,
                                                                                                                    "endColumn": 44},
                                                                                                         "contextRegion": {"startLine": 12709,
                                                                                                                           "snippet": {"text": "    result = truncate(path->narrow, length);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_truncate_impl",
                                                                                                          "fullyQualifiedName": "os_truncate_impl",
                                                                                                          "decoratedName": "os_truncate_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('*path.narrow') NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 27}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/unistd.h"},
                                                                   "region": {"startLine": 1030,
                                                                              "startColumn": 12,
                                                                              "endColumn": 13},
                                                                   "contextRegion": {"startLine": 1030,
                                                                                     "snippet": {"text": "extern int __REDIRECT_NTH (truncate,\n"}}},
                                              "message": {"text": "argument 1 of 'truncate' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-null-argument",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 57364,
                                       "gcc/analyzer/saved_diagnostic/snode": 3528,
                                       "gcc/analyzer/saved_diagnostic/sval": "(const char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 5},
                        "level": "warning",
                        "message": {"text": "use of NULL 'path.narrow' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 13398,
                                                                       "startColumn": 18,
                                                                       "endColumn": 44},
                                                            "contextRegion": {"startLine": 13398,
                                                                              "snippet": {"text": "        result = statvfs(path->narrow, &st);\n"}}},
                                       "logicalLocations": [{"name": "os_statvfs_impl",
                                                             "fullyQualifiedName": "os_statvfs_impl",
                                                             "decoratedName": "os_statvfs_impl",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9738,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 9738,
                                                                                                                           "snippet": {"text": "os_statvfs(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs",
                                                                                                          "fullyQualifiedName": "os_statvfs",
                                                                                                          "decoratedName": "os_statvfs",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_statvfs'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9767,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 16},
                                                                                                         "contextRegion": {"startLine": 9767,
                                                                                                                           "snippet": {"text": "    path_t path = PATH_T_INITIALIZE_P(\"statvfs\", \"path\", 0, 0, 0, PATH_HAVE_FSTATVFS);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs",
                                                                                                          "fullyQualifiedName": "os_statvfs",
                                                                                                          "decoratedName": "os_statvfs",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1069,
                                                                                                                                 "dst_idx": 1072,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9770,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 9770,
                                                                                                                           "snippet": {"text": "    if (!args) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs",
                                                                                                          "fullyQualifiedName": "os_statvfs",
                                                                                                          "decoratedName": "os_statvfs",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1069,
                                                                                                                                 "dst_idx": 1072,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9773,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 9773,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs",
                                                                                                          "fullyQualifiedName": "os_statvfs",
                                                                                                          "decoratedName": "os_statvfs",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1072,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9773,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 9773,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs",
                                                                                                          "fullyQualifiedName": "os_statvfs",
                                                                                                          "decoratedName": "os_statvfs",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_statvfs'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 6045,
                                                                                                                                 "dst_idx": 6161,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_cleanup' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1243,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1243,
                                                                                                                           "snippet": {"text": "path_cleanup(path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_cleanup'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1248,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1248,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->object);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1250,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 2},
                                                                                                         "contextRegion": {"startLine": 1250,
                                                                                                                           "snippet": {"text": "}\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6171,
                                                                                                                                 "dst_idx": 6046,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'path_converter' from 'path_cleanup'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1073,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9773,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 9773,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs",
                                                                                                          "fullyQualifiedName": "os_statvfs",
                                                                                                          "decoratedName": "os_statvfs",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_statvfs' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1073,
                                                                                                                                 "dst_idx": 1075,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9773,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 9773,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs",
                                                                                                          "fullyQualifiedName": "os_statvfs",
                                                                                                          "decoratedName": "os_statvfs",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1073,
                                                                                                                                 "dst_idx": 1075,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9776,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 50},
                                                                                                         "contextRegion": {"startLine": 9776,
                                                                                                                           "snippet": {"text": "    return_value = os_statvfs_impl(module, &path);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs",
                                                                                                          "fullyQualifiedName": "os_statvfs",
                                                                                                          "decoratedName": "os_statvfs",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1075,
                                                                                                                                 "dst_idx": 3525,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9776,
                                                                                                                    "startColumn": 20,
                                                                                                                    "endColumn": 50},
                                                                                                         "contextRegion": {"startLine": 9776,
                                                                                                                           "snippet": {"text": "    return_value = os_statvfs_impl(module, &path);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs",
                                                                                                          "fullyQualifiedName": "os_statvfs",
                                                                                                          "decoratedName": "os_statvfs",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'os_statvfs_impl' from 'os_statvfs'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 13363,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 16},
                                                                                                         "contextRegion": {"startLine": 13363,
                                                                                                                           "snippet": {"text": "os_statvfs_impl(PyObject *module, path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs_impl",
                                                                                                          "fullyQualifiedName": "os_statvfs_impl",
                                                                                                          "decoratedName": "os_statvfs_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_statvfs_impl'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3526,
                                                                                                                                 "dst_idx": 3528,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 13393,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 13393,
                                                                                                                           "snippet": {"text": "    if (path->fd != -1) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs_impl",
                                                                                                          "fullyQualifiedName": "os_statvfs_impl",
                                                                                                          "decoratedName": "os_statvfs_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3526,
                                                                                                                                 "dst_idx": 3528,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 13398,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 44},
                                                                                                         "contextRegion": {"startLine": 13398,
                                                                                                                           "snippet": {"text": "        result = statvfs(path->narrow, &st);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs_impl",
                                                                                                          "fullyQualifiedName": "os_statvfs_impl",
                                                                                                          "decoratedName": "os_statvfs_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 13398,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 44},
                                                                                                         "contextRegion": {"startLine": 13398,
                                                                                                                           "snippet": {"text": "        result = statvfs(path->narrow, &st);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs_impl",
                                                                                                          "fullyQualifiedName": "os_statvfs_impl",
                                                                                                          "decoratedName": "os_statvfs_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 13398,
                                                                                                                    "startColumn": 18,
                                                                                                                    "endColumn": 44},
                                                                                                         "contextRegion": {"startLine": 13398,
                                                                                                                           "snippet": {"text": "        result = statvfs(path->narrow, &st);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_statvfs_impl",
                                                                                                          "fullyQualifiedName": "os_statvfs_impl",
                                                                                                          "decoratedName": "os_statvfs_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('*path.narrow') NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 22}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/sys/statvfs.h"},
                                                                   "region": {"startLine": 56,
                                                                              "startColumn": 12,
                                                                              "endColumn": 13},
                                                                   "contextRegion": {"startLine": 56,
                                                                                     "snippet": {"text": "extern int __REDIRECT_NTH (statvfs,\n"}}},
                                              "message": {"text": "argument 1 of 'statvfs' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-null-argument",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 55417,
                                       "gcc/analyzer/saved_diagnostic/snode": 3490,
                                       "gcc/analyzer/saved_diagnostic/sval": "(const char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 0},
                        "level": "warning",
                        "message": {"text": "use of NULL 'path.narrow' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 13675,
                                                                       "startColumn": 17,
                                                                       "endColumn": 45},
                                                            "contextRegion": {"startLine": 13675,
                                                                              "snippet": {"text": "        limit = pathconf(path->narrow, name);\n"}}},
                                       "logicalLocations": [{"name": "os_pathconf_impl",
                                                             "fullyQualifiedName": "os_pathconf_impl",
                                                             "decoratedName": "os_pathconf_impl",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9916,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 12},
                                                                                                         "contextRegion": {"startLine": 9916,
                                                                                                                           "snippet": {"text": "os_pathconf(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf",
                                                                                                          "fullyQualifiedName": "os_pathconf",
                                                                                                          "decoratedName": "os_pathconf",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_pathconf'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9945,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 16},
                                                                                                         "contextRegion": {"startLine": 9945,
                                                                                                                           "snippet": {"text": "    path_t path = PATH_T_INITIALIZE_P(\"pathconf\", \"path\", 0, 0, 0, PATH_HAVE_FPATHCONF);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf",
                                                                                                          "fullyQualifiedName": "os_pathconf",
                                                                                                          "decoratedName": "os_pathconf",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1032,
                                                                                                                                 "dst_idx": 1035,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9950,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 9950,
                                                                                                                           "snippet": {"text": "    if (!args) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf",
                                                                                                          "fullyQualifiedName": "os_pathconf",
                                                                                                          "decoratedName": "os_pathconf",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1032,
                                                                                                                                 "dst_idx": 1035,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9953,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 9953,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf",
                                                                                                          "fullyQualifiedName": "os_pathconf",
                                                                                                          "decoratedName": "os_pathconf",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1035,
                                                                                                                                 "dst_idx": 6043,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9953,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 9953,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf",
                                                                                                          "fullyQualifiedName": "os_pathconf",
                                                                                                          "decoratedName": "os_pathconf",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_converter' from 'os_pathconf'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1253,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1253,
                                                                                                                           "snippet": {"text": "path_converter(PyObject *o, void *p)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_converter'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 6045,
                                                                                                                                 "dst_idx": 6161,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'path_cleanup' from 'path_converter'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1243,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1243,
                                                                                                                           "snippet": {"text": "path_cleanup(path_t *path)\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'path_cleanup'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1248,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1248,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->object);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6162,
                                                                                                                                 "dst_idx": 6166,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1249,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1249,
                                                                                                                           "snippet": {"text": "    Py_CLEAR(path->cleanup);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when '_tmp_old_op' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 6166,
                                                                                                                                 "dst_idx": 6170,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1250,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 2},
                                                                                                         "contextRegion": {"startLine": 1250,
                                                                                                                           "snippet": {"text": "}\n"}}},
                                                                                    "logicalLocations": [{"name": "path_cleanup",
                                                                                                          "fullyQualifiedName": "path_cleanup",
                                                                                                          "decoratedName": "path_cleanup",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6171,
                                                                                                                                 "dst_idx": 6046,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1271,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 1271,
                                                                                                                           "snippet": {"text": "        path_cleanup(path);\n"}}},
                                                                                    "logicalLocations": [{"name": "path_converter",
                                                                                                          "fullyQualifiedName": "path_converter",
                                                                                                          "decoratedName": "path_converter",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'path_converter' from 'path_cleanup'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 6160,
                                                                                                                                 "dst_idx": 1036,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9953,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 9953,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf",
                                                                                                          "fullyQualifiedName": "os_pathconf",
                                                                                                          "decoratedName": "os_pathconf",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'os_pathconf' from 'path_converter'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1036,
                                                                                                                                 "dst_idx": 1038,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9953,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 9953,
                                                                                                                           "snippet": {"text": "    if (!path_converter(args[0], &path)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf",
                                                                                                          "fullyQualifiedName": "os_pathconf",
                                                                                                          "decoratedName": "os_pathconf",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1036,
                                                                                                                                 "dst_idx": 1038,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9956,
                                                                                                                    "startColumn": 10,
                                                                                                                    "endColumn": 44},
                                                                                                         "contextRegion": {"startLine": 9956,
                                                                                                                           "snippet": {"text": "    if (!conv_path_confname(args[1], &name)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf",
                                                                                                          "fullyQualifiedName": "os_pathconf",
                                                                                                          "decoratedName": "os_pathconf",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1039,
                                                                                                                                 "dst_idx": 1041,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9956,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 9956,
                                                                                                                           "snippet": {"text": "    if (!conv_path_confname(args[1], &name)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf",
                                                                                                          "fullyQualifiedName": "os_pathconf",
                                                                                                          "decoratedName": "os_pathconf",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1039,
                                                                                                                                 "dst_idx": 1041,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9959,
                                                                                                                    "startColumn": 21,
                                                                                                                    "endColumn": 58},
                                                                                                         "contextRegion": {"startLine": 9959,
                                                                                                                           "snippet": {"text": "    _return_value = os_pathconf_impl(module, &path, name);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf",
                                                                                                          "fullyQualifiedName": "os_pathconf",
                                                                                                          "decoratedName": "os_pathconf",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 1041,
                                                                                                                                 "dst_idx": 3487,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/clinic/posixmodule.c.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 9959,
                                                                                                                    "startColumn": 21,
                                                                                                                    "endColumn": 58},
                                                                                                         "contextRegion": {"startLine": 9959,
                                                                                                                           "snippet": {"text": "    _return_value = os_pathconf_impl(module, &path, name);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf",
                                                                                                          "fullyQualifiedName": "os_pathconf",
                                                                                                          "decoratedName": "os_pathconf",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'os_pathconf_impl' from 'os_pathconf'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 13664,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 17},
                                                                                                         "contextRegion": {"startLine": 13664,
                                                                                                                           "snippet": {"text": "os_pathconf_impl(PyObject *module, path_t *path, int name)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf_impl",
                                                                                                          "fullyQualifiedName": "os_pathconf_impl",
                                                                                                          "decoratedName": "os_pathconf_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'os_pathconf_impl'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3488,
                                                                                                                                 "dst_idx": 3490,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 13671,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 13671,
                                                                                                                           "snippet": {"text": "    if (path->fd != -1)\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf_impl",
                                                                                                          "fullyQualifiedName": "os_pathconf_impl",
                                                                                                          "decoratedName": "os_pathconf_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 3488,
                                                                                                                                 "dst_idx": 3490,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 13675,
                                                                                                                    "startColumn": 17,
                                                                                                                    "endColumn": 45},
                                                                                                         "contextRegion": {"startLine": 13675,
                                                                                                                           "snippet": {"text": "        limit = pathconf(path->narrow, name);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf_impl",
                                                                                                          "fullyQualifiedName": "os_pathconf_impl",
                                                                                                          "decoratedName": "os_pathconf_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 22},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(23)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 13675,
                                                                                                                    "startColumn": 17,
                                                                                                                    "endColumn": 45},
                                                                                                         "contextRegion": {"startLine": 13675,
                                                                                                                           "snippet": {"text": "        limit = pathconf(path->narrow, name);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf_impl",
                                                                                                          "fullyQualifiedName": "os_pathconf_impl",
                                                                                                          "decoratedName": "os_pathconf_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'path.narrow' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 23},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(24)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/posixmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 13675,
                                                                                                                    "startColumn": 17,
                                                                                                                    "endColumn": 45},
                                                                                                         "contextRegion": {"startLine": 13675,
                                                                                                                           "snippet": {"text": "        limit = pathconf(path->narrow, name);\n"}}},
                                                                                    "logicalLocations": [{"name": "os_pathconf_impl",
                                                                                                          "fullyQualifiedName": "os_pathconf_impl",
                                                                                                          "decoratedName": "os_pathconf_impl",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('*path.narrow') NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 24}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/unistd.h"},
                                                                   "region": {"startLine": 633,
                                                                              "startColumn": 17,
                                                                              "endColumn": 25},
                                                                   "contextRegion": {"startLine": 633,
                                                                                     "snippet": {"text": "extern long int pathconf (const char *__path, int __name)\n"}}},
                                              "message": {"text": "argument 1 of 'pathconf' must be non-null"}}]}]}]}
