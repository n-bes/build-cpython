{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-null-argument",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-argument"}]}},
           "taxonomies": [{"name": "CWE",
                           "version": "4.7",
                           "organization": "MITRE",
                           "shortDescription": {"text": "The MITRE Common Weakness Enumeration"},
                           "taxa": [{"id": "476",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}],
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.13.0b4/"}},
           "artifacts": [{"location": {"uri": "./Modules/arraymodule.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/* Array object implementation */\n\n/* An array is a uniform list -- all items have the same type.\n   The item type is restricted to simple C types like int or float */\n\n#ifndef Py_BUILD_CORE_BUILTIN\n#  define Py_BUILD_CORE_MODULE 1\n#endif\n\n#include \"Python.h\"\n#include \"pycore_bytesobject.h\"   // _PyBytes_Repeat\n#include \"pycore_call.h\"          // _PyObject_CallMethod()\n#include \"pycore_ceval.h\"         // _PyEval_GetBuiltin()\n#include \"pycore_modsupport.h\"    // _PyArg_NoKeywords()\n#include \"pycore_moduleobject.h\"  // _PyModule_GetState()\n\n#include <stddef.h>               // offsetof()\n#include <stdbool.h>\n\n/*[clinic input]\nmodule array\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=7d1b8d7f5958fd83]*/\n\nstruct arrayobject; /* Forward */\nstatic struct PyModuleDef arraymodule;\n\n/* All possible arraydescr values are defined in the vector \"descriptors\"\n * below.  That's defined later because the appropriate get and set\n * functions aren't visible yet.\n */\nstruct arraydescr {\n    char typecode;\n    int itemsize;\n    PyObject * (*getitem)(struct arrayobject *, Py_ssize_t);\n    int (*setitem)(struct arrayobject *, Py_ssize_t, PyObject *);\n    int (*compareitems)(const void *, const void *, Py_ssize_t);\n    const char *formats;\n    int is_integer_type;\n    int is_signed;\n};\n\ntypedef struct arrayobject {\n    PyObject_VAR_HEAD\n    char *ob_item;\n    Py_ssize_t allocated;\n    const struct arraydescr *ob_descr;\n    PyObject *weakreflist; /* List of weak references */\n    Py_ssize_t ob_exports;  /* Number of exported buffers */\n} arrayobject;\n\ntypedef struct {\n    PyObject_HEAD\n    Py_ssize_t index;\n    arrayobject *ao;\n    PyObject* (*getitem)(struct arrayobject *, Py_ssize_t);\n} arrayiterobject;\n\ntypedef struct {\n    PyTypeObject *ArrayType;\n    PyTypeObject *ArrayIterType;\n\n    PyObject *array_reconstructor;\n\n    PyObject *str_read;\n    PyObject *str_write;\n    PyObject *str___dict__;\n    PyObject *str_iter;\n} array_state;\n\nstatic array_state *\nget_array_state(PyObject *module)\n{\n    return (array_state *)_PyModule_GetState(module);\n}\n\n#define find_array_state_by_type(tp) \\\n    (get_array_state(PyType_GetModuleByDef(tp, &arraymodule)))\n#define get_array_state_by_class(cls) \\\n    (get_array_state(PyType_GetModule(cls)))\n\nenum machine_format_code {\n    UNKNOWN_FORMAT = -1,\n    /* UNKNOWN_FORMAT is used to indicate that the machine format for an\n     * array type code cannot be interpreted. When this occurs, a list of\n     * Python objects is used to represent the content of the array\n     * instead of using the memory content of the array directly. In that\n     * case, the array_reconstructor mechanism is bypassed completely, and\n     * the standard array constructor is used instead.\n     *\n     * This is will most likely occur when the machine doesn't use IEEE\n     * floating-point numbers.\n     */\n\n    UNSIGNED_INT8 = 0,\n    SIGNED_INT8 = 1,\n    UNSIGNED_INT16_LE = 2,\n    UNSIGNED_INT16_BE = 3,\n    SIGNED_INT16_LE = 4,\n    SIGNED_INT16_BE = 5,\n    UNSIGNED_INT32_LE = 6,\n    UNSIGNED_INT32_BE = 7,\n    SIGNED_INT32_LE = 8,\n    SIGNED_INT32_BE = 9,\n    UNSIGNED_INT64_LE = 10,\n    UNSIGNED_INT64_BE = 11,\n    SIGNED_INT64_LE = 12,\n    SIGNED_INT64_BE = 13,\n    IEEE_754_FLOAT_LE = 14,\n    IEEE_754_FLOAT_BE = 15,\n    IEEE_754_DOUBLE_LE = 16,\n    IEEE_754_DOUBLE_BE = 17,\n    UTF16_LE = 18,\n    UTF16_BE = 19,\n    UTF32_LE = 20,\n    UTF32_BE = 21\n};\n#define MACHINE_FORMAT_CODE_MIN 0\n#define MACHINE_FORMAT_CODE_MAX 21\n\n\n/*\n * Must come after arrayobject, arrayiterobject,\n * and enum machine_code_type definitions.\n */\n#include \"clinic/arraymodule.c.h\"\n\n#define array_Check(op, state) PyObject_TypeCheck(op, state->ArrayType)\n\nstatic int\narray_resize(arrayobject *self, Py_ssize_t newsize)\n{\n    char *items;\n    size_t _new_size;\n\n    if (self->ob_exports > 0 && newsize != Py_SIZE(self)) {\n        PyErr_SetString(PyExc_BufferError,\n            \"cannot resize an array that is exporting buffers\");\n        return -1;\n    }\n\n    /* Bypass realloc() when a previous overallocation is large enough\n       to accommodate the newsize.  If the newsize is 16 smaller than the\n       current size, then proceed with the realloc() to shrink the array.\n    */\n\n    if (self->allocated >= newsize &&\n        Py_SIZE(self) < newsize + 16 &&\n        self->ob_item != NULL) {\n        Py_SET_SIZE(self, newsize);\n        return 0;\n    }\n\n    if (newsize == 0) {\n        PyMem_Free(self->ob_item);\n        self->ob_item = NULL;\n        Py_SET_SIZE(self, 0);\n        self->allocated = 0;\n        return 0;\n    }\n\n    /* This over-allocates proportional to the array size, making room\n     * for additional growth.  The over-allocation is mild, but is\n     * enough to give linear-time amortized behavior over a long\n     * sequence of appends() in the presence of a poorly-performing\n     * system realloc().\n     * The growth pattern is:  0, 4, 8, 16, 25, 34, 46, 56, 67, 79, ...\n     * Note, the pattern starts out the same as for lists but then\n     * grows at a smaller rate so that larger arrays only overallocate\n     * by about 1/16th -- this is done because arrays are presumed to be more\n     * memory critical.\n     */\n\n    _new_size = (newsize >> 4) + (Py_SIZE(self) < 8 ? 3 : 7) + newsize;\n    items = self->ob_item;\n    /* XXX The following multiplication and division does not optimize away\n       like it does for lists since the size is not known at compile time */\n    if (_new_size <= ((~(size_t)0) / self->ob_descr->itemsize))\n        PyMem_RESIZE(items, char, (_new_size * self->ob_descr->itemsize));\n    else\n        items = NULL;\n    if (items == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    self->ob_item = items;\n    Py_SET_SIZE(self, newsize);\n    self->allocated = _new_size;\n    return 0;\n}\n\n/****************************************************************************\nGet and Set functions for each type.\nA Get function takes an arrayobject* and an integer index, returning the\narray value at that index wrapped in an appropriate PyObject*.\nA Set function takes an arrayobject, integer index, and PyObject*; sets\nthe array value at that index to the raw C data extracted from the PyObject*,\nand returns 0 if successful, else nonzero on failure (PyObject* not of an\nappropriate type or value).\nNote that the basic Get and Set functions do NOT check that the index is\nin bounds; that's the responsibility of the caller.\n****************************************************************************/\n\nstatic PyObject *\nb_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    long x = ((signed char *)ap->ob_item)[i];\n    return PyLong_FromLong(x);\n}\n\nstatic int\nb_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    short x;\n    /* PyArg_Parse's 'b' formatter is for an unsigned char, therefore\n       must use the next size up that is signed ('h') and manually do\n       the overflow checking */\n    if (!PyArg_Parse(v, \"h;array item must be integer\", &x))\n        return -1;\n    else if (x < -128) {\n        PyErr_SetString(PyExc_OverflowError,\n            \"signed char is less than minimum\");\n        return -1;\n    }\n    else if (x > 127) {\n        PyErr_SetString(PyExc_OverflowError,\n            \"signed char is greater than maximum\");\n        return -1;\n    }\n    if (i >= 0)\n        ((char *)ap->ob_item)[i] = (char)x;\n    return 0;\n}\n\nstatic PyObject *\nBB_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    long x = ((unsigned char *)ap->ob_item)[i];\n    return PyLong_FromLong(x);\n}\n\nstatic int\nBB_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    unsigned char x;\n    /* 'B' == unsigned char, maps to PyArg_Parse's 'b' formatter */\n    if (!PyArg_Parse(v, \"b;array item must be integer\", &x))\n        return -1;\n    if (i >= 0)\n        ((unsigned char *)ap->ob_item)[i] = x;\n    return 0;\n}\n\nstatic PyObject *\nu_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    return PyUnicode_FromOrdinal(((wchar_t *) ap->ob_item)[i]);\n}\n\nstatic int\nu_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    PyObject *u;\n    if (!PyArg_Parse(v, \"U;array item must be unicode character\", &u)) {\n        return -1;\n    }\n\n    Py_ssize_t len = PyUnicode_AsWideChar(u, NULL, 0);\n    if (len != 2) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"array item must be unicode character\");\n        return -1;\n    }\n\n    wchar_t w;\n    len = PyUnicode_AsWideChar(u, &w, 1);\n    assert(len == 1);\n\n    if (i >= 0) {\n        ((wchar_t *)ap->ob_item)[i] = w;\n    }\n    return 0;\n}\n\nstatic PyObject *\nw_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    return PyUnicode_FromOrdinal(((Py_UCS4 *) ap->ob_item)[i]);\n}\n\nstatic int\nw_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    PyObject *u;\n    if (!PyArg_Parse(v, \"U;array item must be unicode character\", &u)) {\n        return -1;\n    }\n\n    if (PyUnicode_GetLength(u) != 1) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"array item must be unicode character\");\n        return -1;\n    }\n\n    if (i >= 0) {\n        ((Py_UCS4 *)ap->ob_item)[i] = PyUnicode_READ_CHAR(u, 0);\n    }\n    return 0;\n}\n\nstatic PyObject *\nh_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    return PyLong_FromLong((long) ((short *)ap->ob_item)[i]);\n}\n\n\nstatic int\nh_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    short x;\n    /* 'h' == signed short, maps to PyArg_Parse's 'h' formatter */\n    if (!PyArg_Parse(v, \"h;array item must be integer\", &x))\n        return -1;\n    if (i >= 0)\n                 ((short *)ap->ob_item)[i] = x;\n    return 0;\n}\n\nstatic PyObject *\nHH_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    return PyLong_FromLong((long) ((unsigned short *)ap->ob_item)[i]);\n}\n\nstatic int\nHH_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    int x;\n    /* PyArg_Parse's 'h' formatter is for a signed short, therefore\n       must use the next size up and manually do the overflow checking */\n    if (!PyArg_Parse(v, \"i;array item must be integer\", &x))\n        return -1;\n    else if (x < 0) {\n        PyErr_SetString(PyExc_OverflowError,\n            \"unsigned short is less than minimum\");\n        return -1;\n    }\n    else if (x > USHRT_MAX) {\n        PyErr_SetString(PyExc_OverflowError,\n            \"unsigned short is greater than maximum\");\n        return -1;\n    }\n    if (i >= 0)\n        ((short *)ap->ob_item)[i] = (short)x;\n    return 0;\n}\n\nstatic PyObject *\ni_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    return PyLong_FromLong((long) ((int *)ap->ob_item)[i]);\n}\n\nstatic int\ni_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    int x;\n    /* 'i' == signed int, maps to PyArg_Parse's 'i' formatter */\n    if (!PyArg_Parse(v, \"i;array item must be integer\", &x))\n        return -1;\n    if (i >= 0)\n                 ((int *)ap->ob_item)[i] = x;\n    return 0;\n}\n\nstatic PyObject *\nII_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    return PyLong_FromUnsignedLong(\n        (unsigned long) ((unsigned int *)ap->ob_item)[i]);\n}\n\nstatic int\nII_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    unsigned long x;\n    int do_decref = 0; /* if nb_int was called */\n\n    if (!PyLong_Check(v)) {\n        v = _PyNumber_Index(v);\n        if (NULL == v) {\n            return -1;\n        }\n        do_decref = 1;\n    }\n    x = PyLong_AsUnsignedLong(v);\n    if (x == (unsigned long)-1 && PyErr_Occurred()) {\n        if (do_decref) {\n            Py_DECREF(v);\n        }\n        return -1;\n    }\n    if (x > UINT_MAX) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"unsigned int is greater than maximum\");\n        if (do_decref) {\n            Py_DECREF(v);\n        }\n        return -1;\n    }\n    if (i >= 0)\n        ((unsigned int *)ap->ob_item)[i] = (unsigned int)x;\n\n    if (do_decref) {\n        Py_DECREF(v);\n    }\n    return 0;\n}\n\nstatic PyObject *\nl_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    return PyLong_FromLong(((long *)ap->ob_item)[i]);\n}\n\nstatic int\nl_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    long x;\n    if (!PyArg_Parse(v, \"l;array item must be integer\", &x))\n        return -1;\n    if (i >= 0)\n                 ((long *)ap->ob_item)[i] = x;\n    return 0;\n}\n\nstatic PyObject *\nLL_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    return PyLong_FromUnsignedLong(((unsigned long *)ap->ob_item)[i]);\n}\n\nstatic int\nLL_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    unsigned long x;\n    int do_decref = 0; /* if nb_int was called */\n\n    if (!PyLong_Check(v)) {\n        v = _PyNumber_Index(v);\n        if (NULL == v) {\n            return -1;\n        }\n        do_decref = 1;\n    }\n    x = PyLong_AsUnsignedLong(v);\n    if (x == (unsigned long)-1 && PyErr_Occurred()) {\n        if (do_decref) {\n            Py_DECREF(v);\n        }\n        return -1;\n    }\n    if (i >= 0)\n        ((unsigned long *)ap->ob_item)[i] = x;\n\n    if (do_decref) {\n        Py_DECREF(v);\n    }\n    return 0;\n}\n\nstatic PyObject *\nq_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    return PyLong_FromLongLong(((long long *)ap->ob_item)[i]);\n}\n\nstatic int\nq_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    long long x;\n    if (!PyArg_Parse(v, \"L;array item must be integer\", &x))\n        return -1;\n    if (i >= 0)\n        ((long long *)ap->ob_item)[i] = x;\n    return 0;\n}\n\nstatic PyObject *\nQQ_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    return PyLong_FromUnsignedLongLong(\n        ((unsigned long long *)ap->ob_item)[i]);\n}\n\nstatic int\nQQ_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    unsigned long long x;\n    int do_decref = 0; /* if nb_int was called */\n\n    if (!PyLong_Check(v)) {\n        v = _PyNumber_Index(v);\n        if (NULL == v) {\n            return -1;\n        }\n        do_decref = 1;\n    }\n    x = PyLong_AsUnsignedLongLong(v);\n    if (x == (unsigned long long)-1 && PyErr_Occurred()) {\n        if (do_decref) {\n            Py_DECREF(v);\n        }\n        return -1;\n    }\n    if (i >= 0)\n        ((unsigned long long *)ap->ob_item)[i] = x;\n\n    if (do_decref) {\n        Py_DECREF(v);\n    }\n    return 0;\n}\n\nstatic PyObject *\nf_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    return PyFloat_FromDouble((double) ((float *)ap->ob_item)[i]);\n}\n\nstatic int\nf_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    float x;\n    if (!PyArg_Parse(v, \"f;array item must be float\", &x))\n        return -1;\n    if (i >= 0)\n                 ((float *)ap->ob_item)[i] = x;\n    return 0;\n}\n\nstatic PyObject *\nd_getitem(arrayobject *ap, Py_ssize_t i)\n{\n    return PyFloat_FromDouble(((double *)ap->ob_item)[i]);\n}\n\nstatic int\nd_setitem(arrayobject *ap, Py_ssize_t i, PyObject *v)\n{\n    double x;\n    if (!PyArg_Parse(v, \"d;array item must be float\", &x))\n        return -1;\n    if (i >= 0)\n                 ((double *)ap->ob_item)[i] = x;\n    return 0;\n}\n\n#define DEFINE_COMPAREITEMS(code, type) \\\n    static int \\\n    code##_compareitems(const void *lhs, const void *rhs, Py_ssize_t length) \\\n    { \\\n        const type *a = lhs, *b = rhs; \\\n        for (Py_ssize_t i = 0; i < length; ++i) \\\n            if (a[i] != b[i]) \\\n                return a[i] < b[i] ? -1 : 1; \\\n        return 0; \\\n    }\n\nDEFINE_COMPAREITEMS(b, signed char)\nDEFINE_COMPAREITEMS(BB, unsigned char)\nDEFINE_COMPAREITEMS(u, wchar_t)\nDEFINE_COMPAREITEMS(w, Py_UCS4)\nDEFINE_COMPAREITEMS(h, short)\nDEFINE_COMPAREITEMS(HH, unsigned short)\nDEFINE_COMPAREITEMS(i, int)\nDEFINE_COMPAREITEMS(II, unsigned int)\nDEFINE_COMPAREITEMS(l, long)\nDEFINE_COMPAREITEMS(LL, unsigned long)\nDEFINE_COMPAREITEMS(q, long long)\nDEFINE_COMPAREITEMS(QQ, unsigned long long)\n\n/* Description of types.\n *\n * Don't forget to update typecode_to_mformat_code() if you add a new\n * typecode.\n */\nstatic const struct arraydescr descriptors[] = {\n    {'b', 1, b_getitem, b_setitem, b_compareitems, \"b\", 1, 1},\n    {'B', 1, BB_getitem, BB_setitem, BB_compareitems, \"B\", 1, 0},\n    {'u', sizeof(wchar_t), u_getitem, u_setitem, u_compareitems, \"u\", 0, 0},\n    {'w', sizeof(Py_UCS4), w_getitem, w_setitem, w_compareitems, \"w\", 0, 0,},\n    {'h', sizeof(short), h_getitem, h_setitem, h_compareitems, \"h\", 1, 1},\n    {'H', sizeof(short), HH_getitem, HH_setitem, HH_compareitems, \"H\", 1, 0},\n    {'i', sizeof(int), i_getitem, i_setitem, i_compareitems, \"i\", 1, 1},\n    {'I', sizeof(int), II_getitem, II_setitem, II_compareitems, \"I\", 1, 0},\n    {'l', sizeof(long), l_getitem, l_setitem, l_compareitems, \"l\", 1, 1},\n    {'L', sizeof(long), LL_getitem, LL_setitem, LL_compareitems, \"L\", 1, 0},\n    {'q', sizeof(long long), q_getitem, q_setitem, q_compareitems, \"q\", 1, 1},\n    {'Q', sizeof(long long), QQ_getitem, QQ_setitem, QQ_compareitems, \"Q\", 1, 0},\n    {'f', sizeof(float), f_getitem, f_setitem, NULL, \"f\", 0, 0},\n    {'d', sizeof(double), d_getitem, d_setitem, NULL, \"d\", 0, 0},\n    {'\\0', 0, 0, 0, 0, 0, 0} /* Sentinel */\n};\n\n/****************************************************************************\nImplementations of array object methods.\n****************************************************************************/\n/*[clinic input]\nclass array.array \"arrayobject *\" \"ArrayType\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=a5c29edf59f176a3]*/\n\nstatic PyObject *\nnewarrayobject(PyTypeObject *type, Py_ssize_t size, const struct arraydescr *descr)\n{\n    arrayobject *op;\n    size_t nbytes;\n\n    if (size < 0) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n\n    /* Check for overflow */\n    if (size > PY_SSIZE_T_MAX / descr->itemsize) {\n        return PyErr_NoMemory();\n    }\n    nbytes = size * descr->itemsize;\n    op = (arrayobject *) type->tp_alloc(type, 0);\n    if (op == NULL) {\n        return NULL;\n    }\n    op->ob_descr = descr;\n    op->allocated = size;\n    op->weakreflist = NULL;\n    Py_SET_SIZE(op, size);\n    if (size <= 0) {\n        op->ob_item = NULL;\n    }\n    else {\n        op->ob_item = PyMem_NEW(char, nbytes);\n        if (op->ob_item == NULL) {\n            Py_DECREF(op);\n            return PyErr_NoMemory();\n        }\n    }\n    op->ob_exports = 0;\n    return (PyObject *) op;\n}\n\nstatic PyObject *\ngetarrayitem(PyObject *op, Py_ssize_t i)\n{\n#ifndef NDEBUG\n    array_state *state = find_array_state_by_type(Py_TYPE(op));\n    assert(array_Check(op, state));\n#endif\n    arrayobject *ap;\n    ap = (arrayobject *)op;\n    assert(i>=0 && i<Py_SIZE(ap));\n    return (*ap->ob_descr->getitem)(ap, i);\n}\n\nstatic int\nins1(arrayobject *self, Py_ssize_t where, PyObject *v)\n{\n    char *items;\n    Py_ssize_t n = Py_SIZE(self);\n    if (v == NULL) {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    if ((*self->ob_descr->setitem)(self, -1, v) < 0)\n        return -1;\n\n    if (array_resize(self, n+1) == -1)\n        return -1;\n    items = self->ob_item;\n    if (where < 0) {\n        where += n;\n        if (where < 0)\n            where = 0;\n    }\n    if (where > n)\n        where = n;\n    /* appends don't need to call memmove() */\n    if (where != n)\n        memmove(items + (where+1)*self->ob_descr->itemsize,\n            items + where*self->ob_descr->itemsize,\n            (n-where)*self->ob_descr->itemsize);\n    return (*self->ob_descr->setitem)(self, where, v);\n}\n\n/* Methods */\n\nstatic int\narray_tp_traverse(arrayobject *op, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(op));\n    return 0;\n}\n\nstatic void\narray_dealloc(arrayobject *op)\n{\n    PyTypeObject *tp = Py_TYPE(op);\n    PyObject_GC_UnTrack(op);\n\n    if (op->weakreflist != NULL)\n        PyObject_ClearWeakRefs((PyObject *) op);\n    if (op->ob_item != NULL)\n        PyMem_Free(op->ob_item);\n    tp->tp_free(op);\n    Py_DECREF(tp);\n}\n\nstatic PyObject *\narray_richcompare(PyObject *v, PyObject *w, int op)\n{\n    array_state *state = find_array_state_by_type(Py_TYPE(v));\n    arrayobject *va, *wa;\n    PyObject *vi = NULL;\n    PyObject *wi = NULL;\n    Py_ssize_t i, k;\n    PyObject *res;\n\n    if (!array_Check(v, state) || !array_Check(w, state))\n        Py_RETURN_NOTIMPLEMENTED;\n\n    va = (arrayobject *)v;\n    wa = (arrayobject *)w;\n\n    if (Py_SIZE(va) != Py_SIZE(wa) && (op == Py_EQ || op == Py_NE)) {\n        /* Shortcut: if the lengths differ, the arrays differ */\n        if (op == Py_EQ)\n            res = Py_False;\n        else\n            res = Py_True;\n        return Py_NewRef(res);\n    }\n\n    if (va->ob_descr == wa->ob_descr && va->ob_descr->compareitems != NULL) {\n        /* Fast path:\n           arrays with same types can have their buffers compared directly */\n        Py_ssize_t common_length = Py_MIN(Py_SIZE(va), Py_SIZE(wa));\n        int result = va->ob_descr->compareitems(va->ob_item, wa->ob_item,\n                                                common_length);\n        if (result == 0)\n            goto compare_sizes;\n\n        int cmp;\n        switch (op) {\n        case Py_LT: cmp = result < 0; break;\n        case Py_LE: cmp = result <= 0; break;\n        case Py_EQ: cmp = result == 0; break;\n        case Py_NE: cmp = result != 0; break;\n        case Py_GT: cmp = result > 0; break;\n        case Py_GE: cmp = result >= 0; break;\n        default: return NULL; /* cannot happen */\n        }\n        PyObject *res = cmp ? Py_True : Py_False;\n        return Py_NewRef(res);\n    }\n\n\n    /* Search for the first index where items are different */\n    k = 1;\n    for (i = 0; i < Py_SIZE(va) && i < Py_SIZE(wa); i++) {\n        vi = getarrayitem(v, i);\n        if (vi == NULL) {\n            return NULL;\n        }\n        wi = getarrayitem(w, i);\n        if (wi == NULL) {\n            Py_DECREF(vi);\n            return NULL;\n        }\n        k = PyObject_RichCompareBool(vi, wi, Py_EQ);\n        if (k == 0)\n            break; /* Keeping vi and wi alive! */\n        Py_DECREF(vi);\n        Py_DECREF(wi);\n        if (k < 0)\n            return NULL;\n    }\n\n    if (k) {\n        /* No more items to compare -- compare sizes */\n        compare_sizes: ;\n        Py_ssize_t vs = Py_SIZE(va);\n        Py_ssize_t ws = Py_SIZE(wa);\n        int cmp;\n        switch (op) {\n        case Py_LT: cmp = vs <  ws; break;\n        case Py_LE: cmp = vs <= ws; break;\n        /* If the lengths were not equal,\n           the earlier fast-path check would have caught that. */\n        case Py_EQ: assert(vs == ws); cmp = 1; break;\n        case Py_NE: assert(vs == ws); cmp = 0; break;\n        case Py_GT: cmp = vs >  ws; break;\n        case Py_GE: cmp = vs >= ws; break;\n        default: return NULL; /* cannot happen */\n        }\n        if (cmp)\n            res = Py_True;\n        else\n            res = Py_False;\n        return Py_NewRef(res);\n    }\n\n    /* We have an item that differs.  First, shortcuts for EQ/NE */\n    if (op == Py_EQ) {\n        res = Py_NewRef(Py_False);\n    }\n    else if (op == Py_NE) {\n        res = Py_NewRef(Py_True);\n    }\n    else {\n        /* Compare the final item again using the proper operator */\n        res = PyObject_RichCompare(vi, wi, op);\n    }\n    Py_DECREF(vi);\n    Py_DECREF(wi);\n    return res;\n}\n\nstatic Py_ssize_t\narray_length(arrayobject *a)\n{\n    return Py_SIZE(a);\n}\n\nstatic PyObject *\narray_item(arrayobject *a, Py_ssize_t i)\n{\n    if (i < 0 || i >= Py_SIZE(a)) {\n        PyErr_SetString(PyExc_IndexError, \"array index out of range\");\n        return NULL;\n    }\n    return getarrayitem((PyObject *)a, i);\n}\n\nstatic PyObject *\narray_slice(arrayobject *a, Py_ssize_t ilow, Py_ssize_t ihigh)\n{\n    array_state *state = find_array_state_by_type(Py_TYPE(a));\n    arrayobject *np;\n\n    if (ilow < 0)\n        ilow = 0;\n    else if (ilow > Py_SIZE(a))\n        ilow = Py_SIZE(a);\n    if (ihigh < 0)\n        ihigh = 0;\n    if (ihigh < ilow)\n        ihigh = ilow;\n    else if (ihigh > Py_SIZE(a))\n        ihigh = Py_SIZE(a);\n    np = (arrayobject *) newarrayobject(state->ArrayType, ihigh - ilow, a->ob_descr);\n    if (np == NULL)\n        return NULL;\n    if (ihigh > ilow) {\n        memcpy(np->ob_item, a->ob_item + ilow * a->ob_descr->itemsize,\n               (ihigh-ilow) * a->ob_descr->itemsize);\n    }\n    return (PyObject *)np;\n}\n\n/*[clinic input]\narray.array.clear\n\nRemove all items from the array.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_clear_impl(arrayobject *self)\n/*[clinic end generated code: output=5efe0417062210a9 input=5dffa30e94e717a4]*/\n{\n    if (array_resize(self, 0) == -1) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\narray.array.__copy__\n\nReturn a copy of the array.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array___copy___impl(arrayobject *self)\n/*[clinic end generated code: output=dec7c3f925d9619e input=ad1ee5b086965f09]*/\n{\n    return array_slice(self, 0, Py_SIZE(self));\n}\n\n/*[clinic input]\narray.array.__deepcopy__\n\n    unused: object\n    /\n\nReturn a copy of the array.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array___deepcopy__(arrayobject *self, PyObject *unused)\n/*[clinic end generated code: output=1ec748d8e14a9faa input=2405ecb4933748c4]*/\n{\n    return array_array___copy___impl(self);\n}\n\nstatic PyObject *\narray_concat(arrayobject *a, PyObject *bb)\n{\n    array_state *state = find_array_state_by_type(Py_TYPE(a));\n    Py_ssize_t size;\n    arrayobject *np;\n    if (!array_Check(bb, state)) {\n        PyErr_Format(PyExc_TypeError,\n             \"can only append array (not \\\"%.200s\\\") to array\",\n                 Py_TYPE(bb)->tp_name);\n        return NULL;\n    }\n#define b ((arrayobject *)bb)\n    if (a->ob_descr != b->ob_descr) {\n        PyErr_BadArgument();\n        return NULL;\n    }\n    if (Py_SIZE(a) > PY_SSIZE_T_MAX - Py_SIZE(b)) {\n        return PyErr_NoMemory();\n    }\n    size = Py_SIZE(a) + Py_SIZE(b);\n    np = (arrayobject *) newarrayobject(state->ArrayType, size, a->ob_descr);\n    if (np == NULL) {\n        return NULL;\n    }\n    if (Py_SIZE(a) > 0) {\n        memcpy(np->ob_item, a->ob_item, Py_SIZE(a)*a->ob_descr->itemsize);\n    }\n    if (Py_SIZE(b) > 0) {\n        memcpy(np->ob_item + Py_SIZE(a)*a->ob_descr->itemsize,\n               b->ob_item, Py_SIZE(b)*b->ob_descr->itemsize);\n    }\n    return (PyObject *)np;\n#undef b\n}\n\nstatic PyObject *\narray_repeat(arrayobject *a, Py_ssize_t n)\n{\n    array_state *state = find_array_state_by_type(Py_TYPE(a));\n\n    if (n < 0)\n        n = 0;\n    const Py_ssize_t array_length = Py_SIZE(a);\n    if ((array_length != 0) && (n > PY_SSIZE_T_MAX / array_length)) {\n        return PyErr_NoMemory();\n    }\n    Py_ssize_t size = array_length * n;\n    arrayobject* np = (arrayobject *) newarrayobject(state->ArrayType, size, a->ob_descr);\n    if (np == NULL)\n        return NULL;\n    if (size == 0)\n        return (PyObject *)np;\n\n    const Py_ssize_t oldbytes = array_length * a->ob_descr->itemsize;\n    const Py_ssize_t newbytes = oldbytes * n;\n    _PyBytes_Repeat(np->ob_item, newbytes, a->ob_item, oldbytes);\n\n    return (PyObject *)np;\n}\n\nstatic int\narray_del_slice(arrayobject *a, Py_ssize_t ilow, Py_ssize_t ihigh)\n{\n    char *item;\n    Py_ssize_t d; /* Change in size */\n    if (ilow < 0)\n        ilow = 0;\n    else if (ilow > Py_SIZE(a))\n        ilow = Py_SIZE(a);\n    if (ihigh < 0)\n        ihigh = 0;\n    if (ihigh < ilow)\n        ihigh = ilow;\n    else if (ihigh > Py_SIZE(a))\n        ihigh = Py_SIZE(a);\n    item = a->ob_item;\n    d = ihigh-ilow;\n    /* Issue #4509: If the array has exported buffers and the slice\n       assignment would change the size of the array, fail early to make\n       sure we don't modify it. */\n    if (d != 0 && a->ob_exports > 0) {\n        PyErr_SetString(PyExc_BufferError,\n            \"cannot resize an array that is exporting buffers\");\n        return -1;\n    }\n    if (d > 0) { /* Delete d items */\n        memmove(item + (ihigh-d)*a->ob_descr->itemsize,\n            item + ihigh*a->ob_descr->itemsize,\n            (Py_SIZE(a)-ihigh)*a->ob_descr->itemsize);\n        if (array_resize(a, Py_SIZE(a) - d) == -1)\n            return -1;\n    }\n    return 0;\n}\n\nstatic int\narray_ass_item(arrayobject *a, Py_ssize_t i, PyObject *v)\n{\n    if (i < 0 || i >= Py_SIZE(a)) {\n        PyErr_SetString(PyExc_IndexError,\n                         \"array assignment index out of range\");\n        return -1;\n    }\n    if (v == NULL)\n        return array_del_slice(a, i, i+1);\n    return (*a->ob_descr->setitem)(a, i, v);\n}\n\nstatic int\nsetarrayitem(PyObject *a, Py_ssize_t i, PyObject *v)\n{\n#ifndef NDEBUG\n    array_state *state = find_array_state_by_type(Py_TYPE(a));\n    assert(array_Check(a, state));\n#endif\n    return array_ass_item((arrayobject *)a, i, v);\n}\n\nstatic int\narray_iter_extend(arrayobject *self, PyObject *bb)\n{\n    PyObject *it, *v;\n\n    it = PyObject_GetIter(bb);\n    if (it == NULL)\n        return -1;\n\n    while ((v = PyIter_Next(it)) != NULL) {\n        if (ins1(self, Py_SIZE(self), v) != 0) {\n            Py_DECREF(v);\n            Py_DECREF(it);\n            return -1;\n        }\n        Py_DECREF(v);\n    }\n    Py_DECREF(it);\n    if (PyErr_Occurred())\n        return -1;\n    return 0;\n}\n\nstatic int\narray_do_extend(array_state *state, arrayobject *self, PyObject *bb)\n{\n    Py_ssize_t size, oldsize, bbsize;\n\n    if (!array_Check(bb, state))\n        return array_iter_extend(self, bb);\n#define b ((arrayobject *)bb)\n    if (self->ob_descr != b->ob_descr) {\n        PyErr_SetString(PyExc_TypeError,\n                     \"can only extend with array of same kind\");\n        return -1;\n    }\n    if ((Py_SIZE(self) > PY_SSIZE_T_MAX - Py_SIZE(b)) ||\n        ((Py_SIZE(self) + Py_SIZE(b)) > PY_SSIZE_T_MAX / self->ob_descr->itemsize)) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    oldsize = Py_SIZE(self);\n    /* Get the size of bb before resizing the array since bb could be self. */\n    bbsize = Py_SIZE(bb);\n    size = oldsize + Py_SIZE(b);\n    if (array_resize(self, size) == -1)\n        return -1;\n    if (bbsize > 0) {\n        memcpy(self->ob_item + oldsize * self->ob_descr->itemsize,\n            b->ob_item, bbsize * b->ob_descr->itemsize);\n    }\n\n    return 0;\n#undef b\n}\n\nstatic PyObject *\narray_inplace_concat(arrayobject *self, PyObject *bb)\n{\n    array_state *state = find_array_state_by_type(Py_TYPE(self));\n\n    if (!array_Check(bb, state)) {\n        PyErr_Format(PyExc_TypeError,\n            \"can only extend array with array (not \\\"%.200s\\\")\",\n            Py_TYPE(bb)->tp_name);\n        return NULL;\n    }\n    if (array_do_extend(state, self, bb) == -1)\n        return NULL;\n    return Py_NewRef(self);\n}\n\nstatic PyObject *\narray_inplace_repeat(arrayobject *self, Py_ssize_t n)\n{\n    const Py_ssize_t array_size = Py_SIZE(self);\n\n    if (array_size > 0 && n != 1 ) {\n        if (n < 0)\n            n = 0;\n        if ((self->ob_descr->itemsize != 0) &&\n            (array_size > PY_SSIZE_T_MAX / self->ob_descr->itemsize)) {\n            return PyErr_NoMemory();\n        }\n        Py_ssize_t size = array_size * self->ob_descr->itemsize;\n        if (n > 0 && size > PY_SSIZE_T_MAX / n) {\n            return PyErr_NoMemory();\n        }\n        if (array_resize(self, n * array_size) == -1)\n            return NULL;\n\n        _PyBytes_Repeat(self->ob_item, n*size, self->ob_item, size);\n    }\n    return Py_NewRef(self);\n}\n\n\nstatic PyObject *\nins(arrayobject *self, Py_ssize_t where, PyObject *v)\n{\n    if (ins1(self, where, v) != 0)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\narray.array.count\n\n    v: object\n    /\n\nReturn number of occurrences of v in the array.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_count(arrayobject *self, PyObject *v)\n/*[clinic end generated code: output=3dd3624bf7135a3a input=d9bce9d65e39d1f5]*/\n{\n    Py_ssize_t count = 0;\n    Py_ssize_t i;\n\n    for (i = 0; i < Py_SIZE(self); i++) {\n        PyObject *selfi;\n        int cmp;\n\n        selfi = getarrayitem((PyObject *)self, i);\n        if (selfi == NULL)\n            return NULL;\n        cmp = PyObject_RichCompareBool(selfi, v, Py_EQ);\n        Py_DECREF(selfi);\n        if (cmp > 0)\n            count++;\n        else if (cmp < 0)\n            return NULL;\n    }\n    return PyLong_FromSsize_t(count);\n}\n\n\n/*[clinic input]\narray.array.index\n\n    v: object\n    start: slice_index(accept={int}) = 0\n    stop: slice_index(accept={int}, c_default=\"PY_SSIZE_T_MAX\") = sys.maxsize\n    /\n\nReturn index of first occurrence of v in the array.\n\nRaise ValueError if the value is not present.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_index_impl(arrayobject *self, PyObject *v, Py_ssize_t start,\n                       Py_ssize_t stop)\n/*[clinic end generated code: output=c45e777880c99f52 input=089dff7baa7e5a7e]*/\n{\n    if (start < 0) {\n        start += Py_SIZE(self);\n        if (start < 0) {\n            start = 0;\n        }\n    }\n    if (stop < 0) {\n        stop += Py_SIZE(self);\n    }\n    // Use Py_SIZE() for every iteration in case the array is mutated\n    // during PyObject_RichCompareBool()\n    for (Py_ssize_t i = start; i < stop && i < Py_SIZE(self); i++) {\n        PyObject *selfi;\n        int cmp;\n\n        selfi = getarrayitem((PyObject *)self, i);\n        if (selfi == NULL)\n            return NULL;\n        cmp = PyObject_RichCompareBool(selfi, v, Py_EQ);\n        Py_DECREF(selfi);\n        if (cmp > 0) {\n            return PyLong_FromSsize_t(i);\n        }\n        else if (cmp < 0)\n            return NULL;\n    }\n    PyErr_SetString(PyExc_ValueError, \"array.index(x): x not in array\");\n    return NULL;\n}\n\nstatic int\narray_contains(arrayobject *self, PyObject *v)\n{\n    Py_ssize_t i;\n    int cmp;\n\n    for (i = 0, cmp = 0 ; cmp == 0 && i < Py_SIZE(self); i++) {\n        PyObject *selfi = getarrayitem((PyObject *)self, i);\n        if (selfi == NULL)\n            return -1;\n        cmp = PyObject_RichCompareBool(selfi, v, Py_EQ);\n        Py_DECREF(selfi);\n    }\n    return cmp;\n}\n\n/*[clinic input]\narray.array.remove\n\n    v: object\n    /\n\nRemove the first occurrence of v in the array.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_remove(arrayobject *self, PyObject *v)\n/*[clinic end generated code: output=bef06be9fdf9dceb input=0b1e5aed25590027]*/\n{\n    Py_ssize_t i;\n\n    for (i = 0; i < Py_SIZE(self); i++) {\n        PyObject *selfi;\n        int cmp;\n\n        selfi = getarrayitem((PyObject *)self,i);\n        if (selfi == NULL)\n            return NULL;\n        cmp = PyObject_RichCompareBool(selfi, v, Py_EQ);\n        Py_DECREF(selfi);\n        if (cmp > 0) {\n            if (array_del_slice(self, i, i+1) != 0)\n                return NULL;\n            Py_RETURN_NONE;\n        }\n        else if (cmp < 0)\n            return NULL;\n    }\n    PyErr_SetString(PyExc_ValueError, \"array.remove(x): x not in array\");\n    return NULL;\n}\n\n/*[clinic input]\narray.array.pop\n\n    i: Py_ssize_t = -1\n    /\n\nReturn the i-th element and delete it from the array.\n\ni defaults to -1.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_pop_impl(arrayobject *self, Py_ssize_t i)\n/*[clinic end generated code: output=bc1f0c54fe5308e4 input=8e5feb4c1a11cd44]*/\n{\n    PyObject *v;\n\n    if (Py_SIZE(self) == 0) {\n        /* Special-case most common failure cause */\n        PyErr_SetString(PyExc_IndexError, \"pop from empty array\");\n        return NULL;\n    }\n    if (i < 0)\n        i += Py_SIZE(self);\n    if (i < 0 || i >= Py_SIZE(self)) {\n        PyErr_SetString(PyExc_IndexError, \"pop index out of range\");\n        return NULL;\n    }\n    v = getarrayitem((PyObject *)self, i);\n    if (v == NULL)\n        return NULL;\n    if (array_del_slice(self, i, i+1) != 0) {\n        Py_DECREF(v);\n        return NULL;\n    }\n    return v;\n}\n\n/*[clinic input]\narray.array.extend\n\n    cls: defining_class\n    bb: object\n    /\n\nAppend items to the end of the array.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_extend_impl(arrayobject *self, PyTypeObject *cls, PyObject *bb)\n/*[clinic end generated code: output=e65eb7588f0bc266 input=8eb6817ec4d2cb62]*/\n{\n    array_state *state = get_array_state_by_class(cls);\n\n    if (array_do_extend(state, self, bb) == -1)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\narray.array.insert\n\n    i: Py_ssize_t\n    v: object\n    /\n\nInsert a new item v into the array before position i.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_insert_impl(arrayobject *self, Py_ssize_t i, PyObject *v)\n/*[clinic end generated code: output=5a3648e278348564 input=5577d1b4383e9313]*/\n{\n    return ins(self, i, v);\n}\n\n/*[clinic input]\narray.array.buffer_info\n\nReturn a tuple (address, length) giving the current memory address and the length in items of the buffer used to hold array's contents.\n\nThe length should be multiplied by the itemsize attribute to calculate\nthe buffer length in bytes.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_buffer_info_impl(arrayobject *self)\n/*[clinic end generated code: output=9b2a4ec3ae7e98e7 input=a58bae5c6e1ac6a6]*/\n{\n    PyObject *retval = NULL, *v;\n\n    retval = PyTuple_New(2);\n    if (!retval)\n        return NULL;\n\n    v = PyLong_FromVoidPtr(self->ob_item);\n    if (v == NULL) {\n        Py_DECREF(retval);\n        return NULL;\n    }\n    PyTuple_SET_ITEM(retval, 0, v);\n\n    v = PyLong_FromSsize_t(Py_SIZE(self));\n    if (v == NULL) {\n        Py_DECREF(retval);\n        return NULL;\n    }\n    PyTuple_SET_ITEM(retval, 1, v);\n\n    return retval;\n}\n\n/*[clinic input]\narray.array.append\n\n    v: object\n    /\n\nAppend new value v to the end of the array.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_append(arrayobject *self, PyObject *v)\n/*[clinic end generated code: output=745a0669bf8db0e2 input=0b98d9d78e78f0fa]*/\n{\n    return ins(self, Py_SIZE(self), v);\n}\n\n/*[clinic input]\narray.array.byteswap\n\nByteswap all items of the array.\n\nIf the items in the array are not 1, 2, 4, or 8 bytes in size, RuntimeError is\nraised.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_byteswap_impl(arrayobject *self)\n/*[clinic end generated code: output=5f8236cbdf0d90b5 input=6a85591b950a0186]*/\n{\n    char *p;\n    Py_ssize_t i;\n\n    switch (self->ob_descr->itemsize) {\n    case 1:\n        break;\n    case 2:\n        for (p = self->ob_item, i = Py_SIZE(self); --i >= 0; p += 2) {\n            char p0 = p[0];\n            p[0] = p[1];\n            p[1] = p0;\n        }\n        break;\n    case 4:\n        for (p = self->ob_item, i = Py_SIZE(self); --i >= 0; p += 4) {\n            char p0 = p[0];\n            char p1 = p[1];\n            p[0] = p[3];\n            p[1] = p[2];\n            p[2] = p1;\n            p[3] = p0;\n        }\n        break;\n    case 8:\n        for (p = self->ob_item, i = Py_SIZE(self); --i >= 0; p += 8) {\n            char p0 = p[0];\n            char p1 = p[1];\n            char p2 = p[2];\n            char p3 = p[3];\n            p[0] = p[7];\n            p[1] = p[6];\n            p[2] = p[5];\n            p[3] = p[4];\n            p[4] = p3;\n            p[5] = p2;\n            p[6] = p1;\n            p[7] = p0;\n        }\n        break;\n    default:\n        PyErr_SetString(PyExc_RuntimeError,\n                   \"don't know how to byteswap this array type\");\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\narray.array.reverse\n\nReverse the order of the items in the array.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_reverse_impl(arrayobject *self)\n/*[clinic end generated code: output=c04868b36f6f4089 input=cd904f01b27d966a]*/\n{\n    Py_ssize_t itemsize = self->ob_descr->itemsize;\n    char *p, *q;\n    /* little buffer to hold items while swapping */\n    char tmp[256];      /* 8 is probably enough -- but why skimp */\n    assert((size_t)itemsize <= sizeof(tmp));\n\n    if (Py_SIZE(self) > 1) {\n        for (p = self->ob_item,\n             q = self->ob_item + (Py_SIZE(self) - 1)*itemsize;\n             p < q;\n             p += itemsize, q -= itemsize) {\n            /* memory areas guaranteed disjoint, so memcpy\n             * is safe (& memmove may be slower).\n             */\n            memcpy(tmp, p, itemsize);\n            memcpy(p, q, itemsize);\n            memcpy(q, tmp, itemsize);\n        }\n    }\n\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\narray.array.fromfile\n\n    cls: defining_class\n    f: object\n    n: Py_ssize_t\n    /\n\nRead n objects from the file object f and append them to the end of the array.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_fromfile_impl(arrayobject *self, PyTypeObject *cls, PyObject *f,\n                          Py_ssize_t n)\n/*[clinic end generated code: output=83a667080b345ebc input=3822e907c1c11f1a]*/\n{\n    PyObject *b, *res;\n    Py_ssize_t itemsize = self->ob_descr->itemsize;\n    Py_ssize_t nbytes;\n    int not_enough_bytes;\n\n    if (n < 0) {\n        PyErr_SetString(PyExc_ValueError, \"negative count\");\n        return NULL;\n    }\n    if (n > PY_SSIZE_T_MAX / itemsize) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n\n    array_state *state = get_array_state_by_class(cls);\n    assert(state != NULL);\n\n    nbytes = n * itemsize;\n\n    b = _PyObject_CallMethod(f, state->str_read, \"n\", nbytes);\n    if (b == NULL)\n        return NULL;\n\n    if (!PyBytes_Check(b)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"read() didn't return bytes\");\n        Py_DECREF(b);\n        return NULL;\n    }\n\n    not_enough_bytes = (PyBytes_GET_SIZE(b) != nbytes);\n\n    res = array_array_frombytes(self, b);\n    Py_DECREF(b);\n    if (res == NULL)\n        return NULL;\n\n    if (not_enough_bytes) {\n        PyErr_SetString(PyExc_EOFError,\n                        \"read() didn't return enough bytes\");\n        Py_DECREF(res);\n        return NULL;\n    }\n\n    return res;\n}\n\n/*[clinic input]\narray.array.tofile\n\n    cls: defining_class\n    f: object\n    /\n\nWrite all items (as machine values) to the file object f.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_tofile_impl(arrayobject *self, PyTypeObject *cls, PyObject *f)\n/*[clinic end generated code: output=4560c628d9c18bc2 input=5a24da7a7b407b52]*/\n{\n    Py_ssize_t nbytes = Py_SIZE(self) * self->ob_descr->itemsize;\n    /* Write 64K blocks at a time */\n    /* XXX Make the block size settable */\n    int BLOCKSIZE = 64*1024;\n    Py_ssize_t nblocks = (nbytes + BLOCKSIZE - 1) / BLOCKSIZE;\n    Py_ssize_t i;\n\n    if (Py_SIZE(self) == 0)\n        goto done;\n\n\n    array_state *state = get_array_state_by_class(cls);\n    assert(state != NULL);\n\n    for (i = 0; i < nblocks; i++) {\n        char* ptr = self->ob_item + i*BLOCKSIZE;\n        Py_ssize_t size = BLOCKSIZE;\n        PyObject *bytes, *res;\n\n        if (i*BLOCKSIZE + size > nbytes)\n            size = nbytes - i*BLOCKSIZE;\n        bytes = PyBytes_FromStringAndSize(ptr, size);\n        if (bytes == NULL)\n            return NULL;\n        res = PyObject_CallMethodOneArg(f, state->str_write, bytes);\n        Py_DECREF(bytes);\n        if (res == NULL)\n            return NULL;\n        Py_DECREF(res); /* drop write result */\n    }\n\n  done:\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\narray.array.fromlist\n\n    list: object\n    /\n\nAppend items to array from list.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_fromlist(arrayobject *self, PyObject *list)\n/*[clinic end generated code: output=26411c2d228a3e3f input=be2605a96c49680f]*/\n{\n    Py_ssize_t n;\n\n    if (!PyList_Check(list)) {\n        PyErr_SetString(PyExc_TypeError, \"arg must be list\");\n        return NULL;\n    }\n    n = PyList_Size(list);\n    if (n > 0) {\n        Py_ssize_t i, old_size;\n        old_size = Py_SIZE(self);\n        if (array_resize(self, old_size + n) == -1)\n            return NULL;\n        for (i = 0; i < n; i++) {\n            PyObject *v = PyList_GET_ITEM(list, i);\n            if ((*self->ob_descr->setitem)(self,\n                            Py_SIZE(self) - n + i, v) != 0) {\n                array_resize(self, old_size);\n                return NULL;\n            }\n            if (n != PyList_GET_SIZE(list)) {\n                PyErr_SetString(PyExc_RuntimeError,\n                                \"list changed size during iteration\");\n                array_resize(self, old_size);\n                return NULL;\n            }\n        }\n    }\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\narray.array.tolist\n\nConvert array to an ordinary list with the same items.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_tolist_impl(arrayobject *self)\n/*[clinic end generated code: output=00b60cc9eab8ef89 input=a8d7784a94f86b53]*/\n{\n    PyObject *list = PyList_New(Py_SIZE(self));\n    Py_ssize_t i;\n\n    if (list == NULL)\n        return NULL;\n    for (i = 0; i < Py_SIZE(self); i++) {\n        PyObject *v = getarrayitem((PyObject *)self, i);\n        if (v == NULL)\n            goto error;\n        PyList_SET_ITEM(list, i, v);\n    }\n    return list;\n\nerror:\n    Py_DECREF(list);\n    return NULL;\n}\n\nstatic PyObject *\nfrombytes(arrayobject *self, Py_buffer *buffer)\n{\n    int itemsize = self->ob_descr->itemsize;\n    Py_ssize_t n;\n    if (buffer->itemsize != 1) {\n        PyBuffer_Release(buffer);\n        PyErr_SetString(PyExc_TypeError, \"a bytes-like object is required\");\n        return NULL;\n    }\n    n = buffer->len;\n    if (n % itemsize != 0) {\n        PyBuffer_Release(buffer);\n        PyErr_SetString(PyExc_ValueError,\n                   \"bytes length not a multiple of item size\");\n        return NULL;\n    }\n    n = n / itemsize;\n    if (n > 0) {\n        Py_ssize_t old_size = Py_SIZE(self);\n        if ((n > PY_SSIZE_T_MAX - old_size) ||\n            ((old_size + n) > PY_SSIZE_T_MAX / itemsize)) {\n                PyBuffer_Release(buffer);\n                return PyErr_NoMemory();\n        }\n        if (array_resize(self, old_size + n) == -1) {\n            PyBuffer_Release(buffer);\n            return NULL;\n        }\n        memcpy(self->ob_item + old_size * itemsize,\n            buffer->buf, n * itemsize);\n    }\n    PyBuffer_Release(buffer);\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\narray.array.frombytes\n\n    buffer: Py_buffer\n    /\n\nAppends items from the string, interpreting it as an array of machine values, as if it had been read from a file using the fromfile() method.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_frombytes_impl(arrayobject *self, Py_buffer *buffer)\n/*[clinic end generated code: output=d9842c8f7510a516 input=378db226dfac949e]*/\n{\n    return frombytes(self, buffer);\n}\n\n/*[clinic input]\narray.array.tobytes\n\nConvert the array to an array of machine values and return the bytes representation.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_tobytes_impl(arrayobject *self)\n/*[clinic end generated code: output=87318e4edcdc2bb6 input=90ee495f96de34f5]*/\n{\n    if (Py_SIZE(self) <= PY_SSIZE_T_MAX / self->ob_descr->itemsize) {\n        return PyBytes_FromStringAndSize(self->ob_item,\n                            Py_SIZE(self) * self->ob_descr->itemsize);\n    } else {\n        return PyErr_NoMemory();\n    }\n}\n\n/*[clinic input]\narray.array.fromunicode\n\n    ustr: unicode\n    /\n\nExtends this array with data from the unicode string ustr.\n\nThe array must be a unicode type array; otherwise a ValueError is raised.\nUse array.frombytes(ustr.encode(...)) to append Unicode data to an array of\nsome other type.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_fromunicode_impl(arrayobject *self, PyObject *ustr)\n/*[clinic end generated code: output=24359f5e001a7f2b input=025db1fdade7a4ce]*/\n{\n    int typecode = self->ob_descr->typecode;\n    if (typecode != 'u' && typecode != 'w') {\n        PyErr_SetString(PyExc_ValueError,\n            \"fromunicode() may only be called on \"\n            \"unicode type arrays ('u' or 'w')\");\n        return NULL;\n    }\n\n    if (typecode == 'u') {\n        Py_ssize_t ustr_length = PyUnicode_AsWideChar(ustr, NULL, 0);\n        assert(ustr_length > 0);\n        if (ustr_length > 1) {\n            ustr_length--; /* trim trailing NUL character */\n            Py_ssize_t old_size = Py_SIZE(self);\n            if (array_resize(self, old_size + ustr_length) == -1) {\n                return NULL;\n            }\n\n            // must not fail\n            PyUnicode_AsWideChar(\n                ustr, ((wchar_t *)self->ob_item) + old_size, ustr_length);\n        }\n    }\n    else { // typecode == 'w'\n        Py_ssize_t ustr_length = PyUnicode_GetLength(ustr);\n        Py_ssize_t old_size = Py_SIZE(self);\n        Py_ssize_t new_size = old_size + ustr_length;\n\n        if (new_size < 0 || (size_t)new_size > PY_SSIZE_T_MAX / sizeof(Py_UCS4)) {\n            return PyErr_NoMemory();\n        }\n        if (array_resize(self, new_size) == -1) {\n            return NULL;\n        }\n\n        // must not fail\n        Py_UCS4 *u = PyUnicode_AsUCS4(ustr, ((Py_UCS4*)self->ob_item) + old_size,\n                                      ustr_length, 0);\n        assert(u != NULL);\n        (void)u; // Suppress unused_variable warning.\n    }\n\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\narray.array.tounicode\n\nExtends this array with data from the unicode string ustr.\n\nConvert the array to a unicode string.  The array must be a unicode type array;\notherwise a ValueError is raised.  Use array.tobytes().decode() to obtain a\nunicode string from an array of some other type.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array_tounicode_impl(arrayobject *self)\n/*[clinic end generated code: output=08e442378336e1ef input=127242eebe70b66d]*/\n{\n    int typecode = self->ob_descr->typecode;\n    if (typecode != 'u' && typecode != 'w') {\n        PyErr_SetString(PyExc_ValueError,\n             \"tounicode() may only be called on unicode type arrays ('u' or 'w')\");\n        return NULL;\n    }\n    if (typecode == 'u') {\n        return PyUnicode_FromWideChar((wchar_t *) self->ob_item, Py_SIZE(self));\n    }\n    else { // typecode == 'w'\n        int byteorder = 0; // native byteorder\n        return PyUnicode_DecodeUTF32((const char *) self->ob_item, Py_SIZE(self) * 4,\n                                     NULL, &byteorder);\n    }\n}\n\n/*[clinic input]\narray.array.__sizeof__\n\nSize of the array in memory, in bytes.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array___sizeof___impl(arrayobject *self)\n/*[clinic end generated code: output=d8e1c61ebbe3eaed input=805586565bf2b3c6]*/\n{\n    size_t res = _PyObject_SIZE(Py_TYPE(self));\n    res += (size_t)self->allocated * (size_t)self->ob_descr->itemsize;\n    return PyLong_FromSize_t(res);\n}\n\n\n/*********************** Pickling support ************************/\n\nstatic const struct mformatdescr {\n    size_t size;\n    int is_signed;\n    int is_big_endian;\n} mformat_descriptors[] = {\n    {1, 0, 0},                  /* 0: UNSIGNED_INT8 */\n    {1, 1, 0},                  /* 1: SIGNED_INT8 */\n    {2, 0, 0},                  /* 2: UNSIGNED_INT16_LE */\n    {2, 0, 1},                  /* 3: UNSIGNED_INT16_BE */\n    {2, 1, 0},                  /* 4: SIGNED_INT16_LE */\n    {2, 1, 1},                  /* 5: SIGNED_INT16_BE */\n    {4, 0, 0},                  /* 6: UNSIGNED_INT32_LE */\n    {4, 0, 1},                  /* 7: UNSIGNED_INT32_BE */\n    {4, 1, 0},                  /* 8: SIGNED_INT32_LE */\n    {4, 1, 1},                  /* 9: SIGNED_INT32_BE */\n    {8, 0, 0},                  /* 10: UNSIGNED_INT64_LE */\n    {8, 0, 1},                  /* 11: UNSIGNED_INT64_BE */\n    {8, 1, 0},                  /* 12: SIGNED_INT64_LE */\n    {8, 1, 1},                  /* 13: SIGNED_INT64_BE */\n    {4, 0, 0},                  /* 14: IEEE_754_FLOAT_LE */\n    {4, 0, 1},                  /* 15: IEEE_754_FLOAT_BE */\n    {8, 0, 0},                  /* 16: IEEE_754_DOUBLE_LE */\n    {8, 0, 1},                  /* 17: IEEE_754_DOUBLE_BE */\n    {4, 0, 0},                  /* 18: UTF16_LE */\n    {4, 0, 1},                  /* 19: UTF16_BE */\n    {8, 0, 0},                  /* 20: UTF32_LE */\n    {8, 0, 1}                   /* 21: UTF32_BE */\n};\n\n\n/*\n * Internal: This function is used to find the machine format of a given\n * array type code. This returns UNKNOWN_FORMAT when the machine format cannot\n * be found.\n */\nstatic enum machine_format_code\ntypecode_to_mformat_code(char typecode)\n{\n    const int is_big_endian = PY_BIG_ENDIAN;\n\n    size_t intsize;\n    int is_signed;\n\n    switch (typecode) {\n    case 'b':\n        return SIGNED_INT8;\n    case 'B':\n        return UNSIGNED_INT8;\n\n    case 'u':\n        if (sizeof(wchar_t) == 2) {\n            return UTF16_LE + is_big_endian;\n        }\n        if (sizeof(wchar_t) == 4) {\n            return UTF32_LE + is_big_endian;\n        }\n        return UNKNOWN_FORMAT;\n\n    case 'w':\n        return UTF32_LE + is_big_endian;\n\n    case 'f':\n        if (sizeof(float) == 4) {\n            const float y = 16711938.0;\n            if (memcmp(&y, \"\\x4b\\x7f\\x01\\x02\", 4) == 0)\n                return IEEE_754_FLOAT_BE;\n            if (memcmp(&y, \"\\x02\\x01\\x7f\\x4b\", 4) == 0)\n                return IEEE_754_FLOAT_LE;\n        }\n        return UNKNOWN_FORMAT;\n\n    case 'd':\n        if (sizeof(double) == 8) {\n            const double x = 9006104071832581.0;\n            if (memcmp(&x, \"\\x43\\x3f\\xff\\x01\\x02\\x03\\x04\\x05\", 8) == 0)\n                return IEEE_754_DOUBLE_BE;\n            if (memcmp(&x, \"\\x05\\x04\\x03\\x02\\x01\\xff\\x3f\\x43\", 8) == 0)\n                return IEEE_754_DOUBLE_LE;\n        }\n        return UNKNOWN_FORMAT;\n\n    /* Integers */\n    case 'h':\n        intsize = sizeof(short);\n        is_signed = 1;\n        break;\n    case 'H':\n        intsize = sizeof(short);\n        is_signed = 0;\n        break;\n    case 'i':\n        intsize = sizeof(int);\n        is_signed = 1;\n        break;\n    case 'I':\n        intsize = sizeof(int);\n        is_signed = 0;\n        break;\n    case 'l':\n        intsize = sizeof(long);\n        is_signed = 1;\n        break;\n    case 'L':\n        intsize = sizeof(long);\n        is_signed = 0;\n        break;\n    case 'q':\n        intsize = sizeof(long long);\n        is_signed = 1;\n        break;\n    case 'Q':\n        intsize = sizeof(long long);\n        is_signed = 0;\n        break;\n    default:\n        return UNKNOWN_FORMAT;\n    }\n    switch (intsize) {\n    case 2:\n        return UNSIGNED_INT16_LE + is_big_endian + (2 * is_signed);\n    case 4:\n        return UNSIGNED_INT32_LE + is_big_endian + (2 * is_signed);\n    case 8:\n        return UNSIGNED_INT64_LE + is_big_endian + (2 * is_signed);\n    default:\n        return UNKNOWN_FORMAT;\n    }\n}\n\n/* Forward declaration. */\nstatic PyObject *array_new(PyTypeObject *type, PyObject *args, PyObject *kwds);\n\n/*\n * Internal: This function wraps the array constructor--i.e., array_new()--to\n * allow the creation of array objects from C code without having to deal\n * directly the tuple argument of array_new(). The typecode argument is a\n * Unicode character value, like 'i' or 'f' for example, representing an array\n * type code. The items argument is a bytes or a list object from which\n * contains the initial value of the array.\n *\n * On success, this functions returns the array object created. Otherwise,\n * NULL is returned to indicate a failure.\n */\nstatic PyObject *\nmake_array(PyTypeObject *arraytype, char typecode, PyObject *items)\n{\n    PyObject *new_args;\n    PyObject *array_obj;\n    PyObject *typecode_obj;\n\n    assert(arraytype != NULL);\n    assert(items != NULL);\n\n    typecode_obj = PyUnicode_FromOrdinal(typecode);\n    if (typecode_obj == NULL)\n        return NULL;\n\n    new_args = PyTuple_New(2);\n    if (new_args == NULL) {\n        Py_DECREF(typecode_obj);\n        return NULL;\n    }\n    PyTuple_SET_ITEM(new_args, 0, typecode_obj);\n    PyTuple_SET_ITEM(new_args, 1, Py_NewRef(items));\n\n    array_obj = array_new(arraytype, new_args, NULL);\n    Py_DECREF(new_args);\n    if (array_obj == NULL)\n        return NULL;\n\n    return array_obj;\n}\n\n/*\n * This functions is a special constructor used when unpickling an array. It\n * provides a portable way to rebuild an array from its memory representation.\n */\n/*[clinic input]\narray._array_reconstructor\n\n    arraytype: object(type=\"PyTypeObject *\")\n    typecode: int(accept={str})\n    mformat_code: int(type=\"enum machine_format_code\")\n    items: object\n    /\n\nInternal. Used for pickling support.\n[clinic start generated code]*/\n\nstatic PyObject *\narray__array_reconstructor_impl(PyObject *module, PyTypeObject *arraytype,\n                                int typecode,\n                                enum machine_format_code mformat_code,\n                                PyObject *items)\n/*[clinic end generated code: output=e05263141ba28365 input=2464dc8f4c7736b5]*/\n{\n    array_state *state = get_array_state(module);\n    PyObject *converted_items;\n    PyObject *result;\n    const struct arraydescr *descr;\n\n    if (!PyType_Check(arraytype)) {\n        PyErr_Format(PyExc_TypeError,\n            \"first argument must be a type object, not %.200s\",\n            Py_TYPE(arraytype)->tp_name);\n        return NULL;\n    }\n    if (!PyType_IsSubtype(arraytype, state->ArrayType)) {\n        PyErr_Format(PyExc_TypeError,\n            \"%.200s is not a subtype of %.200s\",\n            arraytype->tp_name, state->ArrayType->tp_name);\n        return NULL;\n    }\n    for (descr = descriptors; descr->typecode != '\\0'; descr++) {\n        if ((int)descr->typecode == typecode)\n            break;\n    }\n    if (descr->typecode == '\\0') {\n        PyErr_SetString(PyExc_ValueError,\n                        \"second argument must be a valid type code\");\n        return NULL;\n    }\n    if (mformat_code < MACHINE_FORMAT_CODE_MIN ||\n        mformat_code > MACHINE_FORMAT_CODE_MAX) {\n        PyErr_SetString(PyExc_ValueError,\n            \"third argument must be a valid machine format code.\");\n        return NULL;\n    }\n    if (!PyBytes_Check(items)) {\n        PyErr_Format(PyExc_TypeError,\n            \"fourth argument should be bytes, not %.200s\",\n            Py_TYPE(items)->tp_name);\n        return NULL;\n    }\n\n    /* Fast path: No decoding has to be done. */\n    if (mformat_code == typecode_to_mformat_code((char)typecode) ||\n        mformat_code == UNKNOWN_FORMAT) {\n        return make_array(arraytype, (char)typecode, items);\n    }\n\n    /* Slow path: Decode the byte string according to the given machine\n     * format code. This occurs when the computer unpickling the array\n     * object is architecturally different from the one that pickled the\n     * array.\n     */\n    if (Py_SIZE(items) % mformat_descriptors[mformat_code].size != 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"string length not a multiple of item size\");\n        return NULL;\n    }\n    switch (mformat_code) {\n    case IEEE_754_FLOAT_LE:\n    case IEEE_754_FLOAT_BE: {\n        Py_ssize_t i;\n        int le = (mformat_code == IEEE_754_FLOAT_LE) ? 1 : 0;\n        Py_ssize_t itemcount = Py_SIZE(items) / 4;\n        const char *memstr = PyBytes_AS_STRING(items);\n\n        converted_items = PyList_New(itemcount);\n        if (converted_items == NULL)\n            return NULL;\n        for (i = 0; i < itemcount; i++) {\n            PyObject *pyfloat = PyFloat_FromDouble(\n                PyFloat_Unpack4(&memstr[i * 4], le));\n            if (pyfloat == NULL) {\n                Py_DECREF(converted_items);\n                return NULL;\n            }\n            PyList_SET_ITEM(converted_items, i, pyfloat);\n        }\n        break;\n    }\n    case IEEE_754_DOUBLE_LE:\n    case IEEE_754_DOUBLE_BE: {\n        Py_ssize_t i;\n        int le = (mformat_code == IEEE_754_DOUBLE_LE) ? 1 : 0;\n        Py_ssize_t itemcount = Py_SIZE(items) / 8;\n        const char *memstr = PyBytes_AS_STRING(items);\n\n        converted_items = PyList_New(itemcount);\n        if (converted_items == NULL)\n            return NULL;\n        for (i = 0; i < itemcount; i++) {\n            PyObject *pyfloat = PyFloat_FromDouble(\n                PyFloat_Unpack8(&memstr[i * 8], le));\n            if (pyfloat == NULL) {\n                Py_DECREF(converted_items);\n                return NULL;\n            }\n            PyList_SET_ITEM(converted_items, i, pyfloat);\n        }\n        break;\n    }\n    case UTF16_LE:\n    case UTF16_BE: {\n        int byteorder = (mformat_code == UTF16_LE) ? -1 : 1;\n        converted_items = PyUnicode_DecodeUTF16(\n            PyBytes_AS_STRING(items), Py_SIZE(items),\n            \"strict\", &byteorder);\n        if (converted_items == NULL)\n            return NULL;\n        break;\n    }\n    case UTF32_LE:\n    case UTF32_BE: {\n        int byteorder = (mformat_code == UTF32_LE) ? -1 : 1;\n        converted_items = PyUnicode_DecodeUTF32(\n            PyBytes_AS_STRING(items), Py_SIZE(items),\n            \"strict\", &byteorder);\n        if (converted_items == NULL)\n            return NULL;\n        break;\n    }\n\n    case UNSIGNED_INT8:\n    case SIGNED_INT8:\n    case UNSIGNED_INT16_LE:\n    case UNSIGNED_INT16_BE:\n    case SIGNED_INT16_LE:\n    case SIGNED_INT16_BE:\n    case UNSIGNED_INT32_LE:\n    case UNSIGNED_INT32_BE:\n    case SIGNED_INT32_LE:\n    case SIGNED_INT32_BE:\n    case UNSIGNED_INT64_LE:\n    case UNSIGNED_INT64_BE:\n    case SIGNED_INT64_LE:\n    case SIGNED_INT64_BE: {\n        Py_ssize_t i;\n        const struct mformatdescr mf_descr =\n            mformat_descriptors[mformat_code];\n        Py_ssize_t itemcount = Py_SIZE(items) / mf_descr.size;\n        const unsigned char *memstr =\n            (unsigned char *)PyBytes_AS_STRING(items);\n        const struct arraydescr *descr;\n\n        /* If possible, try to pack array's items using a data type\n         * that fits better. This may result in an array with narrower\n         * or wider elements.\n         *\n         * For example, if a 32-bit machine pickles an L-code array of\n         * unsigned longs, then the array will be unpickled by 64-bit\n         * machine as an I-code array of unsigned ints.\n         *\n         * XXX: Is it possible to write a unit test for this?\n         */\n        for (descr = descriptors; descr->typecode != '\\0'; descr++) {\n            if (descr->is_integer_type &&\n                (size_t)descr->itemsize == mf_descr.size &&\n                descr->is_signed == mf_descr.is_signed)\n                typecode = descr->typecode;\n        }\n\n        converted_items = PyList_New(itemcount);\n        if (converted_items == NULL)\n            return NULL;\n        for (i = 0; i < itemcount; i++) {\n            PyObject *pylong;\n\n            pylong = _PyLong_FromByteArray(\n                &memstr[i * mf_descr.size],\n                mf_descr.size,\n                !mf_descr.is_big_endian,\n                mf_descr.is_signed);\n            if (pylong == NULL) {\n                Py_DECREF(converted_items);\n                return NULL;\n            }\n            PyList_SET_ITEM(converted_items, i, pylong);\n        }\n        break;\n    }\n    case UNKNOWN_FORMAT:\n        /* Impossible, but needed to shut up GCC about the unhandled\n         * enumeration value.\n         */\n    default:\n        PyErr_BadArgument();\n        return NULL;\n    }\n\n    result = make_array(arraytype, (char)typecode, converted_items);\n    Py_DECREF(converted_items);\n    return result;\n}\n\n/*[clinic input]\narray.array.__reduce_ex__\n\n    cls: defining_class\n    value: object\n    /\n\nReturn state information for pickling.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_array___reduce_ex___impl(arrayobject *self, PyTypeObject *cls,\n                               PyObject *value)\n/*[clinic end generated code: output=4958ee5d79452ad5 input=19968cf0f91d3eea]*/\n{\n    PyObject *dict;\n    PyObject *result;\n    PyObject *array_str;\n    int typecode = self->ob_descr->typecode;\n    int mformat_code;\n    long protocol;\n\n    array_state *state = get_array_state_by_class(cls);\n    assert(state != NULL);\n\n    if (state->array_reconstructor == NULL) {\n        state->array_reconstructor = _PyImport_GetModuleAttrString(\n                \"array\", \"_array_reconstructor\");\n        if (state->array_reconstructor == NULL) {\n            return NULL;\n        }\n    }\n\n    if (!PyLong_Check(value)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"__reduce_ex__ argument should be an integer\");\n        return NULL;\n    }\n    protocol = PyLong_AsLong(value);\n    if (protocol == -1 && PyErr_Occurred())\n        return NULL;\n\n    if (PyObject_GetOptionalAttr((PyObject *)self, state->str___dict__, &dict) < 0) {\n        return NULL;\n    }\n    if (dict == NULL) {\n        dict = Py_NewRef(Py_None);\n    }\n\n    mformat_code = typecode_to_mformat_code(typecode);\n    if (mformat_code == UNKNOWN_FORMAT || protocol < 3) {\n        /* Convert the array to a list if we got something weird\n         * (e.g., non-IEEE floats), or we are pickling the array using\n         * a Python 2.x compatible protocol.\n         *\n         * It is necessary to use a list representation for Python 2.x\n         * compatible pickle protocol, since Python 2's str objects\n         * are unpickled as unicode by Python 3. Thus it is impossible\n         * to make arrays unpicklable by Python 3 by using their memory\n         * representation, unless we resort to ugly hacks such as\n         * coercing unicode objects to bytes in array_reconstructor.\n         */\n        PyObject *list;\n        list = array_array_tolist_impl(self);\n        if (list == NULL) {\n            Py_DECREF(dict);\n            return NULL;\n        }\n        result = Py_BuildValue(\n            \"O(CO)O\", Py_TYPE(self), typecode, list, dict);\n        Py_DECREF(list);\n        Py_DECREF(dict);\n        return result;\n    }\n\n    array_str = array_array_tobytes_impl(self);\n    if (array_str == NULL) {\n        Py_DECREF(dict);\n        return NULL;\n    }\n\n    assert(state->array_reconstructor != NULL);\n    result = Py_BuildValue(\n        \"O(OCiN)O\", state->array_reconstructor, Py_TYPE(self), typecode,\n        mformat_code, array_str, dict);\n    Py_DECREF(dict);\n    return result;\n}\n\nstatic PyObject *\narray_get_typecode(arrayobject *a, void *closure)\n{\n    char typecode = a->ob_descr->typecode;\n    return PyUnicode_FromOrdinal(typecode);\n}\n\nstatic PyObject *\narray_get_itemsize(arrayobject *a, void *closure)\n{\n    return PyLong_FromLong((long)a->ob_descr->itemsize);\n}\n\nstatic PyGetSetDef array_getsets [] = {\n    {\"typecode\", (getter) array_get_typecode, NULL,\n     \"the typecode character used to create the array\"},\n    {\"itemsize\", (getter) array_get_itemsize, NULL,\n     \"the size, in bytes, of one array item\"},\n    {NULL}\n};\n\nstatic PyMethodDef array_methods[] = {\n    ARRAY_ARRAY_APPEND_METHODDEF\n    ARRAY_ARRAY_BUFFER_INFO_METHODDEF\n    ARRAY_ARRAY_BYTESWAP_METHODDEF\n    ARRAY_ARRAY_CLEAR_METHODDEF\n    ARRAY_ARRAY___COPY___METHODDEF\n    ARRAY_ARRAY_COUNT_METHODDEF\n    ARRAY_ARRAY___DEEPCOPY___METHODDEF\n    ARRAY_ARRAY_EXTEND_METHODDEF\n    ARRAY_ARRAY_FROMFILE_METHODDEF\n    ARRAY_ARRAY_FROMLIST_METHODDEF\n    ARRAY_ARRAY_FROMBYTES_METHODDEF\n    ARRAY_ARRAY_FROMUNICODE_METHODDEF\n    ARRAY_ARRAY_INDEX_METHODDEF\n    ARRAY_ARRAY_INSERT_METHODDEF\n    ARRAY_ARRAY_POP_METHODDEF\n    ARRAY_ARRAY___REDUCE_EX___METHODDEF\n    ARRAY_ARRAY_REMOVE_METHODDEF\n    ARRAY_ARRAY_REVERSE_METHODDEF\n    ARRAY_ARRAY_TOFILE_METHODDEF\n    ARRAY_ARRAY_TOLIST_METHODDEF\n    ARRAY_ARRAY_TOBYTES_METHODDEF\n    ARRAY_ARRAY_TOUNICODE_METHODDEF\n    ARRAY_ARRAY___SIZEOF___METHODDEF\n    {\"__class_getitem__\", Py_GenericAlias, METH_O|METH_CLASS, PyDoc_STR(\"See PEP 585\")},\n    {NULL, NULL}  /* sentinel */\n};\n\nstatic PyObject *\narray_repr(arrayobject *a)\n{\n    char typecode;\n    PyObject *s, *v = NULL;\n    Py_ssize_t len;\n\n    len = Py_SIZE(a);\n    typecode = a->ob_descr->typecode;\n    if (len == 0) {\n        return PyUnicode_FromFormat(\"%s('%c')\",\n                                    _PyType_Name(Py_TYPE(a)), (int)typecode);\n    }\n    if (typecode == 'u' || typecode == 'w') {\n        v = array_array_tounicode_impl(a);\n    } else {\n        v = array_array_tolist_impl(a);\n    }\n    if (v == NULL)\n        return NULL;\n\n    s = PyUnicode_FromFormat(\"%s('%c', %R)\",\n                             _PyType_Name(Py_TYPE(a)), (int)typecode, v);\n    Py_DECREF(v);\n    return s;\n}\n\nstatic PyObject*\narray_subscr(arrayobject* self, PyObject* item)\n{\n    array_state *state = find_array_state_by_type(Py_TYPE(self));\n\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n        if (i==-1 && PyErr_Occurred()) {\n            return NULL;\n        }\n        if (i < 0)\n            i += Py_SIZE(self);\n        return array_item(self, i);\n    }\n    else if (PySlice_Check(item)) {\n        Py_ssize_t start, stop, step, slicelength, i;\n        size_t cur;\n        PyObject* result;\n        arrayobject* ar;\n        int itemsize = self->ob_descr->itemsize;\n\n        if (PySlice_Unpack(item, &start, &stop, &step) < 0) {\n            return NULL;\n        }\n        slicelength = PySlice_AdjustIndices(Py_SIZE(self), &start, &stop,\n                                            step);\n\n        if (slicelength <= 0) {\n            return newarrayobject(state->ArrayType, 0, self->ob_descr);\n        }\n        else if (step == 1) {\n            PyObject *result = newarrayobject(state->ArrayType,\n                                    slicelength, self->ob_descr);\n            if (result == NULL)\n                return NULL;\n            memcpy(((arrayobject *)result)->ob_item,\n                   self->ob_item + start * itemsize,\n                   slicelength * itemsize);\n            return result;\n        }\n        else {\n            result = newarrayobject(state->ArrayType, slicelength, self->ob_descr);\n            if (!result) return NULL;\n\n            ar = (arrayobject*)result;\n\n            for (cur = start, i = 0; i < slicelength;\n                 cur += step, i++) {\n                memcpy(ar->ob_item + i*itemsize,\n                       self->ob_item + cur*itemsize,\n                       itemsize);\n            }\n\n            return result;\n        }\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"array indices must be integers\");\n        return NULL;\n    }\n}\n\nstatic int\narray_ass_subscr(arrayobject* self, PyObject* item, PyObject* value)\n{\n    Py_ssize_t start, stop, step, slicelength, needed;\n    array_state* state = find_array_state_by_type(Py_TYPE(self));\n    arrayobject* other;\n    int itemsize;\n\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n\n        if (i == -1 && PyErr_Occurred())\n            return -1;\n        if (i < 0)\n            i += Py_SIZE(self);\n        if (i < 0 || i >= Py_SIZE(self)) {\n            PyErr_SetString(PyExc_IndexError,\n                \"array assignment index out of range\");\n            return -1;\n        }\n        if (value == NULL) {\n            /* Fall through to slice assignment */\n            start = i;\n            stop = i + 1;\n            step = 1;\n            slicelength = 1;\n        }\n        else\n            return (*self->ob_descr->setitem)(self, i, value);\n    }\n    else if (PySlice_Check(item)) {\n        if (PySlice_Unpack(item, &start, &stop, &step) < 0) {\n            return -1;\n        }\n        slicelength = PySlice_AdjustIndices(Py_SIZE(self), &start, &stop,\n                                            step);\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"array indices must be integers\");\n        return -1;\n    }\n    if (value == NULL) {\n        other = NULL;\n        needed = 0;\n    }\n    else if (array_Check(value, state)) {\n        other = (arrayobject *)value;\n        needed = Py_SIZE(other);\n        if (self == other) {\n            /* Special case \"self[i:j] = self\" -- copy self first */\n            int ret;\n            value = array_slice(other, 0, needed);\n            if (value == NULL)\n                return -1;\n            ret = array_ass_subscr(self, item, value);\n            Py_DECREF(value);\n            return ret;\n        }\n        if (other->ob_descr != self->ob_descr) {\n            PyErr_BadArgument();\n            return -1;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n         \"can only assign array (not \\\"%.200s\\\") to array slice\",\n                         Py_TYPE(value)->tp_name);\n        return -1;\n    }\n    itemsize = self->ob_descr->itemsize;\n    /* for 'a[2:1] = ...', the insertion point is 'start', not 'stop' */\n    if ((step > 0 && stop < start) ||\n        (step < 0 && stop > start))\n        stop = start;\n\n    /* Issue #4509: If the array has exported buffers and the slice\n       assignment would change the size of the array, fail early to make\n       sure we don't modify it. */\n    if ((needed == 0 || slicelength != needed) && self->ob_exports > 0) {\n        PyErr_SetString(PyExc_BufferError,\n            \"cannot resize an array that is exporting buffers\");\n        return -1;\n    }\n\n    if (step == 1) {\n        if (slicelength > needed) {\n            memmove(self->ob_item + (start + needed) * itemsize,\n                self->ob_item + stop * itemsize,\n                (Py_SIZE(self) - stop) * itemsize);\n            if (array_resize(self, Py_SIZE(self) +\n                needed - slicelength) < 0)\n                return -1;\n        }\n        else if (slicelength < needed) {\n            if (array_resize(self, Py_SIZE(self) +\n                needed - slicelength) < 0)\n                return -1;\n            memmove(self->ob_item + (start + needed) * itemsize,\n                self->ob_item + stop * itemsize,\n                (Py_SIZE(self) - start - needed) * itemsize);\n        }\n        if (needed > 0)\n            memcpy(self->ob_item + start * itemsize,\n                   other->ob_item, needed * itemsize);\n        return 0;\n    }\n    else if (needed == 0) {\n        /* Delete slice */\n        size_t cur;\n        Py_ssize_t i;\n\n        if (step < 0) {\n            stop = start + 1;\n            start = stop + step * (slicelength - 1) - 1;\n            step = -step;\n        }\n        for (cur = start, i = 0; i < slicelength;\n             cur += step, i++) {\n            Py_ssize_t lim = step - 1;\n\n            if (cur + step >= (size_t)Py_SIZE(self))\n                lim = Py_SIZE(self) - cur - 1;\n            memmove(self->ob_item + (cur - i) * itemsize,\n                self->ob_item + (cur + 1) * itemsize,\n                lim * itemsize);\n        }\n        cur = start + (size_t)slicelength * step;\n        if (cur < (size_t)Py_SIZE(self)) {\n            memmove(self->ob_item + (cur-slicelength) * itemsize,\n                self->ob_item + cur * itemsize,\n                (Py_SIZE(self) - cur) * itemsize);\n        }\n        if (array_resize(self, Py_SIZE(self) - slicelength) < 0)\n            return -1;\n        return 0;\n    }\n    else {\n        size_t cur;\n        Py_ssize_t i;\n\n        if (needed != slicelength) {\n            PyErr_Format(PyExc_ValueError,\n                \"attempt to assign array of size %zd \"\n                \"to extended slice of size %zd\",\n                needed, slicelength);\n            return -1;\n        }\n        for (cur = start, i = 0; i < slicelength;\n             cur += step, i++) {\n            memcpy(self->ob_item + cur * itemsize,\n                   other->ob_item + i * itemsize,\n                   itemsize);\n        }\n        return 0;\n    }\n}\n\nstatic const void *emptybuf = \"\";\n\n\nstatic int\narray_buffer_getbuf(arrayobject *self, Py_buffer *view, int flags)\n{\n    if (view == NULL) {\n        PyErr_SetString(PyExc_BufferError,\n            \"array_buffer_getbuf: view==NULL argument is obsolete\");\n        return -1;\n    }\n\n    view->buf = (void *)self->ob_item;\n    view->obj = Py_NewRef(self);\n    if (view->buf == NULL)\n        view->buf = (void *)emptybuf;\n    view->len = Py_SIZE(self) * self->ob_descr->itemsize;\n    view->readonly = 0;\n    view->ndim = 1;\n    view->itemsize = self->ob_descr->itemsize;\n    view->suboffsets = NULL;\n    view->shape = NULL;\n    if ((flags & PyBUF_ND)==PyBUF_ND) {\n        view->shape = &((PyVarObject*)self)->ob_size;\n    }\n    view->strides = NULL;\n    if ((flags & PyBUF_STRIDES)==PyBUF_STRIDES)\n        view->strides = &(view->itemsize);\n    view->format = NULL;\n    view->internal = NULL;\n    if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT) {\n        view->format = (char *)self->ob_descr->formats;\n#ifdef Py_UNICODE_WIDE\n        if (self->ob_descr->typecode == 'u') {\n            view->format = \"w\";\n        }\n#endif\n    }\n\n    self->ob_exports++;\n    return 0;\n}\n\nstatic void\narray_buffer_relbuf(arrayobject *self, Py_buffer *view)\n{\n    self->ob_exports--;\n}\n\nstatic PyObject *\narray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    array_state *state = find_array_state_by_type(type);\n    int c;\n    PyObject *initial = NULL, *it = NULL;\n    const struct arraydescr *descr;\n\n    if ((type == state->ArrayType ||\n         type->tp_init == state->ArrayType->tp_init) &&\n        !_PyArg_NoKeywords(\"array.array\", kwds))\n        return NULL;\n\n    if (!PyArg_ParseTuple(args, \"C|O:array\", &c, &initial))\n        return NULL;\n\n    if (PySys_Audit(\"array.__new__\", \"CO\",\n                    c, initial ? initial : Py_None) < 0) {\n        return NULL;\n    }\n\n    if (c == 'u') {\n        if (PyErr_WarnEx(PyExc_DeprecationWarning,\n                         \"The 'u' type code is deprecated and \"\n                         \"will be removed in Python 3.16\",\n                         1)) {\n            return NULL;\n        }\n    }\n\n    bool is_unicode = c == 'u' || c == 'w';\n\n    if (initial && !is_unicode) {\n        if (PyUnicode_Check(initial)) {\n            PyErr_Format(PyExc_TypeError, \"cannot use a str to initialize \"\n                         \"an array with typecode '%c'\", c);\n            return NULL;\n        }\n        else if (array_Check(initial, state)) {\n            int ic = ((arrayobject*)initial)->ob_descr->typecode;\n            if (ic == 'u' || ic == 'w') {\n                PyErr_Format(PyExc_TypeError, \"cannot use a unicode array to \"\n                            \"initialize an array with typecode '%c'\", c);\n                return NULL;\n            }\n        }\n    }\n\n    if (!(initial == NULL || PyList_Check(initial)\n          || PyByteArray_Check(initial)\n          || PyBytes_Check(initial)\n          || PyTuple_Check(initial)\n          || (is_unicode && PyUnicode_Check(initial))\n          || (array_Check(initial, state)\n              && c == ((arrayobject*)initial)->ob_descr->typecode))) {\n        it = PyObject_GetIter(initial);\n        if (it == NULL)\n            return NULL;\n        /* We set initial to NULL so that the subsequent code\n           will create an empty array of the appropriate type\n           and afterwards we can use array_iter_extend to populate\n           the array.\n        */\n        initial = NULL;\n    }\n    for (descr = descriptors; descr->typecode != '\\0'; descr++) {\n        if (descr->typecode == c) {\n            PyObject *a;\n            Py_ssize_t len;\n\n            if (initial == NULL)\n                len = 0;\n            else if (PyList_Check(initial))\n                len = PyList_GET_SIZE(initial);\n            else if (PyTuple_Check(initial) || array_Check(initial, state))\n                len = Py_SIZE(initial);\n            else\n                len = 0;\n\n            a = newarrayobject(type, len, descr);\n            if (a == NULL)\n                return NULL;\n\n            if (len > 0 && !array_Check(initial, state)) {\n                Py_ssize_t i;\n                for (i = 0; i < len; i++) {\n                    PyObject *v =\n                        PySequence_GetItem(initial, i);\n                    if (v == NULL) {\n                        Py_DECREF(a);\n                        return NULL;\n                    }\n                    if (setarrayitem(a, i, v) != 0) {\n                        Py_DECREF(v);\n                        Py_DECREF(a);\n                        return NULL;\n                    }\n                    Py_DECREF(v);\n                }\n            }\n            else if (initial != NULL && (PyByteArray_Check(initial) ||\n                               PyBytes_Check(initial))) {\n                PyObject *v;\n                v = array_array_frombytes((arrayobject *)a,\n                                          initial);\n                if (v == NULL) {\n                    Py_DECREF(a);\n                    return NULL;\n                }\n                Py_DECREF(v);\n            }\n            else if (initial != NULL && PyUnicode_Check(initial))  {\n                if (c == 'u') {\n                    Py_ssize_t n;\n                    wchar_t *ustr = PyUnicode_AsWideCharString(initial, &n);\n                    if (ustr == NULL) {\n                        Py_DECREF(a);\n                        return NULL;\n                    }\n\n                    if (n > 0) {\n                        arrayobject *self = (arrayobject *)a;\n                        // self->ob_item may be NULL but it is safe.\n                        PyMem_Free(self->ob_item);\n                        self->ob_item = (char *)ustr;\n                        Py_SET_SIZE(self, n);\n                        self->allocated = n;\n                    }\n                }\n                else { // c == 'w'\n                    Py_ssize_t n = PyUnicode_GET_LENGTH(initial);\n                    Py_UCS4 *ustr = PyUnicode_AsUCS4Copy(initial);\n                    if (ustr == NULL) {\n                        Py_DECREF(a);\n                        return NULL;\n                    }\n\n                    arrayobject *self = (arrayobject *)a;\n                    // self->ob_item may be NULL but it is safe.\n                    PyMem_Free(self->ob_item);\n                    self->ob_item = (char *)ustr;\n                    Py_SET_SIZE(self, n);\n                    self->allocated = n;\n                }\n            }\n            else if (initial != NULL && array_Check(initial, state) && len > 0) {\n                arrayobject *self = (arrayobject *)a;\n                arrayobject *other = (arrayobject *)initial;\n                memcpy(self->ob_item, other->ob_item, len * other->ob_descr->itemsize);\n            }\n            if (it != NULL) {\n                if (array_iter_extend((arrayobject *)a, it) == -1) {\n                    Py_DECREF(it);\n                    Py_DECREF(a);\n                    return NULL;\n                }\n                Py_DECREF(it);\n            }\n            return a;\n        }\n    }\n    PyErr_SetString(PyExc_ValueError,\n        \"bad typecode (must be b, B, u, h, H, i, I, l, L, q, Q, f or d)\");\n    return NULL;\n}\n\n\nPyDoc_STRVAR(module_doc,\n\"This module defines an object type which can efficiently represent\\n\\\nan array of basic values: characters, integers, floating point\\n\\\nnumbers.  Arrays are sequence types and behave very much like lists,\\n\\\nexcept that the type of objects stored in them is constrained.\\n\");\n\nPyDoc_STRVAR(arraytype_doc,\n\"array(typecode [, initializer]) -> array\\n\\\n\\n\\\nReturn a new array whose items are restricted by typecode, and\\n\\\ninitialized from the optional initializer value, which must be a list,\\n\\\nstring or iterable over elements of the appropriate type.\\n\\\n\\n\\\nArrays represent basic values and behave very much like lists, except\\n\\\nthe type of objects stored in them is constrained. The type is specified\\n\\\nat object creation time by using a type code, which is a single character.\\n\\\nThe following type codes are defined:\\n\\\n\\n\\\n    Type code   C Type             Minimum size in bytes\\n\\\n    'b'         signed integer     1\\n\\\n    'B'         unsigned integer   1\\n\\\n    'u'         Unicode character  2 (see note)\\n\\\n    'h'         signed integer     2\\n\\\n    'H'         unsigned integer   2\\n\\\n    'i'         signed integer     2\\n\\\n    'I'         unsigned integer   2\\n\\\n    'l'         signed integer     4\\n\\\n    'L'         unsigned integer   4\\n\\\n    'q'         signed integer     8 (see note)\\n\\\n    'Q'         unsigned integer   8 (see note)\\n\\\n    'f'         floating point     4\\n\\\n    'd'         floating point     8\\n\\\n\\n\\\nNOTE: The 'u' typecode corresponds to Python's unicode character. On\\n\\\nnarrow builds this is 2-bytes on wide builds this is 4-bytes.\\n\\\n\\n\\\nNOTE: The 'q' and 'Q' type codes are only available if the platform\\n\\\nC compiler used to build Python supports 'long long', or, on Windows,\\n\\\n'__int64'.\\n\\\n\\n\\\nMethods:\\n\\\n\\n\\\nappend() -- append a new item to the end of the array\\n\\\nbuffer_info() -- return information giving the current memory info\\n\\\nbyteswap() -- byteswap all the items of the array\\n\\\ncount() -- return number of occurrences of an object\\n\\\nextend() -- extend array by appending multiple elements from an iterable\\n\\\nfromfile() -- read items from a file object\\n\\\nfromlist() -- append items from the list\\n\\\nfrombytes() -- append items from the string\\n\\\nindex() -- return index of first occurrence of an object\\n\\\ninsert() -- insert a new item into the array at a provided position\\n\\\npop() -- remove and return item (default last)\\n\\\nremove() -- remove first occurrence of an object\\n\\\nreverse() -- reverse the order of the items in the array\\n\\\ntofile() -- write all items to a file object\\n\\\ntolist() -- return the array converted to an ordinary list\\n\\\ntobytes() -- return the array converted to a string\\n\\\n\\n\\\nAttributes:\\n\\\n\\n\\\ntypecode -- the typecode character used to create the array\\n\\\nitemsize -- the length in bytes of one array item\\n\\\n\");\n\nstatic PyObject *array_iter(arrayobject *ao);\n\nstatic struct PyMemberDef array_members[] = {\n    {\"__weaklistoffset__\", Py_T_PYSSIZET, offsetof(arrayobject, weakreflist), Py_READONLY},\n    {NULL},\n};\n\nstatic PyType_Slot array_slots[] = {\n    {Py_tp_dealloc, array_dealloc},\n    {Py_tp_repr, array_repr},\n    {Py_tp_getattro, PyObject_GenericGetAttr},\n    {Py_tp_doc, (void *)arraytype_doc},\n    {Py_tp_richcompare, array_richcompare},\n    {Py_tp_iter, array_iter},\n    {Py_tp_methods, array_methods},\n    {Py_tp_members, array_members},\n    {Py_tp_getset, array_getsets},\n    {Py_tp_alloc, PyType_GenericAlloc},\n    {Py_tp_new, array_new},\n    {Py_tp_traverse, array_tp_traverse},\n\n    /* as sequence */\n    {Py_sq_length, array_length},\n    {Py_sq_concat, array_concat},\n    {Py_sq_repeat, array_repeat},\n    {Py_sq_item, array_item},\n    {Py_sq_ass_item, array_ass_item},\n    {Py_sq_contains, array_contains},\n    {Py_sq_inplace_concat, array_inplace_concat},\n    {Py_sq_inplace_repeat, array_inplace_repeat},\n\n    /* as mapping */\n    {Py_mp_length, array_length},\n    {Py_mp_subscript, array_subscr},\n    {Py_mp_ass_subscript, array_ass_subscr},\n\n    /* as buffer */\n    {Py_bf_getbuffer, array_buffer_getbuf},\n    {Py_bf_releasebuffer, array_buffer_relbuf},\n\n    {0, NULL},\n};\n\nstatic PyType_Spec array_spec = {\n    .name = \"array.array\",\n    .basicsize = sizeof(arrayobject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n              Py_TPFLAGS_IMMUTABLETYPE | Py_TPFLAGS_HAVE_GC |\n              Py_TPFLAGS_SEQUENCE),\n    .slots = array_slots,\n};\n\n/*********************** Array Iterator **************************/\n\n/*[clinic input]\nclass array.arrayiterator \"arrayiterobject *\" \"find_array_state_by_type(type)->ArrayIterType\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=fb46d5ef98dd95ff]*/\n\nstatic PyObject *\narray_iter(arrayobject *ao)\n{\n    array_state *state = find_array_state_by_type(Py_TYPE(ao));\n    arrayiterobject *it;\n\n    if (!array_Check(ao, state)) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n\n    it = PyObject_GC_New(arrayiterobject, state->ArrayIterType);\n    if (it == NULL)\n        return NULL;\n\n    it->ao = (arrayobject*)Py_NewRef(ao);\n    it->index = 0;\n    it->getitem = ao->ob_descr->getitem;\n    PyObject_GC_Track(it);\n    return (PyObject *)it;\n}\n\nstatic PyObject *\narrayiter_next(arrayiterobject *it)\n{\n    arrayobject *ao;\n\n    assert(it != NULL);\n#ifndef NDEBUG\n    array_state *state = find_array_state_by_type(Py_TYPE(it));\n    assert(PyObject_TypeCheck(it, state->ArrayIterType));\n#endif\n    ao = it->ao;\n    if (ao == NULL) {\n        return NULL;\n    }\n#ifndef NDEBUG\n    assert(array_Check(ao, state));\n#endif\n    if (it->index < Py_SIZE(ao)) {\n        return (*it->getitem)(ao, it->index++);\n    }\n    it->ao = NULL;\n    Py_DECREF(ao);\n    return NULL;\n}\n\nstatic void\narrayiter_dealloc(arrayiterobject *it)\n{\n    PyTypeObject *tp = Py_TYPE(it);\n\n    PyObject_GC_UnTrack(it);\n    Py_XDECREF(it->ao);\n    PyObject_GC_Del(it);\n    Py_DECREF(tp);\n}\n\nstatic int\narrayiter_traverse(arrayiterobject *it, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(it));\n    Py_VISIT(it->ao);\n    return 0;\n}\n\n/*[clinic input]\narray.arrayiterator.__reduce__\n\n    cls: defining_class\n    /\n\nReturn state information for pickling.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_arrayiterator___reduce___impl(arrayiterobject *self, PyTypeObject *cls)\n/*[clinic end generated code: output=4b032417a2c8f5e6 input=ac64e65a87ad452e]*/\n{\n\n    array_state *state = get_array_state_by_class(cls);\n    assert(state != NULL);\n    PyObject *func = _PyEval_GetBuiltin(state->str_iter);\n    if (self->ao == NULL) {\n        return Py_BuildValue(\"N(())\", func);\n    }\n    return Py_BuildValue(\"N(O)n\", func, self->ao, self->index);\n}\n\n/*[clinic input]\narray.arrayiterator.__setstate__\n\n    state: object\n    /\n\nSet state information for unpickling.\n[clinic start generated code]*/\n\nstatic PyObject *\narray_arrayiterator___setstate__(arrayiterobject *self, PyObject *state)\n/*[clinic end generated code: output=397da9904e443cbe input=f47d5ceda19e787b]*/\n{\n    Py_ssize_t index = PyLong_AsSsize_t(state);\n    if (index == -1 && PyErr_Occurred())\n        return NULL;\n    if (index < 0)\n        index = 0;\n    else if (index > Py_SIZE(self->ao))\n        index = Py_SIZE(self->ao); /* iterator exhausted */\n    self->index = index;\n    Py_RETURN_NONE;\n}\n\nstatic PyMethodDef arrayiter_methods[] = {\n    ARRAY_ARRAYITERATOR___REDUCE___METHODDEF\n    ARRAY_ARRAYITERATOR___SETSTATE___METHODDEF\n    {NULL, NULL} /* sentinel */\n};\n\nstatic PyType_Slot arrayiter_slots[] = {\n    {Py_tp_dealloc, arrayiter_dealloc},\n    {Py_tp_getattro, PyObject_GenericGetAttr},\n    {Py_tp_traverse, arrayiter_traverse},\n    {Py_tp_iter, PyObject_SelfIter},\n    {Py_tp_iternext, arrayiter_next},\n    {Py_tp_methods, arrayiter_methods},\n    {0, NULL},\n};\n\nstatic PyType_Spec arrayiter_spec = {\n    .name = \"array.arrayiterator\",\n    .basicsize = sizeof(arrayiterobject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n              Py_TPFLAGS_DISALLOW_INSTANTIATION | Py_TPFLAGS_IMMUTABLETYPE),\n    .slots = arrayiter_slots,\n};\n\n\n/*********************** Install Module **************************/\n\nstatic int\narray_traverse(PyObject *module, visitproc visit, void *arg)\n{\n    array_state *state = get_array_state(module);\n    Py_VISIT(state->ArrayType);\n    Py_VISIT(state->ArrayIterType);\n    Py_VISIT(state->array_reconstructor);\n    return 0;\n}\n\nstatic int\narray_clear(PyObject *module)\n{\n    array_state *state = get_array_state(module);\n    Py_CLEAR(state->ArrayType);\n    Py_CLEAR(state->ArrayIterType);\n    Py_CLEAR(state->array_reconstructor);\n    Py_CLEAR(state->str_read);\n    Py_CLEAR(state->str_write);\n    Py_CLEAR(state->str___dict__);\n    Py_CLEAR(state->str_iter);\n    return 0;\n}\n\nstatic void\narray_free(void *module)\n{\n    array_clear((PyObject *)module);\n}\n\n/* No functions in array module. */\nstatic PyMethodDef a_methods[] = {\n    ARRAY__ARRAY_RECONSTRUCTOR_METHODDEF\n    {NULL, NULL, 0, NULL}        /* Sentinel */\n};\n\n#define CREATE_TYPE(module, type, spec)                                  \\\ndo {                                                                     \\\n    type = (PyTypeObject *)PyType_FromModuleAndSpec(module, spec, NULL); \\\n    if (type == NULL) {                                                  \\\n        return -1;                                                       \\\n    }                                                                    \\\n} while (0)\n\n#define ADD_INTERNED(state, string)                      \\\ndo {                                                     \\\n    PyObject *tmp = PyUnicode_InternFromString(#string); \\\n    if (tmp == NULL) {                                   \\\n        return -1;                                       \\\n    }                                                    \\\n    state->str_ ## string = tmp;                         \\\n} while (0)\n\nstatic int\narray_modexec(PyObject *m)\n{\n    array_state *state = get_array_state(m);\n    char buffer[Py_ARRAY_LENGTH(descriptors)], *p;\n    PyObject *typecodes;\n    const struct arraydescr *descr;\n\n    state->array_reconstructor = NULL;\n    /* Add interned strings */\n    ADD_INTERNED(state, read);\n    ADD_INTERNED(state, write);\n    ADD_INTERNED(state, __dict__);\n    ADD_INTERNED(state, iter);\n\n    CREATE_TYPE(m, state->ArrayType, &array_spec);\n    CREATE_TYPE(m, state->ArrayIterType, &arrayiter_spec);\n    Py_SET_TYPE(state->ArrayIterType, &PyType_Type);\n\n    if (PyModule_AddObjectRef(m, \"ArrayType\",\n                              (PyObject *)state->ArrayType) < 0) {\n        return -1;\n    }\n\n    PyObject *mutablesequence = _PyImport_GetModuleAttrString(\n            \"collections.abc\", \"MutableSequence\");\n    if (!mutablesequence) {\n        Py_DECREF((PyObject *)state->ArrayType);\n        return -1;\n    }\n    PyObject *res = PyObject_CallMethod(mutablesequence, \"register\", \"O\",\n                                        (PyObject *)state->ArrayType);\n    Py_DECREF(mutablesequence);\n    if (!res) {\n        Py_DECREF((PyObject *)state->ArrayType);\n        return -1;\n    }\n    Py_DECREF(res);\n\n    if (PyModule_AddType(m, state->ArrayType) < 0) {\n        return -1;\n    }\n\n    p = buffer;\n    for (descr = descriptors; descr->typecode != '\\0'; descr++) {\n        *p++ = (char)descr->typecode;\n    }\n    typecodes = PyUnicode_DecodeASCII(buffer, p - buffer, NULL);\n    if (PyModule_Add(m, \"typecodes\", typecodes) < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic PyModuleDef_Slot arrayslots[] = {\n    {Py_mod_exec, array_modexec},\n    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},\n    {Py_mod_gil, Py_MOD_GIL_NOT_USED},\n    {0, NULL}\n};\n\n\nstatic struct PyModuleDef arraymodule = {\n    .m_base = PyModuleDef_HEAD_INIT,\n    .m_name = \"array\",\n    .m_size = sizeof(array_state),\n    .m_doc = module_doc,\n    .m_methods = a_methods,\n    .m_slots = arrayslots,\n    .m_traverse = array_traverse,\n    .m_clear = array_clear,\n    .m_free = array_free,\n};\n\n\nPyMODINIT_FUNC\nPyInit_array(void)\n{\n    return PyModuleDef_Init(&arraymodule);\n}\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/object.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_OBJECT_H\n#define Py_OBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Object and type object interface */\n\n/*\nObjects are structures allocated on the heap.  Special rules apply to\nthe use of objects to ensure they are properly garbage-collected.\nObjects are never allocated statically or on the stack; they must be\naccessed through special macros and functions only.  (Type objects are\nexceptions to the first rule; the standard types are represented by\nstatically initialized type objects, although work on type/class unification\nfor Python 2.2 made it possible to have heap-allocated type objects too).\n\nAn object has a 'reference count' that is increased or decreased when a\npointer to the object is copied or deleted; when the reference count\nreaches zero there are no references to the object left and it can be\nremoved from the heap.\n\nAn object has a 'type' that determines what it represents and what kind\nof data it contains.  An object's type is fixed when it is created.\nTypes themselves are represented as objects; an object contains a\npointer to the corresponding type object.  The type itself has a type\npointer pointing to the object representing the type 'type', which\ncontains a pointer to itself!.\n\nObjects do not float around in memory; once allocated an object keeps\nthe same size and address.  Objects that must hold variable-size data\ncan contain pointers to variable-size parts of the object.  Not all\nobjects of the same type have the same size; but the size cannot change\nafter allocation.  (These restrictions are made so a reference to an\nobject can be simply a pointer -- moving an object would require\nupdating all the pointers, and changing an object's size would require\nmoving it if there was another object right next to it.)\n\nObjects are always accessed through pointers of the type 'PyObject *'.\nThe type 'PyObject' is a structure that only contains the reference count\nand the type pointer.  The actual memory allocated for an object\ncontains other data that can only be accessed after casting the pointer\nto a pointer to a longer structure type.  This longer type must start\nwith the reference count and type fields; the macro PyObject_HEAD should be\nused for this (to accommodate for future changes).  The implementation\nof a particular object type can cast the object pointer to the proper\ntype and back.\n\nA standard interface exists for objects that contain an array of items\nwhose size is determined when the object is allocated.\n*/\n\n/* Py_DEBUG implies Py_REF_DEBUG. */\n#if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)\n#  define Py_REF_DEBUG\n#endif\n\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   PyObject ob_base;\n\n/*\nImmortalization:\n\nThe following indicates the immortalization strategy depending on the amount\nof available bits in the reference count field. All strategies are backwards\ncompatible but the specific reference count value or immortalization check\nmight change depending on the specializations for the underlying system.\n\nProper deallocation of immortal instances requires distinguishing between\nstatically allocated immortal instances vs those promoted by the runtime to be\nimmortal. The latter should be the only instances that require\ncleanup during runtime finalization.\n*/\n\n#if SIZEOF_VOID_P > 4\n/*\nIn 64+ bit systems, an object will be marked as immortal by setting all of the\nlower 32 bits of the reference count field, which is equal to: 0xFFFFFFFF\n\nUsing the lower 32 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases will use saturated arithmetic, taking advantage of\nhaving all the lower 32 bits set, which will avoid the reference count to go\nbeyond the refcount limit. Immortality checks for reference count decreases will\nbe done by checking the bit sign flag in the lower 32 bits.\n*/\n#define _Py_IMMORTAL_REFCNT _Py_CAST(Py_ssize_t, UINT_MAX)\n\n#else\n/*\nIn 32 bit systems, an object will be marked as immortal by setting all of the\nlower 30 bits of the reference count field, which is equal to: 0x3FFFFFFF\n\nUsing the lower 30 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases and decreases will first go through an immortality\ncheck by comparing the reference count field to the immortality reference count.\n*/\n#define _Py_IMMORTAL_REFCNT _Py_CAST(Py_ssize_t, UINT_MAX >> 2)\n#endif\n\n// Py_GIL_DISABLED builds indicate immortal objects using `ob_ref_local`, which is\n// always 32-bits.\n#ifdef Py_GIL_DISABLED\n#define _Py_IMMORTAL_REFCNT_LOCAL UINT32_MAX\n#endif\n\n// Kept for backward compatibility. It was needed by Py_TRACE_REFS build.\n#define _PyObject_EXTRA_INIT\n\n/* Make all uses of PyObject_HEAD_INIT immortal.\n *\n * Statically allocated objects might be shared between\n * interpreters, so must be marked as immortal.\n */\n#if defined(Py_GIL_DISABLED)\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        0,                          \\\n        0,                          \\\n        { 0 },                      \\\n        0,                          \\\n        _Py_IMMORTAL_REFCNT_LOCAL,  \\\n        0,                          \\\n        (type),                     \\\n    },\n#else\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        { _Py_IMMORTAL_REFCNT },    \\\n        (type)                      \\\n    },\n#endif\n\n#define PyVarObject_HEAD_INIT(type, size) \\\n    {                                     \\\n        PyObject_HEAD_INIT(type)          \\\n        (size)                            \\\n    },\n\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD      PyVarObject ob_base;\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\n#ifndef Py_GIL_DISABLED\nstruct _object {\n#if (defined(__GNUC__) || defined(__clang__)) \\\n        && !(defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L)\n    // On C99 and older, anonymous union is a GCC and clang extension\n    __extension__\n#endif\n#ifdef _MSC_VER\n    // Ignore MSC warning C4201: \"nonstandard extension used:\n    // nameless struct/union\"\n    __pragma(warning(push))\n    __pragma(warning(disable: 4201))\n#endif\n    union {\n       Py_ssize_t ob_refcnt;\n#if SIZEOF_VOID_P > 4\n       PY_UINT32_T ob_refcnt_split[2];\n#endif\n    };\n#ifdef _MSC_VER\n    __pragma(warning(pop))\n#endif\n\n    PyTypeObject *ob_type;\n};\n#else\n// Objects that are not owned by any thread use a thread id (tid) of zero.\n// This includes both immortal objects and objects whose reference count\n// fields have been merged.\n#define _Py_UNOWNED_TID             0\n\n// The shared reference count uses the two least-significant bits to store\n// flags. The remaining bits are used to store the reference count.\n#define _Py_REF_SHARED_SHIFT        2\n#define _Py_REF_SHARED_FLAG_MASK    0x3\n\n// The shared flags are initialized to zero.\n#define _Py_REF_SHARED_INIT         0x0\n#define _Py_REF_MAYBE_WEAKREF       0x1\n#define _Py_REF_QUEUED              0x2\n#define _Py_REF_MERGED              0x3\n\n// Create a shared field from a refcnt and desired flags\n#define _Py_REF_SHARED(refcnt, flags) (((refcnt) << _Py_REF_SHARED_SHIFT) + (flags))\n\nstruct _object {\n    // ob_tid stores the thread id (or zero). It is also used by the GC and the\n    // trashcan mechanism as a linked list pointer and by the GC to store the\n    // computed \"gc_refs\" refcount.\n    uintptr_t ob_tid;\n    uint16_t _padding;\n    PyMutex ob_mutex;           // per-object lock\n    uint8_t ob_gc_bits;         // gc-related state\n    uint32_t ob_ref_local;      // local reference count\n    Py_ssize_t ob_ref_shared;   // shared (atomic) reference count\n    PyTypeObject *ob_type;\n};\n#endif\n\n/* Cast argument to PyObject* type. */\n#define _PyObject_CAST(op) _Py_CAST(PyObject*, (op))\n\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n/* Cast argument to PyVarObject* type. */\n#define _PyVarObject_CAST(op) _Py_CAST(PyVarObject*, (op))\n\n\n// Test if the 'x' object is the 'y' object, the same as \"x is y\" in Python.\nPyAPI_FUNC(int) Py_Is(PyObject *x, PyObject *y);\n#define Py_Is(x, y) ((x) == (y))\n\n#if defined(Py_GIL_DISABLED) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(uintptr_t) _Py_GetThreadLocal_Addr(void);\n\nstatic inline uintptr_t\n_Py_ThreadId(void)\n{\n    uintptr_t tid;\n#if defined(_MSC_VER) && defined(_M_X64)\n    tid = __readgsqword(48);\n#elif defined(_MSC_VER) && defined(_M_IX86)\n    tid = __readfsdword(24);\n#elif defined(_MSC_VER) && defined(_M_ARM64)\n    tid = __getReg(18);\n#elif defined(__i386__)\n    __asm__(\"movl %%gs:0, %0\" : \"=r\" (tid));  // 32-bit always uses GS\n#elif defined(__MACH__) && defined(__x86_64__)\n    __asm__(\"movq %%gs:0, %0\" : \"=r\" (tid));  // x86_64 macOSX uses GS\n#elif defined(__x86_64__)\n   __asm__(\"movq %%fs:0, %0\" : \"=r\" (tid));  // x86_64 Linux, BSD uses FS\n#elif defined(__arm__)\n    __asm__ (\"mrc p15, 0, %0, c13, c0, 3\\nbic %0, %0, #3\" : \"=r\" (tid));\n#elif defined(__aarch64__) && defined(__APPLE__)\n    __asm__ (\"mrs %0, tpidrro_el0\" : \"=r\" (tid));\n#elif defined(__aarch64__)\n    __asm__ (\"mrs %0, tpidr_el0\" : \"=r\" (tid));\n#elif defined(__powerpc64__)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // r13 is reserved for use as system thread ID by the Power 64-bit ABI.\n    register uintptr_t tp __asm__ (\"r13\");\n    __asm__(\"\" : \"=r\" (tp));\n    tid = tp;\n    #endif\n#elif defined(__powerpc__)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // r2 is reserved for use as system thread ID by the Power 32-bit ABI.\n    register uintptr_t tp __asm__ (\"r2\");\n    __asm__ (\"\" : \"=r\" (tp));\n    tid = tp;\n    #endif\n#elif defined(__s390__) && defined(__GNUC__)\n    // Both GCC and Clang have supported __builtin_thread_pointer\n    // for s390 from long time ago.\n    tid = (uintptr_t)__builtin_thread_pointer();\n#elif defined(__riscv)\n    #if defined(__clang__) && _Py__has_builtin(__builtin_thread_pointer)\n    tid = (uintptr_t)__builtin_thread_pointer();\n    #else\n    // tp is Thread Pointer provided by the RISC-V ABI.\n    __asm__ (\"mv %0, tp\" : \"=r\" (tid));\n    #endif\n#else\n    // Fallback to a portable implementation if we do not have a faster\n    // platform-specific implementation.\n    tid = _Py_GetThreadLocal_Addr();\n#endif\n  return tid;\n}\n\nstatic inline Py_ALWAYS_INLINE int\n_Py_IsOwnedByCurrentThread(PyObject *ob)\n{\n#ifdef _Py_THREAD_SANITIZER\n    return _Py_atomic_load_uintptr_relaxed(&ob->ob_tid) == _Py_ThreadId();\n#else\n    return ob->ob_tid == _Py_ThreadId();\n#endif\n}\n#endif\n\nstatic inline Py_ssize_t Py_REFCNT(PyObject *ob) {\n#if !defined(Py_GIL_DISABLED)\n    return ob->ob_refcnt;\n#else\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&ob->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return _Py_IMMORTAL_REFCNT;\n    }\n    Py_ssize_t shared = _Py_atomic_load_ssize_relaxed(&ob->ob_ref_shared);\n    return _Py_STATIC_CAST(Py_ssize_t, local) +\n           Py_ARITHMETIC_RIGHT_SHIFT(Py_ssize_t, shared, _Py_REF_SHARED_SHIFT);\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_REFCNT(ob) Py_REFCNT(_PyObject_CAST(ob))\n#endif\n\n\n// bpo-39573: The Py_SET_TYPE() function must be used to set an object type.\nstatic inline PyTypeObject* Py_TYPE(PyObject *ob) {\n    return ob->ob_type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_TYPE(ob) Py_TYPE(_PyObject_CAST(ob))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyLong_Type;\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n\n// bpo-39573: The Py_SET_SIZE() function must be used to set an object size.\nstatic inline Py_ssize_t Py_SIZE(PyObject *ob) {\n    assert(ob->ob_type != &PyLong_Type);\n    assert(ob->ob_type != &PyBool_Type);\n    return  _PyVarObject_CAST(ob)->ob_size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SIZE(ob) Py_SIZE(_PyObject_CAST(ob))\n#endif\n\nstatic inline Py_ALWAYS_INLINE int _Py_IsImmortal(PyObject *op)\n{\n#if defined(Py_GIL_DISABLED)\n    return (_Py_atomic_load_uint32_relaxed(&op->ob_ref_local) ==\n            _Py_IMMORTAL_REFCNT_LOCAL);\n#elif SIZEOF_VOID_P > 4\n    return (_Py_CAST(PY_INT32_T, op->ob_refcnt) < 0);\n#else\n    return (op->ob_refcnt == _Py_IMMORTAL_REFCNT);\n#endif\n}\n#define _Py_IsImmortal(op) _Py_IsImmortal(_PyObject_CAST(op))\n\nstatic inline int Py_IS_TYPE(PyObject *ob, PyTypeObject *type) {\n    return Py_TYPE(ob) == type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_IS_TYPE(ob, type) Py_IS_TYPE(_PyObject_CAST(ob), (type))\n#endif\n\n\n// Py_SET_REFCNT() implementation for stable ABI\nPyAPI_FUNC(void) _Py_SetRefcnt(PyObject *ob, Py_ssize_t refcnt);\n\nstatic inline void Py_SET_REFCNT(PyObject *ob, Py_ssize_t refcnt) {\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030d0000\n    // Stable ABI implements Py_SET_REFCNT() as a function call\n    // on limited C API version 3.13 and newer.\n    _Py_SetRefcnt(ob, refcnt);\n#else\n    // This immortal check is for code that is unaware of immortal objects.\n    // The runtime tracks these objects and we should avoid as much\n    // as possible having extensions inadvertently change the refcnt\n    // of an immortalized object.\n    if (_Py_IsImmortal(ob)) {\n        return;\n    }\n\n#ifndef Py_GIL_DISABLED\n    ob->ob_refcnt = refcnt;\n#else\n    if (_Py_IsOwnedByCurrentThread(ob)) {\n        if ((size_t)refcnt > (size_t)UINT32_MAX) {\n            // On overflow, make the object immortal\n            ob->ob_tid = _Py_UNOWNED_TID;\n            ob->ob_ref_local = _Py_IMMORTAL_REFCNT_LOCAL;\n            ob->ob_ref_shared = 0;\n        }\n        else {\n            // Set local refcount to desired refcount and shared refcount\n            // to zero, but preserve the shared refcount flags.\n            ob->ob_ref_local = _Py_STATIC_CAST(uint32_t, refcnt);\n            ob->ob_ref_shared &= _Py_REF_SHARED_FLAG_MASK;\n        }\n    }\n    else {\n        // Set local refcount to zero and shared refcount to desired refcount.\n        // Mark the object as merged.\n        ob->ob_tid = _Py_UNOWNED_TID;\n        ob->ob_ref_local = 0;\n        ob->ob_ref_shared = _Py_REF_SHARED(refcnt, _Py_REF_MERGED);\n    }\n#endif  // Py_GIL_DISABLED\n#endif  // Py_LIMITED_API+0 < 0x030d0000\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_REFCNT(ob, refcnt) Py_SET_REFCNT(_PyObject_CAST(ob), (refcnt))\n#endif\n\n\nstatic inline void Py_SET_TYPE(PyObject *ob, PyTypeObject *type) {\n    ob->ob_type = type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_TYPE(ob, type) Py_SET_TYPE(_PyObject_CAST(ob), type)\n#endif\n\nstatic inline void Py_SET_SIZE(PyVarObject *ob, Py_ssize_t size) {\n    assert(ob->ob_base.ob_type != &PyLong_Type);\n    assert(ob->ob_base.ob_type != &PyBool_Type);\n#ifdef Py_GIL_DISABLED\n    _Py_atomic_store_ssize_relaxed(&ob->ob_size, size);\n#else\n    ob->ob_size = size;\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_SIZE(ob, size) Py_SET_SIZE(_PyVarObject_CAST(ob), (size))\n#endif\n\n\n/*\nType objects contain a string containing the type name (to help somewhat\nin debugging), the allocation parameters (see PyObject_New() and\nPyObject_NewVar()),\nand methods for accessing objects of the type.  Methods are optional, a\nnil pointer meaning that particular kind of access is not available for\nthis type.  The Py_DECREF() macro uses the tp_dealloc method without\nchecking for a nil pointer; it should always be implemented except if\nthe implementation can guarantee that the reference count will never\nreach zero (e.g., for statically allocated type objects).\n\nNB: the methods for certain type groups are now contained in separate\nmethod blocks.\n*/\n\ntypedef PyObject * (*unaryfunc)(PyObject *);\ntypedef PyObject * (*binaryfunc)(PyObject *, PyObject *);\ntypedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);\ntypedef int (*inquiry)(PyObject *);\ntypedef Py_ssize_t (*lenfunc)(PyObject *);\ntypedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);\ntypedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);\ntypedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);\ntypedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);\ntypedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);\n\ntypedef int (*objobjproc)(PyObject *, PyObject *);\ntypedef int (*visitproc)(PyObject *, void *);\ntypedef int (*traverseproc)(PyObject *, visitproc, void *);\n\n\ntypedef void (*freefunc)(void *);\ntypedef void (*destructor)(PyObject *);\ntypedef PyObject *(*getattrfunc)(PyObject *, char *);\ntypedef PyObject *(*getattrofunc)(PyObject *, PyObject *);\ntypedef int (*setattrfunc)(PyObject *, char *, PyObject *);\ntypedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*reprfunc)(PyObject *);\ntypedef Py_hash_t (*hashfunc)(PyObject *);\ntypedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);\ntypedef PyObject *(*getiterfunc) (PyObject *);\ntypedef PyObject *(*iternextfunc) (PyObject *);\ntypedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*initproc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*newfunc)(PyTypeObject *, PyObject *, PyObject *);\ntypedef PyObject *(*allocfunc)(PyTypeObject *, Py_ssize_t);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030c0000 // 3.12\ntypedef PyObject *(*vectorcallfunc)(PyObject *callable, PyObject *const *args,\n                                    size_t nargsf, PyObject *kwnames);\n#endif\n\ntypedef struct{\n    int slot;    /* slot id, see below */\n    void *pfunc; /* function pointer */\n} PyType_Slot;\n\ntypedef struct{\n    const char* name;\n    int basicsize;\n    int itemsize;\n    unsigned int flags;\n    PyType_Slot *slots; /* terminated by slot==0. */\n} PyType_Spec;\n\nPyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000\nPyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);\nPyAPI_FUNC(PyObject *) PyType_GetModule(PyTypeObject *);\nPyAPI_FUNC(void *) PyType_GetModuleState(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000\nPyAPI_FUNC(PyObject *) PyType_GetName(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GetQualName(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030D0000\nPyAPI_FUNC(PyObject *) PyType_GetFullyQualifiedName(PyTypeObject *type);\nPyAPI_FUNC(PyObject *) PyType_GetModuleName(PyTypeObject *type);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\nPyAPI_FUNC(PyObject *) PyType_FromMetaclass(PyTypeObject*, PyObject*, PyType_Spec*, PyObject*);\nPyAPI_FUNC(void *) PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls);\nPyAPI_FUNC(Py_ssize_t) PyType_GetTypeDataSize(PyTypeObject *cls);\n#endif\n\n/* Generic type check */\nPyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);\n\nstatic inline int PyObject_TypeCheck(PyObject *ob, PyTypeObject *type) {\n    return Py_IS_TYPE(ob, type) || PyType_IsSubtype(Py_TYPE(ob), type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyObject_TypeCheck(ob, type) PyObject_TypeCheck(_PyObject_CAST(ob), (type))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */\nPyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */\nPyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */\n\nPyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);\n\nPyAPI_FUNC(int) PyType_Ready(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,\n                                               PyObject *, PyObject *);\nPyAPI_FUNC(unsigned int) PyType_ClearCache(void);\nPyAPI_FUNC(void) PyType_Modified(PyTypeObject *);\n\n/* Generic operations on objects */\nPyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);\nPyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);\nPyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);\nPyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);\nPyAPI_FUNC(int) PyObject_DelAttrString(PyObject *v, const char *name);\nPyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(int) PyObject_GetOptionalAttr(PyObject *, PyObject *, PyObject **);\nPyAPI_FUNC(int) PyObject_GetOptionalAttrString(PyObject *, const char *, PyObject **);\n#endif\nPyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_DelAttr(PyObject *v, PyObject *name);\nPyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(int) PyObject_HasAttrWithError(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttrStringWithError(PyObject *, const char *);\n#endif\nPyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);\n#endif\nPyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);\nPyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);\nPyAPI_FUNC(int) PyObject_IsTrue(PyObject *);\nPyAPI_FUNC(int) PyObject_Not(PyObject *);\nPyAPI_FUNC(int) PyCallable_Check(PyObject *);\nPyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);\n\n/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a\n   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),\n   returning the names of the current locals.  In this case, if there are\n   no current locals, NULL is returned, and PyErr_Occurred() is false.\n*/\nPyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);\n\n/* Helpers for printing recursive container types */\nPyAPI_FUNC(int) Py_ReprEnter(PyObject *);\nPyAPI_FUNC(void) Py_ReprLeave(PyObject *);\n\n/* Flag bits for printing: */\n#define Py_PRINT_RAW    1       /* No string quotes etc. */\n\n/*\nType flags (tp_flags)\n\nThese flags are used to change expected features and behavior for a\nparticular type.\n\nArbitration of the flag bit positions will need to be coordinated among\nall extension writers who publicly release their extensions (this will\nbe fewer than you might expect!).\n\nMost flags were removed as of Python 3.0 to make room for new flags.  (Some\nflags are not for backwards compatibility but to indicate the presence of an\noptional feature; these flags remain of course.)\n\nType definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.\n\nCode can use PyType_HasFeature(type_ob, flag_value) to test whether the\ngiven type object has a specified feature.\n*/\n\n#ifndef Py_LIMITED_API\n\n/* Track types initialized using _PyStaticType_InitBuiltin(). */\n#define _Py_TPFLAGS_STATIC_BUILTIN (1 << 1)\n\n/* The values array is placed inline directly after the rest of\n * the object. Implies Py_TPFLAGS_HAVE_GC.\n */\n#define Py_TPFLAGS_INLINE_VALUES (1 << 2)\n\n/* Placement of weakref pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_weaklistoffset.\n */\n#define Py_TPFLAGS_MANAGED_WEAKREF (1 << 3)\n\n/* Placement of dict (and values) pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_dictoffset. Implies Py_TPFLAGS_HAVE_GC.\n */\n#define Py_TPFLAGS_MANAGED_DICT (1 << 4)\n\n#define Py_TPFLAGS_PREHEADER (Py_TPFLAGS_MANAGED_WEAKREF | Py_TPFLAGS_MANAGED_DICT)\n\n/* Set if instances of the type object are treated as sequences for pattern matching */\n#define Py_TPFLAGS_SEQUENCE (1 << 5)\n/* Set if instances of the type object are treated as mappings for pattern matching */\n#define Py_TPFLAGS_MAPPING (1 << 6)\n#endif\n\n/* Disallow creating instances of the type: set tp_new to NULL and don't create\n * the \"__new__\" key in the type dictionary. */\n#define Py_TPFLAGS_DISALLOW_INSTANTIATION (1UL << 7)\n\n/* Set if the type object is immutable: type attributes cannot be set nor deleted */\n#define Py_TPFLAGS_IMMUTABLETYPE (1UL << 8)\n\n/* Set if the type object is dynamically allocated */\n#define Py_TPFLAGS_HEAPTYPE (1UL << 9)\n\n/* Set if the type allows subclassing */\n#define Py_TPFLAGS_BASETYPE (1UL << 10)\n\n/* Set if the type implements the vectorcall protocol (PEP 590) */\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\n#define Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)\n#ifndef Py_LIMITED_API\n// Backwards compatibility alias for API that was provisional in Python 3.8\n#define _Py_TPFLAGS_HAVE_VECTORCALL Py_TPFLAGS_HAVE_VECTORCALL\n#endif\n#endif\n\n/* Set if the type is 'ready' -- fully initialized */\n#define Py_TPFLAGS_READY (1UL << 12)\n\n/* Set while the type is being 'readied', to prevent recursive ready calls */\n#define Py_TPFLAGS_READYING (1UL << 13)\n\n/* Objects support garbage collection (see objimpl.h) */\n#define Py_TPFLAGS_HAVE_GC (1UL << 14)\n\n/* These two bits are preserved for Stackless Python, next after this is 17 */\n#ifdef STACKLESS\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)\n#else\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0\n#endif\n\n/* Objects behave like an unbound method */\n#define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)\n\n/* Unused. Legacy flag */\n#define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)\n\n/* Type is abstract and cannot be instantiated */\n#define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)\n\n// This undocumented flag gives certain built-ins their unique pattern-matching\n// behavior, which allows a single positional subpattern to match against the\n// subject itself (rather than a mapped attribute on it):\n#define _Py_TPFLAGS_MATCH_SELF (1UL << 22)\n\n/* Items (ob_size*tp_itemsize) are found at the end of an instance's memory */\n#define Py_TPFLAGS_ITEMS_AT_END (1UL << 23)\n\n/* These flags are used to determine if a type is a subclass. */\n#define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)\n#define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)\n#define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)\n#define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)\n#define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)\n#define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)\n#define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)\n#define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)\n\n#define Py_TPFLAGS_DEFAULT  ( \\\n                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \\\n                0)\n\n/* NOTE: Some of the following flags reuse lower bits (removed as part of the\n * Python 3.0 transition). */\n\n/* The following flags are kept for compatibility; in previous\n * versions they indicated presence of newer tp_* fields on the\n * type struct.\n * Starting with 3.8, binary compatibility of C extensions across\n * feature releases of Python is not supported anymore (except when\n * using the stable ABI, in which all classes are created dynamically,\n * using the interpreter's memory layout.)\n * Note that older extensions using the stable ABI set these flags,\n * so the bits must not be repurposed.\n */\n#define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)\n#define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)\n\n\n/*\nThe macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement\nreference counts.  Py_DECREF calls the object's deallocator function when\nthe refcount falls to 0; for\nobjects that don't contain references to other objects or heap memory\nthis can be the standard function free().  Both macros can be used\nwherever a void expression is allowed.  The argument must not be a\nNULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.\nThe macro _Py_NewReference(op) initialize reference counts to 1, and\nin special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional\nbookkeeping appropriate to the special build.\n\nWe assume that the reference count field can never overflow; this can\nbe proven when the size of the field is the same as the pointer size, so\nwe ignore the possibility.  Provided a C int is at least 32 bits (which\nis implicitly assumed in many parts of this code), that's enough for\nabout 2**31 references to an object.\n\nXXX The following became out of date in Python 2.2, but I'm not sure\nXXX what the full truth is now.  Certainly, heap-allocated type objects\nXXX can and should be deallocated.\nType objects should never be deallocated; the type pointer in an object\nis not considered to be a reference to the type object, to save\ncomplications in the deallocation function.  (This is actually a\ndecision that's up to the implementer of each new type so if you want,\nyou can count such references to the type object.)\n*/\n\n#if defined(Py_REF_DEBUG) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,\n                                      PyObject *op);\nPyAPI_FUNC(void) _Py_INCREF_IncRefTotal(void);\nPyAPI_FUNC(void) _Py_DECREF_DecRefTotal(void);\n#endif  // Py_REF_DEBUG && !Py_LIMITED_API\n\nPyAPI_FUNC(void) _Py_Dealloc(PyObject *);\n\n/*\nThese are provided as conveniences to Python runtime embedders, so that\nthey can have object code that is not dependent on Python compilation flags.\n*/\nPyAPI_FUNC(void) Py_IncRef(PyObject *);\nPyAPI_FUNC(void) Py_DecRef(PyObject *);\n\n// Similar to Py_IncRef() and Py_DecRef() but the argument must be non-NULL.\n// Private functions used by Py_INCREF() and Py_DECREF().\nPyAPI_FUNC(void) _Py_IncRef(PyObject *);\nPyAPI_FUNC(void) _Py_DecRef(PyObject *);\n\nstatic inline Py_ALWAYS_INLINE void Py_INCREF(PyObject *op)\n{\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n    // Stable ABI implements Py_INCREF() as a function call on limited C API\n    // version 3.12 and newer, and on Python built in debug mode. _Py_IncRef()\n    // was added to Python 3.10.0a7, use Py_IncRef() on older Python versions.\n    // Py_IncRef() accepts NULL whereas _Py_IncRef() doesn't.\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_IncRef(op);\n#  else\n    Py_IncRef(op);\n#  endif\n#else\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n#if defined(Py_GIL_DISABLED)\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    uint32_t new_local = local + 1;\n    if (new_local == 0) {\n        // local is equal to _Py_IMMORTAL_REFCNT: do nothing\n        return;\n    }\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, new_local);\n    }\n    else {\n        _Py_atomic_add_ssize(&op->ob_ref_shared, (1 << _Py_REF_SHARED_SHIFT));\n    }\n#elif SIZEOF_VOID_P > 4\n    // Portable saturated add, branching on the carry flag and set low bits\n    PY_UINT32_T cur_refcnt = op->ob_refcnt_split[PY_BIG_ENDIAN];\n    PY_UINT32_T new_refcnt = cur_refcnt + 1;\n    if (new_refcnt == 0) {\n        // cur_refcnt is equal to _Py_IMMORTAL_REFCNT: the object is immortal,\n        // do nothing\n        return;\n    }\n    op->ob_refcnt_split[PY_BIG_ENDIAN] = new_refcnt;\n#else\n    // Explicitly check immortality against the immortal value\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    op->ob_refcnt++;\n#endif\n    _Py_INCREF_STAT_INC();\n#ifdef Py_REF_DEBUG\n    _Py_INCREF_IncRefTotal();\n#endif\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_INCREF(op) Py_INCREF(_PyObject_CAST(op))\n#endif\n\n\n#if !defined(Py_LIMITED_API) && defined(Py_GIL_DISABLED)\n// Implements Py_DECREF on objects not owned by the current thread.\nPyAPI_FUNC(void) _Py_DecRefShared(PyObject *);\nPyAPI_FUNC(void) _Py_DecRefSharedDebug(PyObject *, const char *, int);\n\n// Called from Py_DECREF by the owning thread when the local refcount reaches\n// zero. The call will deallocate the object if the shared refcount is also\n// zero. Otherwise, the thread gives up ownership and merges the reference\n// count fields.\nPyAPI_FUNC(void) _Py_MergeZeroLocalRefcount(PyObject *);\n#endif\n\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n// Stable ABI implements Py_DECREF() as a function call on limited C API\n// version 3.12 and newer, and on Python built in debug mode. _Py_DecRef() was\n// added to Python 3.10.0a7, use Py_DecRef() on older Python versions.\n// Py_DecRef() accepts NULL whereas _Py_IncRef() doesn't.\nstatic inline void Py_DECREF(PyObject *op) {\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_DecRef(op);\n#  else\n    Py_DecRef(op);\n#  endif\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_GIL_DISABLED) && defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        if (local == 0) {\n            _Py_NegativeRefcount(filename, lineno, op);\n        }\n        local--;\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, local);\n        if (local == 0) {\n            _Py_MergeZeroLocalRefcount(op);\n        }\n    }\n    else {\n        _Py_DecRefSharedDebug(op, filename, lineno);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#elif defined(Py_GIL_DISABLED)\nstatic inline void Py_DECREF(PyObject *op)\n{\n    uint32_t local = _Py_atomic_load_uint32_relaxed(&op->ob_ref_local);\n    if (local == _Py_IMMORTAL_REFCNT_LOCAL) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (_Py_IsOwnedByCurrentThread(op)) {\n        local--;\n        _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, local);\n        if (local == 0) {\n            _Py_MergeZeroLocalRefcount(op);\n        }\n    }\n    else {\n        _Py_DecRefShared(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    if (op->ob_refcnt <= 0) {\n        _Py_NegativeRefcount(filename, lineno, op);\n    }\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#else\nstatic inline Py_ALWAYS_INLINE void Py_DECREF(PyObject *op)\n{\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n#endif\n\n\n/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear\n * and tp_dealloc implementations.\n *\n * Note that \"the obvious\" code can be deadly:\n *\n *     Py_XDECREF(op);\n *     op = NULL;\n *\n * Typically, `op` is something like self->containee, and `self` is done\n * using its `containee` member.  In the code sequence above, suppose\n * `containee` is non-NULL with a refcount of 1.  Its refcount falls to\n * 0 on the first line, which can trigger an arbitrary amount of code,\n * possibly including finalizers (like __del__ methods or weakref callbacks)\n * coded in Python, which in turn can release the GIL and allow other threads\n * to run, etc.  Such code may even invoke methods of `self` again, or cause\n * cyclic gc to trigger, but-- oops! --self->containee still points to the\n * object being torn down, and it may be in an insane state while being torn\n * down.  This has in fact been a rich historic source of miserable (rare &\n * hard-to-diagnose) segfaulting (and other) bugs.\n *\n * The safe way is:\n *\n *      Py_CLEAR(op);\n *\n * That arranges to set `op` to NULL _before_ decref'ing, so that any code\n * triggered as a side-effect of `op` getting torn down no longer believes\n * `op` points to a valid object.\n *\n * There are cases where it's safe to use the naive code, but they're brittle.\n * For example, if `op` points to a Python integer, you know that destroying\n * one of those can't cause problems -- but in part that relies on that\n * Python integers aren't currently weakly referencable.  Best practice is\n * to use Py_CLEAR() even if you can't think of a reason for why you need to.\n *\n * gh-98724: Use a temporary variable to only evaluate the macro argument once,\n * to avoid the duplication of side effects if the argument has side effects.\n *\n * gh-99701: If the PyObject* type is used with casting arguments to PyObject*,\n * the code can be miscompiled with strict aliasing because of type punning.\n * With strict aliasing, a compiler considers that two pointers of different\n * types cannot read or write the same memory which enables optimization\n * opportunities.\n *\n * If available, use _Py_TYPEOF() to use the 'op' type for temporary variables,\n * and so avoid type punning. Otherwise, use memcpy() which causes type erasure\n * and so prevents the compiler to reuse an old cached 'op' value after\n * Py_CLEAR().\n */\n#ifdef _Py_TYPEOF\n#define Py_CLEAR(op) \\\n    do { \\\n        _Py_TYPEOF(op)* _tmp_op_ptr = &(op); \\\n        _Py_TYPEOF(op) _tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            *_tmp_op_ptr = _Py_NULL; \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#else\n#define Py_CLEAR(op) \\\n    do { \\\n        PyObject **_tmp_op_ptr = _Py_CAST(PyObject**, &(op)); \\\n        PyObject *_tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            PyObject *_null_ptr = _Py_NULL; \\\n            memcpy(_tmp_op_ptr, &_null_ptr, sizeof(PyObject*)); \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#endif\n\n\n/* Function to use in case the object pointer can be NULL: */\nstatic inline void Py_XINCREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_INCREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XINCREF(op) Py_XINCREF(_PyObject_CAST(op))\n#endif\n\nstatic inline void Py_XDECREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_DECREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XDECREF(op) Py_XDECREF(_PyObject_CAST(op))\n#endif\n\n// Create a new strong reference to an object:\n// increment the reference count of the object and return the object.\nPyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);\n\n// Similar to Py_NewRef(), but the object can be NULL.\nPyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);\n\nstatic inline PyObject* _Py_NewRef(PyObject *obj)\n{\n    Py_INCREF(obj);\n    return obj;\n}\n\nstatic inline PyObject* _Py_XNewRef(PyObject *obj)\n{\n    Py_XINCREF(obj);\n    return obj;\n}\n\n// Py_NewRef() and Py_XNewRef() are exported as functions for the stable ABI.\n// Names overridden with macros by static inline functions for best\n// performances.\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_NewRef(obj) _Py_NewRef(_PyObject_CAST(obj))\n#  define Py_XNewRef(obj) _Py_XNewRef(_PyObject_CAST(obj))\n#else\n#  define Py_NewRef(obj) _Py_NewRef(obj)\n#  define Py_XNewRef(obj) _Py_XNewRef(obj)\n#endif\n\n\n#define Py_CONSTANT_NONE 0\n#define Py_CONSTANT_FALSE 1\n#define Py_CONSTANT_TRUE 2\n#define Py_CONSTANT_ELLIPSIS 3\n#define Py_CONSTANT_NOT_IMPLEMENTED 4\n#define Py_CONSTANT_ZERO 5\n#define Py_CONSTANT_ONE 6\n#define Py_CONSTANT_EMPTY_STR 7\n#define Py_CONSTANT_EMPTY_BYTES 8\n#define Py_CONSTANT_EMPTY_TUPLE 9\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(PyObject*) Py_GetConstant(unsigned int constant_id);\nPyAPI_FUNC(PyObject*) Py_GetConstantBorrowed(unsigned int constant_id);\n#endif\n\n\n/*\n_Py_NoneStruct is an object of undefined type which can be used in contexts\nwhere NULL (nil) is not suitable (since NULL often means 'error').\n*/\nPyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000\n#  define Py_None Py_GetConstantBorrowed(Py_CONSTANT_NONE)\n#else\n#  define Py_None (&_Py_NoneStruct)\n#endif\n\n// Test if an object is the None singleton, the same as \"x is None\" in Python.\nPyAPI_FUNC(int) Py_IsNone(PyObject *x);\n#define Py_IsNone(x) Py_Is((x), Py_None)\n\n/* Macro for returning Py_None from a function */\n#define Py_RETURN_NONE return Py_None\n\n/*\nPy_NotImplemented is a singleton used to signal that an operation is\nnot implemented for a given type combination.\n*/\nPyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */\n\n#if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000\n#  define Py_NotImplemented Py_GetConstantBorrowed(Py_CONSTANT_NOT_IMPLEMENTED)\n#else\n#  define Py_NotImplemented (&_Py_NotImplementedStruct)\n#endif\n\n/* Macro for returning Py_NotImplemented from a function */\n#define Py_RETURN_NOTIMPLEMENTED return Py_NotImplemented\n\n/* Rich comparison opcodes */\n#define Py_LT 0\n#define Py_LE 1\n#define Py_EQ 2\n#define Py_NE 3\n#define Py_GT 4\n#define Py_GE 5\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000\n/* Result of calling PyIter_Send */\ntypedef enum {\n    PYGEN_RETURN = 0,\n    PYGEN_ERROR = -1,\n    PYGEN_NEXT = 1,\n} PySendResult;\n#endif\n\n/*\n * Macro for implementing rich comparisons\n *\n * Needs to be a macro because any C-comparable type can be used.\n */\n#define Py_RETURN_RICHCOMPARE(val1, val2, op)                               \\\n    do {                                                                    \\\n        switch (op) {                                                       \\\n        case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        default:                                                            \\\n            Py_UNREACHABLE();                                               \\\n        }                                                                   \\\n    } while (0)\n\n\n/*\nMore conventions\n================\n\nArgument Checking\n-----------------\n\nFunctions that take objects as arguments normally don't check for nil\narguments, but they do check the type of the argument, and return an\nerror if the function doesn't apply to the type.\n\nFailure Modes\n-------------\n\nFunctions may fail for a variety of reasons, including running out of\nmemory.  This is communicated to the caller in two ways: an error string\nis set (see errors.h), and the function result differs: functions that\nnormally return a pointer return NULL for failure, functions returning\nan integer return -1 (which could be a legal return value too!), and\nother functions return 0 for success and -1 for failure.\nCallers should always check for errors before using the result.  If\nan error was set, the caller must either explicitly clear it, or pass\nthe error on to its caller.\n\nReference Counts\n----------------\n\nIt takes a while to get used to the proper usage of reference counts.\n\nFunctions that create an object set the reference count to 1; such new\nobjects must be stored somewhere or destroyed again with Py_DECREF().\nSome functions that 'store' objects, such as PyTuple_SetItem() and\nPyList_SetItem(),\ndon't increment the reference count of the object, since the most\nfrequent use is to store a fresh object.  Functions that 'retrieve'\nobjects, such as PyTuple_GetItem() and PyDict_GetItemString(), also\ndon't increment\nthe reference count, since most frequently the object is only looked at\nquickly.  Thus, to retrieve an object and store it again, the caller\nmust call Py_INCREF() explicitly.\n\nNOTE: functions that 'consume' a reference count, like\nPyList_SetItem(), consume the reference even if the object wasn't\nsuccessfully stored, to simplify error handling.\n\nIt seems attractive to make other functions that take an object as\nargument consume a reference count; however, this may quickly get\nconfusing (even the current practice is already confusing).  Consider\nit carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at\ntimes.\n*/\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_OBJECT_H\n#  include \"cpython/object.h\"\n#  undef Py_CPYTHON_OBJECT_H\n#endif\n\n\nstatic inline int\nPyType_HasFeature(PyTypeObject *type, unsigned long feature)\n{\n    unsigned long flags;\n#ifdef Py_LIMITED_API\n    // PyTypeObject is opaque in the limited C API\n    flags = PyType_GetFlags(type);\n#else\n#   ifdef Py_GIL_DISABLED\n        flags = _Py_atomic_load_ulong_relaxed(&type->tp_flags);\n#   else\n        flags = type->tp_flags;\n#   endif\n#endif\n    return ((flags & feature) != 0);\n}\n\n#define PyType_FastSubclass(type, flag) PyType_HasFeature((type), (flag))\n\nstatic inline int PyType_Check(PyObject *op) {\n    return PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_Check(op) PyType_Check(_PyObject_CAST(op))\n#endif\n\n#define _PyType_CAST(op) \\\n    (assert(PyType_Check(op)), _Py_CAST(PyTypeObject*, (op)))\n\nstatic inline int PyType_CheckExact(PyObject *op) {\n    return Py_IS_TYPE(op, &PyType_Type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_CheckExact(op) PyType_CheckExact(_PyObject_CAST(op))\n#endif\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000\nPyAPI_FUNC(PyObject *) PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif   // !Py_OBJECT_H\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-null-argument",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 26398,
                                       "gcc/analyzer/saved_diagnostic/snode": 992,
                                       "gcc/analyzer/saved_diagnostic/sval": "(char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 19},
                        "level": "warning",
                        "message": {"text": "use of NULL where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 865,
                                                                       "startColumn": 9,
                                                                       "endLine": 866,
                                                                       "endColumn": 53},
                                                            "contextRegion": {"startLine": 865,
                                                                              "endLine": 866,
                                                                              "snippet": {"text": "        memcpy(np->ob_item, a->ob_item + ilow * a->ob_descr->itemsize,\n               (ihigh-ilow) * a->ob_descr->itemsize);\n"}}},
                                       "logicalLocations": [{"name": "array_slice",
                                                             "fullyQualifiedName": "array_slice",
                                                             "decoratedName": "array_slice",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 846,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 12},
                                                                                                         "contextRegion": {"startLine": 846,
                                                                                                                           "snippet": {"text": "array_slice(arrayobject *a, Py_ssize_t ilow, Py_ssize_t ihigh)\n"}}},
                                                                                    "logicalLocations": [{"name": "array_slice",
                                                                                                          "fullyQualifiedName": "array_slice",
                                                                                                          "decoratedName": "array_slice",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'array_slice'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 989,
                                                                                                                                 "dst_idx": 1120,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 861,
                                                                                                                    "startColumn": 26,
                                                                                                                    "endColumn": 85},
                                                                                                         "contextRegion": {"startLine": 861,
                                                                                                                           "snippet": {"text": "    np = (arrayobject *) newarrayobject(state->ArrayType, ihigh - ilow, a->ob_descr);\n"}}},
                                                                                    "logicalLocations": [{"name": "array_slice",
                                                                                                          "fullyQualifiedName": "array_slice",
                                                                                                          "decoratedName": "array_slice",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'newarrayobject' from 'array_slice'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 616,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 616,
                                                                                                                           "snippet": {"text": "newarrayobject(PyTypeObject *type, Py_ssize_t size, const struct arraydescr *descr)\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'newarrayobject'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1121,
                                                                                                                                 "dst_idx": 1124,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 621,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 621,
                                                                                                                           "snippet": {"text": "    if (size < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'size >= 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1121,
                                                                                                                                 "dst_idx": 1124,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 627,
                                                                                                                    "startColumn": 33,
                                                                                                                    "endColumn": 48},
                                                                                                         "contextRegion": {"startLine": 627,
                                                                                                                           "snippet": {"text": "    if (size > PY_SSIZE_T_MAX / descr->itemsize) {\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1124,
                                                                                                                                 "dst_idx": 1126,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 627,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 627,
                                                                                                                           "snippet": {"text": "    if (size > PY_SSIZE_T_MAX / descr->itemsize) {\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1124,
                                                                                                                                 "dst_idx": 1126,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 630,
                                                                                                                    "startColumn": 14,
                                                                                                                    "endColumn": 36},
                                                                                                         "contextRegion": {"startLine": 630,
                                                                                                                           "snippet": {"text": "    nbytes = size * descr->itemsize;\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1127,
                                                                                                                                 "dst_idx": 1128,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 632,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 632,
                                                                                                                           "snippet": {"text": "    if (op == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'op' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1127,
                                                                                                                                 "dst_idx": 1128,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 635,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 25},
                                                                                                         "contextRegion": {"startLine": 635,
                                                                                                                           "snippet": {"text": "    op->ob_descr = descr;\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1128,
                                                                                                                                 "dst_idx": 1129,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 639,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 639,
                                                                                                                           "snippet": {"text": "    if (size <= 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'size == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1128,
                                                                                                                                 "dst_idx": 1129,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 640,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 24},
                                                                                                         "contextRegion": {"startLine": 640,
                                                                                                                           "snippet": {"text": "        op->ob_item = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 640,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 24},
                                                                                                         "contextRegion": {"startLine": 640,
                                                                                                                           "snippet": {"text": "        op->ob_item = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'*op.ob_item' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 1139,
                                                                                                                                 "dst_idx": 990,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 861,
                                                                                                                    "startColumn": 26,
                                                                                                                    "endColumn": 85},
                                                                                                         "contextRegion": {"startLine": 861,
                                                                                                                           "snippet": {"text": "    np = (arrayobject *) newarrayobject(state->ArrayType, ihigh - ilow, a->ob_descr);\n"}}},
                                                                                    "logicalLocations": [{"name": "array_slice",
                                                                                                          "fullyQualifiedName": "array_slice",
                                                                                                          "decoratedName": "array_slice",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'array_slice' from 'newarrayobject'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 990,
                                                                                                                                 "dst_idx": 991,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 862,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 862,
                                                                                                                           "snippet": {"text": "    if (np == NULL)\n"}}},
                                                                                    "logicalLocations": [{"name": "array_slice",
                                                                                                          "fullyQualifiedName": "array_slice",
                                                                                                          "decoratedName": "array_slice",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'np' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 990,
                                                                                                                                 "dst_idx": 991,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 864,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 864,
                                                                                                                           "snippet": {"text": "    if (ihigh > ilow) {\n"}}},
                                                                                    "logicalLocations": [{"name": "array_slice",
                                                                                                          "fullyQualifiedName": "array_slice",
                                                                                                          "decoratedName": "array_slice",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 991,
                                                                                                                                 "dst_idx": 992,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 864,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 864,
                                                                                                                           "snippet": {"text": "    if (ihigh > ilow) {\n"}}},
                                                                                    "logicalLocations": [{"name": "array_slice",
                                                                                                          "fullyQualifiedName": "array_slice",
                                                                                                          "decoratedName": "array_slice",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'ilow < ihigh')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 991,
                                                                                                                                 "dst_idx": 992,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 866,
                                                                                                                    "startColumn": 31,
                                                                                                                    "endColumn": 42},
                                                                                                         "contextRegion": {"startLine": 866,
                                                                                                                           "snippet": {"text": "               (ihigh-ilow) * a->ob_descr->itemsize);\n"}}},
                                                                                    "logicalLocations": [{"name": "array_slice",
                                                                                                          "fullyQualifiedName": "array_slice",
                                                                                                          "decoratedName": "array_slice",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 865,
                                                                                                                    "startColumn": 16,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 865,
                                                                                                                           "snippet": {"text": "        memcpy(np->ob_item, a->ob_item + ilow * a->ob_descr->itemsize,\n"}}},
                                                                                    "logicalLocations": [{"name": "array_slice",
                                                                                                          "fullyQualifiedName": "array_slice",
                                                                                                          "decoratedName": "array_slice",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'*np.ob_item' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 865,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endLine": 866,
                                                                                                                    "endColumn": 53},
                                                                                                         "contextRegion": {"startLine": 865,
                                                                                                                           "endLine": 866,
                                                                                                                           "snippet": {"text": "        memcpy(np->ob_item, a->ob_item + ilow * a->ob_descr->itemsize,\n               (ihigh-ilow) * a->ob_descr->itemsize);\n"}}},
                                                                                    "logicalLocations": [{"name": "array_slice",
                                                                                                          "fullyQualifiedName": "array_slice",
                                                                                                          "decoratedName": "array_slice",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('*np.ob_item') NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 19}]}]}],
                        "relatedLocations": [{"message": {"text": "argument 1 of '__builtin_memcpy' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-null-argument",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 25997,
                                       "gcc/analyzer/saved_diagnostic/snode": 974,
                                       "gcc/analyzer/saved_diagnostic/sval": "(char *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 17},
                        "level": "warning",
                        "message": {"text": "use of NULL where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 942,
                                                                       "startColumn": 9,
                                                                       "endColumn": 74},
                                                            "contextRegion": {"startLine": 942,
                                                                              "snippet": {"text": "        memcpy(np->ob_item, a->ob_item, Py_SIZE(a)*a->ob_descr->itemsize);\n"}}},
                                       "logicalLocations": [{"name": "array_concat",
                                                             "fullyQualifiedName": "array_concat",
                                                             "decoratedName": "array_concat",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 917,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 917,
                                                                                                                           "snippet": {"text": "array_concat(arrayobject *a, PyObject *bb)\n"}}},
                                                                                    "logicalLocations": [{"name": "array_concat",
                                                                                                          "fullyQualifiedName": "array_concat",
                                                                                                          "decoratedName": "array_concat",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'array_concat'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 967,
                                                                                                                                 "dst_idx": 969,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 929,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 929,
                                                                                                                           "snippet": {"text": "    if (a->ob_descr != b->ob_descr) {\n"}}},
                                                                                    "logicalLocations": [{"name": "array_concat",
                                                                                                          "fullyQualifiedName": "array_concat",
                                                                                                          "decoratedName": "array_concat",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 933,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 933,
                                                                                                                           "snippet": {"text": "    if (Py_SIZE(a) > PY_SSIZE_T_MAX - Py_SIZE(b)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "array_concat",
                                                                                                          "fullyQualifiedName": "array_concat",
                                                                                                          "decoratedName": "array_concat",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'Py_SIZE' from 'array_concat'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "array_concat",
                                                                                                                                     "fullyQualifiedName": "array_concat",
                                                                                                                                     "decoratedName": "array_concat",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 1,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 967,
                                                                                                                                 "dst_idx": 969,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 343,
                                                                                                                    "startColumn": 13,
                                                                                                                    "endColumn": 43},
                                                                                                         "contextRegion": {"startLine": 343,
                                                                                                                           "snippet": {"text": "    return  _PyVarObject_CAST(ob)->ob_size;\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_SIZE",
                                                                                                          "fullyQualifiedName": "Py_SIZE",
                                                                                                          "decoratedName": "Py_SIZE",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 969,
                                                                                                                                 "dst_idx": 971,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 933,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 933,
                                                                                                                           "snippet": {"text": "    if (Py_SIZE(a) > PY_SSIZE_T_MAX - Py_SIZE(b)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "array_concat",
                                                                                                          "fullyQualifiedName": "array_concat",
                                                                                                          "decoratedName": "array_concat",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 969,
                                                                                                                                 "dst_idx": 971,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 936,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 26},
                                                                                                         "contextRegion": {"startLine": 936,
                                                                                                                           "snippet": {"text": "    size = Py_SIZE(a) + Py_SIZE(b);\n"}}},
                                                                                    "logicalLocations": [{"name": "array_concat",
                                                                                                          "fullyQualifiedName": "array_concat",
                                                                                                          "decoratedName": "array_concat",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 971,
                                                                                                                                 "dst_idx": 1120,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 937,
                                                                                                                    "startColumn": 26,
                                                                                                                    "endColumn": 77},
                                                                                                         "contextRegion": {"startLine": 937,
                                                                                                                           "snippet": {"text": "    np = (arrayobject *) newarrayobject(state->ArrayType, size, a->ob_descr);\n"}}},
                                                                                    "logicalLocations": [{"name": "array_concat",
                                                                                                          "fullyQualifiedName": "array_concat",
                                                                                                          "decoratedName": "array_concat",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'newarrayobject' from 'array_concat'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 616,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 616,
                                                                                                                           "snippet": {"text": "newarrayobject(PyTypeObject *type, Py_ssize_t size, const struct arraydescr *descr)\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'newarrayobject'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1121,
                                                                                                                                 "dst_idx": 1124,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 621,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 621,
                                                                                                                           "snippet": {"text": "    if (size < 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'size >= 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1121,
                                                                                                                                 "dst_idx": 1124,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 627,
                                                                                                                    "startColumn": 33,
                                                                                                                    "endColumn": 48},
                                                                                                         "contextRegion": {"startLine": 627,
                                                                                                                           "snippet": {"text": "    if (size > PY_SSIZE_T_MAX / descr->itemsize) {\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1124,
                                                                                                                                 "dst_idx": 1126,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 627,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 627,
                                                                                                                           "snippet": {"text": "    if (size > PY_SSIZE_T_MAX / descr->itemsize) {\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1124,
                                                                                                                                 "dst_idx": 1126,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 630,
                                                                                                                    "startColumn": 14,
                                                                                                                    "endColumn": 36},
                                                                                                         "contextRegion": {"startLine": 630,
                                                                                                                           "snippet": {"text": "    nbytes = size * descr->itemsize;\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1127,
                                                                                                                                 "dst_idx": 1128,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 632,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 632,
                                                                                                                           "snippet": {"text": "    if (op == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'op' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1127,
                                                                                                                                 "dst_idx": 1128,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 635,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 25},
                                                                                                         "contextRegion": {"startLine": 635,
                                                                                                                           "snippet": {"text": "    op->ob_descr = descr;\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1128,
                                                                                                                                 "dst_idx": 1129,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 639,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 639,
                                                                                                                           "snippet": {"text": "    if (size <= 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'size == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1128,
                                                                                                                                 "dst_idx": 1129,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 640,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 24},
                                                                                                         "contextRegion": {"startLine": 640,
                                                                                                                           "snippet": {"text": "        op->ob_item = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 640,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 24},
                                                                                                         "contextRegion": {"startLine": 640,
                                                                                                                           "snippet": {"text": "        op->ob_item = NULL;\n"}}},
                                                                                    "logicalLocations": [{"name": "newarrayobject",
                                                                                                          "fullyQualifiedName": "newarrayobject",
                                                                                                          "decoratedName": "newarrayobject",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'*op.ob_item' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 1139,
                                                                                                                                 "dst_idx": 972,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 937,
                                                                                                                    "startColumn": 26,
                                                                                                                    "endColumn": 77},
                                                                                                         "contextRegion": {"startLine": 937,
                                                                                                                           "snippet": {"text": "    np = (arrayobject *) newarrayobject(state->ArrayType, size, a->ob_descr);\n"}}},
                                                                                    "logicalLocations": [{"name": "array_concat",
                                                                                                          "fullyQualifiedName": "array_concat",
                                                                                                          "decoratedName": "array_concat",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'array_concat' from 'newarrayobject'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 972,
                                                                                                                                 "dst_idx": 973,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 938,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 938,
                                                                                                                           "snippet": {"text": "    if (np == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "array_concat",
                                                                                                          "fullyQualifiedName": "array_concat",
                                                                                                          "decoratedName": "array_concat",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'np' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 941,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 941,
                                                                                                                           "snippet": {"text": "    if (Py_SIZE(a) > 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "array_concat",
                                                                                                          "fullyQualifiedName": "array_concat",
                                                                                                          "decoratedName": "array_concat",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'Py_SIZE' from 'array_concat'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "array_concat",
                                                                                                                                     "fullyQualifiedName": "array_concat",
                                                                                                                                     "decoratedName": "array_concat",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 1,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 972,
                                                                                                                                 "dst_idx": 973,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 343,
                                                                                                                    "startColumn": 13,
                                                                                                                    "endColumn": 43},
                                                                                                         "contextRegion": {"startLine": 343,
                                                                                                                           "snippet": {"text": "    return  _PyVarObject_CAST(ob)->ob_size;\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_SIZE",
                                                                                                          "fullyQualifiedName": "Py_SIZE",
                                                                                                          "decoratedName": "Py_SIZE",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 973,
                                                                                                                                 "dst_idx": 974,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 941,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 941,
                                                                                                                           "snippet": {"text": "    if (Py_SIZE(a) > 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "array_concat",
                                                                                                          "fullyQualifiedName": "array_concat",
                                                                                                          "decoratedName": "array_concat",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 22},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(23)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 973,
                                                                                                                                 "dst_idx": 974,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 942,
                                                                                                                    "startColumn": 52,
                                                                                                                    "endColumn": 63},
                                                                                                         "contextRegion": {"startLine": 942,
                                                                                                                           "snippet": {"text": "        memcpy(np->ob_item, a->ob_item, Py_SIZE(a)*a->ob_descr->itemsize);\n"}}},
                                                                                    "logicalLocations": [{"name": "array_concat",
                                                                                                          "fullyQualifiedName": "array_concat",
                                                                                                          "decoratedName": "array_concat",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 23},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(24)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 942,
                                                                                                                    "startColumn": 16,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 942,
                                                                                                                           "snippet": {"text": "        memcpy(np->ob_item, a->ob_item, Py_SIZE(a)*a->ob_descr->itemsize);\n"}}},
                                                                                    "logicalLocations": [{"name": "array_concat",
                                                                                                          "fullyQualifiedName": "array_concat",
                                                                                                          "decoratedName": "array_concat",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'*np.ob_item' is NULL"}},
                                                                       "kinds": ["release",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 24},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(25)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/arraymodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 942,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 74},
                                                                                                         "contextRegion": {"startLine": 942,
                                                                                                                           "snippet": {"text": "        memcpy(np->ob_item, a->ob_item, Py_SIZE(a)*a->ob_descr->itemsize);\n"}}},
                                                                                    "logicalLocations": [{"name": "array_concat",
                                                                                                          "fullyQualifiedName": "array_concat",
                                                                                                          "decoratedName": "array_concat",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('*np.ob_item') NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 25}]}]}],
                        "relatedLocations": [{"message": {"text": "argument 1 of '__builtin_memcpy' must be non-null"}}]}]}]}
