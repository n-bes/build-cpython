{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-fd-leak",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-fd-leak"}]}},
           "taxonomies": [{"name": "CWE",
                           "version": "4.7",
                           "organization": "MITRE",
                           "shortDescription": {"text": "The MITRE Common Weakness Enumeration"},
                           "taxa": [{"id": "775",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/775.html"}]}],
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.13.0b4/"}},
           "artifacts": [{"location": {"uri": "./Modules/socketmodule.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/* Socket module */\n\n/*\n\nThis module provides an interface to Berkeley socket IPC.\n\nLimitations:\n\n- Only AF_INET, AF_INET6 and AF_UNIX address families are supported in a\n  portable manner, though AF_PACKET, AF_NETLINK, AF_QIPCRTR and AF_TIPC are\n  supported under Linux.\n- No read/write operations (use sendall/recv or makefile instead).\n- Additional restrictions apply on some non-Unix platforms (compensated\n  for by socket.py).\n\nModule interface:\n\n- socket.error: exception raised for socket specific errors, alias for OSError\n- socket.gaierror: exception raised for getaddrinfo/getnameinfo errors,\n    a subclass of socket.error\n- socket.herror: exception raised for gethostby* errors,\n    a subclass of socket.error\n- socket.gethostbyname(hostname) --> host IP address (string: 'dd.dd.dd.dd')\n- socket.gethostbyaddr(IP address) --> (hostname, [alias, ...], [IP addr, ...])\n- socket.gethostname() --> host name (string: 'spam' or 'spam.domain.com')\n- socket.getprotobyname(protocolname) --> protocol number\n- socket.getservbyname(servicename[, protocolname]) --> port number\n- socket.getservbyport(portnumber[, protocolname]) --> service name\n- socket.socket([family[, type [, proto, fileno]]]) --> new socket object\n    (fileno specifies a pre-existing socket file descriptor)\n- socket.socketpair([family[, type [, proto]]]) --> (socket, socket)\n- socket.ntohs(16 bit value) --> new int object\n- socket.ntohl(32 bit value) --> new int object\n- socket.htons(16 bit value) --> new int object\n- socket.htonl(32 bit value) --> new int object\n- socket.getaddrinfo(host, port [, family, type, proto, flags])\n    --> List of (family, type, proto, canonname, sockaddr)\n- socket.getnameinfo(sockaddr, flags) --> (host, port)\n- socket.AF_INET, socket.SOCK_STREAM, etc.: constants from <socket.h>\n- socket.has_ipv6: boolean value indicating if IPv6 is supported\n- socket.inet_aton(IP address) -> 32-bit packed IP representation\n- socket.inet_ntoa(packed IP) -> IP address string\n- socket.getdefaulttimeout() -> None | float\n- socket.setdefaulttimeout(None | float)\n- socket.if_nameindex() -> list of tuples (if_index, if_name)\n- socket.if_nametoindex(name) -> corresponding interface index\n- socket.if_indextoname(index) -> corresponding interface name\n- an internet socket address is a pair (hostname, port)\n  where hostname can be anything recognized by gethostbyname()\n  (including the dd.dd.dd.dd notation) and port is in host byte order\n- where a hostname is returned, the dd.dd.dd.dd notation is used\n- a UNIX domain socket address is a string specifying the pathname\n- an AF_PACKET socket address is a tuple containing a string\n  specifying the ethernet interface and an integer specifying\n  the Ethernet protocol number to be received. For example:\n  (\"eth0\",0x1234).  Optional 3rd,4th,5th elements in the tuple\n  specify packet-type and ha-type/addr.\n- an AF_QIPCRTR socket address is a (node, port) tuple where the\n  node and port are non-negative integers.\n- an AF_TIPC socket address is expressed as\n (addr_type, v1, v2, v3 [, scope]); where addr_type can be one of:\n    TIPC_ADDR_NAMESEQ, TIPC_ADDR_NAME, and TIPC_ADDR_ID;\n  and scope can be one of:\n    TIPC_ZONE_SCOPE, TIPC_CLUSTER_SCOPE, and TIPC_NODE_SCOPE.\n  The meaning of v1, v2 and v3 depends on the value of addr_type:\n    if addr_type is TIPC_ADDR_NAME:\n        v1 is the server type\n        v2 is the port identifier\n        v3 is ignored\n    if addr_type is TIPC_ADDR_NAMESEQ:\n        v1 is the server type\n        v2 is the lower port number\n        v3 is the upper port number\n    if addr_type is TIPC_ADDR_ID:\n        v1 is the node\n        v2 is the ref\n        v3 is ignored\n\n\nLocal naming conventions:\n\n- names starting with sock_ are socket object methods\n- names starting with socket_ are module-level functions\n- names starting with PySocket are exported through socketmodule.h\n\n*/\n\n#ifndef Py_BUILD_CORE_BUILTIN\n#  define Py_BUILD_CORE_MODULE 1\n#endif\n\n#ifdef __APPLE__\n// Issue #35569: Expose RFC 3542 socket options.\n#define __APPLE_USE_RFC_3542 1\n#include <AvailabilityMacros.h>\n/* for getaddrinfo thread safety test on old versions of OS X */\n#ifndef MAC_OS_X_VERSION_10_5\n#define MAC_OS_X_VERSION_10_5 1050\n#endif\n  /*\n   * inet_aton is not available on OSX 10.3, yet we want to use a binary\n   * that was build on 10.4 or later to work on that release, weak linking\n   * comes to the rescue.\n   */\n# pragma weak inet_aton\n#endif\n\n#include \"Python.h\"\n#include \"pycore_capsule.h\"       // _PyCapsule_SetTraverse()\n#include \"pycore_fileutils.h\"     // _Py_set_inheritable()\n#include \"pycore_moduleobject.h\"  // _PyModule_GetState\n#include \"pycore_time.h\"          // _PyTime_AsMilliseconds()\n\n#ifdef _Py_MEMORY_SANITIZER\n#  include <sanitizer/msan_interface.h>\n#endif\n\n/* Socket object documentation */\nPyDoc_STRVAR(sock_doc,\n\"socket(family=AF_INET, type=SOCK_STREAM, proto=0) -> socket object\\n\\\nsocket(family=-1, type=-1, proto=-1, fileno=None) -> socket object\\n\\\n\\n\\\nOpen a socket of the given type.  The family argument specifies the\\n\\\naddress family; it defaults to AF_INET.  The type argument specifies\\n\\\nwhether this is a stream (SOCK_STREAM, this is the default)\\n\\\nor datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,\\n\\\nspecifying the default protocol.  Keyword arguments are accepted.\\n\\\nThe socket is created as non-inheritable.\\n\\\n\\n\\\nWhen a fileno is passed in, family, type and proto are auto-detected,\\n\\\nunless they are explicitly set.\\n\\\n\\n\\\nA socket object represents one endpoint of a network connection.\\n\\\n\\n\\\nMethods of socket objects (keyword arguments not allowed):\\n\\\n\\n\\\n_accept() -- accept connection, returning new socket fd and client address\\n\\\nbind(addr) -- bind the socket to a local address\\n\\\nclose() -- close the socket\\n\\\nconnect(addr) -- connect the socket to a remote address\\n\\\nconnect_ex(addr) -- connect, return an error code instead of an exception\\n\\\ndup() -- return a new socket fd duplicated from fileno()\\n\\\nfileno() -- return underlying file descriptor\\n\\\ngetpeername() -- return remote address [*]\\n\\\ngetsockname() -- return local address\\n\\\ngetsockopt(level, optname[, buflen]) -- get socket options\\n\\\ngettimeout() -- return timeout or None\\n\\\nlisten([n]) -- start listening for incoming connections\\n\\\nrecv(buflen[, flags]) -- receive data\\n\\\nrecv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)\\n\\\nrecvfrom(buflen[, flags]) -- receive data and sender\\'s address\\n\\\nrecvfrom_into(buffer[, nbytes, [, flags])\\n\\\n  -- receive data and sender\\'s address (into a buffer)\\n\\\nsendall(data[, flags]) -- send all data\\n\\\nsend(data[, flags]) -- send data, may not send all of it\\n\\\nsendto(data[, flags], addr) -- send data to a given address\\n\\\nsetblocking(bool) -- set or clear the blocking I/O flag\\n\\\ngetblocking() -- return True if socket is blocking, False if non-blocking\\n\\\nsetsockopt(level, optname, value[, optlen]) -- set socket options\\n\\\nsettimeout(None | float) -- set or clear the timeout\\n\\\nshutdown(how) -- shut down traffic in one or both directions\\n\\\n\\n\\\n [*] not available on all platforms!\");\n\n/* XXX This is a terrible mess of platform-dependent preprocessor hacks.\n   I hope some day someone can clean this up please... */\n\n/* Hacks for gethostbyname_r().  On some non-Linux platforms, the configure\n   script doesn't get this right, so we hardcode some platform checks below.\n   On the other hand, not all Linux versions agree, so there the settings\n   computed by the configure script are needed! */\n\n#ifndef __linux__\n# undef HAVE_GETHOSTBYNAME_R_3_ARG\n# undef HAVE_GETHOSTBYNAME_R_5_ARG\n# undef HAVE_GETHOSTBYNAME_R_6_ARG\n#endif\n\n#if defined(__OpenBSD__)\n# include <sys/uio.h>\n#endif\n\n#if defined(__ANDROID__) && __ANDROID_API__ < 23\n# undef HAVE_GETHOSTBYNAME_R\n#endif\n\n#ifdef HAVE_GETHOSTBYNAME_R\n# if defined(_AIX) && !defined(_LINUX_SOURCE_COMPAT)\n#  define HAVE_GETHOSTBYNAME_R_3_ARG\n# elif defined(__sun) || defined(__sgi)\n#  define HAVE_GETHOSTBYNAME_R_5_ARG\n# elif defined(__linux__)\n/* Rely on the configure script */\n# elif defined(_LINUX_SOURCE_COMPAT) /* Linux compatibility on AIX */\n#  define HAVE_GETHOSTBYNAME_R_6_ARG\n# else\n#  undef HAVE_GETHOSTBYNAME_R\n# endif\n#endif\n\n#if !defined(HAVE_GETHOSTBYNAME_R) && !defined(MS_WINDOWS)\n# define USE_GETHOSTBYNAME_LOCK\n#endif\n\n#if defined(__APPLE__) || defined(__CYGWIN__) || defined(__NetBSD__)\n#  include <sys/ioctl.h>\n#endif\n\n\n#if defined(__sgi) && _COMPILER_VERSION>700 && !_SGIAPI\n/* make sure that the reentrant (gethostbyaddr_r etc)\n   functions are declared correctly if compiling with\n   MIPSPro 7.x in ANSI C mode (default) */\n\n/* XXX Using _SGIAPI is the wrong thing,\n   but I don't know what the right thing is. */\n#undef _SGIAPI /* to avoid warning */\n#define _SGIAPI 1\n\n#undef _XOPEN_SOURCE\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifdef _SS_ALIGNSIZE\n#define HAVE_GETADDRINFO 1\n#define HAVE_GETNAMEINFO 1\n#endif\n\n#define HAVE_INET_PTON\n#include <netdb.h>\n#endif // __sgi\n\n/* Solaris fails to define this variable at all. */\n#if (defined(__sun) && defined(__SVR4)) && !defined(INET_ADDRSTRLEN)\n#define INET_ADDRSTRLEN 16\n#endif\n\n/* Generic includes */\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n\n#ifdef HAVE_NET_IF_H\n#include <net/if.h>\n#endif\n\n#ifdef HAVE_NET_ETHERNET_H\n#include <net/ethernet.h>\n#endif\n\n/* Generic socket object definitions and includes */\n#define PySocket_BUILDING_SOCKET\n#include \"socketmodule.h\"\n\n/* Addressing includes */\n\n#ifndef MS_WINDOWS\n\n/* Non-MS WINDOWS includes */\n#ifdef HAVE_NETDB_H\n#  include <netdb.h>\n#endif\n#include <unistd.h>               // close()\n\n/* Headers needed for inet_ntoa() and inet_addr() */\n#   include <arpa/inet.h>\n\n#  include <fcntl.h>\n\n#else /* MS_WINDOWS */\n\n/* MS_WINDOWS includes */\n# ifdef HAVE_FCNTL_H\n#  include <fcntl.h>\n# endif\n\n/* Helpers needed for AF_HYPERV */\n# include <Rpc.h>\n\n/* Macros based on the IPPROTO enum, see: https://bugs.python.org/issue29515 */\n#define IPPROTO_ICMP IPPROTO_ICMP\n#define IPPROTO_IGMP IPPROTO_IGMP\n#define IPPROTO_GGP IPPROTO_GGP\n#define IPPROTO_TCP IPPROTO_TCP\n#define IPPROTO_PUP IPPROTO_PUP\n#define IPPROTO_UDP IPPROTO_UDP\n#define IPPROTO_IDP IPPROTO_IDP\n#define IPPROTO_ND IPPROTO_ND\n#define IPPROTO_RAW IPPROTO_RAW\n#define IPPROTO_MAX IPPROTO_MAX\n#define IPPROTO_HOPOPTS IPPROTO_HOPOPTS\n#define IPPROTO_IPV4 IPPROTO_IPV4\n#define IPPROTO_IPV6 IPPROTO_IPV6\n#define IPPROTO_ROUTING IPPROTO_ROUTING\n#define IPPROTO_FRAGMENT IPPROTO_FRAGMENT\n#define IPPROTO_ESP IPPROTO_ESP\n#define IPPROTO_AH IPPROTO_AH\n#define IPPROTO_ICMPV6 IPPROTO_ICMPV6\n#define IPPROTO_NONE IPPROTO_NONE\n#define IPPROTO_DSTOPTS IPPROTO_DSTOPTS\n#define IPPROTO_EGP IPPROTO_EGP\n#define IPPROTO_PIM IPPROTO_PIM\n#define IPPROTO_ICLFXBM IPPROTO_ICLFXBM  // WinSock2 only\n#define IPPROTO_ST IPPROTO_ST  // WinSock2 only\n#define IPPROTO_CBT IPPROTO_CBT  // WinSock2 only\n#define IPPROTO_IGP IPPROTO_IGP  // WinSock2 only\n#define IPPROTO_RDP IPPROTO_RDP  // WinSock2 only\n#define IPPROTO_PGM IPPROTO_PGM  // WinSock2 only\n#define IPPROTO_L2TP IPPROTO_L2TP  // WinSock2 only\n#define IPPROTO_SCTP IPPROTO_SCTP  // WinSock2 only\n\n/* Provides the IsWindows7SP1OrGreater() function */\n#include <versionhelpers.h>\n// For if_nametoindex() and if_indextoname()\n#include <iphlpapi.h>\n\n/* remove some flags on older version Windows during run-time.\n   https://msdn.microsoft.com/en-us/library/windows/desktop/ms738596.aspx */\ntypedef struct {\n    DWORD build_number;  /* available starting with this Win10 BuildNumber */\n    const char flag_name[20];\n} FlagRuntimeInfo;\n\n/* IMPORTANT: make sure the list ordered by descending build_number */\nstatic FlagRuntimeInfo win_runtime_flags[] = {\n    /* available starting with Windows 10 1709 */\n    {16299, \"TCP_KEEPIDLE\"},\n    {16299, \"TCP_KEEPINTVL\"},\n    /* available starting with Windows 10 1703 */\n    {15063, \"TCP_KEEPCNT\"},\n    /* available starting with Windows 10 1607 */\n    {14393, \"TCP_FASTOPEN\"}\n};\n\n/*[clinic input]\nmodule _socket\nclass _socket.socket \"PySocketSockObject *\" \"clinic_state()->sock_type\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=2db2489bd2219fd8]*/\n\nstatic int\nremove_unusable_flags(PyObject *m)\n{\n    PyObject *dict;\n    OSVERSIONINFOEX info;\n\n    dict = PyModule_GetDict(m);\n    if (dict == NULL) {\n        return -1;\n    }\n#ifndef MS_WINDOWS_DESKTOP\n    info.dwOSVersionInfoSize = sizeof(info);\n    if (!GetVersionEx((OSVERSIONINFO*) &info)) {\n        PyErr_SetFromWindowsErr(0);\n        return -1;\n    }\n#else\n    /* set to Windows 10, except BuildNumber. */\n    memset(&info, 0, sizeof(info));\n    info.dwOSVersionInfoSize = sizeof(info);\n    info.dwMajorVersion = 10;\n    info.dwMinorVersion = 0;\n\n    /* set Condition Mask */\n    DWORDLONG dwlConditionMask = 0;\n    VER_SET_CONDITION(dwlConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL);\n    VER_SET_CONDITION(dwlConditionMask, VER_MINORVERSION, VER_GREATER_EQUAL);\n    VER_SET_CONDITION(dwlConditionMask, VER_BUILDNUMBER, VER_GREATER_EQUAL);\n#endif\n\n    for (int i=0; i<sizeof(win_runtime_flags)/sizeof(FlagRuntimeInfo); i++) {\n#ifdef MS_WINDOWS_DESKTOP\n        info.dwBuildNumber = win_runtime_flags[i].build_number;\n        /* greater than or equal to the specified version?\n           Compatibility Mode will not cheat VerifyVersionInfo(...) */\n        BOOL isSupported = VerifyVersionInfo(\n            &info,\n            VER_MAJORVERSION|VER_MINORVERSION|VER_BUILDNUMBER,\n            dwlConditionMask);\n#else\n        /* note in this case 'info' is the actual OS version, whereas above\n           it is the version to compare against. */\n        BOOL isSupported = info.dwMajorVersion > 10 ||\n            (info.dwMajorVersion == 10 && info.dwMinorVersion > 0) ||\n            (info.dwMajorVersion == 10 && info.dwMinorVersion == 0 &&\n            info.dwBuildNumber >= win_runtime_flags[i].build_number);\n#endif\n        if (isSupported) {\n            break;\n        }\n        else {\n            if (PyDict_PopString(dict, win_runtime_flags[i].flag_name,\n                                 NULL) < 0) {\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\n#endif\n\n#include <stddef.h>\n\n#ifndef O_NONBLOCK\n# define O_NONBLOCK O_NDELAY\n#endif\n\n/* include Python's addrinfo.h unless it causes trouble */\n#if defined(__sgi) && _COMPILER_VERSION>700 && defined(_SS_ALIGNSIZE)\n  /* Do not include addinfo.h on some newer IRIX versions.\n   * _SS_ALIGNSIZE is defined in sys/socket.h by 6.5.21,\n   * for example, but not by 6.5.10.\n   */\n#elif defined(_MSC_VER) && _MSC_VER>1201\n  /* Do not include addrinfo.h for MSVC7 or greater. 'addrinfo' and\n   * EAI_* constants are defined in (the already included) ws2tcpip.h.\n   */\n#else\n#  include \"addrinfo.h\"\n#endif\n\n#ifdef __APPLE__\n/* On OS X, getaddrinfo returns no error indication of lookup\n   failure, so we must use the emulation instead of the libinfo\n   implementation. Unfortunately, performing an autoconf test\n   for this bug would require DNS access for the machine performing\n   the configuration, which is not acceptable. Therefore, we\n   determine the bug just by checking for __APPLE__. If this bug\n   gets ever fixed, perhaps checking for sys/version.h would be\n   appropriate, which is 10/0 on the system with the bug. */\n#ifndef HAVE_GETNAMEINFO\n/* This bug seems to be fixed in Jaguar. The easiest way I could\n   Find to check for Jaguar is that it has getnameinfo(), which\n   older releases don't have */\n#undef HAVE_GETADDRINFO\n#endif\n\n#ifdef HAVE_INET_ATON\n#define USE_INET_ATON_WEAKLINK\n#endif\n\n#endif\n\n/* I know this is a bad practice, but it is the easiest... */\n#if !defined(HAVE_GETADDRINFO)\n/* avoid clashes with the C library definition of the symbol. */\n#define getaddrinfo fake_getaddrinfo\n#define gai_strerror fake_gai_strerror\n#define freeaddrinfo fake_freeaddrinfo\n#include \"getaddrinfo.c\"\n#endif\n\n#if !defined(HAVE_GETNAMEINFO)\n#define getnameinfo fake_getnameinfo\n#include \"getnameinfo.c\"\n#endif // HAVE_GETNAMEINFO\n\n#ifdef MS_WINDOWS\n#define SOCKETCLOSE closesocket\n#endif\n\n#ifdef MS_WIN32\n#  undef EAFNOSUPPORT\n#  define EAFNOSUPPORT WSAEAFNOSUPPORT\n#endif\n\n#ifndef SOCKETCLOSE\n#  define SOCKETCLOSE close\n#endif\n\n#if (defined(HAVE_BLUETOOTH_H) || defined(HAVE_BLUETOOTH_BLUETOOTH_H)) && !defined(__NetBSD__) && !defined(__DragonFly__)\n#define USE_BLUETOOTH 1\n#if defined(__FreeBSD__)\n#define BTPROTO_L2CAP BLUETOOTH_PROTO_L2CAP\n#define BTPROTO_RFCOMM BLUETOOTH_PROTO_RFCOMM\n#define BTPROTO_HCI BLUETOOTH_PROTO_HCI\n#define SOL_HCI SOL_HCI_RAW\n#define HCI_FILTER SO_HCI_RAW_FILTER\n#define sockaddr_l2 sockaddr_l2cap\n#define sockaddr_rc sockaddr_rfcomm\n#define hci_dev hci_node\n#define _BT_L2_MEMB(sa, memb) ((sa)->l2cap_##memb)\n#define _BT_RC_MEMB(sa, memb) ((sa)->rfcomm_##memb)\n#define _BT_HCI_MEMB(sa, memb) ((sa)->hci_##memb)\n#elif defined(__NetBSD__) || defined(__DragonFly__)\n#define sockaddr_l2 sockaddr_bt\n#define sockaddr_rc sockaddr_bt\n#define sockaddr_hci sockaddr_bt\n#define sockaddr_sco sockaddr_bt\n#define SOL_HCI BTPROTO_HCI\n#define HCI_DATA_DIR SO_HCI_DIRECTION\n#define _BT_L2_MEMB(sa, memb) ((sa)->bt_##memb)\n#define _BT_RC_MEMB(sa, memb) ((sa)->bt_##memb)\n#define _BT_HCI_MEMB(sa, memb) ((sa)->bt_##memb)\n#define _BT_SCO_MEMB(sa, memb) ((sa)->bt_##memb)\n#else\n#define _BT_L2_MEMB(sa, memb) ((sa)->l2_##memb)\n#define _BT_RC_MEMB(sa, memb) ((sa)->rc_##memb)\n#define _BT_HCI_MEMB(sa, memb) ((sa)->hci_##memb)\n#define _BT_SCO_MEMB(sa, memb) ((sa)->sco_##memb)\n#endif\n#endif\n\n#ifdef MS_WINDOWS_DESKTOP\n#define sockaddr_rc SOCKADDR_BTH_REDEF\n\n#define USE_BLUETOOTH 1\n#define AF_BLUETOOTH AF_BTH\n#define BTPROTO_RFCOMM BTHPROTO_RFCOMM\n#define _BT_RC_MEMB(sa, memb) ((sa)->memb)\n#endif /* MS_WINDOWS_DESKTOP */\n\n/* Convert \"sock_addr_t *\" to \"struct sockaddr *\". */\n#define SAS2SA(x)       (&((x)->sa))\n\n/*\n * Constants for getnameinfo()\n */\n#if !defined(NI_MAXHOST)\n#define NI_MAXHOST 1025\n#endif\n#if !defined(NI_MAXSERV)\n#define NI_MAXSERV 32\n#endif\n\n#ifndef INVALID_SOCKET /* MS defines this */\n#define INVALID_SOCKET (-1)\n#endif\n\n#ifndef INADDR_NONE\n#define INADDR_NONE (-1)\n#endif\n\ntypedef struct _socket_state {\n    /* The sock_type variable contains pointers to various functions,\n       some of which call new_sockobject(), which uses sock_type, so\n       there has to be a circular reference. */\n    PyTypeObject *sock_type;\n\n    /* Global variable holding the exception type for errors detected\n       by this module (but not argument type or memory errors, etc.). */\n    PyObject *socket_herror;\n    PyObject *socket_gaierror;\n\n    /* Default timeout for new sockets */\n    PyTime_t defaulttimeout;\n\n#if defined(HAVE_ACCEPT) || defined(HAVE_ACCEPT4)\n#if defined(HAVE_ACCEPT4) && defined(SOCK_CLOEXEC)\n    /* accept4() is available on Linux 2.6.28+ and glibc 2.10 */\n    int accept4_works;\n#endif\n#endif\n\n#ifdef SOCK_CLOEXEC\n    /* socket() and socketpair() fail with EINVAL on Linux kernel older\n     * than 2.6.27 if SOCK_CLOEXEC flag is set in the socket type. */\n    int sock_cloexec_works;\n#endif\n} socket_state;\n\nstatic inline socket_state *\nget_module_state(PyObject *mod)\n{\n    void *state = _PyModule_GetState(mod);\n    assert(state != NULL);\n    return (socket_state *)state;\n}\n\nstatic struct PyModuleDef socketmodule;\n\nstatic inline socket_state *\nfind_module_state_by_def(PyTypeObject *type)\n{\n    PyObject *mod = PyType_GetModuleByDef(type, &socketmodule);\n    assert(mod != NULL);\n    return get_module_state(mod);\n}\n\n#define clinic_state() (find_module_state_by_def(type))\n#include \"clinic/socketmodule.c.h\"\n#undef clinic_state\n\n/* XXX There's a problem here: *static* functions are not supposed to have\n   a Py prefix (or use CapitalizedWords).  Later... */\n\n#if defined(HAVE_POLL_H)\n#include <poll.h>\n#elif defined(HAVE_SYS_POLL_H)\n#include <sys/poll.h>\n#endif\n\n/* Largest value to try to store in a socklen_t (used when handling\n   ancillary data).  POSIX requires socklen_t to hold at least\n   (2**31)-1 and recommends against storing larger values, but\n   socklen_t was originally int in the BSD interface, so to be on the\n   safe side we use the smaller of (2**31)-1 and INT_MAX. */\n#if INT_MAX > 0x7fffffff\n#define SOCKLEN_T_LIMIT 0x7fffffff\n#else\n#define SOCKLEN_T_LIMIT INT_MAX\n#endif\n\n#ifdef HAVE_POLL\n/* Instead of select(), we'll use poll() since poll() works on any fd. */\n#define IS_SELECTABLE(s) 1\n/* Can we call select() with this socket without a buffer overrun? */\n#else\n/* If there's no timeout left, we don't have to call select, so it's a safe,\n * little white lie. */\n#define IS_SELECTABLE(s) (_PyIsSelectable_fd((s)->sock_fd) || (s)->sock_timeout <= 0)\n#endif\n\nstatic PyObject*\nselect_error(void)\n{\n    PyErr_SetString(PyExc_OSError, \"unable to select on socket\");\n    return NULL;\n}\n\n#ifdef MS_WINDOWS\n#ifndef WSAEAGAIN\n#define WSAEAGAIN WSAEWOULDBLOCK\n#endif\n#define CHECK_ERRNO(expected) \\\n    (WSAGetLastError() == WSA ## expected)\n#else\n#define CHECK_ERRNO(expected) \\\n    (errno == expected)\n#endif\n\n#ifdef MS_WINDOWS\n#  define GET_SOCK_ERROR WSAGetLastError()\n#  define SET_SOCK_ERROR(err) WSASetLastError(err)\n#  define SOCK_TIMEOUT_ERR WSAEWOULDBLOCK\n#  define SOCK_INPROGRESS_ERR WSAEWOULDBLOCK\n#else\n#  define GET_SOCK_ERROR errno\n#  define SET_SOCK_ERROR(err) do { errno = err; } while (0)\n#  define SOCK_TIMEOUT_ERR EWOULDBLOCK\n#  define SOCK_INPROGRESS_ERR EINPROGRESS\n#endif\n\n#ifdef _MSC_VER\n#  define SUPPRESS_DEPRECATED_CALL __pragma(warning(suppress: 4996))\n#else\n#  define SUPPRESS_DEPRECATED_CALL\n#endif\n\n/* Convenience function to raise an error according to errno\n   and return a NULL pointer from a function. */\n\nstatic PyObject *\nset_error(void)\n{\n#ifdef MS_WINDOWS\n    int err_no = WSAGetLastError();\n    /* PyErr_SetExcFromWindowsErr() invokes FormatMessage() which\n       recognizes the error codes used by both GetLastError() and\n       WSAGetLastError */\n    if (err_no)\n        return PyErr_SetExcFromWindowsErr(PyExc_OSError, err_no);\n#endif\n\n    return PyErr_SetFromErrno(PyExc_OSError);\n}\n\n\n#if defined(HAVE_GETHOSTBYNAME_R) || defined (HAVE_GETHOSTBYNAME) || defined (HAVE_GETHOSTBYADDR)\nstatic PyObject *\nset_herror(socket_state *state, int h_error)\n{\n    PyObject *v;\n\n#ifdef HAVE_HSTRERROR\n    v = Py_BuildValue(\"(is)\", h_error, hstrerror(h_error));\n#else\n    v = Py_BuildValue(\"(is)\", h_error, \"host not found\");\n#endif\n    if (v != NULL) {\n        PyErr_SetObject(state->socket_herror, v);\n        Py_DECREF(v);\n    }\n\n    return NULL;\n}\n#endif\n\n\n#ifdef HAVE_GETADDRINFO\nstatic PyObject *\nset_gaierror(socket_state *state, int error)\n{\n    PyObject *v;\n\n#ifdef EAI_SYSTEM\n    /* EAI_SYSTEM is not available on Windows XP. */\n    if (error == EAI_SYSTEM)\n        return set_error();\n#endif\n\n#ifdef HAVE_GAI_STRERROR\n    v = Py_BuildValue(\"(is)\", error, gai_strerror(error));\n#else\n    v = Py_BuildValue(\"(is)\", error, \"getaddrinfo failed\");\n#endif\n    if (v != NULL) {\n        PyErr_SetObject(state->socket_gaierror, v);\n        Py_DECREF(v);\n    }\n\n    return NULL;\n}\n#endif\n\n/* Function to perform the setting of socket blocking mode\n   internally. block = (1 | 0). */\nstatic int\ninternal_setblocking(PySocketSockObject *s, int block)\n{\n    int result = -1;\n#ifdef MS_WINDOWS\n    u_long arg;\n#endif\n#if !defined(MS_WINDOWS) \\\n    && !((defined(HAVE_SYS_IOCTL_H) && defined(FIONBIO)))\n    int delay_flag, new_delay_flag;\n#endif\n\n    Py_BEGIN_ALLOW_THREADS\n#ifndef MS_WINDOWS\n#if (defined(HAVE_SYS_IOCTL_H) && defined(FIONBIO))\n    block = !block;\n    if (ioctl(s->sock_fd, FIONBIO, (unsigned int *)&block) == -1)\n        goto done;\n#else\n    delay_flag = fcntl(s->sock_fd, F_GETFL, 0);\n    if (delay_flag == -1)\n        goto done;\n    if (block)\n        new_delay_flag = delay_flag & (~O_NONBLOCK);\n    else\n        new_delay_flag = delay_flag | O_NONBLOCK;\n    if (new_delay_flag != delay_flag)\n        if (fcntl(s->sock_fd, F_SETFL, new_delay_flag) == -1)\n            goto done;\n#endif\n#else /* MS_WINDOWS */\n    arg = !block;\n    if (ioctlsocket(s->sock_fd, FIONBIO, &arg) != 0)\n        goto done;\n#endif /* MS_WINDOWS */\n\n    result = 0;\n\n  done:\n    Py_END_ALLOW_THREADS\n\n    if (result) {\n#ifndef MS_WINDOWS\n        PyErr_SetFromErrno(PyExc_OSError);\n#else\n        PyErr_SetExcFromWindowsErr(PyExc_OSError, WSAGetLastError());\n#endif\n    }\n\n    return result;\n}\n\nstatic int\ninternal_select(PySocketSockObject *s, int writing, PyTime_t interval,\n                int connect)\n{\n    int n;\n#ifdef HAVE_POLL\n    struct pollfd pollfd;\n    PyTime_t ms;\n#else\n    fd_set fds, efds;\n    struct timeval tv, *tvp;\n#endif\n\n    /* must be called with the GIL held */\n    assert(PyGILState_Check());\n\n    /* Error condition is for output only */\n    assert(!(connect && !writing));\n\n    /* Guard against closed socket */\n    if (s->sock_fd == INVALID_SOCKET)\n        return 0;\n\n    /* Prefer poll, if available, since you can poll() any fd\n     * which can't be done with select(). */\n#ifdef HAVE_POLL\n    pollfd.fd = s->sock_fd;\n    pollfd.events = writing ? POLLOUT : POLLIN;\n    if (connect) {\n        /* On Windows, the socket becomes writable on connection success,\n           but a connection failure is notified as an error. On POSIX, the\n           socket becomes writable on connection success or on connection\n           failure. */\n        pollfd.events |= POLLERR;\n    }\n\n    /* s->sock_timeout is in seconds, timeout in ms */\n    ms = _PyTime_AsMilliseconds(interval, _PyTime_ROUND_CEILING);\n    assert(ms <= INT_MAX);\n\n    /* On some OSes, typically BSD-based ones, the timeout parameter of the\n       poll() syscall, when negative, must be exactly INFTIM, where defined,\n       or -1. See issue 37811. */\n    if (ms < 0) {\n#ifdef INFTIM\n        ms = INFTIM;\n#else\n        ms = -1;\n#endif\n    }\n\n    Py_BEGIN_ALLOW_THREADS;\n    n = poll(&pollfd, 1, (int)ms);\n    Py_END_ALLOW_THREADS;\n#else\n    if (interval >= 0) {\n        _PyTime_AsTimeval_clamp(interval, &tv, _PyTime_ROUND_CEILING);\n        tvp = &tv;\n    }\n    else\n        tvp = NULL;\n\n    FD_ZERO(&fds);\n    FD_SET(s->sock_fd, &fds);\n    FD_ZERO(&efds);\n    if (connect) {\n        /* On Windows, the socket becomes writable on connection success,\n           but a connection failure is notified as an error. On POSIX, the\n           socket becomes writable on connection success or on connection\n           failure. */\n        FD_SET(s->sock_fd, &efds);\n    }\n\n    /* See if the socket is ready */\n    Py_BEGIN_ALLOW_THREADS;\n    if (writing)\n        n = select(Py_SAFE_DOWNCAST(s->sock_fd+1, SOCKET_T, int),\n                   NULL, &fds, &efds, tvp);\n    else\n        n = select(Py_SAFE_DOWNCAST(s->sock_fd+1, SOCKET_T, int),\n                   &fds, NULL, &efds, tvp);\n    Py_END_ALLOW_THREADS;\n#endif\n\n    if (n < 0)\n        return -1;\n    if (n == 0)\n        return 1;\n    return 0;\n}\n\n/* Call a socket function.\n\n   On error, raise an exception and return -1 if err is set, or fill err and\n   return -1 otherwise. If a signal was received and the signal handler raised\n   an exception, return -1, and set err to -1 if err is set.\n\n   On success, return 0, and set err to 0 if err is set.\n\n   If the socket has a timeout, wait until the socket is ready before calling\n   the function: wait until the socket is writable if writing is nonzero, wait\n   until the socket received data otherwise.\n\n   If the socket function is interrupted by a signal (failed with EINTR): retry\n   the function, except if the signal handler raised an exception (PEP 475).\n\n   When the function is retried, recompute the timeout using a monotonic clock.\n\n   sock_call_ex() must be called with the GIL held. The socket function is\n   called with the GIL released. */\nstatic int\nsock_call_ex(PySocketSockObject *s,\n             int writing,\n             int (*sock_func) (PySocketSockObject *s, void *data),\n             void *data,\n             int connect,\n             int *err,\n             PyTime_t timeout)\n{\n    int has_timeout = (timeout > 0);\n    PyTime_t deadline = 0;\n    int deadline_initialized = 0;\n    int res;\n\n    /* sock_call() must be called with the GIL held. */\n    assert(PyGILState_Check());\n\n    /* outer loop to retry select() when select() is interrupted by a signal\n       or to retry select()+sock_func() on false positive (see above) */\n    while (1) {\n        /* For connect(), poll even for blocking socket. The connection\n           runs asynchronously. */\n        if (has_timeout || connect) {\n            if (has_timeout) {\n                PyTime_t interval;\n\n                if (deadline_initialized) {\n                    /* recompute the timeout */\n                    interval = _PyDeadline_Get(deadline);\n                }\n                else {\n                    deadline_initialized = 1;\n                    deadline = _PyDeadline_Init(timeout);\n                    interval = timeout;\n                }\n\n                if (interval >= 0) {\n                    res = internal_select(s, writing, interval, connect);\n                }\n                else {\n                    res = 1;\n                }\n            }\n            else {\n                res = internal_select(s, writing, timeout, connect);\n            }\n\n            if (res == -1) {\n                if (err)\n                    *err = GET_SOCK_ERROR;\n\n                if (CHECK_ERRNO(EINTR)) {\n                    /* select() was interrupted by a signal */\n                    if (PyErr_CheckSignals()) {\n                        if (err)\n                            *err = -1;\n                        return -1;\n                    }\n\n                    /* retry select() */\n                    continue;\n                }\n\n                /* select() failed */\n                s->errorhandler();\n                return -1;\n            }\n\n            if (res == 1) {\n                if (err)\n                    *err = SOCK_TIMEOUT_ERR;\n                else\n                    PyErr_SetString(PyExc_TimeoutError, \"timed out\");\n                return -1;\n            }\n\n            /* the socket is ready */\n        }\n\n        /* inner loop to retry sock_func() when sock_func() is interrupted\n           by a signal */\n        while (1) {\n            Py_BEGIN_ALLOW_THREADS\n            res = sock_func(s, data);\n            Py_END_ALLOW_THREADS\n\n            if (res) {\n                /* sock_func() succeeded */\n                if (err)\n                    *err = 0;\n                return 0;\n            }\n\n            if (err)\n                *err = GET_SOCK_ERROR;\n\n            if (!CHECK_ERRNO(EINTR))\n                break;\n\n            /* sock_func() was interrupted by a signal */\n            if (PyErr_CheckSignals()) {\n                if (err)\n                    *err = -1;\n                return -1;\n            }\n\n            /* retry sock_func() */\n        }\n\n        if (s->sock_timeout > 0\n            && (CHECK_ERRNO(EWOULDBLOCK) || CHECK_ERRNO(EAGAIN))) {\n            /* False positive: sock_func() failed with EWOULDBLOCK or EAGAIN.\n\n               For example, select() could indicate a socket is ready for\n               reading, but the data then discarded by the OS because of a\n               wrong checksum.\n\n               Loop on select() to recheck for socket readiness. */\n            continue;\n        }\n\n        /* sock_func() failed */\n        if (!err)\n            s->errorhandler();\n        /* else: err was already set before */\n        return -1;\n    }\n}\n\nstatic int\nsock_call(PySocketSockObject *s,\n          int writing,\n          int (*func) (PySocketSockObject *s, void *data),\n          void *data)\n{\n    return sock_call_ex(s, writing, func, data, 0, NULL, s->sock_timeout);\n}\n\n\n/* Initialize a new socket object. */\n\nstatic int\ninit_sockobject(socket_state *state, PySocketSockObject *s,\n                SOCKET_T fd, int family, int type, int proto)\n{\n    s->sock_fd = fd;\n    s->sock_family = family;\n\n    s->sock_type = type;\n\n    /* It's possible to pass SOCK_NONBLOCK and SOCK_CLOEXEC bit flags\n       on some OSes as part of socket.type.  We want to reset them here,\n       to make socket.type be set to the same value on all platforms.\n       Otherwise, simple code like 'if sock.type == SOCK_STREAM' is\n       not portable.\n    */\n#ifdef SOCK_NONBLOCK\n    s->sock_type = s->sock_type & ~SOCK_NONBLOCK;\n#endif\n#ifdef SOCK_CLOEXEC\n    s->sock_type = s->sock_type & ~SOCK_CLOEXEC;\n#endif\n\n    s->sock_proto = proto;\n\n    s->errorhandler = &set_error;\n#ifdef SOCK_NONBLOCK\n    if (type & SOCK_NONBLOCK)\n        s->sock_timeout = 0;\n    else\n#endif\n    {\n        s->sock_timeout = _Py_atomic_load_int64_relaxed(&state->defaulttimeout);\n        if (s->sock_timeout >= 0) {\n            if (internal_setblocking(s, 0) == -1) {\n                return -1;\n            }\n        }\n    }\n    s->state = state;\n    return 0;\n}\n\n\n#ifdef HAVE_SOCKETPAIR\n/* Create a new socket object.\n   This just creates the object and initializes it.\n   If the creation fails, return NULL and set an exception (implicit\n   in NEWOBJ()). */\n\nstatic PySocketSockObject *\nnew_sockobject(socket_state *state, SOCKET_T fd, int family, int type,\n               int proto)\n{\n    PyTypeObject *tp = state->sock_type;\n    PySocketSockObject *s = (PySocketSockObject *)tp->tp_alloc(tp, 0);\n    if (s == NULL) {\n        return NULL;\n    }\n    if (init_sockobject(state, s, fd, family, type, proto) == -1) {\n        Py_DECREF(s);\n        return NULL;\n    }\n    return s;\n}\n#endif\n\n\n/* Lock to allow python interpreter to continue, but only allow one\n   thread to be in gethostbyname or getaddrinfo */\n#if defined(USE_GETHOSTBYNAME_LOCK)\nstatic PyThread_type_lock netdb_lock;\n#endif\n\n\n#ifdef HAVE_GETADDRINFO\n/* Convert a string specifying a host name or one of a few symbolic\n   names to a numeric IP address.  This usually calls gethostbyname()\n   to do the work; the names \"\" and \"<broadcast>\" are special.\n   Return the length (IPv4 should be 4 bytes), or negative if\n   an error occurred; then an exception is raised. */\n\nstatic int\nsetipaddr(socket_state *state, const char *name, struct sockaddr *addr_ret,\n          size_t addr_ret_size, int af)\n{\n    struct addrinfo hints, *res;\n    int error;\n\n    memset((void *) addr_ret, '\\0', sizeof(*addr_ret));\n    if (name[0] == '\\0') {\n        int siz;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = af;\n        hints.ai_socktype = SOCK_DGRAM;         /*dummy*/\n        hints.ai_flags = AI_PASSIVE;\n        Py_BEGIN_ALLOW_THREADS\n        error = getaddrinfo(NULL, \"0\", &hints, &res);\n        Py_END_ALLOW_THREADS\n        /* We assume that those thread-unsafe getaddrinfo() versions\n           *are* safe regarding their return value, ie. that a\n           subsequent call to getaddrinfo() does not destroy the\n           outcome of the first call. */\n        if (error) {\n            res = NULL;  // no-op, remind us that it is invalid; gh-100795\n            set_gaierror(state, error);\n            return -1;\n        }\n        switch (res->ai_family) {\n        case AF_INET:\n            siz = 4;\n            break;\n#ifdef ENABLE_IPV6\n        case AF_INET6:\n            siz = 16;\n            break;\n#endif\n        default:\n            freeaddrinfo(res);\n            PyErr_SetString(PyExc_OSError,\n                \"unsupported address family\");\n            return -1;\n        }\n        if (res->ai_next) {\n            freeaddrinfo(res);\n            PyErr_SetString(PyExc_OSError,\n                \"wildcard resolved to multiple address\");\n            return -1;\n        }\n        if (res->ai_addrlen < addr_ret_size)\n            addr_ret_size = res->ai_addrlen;\n        memcpy(addr_ret, res->ai_addr, addr_ret_size);\n        freeaddrinfo(res);\n        return siz;\n    }\n    /* special-case broadcast - inet_addr() below can return INADDR_NONE for\n     * this */\n    if (strcmp(name, \"255.255.255.255\") == 0 ||\n        strcmp(name, \"<broadcast>\") == 0) {\n        struct sockaddr_in *sin;\n        if (af != AF_INET && af != AF_UNSPEC) {\n            PyErr_SetString(PyExc_OSError,\n                \"address family mismatched\");\n            return -1;\n        }\n        sin = (struct sockaddr_in *)addr_ret;\n        memset((void *) sin, '\\0', sizeof(*sin));\n        sin->sin_family = AF_INET;\n#ifdef HAVE_SOCKADDR_SA_LEN\n        sin->sin_len = sizeof(*sin);\n#endif\n        sin->sin_addr.s_addr = INADDR_BROADCAST;\n        return sizeof(sin->sin_addr);\n    }\n\n    /* avoid a name resolution in case of numeric address */\n#ifdef HAVE_INET_PTON\n    /* check for an IPv4 address */\n    if (af == AF_UNSPEC || af == AF_INET) {\n        struct sockaddr_in *sin = (struct sockaddr_in *)addr_ret;\n        memset(sin, 0, sizeof(*sin));\n        if (inet_pton(AF_INET, name, &sin->sin_addr) > 0) {\n            sin->sin_family = AF_INET;\n#ifdef HAVE_SOCKADDR_SA_LEN\n            sin->sin_len = sizeof(*sin);\n#endif\n            return 4;\n        }\n    }\n#ifdef ENABLE_IPV6\n    /* check for an IPv6 address - if the address contains a scope ID, we\n     * fallback to getaddrinfo(), which can handle translation from interface\n     * name to interface index */\n    if ((af == AF_UNSPEC || af == AF_INET6) && !strchr(name, '%')) {\n        struct sockaddr_in6 *sin = (struct sockaddr_in6 *)addr_ret;\n        memset(sin, 0, sizeof(*sin));\n        if (inet_pton(AF_INET6, name, &sin->sin6_addr) > 0) {\n            sin->sin6_family = AF_INET6;\n#ifdef HAVE_SOCKADDR_SA_LEN\n            sin->sin6_len = sizeof(*sin);\n#endif\n            return 16;\n        }\n    }\n#endif /* ENABLE_IPV6 */\n#else /* HAVE_INET_PTON */\n    /* check for an IPv4 address */\n    if (af == AF_INET || af == AF_UNSPEC) {\n        struct sockaddr_in *sin = (struct sockaddr_in *)addr_ret;\n        memset(sin, 0, sizeof(*sin));\n        if ((sin->sin_addr.s_addr = inet_addr(name)) != INADDR_NONE) {\n            sin->sin_family = AF_INET;\n#ifdef HAVE_SOCKADDR_SA_LEN\n            sin->sin_len = sizeof(*sin);\n#endif\n            return 4;\n        }\n    }\n#endif /* HAVE_INET_PTON */\n\n    /* perform a name resolution */\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = af;\n    Py_BEGIN_ALLOW_THREADS\n    error = getaddrinfo(name, NULL, &hints, &res);\n#if defined(__digital__) && defined(__unix__)\n    if (error == EAI_NONAME && af == AF_UNSPEC) {\n        /* On Tru64 V5.1, numeric-to-addr conversion fails\n           if no address family is given. Assume IPv4 for now.*/\n        hints.ai_family = AF_INET;\n        error = getaddrinfo(name, NULL, &hints, &res);\n    }\n#endif\n    Py_END_ALLOW_THREADS\n    if (error) {\n        res = NULL;  // no-op, remind us that it is invalid; gh-100795\n        set_gaierror(state, error);\n        return -1;\n    }\n    if (res->ai_addrlen < addr_ret_size)\n        addr_ret_size = res->ai_addrlen;\n    memcpy((char *) addr_ret, res->ai_addr, addr_ret_size);\n    freeaddrinfo(res);\n    switch (addr_ret->sa_family) {\n    case AF_INET:\n        return 4;\n#ifdef ENABLE_IPV6\n    case AF_INET6:\n        return 16;\n#endif\n    default:\n        PyErr_SetString(PyExc_OSError, \"unknown address family\");\n        return -1;\n    }\n}\n#endif // HAVE_GETADDRINFO\n\n/* Convert IPv4 sockaddr to a Python str. */\n\nstatic PyObject *\nmake_ipv4_addr(const struct sockaddr_in *addr)\n{\n    char buf[INET_ADDRSTRLEN];\n    if (inet_ntop(AF_INET, &addr->sin_addr, buf, sizeof(buf)) == NULL) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        return NULL;\n    }\n    return PyUnicode_FromString(buf);\n}\n\n#ifdef ENABLE_IPV6\n/* Convert IPv6 sockaddr to a Python str. */\n\nstatic PyObject *\nmake_ipv6_addr(const struct sockaddr_in6 *addr)\n{\n    char buf[INET6_ADDRSTRLEN];\n    if (inet_ntop(AF_INET6, &addr->sin6_addr, buf, sizeof(buf)) == NULL) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        return NULL;\n    }\n    return PyUnicode_FromString(buf);\n}\n#endif\n\n#ifdef USE_BLUETOOTH\n/* Convert a string representation of a Bluetooth address into a numeric\n   address.  Returns the length (6), or raises an exception and returns -1 if\n   an error occurred. */\n\nstatic int\nsetbdaddr(const char *name, bdaddr_t *bdaddr)\n{\n    unsigned int b0, b1, b2, b3, b4, b5;\n    char ch;\n    int n;\n\n    n = sscanf(name, \"%X:%X:%X:%X:%X:%X%c\",\n               &b5, &b4, &b3, &b2, &b1, &b0, &ch);\n    if (n == 6 && (b0 | b1 | b2 | b3 | b4 | b5) < 256) {\n\n#ifdef MS_WINDOWS\n        *bdaddr = (ULONGLONG)(b0 & 0xFF);\n        *bdaddr |= ((ULONGLONG)(b1 & 0xFF) << 8);\n        *bdaddr |= ((ULONGLONG)(b2 & 0xFF) << 16);\n        *bdaddr |= ((ULONGLONG)(b3 & 0xFF) << 24);\n        *bdaddr |= ((ULONGLONG)(b4 & 0xFF) << 32);\n        *bdaddr |= ((ULONGLONG)(b5 & 0xFF) << 40);\n#else\n        bdaddr->b[0] = b0;\n        bdaddr->b[1] = b1;\n        bdaddr->b[2] = b2;\n        bdaddr->b[3] = b3;\n        bdaddr->b[4] = b4;\n        bdaddr->b[5] = b5;\n#endif\n\n        return 6;\n    } else {\n        PyErr_SetString(PyExc_OSError, \"bad bluetooth address\");\n        return -1;\n    }\n}\n\n/* Create a string representation of the Bluetooth address.  This is always a\n   string of the form 'XX:XX:XX:XX:XX:XX' where XX is a two digit hexadecimal\n   value (zero padded if necessary). */\n\nstatic PyObject *\nmakebdaddr(bdaddr_t *bdaddr)\n{\n#ifdef MS_WINDOWS\n    int i;\n    unsigned int octets[6];\n\n    for (i = 0; i < 6; ++i) {\n        octets[i] = ((*bdaddr) >> (8 * i)) & 0xFF;\n    }\n\n    return PyUnicode_FromFormat(\"%02X:%02X:%02X:%02X:%02X:%02X\",\n        octets[5], octets[4], octets[3],\n        octets[2], octets[1], octets[0]);\n#else\n    return PyUnicode_FromFormat(\"%02X:%02X:%02X:%02X:%02X:%02X\",\n        bdaddr->b[5], bdaddr->b[4], bdaddr->b[3],\n        bdaddr->b[2], bdaddr->b[1], bdaddr->b[0]);\n#endif\n}\n#endif\n\n\n/* Create an object representing the given socket address,\n   suitable for passing it back to bind(), connect() etc.\n   The family field of the sockaddr structure is inspected\n   to determine what kind of address it really is. */\n\n/*ARGSUSED*/\nstatic PyObject *\nmakesockaddr(SOCKET_T sockfd, struct sockaddr *addr, size_t addrlen, int proto)\n{\n    if (addrlen == 0) {\n        /* No address -- may be recvfrom() from known socket */\n        Py_RETURN_NONE;\n    }\n\n    switch (addr->sa_family) {\n\n    case AF_INET:\n    {\n        const struct sockaddr_in *a = (const struct sockaddr_in *)addr;\n        PyObject *addrobj = make_ipv4_addr(a);\n        PyObject *ret = NULL;\n        if (addrobj) {\n            ret = Py_BuildValue(\"Oi\", addrobj, ntohs(a->sin_port));\n            Py_DECREF(addrobj);\n        }\n        return ret;\n    }\n\n#if defined(AF_UNIX)\n    case AF_UNIX:\n    {\n        struct sockaddr_un *a = (struct sockaddr_un *) addr;\n#ifdef __linux__\n        size_t linuxaddrlen = addrlen - offsetof(struct sockaddr_un, sun_path);\n        if (linuxaddrlen > 0 && a->sun_path[0] == 0) {  /* Linux abstract namespace */\n            return PyBytes_FromStringAndSize(a->sun_path, linuxaddrlen);\n        }\n        else\n#endif /* linux */\n        {\n            /* regular NULL-terminated string */\n            return PyUnicode_DecodeFSDefault(a->sun_path);\n        }\n    }\n#endif /* AF_UNIX */\n\n#if defined(AF_NETLINK)\n       case AF_NETLINK:\n       {\n           struct sockaddr_nl *a = (struct sockaddr_nl *) addr;\n           return Py_BuildValue(\"II\", a->nl_pid, a->nl_groups);\n       }\n#endif /* AF_NETLINK */\n\n#if defined(AF_QIPCRTR)\n       case AF_QIPCRTR:\n       {\n           struct sockaddr_qrtr *a = (struct sockaddr_qrtr *) addr;\n           return Py_BuildValue(\"II\", a->sq_node, a->sq_port);\n       }\n#endif /* AF_QIPCRTR */\n\n#if defined(AF_VSOCK)\n       case AF_VSOCK:\n       {\n           struct sockaddr_vm *a = (struct sockaddr_vm *) addr;\n           return Py_BuildValue(\"II\", a->svm_cid, a->svm_port);\n       }\n#endif /* AF_VSOCK */\n\n#ifdef ENABLE_IPV6\n    case AF_INET6:\n    {\n        const struct sockaddr_in6 *a = (const struct sockaddr_in6 *)addr;\n        PyObject *addrobj = make_ipv6_addr(a);\n        PyObject *ret = NULL;\n        if (addrobj) {\n            ret = Py_BuildValue(\"OiII\",\n                                addrobj,\n                                ntohs(a->sin6_port),\n                                ntohl(a->sin6_flowinfo),\n                                a->sin6_scope_id);\n            Py_DECREF(addrobj);\n        }\n        return ret;\n    }\n#endif /* ENABLE_IPV6 */\n\n#ifdef USE_BLUETOOTH\n    case AF_BLUETOOTH:\n        switch (proto) {\n\n#ifdef BTPROTO_L2CAP\n        case BTPROTO_L2CAP:\n        {\n            struct sockaddr_l2 *a = (struct sockaddr_l2 *) addr;\n            PyObject *addrobj = makebdaddr(&_BT_L2_MEMB(a, bdaddr));\n            PyObject *ret = NULL;\n            if (addrobj) {\n                ret = Py_BuildValue(\"Oi\",\n                                    addrobj,\n                                    _BT_L2_MEMB(a, psm));\n                Py_DECREF(addrobj);\n            }\n            return ret;\n        }\n\n#endif /* BTPROTO_L2CAP */\n\n        case BTPROTO_RFCOMM:\n        {\n            struct sockaddr_rc *a = (struct sockaddr_rc *) addr;\n            PyObject *addrobj = makebdaddr(&_BT_RC_MEMB(a, bdaddr));\n            PyObject *ret = NULL;\n            if (addrobj) {\n                ret = Py_BuildValue(\"Oi\",\n                                    addrobj,\n                                    _BT_RC_MEMB(a, channel));\n                Py_DECREF(addrobj);\n            }\n            return ret;\n        }\n\n#ifdef BTPROTO_HCI\n        case BTPROTO_HCI:\n        {\n            struct sockaddr_hci *a = (struct sockaddr_hci *) addr;\n#if defined(__NetBSD__) || defined(__DragonFly__)\n            return makebdaddr(&_BT_HCI_MEMB(a, bdaddr));\n#else /* __NetBSD__ || __DragonFly__ */\n            PyObject *ret = NULL;\n            ret = Py_BuildValue(\"i\", _BT_HCI_MEMB(a, dev));\n            return ret;\n#endif /* !(__NetBSD__ || __DragonFly__) */\n        }\n\n#if !defined(__FreeBSD__)\n        case BTPROTO_SCO:\n        {\n            struct sockaddr_sco *a = (struct sockaddr_sco *) addr;\n            return makebdaddr(&_BT_SCO_MEMB(a, bdaddr));\n        }\n#endif /* !__FreeBSD__ */\n#endif /* BTPROTO_HCI */\n\n        default:\n            PyErr_SetString(PyExc_ValueError,\n                            \"Unknown Bluetooth protocol\");\n            return NULL;\n        }\n#endif /* USE_BLUETOOTH */\n\n#if defined(HAVE_NETPACKET_PACKET_H) && defined(SIOCGIFNAME)\n    case AF_PACKET:\n    {\n        struct sockaddr_ll *a = (struct sockaddr_ll *)addr;\n        const char *ifname = \"\";\n        struct ifreq ifr;\n        /* need to look up interface name give index */\n        if (a->sll_ifindex) {\n            ifr.ifr_ifindex = a->sll_ifindex;\n            if (ioctl(sockfd, SIOCGIFNAME, &ifr) == 0)\n                ifname = ifr.ifr_name;\n        }\n        return Py_BuildValue(\"shbhy#\",\n                             ifname,\n                             ntohs(a->sll_protocol),\n                             a->sll_pkttype,\n                             a->sll_hatype,\n                             a->sll_addr,\n                             (Py_ssize_t)a->sll_halen);\n    }\n#endif /* HAVE_NETPACKET_PACKET_H && SIOCGIFNAME */\n\n#ifdef HAVE_LINUX_TIPC_H\n    case AF_TIPC:\n    {\n        struct sockaddr_tipc *a = (struct sockaddr_tipc *) addr;\n        if (a->addrtype == TIPC_ADDR_NAMESEQ) {\n            return Py_BuildValue(\"IIIII\",\n                            a->addrtype,\n                            a->addr.nameseq.type,\n                            a->addr.nameseq.lower,\n                            a->addr.nameseq.upper,\n                            a->scope);\n        } else if (a->addrtype == TIPC_ADDR_NAME) {\n            return Py_BuildValue(\"IIIII\",\n                            a->addrtype,\n                            a->addr.name.name.type,\n                            a->addr.name.name.instance,\n                            a->addr.name.name.instance,\n                            a->scope);\n        } else if (a->addrtype == TIPC_ADDR_ID) {\n            return Py_BuildValue(\"IIIII\",\n                            a->addrtype,\n                            a->addr.id.node,\n                            a->addr.id.ref,\n                            0,\n                            a->scope);\n        } else {\n            PyErr_SetString(PyExc_ValueError,\n                            \"Invalid address type\");\n            return NULL;\n        }\n    }\n#endif /* HAVE_LINUX_TIPC_H */\n\n#if defined(AF_CAN) && defined(SIOCGIFNAME)\n    case AF_CAN:\n    {\n        struct sockaddr_can *a = (struct sockaddr_can *)addr;\n        const char *ifname = \"\";\n        struct ifreq ifr;\n        /* need to look up interface name given index */\n        if (a->can_ifindex) {\n            ifr.ifr_ifindex = a->can_ifindex;\n            if (ioctl(sockfd, SIOCGIFNAME, &ifr) == 0)\n                ifname = ifr.ifr_name;\n        }\n\n        switch (proto) {\n#ifdef CAN_ISOTP\n          case CAN_ISOTP:\n          {\n              return Py_BuildValue(\"O&kk\", PyUnicode_DecodeFSDefault,\n                                          ifname,\n                                          a->can_addr.tp.rx_id,\n                                          a->can_addr.tp.tx_id);\n          }\n#endif /* CAN_ISOTP */\n#ifdef CAN_J1939\n          case CAN_J1939:\n          {\n              return Py_BuildValue(\"O&KIB\", PyUnicode_DecodeFSDefault,\n                                          ifname,\n                                          (unsigned long long)a->can_addr.j1939.name,\n                                          (unsigned int)a->can_addr.j1939.pgn,\n                                          a->can_addr.j1939.addr);\n          }\n#endif /* CAN_J1939 */\n          default:\n          {\n              return Py_BuildValue(\"(O&)\", PyUnicode_DecodeFSDefault,\n                                        ifname);\n          }\n        }\n    }\n#endif /* AF_CAN && SIOCGIFNAME */\n\n#ifdef PF_SYSTEM\n    case PF_SYSTEM:\n        switch(proto) {\n#ifdef SYSPROTO_CONTROL\n        case SYSPROTO_CONTROL:\n        {\n            struct sockaddr_ctl *a = (struct sockaddr_ctl *)addr;\n            return Py_BuildValue(\"(II)\", a->sc_id, a->sc_unit);\n        }\n#endif /* SYSPROTO_CONTROL */\n        default:\n            PyErr_SetString(PyExc_ValueError,\n                            \"Invalid address type\");\n            return 0;\n        }\n#endif /* PF_SYSTEM */\n\n#ifdef HAVE_SOCKADDR_ALG\n    case AF_ALG:\n    {\n        struct sockaddr_alg *a = (struct sockaddr_alg *)addr;\n        return Py_BuildValue(\"s#s#HH\",\n            a->salg_type,\n            strnlen((const char*)a->salg_type,\n                    sizeof(a->salg_type)),\n            a->salg_name,\n            strnlen((const char*)a->salg_name,\n                    sizeof(a->salg_name)),\n            a->salg_feat,\n            a->salg_mask);\n    }\n#endif /* HAVE_SOCKADDR_ALG */\n\n#ifdef HAVE_AF_HYPERV\n    case AF_HYPERV:\n    {\n        SOCKADDR_HV *a = (SOCKADDR_HV *) addr;\n\n        wchar_t *guidStr;\n        RPC_STATUS res = UuidToStringW(&a->VmId, &guidStr);\n        if (res != RPC_S_OK) {\n            PyErr_SetFromWindowsErr(res);\n            return 0;\n        }\n        PyObject *vmId = PyUnicode_FromWideChar(guidStr, -1);\n        res = RpcStringFreeW(&guidStr);\n        assert(res == RPC_S_OK);\n\n        res = UuidToStringW(&a->ServiceId, &guidStr);\n        if (res != RPC_S_OK) {\n            Py_DECREF(vmId);\n            PyErr_SetFromWindowsErr(res);\n            return 0;\n        }\n        PyObject *serviceId = PyUnicode_FromWideChar(guidStr, -1);\n        res = RpcStringFreeW(&guidStr);\n        assert(res == RPC_S_OK);\n\n        return Py_BuildValue(\"NN\", vmId, serviceId);\n    }\n#endif /* AF_HYPERV */\n\n    /* More cases here... */\n\n    default:\n        /* If we don't know the address family, don't raise an\n           exception -- return it as an (int, bytes) tuple. */\n        return Py_BuildValue(\"iy#\",\n                             addr->sa_family,\n                             addr->sa_data,\n                             sizeof(addr->sa_data));\n\n    }\n}\n\n#if defined(HAVE_BIND) || defined(HAVE_CONNECTTO) || defined(CMSG_LEN)\n/* Helper for getsockaddrarg: bypass IDNA for ASCII-only host names\n   (in particular, numeric IP addresses). */\nstruct maybe_idna {\n    PyObject *obj;\n    char *buf;\n};\n\nstatic void\nidna_cleanup(struct maybe_idna *data)\n{\n    Py_CLEAR(data->obj);\n}\n\nstatic int\nidna_converter(PyObject *obj, struct maybe_idna *data)\n{\n    size_t len;\n    PyObject *obj2;\n    if (obj == NULL) {\n        idna_cleanup(data);\n        return 1;\n    }\n    data->obj = NULL;\n    len = -1;\n    if (PyBytes_Check(obj)) {\n        data->buf = PyBytes_AsString(obj);\n        len = PyBytes_Size(obj);\n    }\n    else if (PyByteArray_Check(obj)) {\n        data->buf = PyByteArray_AsString(obj);\n        len = PyByteArray_Size(obj);\n    }\n    else if (PyUnicode_Check(obj)) {\n        if (PyUnicode_IS_COMPACT_ASCII(obj)) {\n            data->buf = PyUnicode_DATA(obj);\n            len = PyUnicode_GET_LENGTH(obj);\n        }\n        else {\n            obj2 = PyUnicode_AsEncodedString(obj, \"idna\", NULL);\n            if (!obj2) {\n                PyErr_SetString(PyExc_TypeError, \"encoding of hostname failed\");\n                return 0;\n            }\n            assert(PyBytes_Check(obj2));\n            data->obj = obj2;\n            data->buf = PyBytes_AS_STRING(obj2);\n            len = PyBytes_GET_SIZE(obj2);\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError, \"str, bytes or bytearray expected, not %s\",\n                     Py_TYPE(obj)->tp_name);\n        return 0;\n    }\n    if (strlen(data->buf) != len) {\n        Py_CLEAR(data->obj);\n        PyErr_SetString(PyExc_TypeError, \"host name must not contain null character\");\n        return 0;\n    }\n    return Py_CLEANUP_SUPPORTED;\n}\n\n/* Parse a socket address argument according to the socket object's\n   address family.  Return 1 if the address was in the proper format,\n   0 of not.  The address is returned through addr_ret, its length\n   through len_ret. */\n\nstatic int\ngetsockaddrarg(PySocketSockObject *s, PyObject *args,\n               sock_addr_t *addrbuf, int *len_ret, const char *caller)\n{\n    switch (s->sock_family) {\n\n#if defined(AF_UNIX)\n    case AF_UNIX:\n    {\n        Py_buffer path;\n        int retval = 0;\n\n        /* PEP 383.  Not using PyUnicode_FSConverter since we need to\n           allow embedded nulls on Linux. */\n        if (PyUnicode_Check(args)) {\n            if ((args = PyUnicode_EncodeFSDefault(args)) == NULL)\n                return 0;\n        }\n        else\n            Py_INCREF(args);\n        if (!PyArg_Parse(args, \"y*\", &path)) {\n            Py_DECREF(args);\n            return retval;\n        }\n        assert(path.len >= 0);\n\n        struct sockaddr_un* addr = &addrbuf->un;\n#ifdef __linux__\n        if (path.len == 0 || *(const char *)path.buf == 0) {\n            /* Linux abstract namespace extension:\n               - Empty address auto-binding to an abstract address\n               - Address that starts with null byte */\n            if ((size_t)path.len > sizeof addr->sun_path) {\n                PyErr_SetString(PyExc_OSError,\n                                \"AF_UNIX path too long\");\n                goto unix_out;\n            }\n\n            *len_ret = path.len + offsetof(struct sockaddr_un, sun_path);\n        }\n        else\n#endif /* linux */\n        {\n            /* regular NULL-terminated string */\n            if ((size_t)path.len >= sizeof addr->sun_path) {\n                PyErr_SetString(PyExc_OSError,\n                                \"AF_UNIX path too long\");\n                goto unix_out;\n            }\n            addr->sun_path[path.len] = 0;\n\n            /* including the tailing NUL */\n            *len_ret = path.len + offsetof(struct sockaddr_un, sun_path) + 1;\n        }\n        addr->sun_family = s->sock_family;\n        memcpy(addr->sun_path, path.buf, path.len);\n\n        retval = 1;\n    unix_out:\n        PyBuffer_Release(&path);\n        Py_DECREF(args);\n        return retval;\n    }\n#endif /* AF_UNIX */\n\n#if defined(AF_NETLINK)\n    case AF_NETLINK:\n    {\n        int pid, groups;\n        struct sockaddr_nl* addr = &addrbuf->nl;\n        if (!PyTuple_Check(args)) {\n            PyErr_Format(\n                PyExc_TypeError,\n                \"%s(): AF_NETLINK address must be tuple, not %.500s\",\n                caller, Py_TYPE(args)->tp_name);\n            return 0;\n        }\n        if (!PyArg_ParseTuple(args,\n                              \"II;AF_NETLINK address must be a pair \"\n                              \"(pid, groups)\",\n                              &pid, &groups))\n        {\n            return 0;\n        }\n        addr->nl_family = AF_NETLINK;\n        addr->nl_pid = pid;\n        addr->nl_groups = groups;\n        *len_ret = sizeof(*addr);\n        return 1;\n    }\n#endif /* AF_NETLINK */\n\n#if defined(AF_QIPCRTR)\n    case AF_QIPCRTR:\n    {\n        unsigned int node, port;\n        struct sockaddr_qrtr* addr = &addrbuf->sq;\n        if (!PyTuple_Check(args)) {\n            PyErr_Format(\n                PyExc_TypeError,\n                \"getsockaddrarg: \"\n                \"AF_QIPCRTR address must be tuple, not %.500s\",\n                Py_TYPE(args)->tp_name);\n            return 0;\n        }\n        if (!PyArg_ParseTuple(args, \"II:getsockaddrarg\", &node, &port))\n            return 0;\n        addr->sq_family = AF_QIPCRTR;\n        addr->sq_node = node;\n        addr->sq_port = port;\n        *len_ret = sizeof(*addr);\n        return 1;\n    }\n#endif /* AF_QIPCRTR */\n\n#if defined(AF_VSOCK)\n    case AF_VSOCK:\n    {\n        struct sockaddr_vm* addr = &addrbuf->vm;\n        int port, cid;\n        memset(addr, 0, sizeof(struct sockaddr_vm));\n        if (!PyTuple_Check(args)) {\n            PyErr_Format(\n                PyExc_TypeError,\n                \"getsockaddrarg: \"\n                \"AF_VSOCK address must be tuple, not %.500s\",\n                Py_TYPE(args)->tp_name);\n            return 0;\n        }\n        if (!PyArg_ParseTuple(args, \"II:getsockaddrarg\", &cid, &port))\n            return 0;\n        addr->svm_family = s->sock_family;\n        addr->svm_port = port;\n        addr->svm_cid = cid;\n        *len_ret = sizeof(*addr);\n        return 1;\n    }\n#endif /* AF_VSOCK */\n\n\n#ifdef AF_RDS\n    case AF_RDS:\n        /* RDS sockets use sockaddr_in: fall-through */\n#endif /* AF_RDS */\n\n#ifdef AF_DIVERT\n    case AF_DIVERT:\n        /* FreeBSD divert(4) sockets use sockaddr_in: fall-through */\n#endif /* AF_DIVERT */\n\n    case AF_INET:\n    {\n        struct maybe_idna host = {NULL, NULL};\n        int port, result;\n        if (!PyTuple_Check(args)) {\n            PyErr_Format(\n                PyExc_TypeError,\n                \"%s(): AF_INET address must be tuple, not %.500s\",\n                caller, Py_TYPE(args)->tp_name);\n            return 0;\n        }\n        if (!PyArg_ParseTuple(args,\n                              \"O&i;AF_INET address must be a pair \"\n                              \"(host, port)\",\n                              idna_converter, &host, &port))\n        {\n            assert(PyErr_Occurred());\n            if (PyErr_ExceptionMatches(PyExc_OverflowError)) {\n                PyErr_Format(PyExc_OverflowError,\n                             \"%s(): port must be 0-65535.\", caller);\n            }\n            return 0;\n        }\n        struct sockaddr_in* addr = &addrbuf->in;\n        result = setipaddr(s->state, host.buf, (struct sockaddr *)addr,\n                           sizeof(*addr),  AF_INET);\n        idna_cleanup(&host);\n        if (result < 0)\n            return 0;\n        if (port < 0 || port > 0xffff) {\n            PyErr_Format(\n                PyExc_OverflowError,\n                \"%s(): port must be 0-65535.\", caller);\n            return 0;\n        }\n        addr->sin_family = AF_INET;\n        addr->sin_port = htons((short)port);\n        *len_ret = sizeof *addr;\n        return 1;\n    }\n\n#ifdef ENABLE_IPV6\n    case AF_INET6:\n    {\n        struct maybe_idna host = {NULL, NULL};\n        int port, result;\n        unsigned int flowinfo, scope_id;\n        flowinfo = scope_id = 0;\n        if (!PyTuple_Check(args)) {\n            PyErr_Format(\n                PyExc_TypeError,\n                \"%s(): AF_INET6 address must be tuple, not %.500s\",\n                caller, Py_TYPE(args)->tp_name);\n            return 0;\n        }\n        if (!PyArg_ParseTuple(args,\n                              \"O&i|II;AF_INET6 address must be a tuple \"\n                              \"(host, port[, flowinfo[, scopeid]])\",\n                              idna_converter, &host, &port, &flowinfo,\n                              &scope_id))\n        {\n            assert(PyErr_Occurred());\n            if (PyErr_ExceptionMatches(PyExc_OverflowError)) {\n                PyErr_Format(PyExc_OverflowError,\n                             \"%s(): port must be 0-65535.\", caller);\n            }\n            return 0;\n        }\n        struct sockaddr_in6* addr = &addrbuf->in6;\n        result = setipaddr(s->state, host.buf, (struct sockaddr *)addr,\n                           sizeof(*addr), AF_INET6);\n        idna_cleanup(&host);\n        if (result < 0)\n            return 0;\n        if (port < 0 || port > 0xffff) {\n            PyErr_Format(\n                PyExc_OverflowError,\n                \"%s(): port must be 0-65535.\", caller);\n            return 0;\n        }\n        if (flowinfo > 0xfffff) {\n            PyErr_Format(\n                PyExc_OverflowError,\n                \"%s(): flowinfo must be 0-1048575.\", caller);\n            return 0;\n        }\n        addr->sin6_family = s->sock_family;\n        addr->sin6_port = htons((short)port);\n        addr->sin6_flowinfo = htonl(flowinfo);\n        addr->sin6_scope_id = scope_id;\n        *len_ret = sizeof *addr;\n        return 1;\n    }\n#endif /* ENABLE_IPV6 */\n\n#ifdef USE_BLUETOOTH\n    case AF_BLUETOOTH:\n    {\n        switch (s->sock_proto) {\n#ifdef BTPROTO_L2CAP\n        case BTPROTO_L2CAP:\n        {\n            const char *straddr;\n\n            struct sockaddr_l2 *addr = &addrbuf->bt_l2;\n            memset(addr, 0, sizeof(struct sockaddr_l2));\n            _BT_L2_MEMB(addr, family) = AF_BLUETOOTH;\n            if (!PyArg_ParseTuple(args, \"si\", &straddr,\n                                  &_BT_L2_MEMB(addr, psm))) {\n                PyErr_Format(PyExc_OSError,\n                             \"%s(): wrong format\", caller);\n                return 0;\n            }\n            if (setbdaddr(straddr, &_BT_L2_MEMB(addr, bdaddr)) < 0)\n                return 0;\n\n            *len_ret = sizeof *addr;\n            return 1;\n        }\n#endif /* BTPROTO_L2CAP */\n        case BTPROTO_RFCOMM:\n        {\n            const char *straddr;\n            struct sockaddr_rc *addr = &addrbuf->bt_rc;\n            _BT_RC_MEMB(addr, family) = AF_BLUETOOTH;\n            if (!PyArg_ParseTuple(args, \"si\", &straddr,\n                                  &_BT_RC_MEMB(addr, channel))) {\n                PyErr_Format(PyExc_OSError,\n                             \"%s(): wrong format\", caller);\n                return 0;\n            }\n            if (setbdaddr(straddr, &_BT_RC_MEMB(addr, bdaddr)) < 0)\n                return 0;\n\n            *len_ret = sizeof *addr;\n            return 1;\n        }\n#ifdef BTPROTO_HCI\n        case BTPROTO_HCI:\n        {\n            struct sockaddr_hci *addr = &addrbuf->bt_hci;\n#if defined(__NetBSD__) || defined(__DragonFly__)\n            const char *straddr;\n            _BT_HCI_MEMB(addr, family) = AF_BLUETOOTH;\n            if (!PyBytes_Check(args)) {\n                PyErr_Format(PyExc_OSError, \"%s: \"\n                             \"wrong format\", caller);\n                return 0;\n            }\n            straddr = PyBytes_AS_STRING(args);\n            if (setbdaddr(straddr, &_BT_HCI_MEMB(addr, bdaddr)) < 0)\n                return 0;\n#else  /* __NetBSD__ || __DragonFly__ */\n            _BT_HCI_MEMB(addr, family) = AF_BLUETOOTH;\n            if (!PyArg_ParseTuple(args, \"i\", &_BT_HCI_MEMB(addr, dev))) {\n                PyErr_Format(PyExc_OSError,\n                             \"%s(): wrong format\", caller);\n                return 0;\n            }\n#endif /* !(__NetBSD__ || __DragonFly__) */\n            *len_ret = sizeof *addr;\n            return 1;\n        }\n#if !defined(__FreeBSD__)\n        case BTPROTO_SCO:\n        {\n            const char *straddr;\n\n            struct sockaddr_sco *addr = &addrbuf->bt_sco;\n            _BT_SCO_MEMB(addr, family) = AF_BLUETOOTH;\n            if (!PyBytes_Check(args)) {\n                PyErr_Format(PyExc_OSError,\n                             \"%s(): wrong format\", caller);\n                return 0;\n            }\n            straddr = PyBytes_AS_STRING(args);\n            if (setbdaddr(straddr, &_BT_SCO_MEMB(addr, bdaddr)) < 0)\n                return 0;\n\n            *len_ret = sizeof *addr;\n            return 1;\n        }\n#endif /* !__FreeBSD__ */\n#endif /* BTPROTO_HCI */\n        default:\n            PyErr_Format(PyExc_OSError,\n                         \"%s(): unknown Bluetooth protocol\", caller);\n            return 0;\n        }\n    }\n#endif /* USE_BLUETOOTH */\n\n#if defined(HAVE_NETPACKET_PACKET_H) && defined(SIOCGIFINDEX)\n    case AF_PACKET:\n    {\n        struct ifreq ifr;\n        const char *interfaceName;\n        int protoNumber;\n        int hatype = 0;\n        int pkttype = PACKET_HOST;\n        Py_buffer haddr = {NULL, NULL};\n\n        if (!PyTuple_Check(args)) {\n            PyErr_Format(\n                PyExc_TypeError,\n                \"%s(): AF_PACKET address must be tuple, not %.500s\",\n                caller, Py_TYPE(args)->tp_name);\n            return 0;\n        }\n        /* XXX: improve the default error message according to the\n           documentation of AF_PACKET, which would be added as part\n           of bpo-25041. */\n        if (!PyArg_ParseTuple(args,\n                              \"si|iiy*;AF_PACKET address must be a tuple of \"\n                              \"two to five elements\",\n                              &interfaceName, &protoNumber, &pkttype, &hatype,\n                              &haddr))\n        {\n            assert(PyErr_Occurred());\n            if (PyErr_ExceptionMatches(PyExc_OverflowError)) {\n                PyErr_Format(PyExc_OverflowError,\n                             \"%s(): address argument out of range\", caller);\n            }\n            return 0;\n        }\n        strncpy(ifr.ifr_name, interfaceName, sizeof(ifr.ifr_name));\n        ifr.ifr_name[(sizeof(ifr.ifr_name))-1] = '\\0';\n        if (ioctl(s->sock_fd, SIOCGIFINDEX, &ifr) < 0) {\n            s->errorhandler();\n            PyBuffer_Release(&haddr);\n            return 0;\n        }\n        if (haddr.buf && haddr.len > 8) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"Hardware address must be 8 bytes or less\");\n            PyBuffer_Release(&haddr);\n            return 0;\n        }\n        if (protoNumber < 0 || protoNumber > 0xffff) {\n            PyErr_Format(\n                PyExc_OverflowError,\n                \"%s(): proto must be 0-65535.\", caller);\n            PyBuffer_Release(&haddr);\n            return 0;\n        }\n        struct sockaddr_ll* addr = &addrbuf->ll;\n        addr->sll_family = AF_PACKET;\n        addr->sll_protocol = htons((short)protoNumber);\n        addr->sll_ifindex = ifr.ifr_ifindex;\n        addr->sll_pkttype = pkttype;\n        addr->sll_hatype = hatype;\n        if (haddr.buf) {\n            memcpy(&addr->sll_addr, haddr.buf, haddr.len);\n            addr->sll_halen = haddr.len;\n        }\n        else\n            addr->sll_halen = 0;\n        *len_ret = sizeof *addr;\n        PyBuffer_Release(&haddr);\n        return 1;\n    }\n#endif /* HAVE_NETPACKET_PACKET_H && SIOCGIFINDEX */\n\n#ifdef HAVE_LINUX_TIPC_H\n    case AF_TIPC:\n    {\n        unsigned int atype, v1, v2, v3;\n        unsigned int scope = TIPC_CLUSTER_SCOPE;\n\n        if (!PyTuple_Check(args)) {\n            PyErr_Format(\n                PyExc_TypeError,\n                \"%s(): AF_TIPC address must be tuple, not %.500s\",\n                caller, Py_TYPE(args)->tp_name);\n            return 0;\n        }\n\n        if (!PyArg_ParseTuple(args,\n                              \"IIII|I;AF_TIPC address must be a tuple \"\n                              \"(addr_type, v1, v2, v3[, scope])\",\n                              &atype, &v1, &v2, &v3, &scope))\n        {\n            return 0;\n        }\n\n        struct sockaddr_tipc *addr = &addrbuf->tipc;\n        memset(addr, 0, sizeof(struct sockaddr_tipc));\n\n        addr->family = AF_TIPC;\n        addr->scope = scope;\n        addr->addrtype = atype;\n\n        if (atype == TIPC_ADDR_NAMESEQ) {\n            addr->addr.nameseq.type = v1;\n            addr->addr.nameseq.lower = v2;\n            addr->addr.nameseq.upper = v3;\n        } else if (atype == TIPC_ADDR_NAME) {\n            addr->addr.name.name.type = v1;\n            addr->addr.name.name.instance = v2;\n        } else if (atype == TIPC_ADDR_ID) {\n            addr->addr.id.node = v1;\n            addr->addr.id.ref = v2;\n        } else {\n            /* Shouldn't happen */\n            PyErr_SetString(PyExc_TypeError, \"Invalid address type\");\n            return 0;\n        }\n\n        *len_ret = sizeof(*addr);\n\n        return 1;\n    }\n#endif /* HAVE_LINUX_TIPC_H */\n\n#if defined(AF_CAN) && defined(SIOCGIFINDEX)\n    case AF_CAN:\n        switch (s->sock_proto) {\n#ifdef CAN_RAW\n        case CAN_RAW:\n        /* fall-through */\n#endif\n#ifdef CAN_BCM\n        case CAN_BCM:\n#endif\n#if defined(CAN_RAW) || defined(CAN_BCM)\n        {\n            PyObject *interfaceName;\n            struct ifreq ifr;\n            Py_ssize_t len;\n            struct sockaddr_can *addr = &addrbuf->can;\n\n            if (!PyTuple_Check(args)) {\n                PyErr_Format(PyExc_TypeError,\n                             \"%s(): AF_CAN address must be tuple, not %.500s\",\n                             caller, Py_TYPE(args)->tp_name);\n                return 0;\n            }\n            if (!PyArg_ParseTuple(args,\n                                  \"O&;AF_CAN address must be a tuple \"\n                                  \"(interface, )\",\n                                  PyUnicode_FSConverter, &interfaceName))\n            {\n                return 0;\n            }\n\n            len = PyBytes_GET_SIZE(interfaceName);\n\n            if (len == 0) {\n                ifr.ifr_ifindex = 0;\n            } else if ((size_t)len < sizeof(ifr.ifr_name)) {\n                strncpy(ifr.ifr_name, PyBytes_AS_STRING(interfaceName), sizeof(ifr.ifr_name));\n                ifr.ifr_name[(sizeof(ifr.ifr_name))-1] = '\\0';\n                if (ioctl(s->sock_fd, SIOCGIFINDEX, &ifr) < 0) {\n                    s->errorhandler();\n                    Py_DECREF(interfaceName);\n                    return 0;\n                }\n            } else {\n                PyErr_SetString(PyExc_OSError,\n                                \"AF_CAN interface name too long\");\n                Py_DECREF(interfaceName);\n                return 0;\n            }\n\n            addr->can_family = AF_CAN;\n            addr->can_ifindex = ifr.ifr_ifindex;\n\n            *len_ret = sizeof(*addr);\n            Py_DECREF(interfaceName);\n            return 1;\n        }\n#endif /* CAN_RAW || CAN_BCM */\n\n#ifdef CAN_ISOTP\n        case CAN_ISOTP:\n        {\n            PyObject *interfaceName;\n            struct ifreq ifr;\n            Py_ssize_t len;\n            unsigned long int rx_id, tx_id;\n\n            struct sockaddr_can *addr = &addrbuf->can;\n\n            if (!PyArg_ParseTuple(args, \"O&kk\", PyUnicode_FSConverter,\n                                              &interfaceName,\n                                              &rx_id,\n                                              &tx_id))\n                return 0;\n\n            len = PyBytes_GET_SIZE(interfaceName);\n\n            if (len == 0) {\n                ifr.ifr_ifindex = 0;\n            } else if ((size_t)len < sizeof(ifr.ifr_name)) {\n                strncpy(ifr.ifr_name, PyBytes_AS_STRING(interfaceName), sizeof(ifr.ifr_name));\n                ifr.ifr_name[(sizeof(ifr.ifr_name))-1] = '\\0';\n                if (ioctl(s->sock_fd, SIOCGIFINDEX, &ifr) < 0) {\n                    s->errorhandler();\n                    Py_DECREF(interfaceName);\n                    return 0;\n                }\n            } else {\n                PyErr_SetString(PyExc_OSError,\n                                \"AF_CAN interface name too long\");\n                Py_DECREF(interfaceName);\n                return 0;\n            }\n\n            addr->can_family = AF_CAN;\n            addr->can_ifindex = ifr.ifr_ifindex;\n            addr->can_addr.tp.rx_id = rx_id;\n            addr->can_addr.tp.tx_id = tx_id;\n\n            *len_ret = sizeof(*addr);\n            Py_DECREF(interfaceName);\n            return 1;\n        }\n#endif /* CAN_ISOTP */\n#ifdef CAN_J1939\n        case CAN_J1939:\n        {\n            PyObject *interfaceName;\n            struct ifreq ifr;\n            Py_ssize_t len;\n            unsigned long long j1939_name; /* at least 64 bits */\n            unsigned int j1939_pgn; /* at least 32 bits */\n            uint8_t j1939_addr;\n\n            struct sockaddr_can *addr = &addrbuf->can;\n\n            if (!PyArg_ParseTuple(args, \"O&KIB\", PyUnicode_FSConverter,\n                                              &interfaceName,\n                                              &j1939_name,\n                                              &j1939_pgn,\n                                              &j1939_addr))\n                return 0;\n\n            len = PyBytes_GET_SIZE(interfaceName);\n\n            if (len == 0) {\n                ifr.ifr_ifindex = 0;\n            } else if ((size_t)len < sizeof(ifr.ifr_name)) {\n                strncpy(ifr.ifr_name, PyBytes_AS_STRING(interfaceName), sizeof(ifr.ifr_name));\n                ifr.ifr_name[(sizeof(ifr.ifr_name))-1] = '\\0';\n                if (ioctl(s->sock_fd, SIOCGIFINDEX, &ifr) < 0) {\n                    s->errorhandler();\n                    Py_DECREF(interfaceName);\n                    return 0;\n                }\n            } else {\n                PyErr_SetString(PyExc_OSError,\n                                \"AF_CAN interface name too long\");\n                Py_DECREF(interfaceName);\n                return 0;\n            }\n\n            addr->can_family = AF_CAN;\n            addr->can_ifindex = ifr.ifr_ifindex;\n            addr->can_addr.j1939.name = (uint64_t)j1939_name;\n            addr->can_addr.j1939.pgn = (uint32_t)j1939_pgn;\n            addr->can_addr.j1939.addr = j1939_addr;\n\n            *len_ret = sizeof(*addr);\n            Py_DECREF(interfaceName);\n            return 1;\n        }\n#endif /* CAN_J1939 */\n        default:\n            PyErr_Format(PyExc_OSError,\n                         \"%s(): unsupported CAN protocol\", caller);\n            return 0;\n        }\n#endif /* AF_CAN && SIOCGIFINDEX */\n\n#ifdef PF_SYSTEM\n    case PF_SYSTEM:\n        switch (s->sock_proto) {\n#ifdef SYSPROTO_CONTROL\n        case SYSPROTO_CONTROL:\n        {\n            struct sockaddr_ctl *addr = &addrbuf->ctl;\n            addr->sc_family = AF_SYSTEM;\n            addr->ss_sysaddr = AF_SYS_CONTROL;\n\n            if (PyUnicode_Check(args)) {\n                struct ctl_info info;\n                PyObject *ctl_name;\n\n                if (!PyArg_Parse(args, \"O&\",\n                                PyUnicode_FSConverter, &ctl_name)) {\n                    return 0;\n                }\n\n                if (PyBytes_GET_SIZE(ctl_name) > (Py_ssize_t)sizeof(info.ctl_name)) {\n                    PyErr_SetString(PyExc_ValueError,\n                                    \"provided string is too long\");\n                    Py_DECREF(ctl_name);\n                    return 0;\n                }\n                strncpy(info.ctl_name, PyBytes_AS_STRING(ctl_name),\n                        sizeof(info.ctl_name));\n                Py_DECREF(ctl_name);\n\n                if (ioctl(s->sock_fd, CTLIOCGINFO, &info)) {\n                    PyErr_SetString(PyExc_OSError,\n                          \"cannot find kernel control with provided name\");\n                    return 0;\n                }\n\n                addr->sc_id = info.ctl_id;\n                addr->sc_unit = 0;\n            } else if (!PyArg_ParseTuple(args, \"II\",\n                                         &(addr->sc_id), &(addr->sc_unit))) {\n                PyErr_Format(PyExc_TypeError,\n                             \"%s(): PF_SYSTEM address must be a str or \"\n                             \"a pair (id, unit)\", caller);\n                return 0;\n            }\n\n            *len_ret = sizeof(*addr);\n            return 1;\n        }\n#endif /* SYSPROTO_CONTROL */\n        default:\n            PyErr_Format(PyExc_OSError,\n                         \"%s(): unsupported PF_SYSTEM protocol\", caller);\n            return 0;\n        }\n#endif /* PF_SYSTEM */\n#ifdef HAVE_SOCKADDR_ALG\n    case AF_ALG:\n    {\n        const char *type;\n        const char *name;\n        struct sockaddr_alg *sa = &addrbuf->alg;\n\n        memset(sa, 0, sizeof(*sa));\n        sa->salg_family = AF_ALG;\n\n        if (!PyTuple_Check(args)) {\n            PyErr_Format(PyExc_TypeError,\n                         \"%s(): AF_ALG address must be tuple, not %.500s\",\n                         caller, Py_TYPE(args)->tp_name);\n            return 0;\n        }\n        if (!PyArg_ParseTuple(args,\n                              \"ss|HH;AF_ALG address must be a tuple \"\n                              \"(type, name[, feat[, mask]])\",\n                              &type, &name, &sa->salg_feat, &sa->salg_mask))\n        {\n            return 0;\n        }\n        /* sockaddr_alg has fixed-sized char arrays for type, and name\n         * both must be NULL terminated.\n         */\n        if (strlen(type) >= sizeof(sa->salg_type)) {\n            PyErr_SetString(PyExc_ValueError, \"AF_ALG type too long.\");\n            return 0;\n        }\n        strncpy((char *)sa->salg_type, type, sizeof(sa->salg_type));\n        if (strlen(name) >= sizeof(sa->salg_name)) {\n            PyErr_SetString(PyExc_ValueError, \"AF_ALG name too long.\");\n            return 0;\n        }\n        strncpy((char *)sa->salg_name, name, sizeof(sa->salg_name));\n\n        *len_ret = sizeof(*sa);\n        return 1;\n    }\n#endif /* HAVE_SOCKADDR_ALG */\n#ifdef HAVE_AF_HYPERV\n    case AF_HYPERV:\n    {\n        switch (s->sock_proto) {\n        case HV_PROTOCOL_RAW:\n        {\n            PyObject *vm_id_obj = NULL;\n            PyObject *service_id_obj = NULL;\n\n            SOCKADDR_HV *addr = &addrbuf->hv;\n\n            memset(addr, 0, sizeof(*addr));\n            addr->Family = AF_HYPERV;\n\n            if (!PyTuple_Check(args)) {\n                PyErr_Format(PyExc_TypeError,\n                    \"%s(): AF_HYPERV address must be tuple, not %.500s\",\n                    caller, Py_TYPE(args)->tp_name);\n                return 0;\n            }\n            if (!PyArg_ParseTuple(args,\n                \"UU;AF_HYPERV address must be a str tuple (vm_id, service_id)\",\n                &vm_id_obj, &service_id_obj))\n            {\n                return 0;\n            }\n\n            wchar_t *guid_str = PyUnicode_AsWideCharString(vm_id_obj, NULL);\n            if (guid_str == NULL) {\n                PyErr_Format(PyExc_ValueError,\n                    \"%s(): AF_HYPERV address vm_id is not a valid UUID string\",\n                    caller);\n                return 0;\n            }\n            RPC_STATUS rc = UuidFromStringW(guid_str, &addr->VmId);\n            PyMem_Free(guid_str);\n            if (rc != RPC_S_OK) {\n                PyErr_Format(PyExc_ValueError,\n                    \"%s(): AF_HYPERV address vm_id is not a valid UUID string\",\n                    caller);\n                return 0;\n            }\n\n            guid_str = PyUnicode_AsWideCharString(service_id_obj, NULL);\n            if (guid_str == NULL) {\n                PyErr_Format(PyExc_ValueError,\n                    \"%s(): AF_HYPERV address service_id is not a valid UUID string\",\n                    caller);\n                return 0;\n            }\n            rc = UuidFromStringW(guid_str, &addr->ServiceId);\n            PyMem_Free(guid_str);\n            if (rc != RPC_S_OK) {\n                PyErr_Format(PyExc_ValueError,\n                    \"%s(): AF_HYPERV address service_id is not a valid UUID string\",\n                    caller);\n                return 0;\n            }\n\n            *len_ret = sizeof(*addr);\n            return 1;\n        }\n        default:\n            PyErr_Format(PyExc_OSError,\n                \"%s(): unsupported AF_HYPERV protocol: %d\",\n                caller, s->sock_proto);\n            return 0;\n        }\n    }\n#endif /* HAVE_AF_HYPERV */\n\n    /* More cases here... */\n\n    default:\n        PyErr_Format(PyExc_OSError, \"%s(): bad family\", caller);\n        return 0;\n\n    }\n}\n#endif // defined(HAVE_BIND) || defined(HAVE_CONNECTTO) || defined(CMSG_LEN)\n\n\n/* Get the address length according to the socket object's address family.\n   Return 1 if the family is known, 0 otherwise.  The length is returned\n   through len_ret. */\n\nstatic int\ngetsockaddrlen(PySocketSockObject *s, socklen_t *len_ret)\n{\n    switch (s->sock_family) {\n\n#if defined(AF_UNIX)\n    case AF_UNIX:\n    {\n        *len_ret = sizeof (struct sockaddr_un);\n        return 1;\n    }\n#endif /* AF_UNIX */\n\n#if defined(AF_NETLINK)\n    case AF_NETLINK:\n    {\n        *len_ret = sizeof (struct sockaddr_nl);\n        return 1;\n    }\n#endif /* AF_NETLINK */\n\n#if defined(AF_QIPCRTR)\n    case AF_QIPCRTR:\n    {\n        *len_ret = sizeof (struct sockaddr_qrtr);\n        return 1;\n    }\n#endif /* AF_QIPCRTR */\n\n#if defined(AF_VSOCK)\n       case AF_VSOCK:\n       {\n           *len_ret = sizeof (struct sockaddr_vm);\n           return 1;\n       }\n#endif /* AF_VSOCK */\n\n#ifdef AF_RDS\n    case AF_RDS:\n        /* RDS sockets use sockaddr_in: fall-through */\n#endif /* AF_RDS */\n\n    case AF_INET:\n    {\n        *len_ret = sizeof (struct sockaddr_in);\n        return 1;\n    }\n\n#ifdef ENABLE_IPV6\n    case AF_INET6:\n    {\n        *len_ret = sizeof (struct sockaddr_in6);\n        return 1;\n    }\n#endif /* ENABLE_IPV6 */\n\n#ifdef USE_BLUETOOTH\n    case AF_BLUETOOTH:\n    {\n        switch(s->sock_proto)\n        {\n\n#ifdef BTPROTO_L2CAP\n        case BTPROTO_L2CAP:\n            *len_ret = sizeof (struct sockaddr_l2);\n            return 1;\n#endif /* BTPROTO_L2CAP */\n        case BTPROTO_RFCOMM:\n            *len_ret = sizeof (struct sockaddr_rc);\n            return 1;\n#ifdef BTPROTO_HCI\n        case BTPROTO_HCI:\n            *len_ret = sizeof (struct sockaddr_hci);\n            return 1;\n#if !defined(__FreeBSD__)\n        case BTPROTO_SCO:\n            *len_ret = sizeof (struct sockaddr_sco);\n            return 1;\n#endif /* !__FreeBSD__ */\n#endif /* BTPROTO_HCI */\n        default:\n            PyErr_SetString(PyExc_OSError, \"getsockaddrlen: \"\n                            \"unknown BT protocol\");\n            return 0;\n\n        }\n    }\n#endif /* USE_BLUETOOTH */\n\n#ifdef HAVE_NETPACKET_PACKET_H\n    case AF_PACKET:\n    {\n        *len_ret = sizeof (struct sockaddr_ll);\n        return 1;\n    }\n#endif /* HAVE_NETPACKET_PACKET_H */\n\n#ifdef HAVE_LINUX_TIPC_H\n    case AF_TIPC:\n    {\n        *len_ret = sizeof (struct sockaddr_tipc);\n        return 1;\n    }\n#endif /* HAVE_LINUX_TIPC_H */\n\n#ifdef AF_CAN\n    case AF_CAN:\n    {\n        *len_ret = sizeof (struct sockaddr_can);\n        return 1;\n    }\n#endif /* AF_CAN */\n\n#ifdef PF_SYSTEM\n    case PF_SYSTEM:\n        switch(s->sock_proto) {\n#ifdef SYSPROTO_CONTROL\n        case SYSPROTO_CONTROL:\n            *len_ret = sizeof (struct sockaddr_ctl);\n            return 1;\n#endif /* SYSPROTO_CONTROL */\n        default:\n            PyErr_SetString(PyExc_OSError, \"getsockaddrlen: \"\n                            \"unknown PF_SYSTEM protocol\");\n            return 0;\n        }\n#endif /* PF_SYSTEM */\n#ifdef HAVE_SOCKADDR_ALG\n    case AF_ALG:\n    {\n        *len_ret = sizeof (struct sockaddr_alg);\n        return 1;\n    }\n#endif /* HAVE_SOCKADDR_ALG */\n#ifdef HAVE_AF_HYPERV\n    case AF_HYPERV:\n    {\n        *len_ret = sizeof (SOCKADDR_HV);\n        return 1;\n    }\n#endif /* HAVE_AF_HYPERV */\n\n    /* More cases here... */\n\n    default:\n        PyErr_SetString(PyExc_OSError, \"getsockaddrlen: bad family\");\n        return 0;\n\n    }\n}\n\n\n/* Support functions for the sendmsg() and recvmsg[_into]() methods.\n   Currently, these methods are only compiled if the RFC 2292/3542\n   CMSG_LEN() macro is available.  Older systems seem to have used\n   sizeof(struct cmsghdr) + (length) where CMSG_LEN() is used now, so\n   it may be possible to define CMSG_LEN() that way if it's not\n   provided.  Some architectures might need extra padding after the\n   cmsghdr, however, and CMSG_LEN() would have to take account of\n   this. */\n#ifdef CMSG_LEN\n/* If length is in range, set *result to CMSG_LEN(length) and return\n   true; otherwise, return false. */\nstatic int\nget_CMSG_LEN(size_t length, size_t *result)\n{\n    size_t tmp;\n\n    if (length > (SOCKLEN_T_LIMIT - CMSG_LEN(0)))\n        return 0;\n    tmp = CMSG_LEN(length);\n    if (tmp > SOCKLEN_T_LIMIT || tmp < length)\n        return 0;\n    *result = tmp;\n    return 1;\n}\n\n#ifdef CMSG_SPACE\n/* If length is in range, set *result to CMSG_SPACE(length) and return\n   true; otherwise, return false. */\nstatic int\nget_CMSG_SPACE(size_t length, size_t *result)\n{\n    size_t tmp;\n\n    /* Use CMSG_SPACE(1) here in order to take account of the padding\n       necessary before *and* after the data. */\n    if (length > (SOCKLEN_T_LIMIT - CMSG_SPACE(1)))\n        return 0;\n    tmp = CMSG_SPACE(length);\n    if (tmp > SOCKLEN_T_LIMIT || tmp < length)\n        return 0;\n    *result = tmp;\n    return 1;\n}\n#endif\n\n/* Return true iff msg->msg_controllen is valid, cmsgh is a valid\n   pointer in msg->msg_control with at least \"space\" bytes after it,\n   and its cmsg_len member inside the buffer. */\nstatic int\ncmsg_min_space(struct msghdr *msg, struct cmsghdr *cmsgh, size_t space)\n{\n    size_t cmsg_offset;\n    static const size_t cmsg_len_end = (offsetof(struct cmsghdr, cmsg_len) +\n                                        sizeof(cmsgh->cmsg_len));\n\n    /* Note that POSIX allows msg_controllen to be of signed type. */\n    if (cmsgh == NULL || msg->msg_control == NULL)\n        return 0;\n    /* Note that POSIX allows msg_controllen to be of a signed type. This is\n       annoying under OS X as it's unsigned there and so it triggers a\n       tautological comparison warning under Clang when compared against 0.\n       Since the check is valid on other platforms, silence the warning under\n       Clang. */\n    #ifdef __clang__\n    #pragma clang diagnostic push\n    #pragma clang diagnostic ignored \"-Wtautological-compare\"\n    #endif\n    #if defined(__GNUC__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5)))\n    #pragma GCC diagnostic push\n    #pragma GCC diagnostic ignored \"-Wtype-limits\"\n    #endif\n    if (msg->msg_controllen < 0)\n        return 0;\n    #if defined(__GNUC__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5)))\n    #pragma GCC diagnostic pop\n    #endif\n    #ifdef __clang__\n    #pragma clang diagnostic pop\n    #endif\n    if (space < cmsg_len_end)\n        space = cmsg_len_end;\n    cmsg_offset = (char *)cmsgh - (char *)msg->msg_control;\n    return (cmsg_offset <= (size_t)-1 - space &&\n            cmsg_offset + space <= msg->msg_controllen);\n}\n\n/* If pointer CMSG_DATA(cmsgh) is in buffer msg->msg_control, set\n   *space to number of bytes following it in the buffer and return\n   true; otherwise, return false.  Assumes cmsgh, msg->msg_control and\n   msg->msg_controllen are valid. */\nstatic int\nget_cmsg_data_space(struct msghdr *msg, struct cmsghdr *cmsgh, size_t *space)\n{\n    size_t data_offset;\n    char *data_ptr;\n\n    if ((data_ptr = (char *)CMSG_DATA(cmsgh)) == NULL)\n        return 0;\n    data_offset = data_ptr - (char *)msg->msg_control;\n    if (data_offset > msg->msg_controllen)\n        return 0;\n    *space = msg->msg_controllen - data_offset;\n    return 1;\n}\n\n/* If cmsgh is invalid or not contained in the buffer pointed to by\n   msg->msg_control, return -1.  If cmsgh is valid and its associated\n   data is entirely contained in the buffer, set *data_len to the\n   length of the associated data and return 0.  If only part of the\n   associated data is contained in the buffer but cmsgh is otherwise\n   valid, set *data_len to the length contained in the buffer and\n   return 1. */\nstatic int\nget_cmsg_data_len(struct msghdr *msg, struct cmsghdr *cmsgh, size_t *data_len)\n{\n    size_t space, cmsg_data_len;\n\n    if (!cmsg_min_space(msg, cmsgh, CMSG_LEN(0)) ||\n        cmsgh->cmsg_len < CMSG_LEN(0))\n        return -1;\n    cmsg_data_len = cmsgh->cmsg_len - CMSG_LEN(0);\n    if (!get_cmsg_data_space(msg, cmsgh, &space))\n        return -1;\n    if (space >= cmsg_data_len) {\n        *data_len = cmsg_data_len;\n        return 0;\n    }\n    *data_len = space;\n    return 1;\n}\n#endif    /* CMSG_LEN */\n\n\nstruct sock_accept {\n    socklen_t *addrlen;\n    sock_addr_t *addrbuf;\n    SOCKET_T result;\n};\n\n#if defined(HAVE_ACCEPT) || defined(HAVE_ACCEPT4)\n\nstatic int\nsock_accept_impl(PySocketSockObject *s, void *data)\n{\n    struct sock_accept *ctx = data;\n    struct sockaddr *addr = SAS2SA(ctx->addrbuf);\n    socklen_t *paddrlen = ctx->addrlen;\n#ifdef HAVE_SOCKADDR_ALG\n    /* AF_ALG does not support accept() with addr and raises\n     * ECONNABORTED instead. */\n    if (s->sock_family == AF_ALG) {\n        addr = NULL;\n        paddrlen = NULL;\n        *ctx->addrlen = 0;\n    }\n#endif\n\n#if defined(HAVE_ACCEPT4) && defined(SOCK_CLOEXEC)\n    socket_state *state = s->state;\n    if (state->accept4_works != 0) {\n        ctx->result = accept4(s->sock_fd, addr, paddrlen,\n                              SOCK_CLOEXEC);\n        if (ctx->result == INVALID_SOCKET && state->accept4_works == -1) {\n            /* On Linux older than 2.6.28, accept4() fails with ENOSYS */\n            state->accept4_works = (errno != ENOSYS);\n        }\n    }\n    if (state->accept4_works == 0)\n        ctx->result = accept(s->sock_fd, addr, paddrlen);\n#else\n    ctx->result = accept(s->sock_fd, addr, paddrlen);\n#endif\n\n#ifdef MS_WINDOWS\n    return (ctx->result != INVALID_SOCKET);\n#else\n    return (ctx->result >= 0);\n#endif\n}\n\n/* s._accept() -> (fd, address) */\n\nstatic PyObject *\nsock_accept(PySocketSockObject *s, PyObject *Py_UNUSED(ignored))\n{\n    sock_addr_t addrbuf;\n    SOCKET_T newfd;\n    socklen_t addrlen;\n    PyObject *sock = NULL;\n    PyObject *addr = NULL;\n    PyObject *res = NULL;\n    struct sock_accept ctx;\n\n    if (!getsockaddrlen(s, &addrlen))\n        return NULL;\n    memset(&addrbuf, 0, addrlen);\n\n    if (!IS_SELECTABLE(s))\n        return select_error();\n\n    ctx.addrlen = &addrlen;\n    ctx.addrbuf = &addrbuf;\n    if (sock_call(s, 0, sock_accept_impl, &ctx) < 0)\n        return NULL;\n    newfd = ctx.result;\n\n#ifdef MS_WINDOWS\n#if defined(MS_WINDOWS_APP) || defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_SYSTEM)\n#ifndef HANDLE_FLAG_INHERIT\n#define HANDLE_FLAG_INHERIT 0x00000001\n#endif\n    if (!SetHandleInformation((HANDLE)newfd, HANDLE_FLAG_INHERIT, 0)) {\n        PyErr_SetFromWindowsErr(0);\n        SOCKETCLOSE(newfd);\n        goto finally;\n    }\n#endif\n#else\n\n#if defined(HAVE_ACCEPT4) && defined(SOCK_CLOEXEC)\n    socket_state *state = s->state;\n    if (!state->accept4_works)\n#endif\n    {\n        if (_Py_set_inheritable(newfd, 0, NULL) < 0) {\n            SOCKETCLOSE(newfd);\n            goto finally;\n        }\n    }\n#endif\n\n    sock = PyLong_FromSocket_t(newfd);\n    if (sock == NULL) {\n        SOCKETCLOSE(newfd);\n        goto finally;\n    }\n\n    addr = makesockaddr(s->sock_fd, SAS2SA(&addrbuf),\n                        addrlen, s->sock_proto);\n    if (addr == NULL)\n        goto finally;\n\n    res = PyTuple_Pack(2, sock, addr);\n\nfinally:\n    Py_XDECREF(sock);\n    Py_XDECREF(addr);\n    return res;\n}\n\nPyDoc_STRVAR(accept_doc,\n\"_accept() -> (integer, address info)\\n\\\n\\n\\\nWait for an incoming connection.  Return a new socket file descriptor\\n\\\nrepresenting the connection, and the address of the client.\\n\\\nFor IP sockets, the address info is a pair (hostaddr, port).\");\n#endif // defined(HAVE_ACCEPT) || defined(HAVE_ACCEPT4)\n\n\n/* s.setblocking(flag) method.  Argument:\n   False -- non-blocking mode; same as settimeout(0)\n   True -- blocking mode; same as settimeout(None)\n*/\n\nstatic PyObject *\nsock_setblocking(PySocketSockObject *s, PyObject *arg)\n{\n    long block;\n\n    block = PyObject_IsTrue(arg);\n    if (block < 0)\n        return NULL;\n\n    s->sock_timeout = _PyTime_FromSeconds(block ? -1 : 0);\n    if (internal_setblocking(s, block) == -1) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(setblocking_doc,\n\"setblocking(flag)\\n\\\n\\n\\\nSet the socket to blocking (flag is true) or non-blocking (false).\\n\\\nsetblocking(True) is equivalent to settimeout(None);\\n\\\nsetblocking(False) is equivalent to settimeout(0.0).\");\n\n/* s.getblocking() method.\n   Returns True if socket is in blocking mode,\n   False if it is in non-blocking mode.\n*/\nstatic PyObject *\nsock_getblocking(PySocketSockObject *s, PyObject *Py_UNUSED(ignored))\n{\n    if (s->sock_timeout) {\n        Py_RETURN_TRUE;\n    }\n    else {\n        Py_RETURN_FALSE;\n    }\n}\n\nPyDoc_STRVAR(getblocking_doc,\n\"getblocking()\\n\\\n\\n\\\nReturns True if socket is in blocking mode, or False if it\\n\\\nis in non-blocking mode.\");\n\nstatic int\nsocket_parse_timeout(PyTime_t *timeout, PyObject *timeout_obj)\n{\n#ifdef MS_WINDOWS\n    struct timeval tv;\n#endif\n#ifndef HAVE_POLL\n    PyTime_t ms;\n#endif\n    int overflow = 0;\n\n    if (timeout_obj == Py_None) {\n        *timeout = _PyTime_FromSeconds(-1);\n        return 0;\n    }\n\n    if (_PyTime_FromSecondsObject(timeout,\n                                  timeout_obj, _PyTime_ROUND_TIMEOUT) < 0)\n        return -1;\n\n    if (*timeout < 0) {\n        PyErr_SetString(PyExc_ValueError, \"Timeout value out of range\");\n        return -1;\n    }\n\n#ifdef MS_WINDOWS\n    overflow |= (_PyTime_AsTimeval(*timeout, &tv, _PyTime_ROUND_TIMEOUT) < 0);\n#endif\n#ifndef HAVE_POLL\n    ms = _PyTime_AsMilliseconds(*timeout, _PyTime_ROUND_TIMEOUT);\n    overflow |= (ms > INT_MAX);\n#endif\n    if (overflow) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"timeout doesn't fit into C timeval\");\n        return -1;\n    }\n\n    return 0;\n}\n\n/* s.settimeout(timeout) method.  Argument:\n   None -- no timeout, blocking mode; same as setblocking(True)\n   0.0  -- non-blocking mode; same as setblocking(False)\n   > 0  -- timeout mode; operations time out after timeout seconds\n   < 0  -- illegal; raises an exception\n*/\nstatic PyObject *\nsock_settimeout(PySocketSockObject *s, PyObject *arg)\n{\n    PyTime_t timeout;\n\n    if (socket_parse_timeout(&timeout, arg) < 0)\n        return NULL;\n\n    s->sock_timeout = timeout;\n\n    int block = timeout < 0;\n    /* Blocking mode for a Python socket object means that operations\n       like :meth:`recv` or :meth:`sendall` will block the execution of\n       the current thread until they are complete or aborted with a\n       `TimeoutError` or `socket.error` errors.  When timeout is `None`,\n       the underlying FD is in a blocking mode.  When timeout is a positive\n       number, the FD is in a non-blocking mode, and socket ops are\n       implemented with a `select()` call.\n\n       When timeout is 0.0, the FD is in a non-blocking mode.\n\n       This table summarizes all states in which the socket object and\n       its underlying FD can be:\n\n       ==================== ===================== ==============\n        `gettimeout()`       `getblocking()`       FD\n       ==================== ===================== ==============\n        ``None``             ``True``              blocking\n        ``0.0``              ``False``             non-blocking\n        ``> 0``              ``True``              non-blocking\n    */\n\n    if (internal_setblocking(s, block) == -1) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(settimeout_doc,\n\"settimeout(timeout)\\n\\\n\\n\\\nSet a timeout on socket operations.  'timeout' can be a float,\\n\\\ngiving in seconds, or None.  Setting a timeout of None disables\\n\\\nthe timeout feature and is equivalent to setblocking(1).\\n\\\nSetting a timeout of zero is the same as setblocking(0).\");\n\n/* s.gettimeout() method.\n   Returns the timeout associated with a socket. */\nstatic PyObject *\nsock_gettimeout(PySocketSockObject *s, PyObject *Py_UNUSED(ignored))\n{\n    if (s->sock_timeout < 0) {\n        Py_RETURN_NONE;\n    }\n    else {\n        double seconds = PyTime_AsSecondsDouble(s->sock_timeout);\n        return PyFloat_FromDouble(seconds);\n    }\n}\n\nPyDoc_STRVAR(gettimeout_doc,\n\"gettimeout() -> timeout\\n\\\n\\n\\\nReturns the timeout in seconds (float) associated with socket\\n\\\noperations. A timeout of None indicates that timeouts on socket\\n\\\noperations are disabled.\");\n\n#ifdef HAVE_SETSOCKOPT\n/* s.setsockopt() method.\n   With an integer third argument, sets an integer optval with optlen=4.\n   With None as third argument and an integer fourth argument, set\n   optval=NULL with unsigned int as optlen.\n   With a string third argument, sets an option from a buffer;\n   use optional built-in module 'struct' to encode the string.\n*/\n\nstatic PyObject *\nsock_setsockopt(PySocketSockObject *s, PyObject *args)\n{\n    int level;\n    int optname;\n    int res;\n    Py_buffer optval;\n    int flag;\n    unsigned int optlen;\n    PyObject *none;\n\n#ifdef AF_VSOCK\n    if (s->sock_family == AF_VSOCK) {\n        uint64_t vflag; // Must be set width of 64 bits\n        /* setsockopt(level, opt, flag) */\n        if (PyArg_ParseTuple(args, \"iiK:setsockopt\",\n                         &level, &optname, &vflag)) {\n            // level should always be set to AF_VSOCK\n            res = setsockopt(s->sock_fd, level, optname,\n                         (void*)&vflag, sizeof vflag);\n            goto done;\n        }\n        return NULL;\n    }\n#endif\n\n    /* setsockopt(level, opt, flag) */\n    if (PyArg_ParseTuple(args, \"iii:setsockopt\",\n                         &level, &optname, &flag)) {\n        res = setsockopt(s->sock_fd, level, optname,\n                         (char*)&flag, sizeof flag);\n        goto done;\n    }\n\n    PyErr_Clear();\n    /* setsockopt(level, opt, None, flag) */\n    if (PyArg_ParseTuple(args, \"iiO!I:setsockopt\",\n                         &level, &optname, Py_TYPE(Py_None), &none, &optlen)) {\n        assert(sizeof(socklen_t) >= sizeof(unsigned int));\n        res = setsockopt(s->sock_fd, level, optname,\n                         NULL, (socklen_t)optlen);\n        goto done;\n    }\n\n    PyErr_Clear();\n    /* setsockopt(level, opt, buffer) */\n    if (!PyArg_ParseTuple(args, \"iiy*:setsockopt\",\n                            &level, &optname, &optval))\n        return NULL;\n\n#ifdef MS_WINDOWS\n    if (optval.len > INT_MAX) {\n        PyBuffer_Release(&optval);\n        PyErr_Format(PyExc_OverflowError,\n                        \"socket option is larger than %i bytes\",\n                        INT_MAX);\n        return NULL;\n    }\n    res = setsockopt(s->sock_fd, level, optname,\n                        optval.buf, (int)optval.len);\n#else\n    res = setsockopt(s->sock_fd, level, optname, optval.buf, optval.len);\n#endif\n    PyBuffer_Release(&optval);\n\ndone:\n    if (res < 0) {\n        return s->errorhandler();\n    }\n\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(setsockopt_doc,\n\"setsockopt(level, option, value: int)\\n\\\nsetsockopt(level, option, value: buffer)\\n\\\nsetsockopt(level, option, None, optlen: int)\\n\\\n\\n\\\nSet a socket option.  See the Unix manual for level and option.\\n\\\nThe value argument can either be an integer, a string buffer, or\\n\\\nNone, optlen.\");\n#endif\n\n/* s.getsockopt() method.\n   With two arguments, retrieves an integer option.\n   With a third integer argument, retrieves a string buffer of that size;\n   use optional built-in module 'struct' to decode the string. */\n\nstatic PyObject *\nsock_getsockopt(PySocketSockObject *s, PyObject *args)\n{\n    int level;\n    int optname;\n    int res;\n    PyObject *buf;\n    socklen_t buflen = 0;\n    int flag = 0;\n    socklen_t flagsize;\n\n    if (!PyArg_ParseTuple(args, \"ii|i:getsockopt\",\n                          &level, &optname, &buflen))\n        return NULL;\n\n    if (buflen == 0) {\n#ifdef AF_VSOCK\n        if (s->sock_family == AF_VSOCK) {\n            uint64_t vflag = 0; // Must be set width of 64 bits\n            flagsize = sizeof vflag;\n            res = getsockopt(s->sock_fd, level, optname,\n                         (void *)&vflag, &flagsize);\n            if (res < 0)\n                return s->errorhandler();\n            return PyLong_FromUnsignedLong(vflag);\n        }\n#endif\n        flagsize = sizeof flag;\n        res = getsockopt(s->sock_fd, level, optname,\n                         (void *)&flag, &flagsize);\n        if (res < 0)\n            return s->errorhandler();\n        return PyLong_FromLong(flag);\n    }\n#ifdef AF_VSOCK\n    if (s->sock_family == AF_VSOCK) {\n        PyErr_SetString(PyExc_OSError,\n                        \"getsockopt string buffer not allowed\");\n        return NULL;\n        }\n#endif\n    if (buflen <= 0 || buflen > 1024) {\n        PyErr_SetString(PyExc_OSError,\n                        \"getsockopt buflen out of range\");\n        return NULL;\n    }\n    buf = PyBytes_FromStringAndSize((char *)NULL, buflen);\n    if (buf == NULL)\n        return NULL;\n    res = getsockopt(s->sock_fd, level, optname,\n                     (void *)PyBytes_AS_STRING(buf), &buflen);\n    if (res < 0) {\n        Py_DECREF(buf);\n        return s->errorhandler();\n    }\n    _PyBytes_Resize(&buf, buflen);\n    return buf;\n}\n\nPyDoc_STRVAR(getsockopt_doc,\n\"getsockopt(level, option[, buffersize]) -> value\\n\\\n\\n\\\nGet a socket option.  See the Unix manual for level and option.\\n\\\nIf a nonzero buffersize argument is given, the return value is a\\n\\\nstring of that length; otherwise it is an integer.\");\n\n\n#ifdef HAVE_BIND\n/* s.bind(sockaddr) method */\n\nstatic PyObject *\nsock_bind(PySocketSockObject *s, PyObject *addro)\n{\n    sock_addr_t addrbuf;\n    int addrlen;\n    int res;\n\n    if (!getsockaddrarg(s, addro, &addrbuf, &addrlen, \"bind\")) {\n        return NULL;\n    }\n\n    if (PySys_Audit(\"socket.bind\", \"OO\", s, addro) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    res = bind(s->sock_fd, SAS2SA(&addrbuf), addrlen);\n    Py_END_ALLOW_THREADS\n    if (res < 0)\n        return s->errorhandler();\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(bind_doc,\n\"bind(address)\\n\\\n\\n\\\nBind the socket to a local address.  For IP sockets, the address is a\\n\\\npair (host, port); the host must refer to the local host. For raw packet\\n\\\nsockets the address is a tuple (ifname, proto [,pkttype [,hatype [,addr]]])\");\n#endif\n\n\n/* s.close() method.\n   Set the file descriptor to -1 so operations tried subsequently\n   will surely fail. */\n\nstatic PyObject *\nsock_close(PySocketSockObject *s, PyObject *Py_UNUSED(ignored))\n{\n    SOCKET_T fd;\n    int res;\n\n    fd = s->sock_fd;\n    if (fd != INVALID_SOCKET) {\n        s->sock_fd = INVALID_SOCKET;\n\n        /* We do not want to retry upon EINTR: see\n           http://lwn.net/Articles/576478/ and\n           http://linux.derkeiler.com/Mailing-Lists/Kernel/2005-09/3000.html\n           for more details. */\n        Py_BEGIN_ALLOW_THREADS\n        res = SOCKETCLOSE(fd);\n        Py_END_ALLOW_THREADS\n        /* bpo-30319: The peer can already have closed the connection.\n           Python ignores ECONNRESET on close(). */\n        if (res < 0 && errno != ECONNRESET) {\n            return s->errorhandler();\n        }\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(sock_close_doc,\n\"close()\\n\\\n\\n\\\nClose the socket.  It cannot be used after this call.\");\n\nstatic PyObject *\nsock_detach(PySocketSockObject *s, PyObject *Py_UNUSED(ignored))\n{\n    SOCKET_T fd = s->sock_fd;\n    s->sock_fd = INVALID_SOCKET;\n    return PyLong_FromSocket_t(fd);\n}\n\nPyDoc_STRVAR(detach_doc,\n\"detach()\\n\\\n\\n\\\nClose the socket object without closing the underlying file descriptor.\\n\\\nThe object cannot be used after this call, but the file descriptor\\n\\\ncan be reused for other purposes.  The file descriptor is returned.\");\n\n#ifdef HAVE_CONNECT\nstatic int\nsock_connect_impl(PySocketSockObject *s, void* Py_UNUSED(data))\n{\n    int err;\n    socklen_t size = sizeof err;\n\n    if (getsockopt(s->sock_fd, SOL_SOCKET, SO_ERROR, (void *)&err, &size)) {\n        /* getsockopt() failed */\n        return 0;\n    }\n\n    if (err == EISCONN)\n        return 1;\n    if (err != 0) {\n        /* sock_call_ex() uses GET_SOCK_ERROR() to get the error code */\n        SET_SOCK_ERROR(err);\n        return 0;\n    }\n    return 1;\n}\n\nstatic int\ninternal_connect(PySocketSockObject *s, struct sockaddr *addr, int addrlen,\n                 int raise)\n{\n    int res, err, wait_connect;\n\n    Py_BEGIN_ALLOW_THREADS\n    res = connect(s->sock_fd, addr, addrlen);\n    Py_END_ALLOW_THREADS\n\n    if (!res) {\n        /* connect() succeeded, the socket is connected */\n        return 0;\n    }\n\n    /* connect() failed */\n\n    /* save error, PyErr_CheckSignals() can replace it */\n    err = GET_SOCK_ERROR;\n    if (CHECK_ERRNO(EINTR)) {\n        if (PyErr_CheckSignals())\n            return -1;\n\n        /* Issue #23618: when connect() fails with EINTR, the connection is\n           running asynchronously.\n\n           If the socket is blocking or has a timeout, wait until the\n           connection completes, fails or timed out using select(), and then\n           get the connection status using getsockopt(SO_ERROR).\n\n           If the socket is non-blocking, raise InterruptedError. The caller is\n           responsible to wait until the connection completes, fails or timed\n           out (it's the case in asyncio for example). */\n        wait_connect = (s->sock_timeout != 0 && IS_SELECTABLE(s));\n    }\n    else {\n        wait_connect = (s->sock_timeout > 0 && err == SOCK_INPROGRESS_ERR\n                        && IS_SELECTABLE(s));\n    }\n\n    if (!wait_connect) {\n        if (raise) {\n            /* restore error, maybe replaced by PyErr_CheckSignals() */\n            SET_SOCK_ERROR(err);\n            s->errorhandler();\n            return -1;\n        }\n        else\n            return err;\n    }\n\n    if (raise) {\n        /* socket.connect() raises an exception on error */\n        if (sock_call_ex(s, 1, sock_connect_impl, NULL,\n                         1, NULL, s->sock_timeout) < 0)\n            return -1;\n    }\n    else {\n        /* socket.connect_ex() returns the error code on error */\n        if (sock_call_ex(s, 1, sock_connect_impl, NULL,\n                         1, &err, s->sock_timeout) < 0)\n            return err;\n    }\n    return 0;\n}\n\n/* s.connect(sockaddr) method */\n\nstatic PyObject *\nsock_connect(PySocketSockObject *s, PyObject *addro)\n{\n    sock_addr_t addrbuf;\n    int addrlen;\n    int res;\n\n    if (!getsockaddrarg(s, addro, &addrbuf, &addrlen, \"connect\")) {\n        return NULL;\n    }\n\n    if (PySys_Audit(\"socket.connect\", \"OO\", s, addro) < 0) {\n        return NULL;\n    }\n\n    res = internal_connect(s, SAS2SA(&addrbuf), addrlen, 1);\n    if (res < 0)\n        return NULL;\n\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(connect_doc,\n\"connect(address)\\n\\\n\\n\\\nConnect the socket to a remote address.  For IP sockets, the address\\n\\\nis a pair (host, port).\");\n\n\n/* s.connect_ex(sockaddr) method */\n\nstatic PyObject *\nsock_connect_ex(PySocketSockObject *s, PyObject *addro)\n{\n    sock_addr_t addrbuf;\n    int addrlen;\n    int res;\n\n    if (!getsockaddrarg(s, addro, &addrbuf, &addrlen, \"connect_ex\")) {\n        return NULL;\n    }\n\n    if (PySys_Audit(\"socket.connect\", \"OO\", s, addro) < 0) {\n        return NULL;\n    }\n\n    res = internal_connect(s, SAS2SA(&addrbuf), addrlen, 0);\n    if (res < 0)\n        return NULL;\n\n    return PyLong_FromLong((long) res);\n}\n\nPyDoc_STRVAR(connect_ex_doc,\n\"connect_ex(address) -> errno\\n\\\n\\n\\\nThis is like connect(address), but returns an error code (the errno value)\\n\\\ninstead of raising an exception when an error occurs.\");\n#endif // HAVE_CONNECT\n\n\n/* s.fileno() method */\n\nstatic PyObject *\nsock_fileno(PySocketSockObject *s, PyObject *Py_UNUSED(ignored))\n{\n    return PyLong_FromSocket_t(s->sock_fd);\n}\n\nPyDoc_STRVAR(fileno_doc,\n\"fileno() -> integer\\n\\\n\\n\\\nReturn the integer file descriptor of the socket.\");\n\n\n#ifdef HAVE_GETSOCKNAME\n/* s.getsockname() method */\n\nstatic PyObject *\nsock_getsockname(PySocketSockObject *s, PyObject *Py_UNUSED(ignored))\n{\n    sock_addr_t addrbuf;\n    int res;\n    socklen_t addrlen;\n\n    if (!getsockaddrlen(s, &addrlen))\n        return NULL;\n    memset(&addrbuf, 0, addrlen);\n    Py_BEGIN_ALLOW_THREADS\n    res = getsockname(s->sock_fd, SAS2SA(&addrbuf), &addrlen);\n    Py_END_ALLOW_THREADS\n    if (res < 0)\n        return s->errorhandler();\n    return makesockaddr(s->sock_fd, SAS2SA(&addrbuf), addrlen,\n                        s->sock_proto);\n}\n\nPyDoc_STRVAR(getsockname_doc,\n\"getsockname() -> address info\\n\\\n\\n\\\nReturn the address of the local endpoint. The format depends on the\\n\\\naddress family. For IPv4 sockets, the address info is a pair\\n\\\n(hostaddr, port). For IPv6 sockets, the address info is a 4-tuple\\n\\\n(hostaddr, port, flowinfo, scope_id).\");\n#endif\n\n\n#ifdef HAVE_GETPEERNAME         /* Cray APP doesn't have this :-( */\n/* s.getpeername() method */\n\nstatic PyObject *\nsock_getpeername(PySocketSockObject *s, PyObject *Py_UNUSED(ignored))\n{\n    sock_addr_t addrbuf;\n    int res;\n    socklen_t addrlen;\n\n    if (!getsockaddrlen(s, &addrlen))\n        return NULL;\n    memset(&addrbuf, 0, addrlen);\n    Py_BEGIN_ALLOW_THREADS\n    res = getpeername(s->sock_fd, SAS2SA(&addrbuf), &addrlen);\n    Py_END_ALLOW_THREADS\n    if (res < 0)\n        return s->errorhandler();\n    return makesockaddr(s->sock_fd, SAS2SA(&addrbuf), addrlen,\n                        s->sock_proto);\n}\n\nPyDoc_STRVAR(getpeername_doc,\n\"getpeername() -> address info\\n\\\n\\n\\\nReturn the address of the remote endpoint.  For IP sockets, the address\\n\\\ninfo is a pair (hostaddr, port).\");\n\n#endif /* HAVE_GETPEERNAME */\n\n\n#ifdef HAVE_LISTEN\n/* s.listen(n) method */\n\nstatic PyObject *\nsock_listen(PySocketSockObject *s, PyObject *args)\n{\n    /* We try to choose a default backlog high enough to avoid connection drops\n     * for common workloads, yet not too high to limit resource usage. */\n    int backlog = Py_MIN(SOMAXCONN, 128);\n    int res;\n\n    if (!PyArg_ParseTuple(args, \"|i:listen\", &backlog))\n        return NULL;\n\n    Py_BEGIN_ALLOW_THREADS\n    /* To avoid problems on systems that don't allow a negative backlog\n     * (which doesn't make sense anyway) we force a minimum value of 0. */\n    if (backlog < 0)\n        backlog = 0;\n    res = listen(s->sock_fd, backlog);\n    Py_END_ALLOW_THREADS\n    if (res < 0)\n        return s->errorhandler();\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(listen_doc,\n\"listen([backlog])\\n\\\n\\n\\\nEnable a server to accept connections.  If backlog is specified, it must be\\n\\\nat least 0 (if it is lower, it is set to 0); it specifies the number of\\n\\\nunaccepted connections that the system will allow before refusing new\\n\\\nconnections. If not specified, a default reasonable value is chosen.\");\n#endif\n\nstruct sock_recv {\n    char *cbuf;\n    Py_ssize_t len;\n    int flags;\n    Py_ssize_t result;\n};\n\nstatic int\nsock_recv_impl(PySocketSockObject *s, void *data)\n{\n    struct sock_recv *ctx = data;\n\n#ifdef MS_WINDOWS\n    if (ctx->len > INT_MAX)\n        ctx->len = INT_MAX;\n    ctx->result = recv(s->sock_fd, ctx->cbuf, (int)ctx->len, ctx->flags);\n#else\n    ctx->result = recv(s->sock_fd, ctx->cbuf, ctx->len, ctx->flags);\n#endif\n    return (ctx->result >= 0);\n}\n\n\n/*\n * This is the guts of the recv() and recv_into() methods, which reads into a\n * char buffer.  If you have any inc/dec ref to do to the objects that contain\n * the buffer, do it in the caller.  This function returns the number of bytes\n * successfully read.  If there was an error, it returns -1.  Note that it is\n * also possible that we return a number of bytes smaller than the request\n * bytes.\n */\n\nstatic Py_ssize_t\nsock_recv_guts(PySocketSockObject *s, char* cbuf, Py_ssize_t len, int flags)\n{\n    struct sock_recv ctx;\n\n    if (!IS_SELECTABLE(s)) {\n        select_error();\n        return -1;\n    }\n    if (len == 0) {\n        /* If 0 bytes were requested, do nothing. */\n        return 0;\n    }\n\n    ctx.cbuf = cbuf;\n    ctx.len = len;\n    ctx.flags = flags;\n    if (sock_call(s, 0, sock_recv_impl, &ctx) < 0)\n        return -1;\n\n    return ctx.result;\n}\n\n\n/* s.recv(nbytes [,flags]) method */\n\nstatic PyObject *\nsock_recv(PySocketSockObject *s, PyObject *args)\n{\n    Py_ssize_t recvlen, outlen;\n    int flags = 0;\n    PyObject *buf;\n\n    if (!PyArg_ParseTuple(args, \"n|i:recv\", &recvlen, &flags))\n        return NULL;\n\n    if (recvlen < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"negative buffersize in recv\");\n        return NULL;\n    }\n\n    /* Allocate a new string. */\n    buf = PyBytes_FromStringAndSize((char *) 0, recvlen);\n    if (buf == NULL)\n        return NULL;\n\n    /* Call the guts */\n    outlen = sock_recv_guts(s, PyBytes_AS_STRING(buf), recvlen, flags);\n    if (outlen < 0) {\n        /* An error occurred, release the string and return an\n           error. */\n        Py_DECREF(buf);\n        return NULL;\n    }\n    if (outlen != recvlen) {\n        /* We did not read as many bytes as we anticipated, resize the\n           string if possible and be successful. */\n        _PyBytes_Resize(&buf, outlen);\n    }\n\n    return buf;\n}\n\nPyDoc_STRVAR(recv_doc,\n\"recv(buffersize[, flags]) -> data\\n\\\n\\n\\\nReceive up to buffersize bytes from the socket.  For the optional flags\\n\\\nargument, see the Unix manual.  When no data is available, block until\\n\\\nat least one byte is available or until the remote end is closed.  When\\n\\\nthe remote end is closed and all data is read, return the empty string.\");\n\n\n/* s.recv_into(buffer, [nbytes [,flags]]) method */\n\nstatic PyObject*\nsock_recv_into(PySocketSockObject *s, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"buffer\", \"nbytes\", \"flags\", 0};\n\n    int flags = 0;\n    Py_buffer pbuf;\n    char *buf;\n    Py_ssize_t buflen, readlen, recvlen = 0;\n\n    /* Get the buffer's memory */\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"w*|ni:recv_into\", kwlist,\n                                     &pbuf, &recvlen, &flags))\n        return NULL;\n    buf = pbuf.buf;\n    buflen = pbuf.len;\n\n    if (recvlen < 0) {\n        PyBuffer_Release(&pbuf);\n        PyErr_SetString(PyExc_ValueError,\n                        \"negative buffersize in recv_into\");\n        return NULL;\n    }\n    if (recvlen == 0) {\n        /* If nbytes was not specified, use the buffer's length */\n        recvlen = buflen;\n    }\n\n    /* Check if the buffer is large enough */\n    if (buflen < recvlen) {\n        PyBuffer_Release(&pbuf);\n        PyErr_SetString(PyExc_ValueError,\n                        \"buffer too small for requested bytes\");\n        return NULL;\n    }\n\n    /* Call the guts */\n    readlen = sock_recv_guts(s, buf, recvlen, flags);\n    if (readlen < 0) {\n        /* Return an error. */\n        PyBuffer_Release(&pbuf);\n        return NULL;\n    }\n\n    PyBuffer_Release(&pbuf);\n    /* Return the number of bytes read.  Note that we do not do anything\n       special here in the case that readlen < recvlen. */\n    return PyLong_FromSsize_t(readlen);\n}\n\nPyDoc_STRVAR(recv_into_doc,\n\"recv_into(buffer, [nbytes[, flags]]) -> nbytes_read\\n\\\n\\n\\\nA version of recv() that stores its data into a buffer rather than creating\\n\\\na new string.  Receive up to buffersize bytes from the socket.  If buffersize\\n\\\nis not specified (or 0), receive up to the size available in the given buffer.\\n\\\n\\n\\\nSee recv() for documentation about the flags.\");\n\nstruct sock_recvfrom {\n    char* cbuf;\n    Py_ssize_t len;\n    int flags;\n    socklen_t *addrlen;\n    sock_addr_t *addrbuf;\n    Py_ssize_t result;\n};\n\n#ifdef HAVE_RECVFROM\nstatic int\nsock_recvfrom_impl(PySocketSockObject *s, void *data)\n{\n    struct sock_recvfrom *ctx = data;\n\n    memset(ctx->addrbuf, 0, *ctx->addrlen);\n\n#ifdef MS_WINDOWS\n    if (ctx->len > INT_MAX)\n        ctx->len = INT_MAX;\n    ctx->result = recvfrom(s->sock_fd, ctx->cbuf, (int)ctx->len, ctx->flags,\n                           SAS2SA(ctx->addrbuf), ctx->addrlen);\n#else\n    ctx->result = recvfrom(s->sock_fd, ctx->cbuf, ctx->len, ctx->flags,\n                           SAS2SA(ctx->addrbuf), ctx->addrlen);\n#endif\n    return (ctx->result >= 0);\n}\n\n\n/*\n * This is the guts of the recvfrom() and recvfrom_into() methods, which reads\n * into a char buffer.  If you have any inc/def ref to do to the objects that\n * contain the buffer, do it in the caller.  This function returns the number\n * of bytes successfully read.  If there was an error, it returns -1.  Note\n * that it is also possible that we return a number of bytes smaller than the\n * request bytes.\n *\n * 'addr' is a return value for the address object.  Note that you must decref\n * it yourself.\n */\nstatic Py_ssize_t\nsock_recvfrom_guts(PySocketSockObject *s, char* cbuf, Py_ssize_t len, int flags,\n                   PyObject** addr)\n{\n    sock_addr_t addrbuf;\n    socklen_t addrlen;\n    struct sock_recvfrom ctx;\n\n    *addr = NULL;\n\n    if (!getsockaddrlen(s, &addrlen))\n        return -1;\n\n    if (!IS_SELECTABLE(s)) {\n        select_error();\n        return -1;\n    }\n\n    ctx.cbuf = cbuf;\n    ctx.len = len;\n    ctx.flags = flags;\n    ctx.addrbuf = &addrbuf;\n    ctx.addrlen = &addrlen;\n    if (sock_call(s, 0, sock_recvfrom_impl, &ctx) < 0)\n        return -1;\n\n    *addr = makesockaddr(s->sock_fd, SAS2SA(&addrbuf), addrlen,\n                         s->sock_proto);\n    if (*addr == NULL)\n        return -1;\n\n    return ctx.result;\n}\n\n/* s.recvfrom(nbytes [,flags]) method */\n\nstatic PyObject *\nsock_recvfrom(PySocketSockObject *s, PyObject *args)\n{\n    PyObject *buf = NULL;\n    PyObject *addr = NULL;\n    PyObject *ret = NULL;\n    int flags = 0;\n    Py_ssize_t recvlen, outlen;\n\n    if (!PyArg_ParseTuple(args, \"n|i:recvfrom\", &recvlen, &flags))\n        return NULL;\n\n    if (recvlen < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"negative buffersize in recvfrom\");\n        return NULL;\n    }\n\n    buf = PyBytes_FromStringAndSize((char *) 0, recvlen);\n    if (buf == NULL)\n        return NULL;\n\n    outlen = sock_recvfrom_guts(s, PyBytes_AS_STRING(buf),\n                                recvlen, flags, &addr);\n    if (outlen < 0) {\n        goto finally;\n    }\n\n    if (outlen != recvlen) {\n        /* We did not read as many bytes as we anticipated, resize the\n           string if possible and be successful. */\n        if (_PyBytes_Resize(&buf, outlen) < 0)\n            /* Oopsy, not so successful after all. */\n            goto finally;\n    }\n\n    ret = PyTuple_Pack(2, buf, addr);\n\nfinally:\n    Py_XDECREF(buf);\n    Py_XDECREF(addr);\n    return ret;\n}\n\nPyDoc_STRVAR(recvfrom_doc,\n\"recvfrom(buffersize[, flags]) -> (data, address info)\\n\\\n\\n\\\nLike recv(buffersize, flags) but also return the sender's address info.\");\n\n\n/* s.recvfrom_into(buffer[, nbytes [,flags]]) method */\n\nstatic PyObject *\nsock_recvfrom_into(PySocketSockObject *s, PyObject *args, PyObject* kwds)\n{\n    static char *kwlist[] = {\"buffer\", \"nbytes\", \"flags\", 0};\n\n    int flags = 0;\n    Py_buffer pbuf;\n    char *buf;\n    Py_ssize_t readlen, buflen, recvlen = 0;\n\n    PyObject *addr = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"w*|ni:recvfrom_into\",\n                                     kwlist, &pbuf,\n                                     &recvlen, &flags))\n        return NULL;\n    buf = pbuf.buf;\n    buflen = pbuf.len;\n\n    if (recvlen < 0) {\n        PyBuffer_Release(&pbuf);\n        PyErr_SetString(PyExc_ValueError,\n                        \"negative buffersize in recvfrom_into\");\n        return NULL;\n    }\n    if (recvlen == 0) {\n        /* If nbytes was not specified, use the buffer's length */\n        recvlen = buflen;\n    } else if (recvlen > buflen) {\n        PyBuffer_Release(&pbuf);\n        PyErr_SetString(PyExc_ValueError,\n                        \"nbytes is greater than the length of the buffer\");\n        return NULL;\n    }\n\n    readlen = sock_recvfrom_guts(s, buf, recvlen, flags, &addr);\n    if (readlen < 0) {\n        PyBuffer_Release(&pbuf);\n        /* Return an error */\n        Py_XDECREF(addr);\n        return NULL;\n    }\n\n    PyBuffer_Release(&pbuf);\n    /* Return the number of bytes read and the address.  Note that we do\n       not do anything special here in the case that readlen < recvlen. */\n    return Py_BuildValue(\"nN\", readlen, addr);\n}\n\nPyDoc_STRVAR(recvfrom_into_doc,\n\"recvfrom_into(buffer[, nbytes[, flags]]) -> (nbytes, address info)\\n\\\n\\n\\\nLike recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info.\");\n#endif\n\n/* The sendmsg() and recvmsg[_into]() methods require a working\n   CMSG_LEN().  See the comment near get_CMSG_LEN(). */\n#ifdef CMSG_LEN\nstruct sock_recvmsg {\n    struct msghdr *msg;\n    int flags;\n    ssize_t result;\n};\n\nstatic int\nsock_recvmsg_impl(PySocketSockObject *s, void *data)\n{\n    struct sock_recvmsg *ctx = data;\n\n    ctx->result = recvmsg(s->sock_fd, ctx->msg, ctx->flags);\n    return  (ctx->result >= 0);\n}\n\n/*\n * Call recvmsg() with the supplied iovec structures, flags, and\n * ancillary data buffer size (controllen).  Returns the tuple return\n * value for recvmsg() or recvmsg_into(), with the first item provided\n * by the supplied makeval() function.  makeval() will be called with\n * the length read and makeval_data as arguments, and must return a\n * new reference (which will be decrefed if there is a subsequent\n * error).  On error, closes any file descriptors received via\n * SCM_RIGHTS.\n */\nstatic PyObject *\nsock_recvmsg_guts(PySocketSockObject *s, struct iovec *iov, int iovlen,\n                  int flags, Py_ssize_t controllen,\n                  PyObject *(*makeval)(ssize_t, void *), void *makeval_data)\n{\n    sock_addr_t addrbuf;\n    socklen_t addrbuflen;\n    struct msghdr msg = {0};\n    PyObject *cmsg_list = NULL, *retval = NULL;\n    void *controlbuf = NULL;\n    struct cmsghdr *cmsgh;\n    size_t cmsgdatalen = 0;\n    int cmsg_status;\n    struct sock_recvmsg ctx;\n\n    /* XXX: POSIX says that msg_name and msg_namelen \"shall be\n       ignored\" when the socket is connected (Linux fills them in\n       anyway for AF_UNIX sockets at least).  Normally msg_namelen\n       seems to be set to 0 if there's no address, but try to\n       initialize msg_name to something that won't be mistaken for a\n       real address if that doesn't happen. */\n    if (!getsockaddrlen(s, &addrbuflen))\n        return NULL;\n    memset(&addrbuf, 0, addrbuflen);\n    SAS2SA(&addrbuf)->sa_family = AF_UNSPEC;\n\n    if (controllen < 0 || controllen > SOCKLEN_T_LIMIT) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"invalid ancillary data buffer length\");\n        return NULL;\n    }\n    if (controllen > 0 && (controlbuf = PyMem_Malloc(controllen)) == NULL)\n        return PyErr_NoMemory();\n\n    /* Make the system call. */\n    if (!IS_SELECTABLE(s)) {\n        select_error();\n        goto finally;\n    }\n\n    msg.msg_name = SAS2SA(&addrbuf);\n    msg.msg_namelen = addrbuflen;\n    msg.msg_iov = iov;\n    msg.msg_iovlen = iovlen;\n    msg.msg_control = controlbuf;\n    msg.msg_controllen = controllen;\n\n    ctx.msg = &msg;\n    ctx.flags = flags;\n    if (sock_call(s, 0, sock_recvmsg_impl, &ctx) < 0)\n        goto finally;\n\n    /* Make list of (level, type, data) tuples from control messages. */\n    if ((cmsg_list = PyList_New(0)) == NULL)\n        goto err_closefds;\n    /* Check for empty ancillary data as old CMSG_FIRSTHDR()\n       implementations didn't do so. */\n    for (cmsgh = ((msg.msg_controllen > 0) ? CMSG_FIRSTHDR(&msg) : NULL);\n         cmsgh != NULL; cmsgh = CMSG_NXTHDR(&msg, cmsgh)) {\n        PyObject *bytes, *tuple;\n        int tmp;\n\n        cmsg_status = get_cmsg_data_len(&msg, cmsgh, &cmsgdatalen);\n        if (cmsg_status != 0) {\n            if (PyErr_WarnEx(PyExc_RuntimeWarning,\n                             \"received malformed or improperly-truncated \"\n                             \"ancillary data\", 1) == -1)\n                goto err_closefds;\n        }\n        if (cmsg_status < 0)\n            break;\n        if (cmsgdatalen > PY_SSIZE_T_MAX) {\n            PyErr_SetString(PyExc_OSError, \"control message too long\");\n            goto err_closefds;\n        }\n\n        bytes = PyBytes_FromStringAndSize((char *)CMSG_DATA(cmsgh),\n                                          cmsgdatalen);\n        tuple = Py_BuildValue(\"iiN\", (int)cmsgh->cmsg_level,\n                              (int)cmsgh->cmsg_type, bytes);\n        if (tuple == NULL)\n            goto err_closefds;\n        tmp = PyList_Append(cmsg_list, tuple);\n        Py_DECREF(tuple);\n        if (tmp != 0)\n            goto err_closefds;\n\n        if (cmsg_status != 0)\n            break;\n    }\n\n    retval = Py_BuildValue(\"NOiN\",\n                           (*makeval)(ctx.result, makeval_data),\n                           cmsg_list,\n                           (int)msg.msg_flags,\n                           makesockaddr(s->sock_fd, SAS2SA(&addrbuf),\n                                        ((msg.msg_namelen > addrbuflen) ?\n                                         addrbuflen : msg.msg_namelen),\n                                        s->sock_proto));\n    if (retval == NULL)\n        goto err_closefds;\n\nfinally:\n    Py_XDECREF(cmsg_list);\n    PyMem_Free(controlbuf);\n    return retval;\n\nerr_closefds:\n#ifdef SCM_RIGHTS\n    /* Close all descriptors coming from SCM_RIGHTS, so they don't leak. */\n    for (cmsgh = ((msg.msg_controllen > 0) ? CMSG_FIRSTHDR(&msg) : NULL);\n         cmsgh != NULL; cmsgh = CMSG_NXTHDR(&msg, cmsgh)) {\n        cmsg_status = get_cmsg_data_len(&msg, cmsgh, &cmsgdatalen);\n        if (cmsg_status < 0)\n            break;\n        if (cmsgh->cmsg_level == SOL_SOCKET &&\n            cmsgh->cmsg_type == SCM_RIGHTS) {\n            size_t numfds;\n            int *fdp;\n\n            numfds = cmsgdatalen / sizeof(int);\n            fdp = (int *)CMSG_DATA(cmsgh);\n            while (numfds-- > 0)\n                close(*fdp++);\n        }\n        if (cmsg_status != 0)\n            break;\n    }\n#endif /* SCM_RIGHTS */\n    goto finally;\n}\n\n\nstatic PyObject *\nmakeval_recvmsg(ssize_t received, void *data)\n{\n    PyObject **buf = data;\n\n    if (received < PyBytes_GET_SIZE(*buf))\n        _PyBytes_Resize(buf, received);\n    return Py_XNewRef(*buf);\n}\n\n/* s.recvmsg(bufsize[, ancbufsize[, flags]]) method */\n\nstatic PyObject *\nsock_recvmsg(PySocketSockObject *s, PyObject *args)\n{\n    Py_ssize_t bufsize, ancbufsize = 0;\n    int flags = 0;\n    struct iovec iov;\n    PyObject *buf = NULL, *retval = NULL;\n\n    if (!PyArg_ParseTuple(args, \"n|ni:recvmsg\", &bufsize, &ancbufsize, &flags))\n        return NULL;\n\n    if (bufsize < 0) {\n        PyErr_SetString(PyExc_ValueError, \"negative buffer size in recvmsg()\");\n        return NULL;\n    }\n    if ((buf = PyBytes_FromStringAndSize(NULL, bufsize)) == NULL)\n        return NULL;\n    iov.iov_base = PyBytes_AS_STRING(buf);\n    iov.iov_len = bufsize;\n\n    /* Note that we're passing a pointer to *our pointer* to the bytes\n       object here (&buf); makeval_recvmsg() may incref the object, or\n       deallocate it and set our pointer to NULL. */\n    retval = sock_recvmsg_guts(s, &iov, 1, flags, ancbufsize,\n                               &makeval_recvmsg, &buf);\n    Py_XDECREF(buf);\n    return retval;\n}\n\nPyDoc_STRVAR(recvmsg_doc,\n\"recvmsg(bufsize[, ancbufsize[, flags]]) -> (data, ancdata, msg_flags, address)\\n\\\n\\n\\\nReceive normal data (up to bufsize bytes) and ancillary data from the\\n\\\nsocket.  The ancbufsize argument sets the size in bytes of the\\n\\\ninternal buffer used to receive the ancillary data; it defaults to 0,\\n\\\nmeaning that no ancillary data will be received.  Appropriate buffer\\n\\\nsizes for ancillary data can be calculated using CMSG_SPACE() or\\n\\\nCMSG_LEN(), and items which do not fit into the buffer might be\\n\\\ntruncated or discarded.  The flags argument defaults to 0 and has the\\n\\\nsame meaning as for recv().\\n\\\n\\n\\\nThe return value is a 4-tuple: (data, ancdata, msg_flags, address).\\n\\\nThe data item is a bytes object holding the non-ancillary data\\n\\\nreceived.  The ancdata item is a list of zero or more tuples\\n\\\n(cmsg_level, cmsg_type, cmsg_data) representing the ancillary data\\n\\\n(control messages) received: cmsg_level and cmsg_type are integers\\n\\\nspecifying the protocol level and protocol-specific type respectively,\\n\\\nand cmsg_data is a bytes object holding the associated data.  The\\n\\\nmsg_flags item is the bitwise OR of various flags indicating\\n\\\nconditions on the received message; see your system documentation for\\n\\\ndetails.  If the receiving socket is unconnected, address is the\\n\\\naddress of the sending socket, if available; otherwise, its value is\\n\\\nunspecified.\\n\\\n\\n\\\nIf recvmsg() raises an exception after the system call returns, it\\n\\\nwill first attempt to close any file descriptors received via the\\n\\\nSCM_RIGHTS mechanism.\");\n\n\nstatic PyObject *\nmakeval_recvmsg_into(ssize_t received, void *data)\n{\n    return PyLong_FromSsize_t(received);\n}\n\n/* s.recvmsg_into(buffers[, ancbufsize[, flags]]) method */\n\nstatic PyObject *\nsock_recvmsg_into(PySocketSockObject *s, PyObject *args)\n{\n    Py_ssize_t ancbufsize = 0;\n    int flags = 0;\n    struct iovec *iovs = NULL;\n    Py_ssize_t i, nitems, nbufs = 0;\n    Py_buffer *bufs = NULL;\n    PyObject *buffers_arg, *fast, *retval = NULL;\n\n    if (!PyArg_ParseTuple(args, \"O|ni:recvmsg_into\",\n                          &buffers_arg, &ancbufsize, &flags))\n        return NULL;\n\n    if ((fast = PySequence_Fast(buffers_arg,\n                                \"recvmsg_into() argument 1 must be an \"\n                                \"iterable\")) == NULL)\n        return NULL;\n    nitems = PySequence_Fast_GET_SIZE(fast);\n    if (nitems > INT_MAX) {\n        PyErr_SetString(PyExc_OSError, \"recvmsg_into() argument 1 is too long\");\n        goto finally;\n    }\n\n    /* Fill in an iovec for each item, and save the Py_buffer\n       structs to release afterwards. */\n    if (nitems > 0 && ((iovs = PyMem_New(struct iovec, nitems)) == NULL ||\n                       (bufs = PyMem_New(Py_buffer, nitems)) == NULL)) {\n        PyErr_NoMemory();\n        goto finally;\n    }\n    for (; nbufs < nitems; nbufs++) {\n        if (!PyArg_Parse(PySequence_Fast_GET_ITEM(fast, nbufs),\n                         \"w*;recvmsg_into() argument 1 must be an iterable \"\n                         \"of single-segment read-write buffers\",\n                         &bufs[nbufs]))\n            goto finally;\n        iovs[nbufs].iov_base = bufs[nbufs].buf;\n        iovs[nbufs].iov_len = bufs[nbufs].len;\n    }\n\n    retval = sock_recvmsg_guts(s, iovs, nitems, flags, ancbufsize,\n                               &makeval_recvmsg_into, NULL);\nfinally:\n    for (i = 0; i < nbufs; i++)\n        PyBuffer_Release(&bufs[i]);\n    PyMem_Free(bufs);\n    PyMem_Free(iovs);\n    Py_DECREF(fast);\n    return retval;\n}\n\nPyDoc_STRVAR(recvmsg_into_doc,\n\"recvmsg_into(buffers[, ancbufsize[, flags]]) -> (nbytes, ancdata, msg_flags, address)\\n\\\n\\n\\\nReceive normal data and ancillary data from the socket, scattering the\\n\\\nnon-ancillary data into a series of buffers.  The buffers argument\\n\\\nmust be an iterable of objects that export writable buffers\\n\\\n(e.g. bytearray objects); these will be filled with successive chunks\\n\\\nof the non-ancillary data until it has all been written or there are\\n\\\nno more buffers.  The ancbufsize argument sets the size in bytes of\\n\\\nthe internal buffer used to receive the ancillary data; it defaults to\\n\\\n0, meaning that no ancillary data will be received.  Appropriate\\n\\\nbuffer sizes for ancillary data can be calculated using CMSG_SPACE()\\n\\\nor CMSG_LEN(), and items which do not fit into the buffer might be\\n\\\ntruncated or discarded.  The flags argument defaults to 0 and has the\\n\\\nsame meaning as for recv().\\n\\\n\\n\\\nThe return value is a 4-tuple: (nbytes, ancdata, msg_flags, address).\\n\\\nThe nbytes item is the total number of bytes of non-ancillary data\\n\\\nwritten into the buffers.  The ancdata item is a list of zero or more\\n\\\ntuples (cmsg_level, cmsg_type, cmsg_data) representing the ancillary\\n\\\ndata (control messages) received: cmsg_level and cmsg_type are\\n\\\nintegers specifying the protocol level and protocol-specific type\\n\\\nrespectively, and cmsg_data is a bytes object holding the associated\\n\\\ndata.  The msg_flags item is the bitwise OR of various flags\\n\\\nindicating conditions on the received message; see your system\\n\\\ndocumentation for details.  If the receiving socket is unconnected,\\n\\\naddress is the address of the sending socket, if available; otherwise,\\n\\\nits value is unspecified.\\n\\\n\\n\\\nIf recvmsg_into() raises an exception after the system call returns,\\n\\\nit will first attempt to close any file descriptors received via the\\n\\\nSCM_RIGHTS mechanism.\");\n#endif    /* CMSG_LEN */\n\n\nstruct sock_send {\n    char *buf;\n    Py_ssize_t len;\n    int flags;\n    Py_ssize_t result;\n};\n\nstatic int\nsock_send_impl(PySocketSockObject *s, void *data)\n{\n    struct sock_send *ctx = data;\n\n#ifdef MS_WINDOWS\n    if (ctx->len > INT_MAX)\n        ctx->len = INT_MAX;\n    ctx->result = send(s->sock_fd, ctx->buf, (int)ctx->len, ctx->flags);\n#else\n    ctx->result = send(s->sock_fd, ctx->buf, ctx->len, ctx->flags);\n#endif\n    return (ctx->result >= 0);\n}\n\n/* s.send(data [,flags]) method */\n\nstatic PyObject *\nsock_send(PySocketSockObject *s, PyObject *args)\n{\n    int flags = 0;\n    Py_buffer pbuf;\n    struct sock_send ctx;\n\n    if (!PyArg_ParseTuple(args, \"y*|i:send\", &pbuf, &flags))\n        return NULL;\n\n    if (!IS_SELECTABLE(s)) {\n        PyBuffer_Release(&pbuf);\n        return select_error();\n    }\n    ctx.buf = pbuf.buf;\n    ctx.len = pbuf.len;\n    ctx.flags = flags;\n    if (sock_call(s, 1, sock_send_impl, &ctx) < 0) {\n        PyBuffer_Release(&pbuf);\n        return NULL;\n    }\n    PyBuffer_Release(&pbuf);\n\n    return PyLong_FromSsize_t(ctx.result);\n}\n\nPyDoc_STRVAR(send_doc,\n\"send(data[, flags]) -> count\\n\\\n\\n\\\nSend a data string to the socket.  For the optional flags\\n\\\nargument, see the Unix manual.  Return the number of bytes\\n\\\nsent; this may be less than len(data) if the network is busy.\");\n\n\n/* s.sendall(data [,flags]) method */\n\nstatic PyObject *\nsock_sendall(PySocketSockObject *s, PyObject *args)\n{\n    char *buf;\n    Py_ssize_t len, n;\n    int flags = 0;\n    Py_buffer pbuf;\n    struct sock_send ctx;\n    int has_timeout = (s->sock_timeout > 0);\n    PyTime_t timeout = s->sock_timeout;\n    PyTime_t deadline = 0;\n    int deadline_initialized = 0;\n    PyObject *res = NULL;\n\n    if (!PyArg_ParseTuple(args, \"y*|i:sendall\", &pbuf, &flags))\n        return NULL;\n    buf = pbuf.buf;\n    len = pbuf.len;\n\n    if (!IS_SELECTABLE(s)) {\n        PyBuffer_Release(&pbuf);\n        return select_error();\n    }\n\n    do {\n        if (has_timeout) {\n            if (deadline_initialized) {\n                /* recompute the timeout */\n                timeout = _PyDeadline_Get(deadline);\n            }\n            else {\n                deadline_initialized = 1;\n                deadline = _PyDeadline_Init(timeout);\n            }\n\n            if (timeout <= 0) {\n                PyErr_SetString(PyExc_TimeoutError, \"timed out\");\n                goto done;\n            }\n        }\n\n        ctx.buf = buf;\n        ctx.len = len;\n        ctx.flags = flags;\n        if (sock_call_ex(s, 1, sock_send_impl, &ctx, 0, NULL, timeout) < 0)\n            goto done;\n        n = ctx.result;\n        assert(n >= 0);\n\n        buf += n;\n        len -= n;\n\n        /* We must run our signal handlers before looping again.\n           send() can return a successful partial write when it is\n           interrupted, so we can't restrict ourselves to EINTR. */\n        if (PyErr_CheckSignals())\n            goto done;\n    } while (len > 0);\n    PyBuffer_Release(&pbuf);\n\n    res = Py_NewRef(Py_None);\n\ndone:\n    PyBuffer_Release(&pbuf);\n    return res;\n}\n\nPyDoc_STRVAR(sendall_doc,\n\"sendall(data[, flags])\\n\\\n\\n\\\nSend a data string to the socket.  For the optional flags\\n\\\nargument, see the Unix manual.  This calls send() repeatedly\\n\\\nuntil all data is sent.  If an error occurs, it's impossible\\n\\\nto tell how much data has been sent.\");\n\n\n#ifdef HAVE_SENDTO\nstruct sock_sendto {\n    char *buf;\n    Py_ssize_t len;\n    int flags;\n    int addrlen;\n    sock_addr_t *addrbuf;\n    Py_ssize_t result;\n};\n\nstatic int\nsock_sendto_impl(PySocketSockObject *s, void *data)\n{\n    struct sock_sendto *ctx = data;\n\n#ifdef MS_WINDOWS\n    if (ctx->len > INT_MAX)\n        ctx->len = INT_MAX;\n    ctx->result = sendto(s->sock_fd, ctx->buf, (int)ctx->len, ctx->flags,\n                         SAS2SA(ctx->addrbuf), ctx->addrlen);\n#else\n    ctx->result = sendto(s->sock_fd, ctx->buf, ctx->len, ctx->flags,\n                         SAS2SA(ctx->addrbuf), ctx->addrlen);\n#endif\n    return (ctx->result >= 0);\n}\n\n/* s.sendto(data, [flags,] sockaddr) method */\n\nstatic PyObject *\nsock_sendto(PySocketSockObject *s, PyObject *args)\n{\n    Py_buffer pbuf;\n    PyObject *addro;\n    Py_ssize_t arglen;\n    sock_addr_t addrbuf;\n    int addrlen, flags;\n    struct sock_sendto ctx;\n\n    flags = 0;\n    arglen = PyTuple_Size(args);\n    switch (arglen) {\n        case 2:\n            if (!PyArg_ParseTuple(args, \"y*O:sendto\", &pbuf, &addro)) {\n                return NULL;\n            }\n            break;\n        case 3:\n            if (!PyArg_ParseTuple(args, \"y*iO:sendto\",\n                                  &pbuf, &flags, &addro)) {\n                return NULL;\n            }\n            break;\n        default:\n            PyErr_Format(PyExc_TypeError,\n                         \"sendto() takes 2 or 3 arguments (%zd given)\",\n                         arglen);\n            return NULL;\n    }\n\n    if (!IS_SELECTABLE(s)) {\n        PyBuffer_Release(&pbuf);\n        return select_error();\n    }\n\n    if (!getsockaddrarg(s, addro, &addrbuf, &addrlen, \"sendto\")) {\n        PyBuffer_Release(&pbuf);\n        return NULL;\n    }\n\n    if (PySys_Audit(\"socket.sendto\", \"OO\", s, addro) < 0) {\n        return NULL;\n    }\n\n    ctx.buf = pbuf.buf;\n    ctx.len = pbuf.len;\n    ctx.flags = flags;\n    ctx.addrlen = addrlen;\n    ctx.addrbuf = &addrbuf;\n    if (sock_call(s, 1, sock_sendto_impl, &ctx) < 0) {\n        PyBuffer_Release(&pbuf);\n        return NULL;\n    }\n    PyBuffer_Release(&pbuf);\n\n    return PyLong_FromSsize_t(ctx.result);\n}\n\nPyDoc_STRVAR(sendto_doc,\n\"sendto(data[, flags], address) -> count\\n\\\n\\n\\\nLike send(data, flags) but allows specifying the destination address.\\n\\\nFor IP sockets, the address is a pair (hostaddr, port).\");\n#endif\n\n\n/* The sendmsg() and recvmsg[_into]() methods require a working\n   CMSG_LEN().  See the comment near get_CMSG_LEN(). */\n#ifdef CMSG_LEN\nstruct sock_sendmsg {\n    struct msghdr *msg;\n    int flags;\n    ssize_t result;\n};\n\nstatic int\nsock_sendmsg_iovec(PySocketSockObject *s, PyObject *data_arg,\n                   struct msghdr *msg,\n                   Py_buffer **databufsout, Py_ssize_t *ndatabufsout) {\n    Py_ssize_t ndataparts, ndatabufs = 0;\n    int result = -1;\n    struct iovec *iovs = NULL;\n    PyObject *data_fast = NULL;\n    Py_buffer *databufs = NULL;\n\n    /* Fill in an iovec for each message part, and save the Py_buffer\n       structs to release afterwards. */\n    data_fast = PySequence_Fast(data_arg,\n                                \"sendmsg() argument 1 must be an \"\n                                \"iterable\");\n    if (data_fast == NULL) {\n        goto finally;\n    }\n\n    ndataparts = PySequence_Fast_GET_SIZE(data_fast);\n    if (ndataparts > INT_MAX) {\n        PyErr_SetString(PyExc_OSError, \"sendmsg() argument 1 is too long\");\n        goto finally;\n    }\n\n    msg->msg_iovlen = ndataparts;\n    if (ndataparts > 0) {\n        iovs = PyMem_New(struct iovec, ndataparts);\n        if (iovs == NULL) {\n            PyErr_NoMemory();\n            goto finally;\n        }\n        msg->msg_iov = iovs;\n\n        databufs = PyMem_New(Py_buffer, ndataparts);\n        if (databufs == NULL) {\n            PyErr_NoMemory();\n            goto finally;\n        }\n    }\n    for (; ndatabufs < ndataparts; ndatabufs++) {\n        if (!PyArg_Parse(PySequence_Fast_GET_ITEM(data_fast, ndatabufs),\n                         \"y*;sendmsg() argument 1 must be an iterable of \"\n                         \"bytes-like objects\",\n                         &databufs[ndatabufs]))\n            goto finally;\n        iovs[ndatabufs].iov_base = databufs[ndatabufs].buf;\n        iovs[ndatabufs].iov_len = databufs[ndatabufs].len;\n    }\n    result = 0;\n  finally:\n    *databufsout = databufs;\n    *ndatabufsout = ndatabufs;\n    Py_XDECREF(data_fast);\n    return result;\n}\n\nstatic int\nsock_sendmsg_impl(PySocketSockObject *s, void *data)\n{\n    struct sock_sendmsg *ctx = data;\n\n    ctx->result = sendmsg(s->sock_fd, ctx->msg, ctx->flags);\n    return (ctx->result >= 0);\n}\n\n/* s.sendmsg(buffers[, ancdata[, flags[, address]]]) method */\n\nstatic PyObject *\nsock_sendmsg(PySocketSockObject *s, PyObject *args)\n{\n    Py_ssize_t i, ndatabufs = 0, ncmsgs, ncmsgbufs = 0;\n    Py_buffer *databufs = NULL;\n    sock_addr_t addrbuf;\n    struct msghdr msg;\n    struct cmsginfo {\n        int level;\n        int type;\n        Py_buffer data;\n    } *cmsgs = NULL;\n    void *controlbuf = NULL;\n    size_t controllen, controllen_last;\n    int addrlen, flags = 0;\n    PyObject *data_arg, *cmsg_arg = NULL, *addr_arg = NULL,\n        *cmsg_fast = NULL, *retval = NULL;\n    struct sock_sendmsg ctx;\n\n    if (!PyArg_ParseTuple(args, \"O|OiO:sendmsg\",\n                          &data_arg, &cmsg_arg, &flags, &addr_arg)) {\n        return NULL;\n    }\n\n    memset(&msg, 0, sizeof(msg));\n\n    /* Parse destination address. */\n    if (addr_arg != NULL && addr_arg != Py_None) {\n        if (!getsockaddrarg(s, addr_arg, &addrbuf, &addrlen,\n                            \"sendmsg\"))\n        {\n            goto finally;\n        }\n        if (PySys_Audit(\"socket.sendmsg\", \"OO\", s, addr_arg) < 0) {\n            return NULL;\n        }\n        msg.msg_name = &addrbuf;\n        msg.msg_namelen = addrlen;\n    } else {\n        if (PySys_Audit(\"socket.sendmsg\", \"OO\", s, Py_None) < 0) {\n            return NULL;\n        }\n    }\n\n    /* Fill in an iovec for each message part, and save the Py_buffer\n       structs to release afterwards. */\n    if (sock_sendmsg_iovec(s, data_arg, &msg, &databufs, &ndatabufs) == -1) {\n        goto finally;\n    }\n\n    if (cmsg_arg == NULL)\n        ncmsgs = 0;\n    else {\n        if ((cmsg_fast = PySequence_Fast(cmsg_arg,\n                                         \"sendmsg() argument 2 must be an \"\n                                         \"iterable\")) == NULL)\n            goto finally;\n        ncmsgs = PySequence_Fast_GET_SIZE(cmsg_fast);\n    }\n\n#ifndef CMSG_SPACE\n    if (ncmsgs > 1) {\n        PyErr_SetString(PyExc_OSError,\n                        \"sending multiple control messages is not supported \"\n                        \"on this system\");\n        goto finally;\n    }\n#endif\n    /* Save level, type and Py_buffer for each control message,\n       and calculate total size. */\n    if (ncmsgs > 0 && (cmsgs = PyMem_New(struct cmsginfo, ncmsgs)) == NULL) {\n        PyErr_NoMemory();\n        goto finally;\n    }\n    controllen = controllen_last = 0;\n    while (ncmsgbufs < ncmsgs) {\n        size_t bufsize, space;\n\n        if (!PyArg_Parse(PySequence_Fast_GET_ITEM(cmsg_fast, ncmsgbufs),\n                         \"(iiy*):[sendmsg() ancillary data items]\",\n                         &cmsgs[ncmsgbufs].level,\n                         &cmsgs[ncmsgbufs].type,\n                         &cmsgs[ncmsgbufs].data))\n            goto finally;\n        bufsize = cmsgs[ncmsgbufs++].data.len;\n\n#ifdef CMSG_SPACE\n        if (!get_CMSG_SPACE(bufsize, &space)) {\n#else\n        if (!get_CMSG_LEN(bufsize, &space)) {\n#endif\n            PyErr_SetString(PyExc_OSError, \"ancillary data item too large\");\n            goto finally;\n        }\n        controllen += space;\n        if (controllen > SOCKLEN_T_LIMIT || controllen < controllen_last) {\n            PyErr_SetString(PyExc_OSError, \"too much ancillary data\");\n            goto finally;\n        }\n        controllen_last = controllen;\n    }\n\n    /* Construct ancillary data block from control message info. */\n    if (ncmsgbufs > 0) {\n        struct cmsghdr *cmsgh = NULL;\n\n        controlbuf = PyMem_Malloc(controllen);\n        if (controlbuf == NULL) {\n            PyErr_NoMemory();\n            goto finally;\n        }\n        msg.msg_control = controlbuf;\n\n        msg.msg_controllen = controllen;\n\n        /* Need to zero out the buffer as a workaround for glibc's\n           CMSG_NXTHDR() implementation.  After getting the pointer to\n           the next header, it checks its (uninitialized) cmsg_len\n           member to see if the \"message\" fits in the buffer, and\n           returns NULL if it doesn't.  Zero-filling the buffer\n           ensures that this doesn't happen. */\n        memset(controlbuf, 0, controllen);\n\n        for (i = 0; i < ncmsgbufs; i++) {\n            size_t msg_len, data_len = cmsgs[i].data.len;\n            int enough_space = 0;\n\n            cmsgh = (i == 0) ? CMSG_FIRSTHDR(&msg) : CMSG_NXTHDR(&msg, cmsgh);\n            if (cmsgh == NULL) {\n                PyErr_Format(PyExc_RuntimeError,\n                             \"unexpected NULL result from %s()\",\n                             (i == 0) ? \"CMSG_FIRSTHDR\" : \"CMSG_NXTHDR\");\n                goto finally;\n            }\n            if (!get_CMSG_LEN(data_len, &msg_len)) {\n                PyErr_SetString(PyExc_RuntimeError,\n                                \"item size out of range for CMSG_LEN()\");\n                goto finally;\n            }\n            if (cmsg_min_space(&msg, cmsgh, msg_len)) {\n                size_t space;\n\n                cmsgh->cmsg_len = msg_len;\n                if (get_cmsg_data_space(&msg, cmsgh, &space))\n                    enough_space = (space >= data_len);\n            }\n            if (!enough_space) {\n                PyErr_SetString(PyExc_RuntimeError,\n                                \"ancillary data does not fit in calculated \"\n                                \"space\");\n                goto finally;\n            }\n            cmsgh->cmsg_level = cmsgs[i].level;\n            cmsgh->cmsg_type = cmsgs[i].type;\n            memcpy(CMSG_DATA(cmsgh), cmsgs[i].data.buf, data_len);\n        }\n    }\n\n    /* Make the system call. */\n    if (!IS_SELECTABLE(s)) {\n        select_error();\n        goto finally;\n    }\n\n    ctx.msg = &msg;\n    ctx.flags = flags;\n    if (sock_call(s, 1, sock_sendmsg_impl, &ctx) < 0)\n        goto finally;\n\n    retval = PyLong_FromSsize_t(ctx.result);\n\nfinally:\n    PyMem_Free(controlbuf);\n    for (i = 0; i < ncmsgbufs; i++)\n        PyBuffer_Release(&cmsgs[i].data);\n    PyMem_Free(cmsgs);\n    Py_XDECREF(cmsg_fast);\n    PyMem_Free(msg.msg_iov);\n    for (i = 0; i < ndatabufs; i++) {\n        PyBuffer_Release(&databufs[i]);\n    }\n    PyMem_Free(databufs);\n    return retval;\n}\n\nPyDoc_STRVAR(sendmsg_doc,\n\"sendmsg(buffers[, ancdata[, flags[, address]]]) -> count\\n\\\n\\n\\\nSend normal and ancillary data to the socket, gathering the\\n\\\nnon-ancillary data from a series of buffers and concatenating it into\\n\\\na single message.  The buffers argument specifies the non-ancillary\\n\\\ndata as an iterable of bytes-like objects (e.g. bytes objects).\\n\\\nThe ancdata argument specifies the ancillary data (control messages)\\n\\\nas an iterable of zero or more tuples (cmsg_level, cmsg_type,\\n\\\ncmsg_data), where cmsg_level and cmsg_type are integers specifying the\\n\\\nprotocol level and protocol-specific type respectively, and cmsg_data\\n\\\nis a bytes-like object holding the associated data.  The flags\\n\\\nargument defaults to 0 and has the same meaning as for send().  If\\n\\\naddress is supplied and not None, it sets a destination address for\\n\\\nthe message.  The return value is the number of bytes of non-ancillary\\n\\\ndata sent.\");\n#endif    /* CMSG_LEN */\n\n#ifdef HAVE_SOCKADDR_ALG\nstatic PyObject*\nsock_sendmsg_afalg(PySocketSockObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *retval = NULL;\n\n    Py_ssize_t i, ndatabufs = 0;\n    Py_buffer *databufs = NULL;\n    PyObject *data_arg = NULL;\n\n    Py_buffer iv = {NULL, NULL};\n\n    PyObject *opobj = NULL;\n    int op = -1;\n\n    PyObject *assoclenobj = NULL;\n    int assoclen = -1;\n\n    unsigned int *uiptr;\n    int flags = 0;\n\n    struct msghdr msg;\n    struct cmsghdr *header = NULL;\n    struct af_alg_iv *alg_iv = NULL;\n    struct sock_sendmsg ctx;\n    Py_ssize_t controllen;\n    void *controlbuf = NULL;\n    static char *keywords[] = {\"msg\", \"op\", \"iv\", \"assoclen\", \"flags\", 0};\n\n    if (self->sock_family != AF_ALG) {\n        PyErr_SetString(PyExc_OSError,\n                        \"algset is only supported for AF_ALG\");\n        return NULL;\n    }\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds,\n                                     \"|O$O!y*O!i:sendmsg_afalg\", keywords,\n                                     &data_arg,\n                                     &PyLong_Type, &opobj, &iv,\n                                     &PyLong_Type, &assoclenobj, &flags)) {\n        return NULL;\n    }\n\n    memset(&msg, 0, sizeof(msg));\n\n    /* op is a required, keyword-only argument >= 0 */\n    if (opobj != NULL) {\n        op = PyLong_AsInt(opobj);\n    }\n    if (op < 0) {\n        /* override exception from PyLong_AsInt() */\n        PyErr_SetString(PyExc_TypeError,\n                        \"Invalid or missing argument 'op'\");\n        goto finally;\n    }\n    /* assoclen is optional but must be >= 0 */\n    if (assoclenobj != NULL) {\n        assoclen = PyLong_AsInt(assoclenobj);\n        if (assoclen == -1 && PyErr_Occurred()) {\n            goto finally;\n        }\n        if (assoclen < 0) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"assoclen must be positive\");\n            goto finally;\n        }\n    }\n\n    controllen = CMSG_SPACE(4);\n    if (iv.buf != NULL) {\n        controllen += CMSG_SPACE(sizeof(*alg_iv) + iv.len);\n    }\n    if (assoclen >= 0) {\n        controllen += CMSG_SPACE(4);\n    }\n\n    controlbuf = PyMem_Malloc(controllen);\n    if (controlbuf == NULL) {\n        PyErr_NoMemory();\n        goto finally;\n    }\n    memset(controlbuf, 0, controllen);\n\n    msg.msg_controllen = controllen;\n    msg.msg_control = controlbuf;\n\n    /* Fill in an iovec for each message part, and save the Py_buffer\n       structs to release afterwards. */\n    if (data_arg != NULL) {\n        if (sock_sendmsg_iovec(self, data_arg, &msg, &databufs, &ndatabufs) == -1) {\n            goto finally;\n        }\n    }\n\n    /* set operation to encrypt or decrypt */\n    header = CMSG_FIRSTHDR(&msg);\n    if (header == NULL) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"unexpected NULL result from CMSG_FIRSTHDR\");\n        goto finally;\n    }\n    header->cmsg_level = SOL_ALG;\n    header->cmsg_type = ALG_SET_OP;\n    header->cmsg_len = CMSG_LEN(4);\n    uiptr = (void*)CMSG_DATA(header);\n    *uiptr = (unsigned int)op;\n\n    /* set initialization vector */\n    if (iv.buf != NULL) {\n        header = CMSG_NXTHDR(&msg, header);\n        if (header == NULL) {\n            PyErr_SetString(PyExc_RuntimeError,\n                            \"unexpected NULL result from CMSG_NXTHDR(iv)\");\n            goto finally;\n        }\n        header->cmsg_level = SOL_ALG;\n        header->cmsg_type = ALG_SET_IV;\n        header->cmsg_len = CMSG_SPACE(sizeof(*alg_iv) + iv.len);\n        alg_iv = (void*)CMSG_DATA(header);\n        alg_iv->ivlen = iv.len;\n        memcpy(alg_iv->iv, iv.buf, iv.len);\n    }\n\n    /* set length of associated data for AEAD */\n    if (assoclen >= 0) {\n        header = CMSG_NXTHDR(&msg, header);\n        if (header == NULL) {\n            PyErr_SetString(PyExc_RuntimeError,\n                            \"unexpected NULL result from CMSG_NXTHDR(assoc)\");\n            goto finally;\n        }\n        header->cmsg_level = SOL_ALG;\n        header->cmsg_type = ALG_SET_AEAD_ASSOCLEN;\n        header->cmsg_len = CMSG_LEN(4);\n        uiptr = (void*)CMSG_DATA(header);\n        *uiptr = (unsigned int)assoclen;\n    }\n\n    ctx.msg = &msg;\n    ctx.flags = flags;\n    if (sock_call(self, 1, sock_sendmsg_impl, &ctx) < 0) {\n        goto finally;\n    }\n\n    retval = PyLong_FromSsize_t(ctx.result);\n\n  finally:\n    PyMem_Free(controlbuf);\n    if (iv.buf != NULL) {\n        PyBuffer_Release(&iv);\n    }\n    PyMem_Free(msg.msg_iov);\n    for (i = 0; i < ndatabufs; i++) {\n        PyBuffer_Release(&databufs[i]);\n    }\n    PyMem_Free(databufs);\n    return retval;\n}\n\nPyDoc_STRVAR(sendmsg_afalg_doc,\n\"sendmsg_afalg([msg], *, op[, iv[, assoclen[, flags=MSG_MORE]]])\\n\\\n\\n\\\nSet operation mode, IV and length of associated data for an AF_ALG\\n\\\noperation socket.\");\n#endif\n\n#ifdef HAVE_SHUTDOWN\n/* s.shutdown(how) method */\n\nstatic PyObject *\nsock_shutdown(PySocketSockObject *s, PyObject *arg)\n{\n    int how;\n    int res;\n\n    how = PyLong_AsInt(arg);\n    if (how == -1 && PyErr_Occurred())\n        return NULL;\n    Py_BEGIN_ALLOW_THREADS\n    res = shutdown(s->sock_fd, how);\n    Py_END_ALLOW_THREADS\n    if (res < 0)\n        return s->errorhandler();\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(shutdown_doc,\n\"shutdown(flag)\\n\\\n\\n\\\nShut down the reading side of the socket (flag == SHUT_RD), the writing side\\n\\\nof the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).\");\n#endif\n\n#if defined(MS_WINDOWS) && defined(SIO_RCVALL)\nstatic PyObject*\nsock_ioctl(PySocketSockObject *s, PyObject *arg)\n{\n    unsigned long cmd = SIO_RCVALL;\n    PyObject *argO;\n    DWORD recv;\n\n    if (!PyArg_ParseTuple(arg, \"kO:ioctl\", &cmd, &argO))\n        return NULL;\n\n    switch (cmd) {\n    case SIO_RCVALL: {\n        unsigned int option = RCVALL_ON;\n        if (!PyArg_ParseTuple(arg, \"kI:ioctl\", &cmd, &option))\n            return NULL;\n        if (WSAIoctl(s->sock_fd, cmd, &option, sizeof(option),\n                         NULL, 0, &recv, NULL, NULL) == SOCKET_ERROR) {\n            return set_error();\n        }\n        return PyLong_FromUnsignedLong(recv); }\n    case SIO_KEEPALIVE_VALS: {\n        struct tcp_keepalive ka;\n        if (!PyArg_ParseTuple(arg, \"k(kkk):ioctl\", &cmd,\n                        &ka.onoff, &ka.keepalivetime, &ka.keepaliveinterval))\n            return NULL;\n        if (WSAIoctl(s->sock_fd, cmd, &ka, sizeof(ka),\n                         NULL, 0, &recv, NULL, NULL) == SOCKET_ERROR) {\n            return set_error();\n        }\n        return PyLong_FromUnsignedLong(recv); }\n#if defined(SIO_LOOPBACK_FAST_PATH)\n    case SIO_LOOPBACK_FAST_PATH: {\n        unsigned int option;\n        if (!PyArg_ParseTuple(arg, \"kI:ioctl\", &cmd, &option))\n            return NULL;\n        if (WSAIoctl(s->sock_fd, cmd, &option, sizeof(option),\n                         NULL, 0, &recv, NULL, NULL) == SOCKET_ERROR) {\n            return set_error();\n        }\n        return PyLong_FromUnsignedLong(recv); }\n#endif\n    default:\n        PyErr_Format(PyExc_ValueError, \"invalid ioctl command %lu\", cmd);\n        return NULL;\n    }\n}\nPyDoc_STRVAR(sock_ioctl_doc,\n\"ioctl(cmd, option) -> long\\n\\\n\\n\\\nControl the socket with WSAIoctl syscall. Currently supported 'cmd' values are\\n\\\nSIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.\\n\\\nSIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).\\n\\\nSIO_LOOPBACK_FAST_PATH: 'option' is a boolean value, and is disabled by default\");\n#endif\n\n#if defined(MS_WINDOWS)\nstatic PyObject*\nsock_share(PySocketSockObject *s, PyObject *arg)\n{\n    WSAPROTOCOL_INFOW info;\n    DWORD processId;\n    int result;\n\n    if (!PyArg_ParseTuple(arg, \"I\", &processId))\n        return NULL;\n\n    Py_BEGIN_ALLOW_THREADS\n    result = WSADuplicateSocketW(s->sock_fd, processId, &info);\n    Py_END_ALLOW_THREADS\n    if (result == SOCKET_ERROR)\n        return set_error();\n    return PyBytes_FromStringAndSize((const char*)&info, sizeof(info));\n}\nPyDoc_STRVAR(sock_share_doc,\n\"share(process_id) -> bytes\\n\\\n\\n\\\nShare the socket with another process.  The target process id\\n\\\nmust be provided and the resulting bytes object passed to the target\\n\\\nprocess.  There the shared socket can be instantiated by calling\\n\\\nsocket.fromshare().\");\n\n\n#endif\n\n/* List of methods for socket objects */\n\nstatic PyMethodDef sock_methods[] = {\n#if defined(HAVE_ACCEPT) || defined(HAVE_ACCEPT4)\n    {\"_accept\",           (PyCFunction)sock_accept, METH_NOARGS,\n                      accept_doc},\n#endif\n#ifdef HAVE_BIND\n    {\"bind\",              (PyCFunction)sock_bind, METH_O,\n                      bind_doc},\n#endif\n    {\"close\",             (PyCFunction)sock_close, METH_NOARGS,\n                      sock_close_doc},\n#ifdef HAVE_CONNECT\n    {\"connect\",           (PyCFunction)sock_connect, METH_O,\n                      connect_doc},\n    {\"connect_ex\",        (PyCFunction)sock_connect_ex, METH_O,\n                      connect_ex_doc},\n#endif\n    {\"detach\",            (PyCFunction)sock_detach, METH_NOARGS,\n                      detach_doc},\n    {\"fileno\",            (PyCFunction)sock_fileno, METH_NOARGS,\n                      fileno_doc},\n#ifdef HAVE_GETPEERNAME\n    {\"getpeername\",       (PyCFunction)sock_getpeername,\n                      METH_NOARGS, getpeername_doc},\n#endif\n#ifdef HAVE_GETSOCKNAME\n    {\"getsockname\",       (PyCFunction)sock_getsockname,\n                      METH_NOARGS, getsockname_doc},\n#endif\n    {\"getsockopt\",        (PyCFunction)sock_getsockopt, METH_VARARGS,\n                      getsockopt_doc},\n#if defined(MS_WINDOWS) && defined(SIO_RCVALL)\n    {\"ioctl\",             (PyCFunction)sock_ioctl, METH_VARARGS,\n                      sock_ioctl_doc},\n#endif\n#if defined(MS_WINDOWS)\n    {\"share\",         (PyCFunction)sock_share, METH_VARARGS,\n                      sock_share_doc},\n#endif\n#ifdef HAVE_LISTEN\n    {\"listen\",            (PyCFunction)sock_listen, METH_VARARGS,\n                      listen_doc},\n#endif\n    {\"recv\",              (PyCFunction)sock_recv, METH_VARARGS,\n                      recv_doc},\n    {\"recv_into\",         _PyCFunction_CAST(sock_recv_into), METH_VARARGS | METH_KEYWORDS,\n                      recv_into_doc},\n#ifdef HAVE_RECVFROM\n    {\"recvfrom\",          (PyCFunction)sock_recvfrom, METH_VARARGS,\n                      recvfrom_doc},\n    {\"recvfrom_into\",  _PyCFunction_CAST(sock_recvfrom_into), METH_VARARGS | METH_KEYWORDS,\n                      recvfrom_into_doc},\n#endif\n    {\"send\",              (PyCFunction)sock_send, METH_VARARGS,\n                      send_doc},\n    {\"sendall\",           (PyCFunction)sock_sendall, METH_VARARGS,\n                      sendall_doc},\n#ifdef HAVE_SENDTO\n    {\"sendto\",            (PyCFunction)sock_sendto, METH_VARARGS,\n                      sendto_doc},\n#endif\n    {\"setblocking\",       (PyCFunction)sock_setblocking, METH_O,\n                      setblocking_doc},\n    {\"getblocking\",   (PyCFunction)sock_getblocking, METH_NOARGS,\n                      getblocking_doc},\n    {\"settimeout\",    (PyCFunction)sock_settimeout, METH_O,\n                      settimeout_doc},\n    {\"gettimeout\",    (PyCFunction)sock_gettimeout, METH_NOARGS,\n                      gettimeout_doc},\n#ifdef HAVE_SETSOCKOPT\n    {\"setsockopt\",        (PyCFunction)sock_setsockopt, METH_VARARGS,\n                      setsockopt_doc},\n#endif\n#ifdef HAVE_SHUTDOWN\n    {\"shutdown\",          (PyCFunction)sock_shutdown, METH_O,\n                      shutdown_doc},\n#endif\n#ifdef CMSG_LEN\n    {\"recvmsg\",           (PyCFunction)sock_recvmsg, METH_VARARGS,\n                      recvmsg_doc},\n    {\"recvmsg_into\",      (PyCFunction)sock_recvmsg_into, METH_VARARGS,\n                      recvmsg_into_doc,},\n    {\"sendmsg\",           (PyCFunction)sock_sendmsg, METH_VARARGS,\n                      sendmsg_doc},\n#endif\n#ifdef HAVE_SOCKADDR_ALG\n    {\"sendmsg_afalg\",     _PyCFunction_CAST(sock_sendmsg_afalg), METH_VARARGS | METH_KEYWORDS,\n                      sendmsg_afalg_doc},\n#endif\n    {NULL,                      NULL}           /* sentinel */\n};\n\n/* SockObject members */\nstatic PyMemberDef sock_memberlist[] = {\n       {\"family\", Py_T_INT, offsetof(PySocketSockObject, sock_family), Py_READONLY, \"the socket family\"},\n       {\"type\", Py_T_INT, offsetof(PySocketSockObject, sock_type), Py_READONLY, \"the socket type\"},\n       {\"proto\", Py_T_INT, offsetof(PySocketSockObject, sock_proto), Py_READONLY, \"the socket protocol\"},\n       {0},\n};\n\nstatic PyGetSetDef sock_getsetlist[] = {\n    {\"timeout\", (getter)sock_gettimeout, NULL, PyDoc_STR(\"the socket timeout\")},\n    {NULL} /* sentinel */\n};\n\n/* Deallocate a socket object in response to the last Py_DECREF().\n   First close the file description. */\n\nstatic void\nsock_finalize(PySocketSockObject *s)\n{\n    SOCKET_T fd;\n\n    /* Save the current exception, if any. */\n    PyObject *exc = PyErr_GetRaisedException();\n\n    if (s->sock_fd != INVALID_SOCKET) {\n        if (PyErr_ResourceWarning((PyObject *)s, 1, \"unclosed %R\", s)) {\n            /* Spurious errors can appear at shutdown */\n            if (PyErr_ExceptionMatches(PyExc_Warning)) {\n                PyErr_WriteUnraisable((PyObject *)s);\n            }\n        }\n\n        /* Only close the socket *after* logging the ResourceWarning warning\n           to allow the logger to call socket methods like\n           socket.getsockname(). If the socket is closed before, socket\n           methods fails with the EBADF error. */\n        fd = s->sock_fd;\n        s->sock_fd = INVALID_SOCKET;\n\n        /* We do not want to retry upon EINTR: see sock_close() */\n        Py_BEGIN_ALLOW_THREADS\n        (void) SOCKETCLOSE(fd);\n        Py_END_ALLOW_THREADS\n    }\n\n    /* Restore the saved exception. */\n    PyErr_SetRaisedException(exc);\n}\n\nstatic int\nsock_traverse(PySocketSockObject *s, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(s));\n    return 0;\n}\n\nstatic void\nsock_dealloc(PySocketSockObject *s)\n{\n    if (PyObject_CallFinalizerFromDealloc((PyObject *)s) < 0) {\n        return;\n    }\n    PyTypeObject *tp = Py_TYPE(s);\n    PyObject_GC_UnTrack(s);\n    tp->tp_free((PyObject *)s);\n    Py_DECREF(tp);\n}\n\n\nstatic PyObject *\nsock_repr(PySocketSockObject *s)\n{\n    long sock_fd;\n    /* On Windows, this test is needed because SOCKET_T is unsigned */\n    if (s->sock_fd == INVALID_SOCKET) {\n        sock_fd = -1;\n    }\n#if SIZEOF_SOCKET_T > SIZEOF_LONG\n    else if (s->sock_fd > LONG_MAX) {\n        /* this can occur on Win64, and actually there is a special\n           ugly printf formatter for decimal pointer length integer\n           printing, only bother if necessary*/\n        PyErr_SetString(PyExc_OverflowError,\n                        \"no printf formatter to display \"\n                        \"the socket descriptor in decimal\");\n        return NULL;\n    }\n#endif\n    else\n        sock_fd = (long)s->sock_fd;\n    return PyUnicode_FromFormat(\n        \"<socket object, fd=%ld, family=%d, type=%d, proto=%d>\",\n        sock_fd, s->sock_family,\n        s->sock_type,\n        s->sock_proto);\n}\n\n\n/* Create a new, uninitialized socket object. */\n\nstatic PyObject *\nsock_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyObject *new;\n\n    new = type->tp_alloc(type, 0);\n    if (new != NULL) {\n        ((PySocketSockObject *)new)->sock_fd = INVALID_SOCKET;\n        ((PySocketSockObject *)new)->sock_timeout = _PyTime_FromSeconds(-1);\n        ((PySocketSockObject *)new)->errorhandler = &set_error;\n    }\n    return new;\n}\n\n\n/* Initialize a new socket object. */\n\n/*ARGSUSED*/\n\n#ifndef HAVE_SOCKET\n#define socket stub_socket\nstatic int\nsocket(int domain, int type, int protocol)\n{\n    errno = ENOTSUP;\n    return INVALID_SOCKET;\n}\n#endif\n\n/*[clinic input]\n_socket.socket.__init__ as sock_initobj\n    family: int = -1\n    type: int = -1\n    proto: int = -1\n    fileno as fdobj: object = NULL\n[clinic start generated code]*/\n\nstatic int\nsock_initobj_impl(PySocketSockObject *self, int family, int type, int proto,\n                  PyObject *fdobj)\n/*[clinic end generated code: output=d114d026b9a9a810 input=04cfc32953f5cc25]*/\n{\n\n    SOCKET_T fd = INVALID_SOCKET;\n    socket_state *state = find_module_state_by_def(Py_TYPE(self));\n\n#ifndef MS_WINDOWS\n#ifdef SOCK_CLOEXEC\n    int *atomic_flag_works = &state->sock_cloexec_works;\n#else\n    int *atomic_flag_works = NULL;\n#endif\n#endif\n\n#ifdef MS_WINDOWS\n    /* In this case, we don't use the family, type and proto args */\n    if (fdobj == NULL || fdobj == Py_None)\n#endif\n    {\n        if (PySys_Audit(\"socket.__new__\", \"Oiii\",\n                        self, family, type, proto) < 0) {\n            return -1;\n        }\n    }\n\n    if (fdobj != NULL && fdobj != Py_None) {\n#ifdef MS_WINDOWS\n        /* recreate a socket that was duplicated */\n        if (PyBytes_Check(fdobj)) {\n            WSAPROTOCOL_INFOW info;\n            if (PyBytes_GET_SIZE(fdobj) != sizeof(info)) {\n                PyErr_Format(PyExc_ValueError,\n                    \"socket descriptor string has wrong size, \"\n                    \"should be %zu bytes.\", sizeof(info));\n                return -1;\n            }\n            memcpy(&info, PyBytes_AS_STRING(fdobj), sizeof(info));\n\n            if (PySys_Audit(\"socket.__new__\", \"Oiii\", self,\n                            info.iAddressFamily, info.iSocketType,\n                            info.iProtocol) < 0) {\n                return -1;\n            }\n\n            Py_BEGIN_ALLOW_THREADS\n            fd = WSASocketW(FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO,\n                     FROM_PROTOCOL_INFO, &info, 0, WSA_FLAG_OVERLAPPED);\n            Py_END_ALLOW_THREADS\n            if (fd == INVALID_SOCKET) {\n                set_error();\n                return -1;\n            }\n\n            if (!SetHandleInformation((HANDLE)fd, HANDLE_FLAG_INHERIT, 0)) {\n                PyErr_SetFromWindowsErr(0);\n                closesocket(fd);\n                return -1;\n            }\n\n            family = info.iAddressFamily;\n            type = info.iSocketType;\n            proto = info.iProtocol;\n        }\n        else\n#endif\n        {\n            fd = PyLong_AsSocket_t(fdobj);\n            if (fd == (SOCKET_T)(-1) && PyErr_Occurred())\n                return -1;\n#ifdef MS_WINDOWS\n            if (fd == INVALID_SOCKET) {\n#else\n            if (fd < 0) {\n#endif\n                PyErr_SetString(PyExc_ValueError, \"negative file descriptor\");\n                return -1;\n            }\n\n            /* validate that passed file descriptor is valid and a socket. */\n            sock_addr_t addrbuf;\n            socklen_t addrlen = sizeof(sock_addr_t);\n\n            memset(&addrbuf, 0, addrlen);\n#ifdef HAVE_GETSOCKNAME\n            if (getsockname(fd, SAS2SA(&addrbuf), &addrlen) == 0) {\n                if (family == -1) {\n                    family = SAS2SA(&addrbuf)->sa_family;\n                }\n            } else {\n#ifdef MS_WINDOWS\n                /* getsockname() on an unbound socket is an error on Windows.\n                   Invalid descriptor and not a socket is same error code.\n                   Error out if family must be resolved, or bad descriptor. */\n                if (family == -1 || CHECK_ERRNO(ENOTSOCK)) {\n#else\n                /* getsockname() is not supported for SOL_ALG on Linux. */\n                if (family == -1 || CHECK_ERRNO(EBADF) || CHECK_ERRNO(ENOTSOCK)) {\n#endif\n                    set_error();\n                    return -1;\n                }\n            }\n#endif // HAVE_GETSOCKNAME\n#ifdef SO_TYPE\n            if (type == -1) {\n                int tmp;\n                socklen_t slen = sizeof(tmp);\n                if (getsockopt(fd, SOL_SOCKET, SO_TYPE,\n                               (void *)&tmp, &slen) == 0)\n                {\n                    type = tmp;\n                } else {\n                    set_error();\n                    return -1;\n                }\n            }\n#else\n            type = SOCK_STREAM;\n#endif\n#ifdef SO_PROTOCOL\n            if (proto == -1) {\n                int tmp;\n                socklen_t slen = sizeof(tmp);\n                if (getsockopt(fd, SOL_SOCKET, SO_PROTOCOL,\n                               (void *)&tmp, &slen) == 0)\n                {\n                    proto = tmp;\n                } else {\n                    set_error();\n                    return -1;\n                }\n            }\n#else\n            proto = 0;\n#endif\n        }\n    }\n    else {\n        /* No fd, default to AF_INET and SOCK_STREAM */\n        if (family == -1) {\n            family = AF_INET;\n        }\n        if (type == -1) {\n            type = SOCK_STREAM;\n        }\n        if (proto == -1) {\n            proto = 0;\n        }\n#ifdef MS_WINDOWS\n        Py_BEGIN_ALLOW_THREADS\n        fd = WSASocketW(family, type, proto,\n                        NULL, 0,\n                        WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n        Py_END_ALLOW_THREADS\n\n        if (fd == INVALID_SOCKET) {\n            set_error();\n            return -1;\n        }\n#else\n        /* UNIX */\n        Py_BEGIN_ALLOW_THREADS\n#ifdef SOCK_CLOEXEC\n        if (state->sock_cloexec_works != 0) {\n            fd = socket(family, type | SOCK_CLOEXEC, proto);\n            if (state->sock_cloexec_works == -1) {\n                if (fd >= 0) {\n                    state->sock_cloexec_works = 1;\n                }\n                else if (errno == EINVAL) {\n                    /* Linux older than 2.6.27 does not support SOCK_CLOEXEC */\n                    state->sock_cloexec_works = 0;\n                    fd = socket(family, type, proto);\n                }\n            }\n        }\n        else\n#endif\n        {\n            fd = socket(family, type, proto);\n        }\n        Py_END_ALLOW_THREADS\n\n        if (fd == INVALID_SOCKET) {\n            set_error();\n            return -1;\n        }\n\n        if (_Py_set_inheritable(fd, 0, atomic_flag_works) < 0) {\n            SOCKETCLOSE(fd);\n            return -1;\n        }\n#endif\n    }\n    if (init_sockobject(state, self, fd, family, type, proto) == -1) {\n        SOCKETCLOSE(fd);\n        return -1;\n    }\n\n    return 0;\n\n}\n\n\n/* Type object for socket objects. */\n\nstatic PyType_Slot sock_slots[] = {\n    {Py_tp_dealloc, sock_dealloc},\n    {Py_tp_traverse, sock_traverse},\n    {Py_tp_repr, sock_repr},\n    {Py_tp_doc, (void *)sock_doc},\n    {Py_tp_methods, sock_methods},\n    {Py_tp_members, sock_memberlist},\n    {Py_tp_getset, sock_getsetlist},\n    {Py_tp_init, sock_initobj},\n    {Py_tp_new, sock_new},\n    {Py_tp_finalize, sock_finalize},\n    {0, NULL},\n};\n\nstatic PyType_Spec sock_spec = {\n    .name = \"_socket.socket\",\n    .basicsize = sizeof(PySocketSockObject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC |\n              Py_TPFLAGS_IMMUTABLETYPE),\n    .slots = sock_slots,\n};\n\n\n#ifdef HAVE_GETHOSTNAME\n/* Python interface to gethostname(). */\n\n/*ARGSUSED*/\nstatic PyObject *\nsocket_gethostname(PyObject *self, PyObject *unused)\n{\n    if (PySys_Audit(\"socket.gethostname\", NULL) < 0) {\n        return NULL;\n    }\n\n#ifdef MS_WINDOWS\n    /* Don't use winsock's gethostname, as this returns the ANSI\n       version of the hostname, whereas we need a Unicode string.\n       Otherwise, gethostname apparently also returns the DNS name. */\n    wchar_t buf[MAX_COMPUTERNAME_LENGTH + 1];\n    DWORD size = Py_ARRAY_LENGTH(buf);\n    wchar_t *name;\n    PyObject *result;\n\n    if (GetComputerNameExW(ComputerNamePhysicalDnsHostname, buf, &size))\n        return PyUnicode_FromWideChar(buf, size);\n\n    if (GetLastError() != ERROR_MORE_DATA)\n        return PyErr_SetFromWindowsErr(0);\n\n    if (size == 0)\n        return PyUnicode_New(0, 0);\n\n    /* MSDN says ERROR_MORE_DATA may occur because DNS allows longer\n       names */\n    name = PyMem_New(wchar_t, size);\n    if (!name) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    if (!GetComputerNameExW(ComputerNamePhysicalDnsHostname,\n                           name,\n                           &size))\n    {\n        PyErr_SetFromWindowsErr(0);\n        PyMem_Free(name);\n        return NULL;\n    }\n\n    result = PyUnicode_FromWideChar(name, size);\n    PyMem_Free(name);\n    return result;\n#else\n    char buf[1024];\n    int res;\n    Py_BEGIN_ALLOW_THREADS\n    res = gethostname(buf, (int) sizeof buf - 1);\n    Py_END_ALLOW_THREADS\n    if (res < 0)\n        return set_error();\n    buf[sizeof buf - 1] = '\\0';\n    return PyUnicode_DecodeFSDefault(buf);\n#endif\n}\n\nPyDoc_STRVAR(gethostname_doc,\n\"gethostname() -> string\\n\\\n\\n\\\nReturn the current host name.\");\n#endif\n\n#ifdef HAVE_SETHOSTNAME\nPyDoc_STRVAR(sethostname_doc,\n\"sethostname(name)\\n\\n\\\nSets the hostname to name.\");\n\nstatic PyObject *\nsocket_sethostname(PyObject *self, PyObject *args)\n{\n    PyObject *hnobj;\n    Py_buffer buf;\n    int res, flag = 0;\n\n#if defined(_AIX) || (defined(__sun) && defined(__SVR4) && Py_SUNOS_VERSION <= 510)\n/* issue #18259, sethostname is not declared in any useful header file on AIX\n * the same is true for Solaris 10 */\nextern int sethostname(const char *, size_t);\n#endif\n\n    if (!PyArg_ParseTuple(args, \"S:sethostname\", &hnobj)) {\n        PyErr_Clear();\n        if (!PyArg_ParseTuple(args, \"O&:sethostname\",\n                PyUnicode_FSConverter, &hnobj))\n            return NULL;\n        flag = 1;\n    }\n\n    if (PySys_Audit(\"socket.sethostname\", \"(O)\", hnobj) < 0) {\n        return NULL;\n    }\n\n    res = PyObject_GetBuffer(hnobj, &buf, PyBUF_SIMPLE);\n    if (!res) {\n        res = sethostname(buf.buf, buf.len);\n        PyBuffer_Release(&buf);\n    }\n    if (flag)\n        Py_DECREF(hnobj);\n    if (res)\n        return set_error();\n    Py_RETURN_NONE;\n}\n#endif\n\n#ifdef HAVE_GETADDRINFO\n/* Python interface to gethostbyname(name). */\n\n/*ARGSUSED*/\nstatic PyObject *\nsocket_gethostbyname(PyObject *self, PyObject *args)\n{\n    char *name;\n    struct sockaddr_in addrbuf;\n    PyObject *ret = NULL;\n\n    if (!PyArg_ParseTuple(args, \"et:gethostbyname\", \"idna\", &name))\n        return NULL;\n    if (PySys_Audit(\"socket.gethostbyname\", \"O\", args) < 0) {\n        goto finally;\n    }\n    socket_state *state = get_module_state(self);\n    int rc = setipaddr(state, name, (struct sockaddr *)&addrbuf,\n                       sizeof(addrbuf), AF_INET);\n    if (rc < 0) {\n        goto finally;\n    }\n    ret = make_ipv4_addr(&addrbuf);\nfinally:\n    PyMem_Free(name);\n    return ret;\n}\n\nPyDoc_STRVAR(gethostbyname_doc,\n\"gethostbyname(host) -> address\\n\\\n\\n\\\nReturn the IP address (a string of the form '255.255.255.255') for a host.\");\n#endif\n\n\n#if defined(HAVE_GETHOSTBYNAME_R) || defined (HAVE_GETHOSTBYNAME) || defined (HAVE_GETHOSTBYADDR)\nstatic PyObject*\nsock_decode_hostname(const char *name)\n{\n#ifdef MS_WINDOWS\n    /* Issue #26227: gethostbyaddr() returns a string encoded\n     * to the ANSI code page */\n    return PyUnicode_DecodeMBCS(name, strlen(name), \"surrogatepass\");\n#else\n    /* Decode from UTF-8 */\n    return PyUnicode_FromString(name);\n#endif\n}\n\n/* Convenience function common to gethostbyname_ex and gethostbyaddr */\n\nstatic PyObject *\ngethost_common(socket_state *state, struct hostent *h, struct sockaddr *addr,\n               size_t alen, int af)\n{\n    char **pch;\n    PyObject *rtn_tuple = (PyObject *)NULL;\n    PyObject *name_list = (PyObject *)NULL;\n    PyObject *addr_list = (PyObject *)NULL;\n    PyObject *tmp;\n    PyObject *name;\n\n    if (h == NULL) {\n        /* Let's get real error message to return */\n        set_herror(state, h_errno);\n        return NULL;\n    }\n\n    if (h->h_addrtype != af) {\n        /* Let's get real error message to return */\n        errno = EAFNOSUPPORT;\n        PyErr_SetFromErrno(PyExc_OSError);\n        return NULL;\n    }\n\n    switch (af) {\n\n    case AF_INET:\n        if (alen < sizeof(struct sockaddr_in))\n            return NULL;\n        break;\n\n#ifdef ENABLE_IPV6\n    case AF_INET6:\n        if (alen < sizeof(struct sockaddr_in6))\n            return NULL;\n        break;\n#endif\n\n    }\n\n    if ((name_list = PyList_New(0)) == NULL)\n        goto err;\n\n    if ((addr_list = PyList_New(0)) == NULL)\n        goto err;\n\n    /* SF #1511317: h_aliases can be NULL */\n    if (h->h_aliases) {\n        for (pch = h->h_aliases; ; pch++) {\n            int status;\n            char *host_alias;\n            // pch can be misaligned\n            memcpy(&host_alias, pch, sizeof(host_alias));\n            if (host_alias == NULL) {\n                break;\n            }\n            tmp = PyUnicode_FromString(host_alias);\n            if (tmp == NULL)\n                goto err;\n\n            status = PyList_Append(name_list, tmp);\n            Py_DECREF(tmp);\n\n            if (status)\n                goto err;\n        }\n    }\n\n    for (pch = h->h_addr_list; ; pch++) {\n        int status;\n        char *host_address;\n        // pch can be misaligned\n        memcpy(&host_address, pch, sizeof(host_address));\n        if (host_address == NULL) {\n            break;\n        }\n\n        switch (af) {\n\n        case AF_INET:\n            {\n            struct sockaddr_in sin;\n            memset(&sin, 0, sizeof(sin));\n            sin.sin_family = af;\n#ifdef HAVE_SOCKADDR_SA_LEN\n            sin.sin_len = sizeof(sin);\n#endif\n            memcpy(&sin.sin_addr, host_address, sizeof(sin.sin_addr));\n            tmp = make_ipv4_addr(&sin);\n\n            if (pch == h->h_addr_list && alen >= sizeof(sin))\n                memcpy((char *) addr, &sin, sizeof(sin));\n            break;\n            }\n\n#ifdef ENABLE_IPV6\n        case AF_INET6:\n            {\n            struct sockaddr_in6 sin6;\n            memset(&sin6, 0, sizeof(sin6));\n            sin6.sin6_family = af;\n#ifdef HAVE_SOCKADDR_SA_LEN\n            sin6.sin6_len = sizeof(sin6);\n#endif\n            memcpy(&sin6.sin6_addr, host_address, sizeof(sin6.sin6_addr));\n            tmp = make_ipv6_addr(&sin6);\n\n            if (pch == h->h_addr_list && alen >= sizeof(sin6))\n                memcpy((char *) addr, &sin6, sizeof(sin6));\n            break;\n            }\n#endif\n\n        default:                /* can't happen */\n            PyErr_SetString(PyExc_OSError,\n                            \"unsupported address family\");\n            return NULL;\n        }\n\n        if (tmp == NULL)\n            goto err;\n\n        status = PyList_Append(addr_list, tmp);\n        Py_DECREF(tmp);\n\n        if (status)\n            goto err;\n    }\n\n    name = sock_decode_hostname(h->h_name);\n    if (name == NULL)\n        goto err;\n    rtn_tuple = Py_BuildValue(\"NOO\", name, name_list, addr_list);\n\n err:\n    Py_XDECREF(name_list);\n    Py_XDECREF(addr_list);\n    return rtn_tuple;\n}\n#endif\n\n#if defined(HAVE_GETHOSTBYNAME_R) || defined (HAVE_GETHOSTBYNAME)\n/* Python interface to gethostbyname_ex(name). */\n\n/*ARGSUSED*/\nstatic PyObject *\nsocket_gethostbyname_ex(PyObject *self, PyObject *args)\n{\n    char *name;\n    struct hostent *h;\n    sock_addr_t addr;\n    struct sockaddr *sa;\n    PyObject *ret = NULL;\n#ifdef HAVE_GETHOSTBYNAME_R\n    struct hostent hp_allocated;\n#ifdef HAVE_GETHOSTBYNAME_R_3_ARG\n    struct hostent_data data;\n#else\n    char buf[16384];\n    int buf_len = (sizeof buf) - 1;\n    int errnop;\n#endif\n#ifdef HAVE_GETHOSTBYNAME_R_3_ARG\n    int result;\n#endif\n#endif /* HAVE_GETHOSTBYNAME_R */\n\n    if (!PyArg_ParseTuple(args, \"et:gethostbyname_ex\", \"idna\", &name))\n        return NULL;\n    if (PySys_Audit(\"socket.gethostbyname\", \"O\", args) < 0) {\n        goto finally;\n    }\n    socket_state *state = get_module_state(self);\n    if (setipaddr(state, name, SAS2SA(&addr), sizeof(addr), AF_INET) < 0) {\n        goto finally;\n    }\n    Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_GETHOSTBYNAME_R\n#if   defined(HAVE_GETHOSTBYNAME_R_6_ARG)\n    gethostbyname_r(name, &hp_allocated, buf, buf_len,\n                             &h, &errnop);\n#elif defined(HAVE_GETHOSTBYNAME_R_5_ARG)\n    h = gethostbyname_r(name, &hp_allocated, buf, buf_len, &errnop);\n#else /* HAVE_GETHOSTBYNAME_R_3_ARG */\n    memset((void *) &data, '\\0', sizeof(data));\n    result = gethostbyname_r(name, &hp_allocated, &data);\n    h = (result != 0) ? NULL : &hp_allocated;\n#endif\n#else /* not HAVE_GETHOSTBYNAME_R */\n#ifdef USE_GETHOSTBYNAME_LOCK\n    PyThread_acquire_lock(netdb_lock, 1);\n#endif\n    SUPPRESS_DEPRECATED_CALL\n    h = gethostbyname(name);\n#endif /* HAVE_GETHOSTBYNAME_R */\n    Py_END_ALLOW_THREADS\n    /* Some C libraries would require addr.__ss_family instead of\n       addr.ss_family.\n       Therefore, we cast the sockaddr_storage into sockaddr to\n       access sa_family. */\n    sa = SAS2SA(&addr);\n    ret = gethost_common(state, h, SAS2SA(&addr), sizeof(addr),\n                         sa->sa_family);\n#ifdef USE_GETHOSTBYNAME_LOCK\n    PyThread_release_lock(netdb_lock);\n#endif\nfinally:\n    PyMem_Free(name);\n    return ret;\n}\n\nPyDoc_STRVAR(ghbn_ex_doc,\n\"gethostbyname_ex(host) -> (name, aliaslist, addresslist)\\n\\\n\\n\\\nReturn the true host name, a list of aliases, and a list of IP addresses,\\n\\\nfor a host.  The host argument is a string giving a host name or IP number.\");\n#endif\n\n#if defined(HAVE_GETHOSTBYNAME_R) || defined (HAVE_GETHOSTBYADDR)\n/* Python interface to gethostbyaddr(IP). */\n\n/*ARGSUSED*/\nstatic PyObject *\nsocket_gethostbyaddr(PyObject *self, PyObject *args)\n{\n    sock_addr_t addr;\n    struct sockaddr *sa = SAS2SA(&addr);\n    char *ip_num;\n    struct hostent *h;\n    PyObject *ret = NULL;\n#ifdef HAVE_GETHOSTBYNAME_R\n    struct hostent hp_allocated;\n#ifdef HAVE_GETHOSTBYNAME_R_3_ARG\n    struct hostent_data data;\n#else\n    /* glibcs up to 2.10 assume that the buf argument to\n       gethostbyaddr_r is 8-byte aligned, which at least llvm-gcc\n       does not ensure. The attribute below instructs the compiler\n       to maintain this alignment. */\n    char buf[16384] Py_ALIGNED(8);\n    int buf_len = (sizeof buf) - 1;\n    int errnop;\n#endif\n#ifdef HAVE_GETHOSTBYNAME_R_3_ARG\n    int result;\n#endif\n#endif /* HAVE_GETHOSTBYNAME_R */\n    const char *ap;\n    int al;\n    int af;\n\n    if (!PyArg_ParseTuple(args, \"et:gethostbyaddr\", \"idna\", &ip_num))\n        return NULL;\n    if (PySys_Audit(\"socket.gethostbyaddr\", \"O\", args) < 0) {\n        goto finally;\n    }\n    af = AF_UNSPEC;\n    socket_state *state = get_module_state(self);\n    if (setipaddr(state, ip_num, sa, sizeof(addr), af) < 0) {\n        goto finally;\n    }\n    af = sa->sa_family;\n    ap = NULL;\n    /* al = 0; */\n    switch (af) {\n    case AF_INET:\n        ap = (char *)&((struct sockaddr_in *)sa)->sin_addr;\n        al = sizeof(((struct sockaddr_in *)sa)->sin_addr);\n        break;\n#ifdef ENABLE_IPV6\n    case AF_INET6:\n        ap = (char *)&((struct sockaddr_in6 *)sa)->sin6_addr;\n        al = sizeof(((struct sockaddr_in6 *)sa)->sin6_addr);\n        break;\n#endif\n    default:\n        PyErr_SetString(PyExc_OSError, \"unsupported address family\");\n        goto finally;\n    }\n    Py_BEGIN_ALLOW_THREADS\n#ifdef HAVE_GETHOSTBYNAME_R\n#if   defined(HAVE_GETHOSTBYNAME_R_6_ARG)\n    gethostbyaddr_r(ap, al, af,\n        &hp_allocated, buf, buf_len,\n        &h, &errnop);\n#elif defined(HAVE_GETHOSTBYNAME_R_5_ARG)\n    h = gethostbyaddr_r(ap, al, af,\n                        &hp_allocated, buf, buf_len, &errnop);\n#else /* HAVE_GETHOSTBYNAME_R_3_ARG */\n    memset((void *) &data, '\\0', sizeof(data));\n    result = gethostbyaddr_r(ap, al, af, &hp_allocated, &data);\n    h = (result != 0) ? NULL : &hp_allocated;\n#endif\n#else /* not HAVE_GETHOSTBYNAME_R */\n#ifdef USE_GETHOSTBYNAME_LOCK\n    PyThread_acquire_lock(netdb_lock, 1);\n#endif\n    SUPPRESS_DEPRECATED_CALL\n    h = gethostbyaddr(ap, al, af);\n#endif /* HAVE_GETHOSTBYNAME_R */\n    Py_END_ALLOW_THREADS\n    ret = gethost_common(state, h, SAS2SA(&addr), sizeof(addr), af);\n#ifdef USE_GETHOSTBYNAME_LOCK\n    PyThread_release_lock(netdb_lock);\n#endif\nfinally:\n    PyMem_Free(ip_num);\n    return ret;\n}\n\nPyDoc_STRVAR(gethostbyaddr_doc,\n\"gethostbyaddr(host) -> (name, aliaslist, addresslist)\\n\\\n\\n\\\nReturn the true host name, a list of aliases, and a list of IP addresses,\\n\\\nfor a host.  The host argument is a string giving a host name or IP number.\");\n#endif\n\n#ifdef HAVE_GETSERVBYNAME\n/* Python interface to getservbyname(name).\n   This only returns the port number, since the other info is already\n   known or not useful (like the list of aliases). */\n\n/*ARGSUSED*/\nstatic PyObject *\nsocket_getservbyname(PyObject *self, PyObject *args)\n{\n    const char *name, *proto=NULL;\n    struct servent *sp;\n    if (!PyArg_ParseTuple(args, \"s|s:getservbyname\", &name, &proto))\n        return NULL;\n\n    if (PySys_Audit(\"socket.getservbyname\", \"ss\", name, proto) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    sp = getservbyname(name, proto);\n    Py_END_ALLOW_THREADS\n    if (sp == NULL) {\n        PyErr_SetString(PyExc_OSError, \"service/proto not found\");\n        return NULL;\n    }\n    return PyLong_FromLong((long) ntohs(sp->s_port));\n}\n\nPyDoc_STRVAR(getservbyname_doc,\n\"getservbyname(servicename[, protocolname]) -> integer\\n\\\n\\n\\\nReturn a port number from a service name and protocol name.\\n\\\nThe optional protocol name, if given, should be 'tcp' or 'udp',\\n\\\notherwise any protocol will match.\");\n#endif\n\n#ifdef HAVE_GETSERVBYPORT\n/* Python interface to getservbyport(port).\n   This only returns the service name, since the other info is already\n   known or not useful (like the list of aliases). */\n\n/*ARGSUSED*/\nstatic PyObject *\nsocket_getservbyport(PyObject *self, PyObject *args)\n{\n    int port;\n    const char *proto=NULL;\n    struct servent *sp;\n    if (!PyArg_ParseTuple(args, \"i|s:getservbyport\", &port, &proto))\n        return NULL;\n    if (port < 0 || port > 0xffff) {\n        PyErr_SetString(\n            PyExc_OverflowError,\n            \"getservbyport: port must be 0-65535.\");\n        return NULL;\n    }\n\n    if (PySys_Audit(\"socket.getservbyport\", \"is\", port, proto) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    sp = getservbyport(htons((short)port), proto);\n    Py_END_ALLOW_THREADS\n    if (sp == NULL) {\n        PyErr_SetString(PyExc_OSError, \"port/proto not found\");\n        return NULL;\n    }\n    return PyUnicode_FromString(sp->s_name);\n}\n\nPyDoc_STRVAR(getservbyport_doc,\n\"getservbyport(port[, protocolname]) -> string\\n\\\n\\n\\\nReturn the service name from a port number and protocol name.\\n\\\nThe optional protocol name, if given, should be 'tcp' or 'udp',\\n\\\notherwise any protocol will match.\");\n#endif\n\n#ifdef HAVE_GETPROTOBYNAME\n/* Python interface to getprotobyname(name).\n   This only returns the protocol number, since the other info is\n   already known or not useful (like the list of aliases). */\n\n/*ARGSUSED*/\nstatic PyObject *\nsocket_getprotobyname(PyObject *self, PyObject *args)\n{\n    const char *name;\n    struct protoent *sp;\n    if (!PyArg_ParseTuple(args, \"s:getprotobyname\", &name))\n        return NULL;\n    Py_BEGIN_ALLOW_THREADS\n    sp = getprotobyname(name);\n    Py_END_ALLOW_THREADS\n    if (sp == NULL) {\n        PyErr_SetString(PyExc_OSError, \"protocol not found\");\n        return NULL;\n    }\n    return PyLong_FromLong((long) sp->p_proto);\n}\n\nPyDoc_STRVAR(getprotobyname_doc,\n\"getprotobyname(name) -> integer\\n\\\n\\n\\\nReturn the protocol number for the named protocol.  (Rarely used.)\");\n#endif\n\nstatic PyObject *\nsocket_close(PyObject *self, PyObject *fdobj)\n{\n    SOCKET_T fd;\n    int res;\n\n    fd = PyLong_AsSocket_t(fdobj);\n    if (fd == (SOCKET_T)(-1) && PyErr_Occurred())\n        return NULL;\n    Py_BEGIN_ALLOW_THREADS\n    res = SOCKETCLOSE(fd);\n    Py_END_ALLOW_THREADS\n    /* bpo-30319: The peer can already have closed the connection.\n       Python ignores ECONNRESET on close(). */\n    if (res < 0 && !CHECK_ERRNO(ECONNRESET)) {\n        return set_error();\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(close_doc,\n\"close(integer) -> None\\n\\\n\\n\\\nClose an integer socket file descriptor.  This is like os.close(), but for\\n\\\nsockets; on some platforms os.close() won't work for socket file descriptors.\");\n\n#ifndef NO_DUP\n/* dup() function for socket fds */\n\nstatic PyObject *\nsocket_dup(PyObject *self, PyObject *fdobj)\n{\n    SOCKET_T fd, newfd;\n    PyObject *newfdobj;\n#ifdef MS_WINDOWS\n    WSAPROTOCOL_INFOW info;\n#endif\n\n    fd = PyLong_AsSocket_t(fdobj);\n    if (fd == (SOCKET_T)(-1) && PyErr_Occurred()) {\n        return NULL;\n    }\n\n#ifdef MS_WINDOWS\n    if (WSADuplicateSocketW(fd, GetCurrentProcessId(), &info))\n        return set_error();\n\n    newfd = WSASocketW(FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO,\n                      FROM_PROTOCOL_INFO,\n                      &info, 0, WSA_FLAG_OVERLAPPED);\n    if (newfd == INVALID_SOCKET) {\n        return set_error();\n    }\n\n    if (!SetHandleInformation((HANDLE)newfd, HANDLE_FLAG_INHERIT, 0)) {\n        PyErr_SetFromWindowsErr(0);\n        closesocket(newfd);\n        return NULL;\n    }\n#else\n    /* On UNIX, dup can be used to duplicate the file descriptor of a socket */\n    newfd = _Py_dup(fd);\n    if (newfd == INVALID_SOCKET) {\n        return NULL;\n    }\n#endif\n\n    newfdobj = PyLong_FromSocket_t(newfd);\n    if (newfdobj == NULL) {\n        SOCKETCLOSE(newfd);\n    }\n    return newfdobj;\n}\n\nPyDoc_STRVAR(dup_doc,\n\"dup(integer) -> integer\\n\\\n\\n\\\nDuplicate an integer socket file descriptor.  This is like os.dup(), but for\\n\\\nsockets; on some platforms os.dup() won't work for socket file descriptors.\");\n#endif\n\n\n#ifdef HAVE_SOCKETPAIR\n/* Create a pair of sockets using the socketpair() function.\n   Arguments as for socket() except the default family is AF_UNIX if\n   defined on the platform; otherwise, the default is AF_INET. */\n\n/*ARGSUSED*/\nstatic PyObject *\nsocket_socketpair(PyObject *self, PyObject *args)\n{\n    PySocketSockObject *s0 = NULL, *s1 = NULL;\n    SOCKET_T sv[2];\n    int family, type = SOCK_STREAM, proto = 0;\n    PyObject *res = NULL;\n    socket_state *state = get_module_state(self);\n#ifdef SOCK_CLOEXEC\n    int *atomic_flag_works = &state->sock_cloexec_works;\n#else\n    int *atomic_flag_works = NULL;\n#endif\n    int ret;\n\n#if defined(AF_UNIX)\n    family = AF_UNIX;\n#else\n    family = AF_INET;\n#endif\n    if (!PyArg_ParseTuple(args, \"|iii:socketpair\",\n                          &family, &type, &proto))\n        return NULL;\n\n    /* Create a pair of socket fds */\n    Py_BEGIN_ALLOW_THREADS\n#ifdef SOCK_CLOEXEC\n    if (state->sock_cloexec_works != 0) {\n        ret = socketpair(family, type | SOCK_CLOEXEC, proto, sv);\n        if (state->sock_cloexec_works == -1) {\n            if (ret >= 0) {\n                state->sock_cloexec_works = 1;\n            }\n            else if (errno == EINVAL) {\n                /* Linux older than 2.6.27 does not support SOCK_CLOEXEC */\n                state->sock_cloexec_works = 0;\n                ret = socketpair(family, type, proto, sv);\n            }\n        }\n    }\n    else\n#endif\n    {\n        ret = socketpair(family, type, proto, sv);\n    }\n    Py_END_ALLOW_THREADS\n\n    if (ret < 0)\n        return set_error();\n\n    if (_Py_set_inheritable(sv[0], 0, atomic_flag_works) < 0)\n        goto finally;\n    if (_Py_set_inheritable(sv[1], 0, atomic_flag_works) < 0)\n        goto finally;\n\n    s0 = new_sockobject(state, sv[0], family, type, proto);\n    if (s0 == NULL)\n        goto finally;\n    s1 = new_sockobject(state, sv[1], family, type, proto);\n    if (s1 == NULL)\n        goto finally;\n    res = PyTuple_Pack(2, s0, s1);\n\nfinally:\n    if (res == NULL) {\n        if (s0 == NULL)\n            SOCKETCLOSE(sv[0]);\n        if (s1 == NULL)\n            SOCKETCLOSE(sv[1]);\n    }\n    Py_XDECREF(s0);\n    Py_XDECREF(s1);\n    return res;\n}\n\nPyDoc_STRVAR(socketpair_doc,\n\"socketpair([family[, type [, proto]]]) -> (socket object, socket object)\\n\\\n\\n\\\nCreate a pair of socket objects from the sockets returned by the platform\\n\\\nsocketpair() function.\\n\\\nThe arguments are the same as for socket() except the default family is\\n\\\nAF_UNIX if defined on the platform; otherwise, the default is AF_INET.\");\n\n#endif /* HAVE_SOCKETPAIR */\n\n\n/*[clinic input]\n_socket.socket.ntohs\n    x: int\n    /\n\nConvert a 16-bit unsigned integer from network to host byte order.\n[clinic start generated code]*/\n\nstatic PyObject *\n_socket_socket_ntohs_impl(PySocketSockObject *self, int x)\n/*[clinic end generated code: output=a828a61a9fb205b2 input=9a79cb3a71652147]*/\n{\n    if (x < 0) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"ntohs: can't convert negative Python int to C \"\n                        \"16-bit unsigned integer\");\n        return NULL;\n    }\n    if (x > 0xffff) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"ntohs: Python int too large to convert to C \"\n                        \"16-bit unsigned integer\");\n        return NULL;\n    }\n    return PyLong_FromUnsignedLong(ntohs((unsigned short)x));\n}\n\n\nstatic PyObject *\nsocket_ntohl(PyObject *self, PyObject *arg)\n{\n    unsigned long x;\n\n    if (PyLong_Check(arg)) {\n        x = PyLong_AsUnsignedLong(arg);\n        if (x == (unsigned long) -1 && PyErr_Occurred())\n            return NULL;\n#if SIZEOF_LONG > 4\n        {\n            unsigned long y;\n            /* only want the trailing 32 bits */\n            y = x & 0xFFFFFFFFUL;\n            if (y ^ x)\n                return PyErr_Format(PyExc_OverflowError,\n                            \"int larger than 32 bits\");\n            x = y;\n        }\n#endif\n    }\n    else\n        return PyErr_Format(PyExc_TypeError,\n                            \"expected int, %s found\",\n                            Py_TYPE(arg)->tp_name);\n    return PyLong_FromUnsignedLong(ntohl(x));\n}\n\nPyDoc_STRVAR(ntohl_doc,\n\"ntohl(integer) -> integer\\n\\\n\\n\\\nConvert a 32-bit integer from network to host byte order.\");\n\n\n/*[clinic input]\n_socket.socket.htons\n    x: int\n    /\n\nConvert a 16-bit unsigned integer from host to network byte order.\n[clinic start generated code]*/\n\nstatic PyObject *\n_socket_socket_htons_impl(PySocketSockObject *self, int x)\n/*[clinic end generated code: output=d785ee692312da47 input=053252d8416f4337]*/\n{\n    if (x < 0) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"htons: can't convert negative Python int to C \"\n                        \"16-bit unsigned integer\");\n        return NULL;\n    }\n    if (x > 0xffff) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"htons: Python int too large to convert to C \"\n                        \"16-bit unsigned integer\");\n        return NULL;\n    }\n    return PyLong_FromUnsignedLong(htons((unsigned short)x));\n}\n\n\nstatic PyObject *\nsocket_htonl(PyObject *self, PyObject *arg)\n{\n    unsigned long x;\n\n    if (PyLong_Check(arg)) {\n        x = PyLong_AsUnsignedLong(arg);\n        if (x == (unsigned long) -1 && PyErr_Occurred())\n            return NULL;\n#if SIZEOF_LONG > 4\n        {\n            unsigned long y;\n            /* only want the trailing 32 bits */\n            y = x & 0xFFFFFFFFUL;\n            if (y ^ x)\n                return PyErr_Format(PyExc_OverflowError,\n                            \"int larger than 32 bits\");\n            x = y;\n        }\n#endif\n    }\n    else\n        return PyErr_Format(PyExc_TypeError,\n                            \"expected int, %s found\",\n                            Py_TYPE(arg)->tp_name);\n    return PyLong_FromUnsignedLong(htonl((unsigned long)x));\n}\n\nPyDoc_STRVAR(htonl_doc,\n\"htonl(integer) -> integer\\n\\\n\\n\\\nConvert a 32-bit integer from host to network byte order.\");\n\n/* socket.inet_aton() and socket.inet_ntoa() functions. */\n\n/*[clinic input]\n_socket.socket.inet_aton\n    ip_addr: str\n    /\n\nConvert an IP address in string format (123.45.67.89) to the 32-bit packed binary format used in low-level network functions.\n[clinic start generated code]*/\n\nstatic PyObject *\n_socket_socket_inet_aton_impl(PySocketSockObject *self, const char *ip_addr)\n/*[clinic end generated code: output=5bfe11a255423d8c input=a120e20cb52b9488]*/\n{\n#ifdef HAVE_INET_ATON\n    struct in_addr buf;\n#endif\n\n#if !defined(HAVE_INET_ATON) || defined(USE_INET_ATON_WEAKLINK)\n#if (SIZEOF_INT != 4)\n#error \"Not sure if in_addr_t exists and int is not 32-bits.\"\n#endif\n    /* Have to use inet_addr() instead */\n    unsigned int packed_addr;\n#endif\n\n#ifdef HAVE_INET_ATON\n\n#ifdef USE_INET_ATON_WEAKLINK\n    if (inet_aton != NULL) {\n#endif\n    if (inet_aton(ip_addr, &buf))\n        return PyBytes_FromStringAndSize((char *)(&buf),\n                                          sizeof(buf));\n\n    PyErr_SetString(PyExc_OSError,\n                    \"illegal IP address string passed to inet_aton\");\n    return NULL;\n\n#ifdef USE_INET_ATON_WEAKLINK\n   } else {\n#endif\n\n#endif\n\n#if !defined(HAVE_INET_ATON) || defined(USE_INET_ATON_WEAKLINK)\n\n    /* special-case this address as inet_addr might return INADDR_NONE\n     * for this */\n    if (strcmp(ip_addr, \"255.255.255.255\") == 0) {\n        packed_addr = INADDR_BROADCAST;\n    } else {\n\n        SUPPRESS_DEPRECATED_CALL\n        packed_addr = inet_addr(ip_addr);\n\n        if (packed_addr == INADDR_NONE) {               /* invalid address */\n            PyErr_SetString(PyExc_OSError,\n                \"illegal IP address string passed to inet_aton\");\n            return NULL;\n        }\n    }\n    return PyBytes_FromStringAndSize((char *) &packed_addr,\n                                      sizeof(packed_addr));\n\n#ifdef USE_INET_ATON_WEAKLINK\n   }\n#endif\n\n#endif\n}\n\n#ifdef HAVE_INET_NTOA\n/*[clinic input]\n_socket.socket.inet_ntoa\n    packed_ip: Py_buffer\n    /\n\nConvert an IP address from 32-bit packed binary format to string format.\n[clinic start generated code]*/\n\nstatic PyObject *\n_socket_socket_inet_ntoa_impl(PySocketSockObject *self, Py_buffer *packed_ip)\n/*[clinic end generated code: output=b671880a3f62461b input=95c2c4a1b2ee957c]*/\n{\n    struct in_addr packed_addr;\n\n    if (packed_ip->len != sizeof(packed_addr)) {\n        PyErr_SetString(PyExc_OSError,\n            \"packed IP wrong length for inet_ntoa\");\n        PyBuffer_Release(packed_ip);\n        return NULL;\n    }\n\n    memcpy(&packed_addr, packed_ip->buf, packed_ip->len);\n    PyBuffer_Release(packed_ip);\n\n    SUPPRESS_DEPRECATED_CALL\n    return PyUnicode_FromString(inet_ntoa(packed_addr));\n}\n#endif // HAVE_INET_NTOA\n\n#ifdef HAVE_INET_PTON\n\nPyDoc_STRVAR(inet_pton_doc,\n\"inet_pton(af, ip) -> packed IP address string\\n\\\n\\n\\\nConvert an IP address from string format to a packed string suitable\\n\\\nfor use with low-level network functions.\");\n\nstatic PyObject *\nsocket_inet_pton(PyObject *self, PyObject *args)\n{\n    int af;\n    const char* ip;\n    int retval;\n#ifdef ENABLE_IPV6\n    char packed[Py_MAX(sizeof(struct in_addr), sizeof(struct in6_addr))];\n#else\n    char packed[sizeof(struct in_addr)];\n#endif\n    if (!PyArg_ParseTuple(args, \"is:inet_pton\", &af, &ip)) {\n        return NULL;\n    }\n\n#if !defined(ENABLE_IPV6) && defined(AF_INET6)\n    if(af == AF_INET6) {\n        PyErr_SetString(PyExc_OSError,\n                        \"can't use AF_INET6, IPv6 is disabled\");\n        return NULL;\n    }\n#endif\n\n    retval = inet_pton(af, ip, packed);\n    if (retval < 0) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        return NULL;\n    } else if (retval == 0) {\n        PyErr_SetString(PyExc_OSError,\n            \"illegal IP address string passed to inet_pton\");\n        return NULL;\n    } else if (af == AF_INET) {\n        return PyBytes_FromStringAndSize(packed,\n                                          sizeof(struct in_addr));\n#ifdef ENABLE_IPV6\n    } else if (af == AF_INET6) {\n        return PyBytes_FromStringAndSize(packed,\n                                          sizeof(struct in6_addr));\n#endif\n    } else {\n        PyErr_SetString(PyExc_OSError, \"unknown address family\");\n        return NULL;\n    }\n}\n\nPyDoc_STRVAR(inet_ntop_doc,\n\"inet_ntop(af, packed_ip) -> string formatted IP address\\n\\\n\\n\\\nConvert a packed IP address of the given family to string format.\");\n\nstatic PyObject *\nsocket_inet_ntop(PyObject *self, PyObject *args)\n{\n    int af;\n    Py_buffer packed_ip;\n    const char* retval;\n#ifdef ENABLE_IPV6\n    char ip[Py_MAX(INET_ADDRSTRLEN, INET6_ADDRSTRLEN)];\n#else\n    char ip[INET_ADDRSTRLEN];\n#endif\n\n    if (!PyArg_ParseTuple(args, \"iy*:inet_ntop\", &af, &packed_ip)) {\n        return NULL;\n    }\n\n    if (af == AF_INET) {\n        if (packed_ip.len != sizeof(struct in_addr)) {\n            PyErr_SetString(PyExc_ValueError,\n                \"invalid length of packed IP address string\");\n            PyBuffer_Release(&packed_ip);\n            return NULL;\n        }\n#ifdef ENABLE_IPV6\n    } else if (af == AF_INET6) {\n        if (packed_ip.len != sizeof(struct in6_addr)) {\n            PyErr_SetString(PyExc_ValueError,\n                \"invalid length of packed IP address string\");\n            PyBuffer_Release(&packed_ip);\n            return NULL;\n        }\n#endif\n    } else {\n        PyErr_Format(PyExc_ValueError,\n            \"unknown address family %d\", af);\n        PyBuffer_Release(&packed_ip);\n        return NULL;\n    }\n\n    /* inet_ntop guarantee NUL-termination of resulting string. */\n    retval = inet_ntop(af, packed_ip.buf, ip, sizeof(ip));\n    if (!retval) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        PyBuffer_Release(&packed_ip);\n        return NULL;\n    } else {\n        PyBuffer_Release(&packed_ip);\n        return PyUnicode_FromString(retval);\n    }\n}\n\n#endif /* HAVE_INET_PTON */\n\n#ifdef HAVE_GETADDRINFO\n/* Python interface to getaddrinfo(host, port). */\n\n/*ARGSUSED*/\nstatic PyObject *\nsocket_getaddrinfo(PyObject *self, PyObject *args, PyObject* kwargs)\n{\n    static char* kwnames[] = {\"host\", \"port\", \"family\", \"type\", \"proto\",\n                              \"flags\", 0};\n    struct addrinfo hints, *res;\n    struct addrinfo *res0 = NULL;\n    PyObject *hobj = NULL;\n    PyObject *pobj = (PyObject *)NULL;\n    PyObject *pstr = NULL;\n    const char *hptr, *pptr;\n    int family, socktype, protocol, flags;\n    int error;\n    PyObject *all = (PyObject *)NULL;\n    PyObject *idna = NULL;\n\n    socktype = protocol = flags = 0;\n    family = AF_UNSPEC;\n    if (!PyArg_ParseTupleAndKeywords(args, kwargs, \"OO|iiii:getaddrinfo\",\n                          kwnames, &hobj, &pobj, &family, &socktype,\n                          &protocol, &flags)) {\n        return NULL;\n    }\n    if (hobj == Py_None) {\n        hptr = NULL;\n    } else if (PyUnicode_Check(hobj)) {\n        idna = PyUnicode_AsEncodedString(hobj, \"idna\", NULL);\n        if (!idna)\n            return NULL;\n        assert(PyBytes_Check(idna));\n        hptr = PyBytes_AS_STRING(idna);\n    } else if (PyBytes_Check(hobj)) {\n        hptr = PyBytes_AsString(hobj);\n    } else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"getaddrinfo() argument 1 must be string or None\");\n        return NULL;\n    }\n    if (PyLong_CheckExact(pobj)) {\n        pstr = PyObject_Str(pobj);\n        if (pstr == NULL)\n            goto err;\n        assert(PyUnicode_Check(pstr));\n        pptr = PyUnicode_AsUTF8(pstr);\n        if (pptr == NULL)\n            goto err;\n    } else if (PyUnicode_Check(pobj)) {\n        pptr = PyUnicode_AsUTF8(pobj);\n        if (pptr == NULL)\n            goto err;\n    } else if (PyBytes_Check(pobj)) {\n        pptr = PyBytes_AS_STRING(pobj);\n    } else if (pobj == Py_None) {\n        pptr = (char *)NULL;\n    } else {\n        PyErr_SetString(PyExc_OSError, \"Int or String expected\");\n        goto err;\n    }\n#if defined(__APPLE__) && defined(AI_NUMERICSERV)\n    if ((flags & AI_NUMERICSERV) && (pptr == NULL || (pptr[0] == '0' && pptr[1] == 0))) {\n        /* On OSX up to at least OSX 10.8 getaddrinfo crashes\n         * if AI_NUMERICSERV is set and the servname is NULL or \"0\".\n         * This workaround avoids a segfault in libsystem.\n         */\n        pptr = \"00\";\n    }\n#endif\n\n    if (PySys_Audit(\"socket.getaddrinfo\", \"OOiii\",\n                    hobj, pobj, family, socktype, protocol) < 0) {\n        return NULL;\n    }\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_socktype = socktype;\n    hints.ai_protocol = protocol;\n    hints.ai_flags = flags;\n    Py_BEGIN_ALLOW_THREADS\n    error = getaddrinfo(hptr, pptr, &hints, &res0);\n    Py_END_ALLOW_THREADS\n    if (error) {\n        res0 = NULL;  // gh-100795\n        socket_state *state = get_module_state(self);\n        set_gaierror(state, error);\n        goto err;\n    }\n\n    all = PyList_New(0);\n    if (all == NULL)\n        goto err;\n    for (res = res0; res; res = res->ai_next) {\n        PyObject *single;\n        PyObject *addr =\n            makesockaddr(-1, res->ai_addr, res->ai_addrlen, protocol);\n        if (addr == NULL)\n            goto err;\n        single = Py_BuildValue(\"iiisO\", res->ai_family,\n            res->ai_socktype, res->ai_protocol,\n            res->ai_canonname ? res->ai_canonname : \"\",\n            addr);\n        Py_DECREF(addr);\n        if (single == NULL)\n            goto err;\n\n        if (PyList_Append(all, single)) {\n            Py_DECREF(single);\n            goto err;\n        }\n        Py_DECREF(single);\n    }\n    Py_XDECREF(idna);\n    Py_XDECREF(pstr);\n    if (res0)\n        freeaddrinfo(res0);\n    return all;\n err:\n    Py_XDECREF(all);\n    Py_XDECREF(idna);\n    Py_XDECREF(pstr);\n    if (res0)\n        freeaddrinfo(res0);\n    return (PyObject *)NULL;\n}\n\nPyDoc_STRVAR(getaddrinfo_doc,\n\"getaddrinfo(host, port [, family, type, proto, flags])\\n\\\n    -> list of (family, type, proto, canonname, sockaddr)\\n\\\n\\n\\\nResolve host and port into addrinfo struct.\");\n#endif // HAVE_GETADDRINFO\n\n#ifdef HAVE_GETNAMEINFO\n/* Python interface to getnameinfo(sa, flags). */\n\n/*ARGSUSED*/\nstatic PyObject *\nsocket_getnameinfo(PyObject *self, PyObject *args)\n{\n    PyObject *sa = (PyObject *)NULL;\n    int flags;\n    const char *hostp;\n    int port;\n    unsigned int flowinfo, scope_id;\n    char hbuf[NI_MAXHOST], pbuf[NI_MAXSERV];\n    struct addrinfo hints, *res = NULL;\n    int error;\n    PyObject *ret = (PyObject *)NULL;\n    PyObject *name;\n\n    flags = flowinfo = scope_id = 0;\n    if (!PyArg_ParseTuple(args, \"Oi:getnameinfo\", &sa, &flags))\n        return NULL;\n    if (!PyTuple_Check(sa)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"getnameinfo() argument 1 must be a tuple\");\n        return NULL;\n    }\n    if (!PyArg_ParseTuple(sa, \"si|II;getnameinfo(): illegal sockaddr argument\",\n                          &hostp, &port, &flowinfo, &scope_id))\n    {\n        return NULL;\n    }\n    if (flowinfo > 0xfffff) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"getnameinfo(): flowinfo must be 0-1048575.\");\n        return NULL;\n    }\n\n    if (PySys_Audit(\"socket.getnameinfo\", \"(O)\", sa) < 0) {\n        return NULL;\n    }\n\n    PyOS_snprintf(pbuf, sizeof(pbuf), \"%d\", port);\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_DGRAM;     /* make numeric port happy */\n    hints.ai_flags = AI_NUMERICHOST;    /* don't do any name resolution */\n    Py_BEGIN_ALLOW_THREADS\n    error = getaddrinfo(hostp, pbuf, &hints, &res);\n    Py_END_ALLOW_THREADS\n    if (error) {\n        res = NULL;  // gh-100795\n        socket_state *state = get_module_state(self);\n        set_gaierror(state, error);\n        goto fail;\n    }\n    if (res->ai_next) {\n        PyErr_SetString(PyExc_OSError,\n            \"sockaddr resolved to multiple addresses\");\n        goto fail;\n    }\n    switch (res->ai_family) {\n    case AF_INET:\n        {\n        if (PyTuple_GET_SIZE(sa) != 2) {\n            PyErr_SetString(PyExc_OSError,\n                \"IPv4 sockaddr must be 2 tuple\");\n            goto fail;\n        }\n        break;\n        }\n#ifdef ENABLE_IPV6\n    case AF_INET6:\n        {\n        struct sockaddr_in6 *sin6;\n        sin6 = (struct sockaddr_in6 *)res->ai_addr;\n        sin6->sin6_flowinfo = htonl(flowinfo);\n        sin6->sin6_scope_id = scope_id;\n        break;\n        }\n#endif\n    }\n    Py_BEGIN_ALLOW_THREADS\n    error = getnameinfo(res->ai_addr, (socklen_t) res->ai_addrlen,\n                    hbuf, sizeof(hbuf), pbuf, sizeof(pbuf), flags);\n    Py_END_ALLOW_THREADS\n    if (error) {\n        socket_state *state = get_module_state(self);\n        set_gaierror(state, error);\n        goto fail;\n    }\n\n    name = sock_decode_hostname(hbuf);\n    if (name == NULL)\n        goto fail;\n    ret = Py_BuildValue(\"Ns\", name, pbuf);\n\nfail:\n    if (res)\n        freeaddrinfo(res);\n    return ret;\n}\n\nPyDoc_STRVAR(getnameinfo_doc,\n\"getnameinfo(sockaddr, flags) --> (host, port)\\n\\\n\\n\\\nGet host and port for a sockaddr.\");\n#endif // HAVE_GETNAMEINFO\n\n/* Python API to getting and setting the default timeout value. */\n\nstatic PyObject *\nsocket_getdefaulttimeout(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    socket_state *state = get_module_state(self);\n    PyTime_t timeout = _Py_atomic_load_int64_relaxed(&state->defaulttimeout);\n    if (timeout < 0) {\n        Py_RETURN_NONE;\n    }\n    else {\n        double seconds = PyTime_AsSecondsDouble(timeout);\n        return PyFloat_FromDouble(seconds);\n    }\n}\n\nPyDoc_STRVAR(getdefaulttimeout_doc,\n\"getdefaulttimeout() -> timeout\\n\\\n\\n\\\nReturns the default timeout in seconds (float) for new socket objects.\\n\\\nA value of None indicates that new socket objects have no timeout.\\n\\\nWhen the socket module is first imported, the default is None.\");\n\nstatic PyObject *\nsocket_setdefaulttimeout(PyObject *self, PyObject *arg)\n{\n    PyTime_t timeout;\n\n    if (socket_parse_timeout(&timeout, arg) < 0)\n        return NULL;\n\n    socket_state *state = get_module_state(self);\n    _Py_atomic_store_int64_relaxed(&state->defaulttimeout, timeout);\n\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(setdefaulttimeout_doc,\n\"setdefaulttimeout(timeout)\\n\\\n\\n\\\nSet the default timeout in seconds (float) for new socket objects.\\n\\\nA value of None indicates that new socket objects have no timeout.\\n\\\nWhen the socket module is first imported, the default is None.\");\n\n#if defined(HAVE_IF_NAMEINDEX) || defined(MS_WINDOWS)\n/* Python API for getting interface indices and names */\n\nstatic PyObject *\nsocket_if_nameindex(PyObject *self, PyObject *arg)\n{\n    PyObject *list = PyList_New(0);\n    if (list == NULL) {\n        return NULL;\n    }\n#ifdef MS_WINDOWS\n    PMIB_IF_TABLE2 tbl;\n    int ret;\n    if ((ret = GetIfTable2Ex(MibIfTableRaw, &tbl)) != NO_ERROR) {\n        Py_DECREF(list);\n        // ret is used instead of GetLastError()\n        return PyErr_SetFromWindowsErr(ret);\n    }\n    for (ULONG i = 0; i < tbl->NumEntries; ++i) {\n        MIB_IF_ROW2 r = tbl->Table[i];\n        WCHAR buf[NDIS_IF_MAX_STRING_SIZE + 1];\n        if ((ret = ConvertInterfaceLuidToNameW(&r.InterfaceLuid, buf,\n                                               Py_ARRAY_LENGTH(buf)))) {\n            Py_DECREF(list);\n            FreeMibTable(tbl);\n            // ret is used instead of GetLastError()\n            return PyErr_SetFromWindowsErr(ret);\n        }\n        PyObject *tuple = Py_BuildValue(\"Iu\", r.InterfaceIndex, buf);\n        if (tuple == NULL || PyList_Append(list, tuple) == -1) {\n            Py_XDECREF(tuple);\n            Py_DECREF(list);\n            FreeMibTable(tbl);\n            return NULL;\n        }\n        Py_DECREF(tuple);\n    }\n    FreeMibTable(tbl);\n    return list;\n#else\n    int i;\n    struct if_nameindex *ni;\n\n    ni = if_nameindex();\n    if (ni == NULL) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        Py_DECREF(list);\n        return NULL;\n    }\n\n#ifdef _Py_MEMORY_SANITIZER\n    __msan_unpoison(ni, sizeof(ni));\n    __msan_unpoison(&ni[0], sizeof(ni[0]));\n#endif\n    for (i = 0; ni[i].if_index != 0 && i < INT_MAX; i++) {\n#ifdef _Py_MEMORY_SANITIZER\n        /* This one isn't the end sentinel, the next one must exist. */\n        __msan_unpoison(&ni[i+1], sizeof(ni[0]));\n        /* Otherwise Py_BuildValue internals are flagged by MSan when\n           they access the not-msan-tracked if_name string data. */\n        {\n            char *to_sanitize = ni[i].if_name;\n            do {\n                __msan_unpoison(to_sanitize, 1);\n            } while (*to_sanitize++ != '\\0');\n        }\n#endif\n        PyObject *ni_tuple = Py_BuildValue(\"IO&\",\n                ni[i].if_index, PyUnicode_DecodeFSDefault, ni[i].if_name);\n\n        if (ni_tuple == NULL || PyList_Append(list, ni_tuple) == -1) {\n            Py_XDECREF(ni_tuple);\n            Py_DECREF(list);\n            if_freenameindex(ni);\n            return NULL;\n        }\n        Py_DECREF(ni_tuple);\n    }\n\n    if_freenameindex(ni);\n    return list;\n#endif\n}\n\nPyDoc_STRVAR(if_nameindex_doc,\n\"if_nameindex()\\n\\\n\\n\\\nReturns a list of network interface information (index, name) tuples.\");\n\n/*[clinic input]\n_socket.socket.if_nametoindex\n    oname: object(converter=\"PyUnicode_FSConverter\")\n    /\n\nReturns the interface index corresponding to the interface name if_name.\n[clinic start generated code]*/\n\nstatic PyObject *\n_socket_socket_if_nametoindex_impl(PySocketSockObject *self, PyObject *oname)\n/*[clinic end generated code: output=f7fc00511a309a8e input=662688054482cd46]*/\n{\n#ifdef MS_WINDOWS\n    NET_IFINDEX index;\n#else\n    unsigned long index;\n#endif\n\n    index = if_nametoindex(PyBytes_AS_STRING(oname));\n    Py_DECREF(oname);\n    if (index == 0) {\n        /* if_nametoindex() doesn't set errno */\n        PyErr_SetString(PyExc_OSError, \"no interface with this name\");\n        return NULL;\n    }\n\n    return PyLong_FromUnsignedLong(index);\n}\n\n\nstatic PyObject *\nsocket_if_indextoname(PyObject *self, PyObject *arg)\n{\n    unsigned long index_long = PyLong_AsUnsignedLong(arg);\n    if (index_long == (unsigned long) -1 && PyErr_Occurred()) {\n        return NULL;\n    }\n\n#ifdef MS_WINDOWS\n    NET_IFINDEX index = (NET_IFINDEX)index_long;\n#else\n    unsigned int index = (unsigned int)index_long;\n#endif\n\n    if ((unsigned long)index != index_long) {\n        PyErr_SetString(PyExc_OverflowError, \"index is too large\");\n        return NULL;\n    }\n\n    char name[IF_NAMESIZE + 1];\n    if (if_indextoname(index, name) == NULL) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        return NULL;\n    }\n\n    return PyUnicode_DecodeFSDefault(name);\n}\n\nPyDoc_STRVAR(if_indextoname_doc,\n\"if_indextoname(if_index)\\n\\\n\\n\\\nReturns the interface name corresponding to the interface index if_index.\");\n\n#endif // defined(HAVE_IF_NAMEINDEX) || defined(MS_WINDOWS)\n\n\n#ifdef CMSG_LEN\n/* Python interface to CMSG_LEN(length). */\n\nstatic PyObject *\nsocket_CMSG_LEN(PyObject *self, PyObject *args)\n{\n    Py_ssize_t length;\n    size_t result;\n\n    if (!PyArg_ParseTuple(args, \"n:CMSG_LEN\", &length))\n        return NULL;\n    if (length < 0 || !get_CMSG_LEN(length, &result)) {\n        PyErr_Format(PyExc_OverflowError, \"CMSG_LEN() argument out of range\");\n        return NULL;\n    }\n    return PyLong_FromSize_t(result);\n}\n\nPyDoc_STRVAR(CMSG_LEN_doc,\n\"CMSG_LEN(length) -> control message length\\n\\\n\\n\\\nReturn the total length, without trailing padding, of an ancillary\\n\\\ndata item with associated data of the given length.  This value can\\n\\\noften be used as the buffer size for recvmsg() to receive a single\\n\\\nitem of ancillary data, but RFC 3542 requires portable applications to\\n\\\nuse CMSG_SPACE() and thus include space for padding, even when the\\n\\\nitem will be the last in the buffer.  Raises OverflowError if length\\n\\\nis outside the permissible range of values.\");\n\n\n#ifdef CMSG_SPACE\n/* Python interface to CMSG_SPACE(length). */\n\nstatic PyObject *\nsocket_CMSG_SPACE(PyObject *self, PyObject *args)\n{\n    Py_ssize_t length;\n    size_t result;\n\n    if (!PyArg_ParseTuple(args, \"n:CMSG_SPACE\", &length))\n        return NULL;\n    if (length < 0 || !get_CMSG_SPACE(length, &result)) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"CMSG_SPACE() argument out of range\");\n        return NULL;\n    }\n    return PyLong_FromSize_t(result);\n}\n\nPyDoc_STRVAR(CMSG_SPACE_doc,\n\"CMSG_SPACE(length) -> buffer size\\n\\\n\\n\\\nReturn the buffer size needed for recvmsg() to receive an ancillary\\n\\\ndata item with associated data of the given length, along with any\\n\\\ntrailing padding.  The buffer space needed to receive multiple items\\n\\\nis the sum of the CMSG_SPACE() values for their associated data\\n\\\nlengths.  Raises OverflowError if length is outside the permissible\\n\\\nrange of values.\");\n#endif    /* CMSG_SPACE */\n#endif    /* CMSG_LEN */\n\n\n/* List of functions exported by this module. */\n\nstatic PyMethodDef socket_methods[] = {\n#ifdef HAVE_GETADDRINFO\n    {\"gethostbyname\",           socket_gethostbyname,\n     METH_VARARGS, gethostbyname_doc},\n#endif\n#if defined(HAVE_GETHOSTBYNAME_R) || defined (HAVE_GETHOSTBYNAME)\n    {\"gethostbyname_ex\",        socket_gethostbyname_ex,\n     METH_VARARGS, ghbn_ex_doc},\n#endif\n#if defined(HAVE_GETHOSTBYNAME_R) || defined (HAVE_GETHOSTBYADDR)\n    {\"gethostbyaddr\",           socket_gethostbyaddr,\n     METH_VARARGS, gethostbyaddr_doc},\n#endif\n#ifdef HAVE_GETHOSTNAME\n    {\"gethostname\",             socket_gethostname,\n     METH_NOARGS,  gethostname_doc},\n#endif\n#ifdef HAVE_SETHOSTNAME\n    {\"sethostname\",             socket_sethostname,\n     METH_VARARGS,  sethostname_doc},\n#endif\n#ifdef HAVE_GETSERVBYNAME\n    {\"getservbyname\",           socket_getservbyname,\n     METH_VARARGS, getservbyname_doc},\n#endif\n#ifdef HAVE_GETSERVBYPORT\n    {\"getservbyport\",           socket_getservbyport,\n     METH_VARARGS, getservbyport_doc},\n#endif\n#ifdef HAVE_GETPROTOBYNAME\n    {\"getprotobyname\",          socket_getprotobyname,\n     METH_VARARGS, getprotobyname_doc},\n#endif\n    {\"close\",                   socket_close,\n     METH_O, close_doc},\n#ifndef NO_DUP\n    {\"dup\",                     socket_dup,\n     METH_O, dup_doc},\n#endif\n#ifdef HAVE_SOCKETPAIR\n    {\"socketpair\",              socket_socketpair,\n     METH_VARARGS, socketpair_doc},\n#endif\n    _SOCKET_SOCKET_NTOHS_METHODDEF\n    {\"ntohl\",                   socket_ntohl,\n     METH_O, ntohl_doc},\n    _SOCKET_SOCKET_HTONS_METHODDEF\n    {\"htonl\",                   socket_htonl,\n     METH_O, htonl_doc},\n    _SOCKET_SOCKET_INET_ATON_METHODDEF\n#ifdef HAVE_INET_NTOA\n    _SOCKET_SOCKET_INET_NTOA_METHODDEF\n#endif\n#ifdef HAVE_INET_PTON\n    {\"inet_pton\",               socket_inet_pton,\n     METH_VARARGS, inet_pton_doc},\n    {\"inet_ntop\",               socket_inet_ntop,\n     METH_VARARGS, inet_ntop_doc},\n#endif\n#ifdef HAVE_GETADDRINFO\n    {\"getaddrinfo\",             _PyCFunction_CAST(socket_getaddrinfo),\n     METH_VARARGS | METH_KEYWORDS, getaddrinfo_doc},\n#endif\n#ifdef HAVE_GETNAMEINFO\n    {\"getnameinfo\",             socket_getnameinfo,\n     METH_VARARGS, getnameinfo_doc},\n#endif\n    {\"getdefaulttimeout\",       socket_getdefaulttimeout,\n     METH_NOARGS, getdefaulttimeout_doc},\n    {\"setdefaulttimeout\",       socket_setdefaulttimeout,\n     METH_O, setdefaulttimeout_doc},\n#if defined(HAVE_IF_NAMEINDEX) || defined(MS_WINDOWS)\n    {\"if_nameindex\", socket_if_nameindex,\n     METH_NOARGS, if_nameindex_doc},\n    _SOCKET_SOCKET_IF_NAMETOINDEX_METHODDEF\n    {\"if_indextoname\", socket_if_indextoname,\n     METH_O, if_indextoname_doc},\n#endif\n#ifdef CMSG_LEN\n    {\"CMSG_LEN\",                socket_CMSG_LEN,\n     METH_VARARGS, CMSG_LEN_doc},\n#ifdef CMSG_SPACE\n    {\"CMSG_SPACE\",              socket_CMSG_SPACE,\n     METH_VARARGS, CMSG_SPACE_doc},\n#endif\n#endif\n    {NULL,                      NULL}            /* Sentinel */\n};\n\n\n#ifdef MS_WINDOWS\n#define OS_INIT_DEFINED\n\n/* Additional initialization and cleanup for Windows */\n\nstatic void\nos_cleanup(void)\n{\n    WSACleanup();\n}\n\nstatic int\nos_init(void)\n{\n    WSADATA WSAData;\n    int ret;\n    ret = WSAStartup(0x0101, &WSAData);\n    switch (ret) {\n    case 0:     /* No error */\n        Py_AtExit(os_cleanup);\n        return 1; /* Success */\n    case WSASYSNOTREADY:\n        PyErr_SetString(PyExc_ImportError,\n                        \"WSAStartup failed: network not ready\");\n        break;\n    case WSAVERNOTSUPPORTED:\n    case WSAEINVAL:\n        PyErr_SetString(\n            PyExc_ImportError,\n            \"WSAStartup failed: requested version not supported\");\n        break;\n    default:\n        PyErr_Format(PyExc_ImportError, \"WSAStartup failed: error code %d\", ret);\n        break;\n    }\n    return 0; /* Failure */\n}\n\n#endif /* MS_WINDOWS */\n\n\n\n#ifndef OS_INIT_DEFINED\nstatic int\nos_init(void)\n{\n    return 1; /* Success */\n}\n#endif\n\nstatic int\nsock_capi_traverse(PyObject *capsule, visitproc visit, void *arg)\n{\n    PySocketModule_APIObject *capi = PyCapsule_GetPointer(capsule, PySocket_CAPSULE_NAME);\n    assert(capi != NULL);\n    Py_VISIT(capi->Sock_Type);\n    return 0;\n}\n\nstatic int\nsock_capi_clear(PyObject *capsule)\n{\n    PySocketModule_APIObject *capi = PyCapsule_GetPointer(capsule, PySocket_CAPSULE_NAME);\n    assert(capi != NULL);\n    Py_CLEAR(capi->Sock_Type);\n    return 0;\n}\n\nstatic void\nsock_capi_free(PySocketModule_APIObject *capi)\n{\n    Py_XDECREF(capi->Sock_Type);  // sock_capi_free() can clear it\n    Py_DECREF(capi->error);\n    Py_DECREF(capi->timeout_error);\n    PyMem_Free(capi);\n}\n\nstatic void\nsock_capi_destroy(PyObject *capsule)\n{\n    void *capi = PyCapsule_GetPointer(capsule, PySocket_CAPSULE_NAME);\n    assert(capi != NULL);\n    sock_capi_free(capi);\n}\n\nstatic PySocketModule_APIObject *\nsock_get_api(socket_state *state)\n{\n    PySocketModule_APIObject *capi = PyMem_Malloc(sizeof(PySocketModule_APIObject));\n    if (capi == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    capi->Sock_Type = (PyTypeObject *)Py_NewRef(state->sock_type);\n    capi->error = Py_NewRef(PyExc_OSError);\n    capi->timeout_error = Py_NewRef(PyExc_TimeoutError);\n    return capi;\n}\n\n\n/* Initialize the _socket module.\n\n   This module is actually called \"_socket\", and there's a wrapper\n   \"socket.py\" which implements some additional functionality.\n   The import of \"_socket\" may fail with an ImportError exception if\n   os-specific initialization fails.  On Windows, this does WINSOCK\n   initialization.  When WINSOCK is initialized successfully, a call to\n   WSACleanup() is scheduled to be made at exit time.\n*/\n\nPyDoc_STRVAR(socket_doc,\n\"Implementation module for socket operations.\\n\\\n\\n\\\nSee the socket module for documentation.\");\n\nstatic int\nsocket_exec(PyObject *m)\n{\n    if (!os_init()) {\n        goto error;\n    }\n\n    socket_state *state = get_module_state(m);\n    state->defaulttimeout = _PYTIME_FROMSECONDS(-1);\n\n#if defined(HAVE_ACCEPT) || defined(HAVE_ACCEPT4)\n#if defined(HAVE_ACCEPT4) && defined(SOCK_CLOEXEC)\n    state->accept4_works = -1;\n#endif\n#endif\n\n#ifdef SOCK_CLOEXEC\n    state->sock_cloexec_works = -1;\n#endif\n\n#define ADD_EXC(MOD, NAME, VAR, BASE) do {                  \\\n    VAR = PyErr_NewException(\"socket.\" NAME, BASE, NULL);   \\\n    if (VAR == NULL) {                                      \\\n        goto error;                                         \\\n    }                                                       \\\n    if (PyModule_AddObjectRef(MOD, NAME, VAR) < 0) {        \\\n        goto error;                                         \\\n    }                                                       \\\n} while (0)\n\n    ADD_EXC(m, \"herror\", state->socket_herror, PyExc_OSError);\n    ADD_EXC(m, \"gaierror\", state->socket_gaierror, PyExc_OSError);\n\n#undef ADD_EXC\n\n    if (PyModule_AddObjectRef(m, \"error\", PyExc_OSError) < 0) {\n        goto error;\n    }\n    if (PyModule_AddObjectRef(m, \"timeout\", PyExc_TimeoutError) < 0) {\n        goto error;\n    }\n\n    PyObject *sock_type = PyType_FromMetaclass(NULL, m, &sock_spec, NULL);\n    if (sock_type == NULL) {\n        goto error;\n    }\n    state->sock_type = (PyTypeObject *)sock_type;\n    if (PyModule_AddObjectRef(m, \"SocketType\", sock_type) < 0) {\n        goto error;\n    }\n    if (PyModule_AddType(m, state->sock_type) < 0) {\n        goto error;\n    }\n\n    PyObject *has_ipv6;\n#ifdef ENABLE_IPV6\n    has_ipv6 = Py_True;\n#else\n    has_ipv6 = Py_False;\n#endif\n    if (PyModule_AddObjectRef(m, \"has_ipv6\", has_ipv6) < 0) {\n        goto error;\n    }\n\n    /* Export C API */\n    PySocketModule_APIObject *capi = sock_get_api(state);\n    if (capi == NULL) {\n        goto error;\n    }\n    PyObject *capsule = PyCapsule_New(capi,\n                                      PySocket_CAPSULE_NAME,\n                                      sock_capi_destroy);\n    if (capsule == NULL) {\n        sock_capi_free(capi);\n        goto error;\n    }\n    if (_PyCapsule_SetTraverse(capsule,\n                               sock_capi_traverse, sock_capi_clear) < 0) {\n        sock_capi_free(capi);\n        goto error;\n    }\n\n    if (PyModule_Add(m, PySocket_CAPI_NAME, capsule) < 0) {\n        goto error;\n    }\n\n#define ADD_INT_MACRO(MOD, INT) do {                    \\\n    if (PyModule_AddIntConstant(MOD, #INT, INT) < 0) {  \\\n        goto error;                                     \\\n    }                                                   \\\n} while (0)\n\n#define ADD_INT_CONST(MOD, NAME, INT) do {              \\\n    if (PyModule_AddIntConstant(MOD, NAME, INT) < 0) {  \\\n        goto error;                                     \\\n    }                                                   \\\n} while (0)\n\n#define ADD_STR_CONST(MOD, NAME, STR) do {                  \\\n    if (PyModule_AddStringConstant(MOD, NAME, STR) < 0) {   \\\n        goto error;                                         \\\n    }                                                       \\\n} while (0)\n\n    /* Address families (we only support AF_INET and AF_UNIX) */\n#ifdef AF_UNSPEC\n    ADD_INT_MACRO(m, AF_UNSPEC);\n#endif\n    ADD_INT_MACRO(m, AF_INET);\n#if defined(AF_UNIX)\n    ADD_INT_MACRO(m, AF_UNIX);\n#endif /* AF_UNIX */\n#ifdef AF_AX25\n    /* Amateur Radio AX.25 */\n    ADD_INT_MACRO(m, AF_AX25);\n#endif\n#ifdef AF_IPX\n    ADD_INT_MACRO(m, AF_IPX); /* Novell IPX */\n#endif\n#ifdef AF_APPLETALK\n    /* Appletalk DDP */\n    ADD_INT_MACRO(m, AF_APPLETALK);\n#endif\n#ifdef AF_NETROM\n    /* Amateur radio NetROM */\n    ADD_INT_MACRO(m, AF_NETROM);\n#endif\n#ifdef AF_BRIDGE\n    /* Multiprotocol bridge */\n    ADD_INT_MACRO(m, AF_BRIDGE);\n#endif\n#ifdef AF_ATMPVC\n    /* ATM PVCs */\n    ADD_INT_MACRO(m, AF_ATMPVC);\n#endif\n#ifdef AF_AAL5\n    /* Reserved for Werner's ATM */\n    ADD_INT_MACRO(m, AF_AAL5);\n#endif\n#ifdef HAVE_SOCKADDR_ALG\n    ADD_INT_MACRO(m, AF_ALG); /* Linux crypto */\n#endif\n#ifdef AF_X25\n    /* Reserved for X.25 project */\n    ADD_INT_MACRO(m, AF_X25);\n#endif\n#ifdef AF_INET6\n    ADD_INT_MACRO(m, AF_INET6); /* IP version 6 */\n#endif\n#ifdef AF_ROSE\n    /* Amateur Radio X.25 PLP */\n    ADD_INT_MACRO(m, AF_ROSE);\n#endif\n#ifdef AF_DECnet\n    /* Reserved for DECnet project */\n    ADD_INT_MACRO(m, AF_DECnet);\n#endif\n#ifdef AF_NETBEUI\n    /* Reserved for 802.2LLC project */\n    ADD_INT_MACRO(m, AF_NETBEUI);\n#endif\n#ifdef AF_SECURITY\n    /* Security callback pseudo AF */\n    ADD_INT_MACRO(m, AF_SECURITY);\n#endif\n#ifdef AF_KEY\n    /* PF_KEY key management API */\n    ADD_INT_MACRO(m, AF_KEY);\n#endif\n#ifdef AF_NETLINK\n    /*  */\n    ADD_INT_MACRO(m, AF_NETLINK);\n    ADD_INT_MACRO(m, NETLINK_ROUTE);\n#ifdef NETLINK_SKIP\n    ADD_INT_MACRO(m, NETLINK_SKIP);\n#endif\n#ifdef NETLINK_W1\n    ADD_INT_MACRO(m, NETLINK_W1);\n#endif\n    ADD_INT_MACRO(m, NETLINK_USERSOCK);\n    ADD_INT_MACRO(m, NETLINK_FIREWALL);\n#ifdef NETLINK_TCPDIAG\n    ADD_INT_MACRO(m, NETLINK_TCPDIAG);\n#endif\n#ifdef NETLINK_NFLOG\n    ADD_INT_MACRO(m, NETLINK_NFLOG);\n#endif\n#ifdef NETLINK_XFRM\n    ADD_INT_MACRO(m, NETLINK_XFRM);\n#endif\n#ifdef NETLINK_ARPD\n    ADD_INT_MACRO(m, NETLINK_ARPD);\n#endif\n#ifdef NETLINK_ROUTE6\n    ADD_INT_MACRO(m, NETLINK_ROUTE6);\n#endif\n    ADD_INT_MACRO(m, NETLINK_IP6_FW);\n#ifdef NETLINK_DNRTMSG\n    ADD_INT_MACRO(m, NETLINK_DNRTMSG);\n#endif\n#ifdef NETLINK_TAPBASE\n    ADD_INT_MACRO(m, NETLINK_TAPBASE);\n#endif\n#ifdef NETLINK_CRYPTO\n    ADD_INT_MACRO(m, NETLINK_CRYPTO);\n#endif\n#endif /* AF_NETLINK */\n\n#ifdef AF_QIPCRTR\n    /* Qualcomm IPCROUTER */\n    ADD_INT_MACRO(m, AF_QIPCRTR);\n#endif\n\n#ifdef AF_VSOCK\n    ADD_INT_CONST(m, \"AF_VSOCK\", AF_VSOCK);\n    ADD_INT_CONST(m, \"SO_VM_SOCKETS_BUFFER_SIZE\", 0);\n    ADD_INT_CONST(m, \"SO_VM_SOCKETS_BUFFER_MIN_SIZE\", 1);\n    ADD_INT_CONST(m, \"SO_VM_SOCKETS_BUFFER_MAX_SIZE\", 2);\n    ADD_INT_CONST(m, \"VMADDR_CID_ANY\", 0xffffffff);\n    ADD_INT_CONST(m, \"VMADDR_PORT_ANY\", 0xffffffff);\n    ADD_INT_CONST(m, \"VMADDR_CID_HOST\", 2);\n    ADD_INT_CONST(m, \"VM_SOCKETS_INVALID_VERSION\", 0xffffffff);\n    ADD_INT_CONST(m, \"IOCTL_VM_SOCKETS_GET_LOCAL_CID\",  _IO(7, 0xb9));\n#endif\n\n#ifdef AF_ROUTE\n    /* Alias to emulate 4.4BSD */\n    ADD_INT_MACRO(m, AF_ROUTE);\n#endif\n#ifdef AF_LINK\n    ADD_INT_MACRO(m, AF_LINK);\n#endif\n#ifdef AF_ASH\n    /* Ash */\n    ADD_INT_MACRO(m, AF_ASH);\n#endif\n#ifdef AF_ECONET\n    /* Acorn Econet */\n    ADD_INT_MACRO(m, AF_ECONET);\n#endif\n#ifdef AF_ATMSVC\n    /* ATM SVCs */\n    ADD_INT_MACRO(m, AF_ATMSVC);\n#endif\n#ifdef AF_SNA\n    /* Linux SNA Project (nutters!) */\n    ADD_INT_MACRO(m, AF_SNA);\n#endif\n#ifdef AF_IRDA\n    /* IRDA sockets */\n    ADD_INT_MACRO(m, AF_IRDA);\n#endif\n#ifdef AF_PPPOX\n    /* PPPoX sockets */\n    ADD_INT_MACRO(m, AF_PPPOX);\n#endif\n#ifdef AF_WANPIPE\n    /* Wanpipe API Sockets */\n    ADD_INT_MACRO(m, AF_WANPIPE);\n#endif\n#ifdef AF_LLC\n    /* Linux LLC */\n    ADD_INT_MACRO(m, AF_LLC);\n#endif\n#ifdef HAVE_AF_HYPERV\n    /* Hyper-V sockets */\n    ADD_INT_MACRO(m, AF_HYPERV);\n\n    /* for proto */\n    ADD_INT_MACRO(m, HV_PROTOCOL_RAW);\n\n    /* for setsockopt() */\n    ADD_INT_MACRO(m, HVSOCKET_CONNECT_TIMEOUT);\n    ADD_INT_MACRO(m, HVSOCKET_CONNECT_TIMEOUT_MAX);\n    ADD_INT_MACRO(m, HVSOCKET_CONNECTED_SUSPEND);\n    ADD_INT_MACRO(m, HVSOCKET_ADDRESS_FLAG_PASSTHRU);\n\n    /* for bind() or connect() */\n    ADD_STR_CONST(m, \"HV_GUID_ZERO\", \"00000000-0000-0000-0000-000000000000\");\n    ADD_STR_CONST(m, \"HV_GUID_WILDCARD\", \"00000000-0000-0000-0000-000000000000\");\n    ADD_STR_CONST(m, \"HV_GUID_BROADCAST\", \"FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF\");\n    ADD_STR_CONST(m, \"HV_GUID_CHILDREN\", \"90DB8B89-0D35-4F79-8CE9-49EA0AC8B7CD\");\n    ADD_STR_CONST(m, \"HV_GUID_LOOPBACK\", \"E0E16197-DD56-4A10-9195-5EE7A155A838\");\n    ADD_STR_CONST(m, \"HV_GUID_PARENT\", \"A42E7CDA-D03F-480C-9CC2-A4DE20ABB878\");\n#endif /* HAVE_AF_HYPERV */\n\n#ifdef USE_BLUETOOTH\n    ADD_INT_MACRO(m, AF_BLUETOOTH);\n#ifdef BTPROTO_L2CAP\n    ADD_INT_MACRO(m, BTPROTO_L2CAP);\n#endif /* BTPROTO_L2CAP */\n#ifdef BTPROTO_HCI\n    ADD_INT_MACRO(m, BTPROTO_HCI);\n    ADD_INT_MACRO(m, SOL_HCI);\n#if !defined(__NetBSD__) && !defined(__DragonFly__)\n    ADD_INT_MACRO(m, HCI_FILTER);\n#if !defined(__FreeBSD__)\n    ADD_INT_MACRO(m, HCI_TIME_STAMP);\n    ADD_INT_MACRO(m, HCI_DATA_DIR);\n#endif /* !__FreeBSD__ */\n#endif /* !__NetBSD__ && !__DragonFly__ */\n#endif /* BTPROTO_HCI */\n#ifdef BTPROTO_RFCOMM\n    ADD_INT_MACRO(m, BTPROTO_RFCOMM);\n#endif /* BTPROTO_RFCOMM */\n    ADD_STR_CONST(m, \"BDADDR_ANY\", \"00:00:00:00:00:00\");\n    ADD_STR_CONST(m, \"BDADDR_LOCAL\", \"00:00:00:FF:FF:FF\");\n#ifdef BTPROTO_SCO\n    ADD_INT_MACRO(m, BTPROTO_SCO);\n#endif /* BTPROTO_SCO */\n#endif /* USE_BLUETOOTH */\n\n#ifdef AF_CAN\n    /* Controller Area Network */\n    ADD_INT_MACRO(m, AF_CAN);\n#endif\n#ifdef PF_CAN\n    /* Controller Area Network */\n    ADD_INT_MACRO(m, PF_CAN);\n#endif\n\n/* Reliable Datagram Sockets */\n#ifdef AF_RDS\n    ADD_INT_MACRO(m, AF_RDS);\n#endif\n#ifdef PF_RDS\n    ADD_INT_MACRO(m, PF_RDS);\n#endif\n\n/* Kernel event messages */\n#ifdef PF_SYSTEM\n    ADD_INT_MACRO(m, PF_SYSTEM);\n#endif\n#ifdef AF_SYSTEM\n    ADD_INT_MACRO(m, AF_SYSTEM);\n#endif\n\n/* FreeBSD divert(4) */\n#ifdef PF_DIVERT\n    ADD_INT_MACRO(m, PF_DIVERT);\n#endif\n#ifdef AF_DIVERT\n    ADD_INT_MACRO(m, AF_DIVERT);\n#endif\n\n#ifdef AF_PACKET\n    ADD_INT_MACRO(m, AF_PACKET);\n#endif\n#ifdef PF_PACKET\n    ADD_INT_MACRO(m, PF_PACKET);\n#endif\n#ifdef PACKET_HOST\n    ADD_INT_MACRO(m, PACKET_HOST);\n#endif\n#ifdef PACKET_BROADCAST\n    ADD_INT_MACRO(m, PACKET_BROADCAST);\n#endif\n#ifdef PACKET_MULTICAST\n    ADD_INT_MACRO(m, PACKET_MULTICAST);\n#endif\n#ifdef PACKET_OTHERHOST\n    ADD_INT_MACRO(m, PACKET_OTHERHOST);\n#endif\n#ifdef PACKET_OUTGOING\n    ADD_INT_MACRO(m, PACKET_OUTGOING);\n#endif\n#ifdef PACKET_LOOPBACK\n    ADD_INT_MACRO(m, PACKET_LOOPBACK);\n#endif\n#ifdef PACKET_FASTROUTE\n    ADD_INT_MACRO(m, PACKET_FASTROUTE);\n#endif\n\n#ifdef HAVE_LINUX_TIPC_H\n    ADD_INT_MACRO(m, AF_TIPC);\n\n    /* for addresses */\n    ADD_INT_MACRO(m, TIPC_ADDR_NAMESEQ);\n    ADD_INT_MACRO(m, TIPC_ADDR_NAME);\n    ADD_INT_MACRO(m, TIPC_ADDR_ID);\n\n    ADD_INT_MACRO(m, TIPC_ZONE_SCOPE);\n    ADD_INT_MACRO(m, TIPC_CLUSTER_SCOPE);\n    ADD_INT_MACRO(m, TIPC_NODE_SCOPE);\n\n    /* for setsockopt() */\n    ADD_INT_MACRO(m, SOL_TIPC);\n    ADD_INT_MACRO(m, TIPC_IMPORTANCE);\n    ADD_INT_MACRO(m, TIPC_SRC_DROPPABLE);\n    ADD_INT_MACRO(m, TIPC_DEST_DROPPABLE);\n    ADD_INT_MACRO(m, TIPC_CONN_TIMEOUT);\n\n    ADD_INT_MACRO(m, TIPC_LOW_IMPORTANCE);\n    ADD_INT_MACRO(m, TIPC_MEDIUM_IMPORTANCE);\n    ADD_INT_MACRO(m, TIPC_HIGH_IMPORTANCE);\n    ADD_INT_MACRO(m, TIPC_CRITICAL_IMPORTANCE);\n\n    /* for subscriptions */\n    ADD_INT_MACRO(m, TIPC_SUB_PORTS);\n    ADD_INT_MACRO(m, TIPC_SUB_SERVICE);\n#ifdef TIPC_SUB_CANCEL\n    /* doesn't seem to be available everywhere */\n    ADD_INT_MACRO(m, TIPC_SUB_CANCEL);\n#endif\n    ADD_INT_MACRO(m, TIPC_WAIT_FOREVER);\n    ADD_INT_MACRO(m, TIPC_PUBLISHED);\n    ADD_INT_MACRO(m, TIPC_WITHDRAWN);\n    ADD_INT_MACRO(m, TIPC_SUBSCR_TIMEOUT);\n    ADD_INT_MACRO(m, TIPC_CFG_SRV);\n    ADD_INT_MACRO(m, TIPC_TOP_SRV);\n#endif\n\n#ifdef HAVE_SOCKADDR_ALG\n    /* Socket options */\n    ADD_INT_MACRO(m, ALG_SET_KEY);\n    ADD_INT_MACRO(m, ALG_SET_IV);\n    ADD_INT_MACRO(m, ALG_SET_OP);\n    ADD_INT_MACRO(m, ALG_SET_AEAD_ASSOCLEN);\n    ADD_INT_MACRO(m, ALG_SET_AEAD_AUTHSIZE);\n    ADD_INT_MACRO(m, ALG_SET_PUBKEY);\n\n    /* Operations */\n    ADD_INT_MACRO(m, ALG_OP_DECRYPT);\n    ADD_INT_MACRO(m, ALG_OP_ENCRYPT);\n    ADD_INT_MACRO(m, ALG_OP_SIGN);\n    ADD_INT_MACRO(m, ALG_OP_VERIFY);\n#endif\n\n/* IEEE 802.3 protocol numbers required for a standard TCP/IP network stack */\n#ifdef ETHERTYPE_ARP\n    ADD_INT_MACRO(m, ETHERTYPE_ARP);\n#endif\n#ifdef ETHERTYPE_IP\n    ADD_INT_MACRO(m, ETHERTYPE_IP);\n#endif\n#ifdef ETHERTYPE_IPV6\n    ADD_INT_MACRO(m, ETHERTYPE_IPV6);\n#endif\n#ifdef ETHERTYPE_VLAN\n    ADD_INT_MACRO(m, ETHERTYPE_VLAN);\n#endif\n\n/* Linux pseudo-protocol for sniffing every packet */\n#ifdef ETH_P_ALL\n    ADD_INT_MACRO(m, ETH_P_ALL);\n#endif\n\n    /* Socket types */\n    ADD_INT_MACRO(m, SOCK_STREAM);\n    ADD_INT_MACRO(m, SOCK_DGRAM);\n/* We have incomplete socket support. */\n#ifdef SOCK_RAW\n    /* SOCK_RAW is marked as optional in the POSIX specification */\n    ADD_INT_MACRO(m, SOCK_RAW);\n#endif\n#ifdef SOCK_SEQPACKET\n    ADD_INT_MACRO(m, SOCK_SEQPACKET);\n#endif\n#if defined(SOCK_RDM)\n    ADD_INT_MACRO(m, SOCK_RDM);\n#endif\n#ifdef SOCK_CLOEXEC\n    ADD_INT_MACRO(m, SOCK_CLOEXEC);\n#endif\n#ifdef SOCK_NONBLOCK\n    ADD_INT_MACRO(m, SOCK_NONBLOCK);\n#endif\n\n#ifdef  SO_DEBUG\n    ADD_INT_MACRO(m, SO_DEBUG);\n#endif\n#ifdef  SO_ACCEPTCONN\n    ADD_INT_MACRO(m, SO_ACCEPTCONN);\n#endif\n#ifdef  SO_REUSEADDR\n    ADD_INT_MACRO(m, SO_REUSEADDR);\n#endif\n#ifdef SO_EXCLUSIVEADDRUSE\n    ADD_INT_MACRO(m, SO_EXCLUSIVEADDRUSE);\n#endif\n#ifdef SO_INCOMING_CPU\n    ADD_INT_MACRO(m, SO_INCOMING_CPU);\n#endif\n\n#ifdef  SO_KEEPALIVE\n    ADD_INT_MACRO(m, SO_KEEPALIVE);\n#endif\n#ifdef  SO_DONTROUTE\n    ADD_INT_MACRO(m, SO_DONTROUTE);\n#endif\n#ifdef  SO_BROADCAST\n    ADD_INT_MACRO(m, SO_BROADCAST);\n#endif\n#ifdef  SO_USELOOPBACK\n    ADD_INT_MACRO(m, SO_USELOOPBACK);\n#endif\n#ifdef  SO_LINGER\n    ADD_INT_MACRO(m, SO_LINGER);\n#endif\n#ifdef  SO_OOBINLINE\n    ADD_INT_MACRO(m, SO_OOBINLINE);\n#endif\n#ifndef __GNU__\n#ifdef  SO_REUSEPORT\n    ADD_INT_MACRO(m, SO_REUSEPORT);\n#endif\n#endif\n#ifdef  SO_SNDBUF\n    ADD_INT_MACRO(m, SO_SNDBUF);\n#endif\n#ifdef  SO_RCVBUF\n    ADD_INT_MACRO(m, SO_RCVBUF);\n#endif\n#ifdef  SO_SNDLOWAT\n    ADD_INT_MACRO(m, SO_SNDLOWAT);\n#endif\n#ifdef  SO_RCVLOWAT\n    ADD_INT_MACRO(m, SO_RCVLOWAT);\n#endif\n#ifdef  SO_SNDTIMEO\n    ADD_INT_MACRO(m, SO_SNDTIMEO);\n#endif\n#ifdef  SO_RCVTIMEO\n    ADD_INT_MACRO(m, SO_RCVTIMEO);\n#endif\n#ifdef  SO_ERROR\n    ADD_INT_MACRO(m, SO_ERROR);\n#endif\n#ifdef  SO_TYPE\n    ADD_INT_MACRO(m, SO_TYPE);\n#endif\n#ifdef  SO_SETFIB\n    ADD_INT_MACRO(m, SO_SETFIB);\n#endif\n#ifdef  SO_PASSCRED\n    ADD_INT_MACRO(m, SO_PASSCRED);\n#endif\n#ifdef  SO_PEERCRED\n    ADD_INT_MACRO(m, SO_PEERCRED);\n#endif\n#ifdef  LOCAL_PEERCRED\n    ADD_INT_MACRO(m, LOCAL_PEERCRED);\n#endif\n#ifdef  SO_PASSSEC\n    ADD_INT_MACRO(m, SO_PASSSEC);\n#endif\n#ifdef  SO_PEERSEC\n    ADD_INT_MACRO(m, SO_PEERSEC);\n#endif\n#ifdef  SO_BINDTODEVICE\n    ADD_INT_MACRO(m, SO_BINDTODEVICE);\n#endif\n#ifdef  SO_BINDTOIFINDEX\n    ADD_INT_MACRO(m, SO_BINDTOIFINDEX);\n#endif\n#ifdef  SO_PRIORITY\n    ADD_INT_MACRO(m, SO_PRIORITY);\n#endif\n#ifdef  SO_MARK\n    ADD_INT_MACRO(m, SO_MARK);\n#endif\n#ifdef  SO_USER_COOKIE\n    ADD_INT_MACRO(m, SO_USER_COOKIE);\n#endif\n#ifdef  SO_RTABLE\n    ADD_INT_MACRO(m, SO_RTABLE);\n#endif\n#ifdef SO_DOMAIN\n    ADD_INT_MACRO(m, SO_DOMAIN);\n#endif\n#ifdef SO_PROTOCOL\n    ADD_INT_MACRO(m, SO_PROTOCOL);\n#endif\n#ifdef LOCAL_CREDS\n    ADD_INT_MACRO(m, LOCAL_CREDS);\n#endif\n#ifdef LOCAL_CREDS_PERSISTENT\n    ADD_INT_MACRO(m, LOCAL_CREDS_PERSISTENT);\n#endif\n\n    /* Maximum number of connections for \"listen\" */\n#ifdef  SOMAXCONN\n    ADD_INT_MACRO(m, SOMAXCONN);\n#else\n    ADD_INT_CONST(m, \"SOMAXCONN\", 5); /* Common value */\n#endif\n\n    /* Ancillary message types */\n#ifdef  SCM_RIGHTS\n    ADD_INT_MACRO(m, SCM_RIGHTS);\n#endif\n#ifdef  SCM_CREDENTIALS\n    ADD_INT_MACRO(m, SCM_CREDENTIALS);\n#endif\n#ifdef  SCM_CREDS\n    ADD_INT_MACRO(m, SCM_CREDS);\n#endif\n#ifdef  SCM_CREDS2\n    ADD_INT_MACRO(m, SCM_CREDS2);\n#endif\n\n    /* Flags for send, recv */\n#ifdef  MSG_OOB\n    ADD_INT_MACRO(m, MSG_OOB);\n#endif\n#ifdef  MSG_PEEK\n    ADD_INT_MACRO(m, MSG_PEEK);\n#endif\n#ifdef  MSG_DONTROUTE\n    ADD_INT_MACRO(m, MSG_DONTROUTE);\n#endif\n#ifdef  MSG_DONTWAIT\n    ADD_INT_MACRO(m, MSG_DONTWAIT);\n#endif\n#ifdef  MSG_EOR\n    ADD_INT_MACRO(m, MSG_EOR);\n#endif\n#ifdef  MSG_TRUNC\n    // workaround for https://github.com/WebAssembly/wasi-libc/issues/305\n    #if defined(__wasi__) && !defined(__WASI_RIFLAGS_RECV_DATA_TRUNCATED)\n    #  define __WASI_RIFLAGS_RECV_DATA_TRUNCATED 2\n    #endif\n    ADD_INT_MACRO(m, MSG_TRUNC);\n#endif\n#ifdef  MSG_CTRUNC\n    ADD_INT_MACRO(m, MSG_CTRUNC);\n#endif\n#ifdef  MSG_WAITALL\n    ADD_INT_MACRO(m, MSG_WAITALL);\n#endif\n#ifdef  MSG_BTAG\n    ADD_INT_MACRO(m, MSG_BTAG);\n#endif\n#ifdef  MSG_ETAG\n    ADD_INT_MACRO(m, MSG_ETAG);\n#endif\n#ifdef  MSG_NOSIGNAL\n    ADD_INT_MACRO(m, MSG_NOSIGNAL);\n#endif\n#ifdef  MSG_NOTIFICATION\n    ADD_INT_MACRO(m, MSG_NOTIFICATION);\n#endif\n#ifdef  MSG_CMSG_CLOEXEC\n    ADD_INT_MACRO(m, MSG_CMSG_CLOEXEC);\n#endif\n#ifdef  MSG_ERRQUEUE\n    ADD_INT_MACRO(m, MSG_ERRQUEUE);\n#endif\n#ifdef  MSG_CONFIRM\n    ADD_INT_MACRO(m, MSG_CONFIRM);\n#endif\n#ifdef  MSG_MORE\n    ADD_INT_MACRO(m, MSG_MORE);\n#endif\n#ifdef  MSG_EOF\n    ADD_INT_MACRO(m, MSG_EOF);\n#endif\n#ifdef  MSG_BCAST\n    ADD_INT_MACRO(m, MSG_BCAST);\n#endif\n#ifdef  MSG_MCAST\n    ADD_INT_MACRO(m, MSG_MCAST);\n#endif\n#ifdef MSG_FASTOPEN\n    ADD_INT_MACRO(m, MSG_FASTOPEN);\n#endif\n\n    /* Protocol level and numbers, usable for [gs]etsockopt */\n#ifdef  SOL_SOCKET\n    ADD_INT_MACRO(m, SOL_SOCKET);\n#endif\n#ifdef  SOL_IP\n    ADD_INT_MACRO(m, SOL_IP);\n#else\n    ADD_INT_CONST(m, \"SOL_IP\", 0);\n#endif\n#ifdef  SOL_IPX\n    ADD_INT_MACRO(m, SOL_IPX);\n#endif\n#ifdef  SOL_AX25\n    ADD_INT_MACRO(m, SOL_AX25);\n#endif\n#ifdef  SOL_ATALK\n    ADD_INT_MACRO(m, SOL_ATALK);\n#endif\n#ifdef  SOL_NETROM\n    ADD_INT_MACRO(m, SOL_NETROM);\n#endif\n#ifdef  SOL_ROSE\n    ADD_INT_MACRO(m, SOL_ROSE);\n#endif\n#ifdef  SOL_TCP\n    ADD_INT_MACRO(m, SOL_TCP);\n#else\n    ADD_INT_CONST(m, \"SOL_TCP\", 6);\n#endif\n#ifdef  SOL_UDP\n    ADD_INT_MACRO(m, SOL_UDP);\n#else\n    ADD_INT_CONST(m, \"SOL_UDP\", 17);\n#endif\n#ifdef SOL_CAN_BASE\n    ADD_INT_MACRO(m, SOL_CAN_BASE);\n#endif\n#ifdef SOL_CAN_RAW\n    ADD_INT_MACRO(m, SOL_CAN_RAW);\n    ADD_INT_MACRO(m, CAN_RAW);\n#endif\n#if defined(HAVE_LINUX_CAN_H) || defined(HAVE_NETCAN_CAN_H)\n    ADD_INT_MACRO(m, CAN_EFF_FLAG);\n    ADD_INT_MACRO(m, CAN_RTR_FLAG);\n    ADD_INT_MACRO(m, CAN_ERR_FLAG);\n\n    ADD_INT_MACRO(m, CAN_SFF_MASK);\n    ADD_INT_MACRO(m, CAN_EFF_MASK);\n    ADD_INT_MACRO(m, CAN_ERR_MASK);\n#ifdef CAN_ISOTP\n    ADD_INT_MACRO(m, CAN_ISOTP);\n#endif\n#ifdef CAN_J1939\n    ADD_INT_MACRO(m, CAN_J1939);\n#endif\n#endif\n#if defined(HAVE_LINUX_CAN_RAW_H) || defined(HAVE_NETCAN_CAN_H)\n    ADD_INT_MACRO(m, CAN_RAW_FILTER);\n#ifdef CAN_RAW_ERR_FILTER\n    ADD_INT_MACRO(m, CAN_RAW_ERR_FILTER);\n#endif\n    ADD_INT_MACRO(m, CAN_RAW_LOOPBACK);\n    ADD_INT_MACRO(m, CAN_RAW_RECV_OWN_MSGS);\n#endif\n#ifdef HAVE_LINUX_CAN_RAW_FD_FRAMES\n    ADD_INT_MACRO(m, CAN_RAW_FD_FRAMES);\n#endif\n#ifdef HAVE_LINUX_CAN_RAW_JOIN_FILTERS\n    ADD_INT_MACRO(m, CAN_RAW_JOIN_FILTERS);\n#endif\n#ifdef HAVE_LINUX_CAN_BCM_H\n    ADD_INT_MACRO(m, CAN_BCM);\n\n    /* BCM opcodes */\n    ADD_INT_CONST(m, \"CAN_BCM_TX_SETUP\", TX_SETUP);\n    ADD_INT_CONST(m, \"CAN_BCM_TX_DELETE\", TX_DELETE);\n    ADD_INT_CONST(m, \"CAN_BCM_TX_READ\", TX_READ);\n    ADD_INT_CONST(m, \"CAN_BCM_TX_SEND\", TX_SEND);\n    ADD_INT_CONST(m, \"CAN_BCM_RX_SETUP\", RX_SETUP);\n    ADD_INT_CONST(m, \"CAN_BCM_RX_DELETE\", RX_DELETE);\n    ADD_INT_CONST(m, \"CAN_BCM_RX_READ\", RX_READ);\n    ADD_INT_CONST(m, \"CAN_BCM_TX_STATUS\", TX_STATUS);\n    ADD_INT_CONST(m, \"CAN_BCM_TX_EXPIRED\", TX_EXPIRED);\n    ADD_INT_CONST(m, \"CAN_BCM_RX_STATUS\", RX_STATUS);\n    ADD_INT_CONST(m, \"CAN_BCM_RX_TIMEOUT\", RX_TIMEOUT);\n    ADD_INT_CONST(m, \"CAN_BCM_RX_CHANGED\", RX_CHANGED);\n\n    /* BCM flags */\n    ADD_INT_CONST(m, \"CAN_BCM_SETTIMER\", SETTIMER);\n    ADD_INT_CONST(m, \"CAN_BCM_STARTTIMER\", STARTTIMER);\n    ADD_INT_CONST(m, \"CAN_BCM_TX_COUNTEVT\", TX_COUNTEVT);\n    ADD_INT_CONST(m, \"CAN_BCM_TX_ANNOUNCE\", TX_ANNOUNCE);\n    ADD_INT_CONST(m, \"CAN_BCM_TX_CP_CAN_ID\", TX_CP_CAN_ID);\n    ADD_INT_CONST(m, \"CAN_BCM_RX_FILTER_ID\", RX_FILTER_ID);\n    ADD_INT_CONST(m, \"CAN_BCM_RX_CHECK_DLC\", RX_CHECK_DLC);\n    ADD_INT_CONST(m, \"CAN_BCM_RX_NO_AUTOTIMER\", RX_NO_AUTOTIMER);\n    ADD_INT_CONST(m, \"CAN_BCM_RX_ANNOUNCE_RESUME\", RX_ANNOUNCE_RESUME);\n    ADD_INT_CONST(m, \"CAN_BCM_TX_RESET_MULTI_IDX\", TX_RESET_MULTI_IDX);\n    ADD_INT_CONST(m, \"CAN_BCM_RX_RTR_FRAME\", RX_RTR_FRAME);\n#ifdef CAN_FD_FRAME\n    /* CAN_FD_FRAME was only introduced in the 4.8.x kernel series */\n    ADD_INT_CONST(m, \"CAN_BCM_CAN_FD_FRAME\", CAN_FD_FRAME);\n#endif\n#endif\n#ifdef HAVE_LINUX_CAN_J1939_H\n    ADD_INT_MACRO(m, J1939_MAX_UNICAST_ADDR);\n    ADD_INT_MACRO(m, J1939_IDLE_ADDR);\n    ADD_INT_MACRO(m, J1939_NO_ADDR);\n    ADD_INT_MACRO(m, J1939_NO_NAME);\n    ADD_INT_MACRO(m, J1939_PGN_REQUEST);\n    ADD_INT_MACRO(m, J1939_PGN_ADDRESS_CLAIMED);\n    ADD_INT_MACRO(m, J1939_PGN_ADDRESS_COMMANDED);\n    ADD_INT_MACRO(m, J1939_PGN_PDU1_MAX);\n    ADD_INT_MACRO(m, J1939_PGN_MAX);\n    ADD_INT_MACRO(m, J1939_NO_PGN);\n\n    /* J1939 socket options */\n    ADD_INT_MACRO(m, SO_J1939_FILTER);\n    ADD_INT_MACRO(m, SO_J1939_PROMISC);\n    ADD_INT_MACRO(m, SO_J1939_SEND_PRIO);\n    ADD_INT_MACRO(m, SO_J1939_ERRQUEUE);\n\n    ADD_INT_MACRO(m, SCM_J1939_DEST_ADDR);\n    ADD_INT_MACRO(m, SCM_J1939_DEST_NAME);\n    ADD_INT_MACRO(m, SCM_J1939_PRIO);\n    ADD_INT_MACRO(m, SCM_J1939_ERRQUEUE);\n\n    ADD_INT_MACRO(m, J1939_NLA_PAD);\n    ADD_INT_MACRO(m, J1939_NLA_BYTES_ACKED);\n\n    ADD_INT_MACRO(m, J1939_EE_INFO_NONE);\n    ADD_INT_MACRO(m, J1939_EE_INFO_TX_ABORT);\n\n    ADD_INT_MACRO(m, J1939_FILTER_MAX);\n#endif\n#ifdef SOL_RDS\n    ADD_INT_MACRO(m, SOL_RDS);\n#endif\n#ifdef HAVE_SOCKADDR_ALG\n    ADD_INT_MACRO(m, SOL_ALG);\n#endif\n#ifdef RDS_CANCEL_SENT_TO\n    ADD_INT_MACRO(m, RDS_CANCEL_SENT_TO);\n#endif\n#ifdef RDS_GET_MR\n    ADD_INT_MACRO(m, RDS_GET_MR);\n#endif\n#ifdef RDS_FREE_MR\n    ADD_INT_MACRO(m, RDS_FREE_MR);\n#endif\n#ifdef RDS_RECVERR\n    ADD_INT_MACRO(m, RDS_RECVERR);\n#endif\n#ifdef RDS_CONG_MONITOR\n    ADD_INT_MACRO(m, RDS_CONG_MONITOR);\n#endif\n#ifdef RDS_GET_MR_FOR_DEST\n    ADD_INT_MACRO(m, RDS_GET_MR_FOR_DEST);\n#endif\n#ifdef  IPPROTO_IP\n    ADD_INT_MACRO(m, IPPROTO_IP);\n#else\n    ADD_INT_CONST(m, \"IPPROTO_IP\", 0);\n#endif\n#ifdef  IPPROTO_HOPOPTS\n    ADD_INT_MACRO(m, IPPROTO_HOPOPTS);\n#endif\n#ifdef  IPPROTO_ICMP\n    ADD_INT_MACRO(m, IPPROTO_ICMP);\n#else\n    ADD_INT_CONST(m, \"IPPROTO_ICMP\", 1);\n#endif\n#ifdef  IPPROTO_IGMP\n    ADD_INT_MACRO(m, IPPROTO_IGMP);\n#endif\n#ifdef  IPPROTO_GGP\n    ADD_INT_MACRO(m, IPPROTO_GGP);\n#endif\n#ifdef  IPPROTO_IPV4\n    ADD_INT_MACRO(m, IPPROTO_IPV4);\n#endif\n#ifdef  IPPROTO_IPV6\n    ADD_INT_MACRO(m, IPPROTO_IPV6);\n#endif\n#ifdef  IPPROTO_IPIP\n    ADD_INT_MACRO(m, IPPROTO_IPIP);\n#endif\n#ifdef  IPPROTO_TCP\n    ADD_INT_MACRO(m, IPPROTO_TCP);\n#else\n    ADD_INT_CONST(m, \"IPPROTO_TCP\", 6);\n#endif\n#ifdef  IPPROTO_EGP\n    ADD_INT_MACRO(m, IPPROTO_EGP);\n#endif\n#ifdef  IPPROTO_PUP\n    ADD_INT_MACRO(m, IPPROTO_PUP);\n#endif\n#ifdef  IPPROTO_UDP\n    ADD_INT_MACRO(m, IPPROTO_UDP);\n#else\n    ADD_INT_CONST(m, \"IPPROTO_UDP\", 17);\n#endif\n#ifdef  IPPROTO_UDPLITE\n    ADD_INT_MACRO(m, IPPROTO_UDPLITE);\n    #ifndef UDPLITE_SEND_CSCOV\n        #define UDPLITE_SEND_CSCOV 10\n    #endif\n    ADD_INT_MACRO(m, UDPLITE_SEND_CSCOV);\n    #ifndef UDPLITE_RECV_CSCOV\n        #define UDPLITE_RECV_CSCOV 11\n    #endif\n    ADD_INT_MACRO(m, UDPLITE_RECV_CSCOV);\n#endif\n#ifdef  IPPROTO_IDP\n    ADD_INT_MACRO(m, IPPROTO_IDP);\n#endif\n#ifdef  IPPROTO_HELLO\n    ADD_INT_MACRO(m, IPPROTO_HELLO);\n#endif\n#ifdef  IPPROTO_ND\n    ADD_INT_MACRO(m, IPPROTO_ND);\n#endif\n#ifdef  IPPROTO_TP\n    ADD_INT_MACRO(m, IPPROTO_TP);\n#endif\n#ifdef  IPPROTO_ROUTING\n    ADD_INT_MACRO(m, IPPROTO_ROUTING);\n#endif\n#ifdef  IPPROTO_FRAGMENT\n    ADD_INT_MACRO(m, IPPROTO_FRAGMENT);\n#endif\n#ifdef  IPPROTO_RSVP\n    ADD_INT_MACRO(m, IPPROTO_RSVP);\n#endif\n#ifdef  IPPROTO_GRE\n    ADD_INT_MACRO(m, IPPROTO_GRE);\n#endif\n#ifdef  IPPROTO_ESP\n    ADD_INT_MACRO(m, IPPROTO_ESP);\n#endif\n#ifdef  IPPROTO_AH\n    ADD_INT_MACRO(m, IPPROTO_AH);\n#endif\n#ifdef  IPPROTO_MOBILE\n    ADD_INT_MACRO(m, IPPROTO_MOBILE);\n#endif\n#ifdef  IPPROTO_ICMPV6\n    ADD_INT_MACRO(m, IPPROTO_ICMPV6);\n#endif\n#ifdef  IPPROTO_NONE\n    ADD_INT_MACRO(m, IPPROTO_NONE);\n#endif\n#ifdef  IPPROTO_DSTOPTS\n    ADD_INT_MACRO(m, IPPROTO_DSTOPTS);\n#endif\n#ifdef  IPPROTO_XTP\n    ADD_INT_MACRO(m, IPPROTO_XTP);\n#endif\n#ifdef  IPPROTO_EON\n    ADD_INT_MACRO(m, IPPROTO_EON);\n#endif\n#ifdef  IPPROTO_PIM\n    ADD_INT_MACRO(m, IPPROTO_PIM);\n#endif\n#ifdef  IPPROTO_IPCOMP\n    ADD_INT_MACRO(m, IPPROTO_IPCOMP);\n#endif\n#ifdef  IPPROTO_VRRP\n    ADD_INT_MACRO(m, IPPROTO_VRRP);\n#endif\n#ifdef  IPPROTO_SCTP\n    ADD_INT_MACRO(m, IPPROTO_SCTP);\n#endif\n#ifdef  IPPROTO_BIP\n    ADD_INT_MACRO(m, IPPROTO_BIP);\n#endif\n#ifdef  IPPROTO_MPTCP\n    ADD_INT_MACRO(m, IPPROTO_MPTCP);\n#endif\n/**/\n#ifdef  IPPROTO_RAW\n    ADD_INT_MACRO(m, IPPROTO_RAW);\n#else\n    ADD_INT_CONST(m, \"IPPROTO_RAW\", 255);\n#endif\n#ifdef  IPPROTO_MAX\n    ADD_INT_MACRO(m, IPPROTO_MAX);\n#endif\n\n#ifdef  MS_WINDOWS\n    ADD_INT_MACRO(m, IPPROTO_ICLFXBM);\n    ADD_INT_MACRO(m, IPPROTO_ST);\n    ADD_INT_MACRO(m, IPPROTO_CBT);\n    ADD_INT_MACRO(m, IPPROTO_IGP);\n    ADD_INT_MACRO(m, IPPROTO_RDP);\n    ADD_INT_MACRO(m, IPPROTO_PGM);\n    ADD_INT_MACRO(m, IPPROTO_L2TP);\n    ADD_INT_MACRO(m, IPPROTO_SCTP);\n#endif\n\n#ifdef  SYSPROTO_CONTROL\n    ADD_INT_MACRO(m, SYSPROTO_CONTROL);\n#endif\n\n    /* Some port configuration */\n#ifdef  IPPORT_RESERVED\n    ADD_INT_MACRO(m, IPPORT_RESERVED);\n#else\n    ADD_INT_CONST(m, \"IPPORT_RESERVED\", 1024);\n#endif\n#ifdef  IPPORT_USERRESERVED\n    ADD_INT_MACRO(m, IPPORT_USERRESERVED);\n#else\n    ADD_INT_CONST(m, \"IPPORT_USERRESERVED\", 5000);\n#endif\n\n    /* Some reserved IP v.4 addresses */\n#ifdef  INADDR_ANY\n    ADD_INT_MACRO(m, INADDR_ANY);\n#else\n    ADD_INT_CONST(m, \"INADDR_ANY\", 0x00000000);\n#endif\n#ifdef  INADDR_BROADCAST\n    ADD_INT_MACRO(m, INADDR_BROADCAST);\n#else\n    ADD_INT_CONST(m, \"INADDR_BROADCAST\", 0xffffffff);\n#endif\n#ifdef  INADDR_LOOPBACK\n    ADD_INT_MACRO(m, INADDR_LOOPBACK);\n#else\n    ADD_INT_CONST(m, \"INADDR_LOOPBACK\", 0x7F000001);\n#endif\n#ifdef  INADDR_UNSPEC_GROUP\n    ADD_INT_MACRO(m, INADDR_UNSPEC_GROUP);\n#else\n    ADD_INT_CONST(m, \"INADDR_UNSPEC_GROUP\", 0xe0000000);\n#endif\n#ifdef  INADDR_ALLHOSTS_GROUP\n    ADD_INT_CONST(m, \"INADDR_ALLHOSTS_GROUP\",\n                            INADDR_ALLHOSTS_GROUP);\n#else\n    ADD_INT_CONST(m, \"INADDR_ALLHOSTS_GROUP\", 0xe0000001);\n#endif\n#ifdef  INADDR_MAX_LOCAL_GROUP\n    ADD_INT_MACRO(m, INADDR_MAX_LOCAL_GROUP);\n#else\n    ADD_INT_CONST(m, \"INADDR_MAX_LOCAL_GROUP\", 0xe00000ff);\n#endif\n#ifdef  INADDR_NONE\n    ADD_INT_MACRO(m, INADDR_NONE);\n#else\n    ADD_INT_CONST(m, \"INADDR_NONE\", 0xffffffff);\n#endif\n\n    /* IPv4 [gs]etsockopt options */\n#ifdef  IP_OPTIONS\n    ADD_INT_MACRO(m, IP_OPTIONS);\n#endif\n#ifdef  IP_HDRINCL\n    ADD_INT_MACRO(m, IP_HDRINCL);\n#endif\n#ifdef  IP_TOS\n    ADD_INT_MACRO(m, IP_TOS);\n#endif\n#ifdef  IP_TTL\n    ADD_INT_MACRO(m, IP_TTL);\n#endif\n#ifdef  IP_RECVOPTS\n    ADD_INT_MACRO(m, IP_RECVOPTS);\n#endif\n#ifdef  IP_RECVRETOPTS\n    ADD_INT_MACRO(m, IP_RECVRETOPTS);\n#endif\n#ifdef  IP_RECVTOS\n    ADD_INT_MACRO(m, IP_RECVTOS);\n#endif\n#ifdef  IP_RECVDSTADDR\n    ADD_INT_MACRO(m, IP_RECVDSTADDR);\n#endif\n#ifdef  IP_RETOPTS\n    ADD_INT_MACRO(m, IP_RETOPTS);\n#endif\n#ifdef  IP_MULTICAST_IF\n    ADD_INT_MACRO(m, IP_MULTICAST_IF);\n#endif\n#ifdef  IP_MULTICAST_TTL\n    ADD_INT_MACRO(m, IP_MULTICAST_TTL);\n#endif\n#ifdef  IP_MULTICAST_LOOP\n    ADD_INT_MACRO(m, IP_MULTICAST_LOOP);\n#endif\n#ifdef  IP_ADD_MEMBERSHIP\n    ADD_INT_MACRO(m, IP_ADD_MEMBERSHIP);\n#endif\n#ifdef  IP_DROP_MEMBERSHIP\n    ADD_INT_MACRO(m, IP_DROP_MEMBERSHIP);\n#endif\n#ifdef  IP_DEFAULT_MULTICAST_TTL\n    ADD_INT_MACRO(m, IP_DEFAULT_MULTICAST_TTL);\n#endif\n#ifdef  IP_DEFAULT_MULTICAST_LOOP\n    ADD_INT_MACRO(m, IP_DEFAULT_MULTICAST_LOOP);\n#endif\n#ifdef  IP_MAX_MEMBERSHIPS\n    ADD_INT_MACRO(m, IP_MAX_MEMBERSHIPS);\n#endif\n#ifdef  IP_TRANSPARENT\n    ADD_INT_MACRO(m, IP_TRANSPARENT);\n#endif\n#ifdef  IP_PKTINFO\n    ADD_INT_MACRO(m, IP_PKTINFO);\n#endif\n#ifdef IP_BIND_ADDRESS_NO_PORT\n    ADD_INT_MACRO(m, IP_BIND_ADDRESS_NO_PORT);\n#endif\n#ifdef IP_UNBLOCK_SOURCE\n    ADD_INT_MACRO(m, IP_UNBLOCK_SOURCE);\n#endif\n#ifdef IP_BLOCK_SOURCE\n    ADD_INT_MACRO(m, IP_BLOCK_SOURCE);\n#endif\n#ifdef IP_ADD_SOURCE_MEMBERSHIP\n    ADD_INT_MACRO(m, IP_ADD_SOURCE_MEMBERSHIP);\n#endif\n#ifdef IP_DROP_SOURCE_MEMBERSHIP\n    ADD_INT_MACRO(m, IP_DROP_SOURCE_MEMBERSHIP);\n#endif\n\n    /* IPv6 [gs]etsockopt options, defined in RFC2553 */\n#ifdef  IPV6_JOIN_GROUP\n    ADD_INT_MACRO(m, IPV6_JOIN_GROUP);\n#endif\n#ifdef  IPV6_LEAVE_GROUP\n    ADD_INT_MACRO(m, IPV6_LEAVE_GROUP);\n#endif\n#ifdef  IPV6_MULTICAST_HOPS\n    ADD_INT_MACRO(m, IPV6_MULTICAST_HOPS);\n#endif\n#ifdef  IPV6_MULTICAST_IF\n    ADD_INT_MACRO(m, IPV6_MULTICAST_IF);\n#endif\n#ifdef  IPV6_MULTICAST_LOOP\n    ADD_INT_MACRO(m, IPV6_MULTICAST_LOOP);\n#endif\n#ifdef  IPV6_UNICAST_HOPS\n    ADD_INT_MACRO(m, IPV6_UNICAST_HOPS);\n#endif\n    /* Additional IPV6 socket options, defined in RFC 3493 */\n#ifdef IPV6_V6ONLY\n    ADD_INT_MACRO(m, IPV6_V6ONLY);\n#endif\n    /* Advanced IPV6 socket options, from RFC 3542 */\n#ifdef IPV6_CHECKSUM\n    ADD_INT_MACRO(m, IPV6_CHECKSUM);\n#endif\n#ifdef IPV6_DONTFRAG\n    ADD_INT_MACRO(m, IPV6_DONTFRAG);\n#endif\n#ifdef IPV6_DSTOPTS\n    ADD_INT_MACRO(m, IPV6_DSTOPTS);\n#endif\n#ifdef IPV6_HOPLIMIT\n    ADD_INT_MACRO(m, IPV6_HOPLIMIT);\n#endif\n#ifdef IPV6_HOPOPTS\n    ADD_INT_MACRO(m, IPV6_HOPOPTS);\n#endif\n#ifdef IPV6_NEXTHOP\n    ADD_INT_MACRO(m, IPV6_NEXTHOP);\n#endif\n#ifdef IPV6_PATHMTU\n    ADD_INT_MACRO(m, IPV6_PATHMTU);\n#endif\n#ifdef IPV6_PKTINFO\n    ADD_INT_MACRO(m, IPV6_PKTINFO);\n#endif\n#ifdef IPV6_RECVDSTOPTS\n    ADD_INT_MACRO(m, IPV6_RECVDSTOPTS);\n#endif\n#ifdef IPV6_RECVHOPLIMIT\n    ADD_INT_MACRO(m, IPV6_RECVHOPLIMIT);\n#endif\n#ifdef IPV6_RECVHOPOPTS\n    ADD_INT_MACRO(m, IPV6_RECVHOPOPTS);\n#endif\n#ifdef IPV6_RECVPKTINFO\n    ADD_INT_MACRO(m, IPV6_RECVPKTINFO);\n#endif\n#ifdef IPV6_RECVRTHDR\n    ADD_INT_MACRO(m, IPV6_RECVRTHDR);\n#endif\n#ifdef IPV6_RECVTCLASS\n    ADD_INT_MACRO(m, IPV6_RECVTCLASS);\n#endif\n#ifdef IPV6_RTHDR\n    ADD_INT_MACRO(m, IPV6_RTHDR);\n#endif\n#ifdef IPV6_RTHDRDSTOPTS\n    ADD_INT_MACRO(m, IPV6_RTHDRDSTOPTS);\n#endif\n#ifdef IPV6_RTHDR_TYPE_0\n    ADD_INT_MACRO(m, IPV6_RTHDR_TYPE_0);\n#endif\n#ifdef IPV6_RECVPATHMTU\n    ADD_INT_MACRO(m, IPV6_RECVPATHMTU);\n#endif\n#ifdef IPV6_TCLASS\n    ADD_INT_MACRO(m, IPV6_TCLASS);\n#endif\n#ifdef IPV6_USE_MIN_MTU\n    ADD_INT_MACRO(m, IPV6_USE_MIN_MTU);\n#endif\n\n    /* TCP options */\n#ifdef  TCP_NODELAY\n    ADD_INT_MACRO(m, TCP_NODELAY);\n#endif\n#ifdef  TCP_MAXSEG\n    ADD_INT_MACRO(m, TCP_MAXSEG);\n#endif\n#ifdef  TCP_CORK\n    ADD_INT_MACRO(m, TCP_CORK);\n#endif\n#ifdef  TCP_KEEPIDLE\n    ADD_INT_MACRO(m, TCP_KEEPIDLE);\n#endif\n    /* TCP_KEEPALIVE is OSX's TCP_KEEPIDLE equivalent */\n#if defined(__APPLE__) && defined(TCP_KEEPALIVE)\n    ADD_INT_MACRO(m, TCP_KEEPALIVE);\n#endif\n#ifdef  TCP_KEEPINTVL\n    ADD_INT_MACRO(m, TCP_KEEPINTVL);\n#endif\n#ifdef  TCP_KEEPCNT\n    ADD_INT_MACRO(m, TCP_KEEPCNT);\n#endif\n#ifdef  TCP_SYNCNT\n    ADD_INT_MACRO(m, TCP_SYNCNT);\n#endif\n#ifdef  TCP_LINGER2\n    ADD_INT_MACRO(m, TCP_LINGER2);\n#endif\n#ifdef  TCP_DEFER_ACCEPT\n    ADD_INT_MACRO(m, TCP_DEFER_ACCEPT);\n#endif\n#ifdef  TCP_WINDOW_CLAMP\n    ADD_INT_MACRO(m, TCP_WINDOW_CLAMP);\n#endif\n#ifdef  TCP_INFO\n    ADD_INT_MACRO(m, TCP_INFO);\n#endif\n#ifdef  TCP_CONNECTION_INFO\n    ADD_INT_MACRO(m, TCP_CONNECTION_INFO);\n#endif\n#ifdef  TCP_QUICKACK\n    ADD_INT_MACRO(m, TCP_QUICKACK);\n#endif\n#ifdef  TCP_CONGESTION\n    ADD_INT_MACRO(m, TCP_CONGESTION);\n#endif\n#ifdef  TCP_MD5SIG\n    ADD_INT_MACRO(m, TCP_MD5SIG);\n#endif\n#ifdef  TCP_THIN_LINEAR_TIMEOUTS\n    ADD_INT_MACRO(m, TCP_THIN_LINEAR_TIMEOUTS);\n#endif\n#ifdef  TCP_THIN_DUPACK\n    ADD_INT_MACRO(m, TCP_THIN_DUPACK);\n#endif\n#ifdef  TCP_USER_TIMEOUT\n    ADD_INT_MACRO(m, TCP_USER_TIMEOUT);\n#endif\n#ifdef  TCP_REPAIR\n    ADD_INT_MACRO(m, TCP_REPAIR);\n#endif\n#ifdef  TCP_REPAIR_QUEUE\n    ADD_INT_MACRO(m, TCP_REPAIR_QUEUE);\n#endif\n#ifdef  TCP_QUEUE_SEQ\n    ADD_INT_MACRO(m, TCP_QUEUE_SEQ);\n#endif\n#ifdef  TCP_REPAIR_OPTIONS\n    ADD_INT_MACRO(m, TCP_REPAIR_OPTIONS);\n#endif\n#ifdef  TCP_FASTOPEN\n    ADD_INT_MACRO(m, TCP_FASTOPEN);\n#endif\n#ifdef  TCP_TIMESTAMP\n    ADD_INT_MACRO(m, TCP_TIMESTAMP);\n#endif\n#ifdef  TCP_NOTSENT_LOWAT\n    ADD_INT_MACRO(m, TCP_NOTSENT_LOWAT);\n#endif\n#ifdef  TCP_CC_INFO\n    ADD_INT_MACRO(m, TCP_CC_INFO);\n#endif\n#ifdef  TCP_SAVE_SYN\n    ADD_INT_MACRO(m, TCP_SAVE_SYN);\n#endif\n#ifdef  TCP_SAVED_SYN\n    ADD_INT_MACRO(m, TCP_SAVED_SYN);\n#endif\n#ifdef  TCP_REPAIR_WINDOW\n    ADD_INT_MACRO(m, TCP_REPAIR_WINDOW);\n#endif\n#ifdef  TCP_FASTOPEN_CONNECT\n    ADD_INT_MACRO(m, TCP_FASTOPEN_CONNECT);\n#endif\n#ifdef  TCP_ULP\n    ADD_INT_MACRO(m, TCP_ULP);\n#endif\n#ifdef  TCP_MD5SIG_EXT\n    ADD_INT_MACRO(m, TCP_MD5SIG_EXT);\n#endif\n#ifdef  TCP_FASTOPEN_KEY\n    ADD_INT_MACRO(m, TCP_FASTOPEN_KEY);\n#endif\n#ifdef  TCP_FASTOPEN_NO_COOKIE\n    ADD_INT_MACRO(m, TCP_FASTOPEN_NO_COOKIE);\n#endif\n#ifdef  TCP_ZEROCOPY_RECEIVE\n    ADD_INT_MACRO(m, TCP_ZEROCOPY_RECEIVE);\n#endif\n#ifdef  TCP_INQ\n    ADD_INT_MACRO(m, TCP_INQ);\n#endif\n#ifdef  TCP_TX_DELAY\n    ADD_INT_MACRO(m, TCP_TX_DELAY);\n#endif\n\n    /* IPX options */\n#ifdef  IPX_TYPE\n    ADD_INT_MACRO(m, IPX_TYPE);\n#endif\n\n/* Reliable Datagram Sockets */\n#ifdef RDS_CMSG_RDMA_ARGS\n    ADD_INT_MACRO(m, RDS_CMSG_RDMA_ARGS);\n#endif\n#ifdef RDS_CMSG_RDMA_DEST\n    ADD_INT_MACRO(m, RDS_CMSG_RDMA_DEST);\n#endif\n#ifdef RDS_CMSG_RDMA_MAP\n    ADD_INT_MACRO(m, RDS_CMSG_RDMA_MAP);\n#endif\n#ifdef RDS_CMSG_RDMA_STATUS\n    ADD_INT_MACRO(m, RDS_CMSG_RDMA_STATUS);\n#endif\n#ifdef RDS_CMSG_RDMA_UPDATE\n    ADD_INT_MACRO(m, RDS_CMSG_RDMA_UPDATE);\n#endif\n#ifdef RDS_RDMA_READWRITE\n    ADD_INT_MACRO(m, RDS_RDMA_READWRITE);\n#endif\n#ifdef RDS_RDMA_FENCE\n    ADD_INT_MACRO(m, RDS_RDMA_FENCE);\n#endif\n#ifdef RDS_RDMA_INVALIDATE\n    ADD_INT_MACRO(m, RDS_RDMA_INVALIDATE);\n#endif\n#ifdef RDS_RDMA_USE_ONCE\n    ADD_INT_MACRO(m, RDS_RDMA_USE_ONCE);\n#endif\n#ifdef RDS_RDMA_DONTWAIT\n    ADD_INT_MACRO(m, RDS_RDMA_DONTWAIT);\n#endif\n#ifdef RDS_RDMA_NOTIFY_ME\n    ADD_INT_MACRO(m, RDS_RDMA_NOTIFY_ME);\n#endif\n#ifdef RDS_RDMA_SILENT\n    ADD_INT_MACRO(m, RDS_RDMA_SILENT);\n#endif\n\n    /* get{addr,name}info parameters */\n#ifdef EAI_ADDRFAMILY\n    ADD_INT_MACRO(m, EAI_ADDRFAMILY);\n#endif\n#ifdef EAI_AGAIN\n    ADD_INT_MACRO(m, EAI_AGAIN);\n#endif\n#ifdef EAI_BADFLAGS\n    ADD_INT_MACRO(m, EAI_BADFLAGS);\n#endif\n#ifdef EAI_FAIL\n    ADD_INT_MACRO(m, EAI_FAIL);\n#endif\n#ifdef EAI_FAMILY\n    ADD_INT_MACRO(m, EAI_FAMILY);\n#endif\n#ifdef EAI_MEMORY\n    ADD_INT_MACRO(m, EAI_MEMORY);\n#endif\n#ifdef EAI_NODATA\n    ADD_INT_MACRO(m, EAI_NODATA);\n#endif\n#ifdef EAI_NONAME\n    ADD_INT_MACRO(m, EAI_NONAME);\n#endif\n#ifdef EAI_OVERFLOW\n    ADD_INT_MACRO(m, EAI_OVERFLOW);\n#endif\n#ifdef EAI_SERVICE\n    ADD_INT_MACRO(m, EAI_SERVICE);\n#endif\n#ifdef EAI_SOCKTYPE\n    ADD_INT_MACRO(m, EAI_SOCKTYPE);\n#endif\n#ifdef EAI_SYSTEM\n    ADD_INT_MACRO(m, EAI_SYSTEM);\n#endif\n#ifdef EAI_BADHINTS\n    ADD_INT_MACRO(m, EAI_BADHINTS);\n#endif\n#ifdef EAI_PROTOCOL\n    ADD_INT_MACRO(m, EAI_PROTOCOL);\n#endif\n#ifdef EAI_MAX\n    ADD_INT_MACRO(m, EAI_MAX);\n#endif\n#ifdef AI_PASSIVE\n    ADD_INT_MACRO(m, AI_PASSIVE);\n#endif\n#ifdef AI_CANONNAME\n    ADD_INT_MACRO(m, AI_CANONNAME);\n#endif\n#ifdef AI_NUMERICHOST\n    ADD_INT_MACRO(m, AI_NUMERICHOST);\n#endif\n#ifdef AI_NUMERICSERV\n    ADD_INT_MACRO(m, AI_NUMERICSERV);\n#endif\n#ifdef AI_MASK\n    ADD_INT_MACRO(m, AI_MASK);\n#endif\n#ifdef AI_ALL\n    ADD_INT_MACRO(m, AI_ALL);\n#endif\n#ifdef AI_V4MAPPED_CFG\n    ADD_INT_MACRO(m, AI_V4MAPPED_CFG);\n#endif\n#ifdef AI_ADDRCONFIG\n    ADD_INT_MACRO(m, AI_ADDRCONFIG);\n#endif\n#ifdef AI_V4MAPPED\n    ADD_INT_MACRO(m, AI_V4MAPPED);\n#endif\n#ifdef AI_DEFAULT\n    ADD_INT_MACRO(m, AI_DEFAULT);\n#endif\n#ifdef NI_MAXHOST\n    ADD_INT_MACRO(m, NI_MAXHOST);\n#endif\n#ifdef NI_MAXSERV\n    ADD_INT_MACRO(m, NI_MAXSERV);\n#endif\n#ifdef NI_NOFQDN\n    ADD_INT_MACRO(m, NI_NOFQDN);\n#endif\n#ifdef NI_NUMERICHOST\n    ADD_INT_MACRO(m, NI_NUMERICHOST);\n#endif\n#ifdef NI_NAMEREQD\n    ADD_INT_MACRO(m, NI_NAMEREQD);\n#endif\n#ifdef NI_NUMERICSERV\n    ADD_INT_MACRO(m, NI_NUMERICSERV);\n#endif\n#ifdef NI_DGRAM\n    ADD_INT_MACRO(m, NI_DGRAM);\n#endif\n#ifdef NI_IDN\n    ADD_INT_MACRO(m, NI_IDN);\n#endif\n\n    /* shutdown() parameters */\n#ifdef SHUT_RD\n    ADD_INT_MACRO(m, SHUT_RD);\n#elif defined(SD_RECEIVE)\n    ADD_INT_CONST(m, \"SHUT_RD\", SD_RECEIVE);\n#else\n    ADD_INT_CONST(m, \"SHUT_RD\", 0);\n#endif\n#ifdef SHUT_WR\n    ADD_INT_MACRO(m, SHUT_WR);\n#elif defined(SD_SEND)\n    ADD_INT_CONST(m, \"SHUT_WR\", SD_SEND);\n#else\n    ADD_INT_CONST(m, \"SHUT_WR\", 1);\n#endif\n#ifdef SHUT_RDWR\n    ADD_INT_MACRO(m, SHUT_RDWR);\n#elif defined(SD_BOTH)\n    ADD_INT_CONST(m, \"SHUT_RDWR\", SD_BOTH);\n#else\n    ADD_INT_CONST(m, \"SHUT_RDWR\", 2);\n#endif\n\n#ifdef SIO_RCVALL\n    {\n        DWORD codes[] = {SIO_RCVALL, SIO_KEEPALIVE_VALS,\n#if defined(SIO_LOOPBACK_FAST_PATH)\n            SIO_LOOPBACK_FAST_PATH\n#endif\n        };\n        const char *names[] = {\"SIO_RCVALL\", \"SIO_KEEPALIVE_VALS\",\n#if defined(SIO_LOOPBACK_FAST_PATH)\n            \"SIO_LOOPBACK_FAST_PATH\"\n#endif\n        };\n        int i;\n        for (i = 0; i < Py_ARRAY_LENGTH(codes); ++i) {\n            if (PyModule_Add(m, names[i], PyLong_FromUnsignedLong(codes[i])) < 0) {\n                goto error;\n            }\n        }\n    }\n    ADD_INT_MACRO(m, RCVALL_OFF);\n    ADD_INT_MACRO(m, RCVALL_ON);\n    ADD_INT_MACRO(m, RCVALL_SOCKETLEVELONLY);\n#ifdef RCVALL_IPLEVEL\n    ADD_INT_MACRO(m, RCVALL_IPLEVEL);\n#endif\n#ifdef RCVALL_MAX\n    ADD_INT_MACRO(m, RCVALL_MAX);\n#endif\n#endif /* _MSTCPIP_ */\n\n    /* Initialize gethostbyname lock */\n#if defined(USE_GETHOSTBYNAME_LOCK)\n    netdb_lock = PyThread_allocate_lock();\n#endif\n\n#ifdef MS_WINDOWS\n    /* remove some flags on older version Windows during run-time */\n    if (remove_unusable_flags(m) < 0) {\n        goto error;\n    }\n#endif\n\n#undef ADD_INT_MACRO\n#undef ADD_INT_CONST\n#undef ADD_STR_CONST\n\n    return 0;\n\nerror:\n    return -1;\n}\n\nstatic struct PyModuleDef_Slot socket_slots[] = {\n    {Py_mod_exec, socket_exec},\n    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},\n    {Py_mod_gil, Py_MOD_GIL_NOT_USED},\n    {0, NULL},\n};\n\nstatic int\nsocket_traverse(PyObject *mod, visitproc visit, void *arg)\n{\n    socket_state *state = get_module_state(mod);\n    Py_VISIT(state->sock_type);\n    Py_VISIT(state->socket_herror);\n    Py_VISIT(state->socket_gaierror);\n    return 0;\n}\n\nstatic int\nsocket_clear(PyObject *mod)\n{\n    socket_state *state = get_module_state(mod);\n    Py_CLEAR(state->sock_type);\n    Py_CLEAR(state->socket_herror);\n    Py_CLEAR(state->socket_gaierror);\n    return 0;\n}\n\nstatic void\nsocket_free(void *mod)\n{\n    (void)socket_clear((PyObject *)mod);\n}\n\nstatic struct PyModuleDef socketmodule = {\n    .m_base = PyModuleDef_HEAD_INIT,\n    .m_name = PySocket_MODULE_NAME,\n    .m_doc = socket_doc,\n    .m_size = sizeof(socket_state),\n    .m_methods = socket_methods,\n    .m_slots = socket_slots,\n    .m_traverse = socket_traverse,\n    .m_clear = socket_clear,\n    .m_free = socket_free,\n};\n\nPyMODINIT_FUNC\nPyInit__socket(void)\n{\n    return PyModuleDef_Init(&socketmodule);\n}\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-fd-leak",
                        "taxa": [{"id": "775",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "file-descriptor",
                                       "gcc/analyzer/saved_diagnostic/enode": 36458,
                                       "gcc/analyzer/saved_diagnostic/snode": 1823,
                                       "gcc/analyzer/saved_diagnostic/sval": "SUB(CONJURED(_save_14 = PyEval_SaveThread ();, (*INIT_VAL(s_16(D)))), (*INIT_VAL(s_16(D))).sock_fd)",
                                       "gcc/analyzer/saved_diagnostic/state": "fd-bound-stream-socket",
                                       "gcc/analyzer/saved_diagnostic/idx": 0},
                        "level": "warning",
                        "message": {"text": "leak of file descriptor '*s.sock_fd'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/socketmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 3625,
                                                                       "startColumn": 5,
                                                                       "endColumn": 6},
                                                            "contextRegion": {"startLine": 3625,
                                                                              "snippet": {"text": "    Py_END_ALLOW_THREADS\n"}}},
                                       "logicalLocations": [{"name": "sock_listen",
                                                             "fullyQualifiedName": "sock_listen",
                                                             "decoratedName": "sock_listen",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1820,
                                                                                                                                 "dst_idx": 1821,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/socketmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 3616,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 3616,
                                                                                                                           "snippet": {"text": "    if (!PyArg_ParseTuple(args, \"|i:listen\", &backlog))\n"}}},
                                                                                    "logicalLocations": [{"name": "sock_listen",
                                                                                                          "fullyQualifiedName": "sock_listen",
                                                                                                          "decoratedName": "sock_listen",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1820,
                                                                                                                                 "dst_idx": 1821,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/socketmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 3619,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 3619,
                                                                                                                           "snippet": {"text": "    Py_BEGIN_ALLOW_THREADS\n"}}},
                                                                                    "logicalLocations": [{"name": "sock_listen",
                                                                                                          "fullyQualifiedName": "sock_listen",
                                                                                                          "decoratedName": "sock_listen",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/socketmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 3625,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 3625,
                                                                                                                           "snippet": {"text": "    Py_END_ALLOW_THREADS\n"}}},
                                                                                    "logicalLocations": [{"name": "sock_listen",
                                                                                                          "fullyQualifiedName": "sock_listen",
                                                                                                          "decoratedName": "sock_listen",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'*s.sock_fd' leaks here"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3}]}]}]},
                       {"ruleId": "-Wanalyzer-fd-leak",
                        "taxa": [{"id": "775",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "file-descriptor",
                                       "gcc/analyzer/saved_diagnostic/enode": 36460,
                                       "gcc/analyzer/saved_diagnostic/snode": 1823,
                                       "gcc/analyzer/saved_diagnostic/sval": "SUB(CONJURED(_save_14 = PyEval_SaveThread ();, (*INIT_VAL(s_16(D)))), (*INIT_VAL(s_16(D))).sock_fd)",
                                       "gcc/analyzer/saved_diagnostic/state": "fd-listening-stream-socket",
                                       "gcc/analyzer/saved_diagnostic/idx": 2},
                        "level": "warning",
                        "message": {"text": "leak of file descriptor '*s.sock_fd'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/socketmodule.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 3625,
                                                                       "startColumn": 5,
                                                                       "endColumn": 6},
                                                            "contextRegion": {"startLine": 3625,
                                                                              "snippet": {"text": "    Py_END_ALLOW_THREADS\n"}}},
                                       "logicalLocations": [{"name": "sock_listen",
                                                             "fullyQualifiedName": "sock_listen",
                                                             "decoratedName": "sock_listen",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1820,
                                                                                                                                 "dst_idx": 1821,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/socketmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 3616,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 3616,
                                                                                                                           "snippet": {"text": "    if (!PyArg_ParseTuple(args, \"|i:listen\", &backlog))\n"}}},
                                                                                    "logicalLocations": [{"name": "sock_listen",
                                                                                                          "fullyQualifiedName": "sock_listen",
                                                                                                          "decoratedName": "sock_listen",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 1820,
                                                                                                                                 "dst_idx": 1821,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/socketmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 3619,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 3619,
                                                                                                                           "snippet": {"text": "    Py_BEGIN_ALLOW_THREADS\n"}}},
                                                                                    "logicalLocations": [{"name": "sock_listen",
                                                                                                          "fullyQualifiedName": "sock_listen",
                                                                                                          "decoratedName": "sock_listen",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/socketmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 3624,
                                                                                                                    "startColumn": 11,
                                                                                                                    "endColumn": 38},
                                                                                                         "contextRegion": {"startLine": 3624,
                                                                                                                           "snippet": {"text": "    res = listen(s->sock_fd, backlog);\n"}}},
                                                                                    "logicalLocations": [{"name": "sock_listen",
                                                                                                          "fullyQualifiedName": "sock_listen",
                                                                                                          "decoratedName": "sock_listen",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "stream socket marked as passive here via 'listen'"}},
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CUSTOM"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/socketmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 3624,
                                                                                                                    "startColumn": 11,
                                                                                                                    "endColumn": 38},
                                                                                                         "contextRegion": {"startLine": 3624,
                                                                                                                           "snippet": {"text": "    res = listen(s->sock_fd, backlog);\n"}}},
                                                                                    "logicalLocations": [{"name": "sock_listen",
                                                                                                          "fullyQualifiedName": "sock_listen",
                                                                                                          "decoratedName": "sock_listen",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "when 'listen' succeeds"}},
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/socketmodule.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 3625,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 3625,
                                                                                                                           "snippet": {"text": "    Py_END_ALLOW_THREADS\n"}}},
                                                                                    "logicalLocations": [{"name": "sock_listen",
                                                                                                          "fullyQualifiedName": "sock_listen",
                                                                                                          "decoratedName": "sock_listen",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "'*s.sock_fd' leaks here"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5}]}]}]}]}]}
