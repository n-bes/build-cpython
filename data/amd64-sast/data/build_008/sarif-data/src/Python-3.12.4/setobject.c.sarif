{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-out-of-bounds", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-out-of-bounds"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "126", "helpUri": "https://cwe.mitre.org/data/definitions/126.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}}, "artifacts": [{"location": {"uri": "./Include/cpython/dictobject.h", "uriBaseId": "PWD"}, "contents": {"text": "#ifndef Py_CPYTHON_DICTOBJECT_H\n#  error \"this header file must not be included directly\"\n#endif\n\ntypedef struct _dictkeysobject PyDictKeysObject;\ntypedef struct _dictvalues PyDictValues;\n\n/* The ma_values pointer is NULL for a combined table\n * or points to an array of PyObject* for a split table\n */\ntypedef struct {\n    PyObject_HEAD\n\n    /* Number of items in the dictionary */\n    Py_ssize_t ma_used;\n\n    /* Dictionary version: globally unique, value change each time\n       the dictionary is modified */\n#ifdef Py_BUILD_CORE\n    uint64_t ma_version_tag;\n#else\n    Py_DEPRECATED(3.12) uint64_t ma_version_tag;\n#endif\n\n    PyDictKeysObject *ma_keys;\n\n    /* If ma_values is NULL, the table is \"combined\": keys and values\n       are stored in ma_keys.\n\n       If ma_values is not NULL, the table is split:\n       keys are stored in ma_keys and values are stored in ma_values */\n    PyDictValues *ma_values;\n} PyDictObject;\n\nPyAPI_FUNC(PyObject *) _PyDict_GetItem_KnownHash(PyObject *mp, PyObject *key,\n                                       Py_hash_t hash);\nPyAPI_FUNC(PyObject *) _PyDict_GetItemWithError(PyObject *dp, PyObject *key);\nPyAPI_FUNC(PyObject *) _PyDict_GetItemIdWithError(PyObject *dp,\n                                                  _Py_Identifier *key);\nPyAPI_FUNC(PyObject *) _PyDict_GetItemStringWithError(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyDict_SetDefault(\n    PyObject *mp, PyObject *key, PyObject *defaultobj);\nPyAPI_FUNC(int) _PyDict_SetItem_KnownHash(PyObject *mp, PyObject *key,\n                                          PyObject *item, Py_hash_t hash);\nPyAPI_FUNC(int) _PyDict_DelItem_KnownHash(PyObject *mp, PyObject *key,\n                                          Py_hash_t hash);\nPyAPI_FUNC(int) _PyDict_DelItemIf(PyObject *mp, PyObject *key,\n                                  int (*predicate)(PyObject *value));\nPyAPI_FUNC(int) _PyDict_Next(\n    PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value, Py_hash_t *hash);\n\n/* Get the number of items of a dictionary. */\nstatic inline Py_ssize_t PyDict_GET_SIZE(PyObject *op) {\n    PyDictObject *mp;\n    assert(PyDict_Check(op));\n    mp = _Py_CAST(PyDictObject*, op);\n    return mp->ma_used;\n}\n#define PyDict_GET_SIZE(op) PyDict_GET_SIZE(_PyObject_CAST(op))\n\nPyAPI_FUNC(int) _PyDict_Contains_KnownHash(PyObject *, PyObject *, Py_hash_t);\nPyAPI_FUNC(int) _PyDict_ContainsId(PyObject *, _Py_Identifier *);\nPyAPI_FUNC(PyObject *) _PyDict_NewPresized(Py_ssize_t minused);\nPyAPI_FUNC(void) _PyDict_MaybeUntrack(PyObject *mp);\nPyAPI_FUNC(int) _PyDict_HasOnlyStringKeys(PyObject *mp);\nPyAPI_FUNC(Py_ssize_t) _PyDict_SizeOf(PyDictObject *);\nPyAPI_FUNC(PyObject *) _PyDict_Pop(PyObject *, PyObject *, PyObject *);\n#define _PyDict_HasSplitTable(d) ((d)->ma_values != NULL)\n\n/* Like PyDict_Merge, but override can be 0, 1 or 2.  If override is 0,\n   the first occurrence of a key wins, if override is 1, the last occurrence\n   of a key wins, if override is 2, a KeyError with conflicting key as\n   argument is raised.\n*/\nPyAPI_FUNC(int) _PyDict_MergeEx(PyObject *mp, PyObject *other, int override);\nPyAPI_FUNC(int) _PyDict_SetItemId(PyObject *dp, _Py_Identifier *key, PyObject *item);\n\nPyAPI_FUNC(int) _PyDict_DelItemId(PyObject *mp, _Py_Identifier *key);\nPyAPI_FUNC(void) _PyDict_DebugMallocStats(FILE *out);\n\n/* _PyDictView */\n\ntypedef struct {\n    PyObject_HEAD\n    PyDictObject *dv_dict;\n} _PyDictViewObject;\n\nPyAPI_FUNC(PyObject *) _PyDictView_New(PyObject *, PyTypeObject *);\nPyAPI_FUNC(PyObject *) _PyDictView_Intersect(PyObject* self, PyObject *other);\n\n/* Dictionary watchers */\n\n#define PY_FOREACH_DICT_EVENT(V) \\\n    V(ADDED)                     \\\n    V(MODIFIED)                  \\\n    V(DELETED)                   \\\n    V(CLONED)                    \\\n    V(CLEARED)                   \\\n    V(DEALLOCATED)\n\ntypedef enum {\n    #define PY_DEF_EVENT(EVENT) PyDict_EVENT_##EVENT,\n    PY_FOREACH_DICT_EVENT(PY_DEF_EVENT)\n    #undef PY_DEF_EVENT\n} PyDict_WatchEvent;\n\n// Callback to be invoked when a watched dict is cleared, dealloced, or modified.\n// In clear/dealloc case, key and new_value will be NULL. Otherwise, new_value will be the\n// new value for key, NULL if key is being deleted.\ntypedef int(*PyDict_WatchCallback)(PyDict_WatchEvent event, PyObject* dict, PyObject* key, PyObject* new_value);\n\n// Register/unregister a dict-watcher callback\nPyAPI_FUNC(int) PyDict_AddWatcher(PyDict_WatchCallback callback);\nPyAPI_FUNC(int) PyDict_ClearWatcher(int watcher_id);\n\n// Mark given dictionary as \"watched\" (callback will be called if it is modified)\nPyAPI_FUNC(int) PyDict_Watch(int watcher_id, PyObject* dict);\nPyAPI_FUNC(int) PyDict_Unwatch(int watcher_id, PyObject* dict);\n"}, "sourceLanguage": "c"}, {"location": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "contents": {"text": "#ifndef Py_OBJECT_H\n#define Py_OBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Object and type object interface */\n\n/*\nObjects are structures allocated on the heap.  Special rules apply to\nthe use of objects to ensure they are properly garbage-collected.\nObjects are never allocated statically or on the stack; they must be\naccessed through special macros and functions only.  (Type objects are\nexceptions to the first rule; the standard types are represented by\nstatically initialized type objects, although work on type/class unification\nfor Python 2.2 made it possible to have heap-allocated type objects too).\n\nAn object has a 'reference count' that is increased or decreased when a\npointer to the object is copied or deleted; when the reference count\nreaches zero there are no references to the object left and it can be\nremoved from the heap.\n\nAn object has a 'type' that determines what it represents and what kind\nof data it contains.  An object's type is fixed when it is created.\nTypes themselves are represented as objects; an object contains a\npointer to the corresponding type object.  The type itself has a type\npointer pointing to the object representing the type 'type', which\ncontains a pointer to itself!.\n\nObjects do not float around in memory; once allocated an object keeps\nthe same size and address.  Objects that must hold variable-size data\ncan contain pointers to variable-size parts of the object.  Not all\nobjects of the same type have the same size; but the size cannot change\nafter allocation.  (These restrictions are made so a reference to an\nobject can be simply a pointer -- moving an object would require\nupdating all the pointers, and changing an object's size would require\nmoving it if there was another object right next to it.)\n\nObjects are always accessed through pointers of the type 'PyObject *'.\nThe type 'PyObject' is a structure that only contains the reference count\nand the type pointer.  The actual memory allocated for an object\ncontains other data that can only be accessed after casting the pointer\nto a pointer to a longer structure type.  This longer type must start\nwith the reference count and type fields; the macro PyObject_HEAD should be\nused for this (to accommodate for future changes).  The implementation\nof a particular object type can cast the object pointer to the proper\ntype and back.\n\nA standard interface exists for objects that contain an array of items\nwhose size is determined when the object is allocated.\n*/\n\n#include \"pystats.h\"\n\n/* Py_DEBUG implies Py_REF_DEBUG. */\n#if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)\n#  define Py_REF_DEBUG\n#endif\n\n#if defined(Py_LIMITED_API) && defined(Py_TRACE_REFS)\n#  error Py_LIMITED_API is incompatible with Py_TRACE_REFS\n#endif\n\n#ifdef Py_TRACE_REFS\n/* Define pointers to support a doubly-linked list of all live heap objects. */\n#define _PyObject_HEAD_EXTRA            \\\n    PyObject *_ob_next;           \\\n    PyObject *_ob_prev;\n\n#define _PyObject_EXTRA_INIT _Py_NULL, _Py_NULL,\n\n#else\n#  define _PyObject_HEAD_EXTRA\n#  define _PyObject_EXTRA_INIT\n#endif\n\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   PyObject ob_base;\n\n/*\nImmortalization:\n\nThe following indicates the immortalization strategy depending on the amount\nof available bits in the reference count field. All strategies are backwards\ncompatible but the specific reference count value or immortalization check\nmight change depending on the specializations for the underlying system.\n\nProper deallocation of immortal instances requires distinguishing between\nstatically allocated immortal instances vs those promoted by the runtime to be\nimmortal. The latter should be the only instances that require\ncleanup during runtime finalization.\n*/\n\n#if SIZEOF_VOID_P > 4\n/*\nIn 64+ bit systems, an object will be marked as immortal by setting all of the\nlower 32 bits of the reference count field, which is equal to: 0xFFFFFFFF\n\nUsing the lower 32 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases will use saturated arithmetic, taking advantage of\nhaving all the lower 32 bits set, which will avoid the reference count to go\nbeyond the refcount limit. Immortality checks for reference count decreases will\nbe done by checking the bit sign flag in the lower 32 bits.\n*/\n#define _Py_IMMORTAL_REFCNT UINT_MAX\n\n#else\n/*\nIn 32 bit systems, an object will be marked as immortal by setting all of the\nlower 30 bits of the reference count field, which is equal to: 0x3FFFFFFF\n\nUsing the lower 30 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases and decreases will first go through an immortality\ncheck by comparing the reference count field to the immortality reference count.\n*/\n#define _Py_IMMORTAL_REFCNT (UINT_MAX >> 2)\n#endif\n\n// Make all internal uses of PyObject_HEAD_INIT immortal while preserving the\n// C-API expectation that the refcnt will be set to 1.\n#ifdef Py_BUILD_CORE\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        _PyObject_EXTRA_INIT        \\\n        { _Py_IMMORTAL_REFCNT },    \\\n        (type)                      \\\n    },\n#else\n#define PyObject_HEAD_INIT(type) \\\n    {                            \\\n        _PyObject_EXTRA_INIT     \\\n        { 1 },                   \\\n        (type)                   \\\n    },\n#endif /* Py_BUILD_CORE */\n\n#define PyVarObject_HEAD_INIT(type, size) \\\n    {                                     \\\n        PyObject_HEAD_INIT(type)          \\\n        (size)                            \\\n    },\n\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD      PyVarObject ob_base;\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\nstruct _object {\n    _PyObject_HEAD_EXTRA\n\n#if (defined(__GNUC__) || defined(__clang__)) \\\n        && !(defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L)\n    // On C99 and older, anonymous union is a GCC and clang extension\n    __extension__\n#endif\n#ifdef _MSC_VER\n    // Ignore MSC warning C4201: \"nonstandard extension used:\n    // nameless struct/union\"\n    __pragma(warning(push))\n    __pragma(warning(disable: 4201))\n#endif\n    union {\n       Py_ssize_t ob_refcnt;\n#if SIZEOF_VOID_P > 4\n       PY_UINT32_T ob_refcnt_split[2];\n#endif\n    };\n#ifdef _MSC_VER\n    __pragma(warning(pop))\n#endif\n\n    PyTypeObject *ob_type;\n};\n\n/* Cast argument to PyObject* type. */\n#define _PyObject_CAST(op) _Py_CAST(PyObject*, (op))\n\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n/* Cast argument to PyVarObject* type. */\n#define _PyVarObject_CAST(op) _Py_CAST(PyVarObject*, (op))\n\n\n// Test if the 'x' object is the 'y' object, the same as \"x is y\" in Python.\nPyAPI_FUNC(int) Py_Is(PyObject *x, PyObject *y);\n#define Py_Is(x, y) ((x) == (y))\n\n\nstatic inline Py_ssize_t Py_REFCNT(PyObject *ob) {\n    return ob->ob_refcnt;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_REFCNT(ob) Py_REFCNT(_PyObject_CAST(ob))\n#endif\n\n\n// bpo-39573: The Py_SET_TYPE() function must be used to set an object type.\nstatic inline PyTypeObject* Py_TYPE(PyObject *ob) {\n    return ob->ob_type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_TYPE(ob) Py_TYPE(_PyObject_CAST(ob))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyLong_Type;\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n\n// bpo-39573: The Py_SET_SIZE() function must be used to set an object size.\nstatic inline Py_ssize_t Py_SIZE(PyObject *ob) {\n    assert(ob->ob_type != &PyLong_Type);\n    assert(ob->ob_type != &PyBool_Type);\n    return  _PyVarObject_CAST(ob)->ob_size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SIZE(ob) Py_SIZE(_PyObject_CAST(ob))\n#endif\n\nstatic inline Py_ALWAYS_INLINE int _Py_IsImmortal(PyObject *op)\n{\n#if SIZEOF_VOID_P > 4\n    return _Py_CAST(PY_INT32_T, op->ob_refcnt) < 0;\n#else\n    return op->ob_refcnt == _Py_IMMORTAL_REFCNT;\n#endif\n}\n#define _Py_IsImmortal(op) _Py_IsImmortal(_PyObject_CAST(op))\n\nstatic inline int Py_IS_TYPE(PyObject *ob, PyTypeObject *type) {\n    return Py_TYPE(ob) == type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_IS_TYPE(ob, type) Py_IS_TYPE(_PyObject_CAST(ob), (type))\n#endif\n\n\nstatic inline void Py_SET_REFCNT(PyObject *ob, Py_ssize_t refcnt) {\n    // This immortal check is for code that is unaware of immortal objects.\n    // The runtime tracks these objects and we should avoid as much\n    // as possible having extensions inadvertently change the refcnt\n    // of an immortalized object.\n    if (_Py_IsImmortal(ob)) {\n        return;\n    }\n    ob->ob_refcnt = refcnt;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_REFCNT(ob, refcnt) Py_SET_REFCNT(_PyObject_CAST(ob), (refcnt))\n#endif\n\n\nstatic inline void Py_SET_TYPE(PyObject *ob, PyTypeObject *type) {\n    ob->ob_type = type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_TYPE(ob, type) Py_SET_TYPE(_PyObject_CAST(ob), type)\n#endif\n\nstatic inline void Py_SET_SIZE(PyVarObject *ob, Py_ssize_t size) {\n    assert(ob->ob_base.ob_type != &PyLong_Type);\n    assert(ob->ob_base.ob_type != &PyBool_Type);\n    ob->ob_size = size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_SIZE(ob, size) Py_SET_SIZE(_PyVarObject_CAST(ob), (size))\n#endif\n\n\n/*\nType objects contain a string containing the type name (to help somewhat\nin debugging), the allocation parameters (see PyObject_New() and\nPyObject_NewVar()),\nand methods for accessing objects of the type.  Methods are optional, a\nnil pointer meaning that particular kind of access is not available for\nthis type.  The Py_DECREF() macro uses the tp_dealloc method without\nchecking for a nil pointer; it should always be implemented except if\nthe implementation can guarantee that the reference count will never\nreach zero (e.g., for statically allocated type objects).\n\nNB: the methods for certain type groups are now contained in separate\nmethod blocks.\n*/\n\ntypedef PyObject * (*unaryfunc)(PyObject *);\ntypedef PyObject * (*binaryfunc)(PyObject *, PyObject *);\ntypedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);\ntypedef int (*inquiry)(PyObject *);\ntypedef Py_ssize_t (*lenfunc)(PyObject *);\ntypedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);\ntypedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);\ntypedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);\ntypedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);\ntypedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);\n\ntypedef int (*objobjproc)(PyObject *, PyObject *);\ntypedef int (*visitproc)(PyObject *, void *);\ntypedef int (*traverseproc)(PyObject *, visitproc, void *);\n\n\ntypedef void (*freefunc)(void *);\ntypedef void (*destructor)(PyObject *);\ntypedef PyObject *(*getattrfunc)(PyObject *, char *);\ntypedef PyObject *(*getattrofunc)(PyObject *, PyObject *);\ntypedef int (*setattrfunc)(PyObject *, char *, PyObject *);\ntypedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*reprfunc)(PyObject *);\ntypedef Py_hash_t (*hashfunc)(PyObject *);\ntypedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);\ntypedef PyObject *(*getiterfunc) (PyObject *);\ntypedef PyObject *(*iternextfunc) (PyObject *);\ntypedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*initproc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*newfunc)(PyTypeObject *, PyObject *, PyObject *);\ntypedef PyObject *(*allocfunc)(PyTypeObject *, Py_ssize_t);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030c0000 // 3.12\ntypedef PyObject *(*vectorcallfunc)(PyObject *callable, PyObject *const *args,\n                                    size_t nargsf, PyObject *kwnames);\n#endif\n\ntypedef struct{\n    int slot;    /* slot id, see below */\n    void *pfunc; /* function pointer */\n} PyType_Slot;\n\ntypedef struct{\n    const char* name;\n    int basicsize;\n    int itemsize;\n    unsigned int flags;\n    PyType_Slot *slots; /* terminated by slot==0. */\n} PyType_Spec;\n\nPyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000\nPyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);\nPyAPI_FUNC(PyObject *) PyType_GetModule(PyTypeObject *);\nPyAPI_FUNC(void *) PyType_GetModuleState(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000\nPyAPI_FUNC(PyObject *) PyType_GetName(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GetQualName(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\nPyAPI_FUNC(PyObject *) PyType_FromMetaclass(PyTypeObject*, PyObject*, PyType_Spec*, PyObject*);\nPyAPI_FUNC(void *) PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls);\nPyAPI_FUNC(Py_ssize_t) PyType_GetTypeDataSize(PyTypeObject *cls);\n#endif\n\n/* Generic type check */\nPyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);\n\nstatic inline int PyObject_TypeCheck(PyObject *ob, PyTypeObject *type) {\n    return Py_IS_TYPE(ob, type) || PyType_IsSubtype(Py_TYPE(ob), type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyObject_TypeCheck(ob, type) PyObject_TypeCheck(_PyObject_CAST(ob), (type))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */\nPyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */\nPyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */\n\nPyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);\n\nPyAPI_FUNC(int) PyType_Ready(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,\n                                               PyObject *, PyObject *);\nPyAPI_FUNC(unsigned int) PyType_ClearCache(void);\nPyAPI_FUNC(void) PyType_Modified(PyTypeObject *);\n\n/* Generic operations on objects */\nPyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);\nPyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);\nPyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);\nPyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);\n#endif\nPyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);\nPyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);\nPyAPI_FUNC(int) PyObject_IsTrue(PyObject *);\nPyAPI_FUNC(int) PyObject_Not(PyObject *);\nPyAPI_FUNC(int) PyCallable_Check(PyObject *);\nPyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);\n\n/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a\n   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),\n   returning the names of the current locals.  In this case, if there are\n   no current locals, NULL is returned, and PyErr_Occurred() is false.\n*/\nPyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);\n\n/* Pickle support. */\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyObject_GetState(PyObject *);\n#endif\n\n\n/* Helpers for printing recursive container types */\nPyAPI_FUNC(int) Py_ReprEnter(PyObject *);\nPyAPI_FUNC(void) Py_ReprLeave(PyObject *);\n\n/* Flag bits for printing: */\n#define Py_PRINT_RAW    1       /* No string quotes etc. */\n\n/*\nType flags (tp_flags)\n\nThese flags are used to change expected features and behavior for a\nparticular type.\n\nArbitration of the flag bit positions will need to be coordinated among\nall extension writers who publicly release their extensions (this will\nbe fewer than you might expect!).\n\nMost flags were removed as of Python 3.0 to make room for new flags.  (Some\nflags are not for backwards compatibility but to indicate the presence of an\noptional feature; these flags remain of course.)\n\nType definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.\n\nCode can use PyType_HasFeature(type_ob, flag_value) to test whether the\ngiven type object has a specified feature.\n*/\n\n#ifndef Py_LIMITED_API\n\n/* Track types initialized using _PyStaticType_InitBuiltin(). */\n#define _Py_TPFLAGS_STATIC_BUILTIN (1 << 1)\n\n/* Placement of weakref pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_weaklistoffset.\n */\n#define Py_TPFLAGS_MANAGED_WEAKREF (1 << 3)\n\n/* Placement of dict (and values) pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_dictoffset.\n */\n#define Py_TPFLAGS_MANAGED_DICT (1 << 4)\n\n#define Py_TPFLAGS_PREHEADER (Py_TPFLAGS_MANAGED_WEAKREF | Py_TPFLAGS_MANAGED_DICT)\n\n/* Set if instances of the type object are treated as sequences for pattern matching */\n#define Py_TPFLAGS_SEQUENCE (1 << 5)\n/* Set if instances of the type object are treated as mappings for pattern matching */\n#define Py_TPFLAGS_MAPPING (1 << 6)\n#endif\n\n/* Disallow creating instances of the type: set tp_new to NULL and don't create\n * the \"__new__\" key in the type dictionary. */\n#define Py_TPFLAGS_DISALLOW_INSTANTIATION (1UL << 7)\n\n/* Set if the type object is immutable: type attributes cannot be set nor deleted */\n#define Py_TPFLAGS_IMMUTABLETYPE (1UL << 8)\n\n/* Set if the type object is dynamically allocated */\n#define Py_TPFLAGS_HEAPTYPE (1UL << 9)\n\n/* Set if the type allows subclassing */\n#define Py_TPFLAGS_BASETYPE (1UL << 10)\n\n/* Set if the type implements the vectorcall protocol (PEP 590) */\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\n#define Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)\n#ifndef Py_LIMITED_API\n// Backwards compatibility alias for API that was provisional in Python 3.8\n#define _Py_TPFLAGS_HAVE_VECTORCALL Py_TPFLAGS_HAVE_VECTORCALL\n#endif\n#endif\n\n/* Set if the type is 'ready' -- fully initialized */\n#define Py_TPFLAGS_READY (1UL << 12)\n\n/* Set while the type is being 'readied', to prevent recursive ready calls */\n#define Py_TPFLAGS_READYING (1UL << 13)\n\n/* Objects support garbage collection (see objimpl.h) */\n#define Py_TPFLAGS_HAVE_GC (1UL << 14)\n\n/* These two bits are preserved for Stackless Python, next after this is 17 */\n#ifdef STACKLESS\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)\n#else\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0\n#endif\n\n/* Objects behave like an unbound method */\n#define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)\n\n/* Object has up-to-date type attribute cache */\n#define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)\n\n/* Type is abstract and cannot be instantiated */\n#define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)\n\n// This undocumented flag gives certain built-ins their unique pattern-matching\n// behavior, which allows a single positional subpattern to match against the\n// subject itself (rather than a mapped attribute on it):\n#define _Py_TPFLAGS_MATCH_SELF (1UL << 22)\n\n/* Items (ob_size*tp_itemsize) are found at the end of an instance's memory */\n#define Py_TPFLAGS_ITEMS_AT_END (1UL << 23)\n\n/* These flags are used to determine if a type is a subclass. */\n#define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)\n#define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)\n#define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)\n#define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)\n#define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)\n#define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)\n#define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)\n#define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)\n\n#define Py_TPFLAGS_DEFAULT  ( \\\n                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \\\n                0)\n\n/* NOTE: Some of the following flags reuse lower bits (removed as part of the\n * Python 3.0 transition). */\n\n/* The following flags are kept for compatibility; in previous\n * versions they indicated presence of newer tp_* fields on the\n * type struct.\n * Starting with 3.8, binary compatibility of C extensions across\n * feature releases of Python is not supported anymore (except when\n * using the stable ABI, in which all classes are created dynamically,\n * using the interpreter's memory layout.)\n * Note that older extensions using the stable ABI set these flags,\n * so the bits must not be repurposed.\n */\n#define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)\n#define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)\n\n\n/*\nThe macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement\nreference counts.  Py_DECREF calls the object's deallocator function when\nthe refcount falls to 0; for\nobjects that don't contain references to other objects or heap memory\nthis can be the standard function free().  Both macros can be used\nwherever a void expression is allowed.  The argument must not be a\nNULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.\nThe macro _Py_NewReference(op) initialize reference counts to 1, and\nin special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional\nbookkeeping appropriate to the special build.\n\nWe assume that the reference count field can never overflow; this can\nbe proven when the size of the field is the same as the pointer size, so\nwe ignore the possibility.  Provided a C int is at least 32 bits (which\nis implicitly assumed in many parts of this code), that's enough for\nabout 2**31 references to an object.\n\nXXX The following became out of date in Python 2.2, but I'm not sure\nXXX what the full truth is now.  Certainly, heap-allocated type objects\nXXX can and should be deallocated.\nType objects should never be deallocated; the type pointer in an object\nis not considered to be a reference to the type object, to save\ncomplications in the deallocation function.  (This is actually a\ndecision that's up to the implementer of each new type so if you want,\nyou can count such references to the type object.)\n*/\n\n#if defined(Py_REF_DEBUG) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,\n                                      PyObject *op);\nPyAPI_FUNC(void) _Py_INCREF_IncRefTotal(void);\nPyAPI_FUNC(void) _Py_DECREF_DecRefTotal(void);\n#endif  // Py_REF_DEBUG && !Py_LIMITED_API\n\nPyAPI_FUNC(void) _Py_Dealloc(PyObject *);\n\n/*\nThese are provided as conveniences to Python runtime embedders, so that\nthey can have object code that is not dependent on Python compilation flags.\n*/\nPyAPI_FUNC(void) Py_IncRef(PyObject *);\nPyAPI_FUNC(void) Py_DecRef(PyObject *);\n\n// Similar to Py_IncRef() and Py_DecRef() but the argument must be non-NULL.\n// Private functions used by Py_INCREF() and Py_DECREF().\nPyAPI_FUNC(void) _Py_IncRef(PyObject *);\nPyAPI_FUNC(void) _Py_DecRef(PyObject *);\n\nstatic inline Py_ALWAYS_INLINE void Py_INCREF(PyObject *op)\n{\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n    // Stable ABI implements Py_INCREF() as a function call on limited C API\n    // version 3.12 and newer, and on Python built in debug mode. _Py_IncRef()\n    // was added to Python 3.10.0a7, use Py_IncRef() on older Python versions.\n    // Py_IncRef() accepts NULL whereas _Py_IncRef() doesn't.\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_IncRef(op);\n#  else\n    Py_IncRef(op);\n#  endif\n#else\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n#if SIZEOF_VOID_P > 4\n    // Portable saturated add, branching on the carry flag and set low bits\n    PY_UINT32_T cur_refcnt = op->ob_refcnt_split[PY_BIG_ENDIAN];\n    PY_UINT32_T new_refcnt = cur_refcnt + 1;\n    if (new_refcnt == 0) {\n        return;\n    }\n    op->ob_refcnt_split[PY_BIG_ENDIAN] = new_refcnt;\n#else\n    // Explicitly check immortality against the immortal value\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    op->ob_refcnt++;\n#endif\n    _Py_INCREF_STAT_INC();\n#ifdef Py_REF_DEBUG\n    _Py_INCREF_IncRefTotal();\n#endif\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_INCREF(op) Py_INCREF(_PyObject_CAST(op))\n#endif\n\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n// Stable ABI implements Py_DECREF() as a function call on limited C API\n// version 3.12 and newer, and on Python built in debug mode. _Py_DecRef() was\n// added to Python 3.10.0a7, use Py_DecRef() on older Python versions.\n// Py_DecRef() accepts NULL whereas _Py_IncRef() doesn't.\nstatic inline void Py_DECREF(PyObject *op) {\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_DecRef(op);\n#  else\n    Py_DecRef(op);\n#  endif\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    if (op->ob_refcnt <= 0) {\n        _Py_NegativeRefcount(filename, lineno, op);\n    }\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#else\nstatic inline Py_ALWAYS_INLINE void Py_DECREF(PyObject *op)\n{\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n#endif\n\n\n/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear\n * and tp_dealloc implementations.\n *\n * Note that \"the obvious\" code can be deadly:\n *\n *     Py_XDECREF(op);\n *     op = NULL;\n *\n * Typically, `op` is something like self->containee, and `self` is done\n * using its `containee` member.  In the code sequence above, suppose\n * `containee` is non-NULL with a refcount of 1.  Its refcount falls to\n * 0 on the first line, which can trigger an arbitrary amount of code,\n * possibly including finalizers (like __del__ methods or weakref callbacks)\n * coded in Python, which in turn can release the GIL and allow other threads\n * to run, etc.  Such code may even invoke methods of `self` again, or cause\n * cyclic gc to trigger, but-- oops! --self->containee still points to the\n * object being torn down, and it may be in an insane state while being torn\n * down.  This has in fact been a rich historic source of miserable (rare &\n * hard-to-diagnose) segfaulting (and other) bugs.\n *\n * The safe way is:\n *\n *      Py_CLEAR(op);\n *\n * That arranges to set `op` to NULL _before_ decref'ing, so that any code\n * triggered as a side-effect of `op` getting torn down no longer believes\n * `op` points to a valid object.\n *\n * There are cases where it's safe to use the naive code, but they're brittle.\n * For example, if `op` points to a Python integer, you know that destroying\n * one of those can't cause problems -- but in part that relies on that\n * Python integers aren't currently weakly referencable.  Best practice is\n * to use Py_CLEAR() even if you can't think of a reason for why you need to.\n *\n * gh-98724: Use a temporary variable to only evaluate the macro argument once,\n * to avoid the duplication of side effects if the argument has side effects.\n *\n * gh-99701: If the PyObject* type is used with casting arguments to PyObject*,\n * the code can be miscompiled with strict aliasing because of type punning.\n * With strict aliasing, a compiler considers that two pointers of different\n * types cannot read or write the same memory which enables optimization\n * opportunities.\n *\n * If available, use _Py_TYPEOF() to use the 'op' type for temporary variables,\n * and so avoid type punning. Otherwise, use memcpy() which causes type erasure\n * and so prevents the compiler to reuse an old cached 'op' value after\n * Py_CLEAR().\n */\n#ifdef _Py_TYPEOF\n#define Py_CLEAR(op) \\\n    do { \\\n        _Py_TYPEOF(op)* _tmp_op_ptr = &(op); \\\n        _Py_TYPEOF(op) _tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            *_tmp_op_ptr = _Py_NULL; \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#else\n#define Py_CLEAR(op) \\\n    do { \\\n        PyObject **_tmp_op_ptr = _Py_CAST(PyObject**, &(op)); \\\n        PyObject *_tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            PyObject *_null_ptr = _Py_NULL; \\\n            memcpy(_tmp_op_ptr, &_null_ptr, sizeof(PyObject*)); \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#endif\n\n\n/* Function to use in case the object pointer can be NULL: */\nstatic inline void Py_XINCREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_INCREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XINCREF(op) Py_XINCREF(_PyObject_CAST(op))\n#endif\n\nstatic inline void Py_XDECREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_DECREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XDECREF(op) Py_XDECREF(_PyObject_CAST(op))\n#endif\n\n// Create a new strong reference to an object:\n// increment the reference count of the object and return the object.\nPyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);\n\n// Similar to Py_NewRef(), but the object can be NULL.\nPyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);\n\nstatic inline PyObject* _Py_NewRef(PyObject *obj)\n{\n    Py_INCREF(obj);\n    return obj;\n}\n\nstatic inline PyObject* _Py_XNewRef(PyObject *obj)\n{\n    Py_XINCREF(obj);\n    return obj;\n}\n\n// Py_NewRef() and Py_XNewRef() are exported as functions for the stable ABI.\n// Names overridden with macros by static inline functions for best\n// performances.\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_NewRef(obj) _Py_NewRef(_PyObject_CAST(obj))\n#  define Py_XNewRef(obj) _Py_XNewRef(_PyObject_CAST(obj))\n#else\n#  define Py_NewRef(obj) _Py_NewRef(obj)\n#  define Py_XNewRef(obj) _Py_XNewRef(obj)\n#endif\n\n\n/*\n_Py_NoneStruct is an object of undefined type which can be used in contexts\nwhere NULL (nil) is not suitable (since NULL often means 'error').\n\nDon't forget to apply Py_INCREF() when returning this value!!!\n*/\nPyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n#define Py_None (&_Py_NoneStruct)\n\n// Test if an object is the None singleton, the same as \"x is None\" in Python.\nPyAPI_FUNC(int) Py_IsNone(PyObject *x);\n#define Py_IsNone(x) Py_Is((x), Py_None)\n\n/* Macro for returning Py_None from a function */\n#define Py_RETURN_NONE return Py_None\n\n/*\nPy_NotImplemented is a singleton used to signal that an operation is\nnot implemented for a given type combination.\n*/\nPyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */\n#define Py_NotImplemented (&_Py_NotImplementedStruct)\n\n/* Macro for returning Py_NotImplemented from a function */\n#define Py_RETURN_NOTIMPLEMENTED return Py_NotImplemented\n\n/* Rich comparison opcodes */\n#define Py_LT 0\n#define Py_LE 1\n#define Py_EQ 2\n#define Py_NE 3\n#define Py_GT 4\n#define Py_GE 5\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000\n/* Result of calling PyIter_Send */\ntypedef enum {\n    PYGEN_RETURN = 0,\n    PYGEN_ERROR = -1,\n    PYGEN_NEXT = 1,\n} PySendResult;\n#endif\n\n/*\n * Macro for implementing rich comparisons\n *\n * Needs to be a macro because any C-comparable type can be used.\n */\n#define Py_RETURN_RICHCOMPARE(val1, val2, op)                               \\\n    do {                                                                    \\\n        switch (op) {                                                       \\\n        case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        default:                                                            \\\n            Py_UNREACHABLE();                                               \\\n        }                                                                   \\\n    } while (0)\n\n\n/*\nMore conventions\n================\n\nArgument Checking\n-----------------\n\nFunctions that take objects as arguments normally don't check for nil\narguments, but they do check the type of the argument, and return an\nerror if the function doesn't apply to the type.\n\nFailure Modes\n-------------\n\nFunctions may fail for a variety of reasons, including running out of\nmemory.  This is communicated to the caller in two ways: an error string\nis set (see errors.h), and the function result differs: functions that\nnormally return a pointer return NULL for failure, functions returning\nan integer return -1 (which could be a legal return value too!), and\nother functions return 0 for success and -1 for failure.\nCallers should always check for errors before using the result.  If\nan error was set, the caller must either explicitly clear it, or pass\nthe error on to its caller.\n\nReference Counts\n----------------\n\nIt takes a while to get used to the proper usage of reference counts.\n\nFunctions that create an object set the reference count to 1; such new\nobjects must be stored somewhere or destroyed again with Py_DECREF().\nSome functions that 'store' objects, such as PyTuple_SetItem() and\nPyList_SetItem(),\ndon't increment the reference count of the object, since the most\nfrequent use is to store a fresh object.  Functions that 'retrieve'\nobjects, such as PyTuple_GetItem() and PyDict_GetItemString(), also\ndon't increment\nthe reference count, since most frequently the object is only looked at\nquickly.  Thus, to retrieve an object and store it again, the caller\nmust call Py_INCREF() explicitly.\n\nNOTE: functions that 'consume' a reference count, like\nPyList_SetItem(), consume the reference even if the object wasn't\nsuccessfully stored, to simplify error handling.\n\nIt seems attractive to make other functions that take an object as\nargument consume a reference count; however, this may quickly get\nconfusing (even the current practice is already confusing).  Consider\nit carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at\ntimes.\n*/\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_OBJECT_H\n#  include \"cpython/object.h\"\n#  undef Py_CPYTHON_OBJECT_H\n#endif\n\n\nstatic inline int\nPyType_HasFeature(PyTypeObject *type, unsigned long feature)\n{\n    unsigned long flags;\n#ifdef Py_LIMITED_API\n    // PyTypeObject is opaque in the limited C API\n    flags = PyType_GetFlags(type);\n#else\n    flags = type->tp_flags;\n#endif\n    return ((flags & feature) != 0);\n}\n\n#define PyType_FastSubclass(type, flag) PyType_HasFeature((type), (flag))\n\nstatic inline int PyType_Check(PyObject *op) {\n    return PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_Check(op) PyType_Check(_PyObject_CAST(op))\n#endif\n\n#define _PyType_CAST(op) \\\n    (assert(PyType_Check(op)), _Py_CAST(PyTypeObject*, (op)))\n\nstatic inline int PyType_CheckExact(PyObject *op) {\n    return Py_IS_TYPE(op, &PyType_Type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_CheckExact(op) PyType_CheckExact(_PyObject_CAST(op))\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif   // !Py_OBJECT_H\n"}, "sourceLanguage": "c"}, {"location": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "contents": {"text": "\n/* set object implementation\n\n   Written and maintained by Raymond D. Hettinger <python@rcn.com>\n   Derived from Lib/sets.py and Objects/dictobject.c.\n\n   The basic lookup function used by all operations.\n   This is based on Algorithm D from Knuth Vol. 3, Sec. 6.4.\n\n   The initial probe index is computed as hash mod the table size.\n   Subsequent probe indices are computed as explained in Objects/dictobject.c.\n\n   To improve cache locality, each probe inspects a series of consecutive\n   nearby entries before moving on to probes elsewhere in memory.  This leaves\n   us with a hybrid of linear probing and randomized probing.  The linear probing\n   reduces the cost of hash collisions because consecutive memory accesses\n   tend to be much cheaper than scattered probes.  After LINEAR_PROBES steps,\n   we then use more of the upper bits from the hash value and apply a simple\n   linear congruential random number generator.  This helps break-up long\n   chains of collisions.\n\n   All arithmetic on hash should ignore overflow.\n\n   Unlike the dictionary implementation, the lookkey function can return\n   NULL if the rich comparison returns an error.\n\n   Use cases for sets differ considerably from dictionaries where looked-up\n   keys are more likely to be present.  In contrast, sets are primarily\n   about membership testing where the presence of an element is not known in\n   advance.  Accordingly, the set implementation needs to optimize for both\n   the found and not-found case.\n*/\n\n#include \"Python.h\"\n#include \"pycore_object.h\"        // _PyObject_GC_UNTRACK()\n#include <stddef.h>               // offsetof()\n\n/* Object used as dummy key to fill deleted entries */\nstatic PyObject _dummy_struct;\n\n#define dummy (&_dummy_struct)\n\n\n/* ======================================================================== */\n/* ======= Begin logic for probing the hash table ========================= */\n\n/* Set this to zero to turn-off linear probing */\n#ifndef LINEAR_PROBES\n#define LINEAR_PROBES 9\n#endif\n\n/* This must be >= 1 */\n#define PERTURB_SHIFT 5\n\nstatic setentry *\nset_lookkey(PySetObject *so, PyObject *key, Py_hash_t hash)\n{\n    setentry *table;\n    setentry *entry;\n    size_t perturb = hash;\n    size_t mask = so->mask;\n    size_t i = (size_t)hash & mask; /* Unsigned for defined overflow behavior */\n    int probes;\n    int cmp;\n\n    while (1) {\n        entry = &so->table[i];\n        probes = (i + LINEAR_PROBES <= mask) ? LINEAR_PROBES: 0;\n        do {\n            if (entry->hash == 0 && entry->key == NULL)\n                return entry;\n            if (entry->hash == hash) {\n                PyObject *startkey = entry->key;\n                assert(startkey != dummy);\n                if (startkey == key)\n                    return entry;\n                if (PyUnicode_CheckExact(startkey)\n                    && PyUnicode_CheckExact(key)\n                    && _PyUnicode_EQ(startkey, key))\n                    return entry;\n                table = so->table;\n                Py_INCREF(startkey);\n                cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);\n                Py_DECREF(startkey);\n                if (cmp < 0)\n                    return NULL;\n                if (table != so->table || entry->key != startkey)\n                    return set_lookkey(so, key, hash);\n                if (cmp > 0)\n                    return entry;\n                mask = so->mask;\n            }\n            entry++;\n        } while (probes--);\n        perturb >>= PERTURB_SHIFT;\n        i = (i * 5 + 1 + perturb) & mask;\n    }\n}\n\nstatic int set_table_resize(PySetObject *, Py_ssize_t);\n\nstatic int\nset_add_entry(PySetObject *so, PyObject *key, Py_hash_t hash)\n{\n    setentry *table;\n    setentry *freeslot;\n    setentry *entry;\n    size_t perturb;\n    size_t mask;\n    size_t i;                       /* Unsigned for defined overflow behavior */\n    int probes;\n    int cmp;\n\n    /* Pre-increment is necessary to prevent arbitrary code in the rich\n       comparison from deallocating the key just before the insertion. */\n    Py_INCREF(key);\n\n  restart:\n\n    mask = so->mask;\n    i = (size_t)hash & mask;\n    freeslot = NULL;\n    perturb = hash;\n\n    while (1) {\n        entry = &so->table[i];\n        probes = (i + LINEAR_PROBES <= mask) ? LINEAR_PROBES: 0;\n        do {\n            if (entry->hash == 0 && entry->key == NULL)\n                goto found_unused_or_dummy;\n            if (entry->hash == hash) {\n                PyObject *startkey = entry->key;\n                assert(startkey != dummy);\n                if (startkey == key)\n                    goto found_active;\n                if (PyUnicode_CheckExact(startkey)\n                    && PyUnicode_CheckExact(key)\n                    && _PyUnicode_EQ(startkey, key))\n                    goto found_active;\n                table = so->table;\n                Py_INCREF(startkey);\n                cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);\n                Py_DECREF(startkey);\n                if (cmp > 0)\n                    goto found_active;\n                if (cmp < 0)\n                    goto comparison_error;\n                if (table != so->table || entry->key != startkey)\n                    goto restart;\n                mask = so->mask;\n            }\n            else if (entry->hash == -1) {\n                assert (entry->key == dummy);\n                freeslot = entry;\n            }\n            entry++;\n        } while (probes--);\n        perturb >>= PERTURB_SHIFT;\n        i = (i * 5 + 1 + perturb) & mask;\n    }\n\n  found_unused_or_dummy:\n    if (freeslot == NULL)\n        goto found_unused;\n    so->used++;\n    freeslot->key = key;\n    freeslot->hash = hash;\n    return 0;\n\n  found_unused:\n    so->fill++;\n    so->used++;\n    entry->key = key;\n    entry->hash = hash;\n    if ((size_t)so->fill*5 < mask*3)\n        return 0;\n    return set_table_resize(so, so->used>50000 ? so->used*2 : so->used*4);\n\n  found_active:\n    Py_DECREF(key);\n    return 0;\n\n  comparison_error:\n    Py_DECREF(key);\n    return -1;\n}\n\n/*\nInternal routine used by set_table_resize() to insert an item which is\nknown to be absent from the set.  Besides the performance benefit,\nthere is also safety benefit since using set_add_entry() risks making\na callback in the middle of a set_table_resize(), see issue 1456209.\nThe caller is responsible for updating the key's reference count and\nthe setobject's fill and used fields.\n*/\nstatic void\nset_insert_clean(setentry *table, size_t mask, PyObject *key, Py_hash_t hash)\n{\n    setentry *entry;\n    size_t perturb = hash;\n    size_t i = (size_t)hash & mask;\n    size_t j;\n\n    while (1) {\n        entry = &table[i];\n        if (entry->key == NULL)\n            goto found_null;\n        if (i + LINEAR_PROBES <= mask) {\n            for (j = 0; j < LINEAR_PROBES; j++) {\n                entry++;\n                if (entry->key == NULL)\n                    goto found_null;\n            }\n        }\n        perturb >>= PERTURB_SHIFT;\n        i = (i * 5 + 1 + perturb) & mask;\n    }\n  found_null:\n    entry->key = key;\n    entry->hash = hash;\n}\n\n/* ======== End logic for probing the hash table ========================== */\n/* ======================================================================== */\n\n/*\nRestructure the table by allocating a new table and reinserting all\nkeys again.  When entries have been deleted, the new table may\nactually be smaller than the old one.\n*/\nstatic int\nset_table_resize(PySetObject *so, Py_ssize_t minused)\n{\n    setentry *oldtable, *newtable, *entry;\n    Py_ssize_t oldmask = so->mask;\n    size_t newmask;\n    int is_oldtable_malloced;\n    setentry small_copy[PySet_MINSIZE];\n\n    assert(minused >= 0);\n\n    /* Find the smallest table size > minused. */\n    /* XXX speed-up with intrinsics */\n    size_t newsize = PySet_MINSIZE;\n    while (newsize <= (size_t)minused) {\n        newsize <<= 1; // The largest possible value is PY_SSIZE_T_MAX + 1.\n    }\n\n    /* Get space for a new table. */\n    oldtable = so->table;\n    assert(oldtable != NULL);\n    is_oldtable_malloced = oldtable != so->smalltable;\n\n    if (newsize == PySet_MINSIZE) {\n        /* A large table is shrinking, or we can't get any smaller. */\n        newtable = so->smalltable;\n        if (newtable == oldtable) {\n            if (so->fill == so->used) {\n                /* No dummies, so no point doing anything. */\n                return 0;\n            }\n            /* We're not going to resize it, but rebuild the\n               table anyway to purge old dummy entries.\n               Subtle:  This is *necessary* if fill==size,\n               as set_lookkey needs at least one virgin slot to\n               terminate failing searches.  If fill < size, it's\n               merely desirable, as dummies slow searches. */\n            assert(so->fill > so->used);\n            memcpy(small_copy, oldtable, sizeof(small_copy));\n            oldtable = small_copy;\n        }\n    }\n    else {\n        newtable = PyMem_NEW(setentry, newsize);\n        if (newtable == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n    }\n\n    /* Make the set empty, using the new table. */\n    assert(newtable != oldtable);\n    memset(newtable, 0, sizeof(setentry) * newsize);\n    so->mask = newsize - 1;\n    so->table = newtable;\n\n    /* Copy the data over; this is refcount-neutral for active entries;\n       dummy entries aren't copied over, of course */\n    newmask = (size_t)so->mask;\n    if (so->fill == so->used) {\n        for (entry = oldtable; entry <= oldtable + oldmask; entry++) {\n            if (entry->key != NULL) {\n                set_insert_clean(newtable, newmask, entry->key, entry->hash);\n            }\n        }\n    } else {\n        so->fill = so->used;\n        for (entry = oldtable; entry <= oldtable + oldmask; entry++) {\n            if (entry->key != NULL && entry->key != dummy) {\n                set_insert_clean(newtable, newmask, entry->key, entry->hash);\n            }\n        }\n    }\n\n    if (is_oldtable_malloced)\n        PyMem_Free(oldtable);\n    return 0;\n}\n\nstatic int\nset_contains_entry(PySetObject *so, PyObject *key, Py_hash_t hash)\n{\n    setentry *entry;\n\n    entry = set_lookkey(so, key, hash);\n    if (entry != NULL)\n        return entry->key != NULL;\n    return -1;\n}\n\n#define DISCARD_NOTFOUND 0\n#define DISCARD_FOUND 1\n\nstatic int\nset_discard_entry(PySetObject *so, PyObject *key, Py_hash_t hash)\n{\n    setentry *entry;\n    PyObject *old_key;\n\n    entry = set_lookkey(so, key, hash);\n    if (entry == NULL)\n        return -1;\n    if (entry->key == NULL)\n        return DISCARD_NOTFOUND;\n    old_key = entry->key;\n    entry->key = dummy;\n    entry->hash = -1;\n    so->used--;\n    Py_DECREF(old_key);\n    return DISCARD_FOUND;\n}\n\nstatic int\nset_add_key(PySetObject *so, PyObject *key)\n{\n    Py_hash_t hash;\n\n    if (!PyUnicode_CheckExact(key) ||\n        (hash = _PyASCIIObject_CAST(key)->hash) == -1) {\n        hash = PyObject_Hash(key);\n        if (hash == -1)\n            return -1;\n    }\n    return set_add_entry(so, key, hash);\n}\n\nstatic int\nset_contains_key(PySetObject *so, PyObject *key)\n{\n    Py_hash_t hash;\n\n    if (!PyUnicode_CheckExact(key) ||\n        (hash = _PyASCIIObject_CAST(key)->hash) == -1) {\n        hash = PyObject_Hash(key);\n        if (hash == -1)\n            return -1;\n    }\n    return set_contains_entry(so, key, hash);\n}\n\nstatic int\nset_discard_key(PySetObject *so, PyObject *key)\n{\n    Py_hash_t hash;\n\n    if (!PyUnicode_CheckExact(key) ||\n        (hash = _PyASCIIObject_CAST(key)->hash) == -1) {\n        hash = PyObject_Hash(key);\n        if (hash == -1)\n            return -1;\n    }\n    return set_discard_entry(so, key, hash);\n}\n\nstatic void\nset_empty_to_minsize(PySetObject *so)\n{\n    memset(so->smalltable, 0, sizeof(so->smalltable));\n    so->fill = 0;\n    so->used = 0;\n    so->mask = PySet_MINSIZE - 1;\n    so->table = so->smalltable;\n    so->hash = -1;\n}\n\nstatic int\nset_clear_internal(PySetObject *so)\n{\n    setentry *entry;\n    setentry *table = so->table;\n    Py_ssize_t fill = so->fill;\n    Py_ssize_t used = so->used;\n    int table_is_malloced = table != so->smalltable;\n    setentry small_copy[PySet_MINSIZE];\n\n    assert (PyAnySet_Check(so));\n    assert(table != NULL);\n\n    /* This is delicate.  During the process of clearing the set,\n     * decrefs can cause the set to mutate.  To avoid fatal confusion\n     * (voice of experience), we have to make the set empty before\n     * clearing the slots, and never refer to anything via so->ref while\n     * clearing.\n     */\n    if (table_is_malloced)\n        set_empty_to_minsize(so);\n\n    else if (fill > 0) {\n        /* It's a small table with something that needs to be cleared.\n         * Afraid the only safe way is to copy the set entries into\n         * another small table first.\n         */\n        memcpy(small_copy, table, sizeof(small_copy));\n        table = small_copy;\n        set_empty_to_minsize(so);\n    }\n    /* else it's a small table that's already empty */\n\n    /* Now we can finally clear things.  If C had refcounts, we could\n     * assert that the refcount on table is 1 now, i.e. that this function\n     * has unique access to it, so decref side-effects can't alter it.\n     */\n    for (entry = table; used > 0; entry++) {\n        if (entry->key && entry->key != dummy) {\n            used--;\n            Py_DECREF(entry->key);\n        }\n    }\n\n    if (table_is_malloced)\n        PyMem_Free(table);\n    return 0;\n}\n\n/*\n * Iterate over a set table.  Use like so:\n *\n *     Py_ssize_t pos;\n *     setentry *entry;\n *     pos = 0;   # important!  pos should not otherwise be changed by you\n *     while (set_next(yourset, &pos, &entry)) {\n *              Refer to borrowed reference in entry->key.\n *     }\n *\n * CAUTION:  In general, it isn't safe to use set_next in a loop that\n * mutates the table.\n */\nstatic int\nset_next(PySetObject *so, Py_ssize_t *pos_ptr, setentry **entry_ptr)\n{\n    Py_ssize_t i;\n    Py_ssize_t mask;\n    setentry *entry;\n\n    assert (PyAnySet_Check(so));\n    i = *pos_ptr;\n    assert(i >= 0);\n    mask = so->mask;\n    entry = &so->table[i];\n    while (i <= mask && (entry->key == NULL || entry->key == dummy)) {\n        i++;\n        entry++;\n    }\n    *pos_ptr = i+1;\n    if (i > mask)\n        return 0;\n    assert(entry != NULL);\n    *entry_ptr = entry;\n    return 1;\n}\n\nstatic void\nset_dealloc(PySetObject *so)\n{\n    setentry *entry;\n    Py_ssize_t used = so->used;\n\n    /* bpo-31095: UnTrack is needed before calling any callbacks */\n    PyObject_GC_UnTrack(so);\n    Py_TRASHCAN_BEGIN(so, set_dealloc)\n    if (so->weakreflist != NULL)\n        PyObject_ClearWeakRefs((PyObject *) so);\n\n    for (entry = so->table; used > 0; entry++) {\n        if (entry->key && entry->key != dummy) {\n                used--;\n                Py_DECREF(entry->key);\n        }\n    }\n    if (so->table != so->smalltable)\n        PyMem_Free(so->table);\n    Py_TYPE(so)->tp_free(so);\n    Py_TRASHCAN_END\n}\n\nstatic PyObject *\nset_repr(PySetObject *so)\n{\n    PyObject *result=NULL, *keys, *listrepr, *tmp;\n    int status = Py_ReprEnter((PyObject*)so);\n\n    if (status != 0) {\n        if (status < 0)\n            return NULL;\n        return PyUnicode_FromFormat(\"%s(...)\", Py_TYPE(so)->tp_name);\n    }\n\n    /* shortcut for the empty set */\n    if (!so->used) {\n        Py_ReprLeave((PyObject*)so);\n        return PyUnicode_FromFormat(\"%s()\", Py_TYPE(so)->tp_name);\n    }\n\n    keys = PySequence_List((PyObject *)so);\n    if (keys == NULL)\n        goto done;\n\n    /* repr(keys)[1:-1] */\n    listrepr = PyObject_Repr(keys);\n    Py_DECREF(keys);\n    if (listrepr == NULL)\n        goto done;\n    tmp = PyUnicode_Substring(listrepr, 1, PyUnicode_GET_LENGTH(listrepr)-1);\n    Py_DECREF(listrepr);\n    if (tmp == NULL)\n        goto done;\n    listrepr = tmp;\n\n    if (!PySet_CheckExact(so))\n        result = PyUnicode_FromFormat(\"%s({%U})\",\n                                      Py_TYPE(so)->tp_name,\n                                      listrepr);\n    else\n        result = PyUnicode_FromFormat(\"{%U}\", listrepr);\n    Py_DECREF(listrepr);\ndone:\n    Py_ReprLeave((PyObject*)so);\n    return result;\n}\n\nstatic Py_ssize_t\nset_len(PyObject *so)\n{\n    return ((PySetObject *)so)->used;\n}\n\nstatic int\nset_merge(PySetObject *so, PyObject *otherset)\n{\n    PySetObject *other;\n    PyObject *key;\n    Py_ssize_t i;\n    setentry *so_entry;\n    setentry *other_entry;\n\n    assert (PyAnySet_Check(so));\n    assert (PyAnySet_Check(otherset));\n\n    other = (PySetObject*)otherset;\n    if (other == so || other->used == 0)\n        /* a.update(a) or a.update(set()); nothing to do */\n        return 0;\n    /* Do one big resize at the start, rather than\n     * incrementally resizing as we insert new keys.  Expect\n     * that there will be no (or few) overlapping keys.\n     */\n    if ((so->fill + other->used)*5 >= so->mask*3) {\n        if (set_table_resize(so, (so->used + other->used)*2) != 0)\n            return -1;\n    }\n    so_entry = so->table;\n    other_entry = other->table;\n\n    /* If our table is empty, and both tables have the same size, and\n       there are no dummies to eliminate, then just copy the pointers. */\n    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n        for (i = 0; i <= other->mask; i++, so_entry++, other_entry++) {\n            key = other_entry->key;\n            if (key != NULL) {\n                assert(so_entry->key == NULL);\n                so_entry->key = Py_NewRef(key);\n                so_entry->hash = other_entry->hash;\n            }\n        }\n        so->fill = other->fill;\n        so->used = other->used;\n        return 0;\n    }\n\n    /* If our table is empty, we can use set_insert_clean() */\n    if (so->fill == 0) {\n        setentry *newtable = so->table;\n        size_t newmask = (size_t)so->mask;\n        so->fill = other->used;\n        so->used = other->used;\n        for (i = other->mask + 1; i > 0 ; i--, other_entry++) {\n            key = other_entry->key;\n            if (key != NULL && key != dummy) {\n                set_insert_clean(newtable, newmask, Py_NewRef(key),\n                                 other_entry->hash);\n            }\n        }\n        return 0;\n    }\n\n    /* We can't assure there are no duplicates, so do normal insertions */\n    for (i = 0; i <= other->mask; i++) {\n        other_entry = &other->table[i];\n        key = other_entry->key;\n        if (key != NULL && key != dummy) {\n            if (set_add_entry(so, key, other_entry->hash))\n                return -1;\n        }\n    }\n    return 0;\n}\n\nstatic PyObject *\nset_pop(PySetObject *so, PyObject *Py_UNUSED(ignored))\n{\n    /* Make sure the search finger is in bounds */\n    setentry *entry = so->table + (so->finger & so->mask);\n    setentry *limit = so->table + so->mask;\n    PyObject *key;\n\n    if (so->used == 0) {\n        PyErr_SetString(PyExc_KeyError, \"pop from an empty set\");\n        return NULL;\n    }\n    while (entry->key == NULL || entry->key==dummy) {\n        entry++;\n        if (entry > limit)\n            entry = so->table;\n    }\n    key = entry->key;\n    entry->key = dummy;\n    entry->hash = -1;\n    so->used--;\n    so->finger = entry - so->table + 1;   /* next place to start */\n    return key;\n}\n\nPyDoc_STRVAR(pop_doc, \"Remove and return an arbitrary set element.\\n\\\nRaises KeyError if the set is empty.\");\n\nstatic int\nset_traverse(PySetObject *so, visitproc visit, void *arg)\n{\n    Py_ssize_t pos = 0;\n    setentry *entry;\n\n    while (set_next(so, &pos, &entry))\n        Py_VISIT(entry->key);\n    return 0;\n}\n\n/* Work to increase the bit dispersion for closely spaced hash values.\n   This is important because some use cases have many combinations of a\n   small number of elements with nearby hashes so that many distinct\n   combinations collapse to only a handful of distinct hash values. */\n\nstatic Py_uhash_t\n_shuffle_bits(Py_uhash_t h)\n{\n    return ((h ^ 89869747UL) ^ (h << 16)) * 3644798167UL;\n}\n\n/* Most of the constants in this hash algorithm are randomly chosen\n   large primes with \"interesting bit patterns\" and that passed tests\n   for good collision statistics on a variety of problematic datasets\n   including powersets and graph structures (such as David Eppstein's\n   graph recipes in Lib/test/test_set.py) */\n\nstatic Py_hash_t\nfrozenset_hash(PyObject *self)\n{\n    PySetObject *so = (PySetObject *)self;\n    Py_uhash_t hash = 0;\n    setentry *entry;\n\n    if (so->hash != -1)\n        return so->hash;\n\n    /* Xor-in shuffled bits from every entry's hash field because xor is\n       commutative and a frozenset hash should be independent of order.\n\n       For speed, include null entries and dummy entries and then\n       subtract out their effect afterwards so that the final hash\n       depends only on active entries.  This allows the code to be\n       vectorized by the compiler and it saves the unpredictable\n       branches that would arise when trying to exclude null and dummy\n       entries on every iteration. */\n\n    for (entry = so->table; entry <= &so->table[so->mask]; entry++)\n        hash ^= _shuffle_bits(entry->hash);\n\n    /* Remove the effect of an odd number of NULL entries */\n    if ((so->mask + 1 - so->fill) & 1)\n        hash ^= _shuffle_bits(0);\n\n    /* Remove the effect of an odd number of dummy entries */\n    if ((so->fill - so->used) & 1)\n        hash ^= _shuffle_bits(-1);\n\n    /* Factor in the number of active entries */\n    hash ^= ((Py_uhash_t)PySet_GET_SIZE(self) + 1) * 1927868237UL;\n\n    /* Disperse patterns arising in nested frozensets */\n    hash ^= (hash >> 11) ^ (hash >> 25);\n    hash = hash * 69069U + 907133923UL;\n\n    /* -1 is reserved as an error code */\n    if (hash == (Py_uhash_t)-1)\n        hash = 590923713UL;\n\n    so->hash = hash;\n    return hash;\n}\n\n/***** Set iterator type ***********************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    PySetObject *si_set; /* Set to NULL when iterator is exhausted */\n    Py_ssize_t si_used;\n    Py_ssize_t si_pos;\n    Py_ssize_t len;\n} setiterobject;\n\nstatic void\nsetiter_dealloc(setiterobject *si)\n{\n    /* bpo-31095: UnTrack is needed before calling any callbacks */\n    _PyObject_GC_UNTRACK(si);\n    Py_XDECREF(si->si_set);\n    PyObject_GC_Del(si);\n}\n\nstatic int\nsetiter_traverse(setiterobject *si, visitproc visit, void *arg)\n{\n    Py_VISIT(si->si_set);\n    return 0;\n}\n\nstatic PyObject *\nsetiter_len(setiterobject *si, PyObject *Py_UNUSED(ignored))\n{\n    Py_ssize_t len = 0;\n    if (si->si_set != NULL && si->si_used == si->si_set->used)\n        len = si->len;\n    return PyLong_FromSsize_t(len);\n}\n\nPyDoc_STRVAR(length_hint_doc, \"Private method returning an estimate of len(list(it)).\");\n\nstatic PyObject *setiter_iternext(setiterobject *si);\n\nstatic PyObject *\nsetiter_reduce(setiterobject *si, PyObject *Py_UNUSED(ignored))\n{\n    /* copy the iterator state */\n    setiterobject tmp = *si;\n    Py_XINCREF(tmp.si_set);\n\n    /* iterate the temporary into a list */\n    PyObject *list = PySequence_List((PyObject*)&tmp);\n    Py_XDECREF(tmp.si_set);\n    if (list == NULL) {\n        return NULL;\n    }\n    return Py_BuildValue(\"N(N)\", _PyEval_GetBuiltin(&_Py_ID(iter)), list);\n}\n\nPyDoc_STRVAR(reduce_doc, \"Return state information for pickling.\");\n\nstatic PyMethodDef setiter_methods[] = {\n    {\"__length_hint__\", (PyCFunction)setiter_len, METH_NOARGS, length_hint_doc},\n    {\"__reduce__\", (PyCFunction)setiter_reduce, METH_NOARGS, reduce_doc},\n    {NULL,              NULL}           /* sentinel */\n};\n\nstatic PyObject *setiter_iternext(setiterobject *si)\n{\n    PyObject *key;\n    Py_ssize_t i, mask;\n    setentry *entry;\n    PySetObject *so = si->si_set;\n\n    if (so == NULL)\n        return NULL;\n    assert (PyAnySet_Check(so));\n\n    if (si->si_used != so->used) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"Set changed size during iteration\");\n        si->si_used = -1; /* Make this state sticky */\n        return NULL;\n    }\n\n    i = si->si_pos;\n    assert(i>=0);\n    entry = so->table;\n    mask = so->mask;\n    while (i <= mask && (entry[i].key == NULL || entry[i].key == dummy))\n        i++;\n    si->si_pos = i+1;\n    if (i > mask)\n        goto fail;\n    si->len--;\n    key = entry[i].key;\n    return Py_NewRef(key);\n\nfail:\n    si->si_set = NULL;\n    Py_DECREF(so);\n    return NULL;\n}\n\nPyTypeObject PySetIter_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"set_iterator\",                             /* tp_name */\n    sizeof(setiterobject),                      /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    /* methods */\n    (destructor)setiter_dealloc,                /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,    /* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)setiter_traverse,             /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    PyObject_SelfIter,                          /* tp_iter */\n    (iternextfunc)setiter_iternext,             /* tp_iternext */\n    setiter_methods,                            /* tp_methods */\n    0,\n};\n\nstatic PyObject *\nset_iter(PySetObject *so)\n{\n    setiterobject *si = PyObject_GC_New(setiterobject, &PySetIter_Type);\n    if (si == NULL)\n        return NULL;\n    si->si_set = (PySetObject*)Py_NewRef(so);\n    si->si_used = so->used;\n    si->si_pos = 0;\n    si->len = so->used;\n    _PyObject_GC_TRACK(si);\n    return (PyObject *)si;\n}\n\nstatic int\nset_update_internal(PySetObject *so, PyObject *other)\n{\n    PyObject *key, *it;\n\n    if (PyAnySet_Check(other))\n        return set_merge(so, other);\n\n    if (PyDict_CheckExact(other)) {\n        PyObject *value;\n        Py_ssize_t pos = 0;\n        Py_hash_t hash;\n        Py_ssize_t dictsize = PyDict_GET_SIZE(other);\n\n        /* Do one big resize at the start, rather than\n        * incrementally resizing as we insert new keys.  Expect\n        * that there will be no (or few) overlapping keys.\n        */\n        if (dictsize < 0)\n            return -1;\n        if ((so->fill + dictsize)*5 >= so->mask*3) {\n            if (set_table_resize(so, (so->used + dictsize)*2) != 0)\n                return -1;\n        }\n        while (_PyDict_Next(other, &pos, &key, &value, &hash)) {\n            if (set_add_entry(so, key, hash))\n                return -1;\n        }\n        return 0;\n    }\n\n    it = PyObject_GetIter(other);\n    if (it == NULL)\n        return -1;\n\n    while ((key = PyIter_Next(it)) != NULL) {\n        if (set_add_key(so, key)) {\n            Py_DECREF(it);\n            Py_DECREF(key);\n            return -1;\n        }\n        Py_DECREF(key);\n    }\n    Py_DECREF(it);\n    if (PyErr_Occurred())\n        return -1;\n    return 0;\n}\n\nstatic PyObject *\nset_update(PySetObject *so, PyObject *args)\n{\n    Py_ssize_t i;\n\n    for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {\n        PyObject *other = PyTuple_GET_ITEM(args, i);\n        if (set_update_internal(so, other))\n            return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(update_doc,\n\"Update a set with the union of itself and others.\");\n\n/* XXX Todo:\n   If aligned memory allocations become available, make the\n   set object 64 byte aligned so that most of the fields\n   can be retrieved or updated in a single cache line.\n*/\n\nstatic PyObject *\nmake_new_set(PyTypeObject *type, PyObject *iterable)\n{\n    assert(PyType_Check(type));\n    PySetObject *so;\n\n    so = (PySetObject *)type->tp_alloc(type, 0);\n    if (so == NULL)\n        return NULL;\n\n    so->fill = 0;\n    so->used = 0;\n    so->mask = PySet_MINSIZE - 1;\n    so->table = so->smalltable;\n    so->hash = -1;\n    so->finger = 0;\n    so->weakreflist = NULL;\n\n    if (iterable != NULL) {\n        if (set_update_internal(so, iterable)) {\n            Py_DECREF(so);\n            return NULL;\n        }\n    }\n\n    return (PyObject *)so;\n}\n\nstatic PyObject *\nmake_new_set_basetype(PyTypeObject *type, PyObject *iterable)\n{\n    if (type != &PySet_Type && type != &PyFrozenSet_Type) {\n        if (PyType_IsSubtype(type, &PySet_Type))\n            type = &PySet_Type;\n        else\n            type = &PyFrozenSet_Type;\n    }\n    return make_new_set(type, iterable);\n}\n\nstatic PyObject *\nmake_new_frozenset(PyTypeObject *type, PyObject *iterable)\n{\n    if (type != &PyFrozenSet_Type) {\n        return make_new_set(type, iterable);\n    }\n\n    if (iterable != NULL && PyFrozenSet_CheckExact(iterable)) {\n        /* frozenset(f) is idempotent */\n        return Py_NewRef(iterable);\n    }\n    return make_new_set(type, iterable);\n}\n\nstatic PyObject *\nfrozenset_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyObject *iterable = NULL;\n\n    if ((type == &PyFrozenSet_Type ||\n         type->tp_init == PyFrozenSet_Type.tp_init) &&\n        !_PyArg_NoKeywords(\"frozenset\", kwds)) {\n        return NULL;\n    }\n\n    if (!PyArg_UnpackTuple(args, type->tp_name, 0, 1, &iterable)) {\n        return NULL;\n    }\n\n    return make_new_frozenset(type, iterable);\n}\n\nstatic PyObject *\nfrozenset_vectorcall(PyObject *type, PyObject * const*args,\n                     size_t nargsf, PyObject *kwnames)\n{\n    if (!_PyArg_NoKwnames(\"frozenset\", kwnames)) {\n        return NULL;\n    }\n\n    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);\n    if (!_PyArg_CheckPositional(\"frozenset\", nargs, 0, 1)) {\n        return NULL;\n    }\n\n    PyObject *iterable = (nargs ? args[0] : NULL);\n    return make_new_frozenset(_PyType_CAST(type), iterable);\n}\n\nstatic PyObject *\nset_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    return make_new_set(type, NULL);\n}\n\n/* set_swap_bodies() switches the contents of any two sets by moving their\n   internal data pointers and, if needed, copying the internal smalltables.\n   Semantically equivalent to:\n\n     t=set(a); a.clear(); a.update(b); b.clear(); b.update(t); del t\n\n   The function always succeeds and it leaves both objects in a stable state.\n   Useful for operations that update in-place (by allowing an intermediate\n   result to be swapped into one of the original inputs).\n*/\n\nstatic void\nset_swap_bodies(PySetObject *a, PySetObject *b)\n{\n    Py_ssize_t t;\n    setentry *u;\n    setentry tab[PySet_MINSIZE];\n    Py_hash_t h;\n\n    t = a->fill;     a->fill   = b->fill;        b->fill  = t;\n    t = a->used;     a->used   = b->used;        b->used  = t;\n    t = a->mask;     a->mask   = b->mask;        b->mask  = t;\n\n    u = a->table;\n    if (a->table == a->smalltable)\n        u = b->smalltable;\n    a->table  = b->table;\n    if (b->table == b->smalltable)\n        a->table = a->smalltable;\n    b->table = u;\n\n    if (a->table == a->smalltable || b->table == b->smalltable) {\n        memcpy(tab, a->smalltable, sizeof(tab));\n        memcpy(a->smalltable, b->smalltable, sizeof(tab));\n        memcpy(b->smalltable, tab, sizeof(tab));\n    }\n\n    if (PyType_IsSubtype(Py_TYPE(a), &PyFrozenSet_Type)  &&\n        PyType_IsSubtype(Py_TYPE(b), &PyFrozenSet_Type)) {\n        h = a->hash;     a->hash = b->hash;  b->hash = h;\n    } else {\n        a->hash = -1;\n        b->hash = -1;\n    }\n}\n\nstatic PyObject *\nset_copy(PySetObject *so, PyObject *Py_UNUSED(ignored))\n{\n    return make_new_set_basetype(Py_TYPE(so), (PyObject *)so);\n}\n\nstatic PyObject *\nfrozenset_copy(PySetObject *so, PyObject *Py_UNUSED(ignored))\n{\n    if (PyFrozenSet_CheckExact(so)) {\n        return Py_NewRef(so);\n    }\n    return set_copy(so, NULL);\n}\n\nPyDoc_STRVAR(copy_doc, \"Return a shallow copy of a set.\");\n\nstatic PyObject *\nset_clear(PySetObject *so, PyObject *Py_UNUSED(ignored))\n{\n    set_clear_internal(so);\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(clear_doc, \"Remove all elements from this set.\");\n\nstatic PyObject *\nset_union(PySetObject *so, PyObject *args)\n{\n    PySetObject *result;\n    PyObject *other;\n    Py_ssize_t i;\n\n    result = (PySetObject *)set_copy(so, NULL);\n    if (result == NULL)\n        return NULL;\n\n    for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {\n        other = PyTuple_GET_ITEM(args, i);\n        if ((PyObject *)so == other)\n            continue;\n        if (set_update_internal(result, other)) {\n            Py_DECREF(result);\n            return NULL;\n        }\n    }\n    return (PyObject *)result;\n}\n\nPyDoc_STRVAR(union_doc,\n \"Return the union of sets as a new set.\\n\\\n\\n\\\n(i.e. all elements that are in either set.)\");\n\nstatic PyObject *\nset_or(PySetObject *so, PyObject *other)\n{\n    PySetObject *result;\n\n    if (!PyAnySet_Check(so) || !PyAnySet_Check(other))\n        Py_RETURN_NOTIMPLEMENTED;\n\n    result = (PySetObject *)set_copy(so, NULL);\n    if (result == NULL)\n        return NULL;\n    if ((PyObject *)so == other)\n        return (PyObject *)result;\n    if (set_update_internal(result, other)) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    return (PyObject *)result;\n}\n\nstatic PyObject *\nset_ior(PySetObject *so, PyObject *other)\n{\n    if (!PyAnySet_Check(other))\n        Py_RETURN_NOTIMPLEMENTED;\n\n    if (set_update_internal(so, other))\n        return NULL;\n    return Py_NewRef(so);\n}\n\nstatic PyObject *\nset_intersection(PySetObject *so, PyObject *other)\n{\n    PySetObject *result;\n    PyObject *key, *it, *tmp;\n    Py_hash_t hash;\n    int rv;\n\n    if ((PyObject *)so == other)\n        return set_copy(so, NULL);\n\n    result = (PySetObject *)make_new_set_basetype(Py_TYPE(so), NULL);\n    if (result == NULL)\n        return NULL;\n\n    if (PyAnySet_Check(other)) {\n        Py_ssize_t pos = 0;\n        setentry *entry;\n\n        if (PySet_GET_SIZE(other) > PySet_GET_SIZE(so)) {\n            tmp = (PyObject *)so;\n            so = (PySetObject *)other;\n            other = tmp;\n        }\n\n        while (set_next((PySetObject *)other, &pos, &entry)) {\n            key = entry->key;\n            hash = entry->hash;\n            Py_INCREF(key);\n            rv = set_contains_entry(so, key, hash);\n            if (rv < 0) {\n                Py_DECREF(result);\n                Py_DECREF(key);\n                return NULL;\n            }\n            if (rv) {\n                if (set_add_entry(result, key, hash)) {\n                    Py_DECREF(result);\n                    Py_DECREF(key);\n                    return NULL;\n                }\n            }\n            Py_DECREF(key);\n        }\n        return (PyObject *)result;\n    }\n\n    it = PyObject_GetIter(other);\n    if (it == NULL) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    while ((key = PyIter_Next(it)) != NULL) {\n        hash = PyObject_Hash(key);\n        if (hash == -1)\n            goto error;\n        rv = set_contains_entry(so, key, hash);\n        if (rv < 0)\n            goto error;\n        if (rv) {\n            if (set_add_entry(result, key, hash))\n                goto error;\n            if (PySet_GET_SIZE(result) >= PySet_GET_SIZE(so)) {\n                Py_DECREF(key);\n                break;\n            }\n        }\n        Py_DECREF(key);\n    }\n    Py_DECREF(it);\n    if (PyErr_Occurred()) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    return (PyObject *)result;\n  error:\n    Py_DECREF(it);\n    Py_DECREF(result);\n    Py_DECREF(key);\n    return NULL;\n}\n\nstatic PyObject *\nset_intersection_multi(PySetObject *so, PyObject *args)\n{\n    Py_ssize_t i;\n\n    if (PyTuple_GET_SIZE(args) == 0)\n        return set_copy(so, NULL);\n\n    PyObject *result = Py_NewRef(so);\n    for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {\n        PyObject *other = PyTuple_GET_ITEM(args, i);\n        PyObject *newresult = set_intersection((PySetObject *)result, other);\n        if (newresult == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        Py_SETREF(result, newresult);\n    }\n    return result;\n}\n\nPyDoc_STRVAR(intersection_doc,\n\"Return the intersection of two sets as a new set.\\n\\\n\\n\\\n(i.e. all elements that are in both sets.)\");\n\nstatic PyObject *\nset_intersection_update(PySetObject *so, PyObject *other)\n{\n    PyObject *tmp;\n\n    tmp = set_intersection(so, other);\n    if (tmp == NULL)\n        return NULL;\n    set_swap_bodies(so, (PySetObject *)tmp);\n    Py_DECREF(tmp);\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nset_intersection_update_multi(PySetObject *so, PyObject *args)\n{\n    PyObject *tmp;\n\n    tmp = set_intersection_multi(so, args);\n    if (tmp == NULL)\n        return NULL;\n    set_swap_bodies(so, (PySetObject *)tmp);\n    Py_DECREF(tmp);\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(intersection_update_doc,\n\"Update a set with the intersection of itself and another.\");\n\nstatic PyObject *\nset_and(PySetObject *so, PyObject *other)\n{\n    if (!PyAnySet_Check(so) || !PyAnySet_Check(other))\n        Py_RETURN_NOTIMPLEMENTED;\n    return set_intersection(so, other);\n}\n\nstatic PyObject *\nset_iand(PySetObject *so, PyObject *other)\n{\n    PyObject *result;\n\n    if (!PyAnySet_Check(other))\n        Py_RETURN_NOTIMPLEMENTED;\n    result = set_intersection_update(so, other);\n    if (result == NULL)\n        return NULL;\n    Py_DECREF(result);\n    return Py_NewRef(so);\n}\n\nstatic PyObject *\nset_isdisjoint(PySetObject *so, PyObject *other)\n{\n    PyObject *key, *it, *tmp;\n    int rv;\n\n    if ((PyObject *)so == other) {\n        if (PySet_GET_SIZE(so) == 0)\n            Py_RETURN_TRUE;\n        else\n            Py_RETURN_FALSE;\n    }\n\n    if (PyAnySet_CheckExact(other)) {\n        Py_ssize_t pos = 0;\n        setentry *entry;\n\n        if (PySet_GET_SIZE(other) > PySet_GET_SIZE(so)) {\n            tmp = (PyObject *)so;\n            so = (PySetObject *)other;\n            other = tmp;\n        }\n        while (set_next((PySetObject *)other, &pos, &entry)) {\n            PyObject *key = entry->key;\n            Py_INCREF(key);\n            rv = set_contains_entry(so, key, entry->hash);\n            Py_DECREF(key);\n            if (rv < 0) {\n                return NULL;\n            }\n            if (rv) {\n                Py_RETURN_FALSE;\n            }\n        }\n        Py_RETURN_TRUE;\n    }\n\n    it = PyObject_GetIter(other);\n    if (it == NULL)\n        return NULL;\n\n    while ((key = PyIter_Next(it)) != NULL) {\n        rv = set_contains_key(so, key);\n        Py_DECREF(key);\n        if (rv < 0) {\n            Py_DECREF(it);\n            return NULL;\n        }\n        if (rv) {\n            Py_DECREF(it);\n            Py_RETURN_FALSE;\n        }\n    }\n    Py_DECREF(it);\n    if (PyErr_Occurred())\n        return NULL;\n    Py_RETURN_TRUE;\n}\n\nPyDoc_STRVAR(isdisjoint_doc,\n\"Return True if two sets have a null intersection.\");\n\nstatic int\nset_difference_update_internal(PySetObject *so, PyObject *other)\n{\n    if ((PyObject *)so == other)\n        return set_clear_internal(so);\n\n    if (PyAnySet_Check(other)) {\n        setentry *entry;\n        Py_ssize_t pos = 0;\n\n        /* Optimization:  When the other set is more than 8 times\n           larger than the base set, replace the other set with\n           intersection of the two sets.\n        */\n        if ((PySet_GET_SIZE(other) >> 3) > PySet_GET_SIZE(so)) {\n            other = set_intersection(so, other);\n            if (other == NULL)\n                return -1;\n        } else {\n            Py_INCREF(other);\n        }\n\n        while (set_next((PySetObject *)other, &pos, &entry)) {\n            PyObject *key = entry->key;\n            Py_INCREF(key);\n            if (set_discard_entry(so, key, entry->hash) < 0) {\n                Py_DECREF(other);\n                Py_DECREF(key);\n                return -1;\n            }\n            Py_DECREF(key);\n        }\n\n        Py_DECREF(other);\n    } else {\n        PyObject *key, *it;\n        it = PyObject_GetIter(other);\n        if (it == NULL)\n            return -1;\n\n        while ((key = PyIter_Next(it)) != NULL) {\n            if (set_discard_key(so, key) < 0) {\n                Py_DECREF(it);\n                Py_DECREF(key);\n                return -1;\n            }\n            Py_DECREF(key);\n        }\n        Py_DECREF(it);\n        if (PyErr_Occurred())\n            return -1;\n    }\n    /* If more than 1/4th are dummies, then resize them away. */\n    if ((size_t)(so->fill - so->used) <= (size_t)so->mask / 4)\n        return 0;\n    return set_table_resize(so, so->used>50000 ? so->used*2 : so->used*4);\n}\n\nstatic PyObject *\nset_difference_update(PySetObject *so, PyObject *args)\n{\n    Py_ssize_t i;\n\n    for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {\n        PyObject *other = PyTuple_GET_ITEM(args, i);\n        if (set_difference_update_internal(so, other))\n            return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(difference_update_doc,\n\"Remove all elements of another set from this set.\");\n\nstatic PyObject *\nset_copy_and_difference(PySetObject *so, PyObject *other)\n{\n    PyObject *result;\n\n    result = set_copy(so, NULL);\n    if (result == NULL)\n        return NULL;\n    if (set_difference_update_internal((PySetObject *) result, other) == 0)\n        return result;\n    Py_DECREF(result);\n    return NULL;\n}\n\nstatic PyObject *\nset_difference(PySetObject *so, PyObject *other)\n{\n    PyObject *result;\n    PyObject *key;\n    Py_hash_t hash;\n    setentry *entry;\n    Py_ssize_t pos = 0, other_size;\n    int rv;\n\n    if (PyAnySet_Check(other)) {\n        other_size = PySet_GET_SIZE(other);\n    }\n    else if (PyDict_CheckExact(other)) {\n        other_size = PyDict_GET_SIZE(other);\n    }\n    else {\n        return set_copy_and_difference(so, other);\n    }\n\n    /* If len(so) much more than len(other), it's more efficient to simply copy\n     * so and then iterate other looking for common elements. */\n    if ((PySet_GET_SIZE(so) >> 2) > other_size) {\n        return set_copy_and_difference(so, other);\n    }\n\n    result = make_new_set_basetype(Py_TYPE(so), NULL);\n    if (result == NULL)\n        return NULL;\n\n    if (PyDict_CheckExact(other)) {\n        while (set_next(so, &pos, &entry)) {\n            key = entry->key;\n            hash = entry->hash;\n            Py_INCREF(key);\n            rv = _PyDict_Contains_KnownHash(other, key, hash);\n            if (rv < 0) {\n                Py_DECREF(result);\n                Py_DECREF(key);\n                return NULL;\n            }\n            if (!rv) {\n                if (set_add_entry((PySetObject *)result, key, hash)) {\n                    Py_DECREF(result);\n                    Py_DECREF(key);\n                    return NULL;\n                }\n            }\n            Py_DECREF(key);\n        }\n        return result;\n    }\n\n    /* Iterate over so, checking for common elements in other. */\n    while (set_next(so, &pos, &entry)) {\n        key = entry->key;\n        hash = entry->hash;\n        Py_INCREF(key);\n        rv = set_contains_entry((PySetObject *)other, key, hash);\n        if (rv < 0) {\n            Py_DECREF(result);\n            Py_DECREF(key);\n            return NULL;\n        }\n        if (!rv) {\n            if (set_add_entry((PySetObject *)result, key, hash)) {\n                Py_DECREF(result);\n                Py_DECREF(key);\n                return NULL;\n            }\n        }\n        Py_DECREF(key);\n    }\n    return result;\n}\n\nstatic PyObject *\nset_difference_multi(PySetObject *so, PyObject *args)\n{\n    Py_ssize_t i;\n    PyObject *result, *other;\n\n    if (PyTuple_GET_SIZE(args) == 0)\n        return set_copy(so, NULL);\n\n    other = PyTuple_GET_ITEM(args, 0);\n    result = set_difference(so, other);\n    if (result == NULL)\n        return NULL;\n\n    for (i=1 ; i<PyTuple_GET_SIZE(args) ; i++) {\n        other = PyTuple_GET_ITEM(args, i);\n        if (set_difference_update_internal((PySetObject *)result, other)) {\n            Py_DECREF(result);\n            return NULL;\n        }\n    }\n    return result;\n}\n\nPyDoc_STRVAR(difference_doc,\n\"Return the difference of two or more sets as a new set.\\n\\\n\\n\\\n(i.e. all elements that are in this set but not the others.)\");\nstatic PyObject *\nset_sub(PySetObject *so, PyObject *other)\n{\n    if (!PyAnySet_Check(so) || !PyAnySet_Check(other))\n        Py_RETURN_NOTIMPLEMENTED;\n    return set_difference(so, other);\n}\n\nstatic PyObject *\nset_isub(PySetObject *so, PyObject *other)\n{\n    if (!PyAnySet_Check(other))\n        Py_RETURN_NOTIMPLEMENTED;\n    if (set_difference_update_internal(so, other))\n        return NULL;\n    return Py_NewRef(so);\n}\n\nstatic PyObject *\nset_symmetric_difference_update(PySetObject *so, PyObject *other)\n{\n    PySetObject *otherset;\n    PyObject *key;\n    Py_ssize_t pos = 0;\n    Py_hash_t hash;\n    setentry *entry;\n    int rv;\n\n    if ((PyObject *)so == other)\n        return set_clear(so, NULL);\n\n    if (PyDict_CheckExact(other)) {\n        PyObject *value;\n        while (_PyDict_Next(other, &pos, &key, &value, &hash)) {\n            Py_INCREF(key);\n            rv = set_discard_entry(so, key, hash);\n            if (rv < 0) {\n                Py_DECREF(key);\n                return NULL;\n            }\n            if (rv == DISCARD_NOTFOUND) {\n                if (set_add_entry(so, key, hash)) {\n                    Py_DECREF(key);\n                    return NULL;\n                }\n            }\n            Py_DECREF(key);\n        }\n        Py_RETURN_NONE;\n    }\n\n    if (PyAnySet_Check(other)) {\n        otherset = (PySetObject *)Py_NewRef(other);\n    } else {\n        otherset = (PySetObject *)make_new_set_basetype(Py_TYPE(so), other);\n        if (otherset == NULL)\n            return NULL;\n    }\n\n    while (set_next(otherset, &pos, &entry)) {\n        key = entry->key;\n        hash = entry->hash;\n        Py_INCREF(key);\n        rv = set_discard_entry(so, key, hash);\n        if (rv < 0) {\n            Py_DECREF(otherset);\n            Py_DECREF(key);\n            return NULL;\n        }\n        if (rv == DISCARD_NOTFOUND) {\n            if (set_add_entry(so, key, hash)) {\n                Py_DECREF(otherset);\n                Py_DECREF(key);\n                return NULL;\n            }\n        }\n        Py_DECREF(key);\n    }\n    Py_DECREF(otherset);\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(symmetric_difference_update_doc,\n\"Update a set with the symmetric difference of itself and another.\");\n\nstatic PyObject *\nset_symmetric_difference(PySetObject *so, PyObject *other)\n{\n    PyObject *rv;\n    PySetObject *otherset;\n\n    otherset = (PySetObject *)make_new_set_basetype(Py_TYPE(so), other);\n    if (otherset == NULL)\n        return NULL;\n    rv = set_symmetric_difference_update(otherset, (PyObject *)so);\n    if (rv == NULL) {\n        Py_DECREF(otherset);\n        return NULL;\n    }\n    Py_DECREF(rv);\n    return (PyObject *)otherset;\n}\n\nPyDoc_STRVAR(symmetric_difference_doc,\n\"Return the symmetric difference of two sets as a new set.\\n\\\n\\n\\\n(i.e. all elements that are in exactly one of the sets.)\");\n\nstatic PyObject *\nset_xor(PySetObject *so, PyObject *other)\n{\n    if (!PyAnySet_Check(so) || !PyAnySet_Check(other))\n        Py_RETURN_NOTIMPLEMENTED;\n    return set_symmetric_difference(so, other);\n}\n\nstatic PyObject *\nset_ixor(PySetObject *so, PyObject *other)\n{\n    PyObject *result;\n\n    if (!PyAnySet_Check(other))\n        Py_RETURN_NOTIMPLEMENTED;\n    result = set_symmetric_difference_update(so, other);\n    if (result == NULL)\n        return NULL;\n    Py_DECREF(result);\n    return Py_NewRef(so);\n}\n\nstatic PyObject *\nset_issubset(PySetObject *so, PyObject *other)\n{\n    setentry *entry;\n    Py_ssize_t pos = 0;\n    int rv;\n\n    if (!PyAnySet_Check(other)) {\n        PyObject *tmp = set_intersection(so, other);\n        if (tmp == NULL) {\n            return NULL;\n        }\n        int result = (PySet_GET_SIZE(tmp) == PySet_GET_SIZE(so));\n        Py_DECREF(tmp);\n        return PyBool_FromLong(result);\n    }\n    if (PySet_GET_SIZE(so) > PySet_GET_SIZE(other))\n        Py_RETURN_FALSE;\n\n    while (set_next(so, &pos, &entry)) {\n        PyObject *key = entry->key;\n        Py_INCREF(key);\n        rv = set_contains_entry((PySetObject *)other, key, entry->hash);\n        Py_DECREF(key);\n        if (rv < 0) {\n            return NULL;\n        }\n        if (!rv) {\n            Py_RETURN_FALSE;\n        }\n    }\n    Py_RETURN_TRUE;\n}\n\nPyDoc_STRVAR(issubset_doc,\n\"issubset($self, other, /)\\n\\\n--\\n\\\n\\n\\\nTest whether every element in the set is in other.\");\n\nstatic PyObject *\nset_issuperset(PySetObject *so, PyObject *other)\n{\n    if (PyAnySet_Check(other)) {\n        return set_issubset((PySetObject *)other, (PyObject *)so);\n    }\n\n    PyObject *key, *it = PyObject_GetIter(other);\n    if (it == NULL) {\n        return NULL;\n    }\n    while ((key = PyIter_Next(it)) != NULL) {\n        int rv = set_contains_key(so, key);\n        Py_DECREF(key);\n        if (rv < 0) {\n            Py_DECREF(it);\n            return NULL;\n        }\n        if (!rv) {\n            Py_DECREF(it);\n            Py_RETURN_FALSE;\n        }\n    }\n    Py_DECREF(it);\n    if (PyErr_Occurred()) {\n        return NULL;\n    }\n    Py_RETURN_TRUE;\n}\n\nPyDoc_STRVAR(issuperset_doc,\n\"issuperset($self, other, /)\\n\\\n--\\n\\\n\\n\\\nTest whether every element in other is in the set.\");\n\nstatic PyObject *\nset_richcompare(PySetObject *v, PyObject *w, int op)\n{\n    PyObject *r1;\n    int r2;\n\n    if(!PyAnySet_Check(w))\n        Py_RETURN_NOTIMPLEMENTED;\n\n    switch (op) {\n    case Py_EQ:\n        if (PySet_GET_SIZE(v) != PySet_GET_SIZE(w))\n            Py_RETURN_FALSE;\n        if (v->hash != -1  &&\n            ((PySetObject *)w)->hash != -1 &&\n            v->hash != ((PySetObject *)w)->hash)\n            Py_RETURN_FALSE;\n        return set_issubset(v, w);\n    case Py_NE:\n        r1 = set_richcompare(v, w, Py_EQ);\n        if (r1 == NULL)\n            return NULL;\n        r2 = PyObject_IsTrue(r1);\n        Py_DECREF(r1);\n        if (r2 < 0)\n            return NULL;\n        return PyBool_FromLong(!r2);\n    case Py_LE:\n        return set_issubset(v, w);\n    case Py_GE:\n        return set_issuperset(v, w);\n    case Py_LT:\n        if (PySet_GET_SIZE(v) >= PySet_GET_SIZE(w))\n            Py_RETURN_FALSE;\n        return set_issubset(v, w);\n    case Py_GT:\n        if (PySet_GET_SIZE(v) <= PySet_GET_SIZE(w))\n            Py_RETURN_FALSE;\n        return set_issuperset(v, w);\n    }\n    Py_RETURN_NOTIMPLEMENTED;\n}\n\nstatic PyObject *\nset_add(PySetObject *so, PyObject *key)\n{\n    if (set_add_key(so, key))\n        return NULL;\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(add_doc,\n\"Add an element to a set.\\n\\\n\\n\\\nThis has no effect if the element is already present.\");\n\nstatic int\nset_contains(PySetObject *so, PyObject *key)\n{\n    PyObject *tmpkey;\n    int rv;\n\n    rv = set_contains_key(so, key);\n    if (rv < 0) {\n        if (!PySet_Check(key) || !PyErr_ExceptionMatches(PyExc_TypeError))\n            return -1;\n        PyErr_Clear();\n        tmpkey = make_new_set(&PyFrozenSet_Type, key);\n        if (tmpkey == NULL)\n            return -1;\n        rv = set_contains_key(so, tmpkey);\n        Py_DECREF(tmpkey);\n    }\n    return rv;\n}\n\nstatic PyObject *\nset_direct_contains(PySetObject *so, PyObject *key)\n{\n    long result;\n\n    result = set_contains(so, key);\n    if (result < 0)\n        return NULL;\n    return PyBool_FromLong(result);\n}\n\nPyDoc_STRVAR(contains_doc, \"x.__contains__(y) <==> y in x.\");\n\nstatic PyObject *\nset_remove(PySetObject *so, PyObject *key)\n{\n    PyObject *tmpkey;\n    int rv;\n\n    rv = set_discard_key(so, key);\n    if (rv < 0) {\n        if (!PySet_Check(key) || !PyErr_ExceptionMatches(PyExc_TypeError))\n            return NULL;\n        PyErr_Clear();\n        tmpkey = make_new_set(&PyFrozenSet_Type, key);\n        if (tmpkey == NULL)\n            return NULL;\n        rv = set_discard_key(so, tmpkey);\n        Py_DECREF(tmpkey);\n        if (rv < 0)\n            return NULL;\n    }\n\n    if (rv == DISCARD_NOTFOUND) {\n        _PyErr_SetKeyError(key);\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(remove_doc,\n\"Remove an element from a set; it must be a member.\\n\\\n\\n\\\nIf the element is not a member, raise a KeyError.\");\n\nstatic PyObject *\nset_discard(PySetObject *so, PyObject *key)\n{\n    PyObject *tmpkey;\n    int rv;\n\n    rv = set_discard_key(so, key);\n    if (rv < 0) {\n        if (!PySet_Check(key) || !PyErr_ExceptionMatches(PyExc_TypeError))\n            return NULL;\n        PyErr_Clear();\n        tmpkey = make_new_set(&PyFrozenSet_Type, key);\n        if (tmpkey == NULL)\n            return NULL;\n        rv = set_discard_key(so, tmpkey);\n        Py_DECREF(tmpkey);\n        if (rv < 0)\n            return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(discard_doc,\n\"Remove an element from a set if it is a member.\\n\\\n\\n\\\nUnlike set.remove(), the discard() method does not raise\\n\\\nan exception when an element is missing from the set.\");\n\nstatic PyObject *\nset_reduce(PySetObject *so, PyObject *Py_UNUSED(ignored))\n{\n    PyObject *keys=NULL, *args=NULL, *result=NULL, *state=NULL;\n\n    keys = PySequence_List((PyObject *)so);\n    if (keys == NULL)\n        goto done;\n    args = PyTuple_Pack(1, keys);\n    if (args == NULL)\n        goto done;\n    state = _PyObject_GetState((PyObject *)so);\n    if (state == NULL)\n        goto done;\n    result = PyTuple_Pack(3, Py_TYPE(so), args, state);\ndone:\n    Py_XDECREF(args);\n    Py_XDECREF(keys);\n    Py_XDECREF(state);\n    return result;\n}\n\nstatic PyObject *\nset_sizeof(PySetObject *so, PyObject *Py_UNUSED(ignored))\n{\n    size_t res = _PyObject_SIZE(Py_TYPE(so));\n    if (so->table != so->smalltable) {\n        res += ((size_t)so->mask + 1) * sizeof(setentry);\n    }\n    return PyLong_FromSize_t(res);\n}\n\nPyDoc_STRVAR(sizeof_doc, \"S.__sizeof__() -> size of S in memory, in bytes\");\nstatic int\nset_init(PySetObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *iterable = NULL;\n\n     if (!_PyArg_NoKeywords(\"set\", kwds))\n        return -1;\n    if (!PyArg_UnpackTuple(args, Py_TYPE(self)->tp_name, 0, 1, &iterable))\n        return -1;\n    if (self->fill)\n        set_clear_internal(self);\n    self->hash = -1;\n    if (iterable == NULL)\n        return 0;\n    return set_update_internal(self, iterable);\n}\n\nstatic PyObject*\nset_vectorcall(PyObject *type, PyObject * const*args,\n               size_t nargsf, PyObject *kwnames)\n{\n    assert(PyType_Check(type));\n\n    if (!_PyArg_NoKwnames(\"set\", kwnames)) {\n        return NULL;\n    }\n\n    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);\n    if (!_PyArg_CheckPositional(\"set\", nargs, 0, 1)) {\n        return NULL;\n    }\n\n    if (nargs) {\n        return make_new_set(_PyType_CAST(type), args[0]);\n    }\n\n    return make_new_set(_PyType_CAST(type), NULL);\n}\n\nstatic PySequenceMethods set_as_sequence = {\n    set_len,                            /* sq_length */\n    0,                                  /* sq_concat */\n    0,                                  /* sq_repeat */\n    0,                                  /* sq_item */\n    0,                                  /* sq_slice */\n    0,                                  /* sq_ass_item */\n    0,                                  /* sq_ass_slice */\n    (objobjproc)set_contains,           /* sq_contains */\n};\n\n/* set object ********************************************************/\n\n#ifdef Py_DEBUG\nstatic PyObject *test_c_api(PySetObject *so, PyObject *Py_UNUSED(ignored));\n\nPyDoc_STRVAR(test_c_api_doc, \"Exercises C API.  Returns True.\\n\\\nAll is well if assertions don't fail.\");\n#endif\n\nstatic PyMethodDef set_methods[] = {\n    {\"add\",             (PyCFunction)set_add,           METH_O,\n     add_doc},\n    {\"clear\",           (PyCFunction)set_clear,         METH_NOARGS,\n     clear_doc},\n    {\"__contains__\",(PyCFunction)set_direct_contains,           METH_O | METH_COEXIST,\n     contains_doc},\n    {\"copy\",            (PyCFunction)set_copy,          METH_NOARGS,\n     copy_doc},\n    {\"discard\",         (PyCFunction)set_discard,       METH_O,\n     discard_doc},\n    {\"difference\",      (PyCFunction)set_difference_multi,      METH_VARARGS,\n     difference_doc},\n    {\"difference_update\",       (PyCFunction)set_difference_update,     METH_VARARGS,\n     difference_update_doc},\n    {\"intersection\",(PyCFunction)set_intersection_multi,        METH_VARARGS,\n     intersection_doc},\n    {\"intersection_update\",(PyCFunction)set_intersection_update_multi,          METH_VARARGS,\n     intersection_update_doc},\n    {\"isdisjoint\",      (PyCFunction)set_isdisjoint,    METH_O,\n     isdisjoint_doc},\n    {\"issubset\",        (PyCFunction)set_issubset,      METH_O,\n     issubset_doc},\n    {\"issuperset\",      (PyCFunction)set_issuperset,    METH_O,\n     issuperset_doc},\n    {\"pop\",             (PyCFunction)set_pop,           METH_NOARGS,\n     pop_doc},\n    {\"__reduce__\",      (PyCFunction)set_reduce,        METH_NOARGS,\n     reduce_doc},\n    {\"remove\",          (PyCFunction)set_remove,        METH_O,\n     remove_doc},\n    {\"__sizeof__\",      (PyCFunction)set_sizeof,        METH_NOARGS,\n     sizeof_doc},\n    {\"symmetric_difference\",(PyCFunction)set_symmetric_difference,      METH_O,\n     symmetric_difference_doc},\n    {\"symmetric_difference_update\",(PyCFunction)set_symmetric_difference_update,        METH_O,\n     symmetric_difference_update_doc},\n#ifdef Py_DEBUG\n    {\"test_c_api\",      (PyCFunction)test_c_api,        METH_NOARGS,\n     test_c_api_doc},\n#endif\n    {\"union\",           (PyCFunction)set_union,         METH_VARARGS,\n     union_doc},\n    {\"update\",          (PyCFunction)set_update,        METH_VARARGS,\n     update_doc},\n    {\"__class_getitem__\", Py_GenericAlias, METH_O|METH_CLASS, PyDoc_STR(\"See PEP 585\")},\n    {NULL,              NULL}   /* sentinel */\n};\n\nstatic PyNumberMethods set_as_number = {\n    0,                                  /*nb_add*/\n    (binaryfunc)set_sub,                /*nb_subtract*/\n    0,                                  /*nb_multiply*/\n    0,                                  /*nb_remainder*/\n    0,                                  /*nb_divmod*/\n    0,                                  /*nb_power*/\n    0,                                  /*nb_negative*/\n    0,                                  /*nb_positive*/\n    0,                                  /*nb_absolute*/\n    0,                                  /*nb_bool*/\n    0,                                  /*nb_invert*/\n    0,                                  /*nb_lshift*/\n    0,                                  /*nb_rshift*/\n    (binaryfunc)set_and,                /*nb_and*/\n    (binaryfunc)set_xor,                /*nb_xor*/\n    (binaryfunc)set_or,                 /*nb_or*/\n    0,                                  /*nb_int*/\n    0,                                  /*nb_reserved*/\n    0,                                  /*nb_float*/\n    0,                                  /*nb_inplace_add*/\n    (binaryfunc)set_isub,               /*nb_inplace_subtract*/\n    0,                                  /*nb_inplace_multiply*/\n    0,                                  /*nb_inplace_remainder*/\n    0,                                  /*nb_inplace_power*/\n    0,                                  /*nb_inplace_lshift*/\n    0,                                  /*nb_inplace_rshift*/\n    (binaryfunc)set_iand,               /*nb_inplace_and*/\n    (binaryfunc)set_ixor,               /*nb_inplace_xor*/\n    (binaryfunc)set_ior,                /*nb_inplace_or*/\n};\n\nPyDoc_STRVAR(set_doc,\n\"set() -> new empty set object\\n\\\nset(iterable) -> new set object\\n\\\n\\n\\\nBuild an unordered collection of unique elements.\");\n\nPyTypeObject PySet_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"set\",                              /* tp_name */\n    sizeof(PySetObject),                /* tp_basicsize */\n    0,                                  /* tp_itemsize */\n    /* methods */\n    (destructor)set_dealloc,            /* tp_dealloc */\n    0,                                  /* tp_vectorcall_offset */\n    0,                                  /* tp_getattr */\n    0,                                  /* tp_setattr */\n    0,                                  /* tp_as_async */\n    (reprfunc)set_repr,                 /* tp_repr */\n    &set_as_number,                     /* tp_as_number */\n    &set_as_sequence,                   /* tp_as_sequence */\n    0,                                  /* tp_as_mapping */\n    PyObject_HashNotImplemented,        /* tp_hash */\n    0,                                  /* tp_call */\n    0,                                  /* tp_str */\n    PyObject_GenericGetAttr,            /* tp_getattro */\n    0,                                  /* tp_setattro */\n    0,                                  /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n        Py_TPFLAGS_BASETYPE |\n        _Py_TPFLAGS_MATCH_SELF,       /* tp_flags */\n    set_doc,                            /* tp_doc */\n    (traverseproc)set_traverse,         /* tp_traverse */\n    (inquiry)set_clear_internal,        /* tp_clear */\n    (richcmpfunc)set_richcompare,       /* tp_richcompare */\n    offsetof(PySetObject, weakreflist), /* tp_weaklistoffset */\n    (getiterfunc)set_iter,              /* tp_iter */\n    0,                                  /* tp_iternext */\n    set_methods,                        /* tp_methods */\n    0,                                  /* tp_members */\n    0,                                  /* tp_getset */\n    0,                                  /* tp_base */\n    0,                                  /* tp_dict */\n    0,                                  /* tp_descr_get */\n    0,                                  /* tp_descr_set */\n    0,                                  /* tp_dictoffset */\n    (initproc)set_init,                 /* tp_init */\n    PyType_GenericAlloc,                /* tp_alloc */\n    set_new,                            /* tp_new */\n    PyObject_GC_Del,                    /* tp_free */\n    .tp_vectorcall = set_vectorcall,\n};\n\n/* frozenset object ********************************************************/\n\n\nstatic PyMethodDef frozenset_methods[] = {\n    {\"__contains__\",(PyCFunction)set_direct_contains,           METH_O | METH_COEXIST,\n     contains_doc},\n    {\"copy\",            (PyCFunction)frozenset_copy,    METH_NOARGS,\n     copy_doc},\n    {\"difference\",      (PyCFunction)set_difference_multi,      METH_VARARGS,\n     difference_doc},\n    {\"intersection\",    (PyCFunction)set_intersection_multi,    METH_VARARGS,\n     intersection_doc},\n    {\"isdisjoint\",      (PyCFunction)set_isdisjoint,    METH_O,\n     isdisjoint_doc},\n    {\"issubset\",        (PyCFunction)set_issubset,      METH_O,\n     issubset_doc},\n    {\"issuperset\",      (PyCFunction)set_issuperset,    METH_O,\n     issuperset_doc},\n    {\"__reduce__\",      (PyCFunction)set_reduce,        METH_NOARGS,\n     reduce_doc},\n    {\"__sizeof__\",      (PyCFunction)set_sizeof,        METH_NOARGS,\n     sizeof_doc},\n    {\"symmetric_difference\",(PyCFunction)set_symmetric_difference,      METH_O,\n     symmetric_difference_doc},\n    {\"union\",           (PyCFunction)set_union,         METH_VARARGS,\n     union_doc},\n    {\"__class_getitem__\", Py_GenericAlias, METH_O|METH_CLASS, PyDoc_STR(\"See PEP 585\")},\n    {NULL,              NULL}   /* sentinel */\n};\n\nstatic PyNumberMethods frozenset_as_number = {\n    0,                                  /*nb_add*/\n    (binaryfunc)set_sub,                /*nb_subtract*/\n    0,                                  /*nb_multiply*/\n    0,                                  /*nb_remainder*/\n    0,                                  /*nb_divmod*/\n    0,                                  /*nb_power*/\n    0,                                  /*nb_negative*/\n    0,                                  /*nb_positive*/\n    0,                                  /*nb_absolute*/\n    0,                                  /*nb_bool*/\n    0,                                  /*nb_invert*/\n    0,                                  /*nb_lshift*/\n    0,                                  /*nb_rshift*/\n    (binaryfunc)set_and,                /*nb_and*/\n    (binaryfunc)set_xor,                /*nb_xor*/\n    (binaryfunc)set_or,                 /*nb_or*/\n};\n\nPyDoc_STRVAR(frozenset_doc,\n\"frozenset() -> empty frozenset object\\n\\\nfrozenset(iterable) -> frozenset object\\n\\\n\\n\\\nBuild an immutable unordered collection of unique elements.\");\n\nPyTypeObject PyFrozenSet_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"frozenset\",                        /* tp_name */\n    sizeof(PySetObject),                /* tp_basicsize */\n    0,                                  /* tp_itemsize */\n    /* methods */\n    (destructor)set_dealloc,            /* tp_dealloc */\n    0,                                  /* tp_vectorcall_offset */\n    0,                                  /* tp_getattr */\n    0,                                  /* tp_setattr */\n    0,                                  /* tp_as_async */\n    (reprfunc)set_repr,                 /* tp_repr */\n    &frozenset_as_number,               /* tp_as_number */\n    &set_as_sequence,                   /* tp_as_sequence */\n    0,                                  /* tp_as_mapping */\n    frozenset_hash,                     /* tp_hash */\n    0,                                  /* tp_call */\n    0,                                  /* tp_str */\n    PyObject_GenericGetAttr,            /* tp_getattro */\n    0,                                  /* tp_setattro */\n    0,                                  /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n        Py_TPFLAGS_BASETYPE |\n        _Py_TPFLAGS_MATCH_SELF,       /* tp_flags */\n    frozenset_doc,                      /* tp_doc */\n    (traverseproc)set_traverse,         /* tp_traverse */\n    (inquiry)set_clear_internal,        /* tp_clear */\n    (richcmpfunc)set_richcompare,       /* tp_richcompare */\n    offsetof(PySetObject, weakreflist), /* tp_weaklistoffset */\n    (getiterfunc)set_iter,              /* tp_iter */\n    0,                                  /* tp_iternext */\n    frozenset_methods,                  /* tp_methods */\n    0,                                  /* tp_members */\n    0,                                  /* tp_getset */\n    0,                                  /* tp_base */\n    0,                                  /* tp_dict */\n    0,                                  /* tp_descr_get */\n    0,                                  /* tp_descr_set */\n    0,                                  /* tp_dictoffset */\n    0,                                  /* tp_init */\n    PyType_GenericAlloc,                /* tp_alloc */\n    frozenset_new,                      /* tp_new */\n    PyObject_GC_Del,                    /* tp_free */\n    .tp_vectorcall = frozenset_vectorcall,\n};\n\n\n/***** C API functions *************************************************/\n\nPyObject *\nPySet_New(PyObject *iterable)\n{\n    return make_new_set(&PySet_Type, iterable);\n}\n\nPyObject *\nPyFrozenSet_New(PyObject *iterable)\n{\n    return make_new_set(&PyFrozenSet_Type, iterable);\n}\n\nPy_ssize_t\nPySet_Size(PyObject *anyset)\n{\n    if (!PyAnySet_Check(anyset)) {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    return PySet_GET_SIZE(anyset);\n}\n\nint\nPySet_Clear(PyObject *set)\n{\n    if (!PySet_Check(set)) {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    return set_clear_internal((PySetObject *)set);\n}\n\nint\nPySet_Contains(PyObject *anyset, PyObject *key)\n{\n    if (!PyAnySet_Check(anyset)) {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    return set_contains_key((PySetObject *)anyset, key);\n}\n\nint\nPySet_Discard(PyObject *set, PyObject *key)\n{\n    if (!PySet_Check(set)) {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    return set_discard_key((PySetObject *)set, key);\n}\n\nint\nPySet_Add(PyObject *anyset, PyObject *key)\n{\n    if (!PySet_Check(anyset) &&\n        (!PyFrozenSet_Check(anyset) || Py_REFCNT(anyset) != 1)) {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    return set_add_key((PySetObject *)anyset, key);\n}\n\nint\n_PySet_NextEntry(PyObject *set, Py_ssize_t *pos, PyObject **key, Py_hash_t *hash)\n{\n    setentry *entry;\n\n    if (!PyAnySet_Check(set)) {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    if (set_next((PySetObject *)set, pos, &entry) == 0)\n        return 0;\n    *key = entry->key;\n    *hash = entry->hash;\n    return 1;\n}\n\nPyObject *\nPySet_Pop(PyObject *set)\n{\n    if (!PySet_Check(set)) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n    return set_pop((PySetObject *)set, NULL);\n}\n\nint\n_PySet_Update(PyObject *set, PyObject *iterable)\n{\n    if (!PySet_Check(set)) {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    return set_update_internal((PySetObject *)set, iterable);\n}\n\n/* Exported for the gdb plugin's benefit. */\nPyObject *_PySet_Dummy = dummy;\n\n#ifdef Py_DEBUG\n\n/* Test code to be called with any three element set.\n   Returns True and original set is restored. */\n\n#define assertRaises(call_return_value, exception)              \\\n    do {                                                        \\\n        assert(call_return_value);                              \\\n        assert(PyErr_ExceptionMatches(exception));              \\\n        PyErr_Clear();                                          \\\n    } while(0)\n\nstatic PyObject *\ntest_c_api(PySetObject *so, PyObject *Py_UNUSED(ignored))\n{\n    Py_ssize_t count;\n    const char *s;\n    Py_ssize_t i;\n    PyObject *elem=NULL, *dup=NULL, *t, *f, *dup2, *x=NULL;\n    PyObject *ob = (PyObject *)so;\n    Py_hash_t hash;\n    PyObject *str;\n\n    /* Verify preconditions */\n    assert(PyAnySet_Check(ob));\n    assert(PyAnySet_CheckExact(ob));\n    assert(!PyFrozenSet_CheckExact(ob));\n\n    /* so.clear(); so |= set(\"abc\"); */\n    str = PyUnicode_FromString(\"abc\");\n    if (str == NULL)\n        return NULL;\n    set_clear_internal(so);\n    if (set_update_internal(so, str)) {\n        Py_DECREF(str);\n        return NULL;\n    }\n    Py_DECREF(str);\n\n    /* Exercise type/size checks */\n    assert(PySet_Size(ob) == 3);\n    assert(PySet_GET_SIZE(ob) == 3);\n\n    /* Raise TypeError for non-iterable constructor arguments */\n    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n    assertRaises(PyFrozenSet_New(Py_None) == NULL, PyExc_TypeError);\n\n    /* Raise TypeError for unhashable key */\n    dup = PySet_New(ob);\n    assertRaises(PySet_Discard(ob, dup) == -1, PyExc_TypeError);\n    assertRaises(PySet_Contains(ob, dup) == -1, PyExc_TypeError);\n    assertRaises(PySet_Add(ob, dup) == -1, PyExc_TypeError);\n\n    /* Exercise successful pop, contains, add, and discard */\n    elem = PySet_Pop(ob);\n    assert(PySet_Contains(ob, elem) == 0);\n    assert(PySet_GET_SIZE(ob) == 2);\n    assert(PySet_Add(ob, elem) == 0);\n    assert(PySet_Contains(ob, elem) == 1);\n    assert(PySet_GET_SIZE(ob) == 3);\n    assert(PySet_Discard(ob, elem) == 1);\n    assert(PySet_GET_SIZE(ob) == 2);\n    assert(PySet_Discard(ob, elem) == 0);\n    assert(PySet_GET_SIZE(ob) == 2);\n\n    /* Exercise clear */\n    dup2 = PySet_New(dup);\n    assert(PySet_Clear(dup2) == 0);\n    assert(PySet_Size(dup2) == 0);\n    Py_DECREF(dup2);\n\n    /* Raise SystemError on clear or update of frozen set */\n    f = PyFrozenSet_New(dup);\n    assertRaises(PySet_Clear(f) == -1, PyExc_SystemError);\n    assertRaises(_PySet_Update(f, dup) == -1, PyExc_SystemError);\n    assert(PySet_Add(f, elem) == 0);\n    Py_INCREF(f);\n    assertRaises(PySet_Add(f, elem) == -1, PyExc_SystemError);\n    Py_DECREF(f);\n    Py_DECREF(f);\n\n    /* Exercise direct iteration */\n    i = 0, count = 0;\n    while (_PySet_NextEntry((PyObject *)dup, &i, &x, &hash)) {\n        s = PyUnicode_AsUTF8(x);\n        assert(s && (s[0] == 'a' || s[0] == 'b' || s[0] == 'c'));\n        count++;\n    }\n    assert(count == 3);\n\n    /* Exercise updates */\n    dup2 = PySet_New(NULL);\n    assert(_PySet_Update(dup2, dup) == 0);\n    assert(PySet_Size(dup2) == 3);\n    assert(_PySet_Update(dup2, dup) == 0);\n    assert(PySet_Size(dup2) == 3);\n    Py_DECREF(dup2);\n\n    /* Raise SystemError when self argument is not a set or frozenset. */\n    t = PyTuple_New(0);\n    assertRaises(PySet_Size(t) == -1, PyExc_SystemError);\n    assertRaises(PySet_Contains(t, elem) == -1, PyExc_SystemError);\n    Py_DECREF(t);\n\n    /* Raise SystemError when self argument is not a set. */\n    f = PyFrozenSet_New(dup);\n    assert(PySet_Size(f) == 3);\n    assert(PyFrozenSet_CheckExact(f));\n    assertRaises(PySet_Discard(f, elem) == -1, PyExc_SystemError);\n    assertRaises(PySet_Pop(f) == NULL, PyExc_SystemError);\n    Py_DECREF(f);\n\n    /* Raise KeyError when popping from an empty set */\n    assert(PyNumber_InPlaceSubtract(ob, ob) == ob);\n    Py_DECREF(ob);\n    assert(PySet_GET_SIZE(ob) == 0);\n    assertRaises(PySet_Pop(ob) == NULL, PyExc_KeyError);\n\n    /* Restore the set from the copy using the PyNumber API */\n    assert(PyNumber_InPlaceOr(ob, dup) == ob);\n    Py_DECREF(ob);\n\n    /* Verify constructors accept NULL arguments */\n    f = PySet_New(NULL);\n    assert(f != NULL);\n    assert(PySet_GET_SIZE(f) == 0);\n    Py_DECREF(f);\n    f = PyFrozenSet_New(NULL);\n    assert(f != NULL);\n    assert(PyFrozenSet_CheckExact(f));\n    assert(PySet_GET_SIZE(f) == 0);\n    Py_DECREF(f);\n\n    Py_DECREF(elem);\n    Py_DECREF(dup);\n    Py_RETURN_TRUE;\n}\n\n#undef assertRaises\n\n#endif\n\n/***** Dummy Struct  *************************************************/\n\nstatic PyObject *\ndummy_repr(PyObject *op)\n{\n    return PyUnicode_FromString(\"<dummy key>\");\n}\n\nstatic void _Py_NO_RETURN\ndummy_dealloc(PyObject* ignore)\n{\n    Py_FatalError(\"deallocating <dummy key>\");\n}\n\nstatic PyTypeObject _PySetDummy_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"<dummy key> type\",\n    0,\n    0,\n    dummy_dealloc,      /*tp_dealloc*/ /*never called*/\n    0,                  /*tp_vectorcall_offset*/\n    0,                  /*tp_getattr*/\n    0,                  /*tp_setattr*/\n    0,                  /*tp_as_async*/\n    dummy_repr,         /*tp_repr*/\n    0,                  /*tp_as_number*/\n    0,                  /*tp_as_sequence*/\n    0,                  /*tp_as_mapping*/\n    0,                  /*tp_hash */\n    0,                  /*tp_call */\n    0,                  /*tp_str */\n    0,                  /*tp_getattro */\n    0,                  /*tp_setattro */\n    0,                  /*tp_as_buffer */\n    Py_TPFLAGS_DEFAULT, /*tp_flags */\n};\n\nstatic PyObject _dummy_struct = {\n    _PyObject_EXTRA_INIT\n    { _Py_IMMORTAL_REFCNT },\n    &_PySetDummy_Type\n};\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-out-of-bounds", "taxa": [{"id": "126", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "buffer over-read"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/dictobject.h", "uriBaseId": "PWD"}, "region": {"startLine": 57, "startColumn": 12, "endColumn": 23}, "contextRegion": {"startLine": 57, "snippet": {"text": "    return mp->ma_used;\n"}}}, "logicalLocations": [{"name": "PyDict_GET_SIZE", "fullyQualifiedName": "PyDict_GET_SIZE", "decoratedName": "PyDict_GET_SIZE", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 842, "startColumn": 22, "endColumn": 36}, "contextRegion": {"startLine": 842, "snippet": {"text": "PyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n"}}}, "message": {"text": "capacity: 16 bytes"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2387, "startColumn": 1, "endColumn": 11}, "contextRegion": {"startLine": 2387, "snippet": {"text": "test_c_api(PySetObject *so, PyObject *Py_UNUSED(ignored))\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "entry to 'test_c_api'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2400, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2400, "snippet": {"text": "    assert(!PyFrozenSet_CheckExact(ob));\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2403, "startColumn": 5, "endColumn": 8}, "contextRegion": {"startLine": 2403, "snippet": {"text": "    str = PyUnicode_FromString(\"abc\");\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2404, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2404, "snippet": {"text": "    if (str == NULL)\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch (when 'str' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 23}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'set_clear_internal' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 397, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 397, "snippet": {"text": "set_clear_internal(PySetObject *so)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "entry to 'set_clear_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 407, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 407, "snippet": {"text": "    assert(table != NULL);\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "following 'false' branch (when 'table' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 415, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 415, "snippet": {"text": "    if (table_is_malloced)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'set_clear_internal'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2407, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2407, "snippet": {"text": "    if (set_update_internal(so, str)) {\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'Py_DECREF' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 679, "startColumn": 20, "endColumn": 29}, "contextRegion": {"startLine": 679, "snippet": {"text": "static inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "entry to 'Py_DECREF'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 684, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 684, "snippet": {"text": "    if (_Py_IsImmortal(op)) {\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 687, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 687, "snippet": {"text": "    _Py_DECREF_STAT_INC();\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'Py_DECREF'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2414, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2414, "snippet": {"text": "    assert(PySet_Size(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'PySet_New' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2273, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 2273, "snippet": {"text": "PySet_New(PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "entry to 'PySet_New'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2275, "startColumn": 12, "endColumn": 47}, "contextRegion": {"startLine": 2275, "snippet": {"text": "    return make_new_set(&PySet_Type, iterable);\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "calling 'make_new_set' from 'PySet_New'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 949, "startColumn": 1, "endColumn": 13}, "contextRegion": {"startLine": 949, "snippet": {"text": "make_new_set(PyTypeObject *type, PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "entry to 'make_new_set'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 951, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 951, "snippet": {"text": "    assert(PyType_Check(type));\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 952, "startColumn": 5, "endColumn": 16}, "contextRegion": {"startLine": 952, "snippet": {"text": "    PySetObject *so;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 955, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 955, "snippet": {"text": "    if (so == NULL)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch (when 'so' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 958, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 958, "snippet": {"text": "    so->fill = 0;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 966, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 966, "snippet": {"text": "    if (iterable != NULL) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'true' branch (when 'iterable' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 13, "endColumn": 46}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "calling 'set_update_internal' from 'make_new_set'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 878, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 878, "snippet": {"text": "set_update_internal(PySetObject *so, PyObject *other)\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "entry to 'set_update_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 882, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 882, "snippet": {"text": "    if (PyAnySet_Check(other))\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 250, "startColumn": 5, "endColumn": 11}, "contextRegion": {"startLine": 250, "snippet": {"text": "    return Py_TYPE(ob) == type;\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 882, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 882, "snippet": {"text": "    if (PyAnySet_Check(other))\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 885, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 885, "snippet": {"text": "    if (PyDict_CheckExact(other)) {\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 885, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 885, "snippet": {"text": "    if (PyDict_CheckExact(other)) {\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 886, "startColumn": 9, "endColumn": 17}, "contextRegion": {"startLine": 886, "snippet": {"text": "        PyObject *value;\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 889, "startColumn": 31, "endColumn": 32}, "contextRegion": {"startLine": 889, "snippet": {"text": "        Py_ssize_t dictsize = PyDict_GET_SIZE(other);\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "calling 'PyDict_GET_SIZE' from 'set_update_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/dictobject.h", "uriBaseId": "PWD"}, "region": {"startLine": 53, "startColumn": 26, "endColumn": 41}, "contextRegion": {"startLine": 53, "snippet": {"text": "static inline Py_ssize_t PyDict_GET_SIZE(PyObject *op) {\n"}}}, "logicalLocations": [{"name": "PyDict_GET_SIZE", "fullyQualifiedName": "PyDict_GET_SIZE", "decoratedName": "PyDict_GET_SIZE", "kind": "function"}], "message": {"text": "entry to 'PyDict_GET_SIZE'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/dictobject.h", "uriBaseId": "PWD"}, "region": {"startLine": 55, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 55, "snippet": {"text": "    assert(PyDict_Check(op));\n"}}}, "logicalLocations": [{"name": "PyDict_GET_SIZE", "fullyQualifiedName": "PyDict_GET_SIZE", "decoratedName": "PyDict_GET_SIZE", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/dictobject.h", "uriBaseId": "PWD"}, "region": {"startLine": 56, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 56, "snippet": {"text": "    mp = _Py_CAST(PyDictObject*, op);\n"}}}, "logicalLocations": [{"name": "PyDict_GET_SIZE", "fullyQualifiedName": "PyDict_GET_SIZE", "decoratedName": "PyDict_GET_SIZE", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/dictobject.h", "uriBaseId": "PWD"}, "region": {"startLine": 57, "startColumn": 12, "endColumn": 23}, "contextRegion": {"startLine": 57, "snippet": {"text": "    return mp->ma_used;\n"}}}, "logicalLocations": [{"name": "PyDict_GET_SIZE", "fullyQualifiedName": "PyDict_GET_SIZE", "decoratedName": "PyDict_GET_SIZE", "kind": "function"}], "message": {"text": "out-of-bounds read from byte 16 till byte 23 but '_Py_NoneStruct' ends at byte 16"}}, "kinds": ["danger"], "nestingLevel": 5}]}]}], "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/dictobject.h", "uriBaseId": "PWD"}, "region": {"startLine": 57, "startColumn": 12, "endColumn": 23}, "contextRegion": {"startLine": 57, "snippet": {"text": "    return mp->ma_used;\n"}}}, "message": {"text": "read of 8 bytes from after the end of '_Py_NoneStruct'"}}]}, {"ruleId": "-Wanalyzer-out-of-bounds", "taxa": [{"id": "126", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "buffer over-read"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 570, "startColumn": 24, "endColumn": 35}, "contextRegion": {"startLine": 570, "snippet": {"text": "    if (other == so || other->used == 0)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 842, "startColumn": 22, "endColumn": 36}, "contextRegion": {"startLine": 842, "snippet": {"text": "PyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n"}}}, "message": {"text": "capacity: 16 bytes"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2387, "startColumn": 1, "endColumn": 11}, "contextRegion": {"startLine": 2387, "snippet": {"text": "test_c_api(PySetObject *so, PyObject *Py_UNUSED(ignored))\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "entry to 'test_c_api'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2400, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2400, "snippet": {"text": "    assert(!PyFrozenSet_CheckExact(ob));\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2403, "startColumn": 5, "endColumn": 8}, "contextRegion": {"startLine": 2403, "snippet": {"text": "    str = PyUnicode_FromString(\"abc\");\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2404, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2404, "snippet": {"text": "    if (str == NULL)\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch (when 'str' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 23}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'set_clear_internal' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 397, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 397, "snippet": {"text": "set_clear_internal(PySetObject *so)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "entry to 'set_clear_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 407, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 407, "snippet": {"text": "    assert(table != NULL);\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "following 'false' branch (when 'table' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 415, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 415, "snippet": {"text": "    if (table_is_malloced)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'set_clear_internal'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2407, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2407, "snippet": {"text": "    if (set_update_internal(so, str)) {\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'Py_DECREF' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 679, "startColumn": 20, "endColumn": 29}, "contextRegion": {"startLine": 679, "snippet": {"text": "static inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "entry to 'Py_DECREF'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 684, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 684, "snippet": {"text": "    if (_Py_IsImmortal(op)) {\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 687, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 687, "snippet": {"text": "    _Py_DECREF_STAT_INC();\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'Py_DECREF'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2414, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2414, "snippet": {"text": "    assert(PySet_Size(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'PySet_New' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2273, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 2273, "snippet": {"text": "PySet_New(PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "entry to 'PySet_New'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2275, "startColumn": 12, "endColumn": 47}, "contextRegion": {"startLine": 2275, "snippet": {"text": "    return make_new_set(&PySet_Type, iterable);\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "calling 'make_new_set' from 'PySet_New'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 949, "startColumn": 1, "endColumn": 13}, "contextRegion": {"startLine": 949, "snippet": {"text": "make_new_set(PyTypeObject *type, PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "entry to 'make_new_set'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 951, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 951, "snippet": {"text": "    assert(PyType_Check(type));\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 952, "startColumn": 5, "endColumn": 16}, "contextRegion": {"startLine": 952, "snippet": {"text": "    PySetObject *so;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 955, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 955, "snippet": {"text": "    if (so == NULL)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch (when 'so' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 958, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 958, "snippet": {"text": "    so->fill = 0;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 966, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 966, "snippet": {"text": "    if (iterable != NULL) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'true' branch (when 'iterable' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 13, "endColumn": 46}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "calling 'set_update_internal' from 'make_new_set'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 878, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 878, "snippet": {"text": "set_update_internal(PySetObject *so, PyObject *other)\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "entry to 'set_update_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 883, "startColumn": 16, "endColumn": 36}, "contextRegion": {"startLine": 883, "snippet": {"text": "        return set_merge(so, other);\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "calling 'set_merge' from 'set_update_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 558, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 558, "snippet": {"text": "set_merge(PySetObject *so, PyObject *otherset)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "entry to 'set_merge'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 570, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 570, "snippet": {"text": "    if (other == so || other->used == 0)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'false' branch (when 'so != otherset')..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 570, "startColumn": 24, "endColumn": 35}, "contextRegion": {"startLine": 570, "snippet": {"text": "    if (other == so || other->used == 0)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 570, "startColumn": 24, "endColumn": 35}, "contextRegion": {"startLine": 570, "snippet": {"text": "    if (other == so || other->used == 0)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "out-of-bounds read from byte 24 till byte 31 but '_Py_NoneStruct' ends at byte 16"}}, "kinds": ["danger"], "nestingLevel": 5}]}]}], "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 570, "startColumn": 24, "endColumn": 35}, "contextRegion": {"startLine": 570, "snippet": {"text": "    if (other == so || other->used == 0)\n"}}}, "message": {"text": "read of 8 bytes from after the end of '_Py_NoneStruct'"}}]}, {"ruleId": "-Wanalyzer-out-of-bounds", "taxa": [{"id": "126", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "buffer over-read"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 582, "startColumn": 5, "endColumn": 31}, "contextRegion": {"startLine": 582, "snippet": {"text": "    other_entry = other->table;\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 842, "startColumn": 22, "endColumn": 36}, "contextRegion": {"startLine": 842, "snippet": {"text": "PyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n"}}}, "message": {"text": "capacity: 16 bytes"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2387, "startColumn": 1, "endColumn": 11}, "contextRegion": {"startLine": 2387, "snippet": {"text": "test_c_api(PySetObject *so, PyObject *Py_UNUSED(ignored))\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "entry to 'test_c_api'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2400, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2400, "snippet": {"text": "    assert(!PyFrozenSet_CheckExact(ob));\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2403, "startColumn": 5, "endColumn": 8}, "contextRegion": {"startLine": 2403, "snippet": {"text": "    str = PyUnicode_FromString(\"abc\");\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2404, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2404, "snippet": {"text": "    if (str == NULL)\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch (when 'str' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 23}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'set_clear_internal' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 397, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 397, "snippet": {"text": "set_clear_internal(PySetObject *so)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "entry to 'set_clear_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 407, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 407, "snippet": {"text": "    assert(table != NULL);\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "following 'false' branch (when 'table' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 415, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 415, "snippet": {"text": "    if (table_is_malloced)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'set_clear_internal'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2407, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2407, "snippet": {"text": "    if (set_update_internal(so, str)) {\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'Py_DECREF' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 679, "startColumn": 20, "endColumn": 29}, "contextRegion": {"startLine": 679, "snippet": {"text": "static inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "entry to 'Py_DECREF'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 684, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 684, "snippet": {"text": "    if (_Py_IsImmortal(op)) {\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 687, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 687, "snippet": {"text": "    _Py_DECREF_STAT_INC();\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'Py_DECREF'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2414, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2414, "snippet": {"text": "    assert(PySet_Size(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'PySet_New' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2273, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 2273, "snippet": {"text": "PySet_New(PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "entry to 'PySet_New'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2275, "startColumn": 12, "endColumn": 47}, "contextRegion": {"startLine": 2275, "snippet": {"text": "    return make_new_set(&PySet_Type, iterable);\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "calling 'make_new_set' from 'PySet_New'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 949, "startColumn": 1, "endColumn": 13}, "contextRegion": {"startLine": 949, "snippet": {"text": "make_new_set(PyTypeObject *type, PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "entry to 'make_new_set'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 951, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 951, "snippet": {"text": "    assert(PyType_Check(type));\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 952, "startColumn": 5, "endColumn": 16}, "contextRegion": {"startLine": 952, "snippet": {"text": "    PySetObject *so;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 955, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 955, "snippet": {"text": "    if (so == NULL)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch (when 'so' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 958, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 958, "snippet": {"text": "    so->fill = 0;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 966, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 966, "snippet": {"text": "    if (iterable != NULL) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'true' branch (when 'iterable' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 13, "endColumn": 46}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "calling 'set_update_internal' from 'make_new_set'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 878, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 878, "snippet": {"text": "set_update_internal(PySetObject *so, PyObject *other)\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "entry to 'set_update_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 883, "startColumn": 16, "endColumn": 36}, "contextRegion": {"startLine": 883, "snippet": {"text": "        return set_merge(so, other);\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "calling 'set_merge' from 'set_update_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 558, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 558, "snippet": {"text": "set_merge(PySetObject *so, PyObject *otherset)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "entry to 'set_merge'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 570, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 570, "snippet": {"text": "    if (other == so || other->used == 0)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 577, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 577, "snippet": {"text": "    if ((so->fill + other->used)*5 >= so->mask*3) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 582, "startColumn": 5, "endColumn": 31}, "contextRegion": {"startLine": 582, "snippet": {"text": "    other_entry = other->table;\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "out-of-bounds read from byte 40 till byte 47 but '_Py_NoneStruct' ends at byte 16"}}, "kinds": ["danger"], "nestingLevel": 5}]}]}], "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 582, "startColumn": 5, "endColumn": 31}, "contextRegion": {"startLine": 582, "snippet": {"text": "    other_entry = other->table;\n"}}}, "message": {"text": "read of 8 bytes from after the end of '_Py_NoneStruct'"}}]}, {"ruleId": "-Wanalyzer-out-of-bounds", "taxa": [{"id": "126", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "buffer over-read"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 38, "endColumn": 49}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 842, "startColumn": 22, "endColumn": 36}, "contextRegion": {"startLine": 842, "snippet": {"text": "PyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n"}}}, "message": {"text": "capacity: 16 bytes"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2387, "startColumn": 1, "endColumn": 11}, "contextRegion": {"startLine": 2387, "snippet": {"text": "test_c_api(PySetObject *so, PyObject *Py_UNUSED(ignored))\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "entry to 'test_c_api'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2400, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2400, "snippet": {"text": "    assert(!PyFrozenSet_CheckExact(ob));\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2403, "startColumn": 5, "endColumn": 8}, "contextRegion": {"startLine": 2403, "snippet": {"text": "    str = PyUnicode_FromString(\"abc\");\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2404, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2404, "snippet": {"text": "    if (str == NULL)\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch (when 'str' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 23}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'set_clear_internal' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 397, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 397, "snippet": {"text": "set_clear_internal(PySetObject *so)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "entry to 'set_clear_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 407, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 407, "snippet": {"text": "    assert(table != NULL);\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "following 'false' branch (when 'table' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 415, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 415, "snippet": {"text": "    if (table_is_malloced)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'set_clear_internal'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2407, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2407, "snippet": {"text": "    if (set_update_internal(so, str)) {\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'Py_DECREF' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 679, "startColumn": 20, "endColumn": 29}, "contextRegion": {"startLine": 679, "snippet": {"text": "static inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "entry to 'Py_DECREF'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 684, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 684, "snippet": {"text": "    if (_Py_IsImmortal(op)) {\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 687, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 687, "snippet": {"text": "    _Py_DECREF_STAT_INC();\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'Py_DECREF'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2414, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2414, "snippet": {"text": "    assert(PySet_Size(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'PySet_New' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2273, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 2273, "snippet": {"text": "PySet_New(PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "entry to 'PySet_New'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2275, "startColumn": 12, "endColumn": 47}, "contextRegion": {"startLine": 2275, "snippet": {"text": "    return make_new_set(&PySet_Type, iterable);\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "calling 'make_new_set' from 'PySet_New'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 949, "startColumn": 1, "endColumn": 13}, "contextRegion": {"startLine": 949, "snippet": {"text": "make_new_set(PyTypeObject *type, PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "entry to 'make_new_set'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 951, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 951, "snippet": {"text": "    assert(PyType_Check(type));\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 952, "startColumn": 5, "endColumn": 16}, "contextRegion": {"startLine": 952, "snippet": {"text": "    PySetObject *so;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 955, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 955, "snippet": {"text": "    if (so == NULL)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch (when 'so' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 958, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 958, "snippet": {"text": "    so->fill = 0;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 966, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 966, "snippet": {"text": "    if (iterable != NULL) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'true' branch (when 'iterable' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 13, "endColumn": 46}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "calling 'set_update_internal' from 'make_new_set'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 878, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 878, "snippet": {"text": "set_update_internal(PySetObject *so, PyObject *other)\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "entry to 'set_update_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 883, "startColumn": 16, "endColumn": 36}, "contextRegion": {"startLine": 883, "snippet": {"text": "        return set_merge(so, other);\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "calling 'set_merge' from 'set_update_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 558, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 558, "snippet": {"text": "set_merge(PySetObject *so, PyObject *otherset)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "entry to 'set_merge'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 570, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 570, "snippet": {"text": "    if (other == so || other->used == 0)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 577, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 577, "snippet": {"text": "    if ((so->fill + other->used)*5 >= so->mask*3) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 26, "endColumn": 34}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 38, "endColumn": 49}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "out-of-bounds read from byte 32 till byte 39 but '_Py_NoneStruct' ends at byte 16"}}, "kinds": ["danger"], "nestingLevel": 5}]}]}], "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 38, "endColumn": 49}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "message": {"text": "read of 8 bytes from after the end of '_Py_NoneStruct'"}}]}, {"ruleId": "-Wanalyzer-out-of-bounds", "taxa": [{"id": "126", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "buffer over-read"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 53, "endColumn": 64}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 842, "startColumn": 22, "endColumn": 36}, "contextRegion": {"startLine": 842, "snippet": {"text": "PyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n"}}}, "message": {"text": "capacity: 16 bytes"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2387, "startColumn": 1, "endColumn": 11}, "contextRegion": {"startLine": 2387, "snippet": {"text": "test_c_api(PySetObject *so, PyObject *Py_UNUSED(ignored))\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "entry to 'test_c_api'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2400, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2400, "snippet": {"text": "    assert(!PyFrozenSet_CheckExact(ob));\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2403, "startColumn": 5, "endColumn": 8}, "contextRegion": {"startLine": 2403, "snippet": {"text": "    str = PyUnicode_FromString(\"abc\");\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2404, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2404, "snippet": {"text": "    if (str == NULL)\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch (when 'str' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 23}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'set_clear_internal' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 397, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 397, "snippet": {"text": "set_clear_internal(PySetObject *so)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "entry to 'set_clear_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 407, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 407, "snippet": {"text": "    assert(table != NULL);\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "following 'false' branch (when 'table' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 415, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 415, "snippet": {"text": "    if (table_is_malloced)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'set_clear_internal'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2407, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2407, "snippet": {"text": "    if (set_update_internal(so, str)) {\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'Py_DECREF' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 679, "startColumn": 20, "endColumn": 29}, "contextRegion": {"startLine": 679, "snippet": {"text": "static inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "entry to 'Py_DECREF'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 684, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 684, "snippet": {"text": "    if (_Py_IsImmortal(op)) {\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 687, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 687, "snippet": {"text": "    _Py_DECREF_STAT_INC();\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'Py_DECREF'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2414, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2414, "snippet": {"text": "    assert(PySet_Size(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'PySet_New' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2273, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 2273, "snippet": {"text": "PySet_New(PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "entry to 'PySet_New'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2275, "startColumn": 12, "endColumn": 47}, "contextRegion": {"startLine": 2275, "snippet": {"text": "    return make_new_set(&PySet_Type, iterable);\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "calling 'make_new_set' from 'PySet_New'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 949, "startColumn": 1, "endColumn": 13}, "contextRegion": {"startLine": 949, "snippet": {"text": "make_new_set(PyTypeObject *type, PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "entry to 'make_new_set'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 951, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 951, "snippet": {"text": "    assert(PyType_Check(type));\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 952, "startColumn": 5, "endColumn": 16}, "contextRegion": {"startLine": 952, "snippet": {"text": "    PySetObject *so;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 955, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 955, "snippet": {"text": "    if (so == NULL)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch (when 'so' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 958, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 958, "snippet": {"text": "    so->fill = 0;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 966, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 966, "snippet": {"text": "    if (iterable != NULL) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'true' branch (when 'iterable' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 13, "endColumn": 46}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "calling 'set_update_internal' from 'make_new_set'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 878, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 878, "snippet": {"text": "set_update_internal(PySetObject *so, PyObject *other)\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "entry to 'set_update_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 883, "startColumn": 16, "endColumn": 36}, "contextRegion": {"startLine": 883, "snippet": {"text": "        return set_merge(so, other);\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "calling 'set_merge' from 'set_update_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 558, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 558, "snippet": {"text": "set_merge(PySetObject *so, PyObject *otherset)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "entry to 'set_merge'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 570, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 570, "snippet": {"text": "    if (other == so || other->used == 0)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 577, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 577, "snippet": {"text": "    if ((so->fill + other->used)*5 >= so->mask*3) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 53, "endColumn": 64}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 53, "endColumn": 64}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "out-of-bounds read from byte 16 till byte 23 but '_Py_NoneStruct' ends at byte 16"}}, "kinds": ["danger"], "nestingLevel": 5}]}]}], "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 53, "endColumn": 64}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "message": {"text": "read of 8 bytes from after the end of '_Py_NoneStruct'"}}]}, {"ruleId": "-Wanalyzer-out-of-bounds", "taxa": [{"id": "126", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "buffer over-read"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 68, "endColumn": 79}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 842, "startColumn": 22, "endColumn": 36}, "contextRegion": {"startLine": 842, "snippet": {"text": "PyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n"}}}, "message": {"text": "capacity: 16 bytes"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2387, "startColumn": 1, "endColumn": 11}, "contextRegion": {"startLine": 2387, "snippet": {"text": "test_c_api(PySetObject *so, PyObject *Py_UNUSED(ignored))\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "entry to 'test_c_api'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2400, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2400, "snippet": {"text": "    assert(!PyFrozenSet_CheckExact(ob));\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2403, "startColumn": 5, "endColumn": 8}, "contextRegion": {"startLine": 2403, "snippet": {"text": "    str = PyUnicode_FromString(\"abc\");\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2404, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2404, "snippet": {"text": "    if (str == NULL)\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch (when 'str' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 23}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'set_clear_internal' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 397, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 397, "snippet": {"text": "set_clear_internal(PySetObject *so)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "entry to 'set_clear_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 407, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 407, "snippet": {"text": "    assert(table != NULL);\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "following 'false' branch (when 'table' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 415, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 415, "snippet": {"text": "    if (table_is_malloced)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'set_clear_internal'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2407, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2407, "snippet": {"text": "    if (set_update_internal(so, str)) {\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'Py_DECREF' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 679, "startColumn": 20, "endColumn": 29}, "contextRegion": {"startLine": 679, "snippet": {"text": "static inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "entry to 'Py_DECREF'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 684, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 684, "snippet": {"text": "    if (_Py_IsImmortal(op)) {\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 687, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 687, "snippet": {"text": "    _Py_DECREF_STAT_INC();\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'Py_DECREF'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2414, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2414, "snippet": {"text": "    assert(PySet_Size(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'PySet_New' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2273, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 2273, "snippet": {"text": "PySet_New(PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "entry to 'PySet_New'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2275, "startColumn": 12, "endColumn": 47}, "contextRegion": {"startLine": 2275, "snippet": {"text": "    return make_new_set(&PySet_Type, iterable);\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "calling 'make_new_set' from 'PySet_New'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 949, "startColumn": 1, "endColumn": 13}, "contextRegion": {"startLine": 949, "snippet": {"text": "make_new_set(PyTypeObject *type, PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "entry to 'make_new_set'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 951, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 951, "snippet": {"text": "    assert(PyType_Check(type));\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 952, "startColumn": 5, "endColumn": 16}, "contextRegion": {"startLine": 952, "snippet": {"text": "    PySetObject *so;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 955, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 955, "snippet": {"text": "    if (so == NULL)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch (when 'so' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 958, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 958, "snippet": {"text": "    so->fill = 0;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 966, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 966, "snippet": {"text": "    if (iterable != NULL) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'true' branch (when 'iterable' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 13, "endColumn": 46}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "calling 'set_update_internal' from 'make_new_set'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 878, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 878, "snippet": {"text": "set_update_internal(PySetObject *so, PyObject *other)\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "entry to 'set_update_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 883, "startColumn": 16, "endColumn": 36}, "contextRegion": {"startLine": 883, "snippet": {"text": "        return set_merge(so, other);\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "calling 'set_merge' from 'set_update_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 558, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 558, "snippet": {"text": "set_merge(PySetObject *so, PyObject *otherset)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "entry to 'set_merge'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 570, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 570, "snippet": {"text": "    if (other == so || other->used == 0)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 577, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 577, "snippet": {"text": "    if ((so->fill + other->used)*5 >= so->mask*3) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 53, "endColumn": 64}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 68, "endColumn": 79}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "out-of-bounds read from byte 24 till byte 31 but '_Py_NoneStruct' ends at byte 16"}}, "kinds": ["danger"], "nestingLevel": 5}]}]}], "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 68, "endColumn": 79}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "message": {"text": "read of 8 bytes from after the end of '_Py_NoneStruct'"}}]}, {"ruleId": "-Wanalyzer-out-of-bounds", "taxa": [{"id": "126", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "buffer over-read"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 604, "startColumn": 20, "endColumn": 31}, "contextRegion": {"startLine": 604, "snippet": {"text": "        so->fill = other->used;\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 842, "startColumn": 22, "endColumn": 36}, "contextRegion": {"startLine": 842, "snippet": {"text": "PyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n"}}}, "message": {"text": "capacity: 16 bytes"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2387, "startColumn": 1, "endColumn": 11}, "contextRegion": {"startLine": 2387, "snippet": {"text": "test_c_api(PySetObject *so, PyObject *Py_UNUSED(ignored))\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "entry to 'test_c_api'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2400, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2400, "snippet": {"text": "    assert(!PyFrozenSet_CheckExact(ob));\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2403, "startColumn": 5, "endColumn": 8}, "contextRegion": {"startLine": 2403, "snippet": {"text": "    str = PyUnicode_FromString(\"abc\");\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2404, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2404, "snippet": {"text": "    if (str == NULL)\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch (when 'str' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 23}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'set_clear_internal' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 397, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 397, "snippet": {"text": "set_clear_internal(PySetObject *so)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "entry to 'set_clear_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 407, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 407, "snippet": {"text": "    assert(table != NULL);\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "following 'false' branch (when 'table' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 415, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 415, "snippet": {"text": "    if (table_is_malloced)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'set_clear_internal'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2407, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2407, "snippet": {"text": "    if (set_update_internal(so, str)) {\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'Py_DECREF' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 679, "startColumn": 20, "endColumn": 29}, "contextRegion": {"startLine": 679, "snippet": {"text": "static inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "entry to 'Py_DECREF'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 684, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 684, "snippet": {"text": "    if (_Py_IsImmortal(op)) {\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 687, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 687, "snippet": {"text": "    _Py_DECREF_STAT_INC();\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'Py_DECREF'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2414, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2414, "snippet": {"text": "    assert(PySet_Size(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'PySet_New' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2273, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 2273, "snippet": {"text": "PySet_New(PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "entry to 'PySet_New'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2275, "startColumn": 12, "endColumn": 47}, "contextRegion": {"startLine": 2275, "snippet": {"text": "    return make_new_set(&PySet_Type, iterable);\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "calling 'make_new_set' from 'PySet_New'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 949, "startColumn": 1, "endColumn": 13}, "contextRegion": {"startLine": 949, "snippet": {"text": "make_new_set(PyTypeObject *type, PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "entry to 'make_new_set'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 951, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 951, "snippet": {"text": "    assert(PyType_Check(type));\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 952, "startColumn": 5, "endColumn": 16}, "contextRegion": {"startLine": 952, "snippet": {"text": "    PySetObject *so;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 955, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 955, "snippet": {"text": "    if (so == NULL)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch (when 'so' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 958, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 958, "snippet": {"text": "    so->fill = 0;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 966, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 966, "snippet": {"text": "    if (iterable != NULL) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'true' branch (when 'iterable' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 13, "endColumn": 46}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "calling 'set_update_internal' from 'make_new_set'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 878, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 878, "snippet": {"text": "set_update_internal(PySetObject *so, PyObject *other)\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "entry to 'set_update_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 883, "startColumn": 16, "endColumn": 36}, "contextRegion": {"startLine": 883, "snippet": {"text": "        return set_merge(so, other);\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "calling 'set_merge' from 'set_update_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 558, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 558, "snippet": {"text": "set_merge(PySetObject *so, PyObject *otherset)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "entry to 'set_merge'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 570, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 570, "snippet": {"text": "    if (other == so || other->used == 0)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 577, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 577, "snippet": {"text": "    if ((so->fill + other->used)*5 >= so->mask*3) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 26, "endColumn": 34}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 601, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 601, "snippet": {"text": "    if (so->fill == 0) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 602, "startColumn": 9, "endColumn": 17}, "contextRegion": {"startLine": 602, "snippet": {"text": "        setentry *newtable = so->table;\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 604, "startColumn": 20, "endColumn": 31}, "contextRegion": {"startLine": 604, "snippet": {"text": "        so->fill = other->used;\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "out-of-bounds read from byte 24 till byte 31 but '_Py_NoneStruct' ends at byte 16"}}, "kinds": ["danger"], "nestingLevel": 5}]}]}], "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 604, "startColumn": 20, "endColumn": 31}, "contextRegion": {"startLine": 604, "snippet": {"text": "        so->fill = other->used;\n"}}}, "message": {"text": "read of 8 bytes from after the end of '_Py_NoneStruct'"}}]}, {"ruleId": "-Wanalyzer-out-of-bounds", "taxa": [{"id": "126", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "buffer over-read"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 606, "startColumn": 18, "endColumn": 29}, "contextRegion": {"startLine": 606, "snippet": {"text": "        for (i = other->mask + 1; i > 0 ; i--, other_entry++) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 842, "startColumn": 22, "endColumn": 36}, "contextRegion": {"startLine": 842, "snippet": {"text": "PyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n"}}}, "message": {"text": "capacity: 16 bytes"}}, "nestingLevel": 0}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2387, "startColumn": 1, "endColumn": 11}, "contextRegion": {"startLine": 2387, "snippet": {"text": "test_c_api(PySetObject *so, PyObject *Py_UNUSED(ignored))\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "entry to 'test_c_api'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2400, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2400, "snippet": {"text": "    assert(!PyFrozenSet_CheckExact(ob));\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2403, "startColumn": 5, "endColumn": 8}, "contextRegion": {"startLine": 2403, "snippet": {"text": "    str = PyUnicode_FromString(\"abc\");\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2404, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2404, "snippet": {"text": "    if (str == NULL)\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch (when 'str' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 23}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'set_clear_internal' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 397, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 397, "snippet": {"text": "set_clear_internal(PySetObject *so)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "entry to 'set_clear_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 407, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 407, "snippet": {"text": "    assert(table != NULL);\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "following 'false' branch (when 'table' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 415, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 415, "snippet": {"text": "    if (table_is_malloced)\n"}}}, "logicalLocations": [{"name": "set_clear_internal", "fullyQualifiedName": "set_clear_internal", "decoratedName": "set_clear_internal", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2406, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2406, "snippet": {"text": "    set_clear_internal(so);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'set_clear_internal'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2407, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2407, "snippet": {"text": "    if (set_update_internal(so, str)) {\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'Py_DECREF' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 679, "startColumn": 20, "endColumn": 29}, "contextRegion": {"startLine": 679, "snippet": {"text": "static inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "entry to 'Py_DECREF'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 684, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 684, "snippet": {"text": "    if (_Py_IsImmortal(op)) {\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 687, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 687, "snippet": {"text": "    _Py_DECREF_STAT_INC();\n"}}}, "logicalLocations": [{"name": "Py_DECREF", "fullyQualifiedName": "Py_DECREF", "decoratedName": "Py_DECREF", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2411, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2411, "snippet": {"text": "    Py_DECREF(str);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "returning to 'test_c_api' from 'Py_DECREF'"}}, "kinds": ["return", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2414, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2414, "snippet": {"text": "    assert(PySet_Size(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2415, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2415, "snippet": {"text": "    assert(PySet_GET_SIZE(ob) == 3);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2418, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2418, "snippet": {"text": "    assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);\n"}}}, "logicalLocations": [{"name": "test_c_api", "fullyQualifiedName": "test_c_api", "decoratedName": "test_c_api", "kind": "function"}], "message": {"text": "calling 'PySet_New' from 'test_c_api'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2273, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 2273, "snippet": {"text": "PySet_New(PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "entry to 'PySet_New'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2275, "startColumn": 12, "endColumn": 47}, "contextRegion": {"startLine": 2275, "snippet": {"text": "    return make_new_set(&PySet_Type, iterable);\n"}}}, "logicalLocations": [{"name": "PySet_New", "fullyQualifiedName": "PySet_New", "decoratedName": "PySet_New", "kind": "function"}], "message": {"text": "calling 'make_new_set' from 'PySet_New'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 949, "startColumn": 1, "endColumn": 13}, "contextRegion": {"startLine": 949, "snippet": {"text": "make_new_set(PyTypeObject *type, PyObject *iterable)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "entry to 'make_new_set'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 951, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 951, "snippet": {"text": "    assert(PyType_Check(type));\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 952, "startColumn": 5, "endColumn": 16}, "contextRegion": {"startLine": 952, "snippet": {"text": "    PySetObject *so;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 955, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 955, "snippet": {"text": "    if (so == NULL)\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'false' branch (when 'so' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 958, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 958, "snippet": {"text": "    so->fill = 0;\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 966, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 966, "snippet": {"text": "    if (iterable != NULL) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "following 'true' branch (when 'iterable' is non-NULL)..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 967, "startColumn": 13, "endColumn": 46}, "contextRegion": {"startLine": 967, "snippet": {"text": "        if (set_update_internal(so, iterable)) {\n"}}}, "logicalLocations": [{"name": "make_new_set", "fullyQualifiedName": "make_new_set", "decoratedName": "make_new_set", "kind": "function"}], "message": {"text": "calling 'set_update_internal' from 'make_new_set'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 878, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 878, "snippet": {"text": "set_update_internal(PySetObject *so, PyObject *other)\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "entry to 'set_update_internal'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 883, "startColumn": 16, "endColumn": 36}, "contextRegion": {"startLine": 883, "snippet": {"text": "        return set_merge(so, other);\n"}}}, "logicalLocations": [{"name": "set_update_internal", "fullyQualifiedName": "set_update_internal", "decoratedName": "set_update_internal", "kind": "function"}], "message": {"text": "calling 'set_merge' from 'set_update_internal'"}}, "kinds": ["call", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 558, "startColumn": 1, "endColumn": 10}, "contextRegion": {"startLine": 558, "snippet": {"text": "set_merge(PySetObject *so, PyObject *otherset)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "entry to 'set_merge'"}}, "kinds": ["enter", "function"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 570, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 570, "snippet": {"text": "    if (other == so || other->used == 0)\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 577, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 577, "snippet": {"text": "    if ((so->fill + other->used)*5 >= so->mask*3) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 586, "startColumn": 26, "endColumn": 34}, "contextRegion": {"startLine": 586, "snippet": {"text": "    if (so->fill == 0 && so->mask == other->mask && other->fill == other->used) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 601, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 601, "snippet": {"text": "    if (so->fill == 0) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 602, "startColumn": 9, "endColumn": 17}, "contextRegion": {"startLine": 602, "snippet": {"text": "        setentry *newtable = so->table;\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 5}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 606, "startColumn": 18, "endColumn": 29}, "contextRegion": {"startLine": 606, "snippet": {"text": "        for (i = other->mask + 1; i > 0 ; i--, other_entry++) {\n"}}}, "logicalLocations": [{"name": "set_merge", "fullyQualifiedName": "set_merge", "decoratedName": "set_merge", "kind": "function"}], "message": {"text": "out-of-bounds read from byte 32 till byte 39 but '_Py_NoneStruct' ends at byte 16"}}, "kinds": ["danger"], "nestingLevel": 5}]}]}], "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/setobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 606, "startColumn": 18, "endColumn": 29}, "contextRegion": {"startLine": 606, "snippet": {"text": "        for (i = other->mask + 1; i > 0 ; i--, other_entry++) {\n"}}}, "message": {"text": "read of 8 bytes from after the end of '_Py_NoneStruct'"}}]}]}]}
