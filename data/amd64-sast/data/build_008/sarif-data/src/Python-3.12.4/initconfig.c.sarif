{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-use-of-uninitialized-value", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-use-of-uninitialized-value"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "457", "helpUri": "https://cwe.mitre.org/data/definitions/457.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}}, "artifacts": [{"location": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "contents": {"text": "#include \"Python.h\"\n#include \"pycore_fileutils.h\"     // _Py_HasFileSystemDefaultEncodeErrors\n#include \"pycore_getopt.h\"        // _PyOS_GetOpt()\n#include \"pycore_initconfig.h\"    // _PyStatus_OK()\n#include \"pycore_interp.h\"        // _PyInterpreterState.runtime\n#include \"pycore_long.h\"          // _PY_LONG_MAX_STR_DIGITS_THRESHOLD\n#include \"pycore_pathconfig.h\"    // _Py_path_config\n#include \"pycore_pyerrors.h\"      // _PyErr_GetRaisedException()\n#include \"pycore_pylifecycle.h\"   // _Py_PreInitializeFromConfig()\n#include \"pycore_pymem.h\"         // _PyMem_SetDefaultAllocator()\n#include \"pycore_pystate.h\"       // _PyThreadState_GET()\n\n#include \"osdefs.h\"               // DELIM\n\n#include <locale.h>               // setlocale()\n#include <stdlib.h>               // getenv()\n#if defined(MS_WINDOWS) || defined(__CYGWIN__)\n#  ifdef HAVE_IO_H\n#    include <io.h>\n#  endif\n#  ifdef HAVE_FCNTL_H\n#    include <fcntl.h>            // O_BINARY\n#  endif\n#endif\n\n/* --- Command line options --------------------------------------- */\n\n/* Short usage message (with %s for argv0) */\nstatic const char usage_line[] =\n\"usage: %ls [option] ... [-c cmd | -m mod | file | -] [arg] ...\\n\";\n\n/* Long help message */\n/* Lines sorted by option name; keep in sync with usage_envvars* below */\nstatic const char usage_help[] = \"\\\nOptions (and corresponding environment variables):\\n\\\n-b     : issue warnings about converting bytes/bytearray to str and comparing\\n\\\n         bytes/bytearray with str or bytes with int. (-bb: issue errors)\\n\\\n-B     : don't write .pyc files on import; also PYTHONDONTWRITEBYTECODE=x\\n\\\n-c cmd : program passed in as string (terminates option list)\\n\\\n-d     : turn on parser debugging output (for experts only, only works on\\n\\\n         debug builds); also PYTHONDEBUG=x\\n\\\n-E     : ignore PYTHON* environment variables (such as PYTHONPATH)\\n\\\n-h     : print this help message and exit (also -? or --help)\\n\\\n-i     : inspect interactively after running script; forces a prompt even\\n\\\n         if stdin does not appear to be a terminal; also PYTHONINSPECT=x\\n\\\n-I     : isolate Python from the user's environment (implies -E and -s)\\n\\\n-m mod : run library module as a script (terminates option list)\\n\\\n-O     : remove assert and __debug__-dependent statements; add .opt-1 before\\n\\\n         .pyc extension; also PYTHONOPTIMIZE=x\\n\\\n-OO    : do -O changes and also discard docstrings; add .opt-2 before\\n\\\n         .pyc extension\\n\\\n-P     : don't prepend a potentially unsafe path to sys.path; also\\n\\\n         PYTHONSAFEPATH\\n\\\n-q     : don't print version and copyright messages on interactive startup\\n\\\n-s     : don't add user site directory to sys.path; also PYTHONNOUSERSITE=x\\n\\\n-S     : don't imply 'import site' on initialization\\n\\\n-u     : force the stdout and stderr streams to be unbuffered;\\n\\\n         this option has no effect on stdin; also PYTHONUNBUFFERED=x\\n\\\n-v     : verbose (trace import statements); also PYTHONVERBOSE=x\\n\\\n         can be supplied multiple times to increase verbosity\\n\\\n-V     : print the Python version number and exit (also --version)\\n\\\n         when given twice, print more information about the build\\n\\\n-W arg : warning control; arg is action:message:category:module:lineno\\n\\\n         also PYTHONWARNINGS=arg\\n\\\n-x     : skip first line of source, allowing use of non-Unix forms of #!cmd\\n\\\n-X opt : set implementation-specific option\\n\\\n--check-hash-based-pycs always|default|never:\\n\\\n         control how Python invalidates hash-based .pyc files\\n\\\n--help-env: print help about Python environment variables and exit\\n\\\n--help-xoptions: print help about implementation-specific -X options and exit\\n\\\n--help-all: print complete help information and exit\\n\\\n\\n\\\nArguments:\\n\\\nfile   : program read from script file\\n\\\n-      : program read from stdin (default; interactive mode if a tty)\\n\\\narg ...: arguments passed to program in sys.argv[1:]\\n\\\n\";\n\nstatic const char usage_xoptions[] = \"\\\nThe following implementation-specific options are available:\\n\\\n-X dev : enable Python Development Mode; also PYTHONDEVMODE\\n\\\n-X faulthandler: dump the Python traceback on fatal errors;\\n\\\n         also PYTHONFAULTHANDLER\\n\\\n-X frozen_modules=[on|off]: whether to use frozen modules; the default is \\\"on\\\"\\n\\\n         for installed Python and \\\"off\\\" for a local build\\n\\\n-X importtime: show how long each import takes; also PYTHONPROFILEIMPORTTIME\\n\\\n-X int_max_str_digits=N: limit the size of int<->str conversions;\\n\\\n         0 disables the limit; also PYTHONINTMAXSTRDIGITS\\n\\\n-X no_debug_ranges: don't include extra location information in code objects;\\n\\\n         also PYTHONNODEBUGRANGES\\n\\\n-X perf: support the Linux \\\"perf\\\" profiler; also PYTHONPERFSUPPORT=1\\n\\\n\"\n#ifdef Py_DEBUG\n\"-X presite=MOD: import this module before site; also PYTHON_PRESITE\\n\"\n#endif\n\"\\\n-X pycache_prefix=PATH: write .pyc files to a parallel tree instead of to the\\n\\\n         code tree; also PYTHONPYCACHEPREFIX\\n\\\n\"\n#ifdef Py_STATS\n\"-X pystats: enable pystats collection at startup; also PYTHONSTATS\\n\"\n#endif\n\"\\\n-X showrefcount: output the total reference count and number of used\\n\\\n         memory blocks when the program finishes or after each statement in\\n\\\n         the interactive interpreter; only works on debug builds\\n\\\n-X tracemalloc[=N]: trace Python memory allocations; N sets a traceback limit\\n\\\n         of N frames (default: 1); also PYTHONTRACEMALLOC=N\\n\\\n-X utf8[=0|1]: enable (1) or disable (0) UTF-8 mode; also PYTHONUTF8\\n\\\n-X warn_default_encoding: enable opt-in EncodingWarning for 'encoding=None';\\n\\\n         also PYTHONWARNDEFAULTENCODING\\\n\";\n\n/* Envvars that don't have equivalent command-line options are listed first */\nstatic const char usage_envvars[] =\n\"Environment variables that change behavior:\\n\"\n\"PYTHONSTARTUP   : file executed on interactive startup (no default)\\n\"\n\"PYTHONPATH      : '%lc'-separated list of directories prefixed to the\\n\"\n\"                  default module search path.  The result is sys.path.\\n\"\n\"PYTHONHOME      : alternate <prefix> directory (or <prefix>%lc<exec_prefix>).\\n\"\n\"                  The default module search path uses %s.\\n\"\n\"PYTHONPLATLIBDIR: override sys.platlibdir\\n\"\n\"PYTHONCASEOK    : ignore case in 'import' statements (Windows)\\n\"\n\"PYTHONIOENCODING: encoding[:errors] used for stdin/stdout/stderr\\n\"\n\"PYTHONHASHSEED  : if this variable is set to 'random', a random value is used\\n\"\n\"                  to seed the hashes of str and bytes objects.  It can also be\\n\"\n\"                  set to an integer in the range [0,4294967295] to get hash\\n\"\n\"                  values with a predictable seed.\\n\"\n\"PYTHONMALLOC    : set the Python memory allocators and/or install debug hooks\\n\"\n\"                  on Python memory allocators.  Use PYTHONMALLOC=debug to\\n\"\n\"                  install debug hooks.\\n\"\n\"PYTHONCOERCECLOCALE: if this variable is set to 0, it disables the locale\\n\"\n\"                  coercion behavior.  Use PYTHONCOERCECLOCALE=warn to request\\n\"\n\"                  display of locale coercion and locale compatibility warnings\\n\"\n\"                  on stderr.\\n\"\n\"PYTHONBREAKPOINT: if this variable is set to 0, it disables the default\\n\"\n\"                  debugger.  It can be set to the callable of your debugger of\\n\"\n\"                  choice.\\n\"\n\"\\n\"\n\"These variables have equivalent command-line options (see --help for details):\\n\"\n\"PYTHONDEBUG     : enable parser debug mode (-d)\\n\"\n\"PYTHONDEVMODE   : enable Python Development Mode (-X dev)\\n\"\n\"PYTHONDONTWRITEBYTECODE: don't write .pyc files (-B)\\n\"\n\"PYTHONFAULTHANDLER: dump the Python traceback on fatal errors (-X faulthandler)\\n\"\n\"PYTHONINSPECT   : inspect interactively after running script (-i)\\n\"\n\"PYTHONINTMAXSTRDIGITS: limit the size of int<->str conversions;\\n\"\n\"                  0 disables the limit (-X int_max_str_digits=N)\\n\"\n\"PYTHONNODEBUGRANGES: don't include extra location information in code objects\\n\"\n\"                  (-X no_debug_ranges)\\n\"\n\"PYTHONNOUSERSITE: disable user site directory (-s)\\n\"\n\"PYTHONOPTIMIZE  : enable level 1 optimizations (-O)\\n\"\n\"PYTHONPERFSUPPORT: support the Linux \\\"perf\\\" profiler (-X perf)\\n\"\n\"PYTHONPROFILEIMPORTTIME: show how long each import takes (-X importtime)\\n\"\n\"PYTHONPYCACHEPREFIX: root directory for bytecode cache (pyc) files\\n\"\n\"                  (-X pycache_prefix)\\n\"\n\"PYTHONSAFEPATH  : don't prepend a potentially unsafe path to sys.path.\\n\"\n\"PYTHONTRACEMALLOC: trace Python memory allocations (-X tracemalloc)\\n\"\n\"PYTHONUNBUFFERED: disable stdout/stderr buffering (-u)\\n\"\n\"PYTHONUTF8      : control the UTF-8 mode (-X utf8)\\n\"\n\"PYTHONVERBOSE   : trace import statements (-v)\\n\"\n\"PYTHONWARNDEFAULTENCODING: enable opt-in EncodingWarning for 'encoding=None'\\n\"\n\"                  (-X warn_default_encoding)\\n\"\n\"PYTHONWARNINGS  : warning control (-W)\\n\"\n;\n\n#if defined(MS_WINDOWS)\n#  define PYTHONHOMEHELP \"<prefix>\\\\python{major}{minor}\"\n#else\n#  define PYTHONHOMEHELP \"<prefix>/lib/pythonX.X\"\n#endif\n\n\n/* --- Global configuration variables ----------------------------- */\n\n/* UTF-8 mode (PEP 540): if equals to 1, use the UTF-8 encoding, and change\n   stdin and stdout error handler to \"surrogateescape\". */\nint Py_UTF8Mode = 0;\nint Py_DebugFlag = 0; /* Needed by parser.c */\nint Py_VerboseFlag = 0; /* Needed by import.c */\nint Py_QuietFlag = 0; /* Needed by sysmodule.c */\nint Py_InteractiveFlag = 0; /* Previously, was used by Py_FdIsInteractive() */\nint Py_InspectFlag = 0; /* Needed to determine whether to exit at SystemExit */\nint Py_OptimizeFlag = 0; /* Needed by compile.c */\nint Py_NoSiteFlag = 0; /* Suppress 'import site' */\nint Py_BytesWarningFlag = 0; /* Warn on str(bytes) and str(buffer) */\nint Py_FrozenFlag = 0; /* Needed by getpath.c */\nint Py_IgnoreEnvironmentFlag = 0; /* e.g. PYTHONPATH, PYTHONHOME */\nint Py_DontWriteBytecodeFlag = 0; /* Suppress writing bytecode files (*.pyc) */\nint Py_NoUserSiteDirectory = 0; /* for -s and site.py */\nint Py_UnbufferedStdioFlag = 0; /* Unbuffered binary std{in,out,err} */\nint Py_HashRandomizationFlag = 0; /* for -R and PYTHONHASHSEED */\nint Py_IsolatedFlag = 0; /* for -I, isolate from user's env */\n#ifdef MS_WINDOWS\nint Py_LegacyWindowsFSEncodingFlag = 0; /* Uses mbcs instead of utf-8 */\nint Py_LegacyWindowsStdioFlag = 0; /* Uses FileIO instead of WindowsConsoleIO */\n#endif\n\n\nstatic PyObject *\n_Py_GetGlobalVariablesAsDict(void)\n{\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n    PyObject *dict, *obj;\n\n    dict = PyDict_New();\n    if (dict == NULL) {\n        return NULL;\n    }\n\n#define SET_ITEM(KEY, EXPR) \\\n        do { \\\n            obj = (EXPR); \\\n            if (obj == NULL) { \\\n                return NULL; \\\n            } \\\n            int res = PyDict_SetItemString(dict, (KEY), obj); \\\n            Py_DECREF(obj); \\\n            if (res < 0) { \\\n                goto fail; \\\n            } \\\n        } while (0)\n#define SET_ITEM_INT(VAR) \\\n    SET_ITEM(#VAR, PyLong_FromLong(VAR))\n#define FROM_STRING(STR) \\\n    ((STR != NULL) ? \\\n        PyUnicode_FromString(STR) \\\n        : Py_NewRef(Py_None))\n#define SET_ITEM_STR(VAR) \\\n    SET_ITEM(#VAR, FROM_STRING(VAR))\n\n    SET_ITEM_STR(Py_FileSystemDefaultEncoding);\n    SET_ITEM_INT(Py_HasFileSystemDefaultEncoding);\n    SET_ITEM_STR(Py_FileSystemDefaultEncodeErrors);\n    SET_ITEM_INT(_Py_HasFileSystemDefaultEncodeErrors);\n\n    SET_ITEM_INT(Py_UTF8Mode);\n    SET_ITEM_INT(Py_DebugFlag);\n    SET_ITEM_INT(Py_VerboseFlag);\n    SET_ITEM_INT(Py_QuietFlag);\n    SET_ITEM_INT(Py_InteractiveFlag);\n    SET_ITEM_INT(Py_InspectFlag);\n\n    SET_ITEM_INT(Py_OptimizeFlag);\n    SET_ITEM_INT(Py_NoSiteFlag);\n    SET_ITEM_INT(Py_BytesWarningFlag);\n    SET_ITEM_INT(Py_FrozenFlag);\n    SET_ITEM_INT(Py_IgnoreEnvironmentFlag);\n    SET_ITEM_INT(Py_DontWriteBytecodeFlag);\n    SET_ITEM_INT(Py_NoUserSiteDirectory);\n    SET_ITEM_INT(Py_UnbufferedStdioFlag);\n    SET_ITEM_INT(Py_HashRandomizationFlag);\n    SET_ITEM_INT(Py_IsolatedFlag);\n\n#ifdef MS_WINDOWS\n    SET_ITEM_INT(Py_LegacyWindowsFSEncodingFlag);\n    SET_ITEM_INT(Py_LegacyWindowsStdioFlag);\n#endif\n\n    return dict;\n\nfail:\n    Py_DECREF(dict);\n    return NULL;\n\n#undef FROM_STRING\n#undef SET_ITEM\n#undef SET_ITEM_INT\n#undef SET_ITEM_STR\n_Py_COMP_DIAG_POP\n}\n\nchar*\nPy_GETENV(const char *name)\n{\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n    if (Py_IgnoreEnvironmentFlag) {\n        return NULL;\n    }\n    return getenv(name);\n_Py_COMP_DIAG_POP\n}\n\n/* --- PyStatus ----------------------------------------------- */\n\nPyStatus PyStatus_Ok(void)\n{ return _PyStatus_OK(); }\n\nPyStatus PyStatus_Error(const char *err_msg)\n{\n    assert(err_msg != NULL);\n    return (PyStatus){._type = _PyStatus_TYPE_ERROR,\n                      .err_msg = err_msg};\n}\n\nPyStatus PyStatus_NoMemory(void)\n{ return PyStatus_Error(\"memory allocation failed\"); }\n\nPyStatus PyStatus_Exit(int exitcode)\n{ return _PyStatus_EXIT(exitcode); }\n\n\nint PyStatus_IsError(PyStatus status)\n{ return _PyStatus_IS_ERROR(status); }\n\nint PyStatus_IsExit(PyStatus status)\n{ return _PyStatus_IS_EXIT(status); }\n\nint PyStatus_Exception(PyStatus status)\n{ return _PyStatus_EXCEPTION(status); }\n\nPyObject*\n_PyErr_SetFromPyStatus(PyStatus status)\n{\n    if (!_PyStatus_IS_ERROR(status)) {\n        PyErr_Format(PyExc_SystemError,\n                     \"%s() expects an error PyStatus\",\n                     _PyStatus_GET_FUNC());\n    }\n    else if (status.func) {\n        PyErr_Format(PyExc_ValueError, \"%s: %s\", status.func, status.err_msg);\n    }\n    else {\n        PyErr_Format(PyExc_ValueError, \"%s\", status.err_msg);\n    }\n    return NULL;\n}\n\n\n/* --- PyWideStringList ------------------------------------------------ */\n\n#ifndef NDEBUG\nint\n_PyWideStringList_CheckConsistency(const PyWideStringList *list)\n{\n    assert(list->length >= 0);\n    if (list->length != 0) {\n        assert(list->items != NULL);\n    }\n    for (Py_ssize_t i = 0; i < list->length; i++) {\n        assert(list->items[i] != NULL);\n    }\n    return 1;\n}\n#endif   /* Py_DEBUG */\n\n\nvoid\n_PyWideStringList_Clear(PyWideStringList *list)\n{\n    assert(_PyWideStringList_CheckConsistency(list));\n    for (Py_ssize_t i=0; i < list->length; i++) {\n        PyMem_RawFree(list->items[i]);\n    }\n    PyMem_RawFree(list->items);\n    list->length = 0;\n    list->items = NULL;\n}\n\n\nint\n_PyWideStringList_Copy(PyWideStringList *list, const PyWideStringList *list2)\n{\n    assert(_PyWideStringList_CheckConsistency(list));\n    assert(_PyWideStringList_CheckConsistency(list2));\n\n    if (list2->length == 0) {\n        _PyWideStringList_Clear(list);\n        return 0;\n    }\n\n    PyWideStringList copy = _PyWideStringList_INIT;\n\n    size_t size = list2->length * sizeof(list2->items[0]);\n    copy.items = PyMem_RawMalloc(size);\n    if (copy.items == NULL) {\n        return -1;\n    }\n\n    for (Py_ssize_t i=0; i < list2->length; i++) {\n        wchar_t *item = _PyMem_RawWcsdup(list2->items[i]);\n        if (item == NULL) {\n            _PyWideStringList_Clear(&copy);\n            return -1;\n        }\n        copy.items[i] = item;\n        copy.length = i + 1;\n    }\n\n    _PyWideStringList_Clear(list);\n    *list = copy;\n    return 0;\n}\n\n\nPyStatus\nPyWideStringList_Insert(PyWideStringList *list,\n                        Py_ssize_t index, const wchar_t *item)\n{\n    Py_ssize_t len = list->length;\n    if (len == PY_SSIZE_T_MAX) {\n        /* length+1 would overflow */\n        return _PyStatus_NO_MEMORY();\n    }\n    if (index < 0) {\n        return _PyStatus_ERR(\"PyWideStringList_Insert index must be >= 0\");\n    }\n    if (index > len) {\n        index = len;\n    }\n\n    wchar_t *item2 = _PyMem_RawWcsdup(item);\n    if (item2 == NULL) {\n        return _PyStatus_NO_MEMORY();\n    }\n\n    size_t size = (len + 1) * sizeof(list->items[0]);\n    wchar_t **items2 = (wchar_t **)PyMem_RawRealloc(list->items, size);\n    if (items2 == NULL) {\n        PyMem_RawFree(item2);\n        return _PyStatus_NO_MEMORY();\n    }\n\n    if (index < len) {\n        memmove(&items2[index + 1],\n                &items2[index],\n                (len - index) * sizeof(items2[0]));\n    }\n\n    items2[index] = item2;\n    list->items = items2;\n    list->length++;\n    return _PyStatus_OK();\n}\n\n\nPyStatus\nPyWideStringList_Append(PyWideStringList *list, const wchar_t *item)\n{\n    return PyWideStringList_Insert(list, list->length, item);\n}\n\n\nPyStatus\n_PyWideStringList_Extend(PyWideStringList *list, const PyWideStringList *list2)\n{\n    for (Py_ssize_t i = 0; i < list2->length; i++) {\n        PyStatus status = PyWideStringList_Append(list, list2->items[i]);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n    return _PyStatus_OK();\n}\n\n\nstatic int\n_PyWideStringList_Find(PyWideStringList *list, const wchar_t *item)\n{\n    for (Py_ssize_t i = 0; i < list->length; i++) {\n        if (wcscmp(list->items[i], item) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n\nPyObject*\n_PyWideStringList_AsList(const PyWideStringList *list)\n{\n    assert(_PyWideStringList_CheckConsistency(list));\n\n    PyObject *pylist = PyList_New(list->length);\n    if (pylist == NULL) {\n        return NULL;\n    }\n\n    for (Py_ssize_t i = 0; i < list->length; i++) {\n        PyObject *item = PyUnicode_FromWideChar(list->items[i], -1);\n        if (item == NULL) {\n            Py_DECREF(pylist);\n            return NULL;\n        }\n        PyList_SET_ITEM(pylist, i, item);\n    }\n    return pylist;\n}\n\n\n/* --- Py_SetStandardStreamEncoding() ----------------------------- */\n\n/* Helper to allow an embedding application to override the normal\n * mechanism that attempts to figure out an appropriate IO encoding\n */\n\nstatic char *_Py_StandardStreamEncoding = NULL;\nstatic char *_Py_StandardStreamErrors = NULL;\n\nint\nPy_SetStandardStreamEncoding(const char *encoding, const char *errors)\n{\n    if (Py_IsInitialized()) {\n        /* This is too late to have any effect */\n        return -1;\n    }\n\n    int res = 0;\n\n    /* Py_SetStandardStreamEncoding() can be called before Py_Initialize(),\n       but Py_Initialize() can change the allocator. Use a known allocator\n       to be able to release the memory later. */\n    PyMemAllocatorEx old_alloc;\n    _PyMem_SetDefaultAllocator(PYMEM_DOMAIN_RAW, &old_alloc);\n\n    /* Can't call PyErr_NoMemory() on errors, as Python hasn't been\n     * initialised yet.\n     *\n     * However, the raw memory allocators are initialised appropriately\n     * as C static variables, so _PyMem_RawStrdup is OK even though\n     * Py_Initialize hasn't been called yet.\n     */\n    if (encoding) {\n        PyMem_RawFree(_Py_StandardStreamEncoding);\n        _Py_StandardStreamEncoding = _PyMem_RawStrdup(encoding);\n        if (!_Py_StandardStreamEncoding) {\n            res = -2;\n            goto done;\n        }\n    }\n    if (errors) {\n        PyMem_RawFree(_Py_StandardStreamErrors);\n        _Py_StandardStreamErrors = _PyMem_RawStrdup(errors);\n        if (!_Py_StandardStreamErrors) {\n            PyMem_RawFree(_Py_StandardStreamEncoding);\n            _Py_StandardStreamEncoding = NULL;\n            res = -3;\n            goto done;\n        }\n    }\n#ifdef MS_WINDOWS\n    if (_Py_StandardStreamEncoding) {\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n        /* Overriding the stream encoding implies legacy streams */\n        Py_LegacyWindowsStdioFlag = 1;\n_Py_COMP_DIAG_POP\n    }\n#endif\n\ndone:\n    PyMem_SetAllocator(PYMEM_DOMAIN_RAW, &old_alloc);\n\n    return res;\n}\n\n\nvoid\n_Py_ClearStandardStreamEncoding(void)\n{\n    /* Use the same allocator than Py_SetStandardStreamEncoding() */\n    PyMemAllocatorEx old_alloc;\n    _PyMem_SetDefaultAllocator(PYMEM_DOMAIN_RAW, &old_alloc);\n\n    /* We won't need them anymore. */\n    if (_Py_StandardStreamEncoding) {\n        PyMem_RawFree(_Py_StandardStreamEncoding);\n        _Py_StandardStreamEncoding = NULL;\n    }\n    if (_Py_StandardStreamErrors) {\n        PyMem_RawFree(_Py_StandardStreamErrors);\n        _Py_StandardStreamErrors = NULL;\n    }\n\n    PyMem_SetAllocator(PYMEM_DOMAIN_RAW, &old_alloc);\n}\n\n\n/* --- Py_GetArgcArgv() ------------------------------------------- */\n\nvoid\n_Py_ClearArgcArgv(void)\n{\n    PyMemAllocatorEx old_alloc;\n    _PyMem_SetDefaultAllocator(PYMEM_DOMAIN_RAW, &old_alloc);\n\n    _PyWideStringList_Clear(&_PyRuntime.orig_argv);\n\n    PyMem_SetAllocator(PYMEM_DOMAIN_RAW, &old_alloc);\n}\n\n\nstatic int\n_Py_SetArgcArgv(Py_ssize_t argc, wchar_t * const *argv)\n{\n    const PyWideStringList argv_list = {.length = argc, .items = (wchar_t **)argv};\n    int res;\n\n    PyMemAllocatorEx old_alloc;\n    _PyMem_SetDefaultAllocator(PYMEM_DOMAIN_RAW, &old_alloc);\n\n    // XXX _PyRuntime.orig_argv only gets cleared by Py_Main(),\n    // so it it currently leaks for embedders.\n    res = _PyWideStringList_Copy(&_PyRuntime.orig_argv, &argv_list);\n\n    PyMem_SetAllocator(PYMEM_DOMAIN_RAW, &old_alloc);\n    return res;\n}\n\n\n// _PyConfig_Write() calls _Py_SetArgcArgv() with PyConfig.orig_argv.\nvoid\nPy_GetArgcArgv(int *argc, wchar_t ***argv)\n{\n    *argc = (int)_PyRuntime.orig_argv.length;\n    *argv = _PyRuntime.orig_argv.items;\n}\n\n\n/* --- PyConfig ---------------------------------------------- */\n\n#define MAX_HASH_SEED 4294967295UL\n\n\n#ifndef NDEBUG\nstatic int\nconfig_check_consistency(const PyConfig *config)\n{\n    /* Check config consistency */\n    assert(config->isolated >= 0);\n    assert(config->use_environment >= 0);\n    assert(config->dev_mode >= 0);\n    assert(config->install_signal_handlers >= 0);\n    assert(config->use_hash_seed >= 0);\n    assert(config->hash_seed <= MAX_HASH_SEED);\n    assert(config->faulthandler >= 0);\n    assert(config->tracemalloc >= 0);\n    assert(config->import_time >= 0);\n    assert(config->code_debug_ranges >= 0);\n    assert(config->show_ref_count >= 0);\n    assert(config->dump_refs >= 0);\n    assert(config->malloc_stats >= 0);\n    assert(config->site_import >= 0);\n    assert(config->bytes_warning >= 0);\n    assert(config->warn_default_encoding >= 0);\n    assert(config->inspect >= 0);\n    assert(config->interactive >= 0);\n    assert(config->optimization_level >= 0);\n    assert(config->parser_debug >= 0);\n    assert(config->write_bytecode >= 0);\n    assert(config->verbose >= 0);\n    assert(config->quiet >= 0);\n    assert(config->user_site_directory >= 0);\n    assert(config->parse_argv >= 0);\n    assert(config->configure_c_stdio >= 0);\n    assert(config->buffered_stdio >= 0);\n    assert(_PyWideStringList_CheckConsistency(&config->orig_argv));\n    assert(_PyWideStringList_CheckConsistency(&config->argv));\n    /* sys.argv must be non-empty: empty argv is replaced with [''] */\n    assert(config->argv.length >= 1);\n    assert(_PyWideStringList_CheckConsistency(&config->xoptions));\n    assert(_PyWideStringList_CheckConsistency(&config->warnoptions));\n    assert(_PyWideStringList_CheckConsistency(&config->module_search_paths));\n    assert(config->module_search_paths_set >= 0);\n    assert(config->filesystem_encoding != NULL);\n    assert(config->filesystem_errors != NULL);\n    assert(config->stdio_encoding != NULL);\n    assert(config->stdio_errors != NULL);\n#ifdef MS_WINDOWS\n    assert(config->legacy_windows_stdio >= 0);\n#endif\n    /* -c and -m options are exclusive */\n    assert(!(config->run_command != NULL && config->run_module != NULL));\n    assert(config->check_hash_pycs_mode != NULL);\n    assert(config->_install_importlib >= 0);\n    assert(config->pathconfig_warnings >= 0);\n    assert(config->_is_python_build >= 0);\n    assert(config->safe_path >= 0);\n    assert(config->int_max_str_digits >= 0);\n    // config->use_frozen_modules is initialized later\n    // by _PyConfig_InitImportConfig().\n    return 1;\n}\n#endif\n\n\n/* Free memory allocated in config, but don't clear all attributes */\nvoid\nPyConfig_Clear(PyConfig *config)\n{\n#define CLEAR(ATTR) \\\n    do { \\\n        PyMem_RawFree(ATTR); \\\n        ATTR = NULL; \\\n    } while (0)\n\n    CLEAR(config->pycache_prefix);\n    CLEAR(config->pythonpath_env);\n    CLEAR(config->home);\n    CLEAR(config->program_name);\n\n    _PyWideStringList_Clear(&config->argv);\n    _PyWideStringList_Clear(&config->warnoptions);\n    _PyWideStringList_Clear(&config->xoptions);\n    _PyWideStringList_Clear(&config->module_search_paths);\n    config->module_search_paths_set = 0;\n    CLEAR(config->stdlib_dir);\n\n    CLEAR(config->executable);\n    CLEAR(config->base_executable);\n    CLEAR(config->prefix);\n    CLEAR(config->base_prefix);\n    CLEAR(config->exec_prefix);\n    CLEAR(config->base_exec_prefix);\n    CLEAR(config->platlibdir);\n\n    CLEAR(config->filesystem_encoding);\n    CLEAR(config->filesystem_errors);\n    CLEAR(config->stdio_encoding);\n    CLEAR(config->stdio_errors);\n    CLEAR(config->run_command);\n    CLEAR(config->run_module);\n    CLEAR(config->run_filename);\n    CLEAR(config->check_hash_pycs_mode);\n\n    _PyWideStringList_Clear(&config->orig_argv);\n#undef CLEAR\n}\n\n\nvoid\n_PyConfig_InitCompatConfig(PyConfig *config)\n{\n    memset(config, 0, sizeof(*config));\n\n    config->_config_init = (int)_PyConfig_INIT_COMPAT;\n    config->isolated = -1;\n    config->use_environment = -1;\n    config->dev_mode = -1;\n    config->install_signal_handlers = 1;\n    config->use_hash_seed = -1;\n    config->faulthandler = -1;\n    config->tracemalloc = -1;\n    config->perf_profiling = -1;\n    config->module_search_paths_set = 0;\n    config->parse_argv = 0;\n    config->site_import = -1;\n    config->bytes_warning = -1;\n    config->warn_default_encoding = 0;\n    config->inspect = -1;\n    config->interactive = -1;\n    config->optimization_level = -1;\n    config->parser_debug= -1;\n    config->write_bytecode = -1;\n    config->verbose = -1;\n    config->quiet = -1;\n    config->user_site_directory = -1;\n    config->configure_c_stdio = 0;\n    config->buffered_stdio = -1;\n    config->_install_importlib = 1;\n    config->check_hash_pycs_mode = NULL;\n    config->pathconfig_warnings = -1;\n    config->_init_main = 1;\n#ifdef MS_WINDOWS\n    config->legacy_windows_stdio = -1;\n#endif\n#ifdef Py_DEBUG\n    config->use_frozen_modules = 0;\n#else\n    config->use_frozen_modules = 1;\n#endif\n    config->safe_path = 0;\n    config->int_max_str_digits = -1;\n    config->_is_python_build = 0;\n    config->code_debug_ranges = 1;\n}\n\n\nstatic void\nconfig_init_defaults(PyConfig *config)\n{\n    _PyConfig_InitCompatConfig(config);\n\n    config->isolated = 0;\n    config->use_environment = 1;\n    config->site_import = 1;\n    config->bytes_warning = 0;\n    config->inspect = 0;\n    config->interactive = 0;\n    config->optimization_level = 0;\n    config->parser_debug= 0;\n    config->write_bytecode = 1;\n    config->verbose = 0;\n    config->quiet = 0;\n    config->user_site_directory = 1;\n    config->buffered_stdio = 1;\n    config->pathconfig_warnings = 1;\n#ifdef MS_WINDOWS\n    config->legacy_windows_stdio = 0;\n#endif\n}\n\n\nvoid\nPyConfig_InitPythonConfig(PyConfig *config)\n{\n    config_init_defaults(config);\n\n    config->_config_init = (int)_PyConfig_INIT_PYTHON;\n    config->configure_c_stdio = 1;\n    config->parse_argv = 1;\n}\n\n\nvoid\nPyConfig_InitIsolatedConfig(PyConfig *config)\n{\n    config_init_defaults(config);\n\n    config->_config_init = (int)_PyConfig_INIT_ISOLATED;\n    config->isolated = 1;\n    config->use_environment = 0;\n    config->user_site_directory = 0;\n    config->dev_mode = 0;\n    config->install_signal_handlers = 0;\n    config->use_hash_seed = 0;\n    config->faulthandler = 0;\n    config->tracemalloc = 0;\n    config->perf_profiling = 0;\n    config->int_max_str_digits = _PY_LONG_DEFAULT_MAX_STR_DIGITS;\n    config->safe_path = 1;\n    config->pathconfig_warnings = 0;\n#ifdef MS_WINDOWS\n    config->legacy_windows_stdio = 0;\n#endif\n}\n\n\n/* Copy str into *config_str (duplicate the string) */\nPyStatus\nPyConfig_SetString(PyConfig *config, wchar_t **config_str, const wchar_t *str)\n{\n    PyStatus status = _Py_PreInitializeFromConfig(config, NULL);\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n\n    wchar_t *str2;\n    if (str != NULL) {\n        str2 = _PyMem_RawWcsdup(str);\n        if (str2 == NULL) {\n            return _PyStatus_NO_MEMORY();\n        }\n    }\n    else {\n        str2 = NULL;\n    }\n    PyMem_RawFree(*config_str);\n    *config_str = str2;\n    return _PyStatus_OK();\n}\n\n\nstatic PyStatus\nconfig_set_bytes_string(PyConfig *config, wchar_t **config_str,\n                        const char *str, const char *decode_err_msg)\n{\n    PyStatus status = _Py_PreInitializeFromConfig(config, NULL);\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n\n    wchar_t *str2;\n    if (str != NULL) {\n        size_t len;\n        str2 = Py_DecodeLocale(str, &len);\n        if (str2 == NULL) {\n            if (len == (size_t)-2) {\n                return _PyStatus_ERR(decode_err_msg);\n            }\n            else {\n                return  _PyStatus_NO_MEMORY();\n            }\n        }\n    }\n    else {\n        str2 = NULL;\n    }\n    PyMem_RawFree(*config_str);\n    *config_str = str2;\n    return _PyStatus_OK();\n}\n\n\n#define CONFIG_SET_BYTES_STR(config, config_str, str, NAME) \\\n    config_set_bytes_string(config, config_str, str, \"cannot decode \" NAME)\n\n\n/* Decode str using Py_DecodeLocale() and set the result into *config_str.\n   Pre-initialize Python if needed to ensure that encodings are properly\n   configured. */\nPyStatus\nPyConfig_SetBytesString(PyConfig *config, wchar_t **config_str,\n                        const char *str)\n{\n    return CONFIG_SET_BYTES_STR(config, config_str, str, \"string\");\n}\n\n\nPyStatus\n_PyConfig_Copy(PyConfig *config, const PyConfig *config2)\n{\n    PyStatus status;\n\n    PyConfig_Clear(config);\n\n#define COPY_ATTR(ATTR) config->ATTR = config2->ATTR\n#define COPY_WSTR_ATTR(ATTR) \\\n    do { \\\n        status = PyConfig_SetString(config, &config->ATTR, config2->ATTR); \\\n        if (_PyStatus_EXCEPTION(status)) { \\\n            return status; \\\n        } \\\n    } while (0)\n#define COPY_WSTRLIST(LIST) \\\n    do { \\\n        if (_PyWideStringList_Copy(&config->LIST, &config2->LIST) < 0) { \\\n            return _PyStatus_NO_MEMORY(); \\\n        } \\\n    } while (0)\n\n    COPY_ATTR(_config_init);\n    COPY_ATTR(isolated);\n    COPY_ATTR(use_environment);\n    COPY_ATTR(dev_mode);\n    COPY_ATTR(install_signal_handlers);\n    COPY_ATTR(use_hash_seed);\n    COPY_ATTR(hash_seed);\n    COPY_ATTR(_install_importlib);\n    COPY_ATTR(faulthandler);\n    COPY_ATTR(tracemalloc);\n    COPY_ATTR(perf_profiling);\n    COPY_ATTR(import_time);\n    COPY_ATTR(code_debug_ranges);\n    COPY_ATTR(show_ref_count);\n    COPY_ATTR(dump_refs);\n    COPY_ATTR(dump_refs_file);\n    COPY_ATTR(malloc_stats);\n\n    COPY_WSTR_ATTR(pycache_prefix);\n    COPY_WSTR_ATTR(pythonpath_env);\n    COPY_WSTR_ATTR(home);\n    COPY_WSTR_ATTR(program_name);\n\n    COPY_ATTR(parse_argv);\n    COPY_WSTRLIST(argv);\n    COPY_WSTRLIST(warnoptions);\n    COPY_WSTRLIST(xoptions);\n    COPY_WSTRLIST(module_search_paths);\n    COPY_ATTR(module_search_paths_set);\n    COPY_WSTR_ATTR(stdlib_dir);\n\n    COPY_WSTR_ATTR(executable);\n    COPY_WSTR_ATTR(base_executable);\n    COPY_WSTR_ATTR(prefix);\n    COPY_WSTR_ATTR(base_prefix);\n    COPY_WSTR_ATTR(exec_prefix);\n    COPY_WSTR_ATTR(base_exec_prefix);\n    COPY_WSTR_ATTR(platlibdir);\n\n    COPY_ATTR(site_import);\n    COPY_ATTR(bytes_warning);\n    COPY_ATTR(warn_default_encoding);\n    COPY_ATTR(inspect);\n    COPY_ATTR(interactive);\n    COPY_ATTR(optimization_level);\n    COPY_ATTR(parser_debug);\n    COPY_ATTR(write_bytecode);\n    COPY_ATTR(verbose);\n    COPY_ATTR(quiet);\n    COPY_ATTR(user_site_directory);\n    COPY_ATTR(configure_c_stdio);\n    COPY_ATTR(buffered_stdio);\n    COPY_WSTR_ATTR(filesystem_encoding);\n    COPY_WSTR_ATTR(filesystem_errors);\n    COPY_WSTR_ATTR(stdio_encoding);\n    COPY_WSTR_ATTR(stdio_errors);\n#ifdef MS_WINDOWS\n    COPY_ATTR(legacy_windows_stdio);\n#endif\n    COPY_ATTR(skip_source_first_line);\n    COPY_WSTR_ATTR(run_command);\n    COPY_WSTR_ATTR(run_module);\n    COPY_WSTR_ATTR(run_filename);\n    COPY_WSTR_ATTR(check_hash_pycs_mode);\n    COPY_ATTR(pathconfig_warnings);\n    COPY_ATTR(_init_main);\n    COPY_ATTR(use_frozen_modules);\n    COPY_ATTR(safe_path);\n    COPY_WSTRLIST(orig_argv);\n    COPY_ATTR(_is_python_build);\n    COPY_ATTR(int_max_str_digits);\n\n#undef COPY_ATTR\n#undef COPY_WSTR_ATTR\n#undef COPY_WSTRLIST\n    return _PyStatus_OK();\n}\n\n\nPyObject *\n_PyConfig_AsDict(const PyConfig *config)\n{\n    PyObject *dict = PyDict_New();\n    if (dict == NULL) {\n        return NULL;\n    }\n\n#define SET_ITEM(KEY, EXPR) \\\n        do { \\\n            PyObject *obj = (EXPR); \\\n            if (obj == NULL) { \\\n                goto fail; \\\n            } \\\n            int res = PyDict_SetItemString(dict, (KEY), obj); \\\n            Py_DECREF(obj); \\\n            if (res < 0) { \\\n                goto fail; \\\n            } \\\n        } while (0)\n#define SET_ITEM_INT(ATTR) \\\n    SET_ITEM(#ATTR, PyLong_FromLong(config->ATTR))\n#define SET_ITEM_UINT(ATTR) \\\n    SET_ITEM(#ATTR, PyLong_FromUnsignedLong(config->ATTR))\n#define FROM_WSTRING(STR) \\\n    ((STR != NULL) ? \\\n        PyUnicode_FromWideChar(STR, -1) \\\n        : Py_NewRef(Py_None))\n#define SET_ITEM_WSTR(ATTR) \\\n    SET_ITEM(#ATTR, FROM_WSTRING(config->ATTR))\n#define SET_ITEM_WSTRLIST(LIST) \\\n    SET_ITEM(#LIST, _PyWideStringList_AsList(&config->LIST))\n\n    SET_ITEM_INT(_config_init);\n    SET_ITEM_INT(isolated);\n    SET_ITEM_INT(use_environment);\n    SET_ITEM_INT(dev_mode);\n    SET_ITEM_INT(install_signal_handlers);\n    SET_ITEM_INT(use_hash_seed);\n    SET_ITEM_UINT(hash_seed);\n    SET_ITEM_INT(faulthandler);\n    SET_ITEM_INT(tracemalloc);\n    SET_ITEM_INT(perf_profiling);\n    SET_ITEM_INT(import_time);\n    SET_ITEM_INT(code_debug_ranges);\n    SET_ITEM_INT(show_ref_count);\n    SET_ITEM_INT(dump_refs);\n    SET_ITEM_INT(malloc_stats);\n    SET_ITEM_WSTR(filesystem_encoding);\n    SET_ITEM_WSTR(filesystem_errors);\n    SET_ITEM_WSTR(pycache_prefix);\n    SET_ITEM_WSTR(program_name);\n    SET_ITEM_INT(parse_argv);\n    SET_ITEM_WSTRLIST(argv);\n    SET_ITEM_WSTRLIST(xoptions);\n    SET_ITEM_WSTRLIST(warnoptions);\n    SET_ITEM_WSTR(pythonpath_env);\n    SET_ITEM_WSTR(home);\n    SET_ITEM_INT(module_search_paths_set);\n    SET_ITEM_WSTRLIST(module_search_paths);\n    SET_ITEM_WSTR(stdlib_dir);\n    SET_ITEM_WSTR(executable);\n    SET_ITEM_WSTR(base_executable);\n    SET_ITEM_WSTR(prefix);\n    SET_ITEM_WSTR(base_prefix);\n    SET_ITEM_WSTR(exec_prefix);\n    SET_ITEM_WSTR(base_exec_prefix);\n    SET_ITEM_WSTR(platlibdir);\n    SET_ITEM_INT(site_import);\n    SET_ITEM_INT(bytes_warning);\n    SET_ITEM_INT(warn_default_encoding);\n    SET_ITEM_INT(inspect);\n    SET_ITEM_INT(interactive);\n    SET_ITEM_INT(optimization_level);\n    SET_ITEM_INT(parser_debug);\n    SET_ITEM_INT(write_bytecode);\n    SET_ITEM_INT(verbose);\n    SET_ITEM_INT(quiet);\n    SET_ITEM_INT(user_site_directory);\n    SET_ITEM_INT(configure_c_stdio);\n    SET_ITEM_INT(buffered_stdio);\n    SET_ITEM_WSTR(stdio_encoding);\n    SET_ITEM_WSTR(stdio_errors);\n#ifdef MS_WINDOWS\n    SET_ITEM_INT(legacy_windows_stdio);\n#endif\n    SET_ITEM_INT(skip_source_first_line);\n    SET_ITEM_WSTR(run_command);\n    SET_ITEM_WSTR(run_module);\n    SET_ITEM_WSTR(run_filename);\n    SET_ITEM_INT(_install_importlib);\n    SET_ITEM_WSTR(check_hash_pycs_mode);\n    SET_ITEM_INT(pathconfig_warnings);\n    SET_ITEM_INT(_init_main);\n    SET_ITEM_WSTRLIST(orig_argv);\n    SET_ITEM_INT(use_frozen_modules);\n    SET_ITEM_INT(safe_path);\n    SET_ITEM_INT(_is_python_build);\n    SET_ITEM_INT(int_max_str_digits);\n\n    return dict;\n\nfail:\n    Py_DECREF(dict);\n    return NULL;\n\n#undef FROM_WSTRING\n#undef SET_ITEM\n#undef SET_ITEM_INT\n#undef SET_ITEM_UINT\n#undef SET_ITEM_WSTR\n#undef SET_ITEM_WSTRLIST\n}\n\n\nstatic PyObject*\nconfig_dict_get(PyObject *dict, const char *name)\n{\n    PyObject *item = _PyDict_GetItemStringWithError(dict, name);\n    if (item == NULL && !PyErr_Occurred()) {\n        PyErr_Format(PyExc_ValueError, \"missing config key: %s\", name);\n        return NULL;\n    }\n    return item;\n}\n\n\nstatic void\nconfig_dict_invalid_value(const char *name)\n{\n    PyErr_Format(PyExc_ValueError, \"invalid config value: %s\", name);\n}\n\n\nstatic void\nconfig_dict_invalid_type(const char *name)\n{\n    PyErr_Format(PyExc_TypeError, \"invalid config type: %s\", name);\n}\n\n\nstatic int\nconfig_dict_get_int(PyObject *dict, const char *name, int *result)\n{\n    PyObject *item = config_dict_get(dict, name);\n    if (item == NULL) {\n        return -1;\n    }\n    int value = _PyLong_AsInt(item);\n    if (value == -1 && PyErr_Occurred()) {\n        if (PyErr_ExceptionMatches(PyExc_TypeError)) {\n            config_dict_invalid_type(name);\n        }\n        else if (PyErr_ExceptionMatches(PyExc_OverflowError)) {\n            config_dict_invalid_value(name);\n        }\n        return -1;\n    }\n    *result = value;\n    return 0;\n}\n\n\nstatic int\nconfig_dict_get_ulong(PyObject *dict, const char *name, unsigned long *result)\n{\n    PyObject *item = config_dict_get(dict, name);\n    if (item == NULL) {\n        return -1;\n    }\n    unsigned long value = PyLong_AsUnsignedLong(item);\n    if (value == (unsigned long)-1 && PyErr_Occurred()) {\n        if (PyErr_ExceptionMatches(PyExc_TypeError)) {\n            config_dict_invalid_type(name);\n        }\n        else if (PyErr_ExceptionMatches(PyExc_OverflowError)) {\n            config_dict_invalid_value(name);\n        }\n        return -1;\n    }\n    *result = value;\n    return 0;\n}\n\n\nstatic int\nconfig_dict_get_wstr(PyObject *dict, const char *name, PyConfig *config,\n                     wchar_t **result)\n{\n    PyObject *item = config_dict_get(dict, name);\n    if (item == NULL) {\n        return -1;\n    }\n    PyStatus status;\n    if (item == Py_None) {\n        status = PyConfig_SetString(config, result, NULL);\n    }\n    else if (!PyUnicode_Check(item)) {\n        config_dict_invalid_type(name);\n        return -1;\n    }\n    else {\n        wchar_t *wstr = PyUnicode_AsWideCharString(item, NULL);\n        if (wstr == NULL) {\n            return -1;\n        }\n        status = PyConfig_SetString(config, result, wstr);\n        PyMem_Free(wstr);\n    }\n    if (_PyStatus_EXCEPTION(status)) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    return 0;\n}\n\n\nstatic int\nconfig_dict_get_wstrlist(PyObject *dict, const char *name, PyConfig *config,\n                         PyWideStringList *result)\n{\n    PyObject *list = config_dict_get(dict, name);\n    if (list == NULL) {\n        return -1;\n    }\n\n    if (!PyList_CheckExact(list)) {\n        config_dict_invalid_type(name);\n        return -1;\n    }\n\n    PyWideStringList wstrlist = _PyWideStringList_INIT;\n    for (Py_ssize_t i=0; i < PyList_GET_SIZE(list); i++) {\n        PyObject *item = PyList_GET_ITEM(list, i);\n\n        if (item == Py_None) {\n            config_dict_invalid_value(name);\n            goto error;\n        }\n        else if (!PyUnicode_Check(item)) {\n            config_dict_invalid_type(name);\n            goto error;\n        }\n        wchar_t *wstr = PyUnicode_AsWideCharString(item, NULL);\n        if (wstr == NULL) {\n            goto error;\n        }\n        PyStatus status = PyWideStringList_Append(&wstrlist, wstr);\n        PyMem_Free(wstr);\n        if (_PyStatus_EXCEPTION(status)) {\n            PyErr_NoMemory();\n            goto error;\n        }\n    }\n\n    if (_PyWideStringList_Copy(result, &wstrlist) < 0) {\n        PyErr_NoMemory();\n        goto error;\n    }\n    _PyWideStringList_Clear(&wstrlist);\n    return 0;\n\nerror:\n    _PyWideStringList_Clear(&wstrlist);\n    return -1;\n}\n\n\nint\n_PyConfig_FromDict(PyConfig *config, PyObject *dict)\n{\n    if (!PyDict_Check(dict)) {\n        PyErr_SetString(PyExc_TypeError, \"dict expected\");\n        return -1;\n    }\n\n#define CHECK_VALUE(NAME, TEST) \\\n    if (!(TEST)) { \\\n        config_dict_invalid_value(NAME); \\\n        return -1; \\\n    }\n#define GET_UINT(KEY) \\\n    do { \\\n        if (config_dict_get_int(dict, #KEY, &config->KEY) < 0) { \\\n            return -1; \\\n        } \\\n        CHECK_VALUE(#KEY, config->KEY >= 0); \\\n    } while (0)\n#define GET_INT(KEY) \\\n    do { \\\n        if (config_dict_get_int(dict, #KEY, &config->KEY) < 0) { \\\n            return -1; \\\n        } \\\n    } while (0)\n#define GET_WSTR(KEY) \\\n    do { \\\n        if (config_dict_get_wstr(dict, #KEY, config, &config->KEY) < 0) { \\\n            return -1; \\\n        } \\\n        CHECK_VALUE(#KEY, config->KEY != NULL); \\\n    } while (0)\n#define GET_WSTR_OPT(KEY) \\\n    do { \\\n        if (config_dict_get_wstr(dict, #KEY, config, &config->KEY) < 0) { \\\n            return -1; \\\n        } \\\n    } while (0)\n#define GET_WSTRLIST(KEY) \\\n    do { \\\n        if (config_dict_get_wstrlist(dict, #KEY, config, &config->KEY) < 0) { \\\n            return -1; \\\n        } \\\n    } while (0)\n\n    GET_UINT(_config_init);\n    CHECK_VALUE(\"_config_init\",\n                config->_config_init == _PyConfig_INIT_COMPAT\n                || config->_config_init == _PyConfig_INIT_PYTHON\n                || config->_config_init == _PyConfig_INIT_ISOLATED);\n    GET_UINT(isolated);\n    GET_UINT(use_environment);\n    GET_UINT(dev_mode);\n    GET_UINT(install_signal_handlers);\n    GET_UINT(use_hash_seed);\n    if (config_dict_get_ulong(dict, \"hash_seed\", &config->hash_seed) < 0) {\n        return -1;\n    }\n    CHECK_VALUE(\"hash_seed\", config->hash_seed <= MAX_HASH_SEED);\n    GET_UINT(faulthandler);\n    GET_UINT(tracemalloc);\n    GET_UINT(perf_profiling);\n    GET_UINT(import_time);\n    GET_UINT(code_debug_ranges);\n    GET_UINT(show_ref_count);\n    GET_UINT(dump_refs);\n    GET_UINT(malloc_stats);\n    GET_WSTR(filesystem_encoding);\n    GET_WSTR(filesystem_errors);\n    GET_WSTR_OPT(pycache_prefix);\n    GET_UINT(parse_argv);\n    GET_WSTRLIST(orig_argv);\n    GET_WSTRLIST(argv);\n    GET_WSTRLIST(xoptions);\n    GET_WSTRLIST(warnoptions);\n    GET_UINT(site_import);\n    GET_UINT(bytes_warning);\n    GET_UINT(warn_default_encoding);\n    GET_UINT(inspect);\n    GET_UINT(interactive);\n    GET_UINT(optimization_level);\n    GET_UINT(parser_debug);\n    GET_UINT(write_bytecode);\n    GET_UINT(verbose);\n    GET_UINT(quiet);\n    GET_UINT(user_site_directory);\n    GET_UINT(configure_c_stdio);\n    GET_UINT(buffered_stdio);\n    GET_WSTR(stdio_encoding);\n    GET_WSTR(stdio_errors);\n#ifdef MS_WINDOWS\n    GET_UINT(legacy_windows_stdio);\n#endif\n    GET_WSTR(check_hash_pycs_mode);\n\n    GET_UINT(pathconfig_warnings);\n    GET_WSTR(program_name);\n    GET_WSTR_OPT(pythonpath_env);\n    GET_WSTR_OPT(home);\n    GET_WSTR(platlibdir);\n\n    // Path configuration output\n    GET_UINT(module_search_paths_set);\n    GET_WSTRLIST(module_search_paths);\n    GET_WSTR_OPT(stdlib_dir);\n    GET_WSTR_OPT(executable);\n    GET_WSTR_OPT(base_executable);\n    GET_WSTR_OPT(prefix);\n    GET_WSTR_OPT(base_prefix);\n    GET_WSTR_OPT(exec_prefix);\n    GET_WSTR_OPT(base_exec_prefix);\n\n    GET_UINT(skip_source_first_line);\n    GET_WSTR_OPT(run_command);\n    GET_WSTR_OPT(run_module);\n    GET_WSTR_OPT(run_filename);\n\n    GET_UINT(_install_importlib);\n    GET_UINT(_init_main);\n    GET_UINT(use_frozen_modules);\n    GET_UINT(safe_path);\n    GET_UINT(_is_python_build);\n    GET_INT(int_max_str_digits);\n\n#undef CHECK_VALUE\n#undef GET_UINT\n#undef GET_INT\n#undef GET_WSTR\n#undef GET_WSTR_OPT\n    return 0;\n}\n\n\nstatic const char*\nconfig_get_env(const PyConfig *config, const char *name)\n{\n    return _Py_GetEnv(config->use_environment, name);\n}\n\n\n/* Get a copy of the environment variable as wchar_t*.\n   Return 0 on success, but *dest can be NULL.\n   Return -1 on memory allocation failure. Return -2 on decoding error. */\nstatic PyStatus\nconfig_get_env_dup(PyConfig *config,\n                   wchar_t **dest,\n                   wchar_t *wname, char *name,\n                   const char *decode_err_msg)\n{\n    assert(*dest == NULL);\n    assert(config->use_environment >= 0);\n\n    if (!config->use_environment) {\n        *dest = NULL;\n        return _PyStatus_OK();\n    }\n\n#ifdef MS_WINDOWS\n    const wchar_t *var = _wgetenv(wname);\n    if (!var || var[0] == '\\0') {\n        *dest = NULL;\n        return _PyStatus_OK();\n    }\n\n    return PyConfig_SetString(config, dest, var);\n#else\n    const char *var = getenv(name);\n    if (!var || var[0] == '\\0') {\n        *dest = NULL;\n        return _PyStatus_OK();\n    }\n\n    return config_set_bytes_string(config, dest, var, decode_err_msg);\n#endif\n}\n\n\n#define CONFIG_GET_ENV_DUP(CONFIG, DEST, WNAME, NAME) \\\n    config_get_env_dup(CONFIG, DEST, WNAME, NAME, \"cannot decode \" NAME)\n\n\nstatic void\nconfig_get_global_vars(PyConfig *config)\n{\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n    if (config->_config_init != _PyConfig_INIT_COMPAT) {\n        /* Python and Isolated configuration ignore global variables */\n        return;\n    }\n\n#define COPY_FLAG(ATTR, VALUE) \\\n        if (config->ATTR == -1) { \\\n            config->ATTR = VALUE; \\\n        }\n#define COPY_NOT_FLAG(ATTR, VALUE) \\\n        if (config->ATTR == -1) { \\\n            config->ATTR = !(VALUE); \\\n        }\n\n    COPY_FLAG(isolated, Py_IsolatedFlag);\n    COPY_NOT_FLAG(use_environment, Py_IgnoreEnvironmentFlag);\n    COPY_FLAG(bytes_warning, Py_BytesWarningFlag);\n    COPY_FLAG(inspect, Py_InspectFlag);\n    COPY_FLAG(interactive, Py_InteractiveFlag);\n    COPY_FLAG(optimization_level, Py_OptimizeFlag);\n    COPY_FLAG(parser_debug, Py_DebugFlag);\n    COPY_FLAG(verbose, Py_VerboseFlag);\n    COPY_FLAG(quiet, Py_QuietFlag);\n#ifdef MS_WINDOWS\n    COPY_FLAG(legacy_windows_stdio, Py_LegacyWindowsStdioFlag);\n#endif\n    COPY_NOT_FLAG(pathconfig_warnings, Py_FrozenFlag);\n\n    COPY_NOT_FLAG(buffered_stdio, Py_UnbufferedStdioFlag);\n    COPY_NOT_FLAG(site_import, Py_NoSiteFlag);\n    COPY_NOT_FLAG(write_bytecode, Py_DontWriteBytecodeFlag);\n    COPY_NOT_FLAG(user_site_directory, Py_NoUserSiteDirectory);\n\n#undef COPY_FLAG\n#undef COPY_NOT_FLAG\n_Py_COMP_DIAG_POP\n}\n\n\n/* Set Py_xxx global configuration variables from 'config' configuration. */\nstatic void\nconfig_set_global_vars(const PyConfig *config)\n{\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n#define COPY_FLAG(ATTR, VAR) \\\n        if (config->ATTR != -1) { \\\n            VAR = config->ATTR; \\\n        }\n#define COPY_NOT_FLAG(ATTR, VAR) \\\n        if (config->ATTR != -1) { \\\n            VAR = !config->ATTR; \\\n        }\n\n    COPY_FLAG(isolated, Py_IsolatedFlag);\n    COPY_NOT_FLAG(use_environment, Py_IgnoreEnvironmentFlag);\n    COPY_FLAG(bytes_warning, Py_BytesWarningFlag);\n    COPY_FLAG(inspect, Py_InspectFlag);\n    COPY_FLAG(interactive, Py_InteractiveFlag);\n    COPY_FLAG(optimization_level, Py_OptimizeFlag);\n    COPY_FLAG(parser_debug, Py_DebugFlag);\n    COPY_FLAG(verbose, Py_VerboseFlag);\n    COPY_FLAG(quiet, Py_QuietFlag);\n#ifdef MS_WINDOWS\n    COPY_FLAG(legacy_windows_stdio, Py_LegacyWindowsStdioFlag);\n#endif\n    COPY_NOT_FLAG(pathconfig_warnings, Py_FrozenFlag);\n\n    COPY_NOT_FLAG(buffered_stdio, Py_UnbufferedStdioFlag);\n    COPY_NOT_FLAG(site_import, Py_NoSiteFlag);\n    COPY_NOT_FLAG(write_bytecode, Py_DontWriteBytecodeFlag);\n    COPY_NOT_FLAG(user_site_directory, Py_NoUserSiteDirectory);\n\n    /* Random or non-zero hash seed */\n    Py_HashRandomizationFlag = (config->use_hash_seed == 0 ||\n                                config->hash_seed != 0);\n\n#undef COPY_FLAG\n#undef COPY_NOT_FLAG\n_Py_COMP_DIAG_POP\n}\n\n\nstatic const wchar_t*\nconfig_get_xoption(const PyConfig *config, wchar_t *name)\n{\n    return _Py_get_xoption(&config->xoptions, name);\n}\n\nstatic const wchar_t*\nconfig_get_xoption_value(const PyConfig *config, wchar_t *name)\n{\n    const wchar_t *xoption = config_get_xoption(config, name);\n    if (xoption == NULL) {\n        return NULL;\n    }\n    const wchar_t *sep = wcschr(xoption, L'=');\n    return sep ? sep + 1 : L\"\";\n}\n\n\nstatic PyStatus\nconfig_init_hash_seed(PyConfig *config)\n{\n    static_assert(sizeof(_Py_HashSecret_t) == sizeof(_Py_HashSecret.uc),\n                  \"_Py_HashSecret_t has wrong size\");\n\n    const char *seed_text = config_get_env(config, \"PYTHONHASHSEED\");\n\n    /* Convert a text seed to a numeric one */\n    if (seed_text && strcmp(seed_text, \"random\") != 0) {\n        const char *endptr = seed_text;\n        unsigned long seed;\n        errno = 0;\n        seed = strtoul(seed_text, (char **)&endptr, 10);\n        if (*endptr != '\\0'\n            || seed > MAX_HASH_SEED\n            || (errno == ERANGE && seed == ULONG_MAX))\n        {\n            return _PyStatus_ERR(\"PYTHONHASHSEED must be \\\"random\\\" \"\n                                \"or an integer in range [0; 4294967295]\");\n        }\n        /* Use a specific hash */\n        config->use_hash_seed = 1;\n        config->hash_seed = seed;\n    }\n    else {\n        /* Use a random hash */\n        config->use_hash_seed = 0;\n        config->hash_seed = 0;\n    }\n    return _PyStatus_OK();\n}\n\n\nstatic int\nconfig_wstr_to_int(const wchar_t *wstr, int *result)\n{\n    const wchar_t *endptr = wstr;\n    errno = 0;\n    long value = wcstol(wstr, (wchar_t **)&endptr, 10);\n    if (*endptr != '\\0' || errno == ERANGE) {\n        return -1;\n    }\n    if (value < INT_MIN || value > INT_MAX) {\n        return -1;\n    }\n\n    *result = (int)value;\n    return 0;\n}\n\n\nstatic PyStatus\nconfig_read_env_vars(PyConfig *config)\n{\n    PyStatus status;\n    int use_env = config->use_environment;\n\n    /* Get environment variables */\n    _Py_get_env_flag(use_env, &config->parser_debug, \"PYTHONDEBUG\");\n    _Py_get_env_flag(use_env, &config->verbose, \"PYTHONVERBOSE\");\n    _Py_get_env_flag(use_env, &config->optimization_level, \"PYTHONOPTIMIZE\");\n    _Py_get_env_flag(use_env, &config->inspect, \"PYTHONINSPECT\");\n\n    int dont_write_bytecode = 0;\n    _Py_get_env_flag(use_env, &dont_write_bytecode, \"PYTHONDONTWRITEBYTECODE\");\n    if (dont_write_bytecode) {\n        config->write_bytecode = 0;\n    }\n\n    int no_user_site_directory = 0;\n    _Py_get_env_flag(use_env, &no_user_site_directory, \"PYTHONNOUSERSITE\");\n    if (no_user_site_directory) {\n        config->user_site_directory = 0;\n    }\n\n    int unbuffered_stdio = 0;\n    _Py_get_env_flag(use_env, &unbuffered_stdio, \"PYTHONUNBUFFERED\");\n    if (unbuffered_stdio) {\n        config->buffered_stdio = 0;\n    }\n\n#ifdef MS_WINDOWS\n    _Py_get_env_flag(use_env, &config->legacy_windows_stdio,\n                     \"PYTHONLEGACYWINDOWSSTDIO\");\n#endif\n\n    if (config_get_env(config, \"PYTHONDUMPREFS\")) {\n        config->dump_refs = 1;\n    }\n    if (config_get_env(config, \"PYTHONMALLOCSTATS\")) {\n        config->malloc_stats = 1;\n    }\n\n    if (config->dump_refs_file == NULL) {\n        status = CONFIG_GET_ENV_DUP(config, &config->dump_refs_file,\n                                    L\"PYTHONDUMPREFSFILE\", \"PYTHONDUMPREFSFILE\");\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    if (config->pythonpath_env == NULL) {\n        status = CONFIG_GET_ENV_DUP(config, &config->pythonpath_env,\n                                    L\"PYTHONPATH\", \"PYTHONPATH\");\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    if(config->platlibdir == NULL) {\n        status = CONFIG_GET_ENV_DUP(config, &config->platlibdir,\n                                    L\"PYTHONPLATLIBDIR\", \"PYTHONPLATLIBDIR\");\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    if (config->use_hash_seed < 0) {\n        status = config_init_hash_seed(config);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    if (config_get_env(config, \"PYTHONSAFEPATH\")) {\n        config->safe_path = 1;\n    }\n\n    return _PyStatus_OK();\n}\n\nstatic PyStatus\nconfig_init_perf_profiling(PyConfig *config)\n{\n    int active = 0;\n    const char *env = config_get_env(config, \"PYTHONPERFSUPPORT\");\n    if (env) {\n        if (_Py_str_to_int(env, &active) != 0) {\n            active = 0;\n        }\n        if (active) {\n            config->perf_profiling = 1;\n        }\n    }\n    const wchar_t *xoption = config_get_xoption(config, L\"perf\");\n    if (xoption) {\n        config->perf_profiling = 1;\n    }\n    return _PyStatus_OK();\n\n}\n\nstatic PyStatus\nconfig_init_tracemalloc(PyConfig *config)\n{\n    int nframe;\n    int valid;\n\n    const char *env = config_get_env(config, \"PYTHONTRACEMALLOC\");\n    if (env) {\n        if (!_Py_str_to_int(env, &nframe)) {\n            valid = (nframe >= 0);\n        }\n        else {\n            valid = 0;\n        }\n        if (!valid) {\n            return _PyStatus_ERR(\"PYTHONTRACEMALLOC: invalid number of frames\");\n        }\n        config->tracemalloc = nframe;\n    }\n\n    const wchar_t *xoption = config_get_xoption(config, L\"tracemalloc\");\n    if (xoption) {\n        const wchar_t *sep = wcschr(xoption, L'=');\n        if (sep) {\n            if (!config_wstr_to_int(sep + 1, &nframe)) {\n                valid = (nframe >= 0);\n            }\n            else {\n                valid = 0;\n            }\n            if (!valid) {\n                return _PyStatus_ERR(\"-X tracemalloc=NFRAME: \"\n                                     \"invalid number of frames\");\n            }\n        }\n        else {\n            /* -X tracemalloc behaves as -X tracemalloc=1 */\n            nframe = 1;\n        }\n        config->tracemalloc = nframe;\n    }\n    return _PyStatus_OK();\n}\n\nstatic PyStatus\nconfig_init_int_max_str_digits(PyConfig *config)\n{\n    int maxdigits;\n\n    const char *env = config_get_env(config, \"PYTHONINTMAXSTRDIGITS\");\n    if (env) {\n        bool valid = 0;\n        if (!_Py_str_to_int(env, &maxdigits)) {\n            valid = ((maxdigits == 0) || (maxdigits >= _PY_LONG_MAX_STR_DIGITS_THRESHOLD));\n        }\n        if (!valid) {\n#define STRINGIFY(VAL) _STRINGIFY(VAL)\n#define _STRINGIFY(VAL) #VAL\n            return _PyStatus_ERR(\n                    \"PYTHONINTMAXSTRDIGITS: invalid limit; must be >= \"\n                    STRINGIFY(_PY_LONG_MAX_STR_DIGITS_THRESHOLD)\n                    \" or 0 for unlimited.\");\n        }\n        config->int_max_str_digits = maxdigits;\n    }\n\n    const wchar_t *xoption = config_get_xoption(config, L\"int_max_str_digits\");\n    if (xoption) {\n        const wchar_t *sep = wcschr(xoption, L'=');\n        bool valid = 0;\n        if (sep) {\n            if (!config_wstr_to_int(sep + 1, &maxdigits)) {\n                valid = ((maxdigits == 0) || (maxdigits >= _PY_LONG_MAX_STR_DIGITS_THRESHOLD));\n            }\n        }\n        if (!valid) {\n            return _PyStatus_ERR(\n                    \"-X int_max_str_digits: invalid limit; must be >= \"\n                    STRINGIFY(_PY_LONG_MAX_STR_DIGITS_THRESHOLD)\n                    \" or 0 for unlimited.\");\n#undef _STRINGIFY\n#undef STRINGIFY\n        }\n        config->int_max_str_digits = maxdigits;\n    }\n    if (config->int_max_str_digits < 0) {\n        config->int_max_str_digits = _PY_LONG_DEFAULT_MAX_STR_DIGITS;\n    }\n    return _PyStatus_OK();\n}\n\nstatic PyStatus\nconfig_init_pycache_prefix(PyConfig *config)\n{\n    assert(config->pycache_prefix == NULL);\n\n    const wchar_t *xoption = config_get_xoption(config, L\"pycache_prefix\");\n    if (xoption) {\n        const wchar_t *sep = wcschr(xoption, L'=');\n        if (sep && wcslen(sep) > 1) {\n            config->pycache_prefix = _PyMem_RawWcsdup(sep + 1);\n            if (config->pycache_prefix == NULL) {\n                return _PyStatus_NO_MEMORY();\n            }\n        }\n        else {\n            // PYTHONPYCACHEPREFIX env var ignored\n            // if \"-X pycache_prefix=\" option is used\n            config->pycache_prefix = NULL;\n        }\n        return _PyStatus_OK();\n    }\n\n    return CONFIG_GET_ENV_DUP(config, &config->pycache_prefix,\n                              L\"PYTHONPYCACHEPREFIX\",\n                              \"PYTHONPYCACHEPREFIX\");\n}\n\n\nstatic PyStatus\nconfig_read_complex_options(PyConfig *config)\n{\n    /* More complex options configured by env var and -X option */\n    if (config->faulthandler < 0) {\n        if (config_get_env(config, \"PYTHONFAULTHANDLER\")\n           || config_get_xoption(config, L\"faulthandler\")) {\n            config->faulthandler = 1;\n        }\n    }\n    if (config_get_env(config, \"PYTHONPROFILEIMPORTTIME\")\n       || config_get_xoption(config, L\"importtime\")) {\n        config->import_time = 1;\n    }\n\n    if (config_get_env(config, \"PYTHONNODEBUGRANGES\")\n       || config_get_xoption(config, L\"no_debug_ranges\")) {\n        config->code_debug_ranges = 0;\n    }\n\n    PyStatus status;\n    if (config->tracemalloc < 0) {\n        status = config_init_tracemalloc(config);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    if (config->perf_profiling < 0) {\n        status = config_init_perf_profiling(config);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    if (config->int_max_str_digits < 0) {\n        status = config_init_int_max_str_digits(config);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    if (config->pycache_prefix == NULL) {\n        status = config_init_pycache_prefix(config);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n    return _PyStatus_OK();\n}\n\n\nstatic const wchar_t *\nconfig_get_stdio_errors(const PyPreConfig *preconfig)\n{\n    if (preconfig->utf8_mode) {\n        /* UTF-8 Mode uses UTF-8/surrogateescape */\n        return L\"surrogateescape\";\n    }\n\n#ifndef MS_WINDOWS\n    const char *loc = setlocale(LC_CTYPE, NULL);\n    if (loc != NULL) {\n        /* surrogateescape is the default in the legacy C and POSIX locales */\n        if (strcmp(loc, \"C\") == 0 || strcmp(loc, \"POSIX\") == 0) {\n            return L\"surrogateescape\";\n        }\n\n#ifdef PY_COERCE_C_LOCALE\n        /* surrogateescape is the default in locale coercion target locales */\n        if (_Py_IsLocaleCoercionTarget(loc)) {\n            return L\"surrogateescape\";\n        }\n#endif\n    }\n\n    return L\"strict\";\n#else\n    /* On Windows, always use surrogateescape by default */\n    return L\"surrogateescape\";\n#endif\n}\n\n\n// See also config_get_fs_encoding()\nstatic PyStatus\nconfig_get_locale_encoding(PyConfig *config, const PyPreConfig *preconfig,\n                           wchar_t **locale_encoding)\n{\n    wchar_t *encoding;\n    if (preconfig->utf8_mode) {\n        encoding = _PyMem_RawWcsdup(L\"utf-8\");\n    }\n    else {\n        encoding = _Py_GetLocaleEncoding();\n    }\n    if (encoding == NULL) {\n        return _PyStatus_NO_MEMORY();\n    }\n    PyStatus status = PyConfig_SetString(config, locale_encoding, encoding);\n    PyMem_RawFree(encoding);\n    return status;\n}\n\n\nstatic PyStatus\nconfig_init_stdio_encoding(PyConfig *config,\n                           const PyPreConfig *preconfig)\n{\n    PyStatus status;\n\n    /* If Py_SetStandardStreamEncoding() has been called, use its\n        arguments if they are not NULL. */\n    if (config->stdio_encoding == NULL && _Py_StandardStreamEncoding != NULL) {\n        status = CONFIG_SET_BYTES_STR(config, &config->stdio_encoding,\n                                      _Py_StandardStreamEncoding,\n                                      \"_Py_StandardStreamEncoding\");\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    if (config->stdio_errors == NULL && _Py_StandardStreamErrors != NULL) {\n        status = CONFIG_SET_BYTES_STR(config, &config->stdio_errors,\n                                      _Py_StandardStreamErrors,\n                                      \"_Py_StandardStreamErrors\");\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    // Exit if encoding and errors are defined\n    if (config->stdio_encoding != NULL && config->stdio_errors != NULL) {\n        return _PyStatus_OK();\n    }\n\n    /* PYTHONIOENCODING environment variable */\n    const char *opt = config_get_env(config, \"PYTHONIOENCODING\");\n    if (opt) {\n        char *pythonioencoding = _PyMem_RawStrdup(opt);\n        if (pythonioencoding == NULL) {\n            return _PyStatus_NO_MEMORY();\n        }\n\n        char *errors = strchr(pythonioencoding, ':');\n        if (errors) {\n            *errors = '\\0';\n            errors++;\n            if (!errors[0]) {\n                errors = NULL;\n            }\n        }\n\n        /* Does PYTHONIOENCODING contain an encoding? */\n        if (pythonioencoding[0]) {\n            if (config->stdio_encoding == NULL) {\n                status = CONFIG_SET_BYTES_STR(config, &config->stdio_encoding,\n                                              pythonioencoding,\n                                              \"PYTHONIOENCODING environment variable\");\n                if (_PyStatus_EXCEPTION(status)) {\n                    PyMem_RawFree(pythonioencoding);\n                    return status;\n                }\n            }\n\n            /* If the encoding is set but not the error handler,\n               use \"strict\" error handler by default.\n               PYTHONIOENCODING=latin1 behaves as\n               PYTHONIOENCODING=latin1:strict. */\n            if (!errors) {\n                errors = \"strict\";\n            }\n        }\n\n        if (config->stdio_errors == NULL && errors != NULL) {\n            status = CONFIG_SET_BYTES_STR(config, &config->stdio_errors,\n                                          errors,\n                                          \"PYTHONIOENCODING environment variable\");\n            if (_PyStatus_EXCEPTION(status)) {\n                PyMem_RawFree(pythonioencoding);\n                return status;\n            }\n        }\n\n        PyMem_RawFree(pythonioencoding);\n    }\n\n    /* Choose the default error handler based on the current locale. */\n    if (config->stdio_encoding == NULL) {\n        status = config_get_locale_encoding(config, preconfig,\n                                            &config->stdio_encoding);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n    if (config->stdio_errors == NULL) {\n        const wchar_t *errors = config_get_stdio_errors(preconfig);\n        assert(errors != NULL);\n\n        status = PyConfig_SetString(config, &config->stdio_errors, errors);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    return _PyStatus_OK();\n}\n\n\n// See also config_get_locale_encoding()\nstatic PyStatus\nconfig_get_fs_encoding(PyConfig *config, const PyPreConfig *preconfig,\n                       wchar_t **fs_encoding)\n{\n#ifdef _Py_FORCE_UTF8_FS_ENCODING\n    return PyConfig_SetString(config, fs_encoding, L\"utf-8\");\n#elif defined(MS_WINDOWS)\n    const wchar_t *encoding;\n    if (preconfig->legacy_windows_fs_encoding) {\n        // Legacy Windows filesystem encoding: mbcs/replace\n        encoding = L\"mbcs\";\n    }\n    else {\n        // Windows defaults to utf-8/surrogatepass (PEP 529)\n        encoding = L\"utf-8\";\n    }\n     return PyConfig_SetString(config, fs_encoding, encoding);\n#else  // !MS_WINDOWS\n    if (preconfig->utf8_mode) {\n        return PyConfig_SetString(config, fs_encoding, L\"utf-8\");\n    }\n\n    if (_Py_GetForceASCII()) {\n        return PyConfig_SetString(config, fs_encoding, L\"ascii\");\n    }\n\n    return config_get_locale_encoding(config, preconfig, fs_encoding);\n#endif  // !MS_WINDOWS\n}\n\n\nstatic PyStatus\nconfig_init_fs_encoding(PyConfig *config, const PyPreConfig *preconfig)\n{\n    PyStatus status;\n\n    if (config->filesystem_encoding == NULL) {\n        status = config_get_fs_encoding(config, preconfig,\n                                        &config->filesystem_encoding);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    if (config->filesystem_errors == NULL) {\n        const wchar_t *errors;\n#ifdef MS_WINDOWS\n        if (preconfig->legacy_windows_fs_encoding) {\n            errors = L\"replace\";\n        }\n        else {\n            errors = L\"surrogatepass\";\n        }\n#else\n        errors = L\"surrogateescape\";\n#endif\n        status = PyConfig_SetString(config, &config->filesystem_errors, errors);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n    return _PyStatus_OK();\n}\n\n\nstatic PyStatus\nconfig_init_import(PyConfig *config, int compute_path_config)\n{\n    PyStatus status;\n\n    status = _PyConfig_InitPathConfig(config, compute_path_config);\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n\n    /* -X frozen_modules=[on|off] */\n    const wchar_t *value = config_get_xoption_value(config, L\"frozen_modules\");\n    if (value == NULL) {\n    }\n    else if (wcscmp(value, L\"on\") == 0) {\n        config->use_frozen_modules = 1;\n    }\n    else if (wcscmp(value, L\"off\") == 0) {\n        config->use_frozen_modules = 0;\n    }\n    else if (wcslen(value) == 0) {\n        // \"-X frozen_modules\" and \"-X frozen_modules=\" both imply \"on\".\n        config->use_frozen_modules = 1;\n    }\n    else {\n        return PyStatus_Error(\"bad value for option -X frozen_modules \"\n                              \"(expected \\\"on\\\" or \\\"off\\\")\");\n    }\n\n    assert(config->use_frozen_modules >= 0);\n    return _PyStatus_OK();\n}\n\nPyStatus\n_PyConfig_InitImportConfig(PyConfig *config)\n{\n    return config_init_import(config, 1);\n}\n\n\nstatic PyStatus\nconfig_read(PyConfig *config, int compute_path_config)\n{\n    PyStatus status;\n    const PyPreConfig *preconfig = &_PyRuntime.preconfig;\n\n    if (config->use_environment) {\n        status = config_read_env_vars(config);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    /* -X options */\n    if (config_get_xoption(config, L\"showrefcount\")) {\n        config->show_ref_count = 1;\n    }\n\n#ifdef Py_STATS\n    if (config_get_xoption(config, L\"pystats\")) {\n        _py_stats = &_py_stats_struct;\n    }\n#endif\n\n    status = config_read_complex_options(config);\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n\n    if (config->_install_importlib) {\n        status = config_init_import(config, compute_path_config);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    /* default values */\n    if (config->dev_mode) {\n        if (config->faulthandler < 0) {\n            config->faulthandler = 1;\n        }\n    }\n    if (config->faulthandler < 0) {\n        config->faulthandler = 0;\n    }\n    if (config->tracemalloc < 0) {\n        config->tracemalloc = 0;\n    }\n    if (config->perf_profiling < 0) {\n        config->perf_profiling = 0;\n    }\n    if (config->use_hash_seed < 0) {\n        config->use_hash_seed = 0;\n        config->hash_seed = 0;\n    }\n\n    if (config->filesystem_encoding == NULL || config->filesystem_errors == NULL) {\n        status = config_init_fs_encoding(config, preconfig);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    status = config_init_stdio_encoding(config, preconfig);\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n\n    if (config->argv.length < 1) {\n        /* Ensure at least one (empty) argument is seen */\n        status = PyWideStringList_Append(&config->argv, L\"\");\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    if (config->check_hash_pycs_mode == NULL) {\n        status = PyConfig_SetString(config, &config->check_hash_pycs_mode,\n                                    L\"default\");\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    if (config->configure_c_stdio < 0) {\n        config->configure_c_stdio = 1;\n    }\n\n    // Only parse arguments once.\n    if (config->parse_argv == 1) {\n        config->parse_argv = 2;\n    }\n\n    return _PyStatus_OK();\n}\n\n\nstatic void\nconfig_init_stdio(const PyConfig *config)\n{\n#if defined(MS_WINDOWS) || defined(__CYGWIN__)\n    /* don't translate newlines (\\r\\n <=> \\n) */\n    _setmode(fileno(stdin), O_BINARY);\n    _setmode(fileno(stdout), O_BINARY);\n    _setmode(fileno(stderr), O_BINARY);\n#endif\n\n    if (!config->buffered_stdio) {\n#ifdef HAVE_SETVBUF\n        setvbuf(stdin,  (char *)NULL, _IONBF, BUFSIZ);\n        setvbuf(stdout, (char *)NULL, _IONBF, BUFSIZ);\n        setvbuf(stderr, (char *)NULL, _IONBF, BUFSIZ);\n#else /* !HAVE_SETVBUF */\n        setbuf(stdin,  (char *)NULL);\n        setbuf(stdout, (char *)NULL);\n        setbuf(stderr, (char *)NULL);\n#endif /* !HAVE_SETVBUF */\n    }\n    else if (config->interactive) {\n#ifdef MS_WINDOWS\n        /* Doesn't have to have line-buffered -- use unbuffered */\n        /* Any set[v]buf(stdin, ...) screws up Tkinter :-( */\n        setvbuf(stdout, (char *)NULL, _IONBF, BUFSIZ);\n#else /* !MS_WINDOWS */\n#ifdef HAVE_SETVBUF\n        setvbuf(stdin,  (char *)NULL, _IOLBF, BUFSIZ);\n        setvbuf(stdout, (char *)NULL, _IOLBF, BUFSIZ);\n#endif /* HAVE_SETVBUF */\n#endif /* !MS_WINDOWS */\n        /* Leave stderr alone - it should be unbuffered anyway. */\n    }\n}\n\n\n/* Write the configuration:\n\n   - set Py_xxx global configuration variables\n   - initialize C standard streams (stdin, stdout, stderr) */\nPyStatus\n_PyConfig_Write(const PyConfig *config, _PyRuntimeState *runtime)\n{\n    config_set_global_vars(config);\n\n    if (config->configure_c_stdio) {\n        config_init_stdio(config);\n    }\n\n    /* Write the new pre-configuration into _PyRuntime */\n    PyPreConfig *preconfig = &runtime->preconfig;\n    preconfig->isolated = config->isolated;\n    preconfig->use_environment = config->use_environment;\n    preconfig->dev_mode = config->dev_mode;\n\n    if (_Py_SetArgcArgv(config->orig_argv.length,\n                        config->orig_argv.items) < 0)\n    {\n        return _PyStatus_NO_MEMORY();\n    }\n    return _PyStatus_OK();\n}\n\n\n/* --- PyConfig command line parser -------------------------- */\n\nstatic void\nconfig_usage(int error, const wchar_t* program)\n{\n    FILE *f = error ? stderr : stdout;\n\n    fprintf(f, usage_line, program);\n    if (error)\n        fprintf(f, \"Try `python -h' for more information.\\n\");\n    else {\n        fputs(usage_help, f);\n    }\n}\n\nstatic void\nconfig_envvars_usage(void)\n{\n    printf(usage_envvars, (wint_t)DELIM, (wint_t)DELIM, PYTHONHOMEHELP);\n}\n\nstatic void\nconfig_xoptions_usage(void)\n{\n    puts(usage_xoptions);\n}\n\nstatic void\nconfig_complete_usage(const wchar_t* program)\n{\n   config_usage(0, program);\n   putchar('\\n');\n   config_envvars_usage();\n   putchar('\\n');\n   config_xoptions_usage();\n}\n\n\n/* Parse the command line arguments */\nstatic PyStatus\nconfig_parse_cmdline(PyConfig *config, PyWideStringList *warnoptions,\n                     Py_ssize_t *opt_index)\n{\n    PyStatus status;\n    const PyWideStringList *argv = &config->argv;\n    int print_version = 0;\n    const wchar_t* program = config->program_name;\n    if (!program && argv->length >= 1) {\n        program = argv->items[0];\n    }\n\n    _PyOS_ResetGetOpt();\n    do {\n        int longindex = -1;\n        int c = _PyOS_GetOpt(argv->length, argv->items, &longindex);\n        if (c == EOF) {\n            break;\n        }\n\n        if (c == 'c') {\n            if (config->run_command == NULL) {\n                /* -c is the last option; following arguments\n                   that look like options are left for the\n                   command to interpret. */\n                size_t len = wcslen(_PyOS_optarg) + 1 + 1;\n                wchar_t *command = PyMem_RawMalloc(sizeof(wchar_t) * len);\n                if (command == NULL) {\n                    return _PyStatus_NO_MEMORY();\n                }\n                memcpy(command, _PyOS_optarg, (len - 2) * sizeof(wchar_t));\n                command[len - 2] = '\\n';\n                command[len - 1] = 0;\n                config->run_command = command;\n            }\n            break;\n        }\n\n        if (c == 'm') {\n            /* -m is the last option; following arguments\n               that look like options are left for the\n               module to interpret. */\n            if (config->run_module == NULL) {\n                config->run_module = _PyMem_RawWcsdup(_PyOS_optarg);\n                if (config->run_module == NULL) {\n                    return _PyStatus_NO_MEMORY();\n                }\n            }\n            break;\n        }\n\n        switch (c) {\n        // Integers represent long options, see Python/getopt.c\n        case 0:\n            // check-hash-based-pycs\n            if (wcscmp(_PyOS_optarg, L\"always\") == 0\n                || wcscmp(_PyOS_optarg, L\"never\") == 0\n                || wcscmp(_PyOS_optarg, L\"default\") == 0)\n            {\n                status = PyConfig_SetString(config, &config->check_hash_pycs_mode,\n                                            _PyOS_optarg);\n                if (_PyStatus_EXCEPTION(status)) {\n                    return status;\n                }\n            } else {\n                fprintf(stderr, \"--check-hash-based-pycs must be one of \"\n                        \"'default', 'always', or 'never'\\n\");\n                config_usage(1, program);\n                return _PyStatus_EXIT(2);\n            }\n            break;\n\n        case 1:\n            // help-all\n            config_complete_usage(program);\n            return _PyStatus_EXIT(0);\n\n        case 2:\n            // help-env\n            config_envvars_usage();\n            return _PyStatus_EXIT(0);\n\n        case 3:\n            // help-xoptions\n            config_xoptions_usage();\n            return _PyStatus_EXIT(0);\n\n        case 'b':\n            config->bytes_warning++;\n            break;\n\n        case 'd':\n            config->parser_debug++;\n            break;\n\n        case 'i':\n            config->inspect++;\n            config->interactive++;\n            break;\n\n        case 'E':\n        case 'I':\n        case 'X':\n            /* option handled by _PyPreCmdline_Read() */\n            break;\n\n        /* case 'J': reserved for Jython */\n\n        case 'O':\n            config->optimization_level++;\n            break;\n\n        case 'P':\n            config->safe_path = 1;\n            break;\n\n        case 'B':\n            config->write_bytecode = 0;\n            break;\n\n        case 's':\n            config->user_site_directory = 0;\n            break;\n\n        case 'S':\n            config->site_import = 0;\n            break;\n\n        case 't':\n            /* ignored for backwards compatibility */\n            break;\n\n        case 'u':\n            config->buffered_stdio = 0;\n            break;\n\n        case 'v':\n            config->verbose++;\n            break;\n\n        case 'x':\n            config->skip_source_first_line = 1;\n            break;\n\n        case 'h':\n        case '?':\n            config_usage(0, program);\n            return _PyStatus_EXIT(0);\n\n        case 'V':\n            print_version++;\n            break;\n\n        case 'W':\n            status = PyWideStringList_Append(warnoptions, _PyOS_optarg);\n            if (_PyStatus_EXCEPTION(status)) {\n                return status;\n            }\n            break;\n\n        case 'q':\n            config->quiet++;\n            break;\n\n        case 'R':\n            config->use_hash_seed = 0;\n            break;\n\n        /* This space reserved for other options */\n\n        default:\n            /* unknown argument: parsing failed */\n            config_usage(1, program);\n            return _PyStatus_EXIT(2);\n        }\n    } while (1);\n\n    if (print_version) {\n        printf(\"Python %s\\n\",\n                (print_version >= 2) ? Py_GetVersion() : PY_VERSION);\n        return _PyStatus_EXIT(0);\n    }\n\n    if (config->run_command == NULL && config->run_module == NULL\n        && _PyOS_optind < argv->length\n        && wcscmp(argv->items[_PyOS_optind], L\"-\") != 0\n        && config->run_filename == NULL)\n    {\n        config->run_filename = _PyMem_RawWcsdup(argv->items[_PyOS_optind]);\n        if (config->run_filename == NULL) {\n            return _PyStatus_NO_MEMORY();\n        }\n    }\n\n    if (config->run_command != NULL || config->run_module != NULL) {\n        /* Backup _PyOS_optind */\n        _PyOS_optind--;\n    }\n\n    *opt_index = _PyOS_optind;\n\n    return _PyStatus_OK();\n}\n\n\n#ifdef MS_WINDOWS\n#  define WCSTOK wcstok_s\n#else\n#  define WCSTOK wcstok\n#endif\n\n/* Get warning options from PYTHONWARNINGS environment variable. */\nstatic PyStatus\nconfig_init_env_warnoptions(PyConfig *config, PyWideStringList *warnoptions)\n{\n    PyStatus status;\n    /* CONFIG_GET_ENV_DUP requires dest to be initialized to NULL */\n    wchar_t *env = NULL;\n    status = CONFIG_GET_ENV_DUP(config, &env,\n                             L\"PYTHONWARNINGS\", \"PYTHONWARNINGS\");\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n\n    /* env var is not set or is empty */\n    if (env == NULL) {\n        return _PyStatus_OK();\n    }\n\n\n    wchar_t *warning, *context = NULL;\n    for (warning = WCSTOK(env, L\",\", &context);\n         warning != NULL;\n         warning = WCSTOK(NULL, L\",\", &context))\n    {\n        status = PyWideStringList_Append(warnoptions, warning);\n        if (_PyStatus_EXCEPTION(status)) {\n            PyMem_RawFree(env);\n            return status;\n        }\n    }\n    PyMem_RawFree(env);\n    return _PyStatus_OK();\n}\n\n\nstatic PyStatus\nwarnoptions_append(PyConfig *config, PyWideStringList *options,\n                   const wchar_t *option)\n{\n    /* config_init_warnoptions() add existing config warnoptions at the end:\n       ensure that the new option is not already present in this list to\n       prevent change the options order when config_init_warnoptions() is\n       called twice. */\n    if (_PyWideStringList_Find(&config->warnoptions, option)) {\n        /* Already present: do nothing */\n        return _PyStatus_OK();\n    }\n    if (_PyWideStringList_Find(options, option)) {\n        /* Already present: do nothing */\n        return _PyStatus_OK();\n    }\n    return PyWideStringList_Append(options, option);\n}\n\n\nstatic PyStatus\nwarnoptions_extend(PyConfig *config, PyWideStringList *options,\n                   const PyWideStringList *options2)\n{\n    const Py_ssize_t len = options2->length;\n    wchar_t *const *items = options2->items;\n\n    for (Py_ssize_t i = 0; i < len; i++) {\n        PyStatus status = warnoptions_append(config, options, items[i]);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n    return _PyStatus_OK();\n}\n\n\nstatic PyStatus\nconfig_init_warnoptions(PyConfig *config,\n                        const PyWideStringList *cmdline_warnoptions,\n                        const PyWideStringList *env_warnoptions,\n                        const PyWideStringList *sys_warnoptions)\n{\n    PyStatus status;\n    PyWideStringList options = _PyWideStringList_INIT;\n\n    /* Priority of warnings options, lowest to highest:\n     *\n     * - any implicit filters added by _warnings.c/warnings.py\n     * - PyConfig.dev_mode: \"default\" filter\n     * - PYTHONWARNINGS environment variable\n     * - '-W' command line options\n     * - PyConfig.bytes_warning ('-b' and '-bb' command line options):\n     *   \"default::BytesWarning\" or \"error::BytesWarning\" filter\n     * - early PySys_AddWarnOption() calls\n     * - PyConfig.warnoptions\n     *\n     * PyConfig.warnoptions is copied to sys.warnoptions. Since the warnings\n     * module works on the basis of \"the most recently added filter will be\n     * checked first\", we add the lowest precedence entries first so that later\n     * entries override them.\n     */\n\n    if (config->dev_mode) {\n        status = warnoptions_append(config, &options, L\"default\");\n        if (_PyStatus_EXCEPTION(status)) {\n            goto error;\n        }\n    }\n\n    status = warnoptions_extend(config, &options, env_warnoptions);\n    if (_PyStatus_EXCEPTION(status)) {\n        goto error;\n    }\n\n    status = warnoptions_extend(config, &options, cmdline_warnoptions);\n    if (_PyStatus_EXCEPTION(status)) {\n        goto error;\n    }\n\n    /* If the bytes_warning_flag isn't set, bytesobject.c and bytearrayobject.c\n     * don't even try to emit a warning, so we skip setting the filter in that\n     * case.\n     */\n    if (config->bytes_warning) {\n        const wchar_t *filter;\n        if (config->bytes_warning> 1) {\n            filter = L\"error::BytesWarning\";\n        }\n        else {\n            filter = L\"default::BytesWarning\";\n        }\n        status = warnoptions_append(config, &options, filter);\n        if (_PyStatus_EXCEPTION(status)) {\n            goto error;\n        }\n    }\n\n    status = warnoptions_extend(config, &options, sys_warnoptions);\n    if (_PyStatus_EXCEPTION(status)) {\n        goto error;\n    }\n\n    /* Always add all PyConfig.warnoptions options */\n    status = _PyWideStringList_Extend(&options, &config->warnoptions);\n    if (_PyStatus_EXCEPTION(status)) {\n        goto error;\n    }\n\n    _PyWideStringList_Clear(&config->warnoptions);\n    config->warnoptions = options;\n    return _PyStatus_OK();\n\nerror:\n    _PyWideStringList_Clear(&options);\n    return status;\n}\n\n\nstatic PyStatus\nconfig_update_argv(PyConfig *config, Py_ssize_t opt_index)\n{\n    const PyWideStringList *cmdline_argv = &config->argv;\n    PyWideStringList config_argv = _PyWideStringList_INIT;\n\n    /* Copy argv to be able to modify it (to force -c/-m) */\n    if (cmdline_argv->length <= opt_index) {\n        /* Ensure at least one (empty) argument is seen */\n        PyStatus status = PyWideStringList_Append(&config_argv, L\"\");\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n    else {\n        PyWideStringList slice;\n        slice.length = cmdline_argv->length - opt_index;\n        slice.items = &cmdline_argv->items[opt_index];\n        if (_PyWideStringList_Copy(&config_argv, &slice) < 0) {\n            return _PyStatus_NO_MEMORY();\n        }\n    }\n    assert(config_argv.length >= 1);\n\n    wchar_t *arg0 = NULL;\n    if (config->run_command != NULL) {\n        /* Force sys.argv[0] = '-c' */\n        arg0 = L\"-c\";\n    }\n    else if (config->run_module != NULL) {\n        /* Force sys.argv[0] = '-m'*/\n        arg0 = L\"-m\";\n    }\n\n    if (arg0 != NULL) {\n        arg0 = _PyMem_RawWcsdup(arg0);\n        if (arg0 == NULL) {\n            _PyWideStringList_Clear(&config_argv);\n            return _PyStatus_NO_MEMORY();\n        }\n\n        PyMem_RawFree(config_argv.items[0]);\n        config_argv.items[0] = arg0;\n    }\n\n    _PyWideStringList_Clear(&config->argv);\n    config->argv = config_argv;\n    return _PyStatus_OK();\n}\n\n\nstatic PyStatus\ncore_read_precmdline(PyConfig *config, _PyPreCmdline *precmdline)\n{\n    PyStatus status;\n\n    if (config->parse_argv == 1) {\n        if (_PyWideStringList_Copy(&precmdline->argv, &config->argv) < 0) {\n            return _PyStatus_NO_MEMORY();\n        }\n    }\n\n    PyPreConfig preconfig;\n\n    status = _PyPreConfig_InitFromPreConfig(&preconfig, &_PyRuntime.preconfig);\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n\n    _PyPreConfig_GetConfig(&preconfig, config);\n\n    status = _PyPreCmdline_Read(precmdline, &preconfig);\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n\n    status = _PyPreCmdline_SetConfig(precmdline, config);\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n    return _PyStatus_OK();\n}\n\n\n/* Get run_filename absolute path */\nstatic PyStatus\nconfig_run_filename_abspath(PyConfig *config)\n{\n    if (!config->run_filename) {\n        return _PyStatus_OK();\n    }\n\n#ifndef MS_WINDOWS\n    if (_Py_isabs(config->run_filename)) {\n        /* path is already absolute */\n        return _PyStatus_OK();\n    }\n#endif\n\n    wchar_t *abs_filename;\n    if (_Py_abspath(config->run_filename, &abs_filename) < 0) {\n        /* failed to get the absolute path of the command line filename:\n           ignore the error, keep the relative path */\n        return _PyStatus_OK();\n    }\n    if (abs_filename == NULL) {\n        return _PyStatus_NO_MEMORY();\n    }\n\n    PyMem_RawFree(config->run_filename);\n    config->run_filename = abs_filename;\n    return _PyStatus_OK();\n}\n\n\nstatic PyStatus\nconfig_read_cmdline(PyConfig *config)\n{\n    PyStatus status;\n    PyWideStringList cmdline_warnoptions = _PyWideStringList_INIT;\n    PyWideStringList env_warnoptions = _PyWideStringList_INIT;\n    PyWideStringList sys_warnoptions = _PyWideStringList_INIT;\n\n    if (config->parse_argv < 0) {\n        config->parse_argv = 1;\n    }\n\n    if (config->parse_argv == 1) {\n        Py_ssize_t opt_index;\n        status = config_parse_cmdline(config, &cmdline_warnoptions, &opt_index);\n        if (_PyStatus_EXCEPTION(status)) {\n            goto done;\n        }\n\n        status = config_run_filename_abspath(config);\n        if (_PyStatus_EXCEPTION(status)) {\n            goto done;\n        }\n\n        status = config_update_argv(config, opt_index);\n        if (_PyStatus_EXCEPTION(status)) {\n            goto done;\n        }\n    }\n    else {\n        status = config_run_filename_abspath(config);\n        if (_PyStatus_EXCEPTION(status)) {\n            goto done;\n        }\n    }\n\n    if (config->use_environment) {\n        status = config_init_env_warnoptions(config, &env_warnoptions);\n        if (_PyStatus_EXCEPTION(status)) {\n            goto done;\n        }\n    }\n\n    /* Handle early PySys_AddWarnOption() calls */\n    status = _PySys_ReadPreinitWarnOptions(&sys_warnoptions);\n    if (_PyStatus_EXCEPTION(status)) {\n        goto done;\n    }\n\n    status = config_init_warnoptions(config,\n                                     &cmdline_warnoptions,\n                                     &env_warnoptions,\n                                     &sys_warnoptions);\n    if (_PyStatus_EXCEPTION(status)) {\n        goto done;\n    }\n\n    status = _PyStatus_OK();\n\ndone:\n    _PyWideStringList_Clear(&cmdline_warnoptions);\n    _PyWideStringList_Clear(&env_warnoptions);\n    _PyWideStringList_Clear(&sys_warnoptions);\n    return status;\n}\n\n\nPyStatus\n_PyConfig_SetPyArgv(PyConfig *config, const _PyArgv *args)\n{\n    PyStatus status = _Py_PreInitializeFromConfig(config, args);\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n\n    return _PyArgv_AsWstrList(args, &config->argv);\n}\n\n\n/* Set config.argv: decode argv using Py_DecodeLocale(). Pre-initialize Python\n   if needed to ensure that encodings are properly configured. */\nPyStatus\nPyConfig_SetBytesArgv(PyConfig *config, Py_ssize_t argc, char * const *argv)\n{\n    _PyArgv args = {\n        .argc = argc,\n        .use_bytes_argv = 1,\n        .bytes_argv = argv,\n        .wchar_argv = NULL};\n    return _PyConfig_SetPyArgv(config, &args);\n}\n\n\nPyStatus\nPyConfig_SetArgv(PyConfig *config, Py_ssize_t argc, wchar_t * const *argv)\n{\n    _PyArgv args = {\n        .argc = argc,\n        .use_bytes_argv = 0,\n        .bytes_argv = NULL,\n        .wchar_argv = argv};\n    return _PyConfig_SetPyArgv(config, &args);\n}\n\n\nPyStatus\nPyConfig_SetWideStringList(PyConfig *config, PyWideStringList *list,\n                           Py_ssize_t length, wchar_t **items)\n{\n    PyStatus status = _Py_PreInitializeFromConfig(config, NULL);\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n\n    PyWideStringList list2 = {.length = length, .items = items};\n    if (_PyWideStringList_Copy(list, &list2) < 0) {\n        return _PyStatus_NO_MEMORY();\n    }\n    return _PyStatus_OK();\n}\n\n\n/* Read the configuration into PyConfig from:\n\n   * Command line arguments\n   * Environment variables\n   * Py_xxx global configuration variables\n\n   The only side effects are to modify config and to call _Py_SetArgcArgv(). */\nPyStatus\n_PyConfig_Read(PyConfig *config, int compute_path_config)\n{\n    PyStatus status;\n\n    status = _Py_PreInitializeFromConfig(config, NULL);\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n\n    config_get_global_vars(config);\n\n    if (config->orig_argv.length == 0\n        && !(config->argv.length == 1\n             && wcscmp(config->argv.items[0], L\"\") == 0))\n    {\n        if (_PyWideStringList_Copy(&config->orig_argv, &config->argv) < 0) {\n            return _PyStatus_NO_MEMORY();\n        }\n    }\n\n    _PyPreCmdline precmdline = _PyPreCmdline_INIT;\n    status = core_read_precmdline(config, &precmdline);\n    if (_PyStatus_EXCEPTION(status)) {\n        goto done;\n    }\n\n    assert(config->isolated >= 0);\n    if (config->isolated) {\n        config->safe_path = 1;\n        config->use_environment = 0;\n        config->user_site_directory = 0;\n    }\n\n    status = config_read_cmdline(config);\n    if (_PyStatus_EXCEPTION(status)) {\n        goto done;\n    }\n\n    /* Handle early PySys_AddXOption() calls */\n    status = _PySys_ReadPreinitXOptions(config);\n    if (_PyStatus_EXCEPTION(status)) {\n        goto done;\n    }\n\n    status = config_read(config, compute_path_config);\n    if (_PyStatus_EXCEPTION(status)) {\n        goto done;\n    }\n\n    assert(config_check_consistency(config));\n\n    status = _PyStatus_OK();\n\ndone:\n    _PyPreCmdline_Clear(&precmdline);\n    return status;\n}\n\n\nPyStatus\nPyConfig_Read(PyConfig *config)\n{\n    return _PyConfig_Read(config, 0);\n}\n\n\nPyObject*\n_Py_GetConfigsAsDict(void)\n{\n    PyObject *result = NULL;\n    PyObject *dict = NULL;\n\n    result = PyDict_New();\n    if (result == NULL) {\n        goto error;\n    }\n\n    /* global result */\n    dict = _Py_GetGlobalVariablesAsDict();\n    if (dict == NULL) {\n        goto error;\n    }\n    if (PyDict_SetItemString(result, \"global_config\", dict) < 0) {\n        goto error;\n    }\n    Py_CLEAR(dict);\n\n    /* pre config */\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    const PyPreConfig *pre_config = &interp->runtime->preconfig;\n    dict = _PyPreConfig_AsDict(pre_config);\n    if (dict == NULL) {\n        goto error;\n    }\n    if (PyDict_SetItemString(result, \"pre_config\", dict) < 0) {\n        goto error;\n    }\n    Py_CLEAR(dict);\n\n    /* core config */\n    const PyConfig *config = _PyInterpreterState_GetConfig(interp);\n    dict = _PyConfig_AsDict(config);\n    if (dict == NULL) {\n        goto error;\n    }\n    if (PyDict_SetItemString(result, \"config\", dict) < 0) {\n        goto error;\n    }\n    Py_CLEAR(dict);\n\n    return result;\n\nerror:\n    Py_XDECREF(result);\n    Py_XDECREF(dict);\n    return NULL;\n}\n\n\nstatic void\ninit_dump_ascii_wstr(const wchar_t *str)\n{\n    if (str == NULL) {\n        PySys_WriteStderr(\"(not set)\");\n        return;\n    }\n\n    PySys_WriteStderr(\"'\");\n    for (; *str != L'\\0'; str++) {\n        unsigned int ch = (unsigned int)*str;\n        if (ch == L'\\'') {\n            PySys_WriteStderr(\"\\\\'\");\n        } else if (0x20 <= ch && ch < 0x7f) {\n            PySys_WriteStderr(\"%c\", ch);\n        }\n        else if (ch <= 0xff) {\n            PySys_WriteStderr(\"\\\\x%02x\", ch);\n        }\n#if SIZEOF_WCHAR_T > 2\n        else if (ch > 0xffff) {\n            PySys_WriteStderr(\"\\\\U%08x\", ch);\n        }\n#endif\n        else {\n            PySys_WriteStderr(\"\\\\u%04x\", ch);\n        }\n    }\n    PySys_WriteStderr(\"'\");\n}\n\n\n/* Dump the Python path configuration into sys.stderr */\nvoid\n_Py_DumpPathConfig(PyThreadState *tstate)\n{\n    PyObject *exc = _PyErr_GetRaisedException(tstate);\n\n    PySys_WriteStderr(\"Python path configuration:\\n\");\n\n#define DUMP_CONFIG(NAME, FIELD) \\\n        do { \\\n            PySys_WriteStderr(\"  \" NAME \" = \"); \\\n            init_dump_ascii_wstr(config->FIELD); \\\n            PySys_WriteStderr(\"\\n\"); \\\n        } while (0)\n\n    const PyConfig *config = _PyInterpreterState_GetConfig(tstate->interp);\n    DUMP_CONFIG(\"PYTHONHOME\", home);\n    DUMP_CONFIG(\"PYTHONPATH\", pythonpath_env);\n    DUMP_CONFIG(\"program name\", program_name);\n    PySys_WriteStderr(\"  isolated = %i\\n\", config->isolated);\n    PySys_WriteStderr(\"  environment = %i\\n\", config->use_environment);\n    PySys_WriteStderr(\"  user site = %i\\n\", config->user_site_directory);\n    PySys_WriteStderr(\"  safe_path = %i\\n\", config->safe_path);\n    PySys_WriteStderr(\"  import site = %i\\n\", config->site_import);\n    PySys_WriteStderr(\"  is in build tree = %i\\n\", config->_is_python_build);\n    DUMP_CONFIG(\"stdlib dir\", stdlib_dir);\n#undef DUMP_CONFIG\n\n#define DUMP_SYS(NAME) \\\n        do { \\\n            obj = PySys_GetObject(#NAME); \\\n            PySys_FormatStderr(\"  sys.%s = \", #NAME); \\\n            if (obj != NULL) { \\\n                PySys_FormatStderr(\"%A\", obj); \\\n            } \\\n            else { \\\n                PySys_WriteStderr(\"(not set)\"); \\\n            } \\\n            PySys_FormatStderr(\"\\n\"); \\\n        } while (0)\n\n    PyObject *obj;\n    DUMP_SYS(_base_executable);\n    DUMP_SYS(base_prefix);\n    DUMP_SYS(base_exec_prefix);\n    DUMP_SYS(platlibdir);\n    DUMP_SYS(executable);\n    DUMP_SYS(prefix);\n    DUMP_SYS(exec_prefix);\n#undef DUMP_SYS\n\n    PyObject *sys_path = PySys_GetObject(\"path\");  /* borrowed reference */\n    if (sys_path != NULL && PyList_Check(sys_path)) {\n        PySys_WriteStderr(\"  sys.path = [\\n\");\n        Py_ssize_t len = PyList_GET_SIZE(sys_path);\n        for (Py_ssize_t i=0; i < len; i++) {\n            PyObject *path = PyList_GET_ITEM(sys_path, i);\n            PySys_FormatStderr(\"    %A,\\n\", path);\n        }\n        PySys_WriteStderr(\"  ]\\n\");\n    }\n\n    _PyErr_SetRaisedException(tstate, exc);\n}\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-use-of-uninitialized-value", "taxa": [{"id": "457", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "use of uninitialized value 'opt_index'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2860, "startColumn": 18, "endColumn": 55}, "contextRegion": {"startLine": 2860, "snippet": {"text": "        status = config_update_argv(config, opt_index);\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 3026, "startColumn": 1, "endColumn": 14}, "contextRegion": {"startLine": 3026, "snippet": {"text": "PyConfig_Read(PyConfig *config)\n"}}}, "logicalLocations": [{"name": "PyConfig_Read", "fullyQualifiedName": "PyConfig_Read", "decoratedName": "PyConfig_Read", "kind": "function"}], "message": {"text": "entry to 'PyConfig_Read'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 3028, "startColumn": 12, "endColumn": 37}, "contextRegion": {"startLine": 3028, "snippet": {"text": "    return _PyConfig_Read(config, 0);\n"}}}, "logicalLocations": [{"name": "PyConfig_Read", "fullyQualifiedName": "PyConfig_Read", "decoratedName": "PyConfig_Read", "kind": "function"}], "message": {"text": "calling '_PyConfig_Read' from 'PyConfig_Read'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2966, "startColumn": 1, "endColumn": 15}, "contextRegion": {"startLine": 2966, "snippet": {"text": "_PyConfig_Read(PyConfig *config, int compute_path_config)\n"}}}, "logicalLocations": [{"name": "_PyConfig_Read", "fullyQualifiedName": "_PyConfig_Read", "decoratedName": "_PyConfig_Read", "kind": "function"}], "message": {"text": "entry to '_PyConfig_Read'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2971, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2971, "snippet": {"text": "    if (_PyStatus_EXCEPTION(status)) {\n"}}}, "logicalLocations": [{"name": "_PyConfig_Read", "fullyQualifiedName": "_PyConfig_Read", "decoratedName": "_PyConfig_Read", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2975, "startColumn": 5, "endColumn": 27}, "contextRegion": {"startLine": 2975, "snippet": {"text": "    config_get_global_vars(config);\n"}}}, "logicalLocations": [{"name": "_PyConfig_Read", "fullyQualifiedName": "_PyConfig_Read", "decoratedName": "_PyConfig_Read", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2988, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2988, "snippet": {"text": "    if (_PyStatus_EXCEPTION(status)) {\n"}}}, "logicalLocations": [{"name": "_PyConfig_Read", "fullyQualifiedName": "_PyConfig_Read", "decoratedName": "_PyConfig_Read", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2992, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2992, "snippet": {"text": "    assert(config->isolated >= 0);\n"}}}, "logicalLocations": [{"name": "_PyConfig_Read", "fullyQualifiedName": "_PyConfig_Read", "decoratedName": "_PyConfig_Read", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2992, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2992, "snippet": {"text": "    assert(config->isolated >= 0);\n"}}}, "logicalLocations": [{"name": "_PyConfig_Read", "fullyQualifiedName": "_PyConfig_Read", "decoratedName": "_PyConfig_Read", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2993, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 2993, "snippet": {"text": "    if (config->isolated) {\n"}}}, "logicalLocations": [{"name": "_PyConfig_Read", "fullyQualifiedName": "_PyConfig_Read", "decoratedName": "_PyConfig_Read", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2999, "startColumn": 14, "endColumn": 41}, "contextRegion": {"startLine": 2999, "snippet": {"text": "    status = config_read_cmdline(config);\n"}}}, "logicalLocations": [{"name": "_PyConfig_Read", "fullyQualifiedName": "_PyConfig_Read", "decoratedName": "_PyConfig_Read", "kind": "function"}], "message": {"text": "calling 'config_read_cmdline' from '_PyConfig_Read'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2837, "startColumn": 1, "endColumn": 20}, "contextRegion": {"startLine": 2837, "snippet": {"text": "config_read_cmdline(PyConfig *config)\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "entry to 'config_read_cmdline'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2849, "startColumn": 20, "endColumn": 29}, "contextRegion": {"startLine": 2849, "snippet": {"text": "        Py_ssize_t opt_index;\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "region created on stack here"}}, "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2849, "startColumn": 20, "endColumn": 29}, "contextRegion": {"startLine": 2849, "snippet": {"text": "        Py_ssize_t opt_index;\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "capacity: 8 bytes"}}, "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2848, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2848, "snippet": {"text": "    if (config->parse_argv == 1) {\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2849, "startColumn": 9, "endColumn": 19}, "contextRegion": {"startLine": 2849, "snippet": {"text": "        Py_ssize_t opt_index;\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2850, "startColumn": 18, "endColumn": 80}, "contextRegion": {"startLine": 2850, "snippet": {"text": "        status = config_parse_cmdline(config, &cmdline_warnoptions, &opt_index);\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "calling 'config_parse_cmdline' from 'config_read_cmdline'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2357, "startColumn": 1, "endColumn": 21}, "contextRegion": {"startLine": 2357, "snippet": {"text": "config_parse_cmdline(PyConfig *config, PyWideStringList *warnoptions,\n"}}}, "logicalLocations": [{"name": "config_parse_cmdline", "fullyQualifiedName": "config_parse_cmdline", "decoratedName": "config_parse_cmdline", "kind": "function"}], "message": {"text": "entry to 'config_parse_cmdline'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2372, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 2372, "snippet": {"text": "        if (c == EOF) {\n"}}}, "logicalLocations": [{"name": "config_parse_cmdline", "fullyQualifiedName": "config_parse_cmdline", "decoratedName": "config_parse_cmdline", "kind": "function"}], "message": {"text": "following 'false' branch (when 'c != -1')..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2376, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 2376, "snippet": {"text": "        if (c == 'c') {\n"}}}, "logicalLocations": [{"name": "config_parse_cmdline", "fullyQualifiedName": "config_parse_cmdline", "decoratedName": "config_parse_cmdline", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2376, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 2376, "snippet": {"text": "        if (c == 'c') {\n"}}}, "logicalLocations": [{"name": "config_parse_cmdline", "fullyQualifiedName": "config_parse_cmdline", "decoratedName": "config_parse_cmdline", "kind": "function"}], "message": {"text": "following 'false' branch (when 'c != 99')..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2394, "startColumn": 9, "endColumn": 11}, "contextRegion": {"startLine": 2394, "snippet": {"text": "        if (c == 'm') {\n"}}}, "logicalLocations": [{"name": "config_parse_cmdline", "fullyQualifiedName": "config_parse_cmdline", "decoratedName": "config_parse_cmdline", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2394, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 2394, "snippet": {"text": "        if (c == 'm') {\n"}}}, "logicalLocations": [{"name": "config_parse_cmdline", "fullyQualifiedName": "config_parse_cmdline", "decoratedName": "config_parse_cmdline", "kind": "function"}], "message": {"text": "following 'false' branch (when 'c != 109')..."}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2407, "startColumn": 9, "endColumn": 15}, "contextRegion": {"startLine": 2407, "snippet": {"text": "        switch (c) {\n"}}}, "logicalLocations": [{"name": "config_parse_cmdline", "fullyQualifiedName": "config_parse_cmdline", "decoratedName": "config_parse_cmdline", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2850, "startColumn": 18, "endColumn": 80}, "contextRegion": {"startLine": 2850, "snippet": {"text": "        status = config_parse_cmdline(config, &cmdline_warnoptions, &opt_index);\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "returning to 'config_read_cmdline' from 'config_parse_cmdline'"}}, "kinds": ["return", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2851, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 2851, "snippet": {"text": "        if (_PyStatus_EXCEPTION(status)) {\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2855, "startColumn": 9, "endColumn": 15}, "contextRegion": {"startLine": 2855, "snippet": {"text": "        status = config_run_filename_abspath(config);\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2855, "startColumn": 18, "endColumn": 53}, "contextRegion": {"startLine": 2855, "snippet": {"text": "        status = config_run_filename_abspath(config);\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "calling 'config_run_filename_abspath' from 'config_read_cmdline'"}}, "kinds": ["call", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2807, "startColumn": 1, "endColumn": 28}, "contextRegion": {"startLine": 2807, "snippet": {"text": "config_run_filename_abspath(PyConfig *config)\n"}}}, "logicalLocations": [{"name": "config_run_filename_abspath", "fullyQualifiedName": "config_run_filename_abspath", "decoratedName": "config_run_filename_abspath", "kind": "function"}], "message": {"text": "entry to 'config_run_filename_abspath'"}}, "kinds": ["enter", "function"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2809, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2809, "snippet": {"text": "    if (!config->run_filename) {\n"}}}, "logicalLocations": [{"name": "config_run_filename_abspath", "fullyQualifiedName": "config_run_filename_abspath", "decoratedName": "config_run_filename_abspath", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2810, "startColumn": 9, "endColumn": 15}, "contextRegion": {"startLine": 2810, "snippet": {"text": "        return _PyStatus_OK();\n"}}}, "logicalLocations": [{"name": "config_run_filename_abspath", "fullyQualifiedName": "config_run_filename_abspath", "decoratedName": "config_run_filename_abspath", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 4}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2855, "startColumn": 18, "endColumn": 53}, "contextRegion": {"startLine": 2855, "snippet": {"text": "        status = config_run_filename_abspath(config);\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "returning to 'config_read_cmdline' from 'config_run_filename_abspath'"}}, "kinds": ["return", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2856, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 2856, "snippet": {"text": "        if (_PyStatus_EXCEPTION(status)) {\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2860, "startColumn": 9, "endColumn": 15}, "contextRegion": {"startLine": 2860, "snippet": {"text": "        status = config_update_argv(config, opt_index);\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Python/initconfig.c", "uriBaseId": "PWD"}, "region": {"startLine": 2860, "startColumn": 18, "endColumn": 55}, "contextRegion": {"startLine": 2860, "snippet": {"text": "        status = config_update_argv(config, opt_index);\n"}}}, "logicalLocations": [{"name": "config_read_cmdline", "fullyQualifiedName": "config_read_cmdline", "decoratedName": "config_read_cmdline", "kind": "function"}], "message": {"text": "use of uninitialized value 'opt_index' here"}}, "kinds": ["danger"], "nestingLevel": 3}]}]}]}]}]}
