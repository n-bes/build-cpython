{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-null-dereference", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-dereference"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "476", "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}}, "artifacts": [{"location": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "contents": {"text": "#ifndef Py_OBJECT_H\n#define Py_OBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Object and type object interface */\n\n/*\nObjects are structures allocated on the heap.  Special rules apply to\nthe use of objects to ensure they are properly garbage-collected.\nObjects are never allocated statically or on the stack; they must be\naccessed through special macros and functions only.  (Type objects are\nexceptions to the first rule; the standard types are represented by\nstatically initialized type objects, although work on type/class unification\nfor Python 2.2 made it possible to have heap-allocated type objects too).\n\nAn object has a 'reference count' that is increased or decreased when a\npointer to the object is copied or deleted; when the reference count\nreaches zero there are no references to the object left and it can be\nremoved from the heap.\n\nAn object has a 'type' that determines what it represents and what kind\nof data it contains.  An object's type is fixed when it is created.\nTypes themselves are represented as objects; an object contains a\npointer to the corresponding type object.  The type itself has a type\npointer pointing to the object representing the type 'type', which\ncontains a pointer to itself!.\n\nObjects do not float around in memory; once allocated an object keeps\nthe same size and address.  Objects that must hold variable-size data\ncan contain pointers to variable-size parts of the object.  Not all\nobjects of the same type have the same size; but the size cannot change\nafter allocation.  (These restrictions are made so a reference to an\nobject can be simply a pointer -- moving an object would require\nupdating all the pointers, and changing an object's size would require\nmoving it if there was another object right next to it.)\n\nObjects are always accessed through pointers of the type 'PyObject *'.\nThe type 'PyObject' is a structure that only contains the reference count\nand the type pointer.  The actual memory allocated for an object\ncontains other data that can only be accessed after casting the pointer\nto a pointer to a longer structure type.  This longer type must start\nwith the reference count and type fields; the macro PyObject_HEAD should be\nused for this (to accommodate for future changes).  The implementation\nof a particular object type can cast the object pointer to the proper\ntype and back.\n\nA standard interface exists for objects that contain an array of items\nwhose size is determined when the object is allocated.\n*/\n\n#include \"pystats.h\"\n\n/* Py_DEBUG implies Py_REF_DEBUG. */\n#if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)\n#  define Py_REF_DEBUG\n#endif\n\n#if defined(Py_LIMITED_API) && defined(Py_TRACE_REFS)\n#  error Py_LIMITED_API is incompatible with Py_TRACE_REFS\n#endif\n\n#ifdef Py_TRACE_REFS\n/* Define pointers to support a doubly-linked list of all live heap objects. */\n#define _PyObject_HEAD_EXTRA            \\\n    PyObject *_ob_next;           \\\n    PyObject *_ob_prev;\n\n#define _PyObject_EXTRA_INIT _Py_NULL, _Py_NULL,\n\n#else\n#  define _PyObject_HEAD_EXTRA\n#  define _PyObject_EXTRA_INIT\n#endif\n\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   PyObject ob_base;\n\n/*\nImmortalization:\n\nThe following indicates the immortalization strategy depending on the amount\nof available bits in the reference count field. All strategies are backwards\ncompatible but the specific reference count value or immortalization check\nmight change depending on the specializations for the underlying system.\n\nProper deallocation of immortal instances requires distinguishing between\nstatically allocated immortal instances vs those promoted by the runtime to be\nimmortal. The latter should be the only instances that require\ncleanup during runtime finalization.\n*/\n\n#if SIZEOF_VOID_P > 4\n/*\nIn 64+ bit systems, an object will be marked as immortal by setting all of the\nlower 32 bits of the reference count field, which is equal to: 0xFFFFFFFF\n\nUsing the lower 32 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases will use saturated arithmetic, taking advantage of\nhaving all the lower 32 bits set, which will avoid the reference count to go\nbeyond the refcount limit. Immortality checks for reference count decreases will\nbe done by checking the bit sign flag in the lower 32 bits.\n*/\n#define _Py_IMMORTAL_REFCNT UINT_MAX\n\n#else\n/*\nIn 32 bit systems, an object will be marked as immortal by setting all of the\nlower 30 bits of the reference count field, which is equal to: 0x3FFFFFFF\n\nUsing the lower 30 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases and decreases will first go through an immortality\ncheck by comparing the reference count field to the immortality reference count.\n*/\n#define _Py_IMMORTAL_REFCNT (UINT_MAX >> 2)\n#endif\n\n// Make all internal uses of PyObject_HEAD_INIT immortal while preserving the\n// C-API expectation that the refcnt will be set to 1.\n#ifdef Py_BUILD_CORE\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        _PyObject_EXTRA_INIT        \\\n        { _Py_IMMORTAL_REFCNT },    \\\n        (type)                      \\\n    },\n#else\n#define PyObject_HEAD_INIT(type) \\\n    {                            \\\n        _PyObject_EXTRA_INIT     \\\n        { 1 },                   \\\n        (type)                   \\\n    },\n#endif /* Py_BUILD_CORE */\n\n#define PyVarObject_HEAD_INIT(type, size) \\\n    {                                     \\\n        PyObject_HEAD_INIT(type)          \\\n        (size)                            \\\n    },\n\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD      PyVarObject ob_base;\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\nstruct _object {\n    _PyObject_HEAD_EXTRA\n\n#if (defined(__GNUC__) || defined(__clang__)) \\\n        && !(defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L)\n    // On C99 and older, anonymous union is a GCC and clang extension\n    __extension__\n#endif\n#ifdef _MSC_VER\n    // Ignore MSC warning C4201: \"nonstandard extension used:\n    // nameless struct/union\"\n    __pragma(warning(push))\n    __pragma(warning(disable: 4201))\n#endif\n    union {\n       Py_ssize_t ob_refcnt;\n#if SIZEOF_VOID_P > 4\n       PY_UINT32_T ob_refcnt_split[2];\n#endif\n    };\n#ifdef _MSC_VER\n    __pragma(warning(pop))\n#endif\n\n    PyTypeObject *ob_type;\n};\n\n/* Cast argument to PyObject* type. */\n#define _PyObject_CAST(op) _Py_CAST(PyObject*, (op))\n\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n/* Cast argument to PyVarObject* type. */\n#define _PyVarObject_CAST(op) _Py_CAST(PyVarObject*, (op))\n\n\n// Test if the 'x' object is the 'y' object, the same as \"x is y\" in Python.\nPyAPI_FUNC(int) Py_Is(PyObject *x, PyObject *y);\n#define Py_Is(x, y) ((x) == (y))\n\n\nstatic inline Py_ssize_t Py_REFCNT(PyObject *ob) {\n    return ob->ob_refcnt;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_REFCNT(ob) Py_REFCNT(_PyObject_CAST(ob))\n#endif\n\n\n// bpo-39573: The Py_SET_TYPE() function must be used to set an object type.\nstatic inline PyTypeObject* Py_TYPE(PyObject *ob) {\n    return ob->ob_type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_TYPE(ob) Py_TYPE(_PyObject_CAST(ob))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyLong_Type;\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n\n// bpo-39573: The Py_SET_SIZE() function must be used to set an object size.\nstatic inline Py_ssize_t Py_SIZE(PyObject *ob) {\n    assert(ob->ob_type != &PyLong_Type);\n    assert(ob->ob_type != &PyBool_Type);\n    return  _PyVarObject_CAST(ob)->ob_size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SIZE(ob) Py_SIZE(_PyObject_CAST(ob))\n#endif\n\nstatic inline Py_ALWAYS_INLINE int _Py_IsImmortal(PyObject *op)\n{\n#if SIZEOF_VOID_P > 4\n    return _Py_CAST(PY_INT32_T, op->ob_refcnt) < 0;\n#else\n    return op->ob_refcnt == _Py_IMMORTAL_REFCNT;\n#endif\n}\n#define _Py_IsImmortal(op) _Py_IsImmortal(_PyObject_CAST(op))\n\nstatic inline int Py_IS_TYPE(PyObject *ob, PyTypeObject *type) {\n    return Py_TYPE(ob) == type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_IS_TYPE(ob, type) Py_IS_TYPE(_PyObject_CAST(ob), (type))\n#endif\n\n\nstatic inline void Py_SET_REFCNT(PyObject *ob, Py_ssize_t refcnt) {\n    // This immortal check is for code that is unaware of immortal objects.\n    // The runtime tracks these objects and we should avoid as much\n    // as possible having extensions inadvertently change the refcnt\n    // of an immortalized object.\n    if (_Py_IsImmortal(ob)) {\n        return;\n    }\n    ob->ob_refcnt = refcnt;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_REFCNT(ob, refcnt) Py_SET_REFCNT(_PyObject_CAST(ob), (refcnt))\n#endif\n\n\nstatic inline void Py_SET_TYPE(PyObject *ob, PyTypeObject *type) {\n    ob->ob_type = type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_TYPE(ob, type) Py_SET_TYPE(_PyObject_CAST(ob), type)\n#endif\n\nstatic inline void Py_SET_SIZE(PyVarObject *ob, Py_ssize_t size) {\n    assert(ob->ob_base.ob_type != &PyLong_Type);\n    assert(ob->ob_base.ob_type != &PyBool_Type);\n    ob->ob_size = size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_SIZE(ob, size) Py_SET_SIZE(_PyVarObject_CAST(ob), (size))\n#endif\n\n\n/*\nType objects contain a string containing the type name (to help somewhat\nin debugging), the allocation parameters (see PyObject_New() and\nPyObject_NewVar()),\nand methods for accessing objects of the type.  Methods are optional, a\nnil pointer meaning that particular kind of access is not available for\nthis type.  The Py_DECREF() macro uses the tp_dealloc method without\nchecking for a nil pointer; it should always be implemented except if\nthe implementation can guarantee that the reference count will never\nreach zero (e.g., for statically allocated type objects).\n\nNB: the methods for certain type groups are now contained in separate\nmethod blocks.\n*/\n\ntypedef PyObject * (*unaryfunc)(PyObject *);\ntypedef PyObject * (*binaryfunc)(PyObject *, PyObject *);\ntypedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);\ntypedef int (*inquiry)(PyObject *);\ntypedef Py_ssize_t (*lenfunc)(PyObject *);\ntypedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);\ntypedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);\ntypedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);\ntypedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);\ntypedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);\n\ntypedef int (*objobjproc)(PyObject *, PyObject *);\ntypedef int (*visitproc)(PyObject *, void *);\ntypedef int (*traverseproc)(PyObject *, visitproc, void *);\n\n\ntypedef void (*freefunc)(void *);\ntypedef void (*destructor)(PyObject *);\ntypedef PyObject *(*getattrfunc)(PyObject *, char *);\ntypedef PyObject *(*getattrofunc)(PyObject *, PyObject *);\ntypedef int (*setattrfunc)(PyObject *, char *, PyObject *);\ntypedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*reprfunc)(PyObject *);\ntypedef Py_hash_t (*hashfunc)(PyObject *);\ntypedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);\ntypedef PyObject *(*getiterfunc) (PyObject *);\ntypedef PyObject *(*iternextfunc) (PyObject *);\ntypedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*initproc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*newfunc)(PyTypeObject *, PyObject *, PyObject *);\ntypedef PyObject *(*allocfunc)(PyTypeObject *, Py_ssize_t);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030c0000 // 3.12\ntypedef PyObject *(*vectorcallfunc)(PyObject *callable, PyObject *const *args,\n                                    size_t nargsf, PyObject *kwnames);\n#endif\n\ntypedef struct{\n    int slot;    /* slot id, see below */\n    void *pfunc; /* function pointer */\n} PyType_Slot;\n\ntypedef struct{\n    const char* name;\n    int basicsize;\n    int itemsize;\n    unsigned int flags;\n    PyType_Slot *slots; /* terminated by slot==0. */\n} PyType_Spec;\n\nPyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000\nPyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);\nPyAPI_FUNC(PyObject *) PyType_GetModule(PyTypeObject *);\nPyAPI_FUNC(void *) PyType_GetModuleState(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000\nPyAPI_FUNC(PyObject *) PyType_GetName(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GetQualName(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\nPyAPI_FUNC(PyObject *) PyType_FromMetaclass(PyTypeObject*, PyObject*, PyType_Spec*, PyObject*);\nPyAPI_FUNC(void *) PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls);\nPyAPI_FUNC(Py_ssize_t) PyType_GetTypeDataSize(PyTypeObject *cls);\n#endif\n\n/* Generic type check */\nPyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);\n\nstatic inline int PyObject_TypeCheck(PyObject *ob, PyTypeObject *type) {\n    return Py_IS_TYPE(ob, type) || PyType_IsSubtype(Py_TYPE(ob), type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyObject_TypeCheck(ob, type) PyObject_TypeCheck(_PyObject_CAST(ob), (type))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */\nPyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */\nPyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */\n\nPyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);\n\nPyAPI_FUNC(int) PyType_Ready(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,\n                                               PyObject *, PyObject *);\nPyAPI_FUNC(unsigned int) PyType_ClearCache(void);\nPyAPI_FUNC(void) PyType_Modified(PyTypeObject *);\n\n/* Generic operations on objects */\nPyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);\nPyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);\nPyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);\nPyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);\n#endif\nPyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);\nPyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);\nPyAPI_FUNC(int) PyObject_IsTrue(PyObject *);\nPyAPI_FUNC(int) PyObject_Not(PyObject *);\nPyAPI_FUNC(int) PyCallable_Check(PyObject *);\nPyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);\n\n/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a\n   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),\n   returning the names of the current locals.  In this case, if there are\n   no current locals, NULL is returned, and PyErr_Occurred() is false.\n*/\nPyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);\n\n/* Pickle support. */\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyObject_GetState(PyObject *);\n#endif\n\n\n/* Helpers for printing recursive container types */\nPyAPI_FUNC(int) Py_ReprEnter(PyObject *);\nPyAPI_FUNC(void) Py_ReprLeave(PyObject *);\n\n/* Flag bits for printing: */\n#define Py_PRINT_RAW    1       /* No string quotes etc. */\n\n/*\nType flags (tp_flags)\n\nThese flags are used to change expected features and behavior for a\nparticular type.\n\nArbitration of the flag bit positions will need to be coordinated among\nall extension writers who publicly release their extensions (this will\nbe fewer than you might expect!).\n\nMost flags were removed as of Python 3.0 to make room for new flags.  (Some\nflags are not for backwards compatibility but to indicate the presence of an\noptional feature; these flags remain of course.)\n\nType definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.\n\nCode can use PyType_HasFeature(type_ob, flag_value) to test whether the\ngiven type object has a specified feature.\n*/\n\n#ifndef Py_LIMITED_API\n\n/* Track types initialized using _PyStaticType_InitBuiltin(). */\n#define _Py_TPFLAGS_STATIC_BUILTIN (1 << 1)\n\n/* Placement of weakref pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_weaklistoffset.\n */\n#define Py_TPFLAGS_MANAGED_WEAKREF (1 << 3)\n\n/* Placement of dict (and values) pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_dictoffset.\n */\n#define Py_TPFLAGS_MANAGED_DICT (1 << 4)\n\n#define Py_TPFLAGS_PREHEADER (Py_TPFLAGS_MANAGED_WEAKREF | Py_TPFLAGS_MANAGED_DICT)\n\n/* Set if instances of the type object are treated as sequences for pattern matching */\n#define Py_TPFLAGS_SEQUENCE (1 << 5)\n/* Set if instances of the type object are treated as mappings for pattern matching */\n#define Py_TPFLAGS_MAPPING (1 << 6)\n#endif\n\n/* Disallow creating instances of the type: set tp_new to NULL and don't create\n * the \"__new__\" key in the type dictionary. */\n#define Py_TPFLAGS_DISALLOW_INSTANTIATION (1UL << 7)\n\n/* Set if the type object is immutable: type attributes cannot be set nor deleted */\n#define Py_TPFLAGS_IMMUTABLETYPE (1UL << 8)\n\n/* Set if the type object is dynamically allocated */\n#define Py_TPFLAGS_HEAPTYPE (1UL << 9)\n\n/* Set if the type allows subclassing */\n#define Py_TPFLAGS_BASETYPE (1UL << 10)\n\n/* Set if the type implements the vectorcall protocol (PEP 590) */\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\n#define Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)\n#ifndef Py_LIMITED_API\n// Backwards compatibility alias for API that was provisional in Python 3.8\n#define _Py_TPFLAGS_HAVE_VECTORCALL Py_TPFLAGS_HAVE_VECTORCALL\n#endif\n#endif\n\n/* Set if the type is 'ready' -- fully initialized */\n#define Py_TPFLAGS_READY (1UL << 12)\n\n/* Set while the type is being 'readied', to prevent recursive ready calls */\n#define Py_TPFLAGS_READYING (1UL << 13)\n\n/* Objects support garbage collection (see objimpl.h) */\n#define Py_TPFLAGS_HAVE_GC (1UL << 14)\n\n/* These two bits are preserved for Stackless Python, next after this is 17 */\n#ifdef STACKLESS\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)\n#else\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0\n#endif\n\n/* Objects behave like an unbound method */\n#define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)\n\n/* Object has up-to-date type attribute cache */\n#define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)\n\n/* Type is abstract and cannot be instantiated */\n#define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)\n\n// This undocumented flag gives certain built-ins their unique pattern-matching\n// behavior, which allows a single positional subpattern to match against the\n// subject itself (rather than a mapped attribute on it):\n#define _Py_TPFLAGS_MATCH_SELF (1UL << 22)\n\n/* Items (ob_size*tp_itemsize) are found at the end of an instance's memory */\n#define Py_TPFLAGS_ITEMS_AT_END (1UL << 23)\n\n/* These flags are used to determine if a type is a subclass. */\n#define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)\n#define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)\n#define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)\n#define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)\n#define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)\n#define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)\n#define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)\n#define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)\n\n#define Py_TPFLAGS_DEFAULT  ( \\\n                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \\\n                0)\n\n/* NOTE: Some of the following flags reuse lower bits (removed as part of the\n * Python 3.0 transition). */\n\n/* The following flags are kept for compatibility; in previous\n * versions they indicated presence of newer tp_* fields on the\n * type struct.\n * Starting with 3.8, binary compatibility of C extensions across\n * feature releases of Python is not supported anymore (except when\n * using the stable ABI, in which all classes are created dynamically,\n * using the interpreter's memory layout.)\n * Note that older extensions using the stable ABI set these flags,\n * so the bits must not be repurposed.\n */\n#define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)\n#define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)\n\n\n/*\nThe macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement\nreference counts.  Py_DECREF calls the object's deallocator function when\nthe refcount falls to 0; for\nobjects that don't contain references to other objects or heap memory\nthis can be the standard function free().  Both macros can be used\nwherever a void expression is allowed.  The argument must not be a\nNULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.\nThe macro _Py_NewReference(op) initialize reference counts to 1, and\nin special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional\nbookkeeping appropriate to the special build.\n\nWe assume that the reference count field can never overflow; this can\nbe proven when the size of the field is the same as the pointer size, so\nwe ignore the possibility.  Provided a C int is at least 32 bits (which\nis implicitly assumed in many parts of this code), that's enough for\nabout 2**31 references to an object.\n\nXXX The following became out of date in Python 2.2, but I'm not sure\nXXX what the full truth is now.  Certainly, heap-allocated type objects\nXXX can and should be deallocated.\nType objects should never be deallocated; the type pointer in an object\nis not considered to be a reference to the type object, to save\ncomplications in the deallocation function.  (This is actually a\ndecision that's up to the implementer of each new type so if you want,\nyou can count such references to the type object.)\n*/\n\n#if defined(Py_REF_DEBUG) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,\n                                      PyObject *op);\nPyAPI_FUNC(void) _Py_INCREF_IncRefTotal(void);\nPyAPI_FUNC(void) _Py_DECREF_DecRefTotal(void);\n#endif  // Py_REF_DEBUG && !Py_LIMITED_API\n\nPyAPI_FUNC(void) _Py_Dealloc(PyObject *);\n\n/*\nThese are provided as conveniences to Python runtime embedders, so that\nthey can have object code that is not dependent on Python compilation flags.\n*/\nPyAPI_FUNC(void) Py_IncRef(PyObject *);\nPyAPI_FUNC(void) Py_DecRef(PyObject *);\n\n// Similar to Py_IncRef() and Py_DecRef() but the argument must be non-NULL.\n// Private functions used by Py_INCREF() and Py_DECREF().\nPyAPI_FUNC(void) _Py_IncRef(PyObject *);\nPyAPI_FUNC(void) _Py_DecRef(PyObject *);\n\nstatic inline Py_ALWAYS_INLINE void Py_INCREF(PyObject *op)\n{\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n    // Stable ABI implements Py_INCREF() as a function call on limited C API\n    // version 3.12 and newer, and on Python built in debug mode. _Py_IncRef()\n    // was added to Python 3.10.0a7, use Py_IncRef() on older Python versions.\n    // Py_IncRef() accepts NULL whereas _Py_IncRef() doesn't.\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_IncRef(op);\n#  else\n    Py_IncRef(op);\n#  endif\n#else\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n#if SIZEOF_VOID_P > 4\n    // Portable saturated add, branching on the carry flag and set low bits\n    PY_UINT32_T cur_refcnt = op->ob_refcnt_split[PY_BIG_ENDIAN];\n    PY_UINT32_T new_refcnt = cur_refcnt + 1;\n    if (new_refcnt == 0) {\n        return;\n    }\n    op->ob_refcnt_split[PY_BIG_ENDIAN] = new_refcnt;\n#else\n    // Explicitly check immortality against the immortal value\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    op->ob_refcnt++;\n#endif\n    _Py_INCREF_STAT_INC();\n#ifdef Py_REF_DEBUG\n    _Py_INCREF_IncRefTotal();\n#endif\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_INCREF(op) Py_INCREF(_PyObject_CAST(op))\n#endif\n\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n// Stable ABI implements Py_DECREF() as a function call on limited C API\n// version 3.12 and newer, and on Python built in debug mode. _Py_DecRef() was\n// added to Python 3.10.0a7, use Py_DecRef() on older Python versions.\n// Py_DecRef() accepts NULL whereas _Py_IncRef() doesn't.\nstatic inline void Py_DECREF(PyObject *op) {\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_DecRef(op);\n#  else\n    Py_DecRef(op);\n#  endif\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    if (op->ob_refcnt <= 0) {\n        _Py_NegativeRefcount(filename, lineno, op);\n    }\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#else\nstatic inline Py_ALWAYS_INLINE void Py_DECREF(PyObject *op)\n{\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n#endif\n\n\n/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear\n * and tp_dealloc implementations.\n *\n * Note that \"the obvious\" code can be deadly:\n *\n *     Py_XDECREF(op);\n *     op = NULL;\n *\n * Typically, `op` is something like self->containee, and `self` is done\n * using its `containee` member.  In the code sequence above, suppose\n * `containee` is non-NULL with a refcount of 1.  Its refcount falls to\n * 0 on the first line, which can trigger an arbitrary amount of code,\n * possibly including finalizers (like __del__ methods or weakref callbacks)\n * coded in Python, which in turn can release the GIL and allow other threads\n * to run, etc.  Such code may even invoke methods of `self` again, or cause\n * cyclic gc to trigger, but-- oops! --self->containee still points to the\n * object being torn down, and it may be in an insane state while being torn\n * down.  This has in fact been a rich historic source of miserable (rare &\n * hard-to-diagnose) segfaulting (and other) bugs.\n *\n * The safe way is:\n *\n *      Py_CLEAR(op);\n *\n * That arranges to set `op` to NULL _before_ decref'ing, so that any code\n * triggered as a side-effect of `op` getting torn down no longer believes\n * `op` points to a valid object.\n *\n * There are cases where it's safe to use the naive code, but they're brittle.\n * For example, if `op` points to a Python integer, you know that destroying\n * one of those can't cause problems -- but in part that relies on that\n * Python integers aren't currently weakly referencable.  Best practice is\n * to use Py_CLEAR() even if you can't think of a reason for why you need to.\n *\n * gh-98724: Use a temporary variable to only evaluate the macro argument once,\n * to avoid the duplication of side effects if the argument has side effects.\n *\n * gh-99701: If the PyObject* type is used with casting arguments to PyObject*,\n * the code can be miscompiled with strict aliasing because of type punning.\n * With strict aliasing, a compiler considers that two pointers of different\n * types cannot read or write the same memory which enables optimization\n * opportunities.\n *\n * If available, use _Py_TYPEOF() to use the 'op' type for temporary variables,\n * and so avoid type punning. Otherwise, use memcpy() which causes type erasure\n * and so prevents the compiler to reuse an old cached 'op' value after\n * Py_CLEAR().\n */\n#ifdef _Py_TYPEOF\n#define Py_CLEAR(op) \\\n    do { \\\n        _Py_TYPEOF(op)* _tmp_op_ptr = &(op); \\\n        _Py_TYPEOF(op) _tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            *_tmp_op_ptr = _Py_NULL; \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#else\n#define Py_CLEAR(op) \\\n    do { \\\n        PyObject **_tmp_op_ptr = _Py_CAST(PyObject**, &(op)); \\\n        PyObject *_tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            PyObject *_null_ptr = _Py_NULL; \\\n            memcpy(_tmp_op_ptr, &_null_ptr, sizeof(PyObject*)); \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#endif\n\n\n/* Function to use in case the object pointer can be NULL: */\nstatic inline void Py_XINCREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_INCREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XINCREF(op) Py_XINCREF(_PyObject_CAST(op))\n#endif\n\nstatic inline void Py_XDECREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_DECREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XDECREF(op) Py_XDECREF(_PyObject_CAST(op))\n#endif\n\n// Create a new strong reference to an object:\n// increment the reference count of the object and return the object.\nPyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);\n\n// Similar to Py_NewRef(), but the object can be NULL.\nPyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);\n\nstatic inline PyObject* _Py_NewRef(PyObject *obj)\n{\n    Py_INCREF(obj);\n    return obj;\n}\n\nstatic inline PyObject* _Py_XNewRef(PyObject *obj)\n{\n    Py_XINCREF(obj);\n    return obj;\n}\n\n// Py_NewRef() and Py_XNewRef() are exported as functions for the stable ABI.\n// Names overridden with macros by static inline functions for best\n// performances.\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_NewRef(obj) _Py_NewRef(_PyObject_CAST(obj))\n#  define Py_XNewRef(obj) _Py_XNewRef(_PyObject_CAST(obj))\n#else\n#  define Py_NewRef(obj) _Py_NewRef(obj)\n#  define Py_XNewRef(obj) _Py_XNewRef(obj)\n#endif\n\n\n/*\n_Py_NoneStruct is an object of undefined type which can be used in contexts\nwhere NULL (nil) is not suitable (since NULL often means 'error').\n\nDon't forget to apply Py_INCREF() when returning this value!!!\n*/\nPyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n#define Py_None (&_Py_NoneStruct)\n\n// Test if an object is the None singleton, the same as \"x is None\" in Python.\nPyAPI_FUNC(int) Py_IsNone(PyObject *x);\n#define Py_IsNone(x) Py_Is((x), Py_None)\n\n/* Macro for returning Py_None from a function */\n#define Py_RETURN_NONE return Py_None\n\n/*\nPy_NotImplemented is a singleton used to signal that an operation is\nnot implemented for a given type combination.\n*/\nPyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */\n#define Py_NotImplemented (&_Py_NotImplementedStruct)\n\n/* Macro for returning Py_NotImplemented from a function */\n#define Py_RETURN_NOTIMPLEMENTED return Py_NotImplemented\n\n/* Rich comparison opcodes */\n#define Py_LT 0\n#define Py_LE 1\n#define Py_EQ 2\n#define Py_NE 3\n#define Py_GT 4\n#define Py_GE 5\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000\n/* Result of calling PyIter_Send */\ntypedef enum {\n    PYGEN_RETURN = 0,\n    PYGEN_ERROR = -1,\n    PYGEN_NEXT = 1,\n} PySendResult;\n#endif\n\n/*\n * Macro for implementing rich comparisons\n *\n * Needs to be a macro because any C-comparable type can be used.\n */\n#define Py_RETURN_RICHCOMPARE(val1, val2, op)                               \\\n    do {                                                                    \\\n        switch (op) {                                                       \\\n        case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        default:                                                            \\\n            Py_UNREACHABLE();                                               \\\n        }                                                                   \\\n    } while (0)\n\n\n/*\nMore conventions\n================\n\nArgument Checking\n-----------------\n\nFunctions that take objects as arguments normally don't check for nil\narguments, but they do check the type of the argument, and return an\nerror if the function doesn't apply to the type.\n\nFailure Modes\n-------------\n\nFunctions may fail for a variety of reasons, including running out of\nmemory.  This is communicated to the caller in two ways: an error string\nis set (see errors.h), and the function result differs: functions that\nnormally return a pointer return NULL for failure, functions returning\nan integer return -1 (which could be a legal return value too!), and\nother functions return 0 for success and -1 for failure.\nCallers should always check for errors before using the result.  If\nan error was set, the caller must either explicitly clear it, or pass\nthe error on to its caller.\n\nReference Counts\n----------------\n\nIt takes a while to get used to the proper usage of reference counts.\n\nFunctions that create an object set the reference count to 1; such new\nobjects must be stored somewhere or destroyed again with Py_DECREF().\nSome functions that 'store' objects, such as PyTuple_SetItem() and\nPyList_SetItem(),\ndon't increment the reference count of the object, since the most\nfrequent use is to store a fresh object.  Functions that 'retrieve'\nobjects, such as PyTuple_GetItem() and PyDict_GetItemString(), also\ndon't increment\nthe reference count, since most frequently the object is only looked at\nquickly.  Thus, to retrieve an object and store it again, the caller\nmust call Py_INCREF() explicitly.\n\nNOTE: functions that 'consume' a reference count, like\nPyList_SetItem(), consume the reference even if the object wasn't\nsuccessfully stored, to simplify error handling.\n\nIt seems attractive to make other functions that take an object as\nargument consume a reference count; however, this may quickly get\nconfusing (even the current practice is already confusing).  Consider\nit carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at\ntimes.\n*/\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_OBJECT_H\n#  include \"cpython/object.h\"\n#  undef Py_CPYTHON_OBJECT_H\n#endif\n\n\nstatic inline int\nPyType_HasFeature(PyTypeObject *type, unsigned long feature)\n{\n    unsigned long flags;\n#ifdef Py_LIMITED_API\n    // PyTypeObject is opaque in the limited C API\n    flags = PyType_GetFlags(type);\n#else\n    flags = type->tp_flags;\n#endif\n    return ((flags & feature) != 0);\n}\n\n#define PyType_FastSubclass(type, flag) PyType_HasFeature((type), (flag))\n\nstatic inline int PyType_Check(PyObject *op) {\n    return PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_Check(op) PyType_Check(_PyObject_CAST(op))\n#endif\n\n#define _PyType_CAST(op) \\\n    (assert(PyType_Check(op)), _Py_CAST(PyTypeObject*, (op)))\n\nstatic inline int PyType_CheckExact(PyObject *op) {\n    return Py_IS_TYPE(op, &PyType_Type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_CheckExact(op) PyType_CheckExact(_PyObject_CAST(op))\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif   // !Py_OBJECT_H\n"}, "sourceLanguage": "c"}, {"location": {"uri": "./Include/cpython/tupleobject.h", "uriBaseId": "PWD"}, "contents": {"text": "#ifndef Py_CPYTHON_TUPLEOBJECT_H\n#  error \"this header file must not be included directly\"\n#endif\n\ntypedef struct {\n    PyObject_VAR_HEAD\n    /* ob_item contains space for 'ob_size' elements.\n       Items must normally not be NULL, except during construction when\n       the tuple is not yet visible outside the function that builds it. */\n    PyObject *ob_item[1];\n} PyTupleObject;\n\nPyAPI_FUNC(int) _PyTuple_Resize(PyObject **, Py_ssize_t);\nPyAPI_FUNC(void) _PyTuple_MaybeUntrack(PyObject *);\n\n/* Cast argument to PyTupleObject* type. */\n#define _PyTuple_CAST(op) \\\n    (assert(PyTuple_Check(op)), _Py_CAST(PyTupleObject*, (op)))\n\n// Macros and static inline functions, trading safety for speed\n\nstatic inline Py_ssize_t PyTuple_GET_SIZE(PyObject *op) {\n    PyTupleObject *tuple = _PyTuple_CAST(op);\n    return Py_SIZE(tuple);\n}\n#define PyTuple_GET_SIZE(op) PyTuple_GET_SIZE(_PyObject_CAST(op))\n\n#define PyTuple_GET_ITEM(op, index) (_PyTuple_CAST(op)->ob_item[(index)])\n\n/* Function *only* to be used to fill in brand new tuples */\nstatic inline void\nPyTuple_SET_ITEM(PyObject *op, Py_ssize_t index, PyObject *value) {\n    PyTupleObject *tuple = _PyTuple_CAST(op);\n    tuple->ob_item[index] = value;\n}\n#define PyTuple_SET_ITEM(op, index, value) \\\n    PyTuple_SET_ITEM(_PyObject_CAST(op), (index), _PyObject_CAST(value))\n\nPyAPI_FUNC(void) _PyTuple_DebugMallocStats(FILE *out);\n"}, "sourceLanguage": "c"}, {"location": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "contents": {"text": "/*\n  ToDo:\n\n  Get rid of the checker (and also the converters) field in PyCFuncPtrObject and\n  StgDictObject, and replace them by slot functions in StgDictObject.\n\n  think about a buffer-like object (memory? bytes?)\n\n  Should POINTER(c_char) and POINTER(c_wchar) have a .value property?\n  What about c_char and c_wchar arrays then?\n\n  Add from_mmap, from_file, from_string metaclass methods.\n\n  Maybe we can get away with from_file (calls read) and with a from_buffer\n  method?\n\n  And what about the to_mmap, to_file, to_str(?) methods?  They would clobber\n  the namespace, probably. So, functions instead? And we already have memmove...\n*/\n\n/*\n\nName                    methods, members, getsets\n==============================================================================\n\nPyCStructType_Type              __new__(), from_address(), __mul__(), from_param()\nUnionType_Type                  __new__(), from_address(), __mul__(), from_param()\nPyCPointerType_Type             __new__(), from_address(), __mul__(), from_param(), set_type()\nPyCArrayType_Type               __new__(), from_address(), __mul__(), from_param()\nPyCSimpleType_Type              __new__(), from_address(), __mul__(), from_param()\n\nPyCData_Type\n  Struct_Type                   __new__(), __init__()\n  PyCPointer_Type               __new__(), __init__(), _as_parameter_, contents\n  PyCArray_Type                 __new__(), __init__(), _as_parameter_, __get/setitem__(), __len__()\n  Simple_Type                   __new__(), __init__(), _as_parameter_\n\nPyCField_Type\nPyCStgDict_Type\n\n==============================================================================\n\nclass methods\n-------------\n\nIt has some similarity to the byref() construct compared to pointer()\nfrom_address(addr)\n    - construct an instance from a given memory block (sharing this memory block)\n\nfrom_param(obj)\n    - typecheck and convert a Python object into a C function call parameter\n      The result may be an instance of the type, or an integer or tuple\n      (typecode, value[, obj])\n\ninstance methods/properties\n---------------------------\n\n_as_parameter_\n    - convert self into a C function call parameter\n      This is either an integer, or a 3-tuple (typecode, value, obj)\n\nfunctions\n---------\n\nsizeof(cdata)\n    - return the number of bytes the buffer contains\n\nsizeof(ctype)\n    - return the number of bytes the buffer of an instance would contain\n\nbyref(cdata)\n\naddressof(cdata)\n\npointer(cdata)\n\nPOINTER(ctype)\n\nbytes(cdata)\n    - return the buffer contents as a sequence of bytes (which is currently a string)\n\n*/\n\n/*\n * PyCStgDict_Type\n * PyCStructType_Type\n * UnionType_Type\n * PyCPointerType_Type\n * PyCArrayType_Type\n * PyCSimpleType_Type\n *\n * PyCData_Type\n * Struct_Type\n * Union_Type\n * PyCArray_Type\n * Simple_Type\n * PyCPointer_Type\n * PyCField_Type\n *\n */\n#ifndef Py_BUILD_CORE_BUILTIN\n#  define Py_BUILD_CORE_MODULE 1\n#endif\n#define PY_SSIZE_T_CLEAN\n\n#include \"Python.h\"\n// windows.h must be included before pycore internal headers\n#ifdef MS_WIN32\n#  include <windows.h>\n#endif\n\n#include \"pycore_call.h\"          // _PyObject_CallNoArgs()\n#include \"pycore_ceval.h\"         // _Py_EnterRecursiveCall()\n#include \"structmember.h\"         // PyMemberDef\n\n#include <ffi.h>\n#ifdef MS_WIN32\n#include <malloc.h>\n#ifndef IS_INTRESOURCE\n#define IS_INTRESOURCE(x) (((size_t)(x) >> 16) == 0)\n#endif\n#else\n#include <dlfcn.h>\n#endif\n#include \"ctypes.h\"\n\n#include \"pycore_long.h\"          // _PyLong_GetZero()\n\nctypes_state global_state;\n\nPyObject *PyExc_ArgError = NULL;\n\n/* This dict maps ctypes types to POINTER types */\nPyObject *_ctypes_ptrtype_cache = NULL;\n\nstatic PyTypeObject Simple_Type;\n\n/* a callable object used for unpickling:\n   strong reference to _ctypes._unpickle() function */\nstatic PyObject *_unpickle;\n\n\n/****************************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *key;\n    PyObject *dict;\n} DictRemoverObject;\n\nstatic int\n_DictRemover_traverse(DictRemoverObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(self));\n    Py_VISIT(self->key);\n    Py_VISIT(self->dict);\n    return 0;\n}\n\nstatic int\n_DictRemover_clear(DictRemoverObject *self)\n{\n    Py_CLEAR(self->key);\n    Py_CLEAR(self->dict);\n    return 0;\n}\n\nstatic void\n_DictRemover_dealloc(PyObject *myself)\n{\n    PyTypeObject *tp = Py_TYPE(myself);\n    DictRemoverObject *self = (DictRemoverObject *)myself;\n    PyObject_GC_UnTrack(myself);\n    (void)_DictRemover_clear(self);\n    tp->tp_free(myself);\n    Py_DECREF(tp);\n}\n\nstatic PyObject *\n_DictRemover_call(PyObject *myself, PyObject *args, PyObject *kw)\n{\n    DictRemoverObject *self = (DictRemoverObject *)myself;\n    if (self->key && self->dict) {\n        if (-1 == PyDict_DelItem(self->dict, self->key)) {\n            _PyErr_WriteUnraisableMsg(\"on calling _ctypes.DictRemover\", NULL);\n        }\n        Py_CLEAR(self->key);\n        Py_CLEAR(self->dict);\n    }\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(dictremover_doc, \"deletes a key from a dictionary\");\n\nstatic PyType_Slot dictremover_slots[] = {\n    {Py_tp_dealloc, _DictRemover_dealloc},\n    {Py_tp_traverse, _DictRemover_traverse},\n    {Py_tp_clear, _DictRemover_clear},\n    {Py_tp_call, _DictRemover_call},\n    {Py_tp_doc, (void *)dictremover_doc},\n    {0, NULL},\n};\n\nstatic PyType_Spec dictremover_spec = {\n    .name = \"_ctypes.DictRemover\",\n    .basicsize = sizeof(DictRemoverObject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n              Py_TPFLAGS_IMMUTABLETYPE),\n    .slots = dictremover_slots,\n};\n\nint\nPyDict_SetItemProxy(PyObject *dict, PyObject *key, PyObject *item)\n{\n    PyObject *obj;\n    DictRemoverObject *remover;\n    PyObject *proxy;\n    int result;\n\n    ctypes_state *st = GLOBAL_STATE();\n    obj = _PyObject_CallNoArgs((PyObject *)st->DictRemover_Type);\n    if (obj == NULL)\n        return -1;\n\n    remover = (DictRemoverObject *)obj;\n    assert(remover->key == NULL);\n    assert(remover->dict == NULL);\n    remover->key = Py_NewRef(key);\n    remover->dict = Py_NewRef(dict);\n\n    proxy = PyWeakref_NewProxy(item, obj);\n    Py_DECREF(obj);\n    if (proxy == NULL)\n        return -1;\n\n    result = PyDict_SetItem(dict, key, proxy);\n    Py_DECREF(proxy);\n    return result;\n}\n\nPyObject *\nPyDict_GetItemProxy(PyObject *dict, PyObject *key)\n{\n    PyObject *result;\n    PyObject *item = PyDict_GetItemWithError(dict, key);\n\n    if (item == NULL)\n        return NULL;\n    if (!PyWeakref_CheckProxy(item))\n        return item;\n    result = PyWeakref_GET_OBJECT(item);\n    if (result == Py_None)\n        return NULL;\n    return result;\n}\n\n/******************************************************************/\n\n/*\n  Allocate a memory block for a pep3118 format string, filled with\n  a suitable PEP 3118 type code corresponding to the given ctypes\n  type. Returns NULL on failure, with the error indicator set.\n\n  This produces type codes in the standard size mode (cf. struct module),\n  since the endianness may need to be swapped to a non-native one\n  later on.\n */\nstatic char *\n_ctypes_alloc_format_string_for_type(char code, int big_endian)\n{\n    char *result;\n    char pep_code = '\\0';\n\n    switch (code) {\n#if SIZEOF_INT == 2\n    case 'i': pep_code = 'h'; break;\n    case 'I': pep_code = 'H'; break;\n#elif SIZEOF_INT == 4\n    case 'i': pep_code = 'i'; break;\n    case 'I': pep_code = 'I'; break;\n#elif SIZEOF_INT == 8\n    case 'i': pep_code = 'q'; break;\n    case 'I': pep_code = 'Q'; break;\n#else\n# error SIZEOF_INT has an unexpected value\n#endif /* SIZEOF_INT */\n#if SIZEOF_LONG == 4\n    case 'l': pep_code = 'l'; break;\n    case 'L': pep_code = 'L'; break;\n#elif SIZEOF_LONG == 8\n    case 'l': pep_code = 'q'; break;\n    case 'L': pep_code = 'Q'; break;\n#else\n# error SIZEOF_LONG has an unexpected value\n#endif /* SIZEOF_LONG */\n#if SIZEOF__BOOL == 1\n    case '?': pep_code = '?'; break;\n#elif SIZEOF__BOOL == 2\n    case '?': pep_code = 'H'; break;\n#elif SIZEOF__BOOL == 4\n    case '?': pep_code = 'L'; break;\n#elif SIZEOF__BOOL == 8\n    case '?': pep_code = 'Q'; break;\n#else\n# error SIZEOF__BOOL has an unexpected value\n#endif /* SIZEOF__BOOL */\n    default:\n        /* The standard-size code is the same as the ctypes one */\n        pep_code = code;\n        break;\n    }\n\n    result = PyMem_Malloc(3);\n    if (result == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    result[0] = big_endian ? '>' : '<';\n    result[1] = pep_code;\n    result[2] = '\\0';\n    return result;\n}\n\n/*\n  Allocate a memory block for a pep3118 format string, copy prefix (if\n  non-null) and suffix into it.  Returns NULL on failure, with the error\n  indicator set.  If called with a suffix of NULL the error indicator must\n  already be set.\n */\nchar *\n_ctypes_alloc_format_string(const char *prefix, const char *suffix)\n{\n    size_t len;\n    char *result;\n\n    if (suffix == NULL) {\n        assert(PyErr_Occurred());\n        return NULL;\n    }\n    len = strlen(suffix);\n    if (prefix)\n        len += strlen(prefix);\n    result = PyMem_Malloc(len + 1);\n    if (result == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    if (prefix)\n        strcpy(result, prefix);\n    else\n        result[0] = '\\0';\n    strcat(result, suffix);\n    return result;\n}\n\n/*\n  Allocate a memory block for a pep3118 format string, adding\n  the given prefix (if non-null), an additional shape prefix, and a suffix.\n  Returns NULL on failure, with the error indicator set.  If called with\n  a suffix of NULL the error indicator must already be set.\n */\nchar *\n_ctypes_alloc_format_string_with_shape(int ndim, const Py_ssize_t *shape,\n                                       const char *prefix, const char *suffix)\n{\n    char *new_prefix;\n    char *result;\n    char buf[32];\n    Py_ssize_t prefix_len;\n    int k;\n\n    prefix_len = 32 * ndim + 3;\n    if (prefix)\n        prefix_len += strlen(prefix);\n    new_prefix = PyMem_Malloc(prefix_len);\n    if (new_prefix == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    new_prefix[0] = '\\0';\n    if (prefix)\n        strcpy(new_prefix, prefix);\n    if (ndim > 0) {\n        /* Add the prefix \"(shape[0],shape[1],...,shape[ndim-1])\" */\n        strcat(new_prefix, \"(\");\n        for (k = 0; k < ndim; ++k) {\n            if (k < ndim-1) {\n                sprintf(buf, \"%zd,\", shape[k]);\n            } else {\n                sprintf(buf, \"%zd)\", shape[k]);\n            }\n            strcat(new_prefix, buf);\n        }\n    }\n    result = _ctypes_alloc_format_string(new_prefix, suffix);\n    PyMem_Free(new_prefix);\n    return result;\n}\n\n/* StructParamObject and StructParam_Type are used in _ctypes_callproc()\n   for argument.keep to call PyMem_Free(ptr) on Py_DECREF(argument).\n\n   StructUnionType_paramfunc() creates such object when a ctypes Structure is\n   passed by copy to a C function. */\ntypedef struct {\n    PyObject_HEAD\n    void *ptr;\n    PyObject *keep;  // If set, a reference to the original CDataObject.\n} StructParamObject;\n\nstatic int\nStructParam_traverse(StructParamObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(self));\n    return 0;\n}\n\nstatic int\nStructParam_clear(StructParamObject *self)\n{\n    Py_CLEAR(self->keep);\n    return 0;\n}\n\nstatic void\nStructParam_dealloc(PyObject *myself)\n{\n    StructParamObject *self = (StructParamObject *)myself;\n    PyTypeObject *tp = Py_TYPE(self);\n    PyObject_GC_UnTrack(myself);\n    (void)StructParam_clear(self);\n    PyMem_Free(self->ptr);\n    tp->tp_free(myself);\n    Py_DECREF(tp);\n}\n\nstatic PyType_Slot structparam_slots[] = {\n    {Py_tp_traverse, StructParam_traverse},\n    {Py_tp_clear, StructParam_clear},\n    {Py_tp_dealloc, StructParam_dealloc},\n    {0, NULL},\n};\n\nstatic PyType_Spec structparam_spec = {\n    .name = \"_ctypes.StructParam_Type\",\n    .basicsize = sizeof(StructParamObject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE |\n              Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_DISALLOW_INSTANTIATION),\n    .slots = structparam_slots,\n};\n\n\n/*\n  PyCStructType_Type - a meta type/class.  Creating a new class using this one as\n  __metaclass__ will call the constructor StructUnionType_new.  It replaces the\n  tp_dict member with a new instance of StgDict, and initializes the C\n  accessible fields somehow.\n*/\n\nstatic PyCArgObject *\nStructUnionType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *parg;\n    PyObject *obj;\n    StgDictObject *stgdict;\n    void *ptr;\n\n    if ((size_t)self->b_size > sizeof(void*)) {\n        ptr = PyMem_Malloc(self->b_size);\n        if (ptr == NULL) {\n            return NULL;\n        }\n        memcpy(ptr, self->b_ptr, self->b_size);\n\n        /* Create a Python object which calls PyMem_Free(ptr) in\n           its deallocator. The object will be destroyed\n           at _ctypes_callproc() cleanup. */\n        ctypes_state *st = GLOBAL_STATE();\n        PyTypeObject *tp = st->StructParam_Type;\n        obj = tp->tp_alloc(tp, 0);\n        if (obj == NULL) {\n            PyMem_Free(ptr);\n            return NULL;\n        }\n\n        StructParamObject *struct_param = (StructParamObject *)obj;\n        struct_param->ptr = ptr;\n        struct_param->keep = Py_NewRef(self);\n    } else {\n        ptr = self->b_ptr;\n        obj = Py_NewRef(self);\n    }\n\n    parg = PyCArgObject_new();\n    if (parg == NULL) {\n        Py_DECREF(obj);\n        return NULL;\n    }\n\n    parg->tag = 'V';\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for structure/union instances */\n    parg->pffi_type = &stgdict->ffi_type_pointer;\n    parg->value.p = ptr;\n    parg->size = self->b_size;\n    parg->obj = obj;\n    return parg;\n}\n\nstatic PyObject *\nStructUnionType_new(PyTypeObject *type, PyObject *args, PyObject *kwds, int isStruct)\n{\n    PyTypeObject *result;\n    PyObject *fields;\n    StgDictObject *dict;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (!result)\n        return NULL;\n\n    /* keep this for bw compatibility */\n    int r = PyDict_Contains(result->tp_dict, &_Py_ID(_abstract_));\n    if (r > 0)\n        return (PyObject *)result;\n    if (r < 0) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    dict = (StgDictObject *)_PyObject_CallNoArgs((PyObject *)&PyCStgDict_Type);\n    if (!dict) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    if (!isStruct) {\n        dict->flags |= TYPEFLAG_HASUNION;\n    }\n    /* replace the class dict by our updated stgdict, which holds info\n       about storage requirements of the instances */\n    if (-1 == PyDict_Update((PyObject *)dict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)dict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)dict);\n    dict->format = _ctypes_alloc_format_string(NULL, \"B\");\n    if (dict->format == NULL) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    dict->paramfunc = StructUnionType_paramfunc;\n\n    fields = PyDict_GetItemWithError((PyObject *)dict, &_Py_ID(_fields_));\n    if (fields) {\n        if (PyObject_SetAttr((PyObject *)result, &_Py_ID(_fields_), fields) < 0) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        return (PyObject *)result;\n    }\n    else if (PyErr_Occurred()) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    else {\n        StgDictObject *basedict = PyType_stgdict((PyObject *)result->tp_base);\n\n        if (basedict == NULL)\n            return (PyObject *)result;\n        /* copy base dict */\n        if (-1 == PyCStgDict_clone(dict, basedict)) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        dict->flags &= ~DICTFLAG_FINAL; /* clear the 'final' flag in the subclass dict */\n        basedict->flags |= DICTFLAG_FINAL; /* set the 'final' flag in the baseclass dict */\n        return (PyObject *)result;\n    }\n}\n\nstatic PyObject *\nPyCStructType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    return StructUnionType_new(type, args, kwds, 1);\n}\n\nstatic PyObject *\nUnionType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    return StructUnionType_new(type, args, kwds, 0);\n}\n\nPyDoc_STRVAR(from_address_doc,\n\"C.from_address(integer) -> C instance\\naccess a C instance at the specified address\");\n\nstatic PyObject *\nCDataType_from_address(PyObject *type, PyObject *value)\n{\n    void *buf;\n    if (!PyLong_Check(value)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"integer expected\");\n        return NULL;\n    }\n    buf = (void *)PyLong_AsVoidPtr(value);\n    if (PyErr_Occurred())\n        return NULL;\n    return PyCData_AtAddress(type, buf);\n}\n\nPyDoc_STRVAR(from_buffer_doc,\n\"C.from_buffer(object, offset=0) -> C instance\\ncreate a C instance from a writeable buffer\");\n\nstatic int\nKeepRef(CDataObject *target, Py_ssize_t index, PyObject *keep);\n\nstatic PyObject *\nCDataType_from_buffer(PyObject *type, PyObject *args)\n{\n    PyObject *obj;\n    PyObject *mv;\n    PyObject *result;\n    Py_buffer *buffer;\n    Py_ssize_t offset = 0;\n\n    StgDictObject *dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError, \"abstract class\");\n        return NULL;\n    }\n\n    if (!PyArg_ParseTuple(args, \"O|n:from_buffer\", &obj, &offset))\n        return NULL;\n\n    mv = PyMemoryView_FromObject(obj);\n    if (mv == NULL)\n        return NULL;\n\n    buffer = PyMemoryView_GET_BUFFER(mv);\n\n    if (buffer->readonly) {\n        PyErr_SetString(PyExc_TypeError,\n            \"underlying buffer is not writable\");\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (!PyBuffer_IsContiguous(buffer, 'C')) {\n        PyErr_SetString(PyExc_TypeError,\n            \"underlying buffer is not C contiguous\");\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (offset < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"offset cannot be negative\");\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (dict->size > buffer->len - offset) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Buffer size too small \"\n                     \"(%zd instead of at least %zd bytes)\",\n                     buffer->len, dict->size + offset);\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (PySys_Audit(\"ctypes.cdata/buffer\", \"nnn\",\n                    (Py_ssize_t)buffer->buf, buffer->len, offset) < 0) {\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    result = PyCData_AtAddress(type, (char *)buffer->buf + offset);\n    if (result == NULL) {\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (-1 == KeepRef((CDataObject *)result, -1, mv)) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    return result;\n}\n\nPyDoc_STRVAR(from_buffer_copy_doc,\n\"C.from_buffer_copy(object, offset=0) -> C instance\\ncreate a C instance from a readable buffer\");\n\nstatic PyObject *\nGenericPyCData_new(PyTypeObject *type, PyObject *args, PyObject *kwds);\n\nstatic PyObject *\nCDataType_from_buffer_copy(PyObject *type, PyObject *args)\n{\n    Py_buffer buffer;\n    Py_ssize_t offset = 0;\n    PyObject *result;\n    StgDictObject *dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError, \"abstract class\");\n        return NULL;\n    }\n\n    if (!PyArg_ParseTuple(args, \"y*|n:from_buffer_copy\", &buffer, &offset))\n        return NULL;\n\n    if (offset < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"offset cannot be negative\");\n        PyBuffer_Release(&buffer);\n        return NULL;\n    }\n\n    if (dict->size > buffer.len - offset) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Buffer size too small (%zd instead of at least %zd bytes)\",\n                     buffer.len, dict->size + offset);\n        PyBuffer_Release(&buffer);\n        return NULL;\n    }\n\n    if (PySys_Audit(\"ctypes.cdata/buffer\", \"nnn\",\n                    (Py_ssize_t)buffer.buf, buffer.len, offset) < 0) {\n        PyBuffer_Release(&buffer);\n        return NULL;\n    }\n\n    result = GenericPyCData_new((PyTypeObject *)type, NULL, NULL);\n    if (result != NULL) {\n        memcpy(((CDataObject *)result)->b_ptr,\n               (char *)buffer.buf + offset, dict->size);\n    }\n    PyBuffer_Release(&buffer);\n    return result;\n}\n\nPyDoc_STRVAR(in_dll_doc,\n\"C.in_dll(dll, name) -> C instance\\naccess a C instance in a dll\");\n\nstatic PyObject *\nCDataType_in_dll(PyObject *type, PyObject *args)\n{\n    PyObject *dll;\n    char *name;\n    PyObject *obj;\n    void *handle;\n    void *address;\n\n    if (!PyArg_ParseTuple(args, \"Os:in_dll\", &dll, &name))\n        return NULL;\n    if (PySys_Audit(\"ctypes.dlsym\", \"O\", args) < 0) {\n        return NULL;\n    }\n\n    obj = PyObject_GetAttrString(dll, \"_handle\");\n    if (!obj)\n        return NULL;\n    if (!PyLong_Check(obj)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"the _handle attribute of the second argument must be an integer\");\n        Py_DECREF(obj);\n        return NULL;\n    }\n    handle = (void *)PyLong_AsVoidPtr(obj);\n    Py_DECREF(obj);\n    if (PyErr_Occurred()) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"could not convert the _handle attribute to a pointer\");\n        return NULL;\n    }\n\n#ifdef MS_WIN32\n    Py_BEGIN_ALLOW_THREADS\n    address = (void *)GetProcAddress(handle, name);\n    Py_END_ALLOW_THREADS\n    if (!address) {\n        PyErr_Format(PyExc_ValueError,\n                     \"symbol '%s' not found\",\n                     name);\n        return NULL;\n    }\n#else\n    address = (void *)dlsym(handle, name);\n    if (!address) {\n#ifdef __CYGWIN__\n/* dlerror() isn't very helpful on cygwin */\n        PyErr_Format(PyExc_ValueError,\n                     \"symbol '%s' not found\",\n                     name);\n#else\n        PyErr_SetString(PyExc_ValueError, dlerror());\n#endif\n        return NULL;\n    }\n#endif\n    return PyCData_AtAddress(type, address);\n}\n\nPyDoc_STRVAR(from_param_doc,\n\"Convert a Python object into a function call parameter.\");\n\nstatic PyObject *\nCDataType_from_param(PyObject *type, PyObject *value)\n{\n    PyObject *as_parameter;\n    int res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        return Py_NewRef(value);\n    }\n    ctypes_state *st = GLOBAL_STATE();\n    if (PyCArg_CheckExact(st, value)) {\n        PyCArgObject *p = (PyCArgObject *)value;\n        PyObject *ob = p->obj;\n        const char *ob_name;\n        StgDictObject *dict;\n        dict = PyType_stgdict(type);\n\n        /* If we got a PyCArgObject, we must check if the object packed in it\n           is an instance of the type's dict->proto */\n        if(dict && ob) {\n            res = PyObject_IsInstance(ob, dict->proto);\n            if (res == -1)\n                return NULL;\n            if (res) {\n                return Py_NewRef(value);\n            }\n        }\n        ob_name = (ob) ? Py_TYPE(ob)->tp_name : \"???\";\n        PyErr_Format(PyExc_TypeError,\n                     \"expected %s instance instead of pointer to %s\",\n                     ((PyTypeObject *)type)->tp_name, ob_name);\n        return NULL;\n    }\n\n    if (_PyObject_LookupAttr(value, &_Py_ID(_as_parameter_), &as_parameter) < 0) {\n        return NULL;\n    }\n    if (as_parameter) {\n        value = CDataType_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"expected %s instance instead of %s\",\n                 ((PyTypeObject *)type)->tp_name,\n                 Py_TYPE(value)->tp_name);\n    return NULL;\n}\n\nstatic PyMethodDef CDataType_methods[] = {\n    { \"from_param\", CDataType_from_param, METH_O, from_param_doc },\n    { \"from_address\", CDataType_from_address, METH_O, from_address_doc },\n    { \"from_buffer\", CDataType_from_buffer, METH_VARARGS, from_buffer_doc, },\n    { \"from_buffer_copy\", CDataType_from_buffer_copy, METH_VARARGS, from_buffer_copy_doc, },\n    { \"in_dll\", CDataType_in_dll, METH_VARARGS, in_dll_doc },\n    { NULL, NULL },\n};\n\nstatic PyObject *\nCDataType_repeat(PyObject *self, Py_ssize_t length)\n{\n    if (length < 0)\n        return PyErr_Format(PyExc_ValueError,\n                            \"Array length must be >= 0, not %zd\",\n                            length);\n    return PyCArrayType_from_ctype(self, length);\n}\n\nstatic PySequenceMethods CDataType_as_sequence = {\n    0,                          /* inquiry sq_length; */\n    0,                          /* binaryfunc sq_concat; */\n    CDataType_repeat,           /* intargfunc sq_repeat; */\n    0,                          /* intargfunc sq_item; */\n    0,                          /* intintargfunc sq_slice; */\n    0,                          /* intobjargproc sq_ass_item; */\n    0,                          /* intintobjargproc sq_ass_slice; */\n    0,                          /* objobjproc sq_contains; */\n\n    0,                          /* binaryfunc sq_inplace_concat; */\n    0,                          /* intargfunc sq_inplace_repeat; */\n};\n\nstatic int\nCDataType_clear(PyTypeObject *self)\n{\n    StgDictObject *dict = PyType_stgdict((PyObject *)self);\n    if (dict)\n        Py_CLEAR(dict->proto);\n    return PyType_Type.tp_clear((PyObject *)self);\n}\n\nstatic int\nCDataType_traverse(PyTypeObject *self, visitproc visit, void *arg)\n{\n    StgDictObject *dict = PyType_stgdict((PyObject *)self);\n    if (dict)\n        Py_VISIT(dict->proto);\n    return PyType_Type.tp_traverse((PyObject *)self, visit, arg);\n}\n\nstatic int\nPyCStructType_setattro(PyObject *self, PyObject *key, PyObject *value)\n{\n    /* XXX Should we disallow deleting _fields_? */\n    if (-1 == PyType_Type.tp_setattro(self, key, value))\n        return -1;\n\n    if (value && PyUnicode_Check(key) &&\n        _PyUnicode_EqualToASCIIString(key, \"_fields_\"))\n        return PyCStructUnionType_update_stgdict(self, value, 1);\n    return 0;\n}\n\n\nstatic int\nUnionType_setattro(PyObject *self, PyObject *key, PyObject *value)\n{\n    /* XXX Should we disallow deleting _fields_? */\n    if (-1 == PyObject_GenericSetAttr(self, key, value))\n        return -1;\n\n    if (PyUnicode_Check(key) &&\n        _PyUnicode_EqualToASCIIString(key, \"_fields_\"))\n        return PyCStructUnionType_update_stgdict(self, value, 0);\n    return 0;\n}\n\n\nPyTypeObject PyCStructType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCStructType\",                            /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,                     /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    PyCStructType_setattro,                     /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    PyDoc_STR(\"metatype for the CData Objects\"), /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCStructType_new,                                  /* tp_new */\n    0,                                          /* tp_free */\n};\n\nstatic PyTypeObject UnionType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.UnionType\",                        /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,             /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    UnionType_setattro,                         /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    PyDoc_STR(\"metatype for the CData Objects\"), /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    UnionType_new,                              /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n\n/*\n\nThe PyCPointerType_Type metaclass must ensure that the subclass of Pointer can be\ncreated. It must check for a _type_ attribute in the class. Since are no\nruntime created properties, a CField is probably *not* needed ?\n\nclass IntPointer(Pointer):\n    _type_ = \"i\"\n\nThe PyCPointer_Type provides the functionality: a contents method/property, a\nsize property/method, and the sequence protocol.\n\n*/\n\nstatic int\nPyCPointerType_SetProto(StgDictObject *stgdict, PyObject *proto)\n{\n    if (!proto || !PyType_Check(proto)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_type_ must be a type\");\n        return -1;\n    }\n    if (!PyType_stgdict(proto)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_type_ must have storage info\");\n        return -1;\n    }\n    Py_INCREF(proto);\n    Py_XSETREF(stgdict->proto, proto);\n    return 0;\n}\n\nstatic PyCArgObject *\nPyCPointerType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *parg;\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    parg->obj = Py_NewRef(self);\n    parg->value.p = *(void **)self->b_ptr;\n    return parg;\n}\n\nstatic PyObject *\nPyCPointerType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    PyObject *proto;\n    PyObject *typedict;\n\n\n    typedict = PyTuple_GetItem(args, 2);\n    if (!typedict)\n        return NULL;\n/*\n  stgdict items size, align, length contain info about pointers itself,\n  stgdict->proto has info about the pointed to type!\n*/\n    stgdict = (StgDictObject *)_PyObject_CallNoArgs(\n        (PyObject *)&PyCStgDict_Type);\n    if (!stgdict)\n        return NULL;\n    stgdict->size = sizeof(void *);\n    stgdict->align = _ctypes_get_fielddesc(\"P\")->pffi_type->alignment;\n    stgdict->length = 1;\n    stgdict->ffi_type_pointer = ffi_type_pointer;\n    stgdict->paramfunc = PyCPointerType_paramfunc;\n    stgdict->flags |= TYPEFLAG_ISPOINTER;\n\n    proto = PyDict_GetItemWithError(typedict, &_Py_ID(_type_)); /* Borrowed ref */\n    if (proto) {\n        StgDictObject *itemdict;\n        const char *current_format;\n        if (-1 == PyCPointerType_SetProto(stgdict, proto)) {\n            Py_DECREF((PyObject *)stgdict);\n            return NULL;\n        }\n        itemdict = PyType_stgdict(proto);\n        /* PyCPointerType_SetProto has verified proto has a stgdict. */\n        assert(itemdict);\n        /* If itemdict->format is NULL, then this is a pointer to an\n           incomplete type.  We create a generic format string\n           'pointer to bytes' in this case.  XXX Better would be to\n           fix the format string later...\n        */\n        current_format = itemdict->format ? itemdict->format : \"B\";\n        if (itemdict->shape != NULL) {\n            /* pointer to an array: the shape needs to be prefixed */\n            stgdict->format = _ctypes_alloc_format_string_with_shape(\n                itemdict->ndim, itemdict->shape, \"&\", current_format);\n        } else {\n            stgdict->format = _ctypes_alloc_format_string(\"&\", current_format);\n        }\n        if (stgdict->format == NULL) {\n            Py_DECREF((PyObject *)stgdict);\n            return NULL;\n        }\n    }\n    else if (PyErr_Occurred()) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);\n\n    return (PyObject *)result;\n}\n\n\nstatic PyObject *\nPyCPointerType_set_type(PyTypeObject *self, PyObject *type)\n{\n    StgDictObject *dict;\n\n\n    dict = PyType_stgdict((PyObject *)self);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n\n    if (-1 == PyCPointerType_SetProto(dict, type))\n        return NULL;\n\n    if (-1 == PyDict_SetItem((PyObject *)dict, &_Py_ID(_type_), type))\n        return NULL;\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *_byref(PyObject *);\n\nstatic PyObject *\nPyCPointerType_from_param(PyObject *type, PyObject *value)\n{\n    StgDictObject *typedict;\n\n    if (value == Py_None) {\n        /* ConvParam will convert to a NULL pointer later */\n        return Py_NewRef(value);\n    }\n\n    typedict = PyType_stgdict(type);\n    if (!typedict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n\n    /* If we expect POINTER(<type>), but receive a <type> instance, accept\n       it by calling byref(<type>).\n    */\n    switch (PyObject_IsInstance(value, typedict->proto)) {\n    case 1:\n        Py_INCREF(value); /* _byref steals a refcount */\n        return _byref(value);\n    case -1:\n        return NULL;\n    default:\n        break;\n    }\n\n    if (PointerObject_Check(value) || ArrayObject_Check(value)) {\n        /* Array instances are also pointers when\n           the item types are the same.\n        */\n        StgDictObject *v = PyObject_stgdict(value);\n        assert(v); /* Cannot be NULL for pointer or array objects */\n        int ret = PyObject_IsSubclass(v->proto, typedict->proto);\n        if (ret < 0) {\n            return NULL;\n        }\n        if (ret) {\n            return Py_NewRef(value);\n        }\n    }\n    return CDataType_from_param(type, value);\n}\n\nstatic PyMethodDef PyCPointerType_methods[] = {\n    { \"from_address\", CDataType_from_address, METH_O, from_address_doc },\n    { \"from_buffer\", CDataType_from_buffer, METH_VARARGS, from_buffer_doc, },\n    { \"from_buffer_copy\", CDataType_from_buffer_copy, METH_VARARGS, from_buffer_copy_doc, },\n    { \"in_dll\", CDataType_in_dll, METH_VARARGS, in_dll_doc},\n    { \"from_param\", (PyCFunction)PyCPointerType_from_param, METH_O, from_param_doc},\n    { \"set_type\", (PyCFunction)PyCPointerType_set_type, METH_O },\n    { NULL, NULL },\n};\n\nPyTypeObject PyCPointerType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCPointerType\",                                   /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,             /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    PyDoc_STR(\"metatype for the Pointer Objects\"), /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    PyCPointerType_methods,                     /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCPointerType_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n  PyCArrayType_Type\n*/\n/*\n  PyCArrayType_new ensures that the new Array subclass created has a _length_\n  attribute, and a _type_ attribute.\n*/\n\nstatic int\nCharArray_set_raw(CDataObject *self, PyObject *value, void *Py_UNUSED(ignored))\n{\n    char *ptr;\n    Py_ssize_t size;\n    Py_buffer view;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"cannot delete attribute\");\n        return -1;\n    }\n    if (PyObject_GetBuffer(value, &view, PyBUF_SIMPLE) < 0)\n        return -1;\n    size = view.len;\n    ptr = view.buf;\n    if (size > self->b_size) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"byte string too long\");\n        goto fail;\n    }\n\n    memcpy(self->b_ptr, ptr, size);\n\n    PyBuffer_Release(&view);\n    return 0;\n fail:\n    PyBuffer_Release(&view);\n    return -1;\n}\n\nstatic PyObject *\nCharArray_get_raw(CDataObject *self, void *Py_UNUSED(ignored))\n{\n    return PyBytes_FromStringAndSize(self->b_ptr, self->b_size);\n}\n\nstatic PyObject *\nCharArray_get_value(CDataObject *self, void *Py_UNUSED(ignored))\n{\n    Py_ssize_t i;\n    char *ptr = self->b_ptr;\n    for (i = 0; i < self->b_size; ++i)\n        if (*ptr++ == '\\0')\n            break;\n    return PyBytes_FromStringAndSize(self->b_ptr, i);\n}\n\nstatic int\nCharArray_set_value(CDataObject *self, PyObject *value, void *Py_UNUSED(ignored))\n{\n    const char *ptr;\n    Py_ssize_t size;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"can't delete attribute\");\n        return -1;\n    }\n\n    if (!PyBytes_Check(value)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"bytes expected instead of %s instance\",\n                     Py_TYPE(value)->tp_name);\n        return -1;\n    } else\n        Py_INCREF(value);\n    size = PyBytes_GET_SIZE(value);\n    if (size > self->b_size) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"byte string too long\");\n        Py_DECREF(value);\n        return -1;\n    }\n\n    ptr = PyBytes_AS_STRING(value);\n    memcpy(self->b_ptr, ptr, size);\n    if (size < self->b_size)\n        self->b_ptr[size] = '\\0';\n    Py_DECREF(value);\n\n    return 0;\n}\n\nstatic PyGetSetDef CharArray_getsets[] = {\n    { \"raw\", (getter)CharArray_get_raw, (setter)CharArray_set_raw,\n      \"value\", NULL },\n    { \"value\", (getter)CharArray_get_value, (setter)CharArray_set_value,\n      \"string value\"},\n    { NULL, NULL }\n};\n\nstatic PyObject *\nWCharArray_get_value(CDataObject *self, void *Py_UNUSED(ignored))\n{\n    Py_ssize_t i;\n    wchar_t *ptr = (wchar_t *)self->b_ptr;\n    for (i = 0; i < self->b_size/(Py_ssize_t)sizeof(wchar_t); ++i)\n        if (*ptr++ == (wchar_t)0)\n            break;\n    return PyUnicode_FromWideChar((wchar_t *)self->b_ptr, i);\n}\n\nstatic int\nWCharArray_set_value(CDataObject *self, PyObject *value, void *Py_UNUSED(ignored))\n{\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"can't delete attribute\");\n        return -1;\n    }\n    if (!PyUnicode_Check(value)) {\n        PyErr_Format(PyExc_TypeError,\n                        \"unicode string expected instead of %s instance\",\n                        Py_TYPE(value)->tp_name);\n        return -1;\n    }\n\n    Py_ssize_t size = self->b_size / sizeof(wchar_t);\n    Py_ssize_t len = PyUnicode_AsWideChar(value, NULL, 0);\n    if (len < 0) {\n        return -1;\n    }\n    // PyUnicode_AsWideChar() returns number of wchars including trailing null byte,\n    // when it is called with NULL.\n    assert(len > 0);\n    if (len - 1 > size) {\n        PyErr_SetString(PyExc_ValueError, \"string too long\");\n        return -1;\n    }\n    if (PyUnicode_AsWideChar(value, (wchar_t *)self->b_ptr, size) < 0) {\n        return -1;\n    }\n    return 0;\n}\n\nstatic PyGetSetDef WCharArray_getsets[] = {\n    { \"value\", (getter)WCharArray_get_value, (setter)WCharArray_set_value,\n      \"string value\"},\n    { NULL, NULL }\n};\n\n/*\n  The next function is copied from Python's typeobject.c.\n\n  It is used to attach getsets to a type *after* it\n  has been created: Arrays of characters have additional getsets to treat them\n  as strings.\n */\n\nstatic int\nadd_getset(PyTypeObject *type, PyGetSetDef *gsp)\n{\n    PyObject *dict = type->tp_dict;\n    for (; gsp->name != NULL; gsp++) {\n        PyObject *descr;\n        descr = PyDescr_NewGetSet(type, gsp);\n        if (descr == NULL)\n            return -1;\n        if (PyDict_SetItemString(dict, gsp->name, descr) < 0) {\n            Py_DECREF(descr);\n            return -1;\n        }\n        Py_DECREF(descr);\n    }\n    return 0;\n}\n\nstatic PyCArgObject *\nPyCArrayType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *p = PyCArgObject_new();\n    if (p == NULL)\n        return NULL;\n    p->tag = 'P';\n    p->pffi_type = &ffi_type_pointer;\n    p->value.p = (char *)self->b_ptr;\n    p->obj = Py_NewRef(self);\n    return p;\n}\n\nstatic PyObject *\nPyCArrayType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    StgDictObject *itemdict;\n    PyObject *length_attr, *type_attr;\n    Py_ssize_t length;\n    Py_ssize_t itemsize, itemalign;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL)\n        return NULL;\n\n    /* Initialize these variables to NULL so that we can simplify error\n       handling by using Py_XDECREF.  */\n    stgdict = NULL;\n    type_attr = NULL;\n\n    if (_PyObject_LookupAttr((PyObject *)result, &_Py_ID(_length_), &length_attr) < 0) {\n        goto error;\n    }\n    if (!length_attr) {\n        PyErr_SetString(PyExc_AttributeError,\n                        \"class must define a '_length_' attribute\");\n        goto error;\n    }\n\n    if (!PyLong_Check(length_attr)) {\n        Py_DECREF(length_attr);\n        PyErr_SetString(PyExc_TypeError,\n                        \"The '_length_' attribute must be an integer\");\n        goto error;\n    }\n\n    if (_PyLong_Sign(length_attr) == -1) {\n        Py_DECREF(length_attr);\n        PyErr_SetString(PyExc_ValueError,\n                        \"The '_length_' attribute must not be negative\");\n        goto error;\n    }\n\n    length = PyLong_AsSsize_t(length_attr);\n    Py_DECREF(length_attr);\n    if (length == -1 && PyErr_Occurred()) {\n        if (PyErr_ExceptionMatches(PyExc_OverflowError)) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"The '_length_' attribute is too large\");\n        }\n        goto error;\n    }\n\n    if (_PyObject_LookupAttr((PyObject *)result, &_Py_ID(_type_), &type_attr) < 0) {\n        goto error;\n    }\n    if (!type_attr) {\n        PyErr_SetString(PyExc_AttributeError,\n                        \"class must define a '_type_' attribute\");\n        goto error;\n    }\n\n    stgdict = (StgDictObject *)_PyObject_CallNoArgs(\n        (PyObject *)&PyCStgDict_Type);\n    if (!stgdict)\n        goto error;\n\n    itemdict = PyType_stgdict(type_attr);\n    if (!itemdict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_type_ must have storage info\");\n        goto error;\n    }\n\n    assert(itemdict->format);\n    stgdict->format = _ctypes_alloc_format_string(NULL, itemdict->format);\n    if (stgdict->format == NULL)\n        goto error;\n    stgdict->ndim = itemdict->ndim + 1;\n    stgdict->shape = PyMem_Malloc(sizeof(Py_ssize_t) * stgdict->ndim);\n    if (stgdict->shape == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n    stgdict->shape[0] = length;\n    if (stgdict->ndim > 1) {\n        memmove(&stgdict->shape[1], itemdict->shape,\n            sizeof(Py_ssize_t) * (stgdict->ndim - 1));\n    }\n\n    itemsize = itemdict->size;\n    if (itemsize != 0 && length > PY_SSIZE_T_MAX / itemsize) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"array too large\");\n        goto error;\n    }\n\n    itemalign = itemdict->align;\n\n    if (itemdict->flags & (TYPEFLAG_ISPOINTER | TYPEFLAG_HASPOINTER))\n        stgdict->flags |= TYPEFLAG_HASPOINTER;\n\n    stgdict->size = itemsize * length;\n    stgdict->align = itemalign;\n    stgdict->length = length;\n    stgdict->proto = type_attr;\n    type_attr = NULL;\n\n    stgdict->paramfunc = &PyCArrayType_paramfunc;\n\n    /* Arrays are passed as pointers to function calls. */\n    stgdict->ffi_type_pointer = ffi_type_pointer;\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict))\n        goto error;\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);  /* steal the reference */\n    stgdict = NULL;\n\n    /* Special case for character arrays.\n       A permanent annoyance: char arrays are also strings!\n    */\n    if (itemdict->getfunc == _ctypes_get_fielddesc(\"c\")->getfunc) {\n        if (-1 == add_getset(result, CharArray_getsets))\n            goto error;\n    }\n    else if (itemdict->getfunc == _ctypes_get_fielddesc(\"u\")->getfunc) {\n        if (-1 == add_getset(result, WCharArray_getsets))\n            goto error;\n    }\n\n    return (PyObject *)result;\nerror:\n    Py_XDECREF((PyObject*)stgdict);\n    Py_XDECREF(type_attr);\n    Py_DECREF(result);\n    return NULL;\n}\n\nPyTypeObject PyCArrayType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCArrayType\",                     /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,                     /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    PyDoc_STR(\"metatype for the Array Objects\"), /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCArrayType_new,                                   /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n  PyCSimpleType_Type\n*/\n/*\n\nPyCSimpleType_new ensures that the new Simple_Type subclass created has a valid\n_type_ attribute.\n\n*/\n\nstatic const char SIMPLE_TYPE_CHARS[] = \"cbBhHiIlLdfuzZqQPXOv?g\";\n\nstatic PyObject *\nc_wchar_p_from_param(PyObject *type, PyObject *value)\n{\n    PyObject *as_parameter;\n    int res;\n    if (value == Py_None) {\n        Py_RETURN_NONE;\n    }\n    if (PyUnicode_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"Z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'Z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        return Py_NewRef(value);\n    }\n    if (ArrayObject_Check(value) || PointerObject_Check(value)) {\n        /* c_wchar array instance or pointer(c_wchar(...)) */\n        StgDictObject *dt = PyObject_stgdict(value);\n        StgDictObject *dict;\n        assert(dt); /* Cannot be NULL for pointer or array objects */\n        dict = dt && dt->proto ? PyType_stgdict(dt->proto) : NULL;\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"u\")->setfunc)) {\n            return Py_NewRef(value);\n        }\n    }\n    ctypes_state *st = GLOBAL_STATE();\n    if (PyCArg_CheckExact(st, value)) {\n        /* byref(c_char(...)) */\n        PyCArgObject *a = (PyCArgObject *)value;\n        StgDictObject *dict = PyObject_stgdict(a->obj);\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"u\")->setfunc)) {\n            return Py_NewRef(value);\n        }\n    }\n\n    if (_PyObject_LookupAttr(value, &_Py_ID(_as_parameter_), &as_parameter) < 0) {\n        return NULL;\n    }\n    if (as_parameter) {\n        value = c_wchar_p_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    /* XXX better message */\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyObject *\nc_char_p_from_param(PyObject *type, PyObject *value)\n{\n    PyObject *as_parameter;\n    int res;\n    if (value == Py_None) {\n        Py_RETURN_NONE;\n    }\n    if (PyBytes_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        return Py_NewRef(value);\n    }\n    if (ArrayObject_Check(value) || PointerObject_Check(value)) {\n        /* c_char array instance or pointer(c_char(...)) */\n        StgDictObject *dt = PyObject_stgdict(value);\n        StgDictObject *dict;\n        assert(dt); /* Cannot be NULL for pointer or array objects */\n        dict = dt && dt->proto ? PyType_stgdict(dt->proto) : NULL;\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"c\")->setfunc)) {\n            return Py_NewRef(value);\n        }\n    }\n    ctypes_state *st = GLOBAL_STATE();\n    if (PyCArg_CheckExact(st, value)) {\n        /* byref(c_char(...)) */\n        PyCArgObject *a = (PyCArgObject *)value;\n        StgDictObject *dict = PyObject_stgdict(a->obj);\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"c\")->setfunc)) {\n            return Py_NewRef(value);\n        }\n    }\n\n    if (_PyObject_LookupAttr(value, &_Py_ID(_as_parameter_), &as_parameter) < 0) {\n        return NULL;\n    }\n    if (as_parameter) {\n        value = c_char_p_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    /* XXX better message */\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyObject *\nc_void_p_from_param(PyObject *type, PyObject *value)\n{\n    StgDictObject *stgd;\n    PyObject *as_parameter;\n    int res;\n\n/* None */\n    if (value == Py_None) {\n        Py_RETURN_NONE;\n    }\n    /* Should probably allow buffer interface as well */\n/* int, long */\n    if (PyLong_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"P\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'P';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n    /* XXX struni: remove later */\n/* bytes */\n    if (PyBytes_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n/* unicode */\n    if (PyUnicode_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"Z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'Z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n/* c_void_p instance (or subclass) */\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        /* c_void_p instances */\n        return Py_NewRef(value);\n    }\n/* ctypes array or pointer instance */\n    if (ArrayObject_Check(value) || PointerObject_Check(value)) {\n        /* Any array or pointer is accepted */\n        return Py_NewRef(value);\n    }\n/* byref(...) */\n    ctypes_state *st = GLOBAL_STATE();\n    if (PyCArg_CheckExact(st, value)) {\n        /* byref(c_xxx()) */\n        PyCArgObject *a = (PyCArgObject *)value;\n        if (a->tag == 'P') {\n            return Py_NewRef(value);\n        }\n    }\n/* function pointer */\n    if (PyCFuncPtrObject_Check(value)) {\n        PyCArgObject *parg;\n        PyCFuncPtrObject *func;\n        func = (PyCFuncPtrObject *)value;\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'P';\n        Py_INCREF(value);\n        parg->value.p = *(void **)func->b_ptr;\n        parg->obj = value;\n        return (PyObject *)parg;\n    }\n/* c_char_p, c_wchar_p */\n    stgd = PyObject_stgdict(value);\n    if (stgd && CDataObject_Check(value) && stgd->proto && PyUnicode_Check(stgd->proto)) {\n        PyCArgObject *parg;\n\n        switch (PyUnicode_AsUTF8(stgd->proto)[0]) {\n        case 'z': /* c_char_p */\n        case 'Z': /* c_wchar_p */\n            parg = PyCArgObject_new();\n            if (parg == NULL)\n                return NULL;\n            parg->pffi_type = &ffi_type_pointer;\n            parg->tag = 'Z';\n            parg->obj = Py_NewRef(value);\n            /* Remember: b_ptr points to where the pointer is stored! */\n            parg->value.p = *(void **)(((CDataObject *)value)->b_ptr);\n            return (PyObject *)parg;\n        }\n    }\n\n    if (_PyObject_LookupAttr(value, &_Py_ID(_as_parameter_), &as_parameter) < 0) {\n        return NULL;\n    }\n    if (as_parameter) {\n        value = c_void_p_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    /* XXX better message */\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyMethodDef c_void_p_method = { \"from_param\", c_void_p_from_param, METH_O };\nstatic PyMethodDef c_char_p_method = { \"from_param\", c_char_p_from_param, METH_O };\nstatic PyMethodDef c_wchar_p_method = { \"from_param\", c_wchar_p_from_param, METH_O };\n\nstatic PyObject *CreateSwappedType(PyTypeObject *type, PyObject *args, PyObject *kwds,\n                                   PyObject *proto, struct fielddesc *fmt)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    PyObject *name = PyTuple_GET_ITEM(args, 0);\n    PyObject *newname;\n    PyObject *swapped_args;\n    static PyObject *suffix;\n    Py_ssize_t i;\n\n    swapped_args = PyTuple_New(PyTuple_GET_SIZE(args));\n    if (!swapped_args)\n        return NULL;\n\n    if (suffix == NULL)\n#ifdef WORDS_BIGENDIAN\n        suffix = PyUnicode_InternFromString(\"_le\");\n#else\n        suffix = PyUnicode_InternFromString(\"_be\");\n#endif\n    if (suffix == NULL) {\n        Py_DECREF(swapped_args);\n        return NULL;\n    }\n\n    newname = PyUnicode_Concat(name, suffix);\n    if (newname == NULL) {\n        Py_DECREF(swapped_args);\n        return NULL;\n    }\n\n    PyTuple_SET_ITEM(swapped_args, 0, newname);\n    for (i=1; i<PyTuple_GET_SIZE(args); ++i) {\n        PyObject *v = PyTuple_GET_ITEM(args, i);\n        Py_INCREF(v);\n        PyTuple_SET_ITEM(swapped_args, i, v);\n    }\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, swapped_args, kwds);\n    Py_DECREF(swapped_args);\n    if (result == NULL)\n        return NULL;\n\n    stgdict = (StgDictObject *)_PyObject_CallNoArgs(\n        (PyObject *)&PyCStgDict_Type);\n    if (!stgdict) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    stgdict->ffi_type_pointer = *fmt->pffi_type;\n    stgdict->align = fmt->pffi_type->alignment;\n    stgdict->length = 0;\n    stgdict->size = fmt->pffi_type->size;\n    stgdict->setfunc = fmt->setfunc_swapped;\n    stgdict->getfunc = fmt->getfunc_swapped;\n\n    stgdict->proto = Py_NewRef(proto);\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);\n\n    return (PyObject *)result;\n}\n\nstatic PyCArgObject *\nPyCSimpleType_paramfunc(CDataObject *self)\n{\n    StgDictObject *dict;\n    const char *fmt;\n    PyCArgObject *parg;\n    struct fielddesc *fd;\n\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for CDataObject instances */\n    fmt = PyUnicode_AsUTF8(dict->proto);\n    assert(fmt);\n\n    fd = _ctypes_get_fielddesc(fmt);\n    assert(fd);\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = fmt[0];\n    parg->pffi_type = fd->pffi_type;\n    parg->obj = Py_NewRef(self);\n    memcpy(&parg->value, self->b_ptr, self->b_size);\n    return parg;\n}\n\nstatic PyObject *\nPyCSimpleType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    PyObject *proto;\n    const char *proto_str;\n    Py_ssize_t proto_len;\n    PyMethodDef *ml;\n    struct fielddesc *fmt;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL)\n        return NULL;\n\n    if (_PyObject_LookupAttr((PyObject *)result, &_Py_ID(_type_), &proto) < 0) {\n        return NULL;\n    }\n    if (!proto) {\n        PyErr_SetString(PyExc_AttributeError,\n                        \"class must define a '_type_' attribute\");\n  error:\n        Py_XDECREF(proto);\n        Py_DECREF(result);\n        return NULL;\n    }\n    if (PyUnicode_Check(proto)) {\n        proto_str = PyUnicode_AsUTF8AndSize(proto, &proto_len);\n        if (!proto_str)\n            goto error;\n    } else {\n        PyErr_SetString(PyExc_TypeError,\n            \"class must define a '_type_' string attribute\");\n        goto error;\n    }\n    if (proto_len != 1) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"class must define a '_type_' attribute \"\n                        \"which must be a string of length 1\");\n        goto error;\n    }\n    if (!strchr(SIMPLE_TYPE_CHARS, *proto_str)) {\n        PyErr_Format(PyExc_AttributeError,\n                     \"class must define a '_type_' attribute which must be\\n\"\n                     \"a single character string containing one of '%s'.\",\n                     SIMPLE_TYPE_CHARS);\n        goto error;\n    }\n    fmt = _ctypes_get_fielddesc(proto_str);\n    if (fmt == NULL) {\n        PyErr_Format(PyExc_ValueError,\n                     \"_type_ '%s' not supported\", proto_str);\n        goto error;\n    }\n\n    stgdict = (StgDictObject *)_PyObject_CallNoArgs(\n        (PyObject *)&PyCStgDict_Type);\n    if (!stgdict)\n        goto error;\n\n    stgdict->ffi_type_pointer = *fmt->pffi_type;\n    stgdict->align = fmt->pffi_type->alignment;\n    stgdict->length = 0;\n    stgdict->size = fmt->pffi_type->size;\n    stgdict->setfunc = fmt->setfunc;\n    stgdict->getfunc = fmt->getfunc;\n#ifdef WORDS_BIGENDIAN\n    stgdict->format = _ctypes_alloc_format_string_for_type(proto_str[0], 1);\n#else\n    stgdict->format = _ctypes_alloc_format_string_for_type(proto_str[0], 0);\n#endif\n    if (stgdict->format == NULL) {\n        Py_DECREF(result);\n        Py_DECREF(proto);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    stgdict->paramfunc = PyCSimpleType_paramfunc;\n/*\n    if (result->tp_base != &Simple_Type) {\n        stgdict->setfunc = NULL;\n        stgdict->getfunc = NULL;\n    }\n*/\n\n    /* This consumes the refcount on proto which we have */\n    stgdict->proto = proto;\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);\n\n    /* Install from_param class methods in ctypes base classes.\n       Overrides the PyCSimpleType_from_param generic method.\n     */\n    if (result->tp_base == &Simple_Type) {\n        switch (*proto_str) {\n        case 'z': /* c_char_p */\n            ml = &c_char_p_method;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        case 'Z': /* c_wchar_p */\n            ml = &c_wchar_p_method;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        case 'P': /* c_void_p */\n            ml = &c_void_p_method;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        case 's':\n        case 'X':\n        case 'O':\n            ml = NULL;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        default:\n            ml = NULL;\n            break;\n        }\n\n        if (ml) {\n            PyObject *meth;\n            int x;\n            meth = PyDescr_NewClassMethod(result, ml);\n            if (!meth) {\n                Py_DECREF(result);\n                return NULL;\n            }\n            x = PyDict_SetItemString(result->tp_dict,\n                                     ml->ml_name,\n                                     meth);\n            Py_DECREF(meth);\n            if (x == -1) {\n                Py_DECREF(result);\n                return NULL;\n            }\n        }\n    }\n\n    if (type == &PyCSimpleType_Type && fmt->setfunc_swapped && fmt->getfunc_swapped) {\n        PyObject *swapped = CreateSwappedType(type, args, kwds,\n                                              proto, fmt);\n        StgDictObject *sw_dict;\n        if (swapped == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        sw_dict = PyType_stgdict(swapped);\n#ifdef WORDS_BIGENDIAN\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_le__\", swapped);\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_be__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_be__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_le__\", swapped);\n        /* We are creating the type for the OTHER endian */\n        sw_dict->format = _ctypes_alloc_format_string(\"<\", stgdict->format+1);\n#else\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_be__\", swapped);\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_le__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_le__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_be__\", swapped);\n        /* We are creating the type for the OTHER endian */\n        sw_dict->format = _ctypes_alloc_format_string(\">\", stgdict->format+1);\n#endif\n        Py_DECREF(swapped);\n        if (PyErr_Occurred()) {\n            Py_DECREF(result);\n            return NULL;\n        }\n    };\n\n    return (PyObject *)result;\n}\n\n/*\n * This is a *class method*.\n * Convert a parameter into something that ConvParam can handle.\n */\nstatic PyObject *\nPyCSimpleType_from_param(PyObject *type, PyObject *value)\n{\n    StgDictObject *dict;\n    const char *fmt;\n    PyCArgObject *parg;\n    struct fielddesc *fd;\n    PyObject *as_parameter;\n    int res;\n\n    /* If the value is already an instance of the requested type,\n       we can use it as is */\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        return Py_NewRef(value);\n    }\n\n    dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n\n    /* I think we can rely on this being a one-character string */\n    fmt = PyUnicode_AsUTF8(dict->proto);\n    assert(fmt);\n\n    fd = _ctypes_get_fielddesc(fmt);\n    assert(fd);\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = fmt[0];\n    parg->pffi_type = fd->pffi_type;\n    parg->obj = fd->setfunc(&parg->value, value, 0);\n    if (parg->obj)\n        return (PyObject *)parg;\n    PyObject *exc = PyErr_GetRaisedException();\n    Py_DECREF(parg);\n\n    if (_PyObject_LookupAttr(value, &_Py_ID(_as_parameter_), &as_parameter) < 0) {\n        Py_XDECREF(exc);\n        return NULL;\n    }\n    if (as_parameter) {\n        if (_Py_EnterRecursiveCall(\"while processing _as_parameter_\")) {\n            Py_DECREF(as_parameter);\n            Py_XDECREF(exc);\n            return NULL;\n        }\n        value = PyCSimpleType_from_param(type, as_parameter);\n        _Py_LeaveRecursiveCall();\n        Py_DECREF(as_parameter);\n        Py_XDECREF(exc);\n        return value;\n    }\n    if (exc) {\n        PyErr_SetRaisedException(exc);\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError, \"wrong type\");\n    }\n    return NULL;\n}\n\nstatic PyMethodDef PyCSimpleType_methods[] = {\n    { \"from_param\", PyCSimpleType_from_param, METH_O, from_param_doc },\n    { \"from_address\", CDataType_from_address, METH_O, from_address_doc },\n    { \"from_buffer\", CDataType_from_buffer, METH_VARARGS, from_buffer_doc, },\n    { \"from_buffer_copy\", CDataType_from_buffer_copy, METH_VARARGS, from_buffer_copy_doc, },\n    { \"in_dll\", CDataType_in_dll, METH_VARARGS, in_dll_doc},\n    { NULL, NULL },\n};\n\nPyTypeObject PyCSimpleType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCSimpleType\",                                    /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,             /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    PyDoc_STR(\"metatype for the PyCSimpleType Objects\"), /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    PyCSimpleType_methods,                      /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCSimpleType_new,                                  /* tp_new */\n    0,                                          /* tp_free */\n};\n\n/******************************************************************/\n/*\n  PyCFuncPtrType_Type\n */\n\nstatic PyObject *\nconverters_from_argtypes(PyObject *ob)\n{\n    PyObject *converters;\n    Py_ssize_t i;\n\n    ob = PySequence_Tuple(ob); /* new reference */\n    if (!ob) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_argtypes_ must be a sequence of types\");\n        return NULL;\n    }\n\n    Py_ssize_t nArgs = PyTuple_GET_SIZE(ob);\n    if (nArgs > CTYPES_MAX_ARGCOUNT) {\n        Py_DECREF(ob);\n        PyErr_Format(PyExc_ArgError,\n                     \"_argtypes_ has too many arguments (%zi), maximum is %i\",\n                     nArgs, CTYPES_MAX_ARGCOUNT);\n        return NULL;\n    }\n\n    converters = PyTuple_New(nArgs);\n    if (!converters) {\n        Py_DECREF(ob);\n        return NULL;\n    }\n\n    /* I have to check if this is correct. Using c_char, which has a size\n       of 1, will be assumed to be pushed as only one byte!\n       Aren't these promoted to integers by the C compiler and pushed as 4 bytes?\n    */\n\n    for (i = 0; i < nArgs; ++i) {\n        PyObject *cnv;\n        PyObject *tp = PyTuple_GET_ITEM(ob, i);\n/*\n *      The following checks, relating to bpo-16575 and bpo-16576, have been\n *      disabled. The reason is that, although there is a definite problem with\n *      how libffi handles unions (https://github.com/libffi/libffi/issues/33),\n *      there are numerous libraries which pass structures containing unions\n *      by values - especially on Windows but examples also exist on Linux\n *      (https://bugs.python.org/msg359834).\n *\n *      It may not be possible to get proper support for unions and bitfields\n *      until support is forthcoming in libffi, but for now, adding the checks\n *      has caused problems in otherwise-working software, which suggests it\n *      is better to disable the checks.\n *\n *      Although specific examples reported relate specifically to unions and\n *      not bitfields, the bitfields check is also being disabled as a\n *      precaution.\n\n        StgDictObject *stgdict = PyType_stgdict(tp);\n\n        if (stgdict != NULL) {\n            if (stgdict->flags & TYPEFLAG_HASUNION) {\n                Py_DECREF(converters);\n                Py_DECREF(ob);\n                if (!PyErr_Occurred()) {\n                    PyErr_Format(PyExc_TypeError,\n                                 \"item %zd in _argtypes_ passes a union by \"\n                                 \"value, which is unsupported.\",\n                                 i + 1);\n                }\n                return NULL;\n            }\n            if (stgdict->flags & TYPEFLAG_HASBITFIELD) {\n                Py_DECREF(converters);\n                Py_DECREF(ob);\n                if (!PyErr_Occurred()) {\n                    PyErr_Format(PyExc_TypeError,\n                                 \"item %zd in _argtypes_ passes a struct/\"\n                                 \"union with a bitfield by value, which is \"\n                                 \"unsupported.\",\n                                 i + 1);\n                }\n                return NULL;\n            }\n        }\n */\n\n        if (_PyObject_LookupAttr(tp, &_Py_ID(from_param), &cnv) <= 0) {\n            Py_DECREF(converters);\n            Py_DECREF(ob);\n            if (!PyErr_Occurred()) {\n                PyErr_Format(PyExc_TypeError,\n                             \"item %zd in _argtypes_ has no from_param method\",\n                             i+1);\n            }\n            return NULL;\n        }\n        PyTuple_SET_ITEM(converters, i, cnv);\n    }\n    Py_DECREF(ob);\n    return converters;\n}\n\nstatic int\nmake_funcptrtype_dict(StgDictObject *stgdict)\n{\n    PyObject *ob;\n    PyObject *converters = NULL;\n\n    stgdict->align = _ctypes_get_fielddesc(\"P\")->pffi_type->alignment;\n    stgdict->length = 1;\n    stgdict->size = sizeof(void *);\n    stgdict->setfunc = NULL;\n    stgdict->getfunc = NULL;\n    stgdict->ffi_type_pointer = ffi_type_pointer;\n\n    ob = PyDict_GetItemWithError((PyObject *)stgdict, &_Py_ID(_flags_));\n    if (!ob || !PyLong_Check(ob)) {\n        if (!PyErr_Occurred()) {\n            PyErr_SetString(PyExc_TypeError,\n                \"class must define _flags_ which must be an integer\");\n        }\n        return -1;\n    }\n    stgdict->flags = PyLong_AsUnsignedLongMask(ob) | TYPEFLAG_ISPOINTER;\n\n    /* _argtypes_ is optional... */\n    ob = PyDict_GetItemWithError((PyObject *)stgdict, &_Py_ID(_argtypes_));\n    if (ob) {\n        converters = converters_from_argtypes(ob);\n        if (!converters)\n            return -1;\n        stgdict->argtypes = Py_NewRef(ob);\n        stgdict->converters = converters;\n    }\n    else if (PyErr_Occurred()) {\n        return -1;\n    }\n\n    ob = PyDict_GetItemWithError((PyObject *)stgdict, &_Py_ID(_restype_));\n    if (ob) {\n        if (ob != Py_None && !PyType_stgdict(ob) && !PyCallable_Check(ob)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"_restype_ must be a type, a callable, or None\");\n            return -1;\n        }\n        stgdict->restype = Py_NewRef(ob);\n        if (_PyObject_LookupAttr(ob, &_Py_ID(_check_retval_),\n                                   &stgdict->checker) < 0)\n        {\n            return -1;\n        }\n    }\n    else if (PyErr_Occurred()) {\n        return -1;\n    }\n/* XXX later, maybe.\n    ob = _PyDict_GetItemIdWithError((PyObject *)stgdict, &PyId__errcheck_);\n    if (ob) {\n        if (!PyCallable_Check(ob)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"_errcheck_ must be callable\");\n            return -1;\n        }\n        stgdict->errcheck = Py_NewRef(ob);\n    }\n    else if (PyErr_Occurred()) {\n        return -1;\n    }\n*/\n    return 0;\n}\n\nstatic PyCArgObject *\nPyCFuncPtrType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *parg;\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    parg->obj = Py_NewRef(self);\n    parg->value.p = *(void **)self->b_ptr;\n    return parg;\n}\n\nstatic PyObject *\nPyCFuncPtrType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n\n    stgdict = (StgDictObject *)_PyObject_CallNoArgs(\n        (PyObject *)&PyCStgDict_Type);\n    if (!stgdict)\n        return NULL;\n\n    stgdict->paramfunc = PyCFuncPtrType_paramfunc;\n    /* We do NOT expose the function signature in the format string.  It\n       is impossible, generally, because the only requirement for the\n       argtypes items is that they have a .from_param method - we do not\n       know the types of the arguments (although, in practice, most\n       argtypes would be a ctypes type).\n    */\n    stgdict->format = _ctypes_alloc_format_string(NULL, \"X{}\");\n    if (stgdict->format == NULL) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    stgdict->flags |= TYPEFLAG_ISPOINTER;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    /* replace the class dict by our updated storage dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);\n\n    if (-1 == make_funcptrtype_dict(stgdict)) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    return (PyObject *)result;\n}\n\nPyTypeObject PyCFuncPtrType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCFuncPtrType\",                           /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,                     /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    PyDoc_STR(\"metatype for C function pointers\"), /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCFuncPtrType_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/*****************************************************************\n * Code to keep needed objects alive\n */\n\nstatic CDataObject *\nPyCData_GetContainer(CDataObject *self)\n{\n    while (self->b_base)\n        self = self->b_base;\n    if (self->b_objects == NULL) {\n        if (self->b_length) {\n            self->b_objects = PyDict_New();\n            if (self->b_objects == NULL)\n                return NULL;\n        } else {\n            self->b_objects = Py_NewRef(Py_None);\n        }\n    }\n    return self;\n}\n\nstatic PyObject *\nGetKeepedObjects(CDataObject *target)\n{\n    CDataObject *container;\n    container = PyCData_GetContainer(target);\n    if (container == NULL)\n        return NULL;\n    return container->b_objects;\n}\n\nstatic PyObject *\nunique_key(CDataObject *target, Py_ssize_t index)\n{\n    char string[256];\n    char *cp = string;\n    size_t bytes_left;\n\n    Py_BUILD_ASSERT(sizeof(string) - 1 > sizeof(Py_ssize_t) * 2);\n    cp += sprintf(cp, \"%x\", Py_SAFE_DOWNCAST(index, Py_ssize_t, int));\n    while (target->b_base) {\n        bytes_left = sizeof(string) - (cp - string) - 1;\n        /* Hex format needs 2 characters per byte */\n        if (bytes_left < sizeof(Py_ssize_t) * 2) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"ctypes object structure too deep\");\n            return NULL;\n        }\n        cp += sprintf(cp, \":%x\", Py_SAFE_DOWNCAST(target->b_index, Py_ssize_t, int));\n        target = target->b_base;\n    }\n    return PyUnicode_FromStringAndSize(string, cp-string);\n}\n\n/*\n * Keep a reference to 'keep' in the 'target', at index 'index'.\n *\n * If 'keep' is None, do nothing.\n *\n * Otherwise create a dictionary (if it does not yet exist) id the root\n * objects 'b_objects' item, which will store the 'keep' object under a unique\n * key.\n *\n * The unique_key helper travels the target's b_base pointer down to the root,\n * building a string containing hex-formatted indexes found during traversal,\n * separated by colons.\n *\n * The index tuple is used as a key into the root object's b_objects dict.\n *\n * Note: This function steals a refcount of the third argument, even if it\n * fails!\n */\nstatic int\nKeepRef(CDataObject *target, Py_ssize_t index, PyObject *keep)\n{\n    int result;\n    CDataObject *ob;\n    PyObject *key;\n\n/* Optimization: no need to store None */\n    if (keep == Py_None) {\n        Py_DECREF(Py_None);\n        return 0;\n    }\n    ob = PyCData_GetContainer(target);\n    if (ob == NULL) {\n        Py_DECREF(keep);\n        return -1;\n    }\n    if (ob->b_objects == NULL || !PyDict_CheckExact(ob->b_objects)) {\n        Py_XSETREF(ob->b_objects, keep); /* refcount consumed */\n        return 0;\n    }\n    key = unique_key(target, index);\n    if (key == NULL) {\n        Py_DECREF(keep);\n        return -1;\n    }\n    result = PyDict_SetItem(ob->b_objects, key, keep);\n    Py_DECREF(key);\n    Py_DECREF(keep);\n    return result;\n}\n\n/******************************************************************/\n/*\n  PyCData_Type\n */\nstatic int\nPyCData_traverse(CDataObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->b_objects);\n    Py_VISIT((PyObject *)self->b_base);\n    return 0;\n}\n\nstatic int\nPyCData_clear(CDataObject *self)\n{\n    Py_CLEAR(self->b_objects);\n    if ((self->b_needsfree)\n        && _CDataObject_HasExternalBuffer(self))\n        PyMem_Free(self->b_ptr);\n    self->b_ptr = NULL;\n    Py_CLEAR(self->b_base);\n    return 0;\n}\n\nstatic void\nPyCData_dealloc(PyObject *self)\n{\n    PyCData_clear((CDataObject *)self);\n    Py_TYPE(self)->tp_free(self);\n}\n\nstatic PyMemberDef PyCData_members[] = {\n    { \"_b_base_\", T_OBJECT,\n      offsetof(CDataObject, b_base), READONLY,\n      \"the base object\" },\n    { \"_b_needsfree_\", T_INT,\n      offsetof(CDataObject, b_needsfree), READONLY,\n      \"whether the object owns the memory or not\" },\n    { \"_objects\", T_OBJECT,\n      offsetof(CDataObject, b_objects), READONLY,\n      \"internal objects tree (NEVER CHANGE THIS OBJECT!)\"},\n    { NULL },\n};\n\n/* Find the innermost type of an array type, returning a borrowed reference */\nstatic PyObject *\nPyCData_item_type(PyObject *type)\n{\n    if (PyCArrayTypeObject_Check(type)) {\n        StgDictObject *stg_dict;\n        PyObject *elem_type;\n\n        /* asserts used here as these are all guaranteed by construction */\n        stg_dict = PyType_stgdict(type);\n        assert(stg_dict);\n        elem_type = stg_dict->proto;\n        assert(elem_type);\n        return PyCData_item_type(elem_type);\n    }\n    else {\n        return type;\n    }\n}\n\nstatic int\nPyCData_NewGetBuffer(PyObject *myself, Py_buffer *view, int flags)\n{\n    CDataObject *self = (CDataObject *)myself;\n    StgDictObject *dict = PyObject_stgdict(myself);\n    PyObject *item_type = PyCData_item_type((PyObject*)Py_TYPE(myself));\n    StgDictObject *item_dict = PyType_stgdict(item_type);\n\n    if (view == NULL) return 0;\n\n    view->buf = self->b_ptr;\n    view->obj = Py_NewRef(myself);\n    view->len = self->b_size;\n    view->readonly = 0;\n    /* use default format character if not set */\n    view->format = dict->format ? dict->format : \"B\";\n    view->ndim = dict->ndim;\n    view->shape = dict->shape;\n    view->itemsize = item_dict->size;\n    view->strides = NULL;\n    view->suboffsets = NULL;\n    view->internal = NULL;\n    return 0;\n}\n\nstatic PyBufferProcs PyCData_as_buffer = {\n    PyCData_NewGetBuffer,\n    NULL,\n};\n\n/*\n * CData objects are mutable, so they cannot be hashable!\n */\nstatic Py_hash_t\nPyCData_nohash(PyObject *self)\n{\n    PyErr_SetString(PyExc_TypeError, \"unhashable type\");\n    return -1;\n}\n\nstatic PyObject *\nPyCData_reduce(PyObject *myself, PyObject *args)\n{\n    CDataObject *self = (CDataObject *)myself;\n\n    if (PyObject_stgdict(myself)->flags & (TYPEFLAG_ISPOINTER|TYPEFLAG_HASPOINTER)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"ctypes objects containing pointers cannot be pickled\");\n        return NULL;\n    }\n    PyObject *dict = PyObject_GetAttrString(myself, \"__dict__\");\n    if (dict == NULL) {\n        return NULL;\n    }\n    return Py_BuildValue(\"O(O(NN))\", _unpickle, Py_TYPE(myself), dict,\n                         PyBytes_FromStringAndSize(self->b_ptr, self->b_size));\n}\n\nstatic PyObject *\nPyCData_setstate(PyObject *myself, PyObject *args)\n{\n    void *data;\n    Py_ssize_t len;\n    int res;\n    PyObject *dict, *mydict;\n    CDataObject *self = (CDataObject *)myself;\n    if (!PyArg_ParseTuple(args, \"O!s#\",\n                          &PyDict_Type, &dict, &data, &len))\n    {\n        return NULL;\n    }\n    if (len > self->b_size)\n        len = self->b_size;\n    memmove(self->b_ptr, data, len);\n    mydict = PyObject_GetAttrString(myself, \"__dict__\");\n    if (mydict == NULL) {\n        return NULL;\n    }\n    if (!PyDict_Check(mydict)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"%.200s.__dict__ must be a dictionary, not %.200s\",\n                     Py_TYPE(myself)->tp_name, Py_TYPE(mydict)->tp_name);\n        Py_DECREF(mydict);\n        return NULL;\n    }\n    res = PyDict_Update(mydict, dict);\n    Py_DECREF(mydict);\n    if (res == -1)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n/*\n * default __ctypes_from_outparam__ method returns self.\n */\nstatic PyObject *\nPyCData_from_outparam(PyObject *self, PyObject *args)\n{\n    return Py_NewRef(self);\n}\n\nstatic PyMethodDef PyCData_methods[] = {\n    { \"__ctypes_from_outparam__\", PyCData_from_outparam, METH_NOARGS, },\n    { \"__reduce__\", PyCData_reduce, METH_NOARGS, },\n    { \"__setstate__\", PyCData_setstate, METH_VARARGS, },\n    { NULL, NULL },\n};\n\nPyTypeObject PyCData_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes._CData\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    PyCData_dealloc,                                    /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    PyCData_nohash,                             /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    PyDoc_STR(\"XXX to be provided\"),            /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    PyCData_methods,                                    /* tp_methods */\n    PyCData_members,                                    /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    0,                                          /* tp_free */\n};\n\nstatic int PyCData_MallocBuffer(CDataObject *obj, StgDictObject *dict)\n{\n    if ((size_t)dict->size <= sizeof(obj->b_value)) {\n        /* No need to call malloc, can use the default buffer */\n        obj->b_ptr = (char *)&obj->b_value;\n        /* The b_needsfree flag does not mean that we actually did\n           call PyMem_Malloc to allocate the memory block; instead it\n           means we are the *owner* of the memory and are responsible\n           for freeing resources associated with the memory.  This is\n           also the reason that b_needsfree is exposed to Python.\n         */\n        obj->b_needsfree = 1;\n    } else {\n        /* In python 2.4, and ctypes 0.9.6, the malloc call took about\n           33% of the creation time for c_int().\n        */\n        obj->b_ptr = (char *)PyMem_Malloc(dict->size);\n        if (obj->b_ptr == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        obj->b_needsfree = 1;\n        memset(obj->b_ptr, 0, dict->size);\n    }\n    obj->b_size = dict->size;\n    return 0;\n}\n\nPyObject *\nPyCData_FromBaseObj(PyObject *type, PyObject *base, Py_ssize_t index, char *adr)\n{\n    CDataObject *cmem;\n    StgDictObject *dict;\n\n    assert(PyType_Check(type));\n    dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n    dict->flags |= DICTFLAG_FINAL;\n    cmem = (CDataObject *)((PyTypeObject *)type)->tp_alloc((PyTypeObject *)type, 0);\n    if (cmem == NULL)\n        return NULL;\n    assert(CDataObject_Check(cmem));\n\n    cmem->b_length = dict->length;\n    cmem->b_size = dict->size;\n    if (base) { /* use base's buffer */\n        assert(CDataObject_Check(base));\n        cmem->b_ptr = adr;\n        cmem->b_needsfree = 0;\n        cmem->b_base = (CDataObject *)Py_NewRef(base);\n        cmem->b_index = index;\n    } else { /* copy contents of adr */\n        if (-1 == PyCData_MallocBuffer(cmem, dict)) {\n            Py_DECREF(cmem);\n            return NULL;\n        }\n        memcpy(cmem->b_ptr, adr, dict->size);\n        cmem->b_index = index;\n    }\n    return (PyObject *)cmem;\n}\n\n/*\n Box a memory block into a CData instance.\n*/\nPyObject *\nPyCData_AtAddress(PyObject *type, void *buf)\n{\n    CDataObject *pd;\n    StgDictObject *dict;\n\n    if (PySys_Audit(\"ctypes.cdata\", \"n\", (Py_ssize_t)buf) < 0) {\n        return NULL;\n    }\n\n    assert(PyType_Check(type));\n    dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n    dict->flags |= DICTFLAG_FINAL;\n\n    pd = (CDataObject *)((PyTypeObject *)type)->tp_alloc((PyTypeObject *)type, 0);\n    if (!pd)\n        return NULL;\n    assert(CDataObject_Check(pd));\n    pd->b_ptr = (char *)buf;\n    pd->b_length = dict->length;\n    pd->b_size = dict->size;\n    return (PyObject *)pd;\n}\n\n/*\n  This function returns TRUE for c_int, c_void_p, and these kind of\n  classes.  FALSE otherwise FALSE also for subclasses of c_int and\n  such.\n*/\nint _ctypes_simple_instance(PyObject *obj)\n{\n    PyTypeObject *type = (PyTypeObject *)obj;\n\n    if (PyCSimpleTypeObject_Check(type))\n        return type->tp_base != &Simple_Type;\n    return 0;\n}\n\nPyObject *\nPyCData_get(PyObject *type, GETFUNC getfunc, PyObject *src,\n          Py_ssize_t index, Py_ssize_t size, char *adr)\n{\n    StgDictObject *dict;\n    if (getfunc)\n        return getfunc(adr, size);\n    assert(type);\n    dict = PyType_stgdict(type);\n    if (dict && dict->getfunc && !_ctypes_simple_instance(type))\n        return dict->getfunc(adr, size);\n    return PyCData_FromBaseObj(type, src, index, adr);\n}\n\n/*\n  Helper function for PyCData_set below.\n*/\nstatic PyObject *\n_PyCData_set(CDataObject *dst, PyObject *type, SETFUNC setfunc, PyObject *value,\n           Py_ssize_t size, char *ptr)\n{\n    CDataObject *src;\n    int err;\n\n    if (setfunc)\n        return setfunc(ptr, value, size);\n\n    if (!CDataObject_Check(value)) {\n        StgDictObject *dict = PyType_stgdict(type);\n        if (dict && dict->setfunc)\n            return dict->setfunc(ptr, value, size);\n        /*\n           If value is a tuple, we try to call the type with the tuple\n           and use the result!\n        */\n        assert(PyType_Check(type));\n        if (PyTuple_Check(value)) {\n            PyObject *ob;\n            PyObject *result;\n            ob = PyObject_CallObject(type, value);\n            if (ob == NULL) {\n                _ctypes_extend_error(PyExc_RuntimeError, \"(%s) \",\n                                  ((PyTypeObject *)type)->tp_name);\n                return NULL;\n            }\n            result = _PyCData_set(dst, type, setfunc, ob,\n                                size, ptr);\n            Py_DECREF(ob);\n            return result;\n        } else if (value == Py_None && PyCPointerTypeObject_Check(type)) {\n            *(void **)ptr = NULL;\n            Py_RETURN_NONE;\n        } else {\n            PyErr_Format(PyExc_TypeError,\n                         \"expected %s instance, got %s\",\n                         ((PyTypeObject *)type)->tp_name,\n                         Py_TYPE(value)->tp_name);\n            return NULL;\n        }\n    }\n    src = (CDataObject *)value;\n\n    err = PyObject_IsInstance(value, type);\n    if (err == -1)\n        return NULL;\n    if (err) {\n        memcpy(ptr,\n               src->b_ptr,\n               size);\n\n        if (PyCPointerTypeObject_Check(type)) {\n            /* XXX */\n        }\n\n        value = GetKeepedObjects(src);\n        if (value == NULL)\n            return NULL;\n\n        return Py_NewRef(value);\n    }\n\n    if (PyCPointerTypeObject_Check(type)\n        && ArrayObject_Check(value)) {\n        StgDictObject *p1, *p2;\n        PyObject *keep;\n        p1 = PyObject_stgdict(value);\n        assert(p1); /* Cannot be NULL for array instances */\n        p2 = PyType_stgdict(type);\n        assert(p2); /* Cannot be NULL for pointer types */\n\n        if (p1->proto != p2->proto) {\n            PyErr_Format(PyExc_TypeError,\n                         \"incompatible types, %s instance instead of %s instance\",\n                         Py_TYPE(value)->tp_name,\n                         ((PyTypeObject *)type)->tp_name);\n            return NULL;\n        }\n        *(void **)ptr = src->b_ptr;\n\n        keep = GetKeepedObjects(src);\n        if (keep == NULL)\n            return NULL;\n\n        /*\n          We are assigning an array object to a field which represents\n          a pointer. This has the same effect as converting an array\n          into a pointer. So, again, we have to keep the whole object\n          pointed to (which is the array in this case) alive, and not\n          only it's object list.  So we create a tuple, containing\n          b_objects list PLUS the array itself, and return that!\n        */\n        return PyTuple_Pack(2, keep, value);\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"incompatible types, %s instance instead of %s instance\",\n                 Py_TYPE(value)->tp_name,\n                 ((PyTypeObject *)type)->tp_name);\n    return NULL;\n}\n\n/*\n * Set a slice in object 'dst', which has the type 'type',\n * to the value 'value'.\n */\nint\nPyCData_set(PyObject *dst, PyObject *type, SETFUNC setfunc, PyObject *value,\n          Py_ssize_t index, Py_ssize_t size, char *ptr)\n{\n    CDataObject *mem = (CDataObject *)dst;\n    PyObject *result;\n\n    if (!CDataObject_Check(dst)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"not a ctype instance\");\n        return -1;\n    }\n\n    result = _PyCData_set(mem, type, setfunc, value,\n                        size, ptr);\n    if (result == NULL)\n        return -1;\n\n    /* KeepRef steals a refcount from it's last argument */\n    /* If KeepRef fails, we are stumped.  The dst memory block has already\n       been changed */\n    return KeepRef(mem, index, result);\n}\n\n\n/******************************************************************/\nstatic PyObject *\nGenericPyCData_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    CDataObject *obj;\n    StgDictObject *dict;\n\n    dict = PyType_stgdict((PyObject *)type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n    dict->flags |= DICTFLAG_FINAL;\n\n    obj = (CDataObject *)type->tp_alloc(type, 0);\n    if (!obj)\n        return NULL;\n\n    obj->b_base = NULL;\n    obj->b_index = 0;\n    obj->b_objects = NULL;\n    obj->b_length = dict->length;\n\n    if (-1 == PyCData_MallocBuffer(obj, dict)) {\n        Py_DECREF(obj);\n        return NULL;\n    }\n    return (PyObject *)obj;\n}\n/*****************************************************************/\n/*\n  PyCFuncPtr_Type\n*/\n\nstatic int\nPyCFuncPtr_set_errcheck(PyCFuncPtrObject *self, PyObject *ob, void *Py_UNUSED(ignored))\n{\n    if (ob && !PyCallable_Check(ob)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"the errcheck attribute must be callable\");\n        return -1;\n    }\n    Py_XINCREF(ob);\n    Py_XSETREF(self->errcheck, ob);\n    return 0;\n}\n\nstatic PyObject *\nPyCFuncPtr_get_errcheck(PyCFuncPtrObject *self, void *Py_UNUSED(ignored))\n{\n    if (self->errcheck) {\n        return Py_NewRef(self->errcheck);\n    }\n    Py_RETURN_NONE;\n}\n\nstatic int\nPyCFuncPtr_set_restype(PyCFuncPtrObject *self, PyObject *ob, void *Py_UNUSED(ignored))\n{\n    PyObject *checker, *oldchecker;\n    if (ob == NULL) {\n        oldchecker = self->checker;\n        self->checker = NULL;\n        Py_CLEAR(self->restype);\n        Py_XDECREF(oldchecker);\n        return 0;\n    }\n    if (ob != Py_None && !PyType_stgdict(ob) && !PyCallable_Check(ob)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"restype must be a type, a callable, or None\");\n        return -1;\n    }\n    if (_PyObject_LookupAttr(ob, &_Py_ID(_check_retval_), &checker) < 0) {\n        return -1;\n    }\n    oldchecker = self->checker;\n    self->checker = checker;\n    Py_INCREF(ob);\n    Py_XSETREF(self->restype, ob);\n    Py_XDECREF(oldchecker);\n    return 0;\n}\n\nstatic PyObject *\nPyCFuncPtr_get_restype(PyCFuncPtrObject *self, void *Py_UNUSED(ignored))\n{\n    StgDictObject *dict;\n    if (self->restype) {\n        return Py_NewRef(self->restype);\n    }\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for PyCFuncPtrObject instances */\n    if (dict->restype) {\n        return Py_NewRef(dict->restype);\n    } else {\n        Py_RETURN_NONE;\n    }\n}\n\nstatic int\nPyCFuncPtr_set_argtypes(PyCFuncPtrObject *self, PyObject *ob, void *Py_UNUSED(ignored))\n{\n    PyObject *converters;\n\n    if (ob == NULL || ob == Py_None) {\n        Py_CLEAR(self->converters);\n        Py_CLEAR(self->argtypes);\n    } else {\n        converters = converters_from_argtypes(ob);\n        if (!converters)\n            return -1;\n        Py_XSETREF(self->converters, converters);\n        Py_INCREF(ob);\n        Py_XSETREF(self->argtypes, ob);\n    }\n    return 0;\n}\n\nstatic PyObject *\nPyCFuncPtr_get_argtypes(PyCFuncPtrObject *self, void *Py_UNUSED(ignored))\n{\n    StgDictObject *dict;\n    if (self->argtypes) {\n        return Py_NewRef(self->argtypes);\n    }\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for PyCFuncPtrObject instances */\n    if (dict->argtypes) {\n        return Py_NewRef(dict->argtypes);\n    } else {\n        Py_RETURN_NONE;\n    }\n}\n\nstatic PyGetSetDef PyCFuncPtr_getsets[] = {\n    { \"errcheck\", (getter)PyCFuncPtr_get_errcheck, (setter)PyCFuncPtr_set_errcheck,\n      \"a function to check for errors\", NULL },\n    { \"restype\", (getter)PyCFuncPtr_get_restype, (setter)PyCFuncPtr_set_restype,\n      \"specify the result type\", NULL },\n    { \"argtypes\", (getter)PyCFuncPtr_get_argtypes,\n      (setter)PyCFuncPtr_set_argtypes,\n      \"specify the argument types\", NULL },\n    { NULL, NULL }\n};\n\n#ifdef MS_WIN32\nstatic PPROC FindAddress(void *handle, const char *name, PyObject *type)\n{\n    PPROC address;\n#ifdef MS_WIN64\n    /* win64 has no stdcall calling conv, so it should\n       also not have the name mangling of it.\n    */\n    Py_BEGIN_ALLOW_THREADS\n    address = (PPROC)GetProcAddress(handle, name);\n    Py_END_ALLOW_THREADS\n    return address;\n#else\n    char *mangled_name;\n    int i;\n    StgDictObject *dict;\n\n    Py_BEGIN_ALLOW_THREADS\n    address = (PPROC)GetProcAddress(handle, name);\n    Py_END_ALLOW_THREADS\n    if (address)\n        return address;\n    if (((size_t)name & ~0xFFFF) == 0) {\n        return NULL;\n    }\n\n    dict = PyType_stgdict((PyObject *)type);\n    /* It should not happen that dict is NULL, but better be safe */\n    if (dict==NULL || dict->flags & FUNCFLAG_CDECL)\n        return address;\n\n    /* for stdcall, try mangled names:\n       funcname -> _funcname@<n>\n       where n is 0, 4, 8, 12, ..., 128\n     */\n    mangled_name = alloca(strlen(name) + 1 + 1 + 1 + 3); /* \\0 _ @ %d */\n    if (!mangled_name)\n        return NULL;\n    for (i = 0; i < 32; ++i) {\n        sprintf(mangled_name, \"_%s@%d\", name, i*4);\n        Py_BEGIN_ALLOW_THREADS\n        address = (PPROC)GetProcAddress(handle, mangled_name);\n        Py_END_ALLOW_THREADS\n        if (address)\n            return address;\n    }\n    return NULL;\n#endif\n}\n#endif\n\n/* Return 1 if usable, 0 else and exception set. */\nstatic int\n_check_outarg_type(PyObject *arg, Py_ssize_t index)\n{\n    StgDictObject *dict;\n\n    if (PyCPointerTypeObject_Check(arg))\n        return 1;\n\n    if (PyCArrayTypeObject_Check(arg))\n        return 1;\n\n    dict = PyType_stgdict(arg);\n    if (dict\n        /* simple pointer types, c_void_p, c_wchar_p, BSTR, ... */\n        && PyUnicode_Check(dict->proto)\n/* We only allow c_void_p, c_char_p and c_wchar_p as a simple output parameter type */\n        && (strchr(\"PzZ\", PyUnicode_AsUTF8(dict->proto)[0]))) {\n        return 1;\n    }\n\n    PyErr_Format(PyExc_TypeError,\n                 \"'out' parameter %d must be a pointer type, not %s\",\n                 Py_SAFE_DOWNCAST(index, Py_ssize_t, int),\n                 PyType_Check(arg) ?\n                 ((PyTypeObject *)arg)->tp_name :\n             Py_TYPE(arg)->tp_name);\n    return 0;\n}\n\n/* Returns 1 on success, 0 on error */\nstatic int\n_validate_paramflags(PyTypeObject *type, PyObject *paramflags)\n{\n    Py_ssize_t i, len;\n    StgDictObject *dict;\n    PyObject *argtypes;\n\n    dict = PyType_stgdict((PyObject *)type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return 0;\n    }\n    argtypes = dict->argtypes;\n\n    if (paramflags == NULL || dict->argtypes == NULL)\n        return 1;\n\n    if (!PyTuple_Check(paramflags)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"paramflags must be a tuple or None\");\n        return 0;\n    }\n\n    len = PyTuple_GET_SIZE(paramflags);\n    if (len != PyTuple_GET_SIZE(dict->argtypes)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"paramflags must have the same length as argtypes\");\n        return 0;\n    }\n\n    for (i = 0; i < len; ++i) {\n        PyObject *item = PyTuple_GET_ITEM(paramflags, i);\n        int flag;\n        PyObject *name = Py_None;\n        PyObject *defval;\n        PyObject *typ;\n        if (!PyArg_ParseTuple(item, \"i|OO\", &flag, &name, &defval) ||\n            !(name == Py_None || PyUnicode_Check(name)))\n        {\n            PyErr_SetString(PyExc_TypeError,\n                   \"paramflags must be a sequence of (int [,string [,value]]) tuples\");\n            return 0;\n        }\n        typ = PyTuple_GET_ITEM(argtypes, i);\n        switch (flag & (PARAMFLAG_FIN | PARAMFLAG_FOUT | PARAMFLAG_FLCID)) {\n        case 0:\n        case PARAMFLAG_FIN:\n        case PARAMFLAG_FIN | PARAMFLAG_FLCID:\n        case PARAMFLAG_FIN | PARAMFLAG_FOUT:\n            break;\n        case PARAMFLAG_FOUT:\n            if (!_check_outarg_type(typ, i+1))\n                return 0;\n            break;\n        default:\n            PyErr_Format(PyExc_TypeError,\n                         \"paramflag value %d not supported\",\n                         flag);\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic int\n_get_name(PyObject *obj, const char **pname)\n{\n#ifdef MS_WIN32\n    if (PyLong_Check(obj)) {\n        /* We have to use MAKEINTRESOURCEA for Windows CE.\n           Works on Windows as well, of course.\n        */\n        *pname = MAKEINTRESOURCEA(PyLong_AsUnsignedLongMask(obj) & 0xFFFF);\n        return 1;\n    }\n#endif\n    if (PyBytes_Check(obj)) {\n        *pname = PyBytes_AS_STRING(obj);\n        return *pname ? 1 : 0;\n    }\n    if (PyUnicode_Check(obj)) {\n        *pname = PyUnicode_AsUTF8(obj);\n        return *pname ? 1 : 0;\n    }\n    PyErr_SetString(PyExc_TypeError,\n                    \"function name must be string, bytes object or integer\");\n    return 0;\n}\n\n\nstatic PyObject *\nPyCFuncPtr_FromDll(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    const char *name;\n    int (* address)(void);\n    PyObject *ftuple;\n    PyObject *dll;\n    PyObject *obj;\n    PyCFuncPtrObject *self;\n    void *handle;\n    PyObject *paramflags = NULL;\n\n    if (!PyArg_ParseTuple(args, \"O|O\", &ftuple, &paramflags))\n        return NULL;\n    if (paramflags == Py_None)\n        paramflags = NULL;\n\n    ftuple = PySequence_Tuple(ftuple);\n    if (!ftuple)\n        /* Here ftuple is a borrowed reference */\n        return NULL;\n\n    if (!PyArg_ParseTuple(ftuple, \"O&O;illegal func_spec argument\",\n                          _get_name, &name, &dll))\n    {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n\n#ifdef MS_WIN32\n    if (PySys_Audit(\"ctypes.dlsym\",\n                    ((uintptr_t)name & ~0xFFFF) ? \"Os\" : \"On\",\n                    dll, name) < 0) {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n#else\n    if (PySys_Audit(\"ctypes.dlsym\", \"Os\", dll, name) < 0) {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n#endif\n\n    obj = PyObject_GetAttrString(dll, \"_handle\");\n    if (!obj) {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n    if (!PyLong_Check(obj)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"the _handle attribute of the second argument must be an integer\");\n        Py_DECREF(ftuple);\n        Py_DECREF(obj);\n        return NULL;\n    }\n    handle = (void *)PyLong_AsVoidPtr(obj);\n    Py_DECREF(obj);\n    if (PyErr_Occurred()) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"could not convert the _handle attribute to a pointer\");\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n\n#ifdef MS_WIN32\n    address = FindAddress(handle, name, (PyObject *)type);\n    if (!address) {\n        if (!IS_INTRESOURCE(name))\n            PyErr_Format(PyExc_AttributeError,\n                         \"function '%s' not found\",\n                         name);\n        else\n            PyErr_Format(PyExc_AttributeError,\n                         \"function ordinal %d not found\",\n                         (WORD)(size_t)name);\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n#else\n    address = (PPROC)dlsym(handle, name);\n    if (!address) {\n#ifdef __CYGWIN__\n/* dlerror() isn't very helpful on cygwin */\n        PyErr_Format(PyExc_AttributeError,\n                     \"function '%s' not found\",\n                     name);\n#else\n        PyErr_SetString(PyExc_AttributeError, dlerror());\n#endif\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n#endif\n    if (!_validate_paramflags(type, paramflags)) {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n\n    self = (PyCFuncPtrObject *)GenericPyCData_new(type, args, kwds);\n    if (!self) {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n\n    self->paramflags = Py_XNewRef(paramflags);\n\n    *(void **)self->b_ptr = address;\n    Py_INCREF(dll);\n    Py_DECREF(ftuple);\n    if (-1 == KeepRef((CDataObject *)self, 0, dll)) {\n        Py_DECREF((PyObject *)self);\n        return NULL;\n    }\n\n    self->callable = Py_NewRef(self);\n    return (PyObject *)self;\n}\n\n#ifdef MS_WIN32\nstatic PyObject *\nPyCFuncPtr_FromVtblIndex(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyCFuncPtrObject *self;\n    int index;\n    char *name = NULL;\n    PyObject *paramflags = NULL;\n    GUID *iid = NULL;\n    Py_ssize_t iid_len = 0;\n\n    if (!PyArg_ParseTuple(args, \"is|Oz#\", &index, &name, &paramflags, &iid, &iid_len))\n        return NULL;\n    if (paramflags == Py_None)\n        paramflags = NULL;\n\n    if (!_validate_paramflags(type, paramflags))\n        return NULL;\n\n    self = (PyCFuncPtrObject *)GenericPyCData_new(type, args, kwds);\n    self->index = index + 0x1000;\n    self->paramflags = Py_XNewRef(paramflags);\n    if (iid_len == sizeof(GUID))\n        self->iid = iid;\n    return (PyObject *)self;\n}\n#endif\n\n/*\n  PyCFuncPtr_new accepts different argument lists in addition to the standard\n  _basespec_ keyword arg:\n\n  one argument form\n  \"i\" - function address\n  \"O\" - must be a callable, creates a C callable function\n\n  two or more argument forms (the third argument is a paramflags tuple)\n  \"(sO)|...\" - (function name, dll object (with an integer handle)), paramflags\n  \"(iO)|...\" - (function ordinal, dll object (with an integer handle)), paramflags\n  \"is|...\" - vtable index, method name, creates callable calling COM vtbl\n*/\nstatic PyObject *\nPyCFuncPtr_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyCFuncPtrObject *self;\n    PyObject *callable;\n    StgDictObject *dict;\n    CThunkObject *thunk;\n\n    if (PyTuple_GET_SIZE(args) == 0)\n        return GenericPyCData_new(type, args, kwds);\n\n    if (1 <= PyTuple_GET_SIZE(args) && PyTuple_Check(PyTuple_GET_ITEM(args, 0)))\n        return PyCFuncPtr_FromDll(type, args, kwds);\n\n#ifdef MS_WIN32\n    if (2 <= PyTuple_GET_SIZE(args) && PyLong_Check(PyTuple_GET_ITEM(args, 0)))\n        return PyCFuncPtr_FromVtblIndex(type, args, kwds);\n#endif\n\n    if (1 == PyTuple_GET_SIZE(args)\n        && (PyLong_Check(PyTuple_GET_ITEM(args, 0)))) {\n        CDataObject *ob;\n        void *ptr = PyLong_AsVoidPtr(PyTuple_GET_ITEM(args, 0));\n        if (ptr == NULL && PyErr_Occurred())\n            return NULL;\n        ob = (CDataObject *)GenericPyCData_new(type, args, kwds);\n        if (ob == NULL)\n            return NULL;\n        *(void **)ob->b_ptr = ptr;\n        return (PyObject *)ob;\n    }\n\n    if (!PyArg_ParseTuple(args, \"O\", &callable))\n        return NULL;\n    if (!PyCallable_Check(callable)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"argument must be callable or integer function address\");\n        return NULL;\n    }\n\n    /* XXX XXX This would allow passing additional options.  For COM\n       method *implementations*, we would probably want different\n       behaviour than in 'normal' callback functions: return a HRESULT if\n       an exception occurs in the callback, and print the traceback not\n       only on the console, but also to OutputDebugString() or something\n       like that.\n    */\n/*\n    if (kwds && _PyDict_GetItemIdWithError(kwds, &PyId_options)) {\n        ...\n    }\n    else if (PyErr_Occurred()) {\n        return NULL;\n    }\n*/\n\n    dict = PyType_stgdict((PyObject *)type);\n    /* XXXX Fails if we do: 'PyCFuncPtr(lambda x: x)' */\n    if (!dict || !dict->argtypes) {\n        PyErr_SetString(PyExc_TypeError,\n               \"cannot construct instance of this class:\"\n            \" no argtypes\");\n        return NULL;\n    }\n\n    thunk = _ctypes_alloc_callback(callable,\n                                  dict->argtypes,\n                                  dict->restype,\n                                  dict->flags);\n    if (!thunk)\n        return NULL;\n\n    self = (PyCFuncPtrObject *)GenericPyCData_new(type, args, kwds);\n    if (self == NULL) {\n        Py_DECREF(thunk);\n        return NULL;\n    }\n\n    self->callable = Py_NewRef(callable);\n\n    self->thunk = thunk;\n    *(void **)self->b_ptr = (void *)thunk->pcl_exec;\n\n    Py_INCREF((PyObject *)thunk); /* for KeepRef */\n    if (-1 == KeepRef((CDataObject *)self, 0, (PyObject *)thunk)) {\n        Py_DECREF((PyObject *)self);\n        return NULL;\n    }\n    return (PyObject *)self;\n}\n\n\n/*\n  _byref consumes a refcount to its argument\n*/\nstatic PyObject *\n_byref(PyObject *obj)\n{\n    PyCArgObject *parg;\n    if (!CDataObject_Check(obj)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected CData instance\");\n        return NULL;\n    }\n\n    parg = PyCArgObject_new();\n    if (parg == NULL) {\n        Py_DECREF(obj);\n        return NULL;\n    }\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    parg->obj = obj;\n    parg->value.p = ((CDataObject *)obj)->b_ptr;\n    return (PyObject *)parg;\n}\n\nstatic PyObject *\n_get_arg(int *pindex, PyObject *name, PyObject *defval, PyObject *inargs, PyObject *kwds)\n{\n    PyObject *v;\n\n    if (*pindex < PyTuple_GET_SIZE(inargs)) {\n        v = PyTuple_GET_ITEM(inargs, *pindex);\n        ++*pindex;\n        return Py_NewRef(v);\n    }\n    if (kwds && name) {\n        v = PyDict_GetItemWithError(kwds, name);\n        if (v) {\n            ++*pindex;\n            return Py_NewRef(v);\n        }\n        else if (PyErr_Occurred()) {\n            return NULL;\n        }\n    }\n    if (defval) {\n        return Py_NewRef(defval);\n    }\n    /* we can't currently emit a better error message */\n    if (name)\n        PyErr_Format(PyExc_TypeError,\n                     \"required argument '%S' missing\", name);\n    else\n        PyErr_Format(PyExc_TypeError,\n                     \"not enough arguments\");\n    return NULL;\n}\n\n/*\n This function implements higher level functionality plus the ability to call\n functions with keyword arguments by looking at parameter flags.  parameter\n flags is a tuple of 1, 2 or 3-tuples.  The first entry in each is an integer\n specifying the direction of the data transfer for this parameter - 'in',\n 'out' or 'inout' (zero means the same as 'in').  The second entry is the\n parameter name, and the third is the default value if the parameter is\n missing in the function call.\n\n This function builds and returns a new tuple 'callargs' which contains the\n parameters to use in the call.  Items on this tuple are copied from the\n 'inargs' tuple for 'in' and 'in, out' parameters, and constructed from the\n 'argtypes' tuple for 'out' parameters.  It also calculates numretvals which\n is the number of return values for the function, outmask/inoutmask are\n bitmasks containing indexes into the callargs tuple specifying which\n parameters have to be returned.  _build_result builds the return value of the\n function.\n*/\nstatic PyObject *\n_build_callargs(PyCFuncPtrObject *self, PyObject *argtypes,\n                PyObject *inargs, PyObject *kwds,\n                int *poutmask, int *pinoutmask, unsigned int *pnumretvals)\n{\n    PyObject *paramflags = self->paramflags;\n    PyObject *callargs;\n    StgDictObject *dict;\n    Py_ssize_t i, len;\n    int inargs_index = 0;\n    /* It's a little bit difficult to determine how many arguments the\n    function call requires/accepts.  For simplicity, we count the consumed\n    args and compare this to the number of supplied args. */\n    Py_ssize_t actual_args;\n\n    *poutmask = 0;\n    *pinoutmask = 0;\n    *pnumretvals = 0;\n\n    /* Trivial cases, where we either return inargs itself, or a slice of it. */\n    if (argtypes == NULL || paramflags == NULL || PyTuple_GET_SIZE(argtypes) == 0) {\n#ifdef MS_WIN32\n        if (self->index)\n            return PyTuple_GetSlice(inargs, 1, PyTuple_GET_SIZE(inargs));\n#endif\n        return Py_NewRef(inargs);\n    }\n\n    len = PyTuple_GET_SIZE(argtypes);\n    callargs = PyTuple_New(len); /* the argument tuple we build */\n    if (callargs == NULL)\n        return NULL;\n\n#ifdef MS_WIN32\n    /* For a COM method, skip the first arg */\n    if (self->index) {\n        inargs_index = 1;\n    }\n#endif\n    for (i = 0; i < len; ++i) {\n        PyObject *item = PyTuple_GET_ITEM(paramflags, i);\n        PyObject *ob;\n        unsigned int flag;\n        PyObject *name = NULL;\n        PyObject *defval = NULL;\n\n        /* This way seems to be ~2 us faster than the PyArg_ParseTuple\n           calls below. */\n        /* We HAVE already checked that the tuple can be parsed with \"i|ZO\", so... */\n        Py_ssize_t tsize = PyTuple_GET_SIZE(item);\n        flag = PyLong_AsUnsignedLongMask(PyTuple_GET_ITEM(item, 0));\n        name = tsize > 1 ? PyTuple_GET_ITEM(item, 1) : NULL;\n        defval = tsize > 2 ? PyTuple_GET_ITEM(item, 2) : NULL;\n\n        switch (flag & (PARAMFLAG_FIN | PARAMFLAG_FOUT | PARAMFLAG_FLCID)) {\n        case PARAMFLAG_FIN | PARAMFLAG_FLCID:\n            /* ['in', 'lcid'] parameter.  Always taken from defval,\n             if given, else the integer 0. */\n            if (defval == NULL) {\n                defval = _PyLong_GetZero();\n            }\n            Py_INCREF(defval);\n            PyTuple_SET_ITEM(callargs, i, defval);\n            break;\n        case (PARAMFLAG_FIN | PARAMFLAG_FOUT):\n            *pinoutmask |= (1 << i); /* mark as inout arg */\n            (*pnumretvals)++;\n            /* fall through */\n        case 0:\n        case PARAMFLAG_FIN:\n            /* 'in' parameter.  Copy it from inargs. */\n            ob =_get_arg(&inargs_index, name, defval, inargs, kwds);\n            if (ob == NULL)\n                goto error;\n            PyTuple_SET_ITEM(callargs, i, ob);\n            break;\n        case PARAMFLAG_FOUT:\n            /* XXX Refactor this code into a separate function. */\n            /* 'out' parameter.\n               argtypes[i] must be a POINTER to a c type.\n\n               Cannot by supplied in inargs, but a defval will be used\n               if available.  XXX Should we support getting it from kwds?\n            */\n            if (defval) {\n                /* XXX Using mutable objects as defval will\n                   make the function non-threadsafe, unless we\n                   copy the object in each invocation */\n                Py_INCREF(defval);\n                PyTuple_SET_ITEM(callargs, i, defval);\n                *poutmask |= (1 << i); /* mark as out arg */\n                (*pnumretvals)++;\n                break;\n            }\n            ob = PyTuple_GET_ITEM(argtypes, i);\n            dict = PyType_stgdict(ob);\n            if (dict == NULL) {\n                /* Cannot happen: _validate_paramflags()\n                  would not accept such an object */\n                PyErr_Format(PyExc_RuntimeError,\n                             \"NULL stgdict unexpected\");\n                goto error;\n            }\n            if (PyUnicode_Check(dict->proto)) {\n                PyErr_Format(\n                    PyExc_TypeError,\n                    \"%s 'out' parameter must be passed as default value\",\n                    ((PyTypeObject *)ob)->tp_name);\n                goto error;\n            }\n            if (PyCArrayTypeObject_Check(ob))\n                ob = _PyObject_CallNoArgs(ob);\n            else\n                /* Create an instance of the pointed-to type */\n                ob = _PyObject_CallNoArgs(dict->proto);\n            /*\n               XXX Is the following correct any longer?\n               We must not pass a byref() to the array then but\n               the array instance itself. Then, we cannot retrieve\n               the result from the PyCArgObject.\n            */\n            if (ob == NULL)\n                goto error;\n            /* The .from_param call that will occur later will pass this\n               as a byref parameter. */\n            PyTuple_SET_ITEM(callargs, i, ob);\n            *poutmask |= (1 << i); /* mark as out arg */\n            (*pnumretvals)++;\n            break;\n        default:\n            PyErr_Format(PyExc_ValueError,\n                         \"paramflag %u not yet implemented\", flag);\n            goto error;\n            break;\n        }\n    }\n\n    /* We have counted the arguments we have consumed in 'inargs_index'.  This\n       must be the same as len(inargs) + len(kwds), otherwise we have\n       either too much or not enough arguments. */\n\n    actual_args = PyTuple_GET_SIZE(inargs) + (kwds ? PyDict_GET_SIZE(kwds) : 0);\n    if (actual_args != inargs_index) {\n        /* When we have default values or named parameters, this error\n           message is misleading.  See unittests/test_paramflags.py\n         */\n        PyErr_Format(PyExc_TypeError,\n                     \"call takes exactly %d arguments (%zd given)\",\n                     inargs_index, actual_args);\n        goto error;\n    }\n\n    /* outmask is a bitmask containing indexes into callargs.  Items at\n       these indexes contain values to return.\n     */\n    return callargs;\n  error:\n    Py_DECREF(callargs);\n    return NULL;\n}\n\n/* See also:\n   http://msdn.microsoft.com/library/en-us/com/html/769127a1-1a14-4ed4-9d38-7cf3e571b661.asp\n*/\n/*\n  Build return value of a function.\n\n  Consumes the refcount on result and callargs.\n*/\nstatic PyObject *\n_build_result(PyObject *result, PyObject *callargs,\n              int outmask, int inoutmask, unsigned int numretvals)\n{\n    unsigned int i, index;\n    int bit;\n    PyObject *tup = NULL;\n\n    if (callargs == NULL)\n        return result;\n    if (result == NULL || numretvals == 0) {\n        Py_DECREF(callargs);\n        return result;\n    }\n    Py_DECREF(result);\n\n    /* tup will not be allocated if numretvals == 1 */\n    /* allocate tuple to hold the result */\n    if (numretvals > 1) {\n        tup = PyTuple_New(numretvals);\n        if (tup == NULL) {\n            Py_DECREF(callargs);\n            return NULL;\n        }\n    }\n\n    index = 0;\n    for (bit = 1, i = 0; i < 32; ++i, bit <<= 1) {\n        PyObject *v;\n        if (bit & inoutmask) {\n            v = PyTuple_GET_ITEM(callargs, i);\n            Py_INCREF(v);\n            if (numretvals == 1) {\n                Py_DECREF(callargs);\n                return v;\n            }\n            PyTuple_SET_ITEM(tup, index, v);\n            index++;\n        } else if (bit & outmask) {\n\n            v = PyTuple_GET_ITEM(callargs, i);\n            v = PyObject_CallMethodNoArgs(v, &_Py_ID(__ctypes_from_outparam__));\n            if (v == NULL || numretvals == 1) {\n                Py_DECREF(callargs);\n                return v;\n            }\n            PyTuple_SET_ITEM(tup, index, v);\n            index++;\n        }\n        if (index == numretvals)\n            break;\n    }\n\n    Py_DECREF(callargs);\n    return tup;\n}\n\nstatic PyObject *\nPyCFuncPtr_call(PyCFuncPtrObject *self, PyObject *inargs, PyObject *kwds)\n{\n    PyObject *restype;\n    PyObject *converters;\n    PyObject *checker;\n    PyObject *argtypes;\n    StgDictObject *dict = PyObject_stgdict((PyObject *)self);\n    PyObject *result;\n    PyObject *callargs;\n    PyObject *errcheck;\n#ifdef MS_WIN32\n    IUnknown *piunk = NULL;\n#endif\n    void *pProc = NULL;\n\n    int inoutmask;\n    int outmask;\n    unsigned int numretvals;\n\n    assert(dict); /* Cannot be NULL for PyCFuncPtrObject instances */\n    restype = self->restype ? self->restype : dict->restype;\n    converters = self->converters ? self->converters : dict->converters;\n    checker = self->checker ? self->checker : dict->checker;\n    argtypes = self->argtypes ? self->argtypes : dict->argtypes;\n/* later, we probably want to have an errcheck field in stgdict */\n    errcheck = self->errcheck /* ? self->errcheck : dict->errcheck */;\n\n\n    pProc = *(void **)self->b_ptr;\n#ifdef MS_WIN32\n    if (self->index) {\n        /* It's a COM method */\n        CDataObject *this;\n        this = (CDataObject *)PyTuple_GetItem(inargs, 0); /* borrowed ref! */\n        if (!this) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"native com method call without 'this' parameter\");\n            return NULL;\n        }\n        if (!CDataObject_Check(this)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"Expected a COM this pointer as first argument\");\n            return NULL;\n        }\n        /* there should be more checks? No, in Python */\n        /* First arg is a pointer to an interface instance */\n        if (!this->b_ptr || *(void **)this->b_ptr == NULL) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"NULL COM pointer access\");\n            return NULL;\n        }\n        piunk = *(IUnknown **)this->b_ptr;\n        if (NULL == piunk->lpVtbl) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"COM method call without VTable\");\n            return NULL;\n        }\n        pProc = ((void **)piunk->lpVtbl)[self->index - 0x1000];\n    }\n#endif\n    callargs = _build_callargs(self, argtypes,\n                               inargs, kwds,\n                               &outmask, &inoutmask, &numretvals);\n    if (callargs == NULL)\n        return NULL;\n\n    if (converters) {\n        int required = Py_SAFE_DOWNCAST(PyTuple_GET_SIZE(converters),\n                                        Py_ssize_t, int);\n        int actual = Py_SAFE_DOWNCAST(PyTuple_GET_SIZE(callargs),\n                                      Py_ssize_t, int);\n\n        if ((dict->flags & FUNCFLAG_CDECL) == FUNCFLAG_CDECL) {\n            /* For cdecl functions, we allow more actual arguments\n               than the length of the argtypes tuple.\n            */\n            if (required > actual) {\n                Py_DECREF(callargs);\n                PyErr_Format(PyExc_TypeError,\n              \"this function takes at least %d argument%s (%d given)\",\n                                 required,\n                                 required == 1 ? \"\" : \"s\",\n                                 actual);\n                return NULL;\n            }\n        } else if (required != actual) {\n            Py_DECREF(callargs);\n            PyErr_Format(PyExc_TypeError,\n                 \"this function takes %d argument%s (%d given)\",\n                     required,\n                     required == 1 ? \"\" : \"s\",\n                     actual);\n            return NULL;\n        }\n    }\n\n    result = _ctypes_callproc(pProc,\n                       callargs,\n#ifdef MS_WIN32\n                       piunk,\n                       self->iid,\n#endif\n                       dict->flags,\n                       converters,\n                       restype,\n                       checker);\n/* The 'errcheck' protocol */\n    if (result != NULL && errcheck) {\n        PyObject *v = PyObject_CallFunctionObjArgs(errcheck,\n                                                   result,\n                                                   self,\n                                                   callargs,\n                                                   NULL);\n        /* If the errcheck function failed, return NULL.\n           If the errcheck function returned callargs unchanged,\n           continue normal processing.\n           If the errcheck function returned something else,\n           use that as result.\n        */\n        if (v == NULL || v != callargs) {\n            Py_DECREF(result);\n            Py_DECREF(callargs);\n            return v;\n        }\n        Py_DECREF(v);\n    }\n\n    return _build_result(result, callargs,\n                         outmask, inoutmask, numretvals);\n}\n\nstatic int\nPyCFuncPtr_traverse(PyCFuncPtrObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->callable);\n    Py_VISIT(self->restype);\n    Py_VISIT(self->checker);\n    Py_VISIT(self->errcheck);\n    Py_VISIT(self->argtypes);\n    Py_VISIT(self->converters);\n    Py_VISIT(self->paramflags);\n    Py_VISIT(self->thunk);\n    return PyCData_traverse((CDataObject *)self, visit, arg);\n}\n\nstatic int\nPyCFuncPtr_clear(PyCFuncPtrObject *self)\n{\n    Py_CLEAR(self->callable);\n    Py_CLEAR(self->restype);\n    Py_CLEAR(self->checker);\n    Py_CLEAR(self->errcheck);\n    Py_CLEAR(self->argtypes);\n    Py_CLEAR(self->converters);\n    Py_CLEAR(self->paramflags);\n    Py_CLEAR(self->thunk);\n    return PyCData_clear((CDataObject *)self);\n}\n\nstatic void\nPyCFuncPtr_dealloc(PyCFuncPtrObject *self)\n{\n    PyCFuncPtr_clear(self);\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\nstatic PyObject *\nPyCFuncPtr_repr(PyCFuncPtrObject *self)\n{\n#ifdef MS_WIN32\n    if (self->index)\n        return PyUnicode_FromFormat(\"<COM method offset %d: %s at %p>\",\n                                   self->index - 0x1000,\n                                   Py_TYPE(self)->tp_name,\n                                   self);\n#endif\n    return PyUnicode_FromFormat(\"<%s object at %p>\",\n                               Py_TYPE(self)->tp_name,\n                               self);\n}\n\nstatic int\nPyCFuncPtr_bool(PyCFuncPtrObject *self)\n{\n    return ((*(void **)self->b_ptr != NULL)\n#ifdef MS_WIN32\n        || (self->index != 0)\n#endif\n        );\n}\n\nstatic PyNumberMethods PyCFuncPtr_as_number = {\n    0, /* nb_add */\n    0, /* nb_subtract */\n    0, /* nb_multiply */\n    0, /* nb_remainder */\n    0, /* nb_divmod */\n    0, /* nb_power */\n    0, /* nb_negative */\n    0, /* nb_positive */\n    0, /* nb_absolute */\n    (inquiry)PyCFuncPtr_bool, /* nb_bool */\n};\n\nPyTypeObject PyCFuncPtr_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.CFuncPtr\",\n    sizeof(PyCFuncPtrObject),                           /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    (destructor)PyCFuncPtr_dealloc,             /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    (reprfunc)PyCFuncPtr_repr,                  /* tp_repr */\n    &PyCFuncPtr_as_number,                      /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    (ternaryfunc)PyCFuncPtr_call,               /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    PyDoc_STR(\"Function Pointer\"),              /* tp_doc */\n    (traverseproc)PyCFuncPtr_traverse,          /* tp_traverse */\n    (inquiry)PyCFuncPtr_clear,                  /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    PyCFuncPtr_getsets,                         /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCFuncPtr_new,                             /* tp_new */\n    0,                                          /* tp_free */\n};\n\n/*****************************************************************/\n/*\n  Struct_Type\n*/\n/*\n  This function is called to initialize a Structure or Union with positional\n  arguments. It calls itself recursively for all Structure or Union base\n  classes, then retrieves the _fields_ member to associate the argument\n  position with the correct field name.\n\n  Returns -1 on error, or the index of next argument on success.\n */\nstatic Py_ssize_t\n_init_pos_args(PyObject *self, PyTypeObject *type,\n               PyObject *args, PyObject *kwds,\n               Py_ssize_t index)\n{\n    StgDictObject *dict;\n    PyObject *fields;\n    Py_ssize_t i;\n\n    if (PyType_stgdict((PyObject *)type->tp_base)) {\n        index = _init_pos_args(self, type->tp_base,\n                               args, kwds,\n                               index);\n        if (index == -1)\n            return -1;\n    }\n\n    dict = PyType_stgdict((PyObject *)type);\n    fields = PyDict_GetItemWithError((PyObject *)dict, &_Py_ID(_fields_));\n    if (fields == NULL) {\n        if (PyErr_Occurred()) {\n            return -1;\n        }\n        return index;\n    }\n\n    for (i = index;\n         i < dict->length && i < PyTuple_GET_SIZE(args);\n         ++i) {\n        PyObject *pair = PySequence_GetItem(fields, i - index);\n        PyObject *name, *val;\n        int res;\n        if (!pair)\n            return -1;\n        name = PySequence_GetItem(pair, 0);\n        if (!name) {\n            Py_DECREF(pair);\n            return -1;\n        }\n        val = PyTuple_GET_ITEM(args, i);\n        if (kwds) {\n            res = PyDict_Contains(kwds, name);\n            if (res != 0) {\n                if (res > 0) {\n                    PyErr_Format(PyExc_TypeError,\n                                 \"duplicate values for field %R\",\n                                 name);\n                }\n                Py_DECREF(pair);\n                Py_DECREF(name);\n                return -1;\n            }\n        }\n\n        res = PyObject_SetAttr(self, name, val);\n        Py_DECREF(pair);\n        Py_DECREF(name);\n        if (res == -1)\n            return -1;\n    }\n    return dict->length;\n}\n\nstatic int\nStruct_init(PyObject *self, PyObject *args, PyObject *kwds)\n{\n/* Optimization possible: Store the attribute names _fields_[x][0]\n * in C accessible fields somewhere ?\n */\n    if (!PyTuple_Check(args)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"args not a tuple?\");\n        return -1;\n    }\n    if (PyTuple_GET_SIZE(args)) {\n        Py_ssize_t res = _init_pos_args(self, Py_TYPE(self),\n                                        args, kwds, 0);\n        if (res == -1)\n            return -1;\n        if (res < PyTuple_GET_SIZE(args)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"too many initializers\");\n            return -1;\n        }\n    }\n\n    if (kwds) {\n        PyObject *key, *value;\n        Py_ssize_t pos = 0;\n        while(PyDict_Next(kwds, &pos, &key, &value)) {\n            if (-1 == PyObject_SetAttr(self, key, value))\n                return -1;\n        }\n    }\n    return 0;\n}\n\nstatic PyTypeObject Struct_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.Structure\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    PyDoc_STR(\"Structure base class\"),          /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    Struct_init,                                /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\nstatic PyTypeObject Union_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.Union\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    PyDoc_STR(\"Union base class\"),              /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    Struct_init,                                /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n  PyCArray_Type\n*/\nstatic int\nArray_init(CDataObject *self, PyObject *args, PyObject *kw)\n{\n    Py_ssize_t i;\n    Py_ssize_t n;\n\n    if (!PyTuple_Check(args)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"args not a tuple?\");\n        return -1;\n    }\n    n = PyTuple_GET_SIZE(args);\n    for (i = 0; i < n; ++i) {\n        PyObject *v;\n        v = PyTuple_GET_ITEM(args, i);\n        if (-1 == PySequence_SetItem((PyObject *)self, i, v))\n            return -1;\n    }\n    return 0;\n}\n\nstatic PyObject *\nArray_item(PyObject *myself, Py_ssize_t index)\n{\n    CDataObject *self = (CDataObject *)myself;\n    Py_ssize_t offset, size;\n    StgDictObject *stgdict;\n\n\n    if (index < 0 || index >= self->b_length) {\n        PyErr_SetString(PyExc_IndexError,\n                        \"invalid index\");\n        return NULL;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for array instances */\n    /* Would it be clearer if we got the item size from\n       stgdict->proto's stgdict?\n    */\n    size = stgdict->size / stgdict->length;\n    offset = index * size;\n\n    return PyCData_get(stgdict->proto, stgdict->getfunc, (PyObject *)self,\n                     index, size, self->b_ptr + offset);\n}\n\nstatic PyObject *\nArray_subscript(PyObject *myself, PyObject *item)\n{\n    CDataObject *self = (CDataObject *)myself;\n\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n\n        if (i == -1 && PyErr_Occurred())\n            return NULL;\n        if (i < 0)\n            i += self->b_length;\n        return Array_item(myself, i);\n    }\n    else if (PySlice_Check(item)) {\n        StgDictObject *stgdict, *itemdict;\n        PyObject *proto;\n        PyObject *np;\n        Py_ssize_t start, stop, step, slicelen, i;\n        size_t cur;\n\n        if (PySlice_Unpack(item, &start, &stop, &step) < 0) {\n            return NULL;\n        }\n        slicelen = PySlice_AdjustIndices(self->b_length, &start, &stop, step);\n\n        stgdict = PyObject_stgdict((PyObject *)self);\n        assert(stgdict); /* Cannot be NULL for array object instances */\n        proto = stgdict->proto;\n        itemdict = PyType_stgdict(proto);\n        assert(itemdict); /* proto is the item type of the array, a\n                             ctypes type, so this cannot be NULL */\n\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"c\")->getfunc) {\n            char *ptr = (char *)self->b_ptr;\n            char *dest;\n\n            if (slicelen <= 0)\n                return PyBytes_FromStringAndSize(\"\", 0);\n            if (step == 1) {\n                return PyBytes_FromStringAndSize(ptr + start,\n                                                 slicelen);\n            }\n            dest = (char *)PyMem_Malloc(slicelen);\n\n            if (dest == NULL)\n                return PyErr_NoMemory();\n\n            for (cur = start, i = 0; i < slicelen;\n                 cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n\n            np = PyBytes_FromStringAndSize(dest, slicelen);\n            PyMem_Free(dest);\n            return np;\n        }\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"u\")->getfunc) {\n            wchar_t *ptr = (wchar_t *)self->b_ptr;\n            wchar_t *dest;\n\n            if (slicelen <= 0)\n                return PyUnicode_New(0, 0);\n            if (step == 1) {\n                return PyUnicode_FromWideChar(ptr + start,\n                                              slicelen);\n            }\n\n            dest = PyMem_New(wchar_t, slicelen);\n            if (dest == NULL) {\n                PyErr_NoMemory();\n                return NULL;\n            }\n\n            for (cur = start, i = 0; i < slicelen;\n                 cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n\n            np = PyUnicode_FromWideChar(dest, slicelen);\n            PyMem_Free(dest);\n            return np;\n        }\n\n        np = PyList_New(slicelen);\n        if (np == NULL)\n            return NULL;\n\n        for (cur = start, i = 0; i < slicelen;\n             cur += step, i++) {\n            PyObject *v = Array_item(myself, cur);\n            if (v == NULL) {\n                Py_DECREF(np);\n                return NULL;\n            }\n            PyList_SET_ITEM(np, i, v);\n        }\n        return np;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"indices must be integers\");\n        return NULL;\n    }\n\n}\n\nstatic int\nArray_ass_item(PyObject *myself, Py_ssize_t index, PyObject *value)\n{\n    CDataObject *self = (CDataObject *)myself;\n    Py_ssize_t size, offset;\n    StgDictObject *stgdict;\n    char *ptr;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Array does not support item deletion\");\n        return -1;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for array object instances */\n    if (index < 0 || index >= stgdict->length) {\n        PyErr_SetString(PyExc_IndexError,\n                        \"invalid index\");\n        return -1;\n    }\n    size = stgdict->size / stgdict->length;\n    offset = index * size;\n    ptr = self->b_ptr + offset;\n\n    return PyCData_set((PyObject *)self, stgdict->proto, stgdict->setfunc, value,\n                     index, size, ptr);\n}\n\nstatic int\nArray_ass_subscript(PyObject *myself, PyObject *item, PyObject *value)\n{\n    CDataObject *self = (CDataObject *)myself;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Array does not support item deletion\");\n        return -1;\n    }\n\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n\n        if (i == -1 && PyErr_Occurred())\n            return -1;\n        if (i < 0)\n            i += self->b_length;\n        return Array_ass_item(myself, i, value);\n    }\n    else if (PySlice_Check(item)) {\n        Py_ssize_t start, stop, step, slicelen, otherlen, i;\n        size_t cur;\n\n        if (PySlice_Unpack(item, &start, &stop, &step) < 0) {\n            return -1;\n        }\n        slicelen = PySlice_AdjustIndices(self->b_length, &start, &stop, step);\n        if ((step < 0 && start < stop) ||\n            (step > 0 && start > stop))\n            stop = start;\n\n        otherlen = PySequence_Length(value);\n        if (otherlen != slicelen) {\n            PyErr_SetString(PyExc_ValueError,\n                \"Can only assign sequence of same size\");\n            return -1;\n        }\n        for (cur = start, i = 0; i < otherlen; cur += step, i++) {\n            PyObject *item = PySequence_GetItem(value, i);\n            int result;\n            if (item == NULL)\n                return -1;\n            result = Array_ass_item(myself, cur, item);\n            Py_DECREF(item);\n            if (result == -1)\n                return -1;\n        }\n        return 0;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"indices must be integer\");\n        return -1;\n    }\n}\n\nstatic Py_ssize_t\nArray_length(PyObject *myself)\n{\n    CDataObject *self = (CDataObject *)myself;\n    return self->b_length;\n}\n\nstatic PyMethodDef Array_methods[] = {\n    {\"__class_getitem__\",    Py_GenericAlias,\n    METH_O|METH_CLASS,       PyDoc_STR(\"See PEP 585\")},\n    { NULL, NULL }\n};\n\nstatic PySequenceMethods Array_as_sequence = {\n    Array_length,                               /* sq_length; */\n    0,                                          /* sq_concat; */\n    0,                                          /* sq_repeat; */\n    Array_item,                                 /* sq_item; */\n    0,                                          /* sq_slice; */\n    Array_ass_item,                             /* sq_ass_item; */\n    0,                                          /* sq_ass_slice; */\n    0,                                          /* sq_contains; */\n\n    0,                                          /* sq_inplace_concat; */\n    0,                                          /* sq_inplace_repeat; */\n};\n\nstatic PyMappingMethods Array_as_mapping = {\n    Array_length,\n    Array_subscript,\n    Array_ass_subscript,\n};\n\nPyTypeObject PyCArray_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.Array\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &Array_as_sequence,                         /* tp_as_sequence */\n    &Array_as_mapping,                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    PyDoc_STR(\"XXX to be provided\"),            /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    Array_methods,                              /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc)Array_init,                       /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\nPyObject *\nPyCArrayType_from_ctype(PyObject *itemtype, Py_ssize_t length)\n{\n    static PyObject *cache;\n    PyObject *key;\n    PyObject *result;\n    char name[256];\n    PyObject *len;\n\n    if (cache == NULL) {\n        cache = PyDict_New();\n        if (cache == NULL)\n            return NULL;\n    }\n    len = PyLong_FromSsize_t(length);\n    if (len == NULL)\n        return NULL;\n    key = PyTuple_Pack(2, itemtype, len);\n    Py_DECREF(len);\n    if (!key)\n        return NULL;\n    result = PyDict_GetItemProxy(cache, key);\n    if (result) {\n        Py_INCREF(result);\n        Py_DECREF(key);\n        return result;\n    }\n    else if (PyErr_Occurred()) {\n        Py_DECREF(key);\n        return NULL;\n    }\n\n    if (!PyType_Check(itemtype)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Expected a type object\");\n        Py_DECREF(key);\n        return NULL;\n    }\n#ifdef MS_WIN64\n    sprintf(name, \"%.200s_Array_%Id\",\n        ((PyTypeObject *)itemtype)->tp_name, length);\n#else\n    sprintf(name, \"%.200s_Array_%ld\",\n        ((PyTypeObject *)itemtype)->tp_name, (long)length);\n#endif\n\n    result = PyObject_CallFunction((PyObject *)&PyCArrayType_Type,\n                                   \"s(O){s:n,s:O}\",\n                                   name,\n                                   &PyCArray_Type,\n                                   \"_length_\",\n                                   length,\n                                   \"_type_\",\n                                   itemtype\n        );\n    if (result == NULL) {\n        Py_DECREF(key);\n        return NULL;\n    }\n    if (-1 == PyDict_SetItemProxy(cache, key, result)) {\n        Py_DECREF(key);\n        Py_DECREF(result);\n        return NULL;\n    }\n    Py_DECREF(key);\n    return result;\n}\n\n\n/******************************************************************/\n/*\n  Simple_Type\n*/\n\nstatic int\nSimple_set_value(CDataObject *self, PyObject *value, void *Py_UNUSED(ignored))\n{\n    PyObject *result;\n    StgDictObject *dict = PyObject_stgdict((PyObject *)self);\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"can't delete attribute\");\n        return -1;\n    }\n    assert(dict); /* Cannot be NULL for CDataObject instances */\n    assert(dict->setfunc);\n    result = dict->setfunc(self->b_ptr, value, dict->size);\n    if (!result)\n        return -1;\n\n    /* consumes the refcount the setfunc returns */\n    return KeepRef(self, 0, result);\n}\n\nstatic int\nSimple_init(CDataObject *self, PyObject *args, PyObject *kw)\n{\n    PyObject *value = NULL;\n    if (!PyArg_UnpackTuple(args, \"__init__\", 0, 1, &value))\n        return -1;\n    if (value)\n        return Simple_set_value(self, value, NULL);\n    return 0;\n}\n\nstatic PyObject *\nSimple_get_value(CDataObject *self, void *Py_UNUSED(ignored))\n{\n    StgDictObject *dict;\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for CDataObject instances */\n    assert(dict->getfunc);\n    return dict->getfunc(self->b_ptr, self->b_size);\n}\n\nstatic PyGetSetDef Simple_getsets[] = {\n    { \"value\", (getter)Simple_get_value, (setter)Simple_set_value,\n      \"current value\", NULL },\n    { NULL, NULL }\n};\n\nstatic PyObject *\nSimple_from_outparm(PyObject *self, PyObject *args)\n{\n    if (_ctypes_simple_instance((PyObject *)Py_TYPE(self))) {\n        return Py_NewRef(self);\n    }\n    /* call stgdict->getfunc */\n    return Simple_get_value((CDataObject *)self, NULL);\n}\n\nstatic PyMethodDef Simple_methods[] = {\n    { \"__ctypes_from_outparam__\", Simple_from_outparm, METH_NOARGS, },\n    { NULL, NULL },\n};\n\nstatic int Simple_bool(CDataObject *self)\n{\n    return memcmp(self->b_ptr, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", self->b_size);\n}\n\nstatic PyNumberMethods Simple_as_number = {\n    0, /* nb_add */\n    0, /* nb_subtract */\n    0, /* nb_multiply */\n    0, /* nb_remainder */\n    0, /* nb_divmod */\n    0, /* nb_power */\n    0, /* nb_negative */\n    0, /* nb_positive */\n    0, /* nb_absolute */\n    (inquiry)Simple_bool, /* nb_bool */\n};\n\n/* \"%s(%s)\" % (self.__class__.__name__, self.value) */\nstatic PyObject *\nSimple_repr(CDataObject *self)\n{\n    PyObject *val, *result;\n\n    if (Py_TYPE(self)->tp_base != &Simple_Type) {\n        return PyUnicode_FromFormat(\"<%s object at %p>\",\n                                   Py_TYPE(self)->tp_name, self);\n    }\n\n    val = Simple_get_value(self, NULL);\n    if (val == NULL)\n        return NULL;\n\n    result = PyUnicode_FromFormat(\"%s(%R)\",\n                                  Py_TYPE(self)->tp_name, val);\n    Py_DECREF(val);\n    return result;\n}\n\nstatic PyTypeObject Simple_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes._SimpleCData\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    (reprfunc)&Simple_repr,                     /* tp_repr */\n    &Simple_as_number,                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    PyDoc_STR(\"XXX to be provided\"),            /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    Simple_methods,                             /* tp_methods */\n    0,                                          /* tp_members */\n    Simple_getsets,                             /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc)Simple_init,                      /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n/******************************************************************/\n/*\n  PyCPointer_Type\n*/\nstatic PyObject *\nPointer_item(PyObject *myself, Py_ssize_t index)\n{\n    CDataObject *self = (CDataObject *)myself;\n    Py_ssize_t size;\n    Py_ssize_t offset;\n    StgDictObject *stgdict, *itemdict;\n    PyObject *proto;\n\n    if (*(void **)self->b_ptr == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"NULL pointer access\");\n        return NULL;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for pointer object instances */\n\n    proto = stgdict->proto;\n    assert(proto);\n    itemdict = PyType_stgdict(proto);\n    assert(itemdict); /* proto is the item type of the pointer, a ctypes\n                         type, so this cannot be NULL */\n\n    size = itemdict->size;\n    offset = index * itemdict->size;\n\n    return PyCData_get(proto, stgdict->getfunc, (PyObject *)self,\n                     index, size, (*(char **)self->b_ptr) + offset);\n}\n\nstatic int\nPointer_ass_item(PyObject *myself, Py_ssize_t index, PyObject *value)\n{\n    CDataObject *self = (CDataObject *)myself;\n    Py_ssize_t size;\n    Py_ssize_t offset;\n    StgDictObject *stgdict, *itemdict;\n    PyObject *proto;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Pointer does not support item deletion\");\n        return -1;\n    }\n\n    if (*(void **)self->b_ptr == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"NULL pointer access\");\n        return -1;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for pointer instances */\n\n    proto = stgdict->proto;\n    assert(proto);\n\n    itemdict = PyType_stgdict(proto);\n    assert(itemdict); /* Cannot be NULL because the itemtype of a pointer\n                         is always a ctypes type */\n\n    size = itemdict->size;\n    offset = index * itemdict->size;\n\n    return PyCData_set((PyObject *)self, proto, stgdict->setfunc, value,\n                     index, size, (*(char **)self->b_ptr) + offset);\n}\n\nstatic PyObject *\nPointer_get_contents(CDataObject *self, void *closure)\n{\n    StgDictObject *stgdict;\n\n    if (*(void **)self->b_ptr == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"NULL pointer access\");\n        return NULL;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for pointer instances */\n    return PyCData_FromBaseObj(stgdict->proto,\n                             (PyObject *)self, 0,\n                             *(void **)self->b_ptr);\n}\n\nstatic int\nPointer_set_contents(CDataObject *self, PyObject *value, void *closure)\n{\n    StgDictObject *stgdict;\n    CDataObject *dst;\n    PyObject *keep;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Pointer does not support item deletion\");\n        return -1;\n    }\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for pointer instances */\n    assert(stgdict->proto);\n    if (!CDataObject_Check(value)) {\n        int res = PyObject_IsInstance(value, stgdict->proto);\n        if (res == -1)\n            return -1;\n        if (!res) {\n            PyErr_Format(PyExc_TypeError,\n                         \"expected %s instead of %s\",\n                         ((PyTypeObject *)(stgdict->proto))->tp_name,\n                         Py_TYPE(value)->tp_name);\n            return -1;\n        }\n    }\n\n    dst = (CDataObject *)value;\n    *(void **)self->b_ptr = dst->b_ptr;\n\n    /*\n       A Pointer instance must keep the value it points to alive.  So, a\n       pointer instance has b_length set to 2 instead of 1, and we set\n       'value' itself as the second item of the b_objects list, additionally.\n    */\n    Py_INCREF(value);\n    if (-1 == KeepRef(self, 1, value))\n        return -1;\n\n    keep = GetKeepedObjects(dst);\n    if (keep == NULL)\n        return -1;\n\n    Py_INCREF(keep);\n    return KeepRef(self, 0, keep);\n}\n\nstatic PyGetSetDef Pointer_getsets[] = {\n    { \"contents\", (getter)Pointer_get_contents,\n      (setter)Pointer_set_contents,\n      \"the object this pointer points to (read-write)\", NULL },\n    { NULL, NULL }\n};\n\nstatic int\nPointer_init(CDataObject *self, PyObject *args, PyObject *kw)\n{\n    PyObject *value = NULL;\n\n    if (!PyArg_UnpackTuple(args, \"POINTER\", 0, 1, &value))\n        return -1;\n    if (value == NULL)\n        return 0;\n    return Pointer_set_contents(self, value, NULL);\n}\n\nstatic PyObject *\nPointer_new(PyTypeObject *type, PyObject *args, PyObject *kw)\n{\n    StgDictObject *dict = PyType_stgdict((PyObject *)type);\n    if (!dict || !dict->proto) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Cannot create instance: has no _type_\");\n        return NULL;\n    }\n    return GenericPyCData_new(type, args, kw);\n}\n\nstatic PyObject *\nPointer_subscript(PyObject *myself, PyObject *item)\n{\n    CDataObject *self = (CDataObject *)myself;\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n        if (i == -1 && PyErr_Occurred())\n            return NULL;\n        return Pointer_item(myself, i);\n    }\n    else if (PySlice_Check(item)) {\n        PySliceObject *slice = (PySliceObject *)item;\n        Py_ssize_t start, stop, step;\n        PyObject *np;\n        StgDictObject *stgdict, *itemdict;\n        PyObject *proto;\n        Py_ssize_t i, len;\n        size_t cur;\n\n        /* Since pointers have no length, and we want to apply\n           different semantics to negative indices than normal\n           slicing, we have to dissect the slice object ourselves.*/\n        if (slice->step == Py_None) {\n            step = 1;\n        }\n        else {\n            step = PyNumber_AsSsize_t(slice->step,\n                                      PyExc_ValueError);\n            if (step == -1 && PyErr_Occurred())\n                return NULL;\n            if (step == 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"slice step cannot be zero\");\n                return NULL;\n            }\n        }\n        if (slice->start == Py_None) {\n            if (step < 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"slice start is required \"\n                                \"for step < 0\");\n                return NULL;\n            }\n            start = 0;\n        }\n        else {\n            start = PyNumber_AsSsize_t(slice->start,\n                                       PyExc_ValueError);\n            if (start == -1 && PyErr_Occurred())\n                return NULL;\n        }\n        if (slice->stop == Py_None) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"slice stop is required\");\n            return NULL;\n        }\n        stop = PyNumber_AsSsize_t(slice->stop,\n                                  PyExc_ValueError);\n        if (stop == -1 && PyErr_Occurred())\n            return NULL;\n        if ((step > 0 && start > stop) ||\n            (step < 0 && start < stop))\n            len = 0;\n        else if (step > 0)\n            len = (stop - start - 1) / step + 1;\n        else\n            len = (stop - start + 1) / step + 1;\n\n        stgdict = PyObject_stgdict((PyObject *)self);\n        assert(stgdict); /* Cannot be NULL for pointer instances */\n        proto = stgdict->proto;\n        assert(proto);\n        itemdict = PyType_stgdict(proto);\n        assert(itemdict);\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"c\")->getfunc) {\n            char *ptr = *(char **)self->b_ptr;\n            char *dest;\n\n            if (len <= 0)\n                return PyBytes_FromStringAndSize(\"\", 0);\n            if (step == 1) {\n                return PyBytes_FromStringAndSize(ptr + start,\n                                                 len);\n            }\n            dest = (char *)PyMem_Malloc(len);\n            if (dest == NULL)\n                return PyErr_NoMemory();\n            for (cur = start, i = 0; i < len; cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n            np = PyBytes_FromStringAndSize(dest, len);\n            PyMem_Free(dest);\n            return np;\n        }\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"u\")->getfunc) {\n            wchar_t *ptr = *(wchar_t **)self->b_ptr;\n            wchar_t *dest;\n\n            if (len <= 0)\n                return PyUnicode_New(0, 0);\n            if (step == 1) {\n                return PyUnicode_FromWideChar(ptr + start,\n                                              len);\n            }\n            dest = PyMem_New(wchar_t, len);\n            if (dest == NULL)\n                return PyErr_NoMemory();\n            for (cur = start, i = 0; i < len; cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n            np = PyUnicode_FromWideChar(dest, len);\n            PyMem_Free(dest);\n            return np;\n        }\n\n        np = PyList_New(len);\n        if (np == NULL)\n            return NULL;\n\n        for (cur = start, i = 0; i < len; cur += step, i++) {\n            PyObject *v = Pointer_item(myself, cur);\n            PyList_SET_ITEM(np, i, v);\n        }\n        return np;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Pointer indices must be integer\");\n        return NULL;\n    }\n}\n\nstatic PySequenceMethods Pointer_as_sequence = {\n    0,                                          /* inquiry sq_length; */\n    0,                                          /* binaryfunc sq_concat; */\n    0,                                          /* intargfunc sq_repeat; */\n    Pointer_item,                               /* intargfunc sq_item; */\n    0,                                          /* intintargfunc sq_slice; */\n    Pointer_ass_item,                           /* intobjargproc sq_ass_item; */\n    0,                                          /* intintobjargproc sq_ass_slice; */\n    0,                                          /* objobjproc sq_contains; */\n    /* Added in release 2.0 */\n    0,                                          /* binaryfunc sq_inplace_concat; */\n    0,                                          /* intargfunc sq_inplace_repeat; */\n};\n\nstatic PyMappingMethods Pointer_as_mapping = {\n    0,\n    Pointer_subscript,\n};\n\nstatic int\nPointer_bool(CDataObject *self)\n{\n    return (*(void **)self->b_ptr != NULL);\n}\n\nstatic PyNumberMethods Pointer_as_number = {\n    0, /* nb_add */\n    0, /* nb_subtract */\n    0, /* nb_multiply */\n    0, /* nb_remainder */\n    0, /* nb_divmod */\n    0, /* nb_power */\n    0, /* nb_negative */\n    0, /* nb_positive */\n    0, /* nb_absolute */\n    (inquiry)Pointer_bool, /* nb_bool */\n};\n\nPyTypeObject PyCPointer_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes._Pointer\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    &Pointer_as_number,                         /* tp_as_number */\n    &Pointer_as_sequence,                       /* tp_as_sequence */\n    &Pointer_as_mapping,                        /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    PyDoc_STR(\"XXX to be provided\"),            /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    Pointer_getsets,                            /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc)Pointer_init,                     /* tp_init */\n    0,                                          /* tp_alloc */\n    Pointer_new,                                /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n *  Module initialization.\n */\n\nPyDoc_STRVAR(_ctypes__doc__,\n\"Create and manipulate C compatible data types in Python.\");\n\n#ifdef MS_WIN32\n\nPyDoc_STRVAR(comerror_doc, \"Raised when a COM method call failed.\");\n\nint\ncomerror_init(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *hresult, *text, *details;\n    PyObject *a;\n    int status;\n\n    if (!_PyArg_NoKeywords(Py_TYPE(self)->tp_name, kwds))\n        return -1;\n\n    if (!PyArg_ParseTuple(args, \"OOO:COMError\", &hresult, &text, &details))\n        return -1;\n\n    a = PySequence_GetSlice(args, 1, PyTuple_GET_SIZE(args));\n    if (!a)\n        return -1;\n    status = PyObject_SetAttrString(self, \"args\", a);\n    Py_DECREF(a);\n    if (status < 0)\n        return -1;\n\n    if (PyObject_SetAttrString(self, \"hresult\", hresult) < 0)\n        return -1;\n\n    if (PyObject_SetAttrString(self, \"text\", text) < 0)\n        return -1;\n\n    if (PyObject_SetAttrString(self, \"details\", details) < 0)\n        return -1;\n\n    Py_INCREF(args);\n    Py_SETREF(((PyBaseExceptionObject *)self)->args, args);\n\n    return 0;\n}\n\nstatic int\ncomerror_clear(PyObject *self)\n{\n    return ((PyTypeObject *)PyExc_BaseException)->tp_clear(self);\n}\n\nstatic int\ncomerror_traverse(PyObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(Py_TYPE(self));\n    return ((PyTypeObject *)PyExc_BaseException)->tp_traverse(self, visit, arg);\n}\n\nstatic void\ncomerror_dealloc(PyObject *self)\n{\n    PyTypeObject *tp = Py_TYPE(self);\n    PyObject_GC_UnTrack(self);\n    (void)comerror_clear(self);\n    tp->tp_free(self);\n    Py_DECREF(tp);\n}\n\nstatic PyType_Slot comerror_slots[] = {\n    {Py_tp_doc, (void *)PyDoc_STR(comerror_doc)},\n    {Py_tp_init, comerror_init},\n    {Py_tp_traverse, comerror_traverse},\n    {Py_tp_dealloc, comerror_dealloc},\n    {Py_tp_clear, comerror_clear},\n    {0, NULL},\n};\n\nstatic PyType_Spec comerror_spec = {\n    .name = \"_ctypes.COMError\",\n    .basicsize = sizeof(PyBaseExceptionObject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n              Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_IMMUTABLETYPE),\n    .slots = comerror_slots,\n};\n\n#endif  // MS_WIN32\n\nstatic PyObject *\nstring_at(const char *ptr, int size)\n{\n    if (PySys_Audit(\"ctypes.string_at\", \"ni\", (Py_ssize_t)ptr, size) < 0) {\n        return NULL;\n    }\n    if (size == -1)\n        return PyBytes_FromStringAndSize(ptr, strlen(ptr));\n    return PyBytes_FromStringAndSize(ptr, size);\n}\n\nstatic int\ncast_check_pointertype(PyObject *arg)\n{\n    StgDictObject *dict;\n\n    if (PyCPointerTypeObject_Check(arg))\n        return 1;\n    if (PyCFuncPtrTypeObject_Check(arg))\n        return 1;\n    dict = PyType_stgdict(arg);\n    if (dict != NULL && dict->proto != NULL) {\n        if (PyUnicode_Check(dict->proto)\n            && (strchr(\"sPzUZXO\", PyUnicode_AsUTF8(dict->proto)[0]))) {\n            /* simple pointer types, c_void_p, c_wchar_p, BSTR, ... */\n            return 1;\n        }\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"cast() argument 2 must be a pointer type, not %s\",\n                 PyType_Check(arg)\n                 ? ((PyTypeObject *)arg)->tp_name\n                 : Py_TYPE(arg)->tp_name);\n    return 0;\n}\n\nstatic PyObject *\ncast(void *ptr, PyObject *src, PyObject *ctype)\n{\n    CDataObject *result;\n    if (0 == cast_check_pointertype(ctype))\n        return NULL;\n    result = (CDataObject *)_PyObject_CallNoArgs(ctype);\n    if (result == NULL)\n        return NULL;\n\n    /*\n      The casted objects '_objects' member:\n\n      It must certainly contain the source objects one.\n      It must contain the source object itself.\n     */\n    if (CDataObject_Check(src)) {\n        CDataObject *obj = (CDataObject *)src;\n        CDataObject *container;\n\n        /* PyCData_GetContainer will initialize src.b_objects, we need\n           this so it can be shared */\n        container = PyCData_GetContainer(obj);\n        if (container == NULL)\n            goto failed;\n\n        /* But we need a dictionary! */\n        if (obj->b_objects == Py_None) {\n            Py_DECREF(Py_None);\n            obj->b_objects = PyDict_New();\n            if (obj->b_objects == NULL)\n                goto failed;\n        }\n        result->b_objects = Py_XNewRef(obj->b_objects);\n        if (result->b_objects && PyDict_CheckExact(result->b_objects)) {\n            PyObject *index;\n            int rc;\n            index = PyLong_FromVoidPtr((void *)src);\n            if (index == NULL)\n                goto failed;\n            rc = PyDict_SetItem(result->b_objects, index, src);\n            Py_DECREF(index);\n            if (rc == -1)\n                goto failed;\n        }\n    }\n    /* Should we assert that result is a pointer type? */\n    memcpy(result->b_ptr, &ptr, sizeof(void *));\n    return (PyObject *)result;\n\n  failed:\n    Py_DECREF(result);\n    return NULL;\n}\n\n\nstatic PyObject *\nwstring_at(const wchar_t *ptr, int size)\n{\n    Py_ssize_t ssize = size;\n    if (PySys_Audit(\"ctypes.wstring_at\", \"nn\", (Py_ssize_t)ptr, ssize) < 0) {\n        return NULL;\n    }\n    if (ssize == -1)\n        ssize = wcslen(ptr);\n    return PyUnicode_FromWideChar(ptr, ssize);\n}\n\n\nstatic struct PyModuleDef _ctypesmodule = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = \"_ctypes\",\n    .m_doc = _ctypes__doc__,\n    .m_size = -1,\n    .m_methods = _ctypes_module_methods,\n};\n\n\nstatic int\n_ctypes_add_types(PyObject *mod)\n{\n#define TYPE_READY(TYPE) \\\n    if (PyType_Ready(TYPE) < 0) { \\\n        return -1; \\\n    }\n\n#define TYPE_READY_BASE(TYPE_EXPR, TP_BASE) \\\n    do { \\\n        PyTypeObject *type = (TYPE_EXPR); \\\n        type->tp_base = (TP_BASE); \\\n        TYPE_READY(type); \\\n    } while (0)\n\n#define MOD_ADD_TYPE(TYPE_EXPR, TP_TYPE, TP_BASE) \\\n    do { \\\n        PyTypeObject *type = (TYPE_EXPR); \\\n        Py_SET_TYPE(type, TP_TYPE); \\\n        type->tp_base = TP_BASE; \\\n        if (PyModule_AddType(mod, type) < 0) { \\\n            return -1; \\\n        } \\\n    } while (0)\n\n#define CREATE_TYPE(MOD, TP, SPEC, BASE) do {                       \\\n    PyObject *type = PyType_FromMetaclass(NULL, MOD, SPEC,          \\\n                                          (PyObject *)BASE);        \\\n    if (type == NULL) {                                             \\\n        return -1;                                                  \\\n    }                                                               \\\n    TP = (PyTypeObject *)type;                                      \\\n} while (0)\n\n    ctypes_state *st = GLOBAL_STATE();\n\n    /* Note:\n       ob_type is the metatype (the 'type'), defaults to PyType_Type,\n       tp_base is the base type, defaults to 'object' aka PyBaseObject_Type.\n    */\n    CREATE_TYPE(mod, st->PyCArg_Type, &carg_spec, NULL);\n    CREATE_TYPE(mod, st->PyCThunk_Type, &cthunk_spec, NULL);\n    TYPE_READY(&PyCData_Type);\n    /* StgDict is derived from PyDict_Type */\n    TYPE_READY_BASE(&PyCStgDict_Type, &PyDict_Type);\n\n    /*************************************************\n     *\n     * Metaclasses\n     */\n    TYPE_READY_BASE(&PyCStructType_Type, &PyType_Type);\n    TYPE_READY_BASE(&UnionType_Type, &PyType_Type);\n    TYPE_READY_BASE(&PyCPointerType_Type, &PyType_Type);\n    TYPE_READY_BASE(&PyCArrayType_Type, &PyType_Type);\n    TYPE_READY_BASE(&PyCSimpleType_Type, &PyType_Type);\n    TYPE_READY_BASE(&PyCFuncPtrType_Type, &PyType_Type);\n\n    /*************************************************\n     *\n     * Classes using a custom metaclass\n     */\n\n    MOD_ADD_TYPE(&Struct_Type, &PyCStructType_Type, &PyCData_Type);\n    MOD_ADD_TYPE(&Union_Type, &UnionType_Type, &PyCData_Type);\n    MOD_ADD_TYPE(&PyCPointer_Type, &PyCPointerType_Type, &PyCData_Type);\n    MOD_ADD_TYPE(&PyCArray_Type, &PyCArrayType_Type, &PyCData_Type);\n    MOD_ADD_TYPE(&Simple_Type, &PyCSimpleType_Type, &PyCData_Type);\n    MOD_ADD_TYPE(&PyCFuncPtr_Type, &PyCFuncPtrType_Type, &PyCData_Type);\n\n    /*************************************************\n     *\n     * Simple classes\n     */\n\n    CREATE_TYPE(mod, st->PyCField_Type, &cfield_spec, NULL);\n\n    /*************************************************\n     *\n     * Other stuff\n     */\n\n    CREATE_TYPE(mod, st->DictRemover_Type, &dictremover_spec, NULL);\n    CREATE_TYPE(mod, st->StructParam_Type, &structparam_spec, NULL);\n\n#ifdef MS_WIN32\n    CREATE_TYPE(mod, st->PyComError_Type, &comerror_spec, PyExc_Exception);\n#endif\n\n#undef TYPE_READY\n#undef TYPE_READY_BASE\n#undef MOD_ADD_TYPE\n#undef CREATE_TYPE\n    return 0;\n}\n\n\nstatic int\n_ctypes_add_objects(PyObject *mod)\n{\n#define MOD_ADD(name, expr) \\\n    do { \\\n        PyObject *obj = (expr); \\\n        if (obj == NULL) { \\\n            return -1; \\\n        } \\\n        if (PyModule_AddObjectRef(mod, name, obj) < 0) { \\\n            Py_DECREF(obj); \\\n            return -1; \\\n        } \\\n        Py_DECREF(obj); \\\n    } while (0)\n\n    MOD_ADD(\"_pointer_type_cache\", Py_NewRef(_ctypes_ptrtype_cache));\n\n#ifdef MS_WIN32\n    ctypes_state *st = GLOBAL_STATE();\n    MOD_ADD(\"COMError\", Py_NewRef(st->PyComError_Type));\n    MOD_ADD(\"FUNCFLAG_HRESULT\", PyLong_FromLong(FUNCFLAG_HRESULT));\n    MOD_ADD(\"FUNCFLAG_STDCALL\", PyLong_FromLong(FUNCFLAG_STDCALL));\n#endif\n    MOD_ADD(\"FUNCFLAG_CDECL\", PyLong_FromLong(FUNCFLAG_CDECL));\n    MOD_ADD(\"FUNCFLAG_USE_ERRNO\", PyLong_FromLong(FUNCFLAG_USE_ERRNO));\n    MOD_ADD(\"FUNCFLAG_USE_LASTERROR\", PyLong_FromLong(FUNCFLAG_USE_LASTERROR));\n    MOD_ADD(\"FUNCFLAG_PYTHONAPI\", PyLong_FromLong(FUNCFLAG_PYTHONAPI));\n    MOD_ADD(\"__version__\", PyUnicode_FromString(\"1.1.0\"));\n\n    MOD_ADD(\"_memmove_addr\", PyLong_FromVoidPtr(memmove));\n    MOD_ADD(\"_memset_addr\", PyLong_FromVoidPtr(memset));\n    MOD_ADD(\"_string_at_addr\", PyLong_FromVoidPtr(string_at));\n    MOD_ADD(\"_cast_addr\", PyLong_FromVoidPtr(cast));\n    MOD_ADD(\"_wstring_at_addr\", PyLong_FromVoidPtr(wstring_at));\n\n/* If RTLD_LOCAL is not defined (Windows!), set it to zero. */\n#if !HAVE_DECL_RTLD_LOCAL\n#  define RTLD_LOCAL 0\n#endif\n\n/* If RTLD_GLOBAL is not defined (cygwin), set it to the same value as\n   RTLD_LOCAL. */\n#if !HAVE_DECL_RTLD_GLOBAL\n#  define RTLD_GLOBAL RTLD_LOCAL\n#endif\n    MOD_ADD(\"RTLD_LOCAL\", PyLong_FromLong(RTLD_LOCAL));\n    MOD_ADD(\"RTLD_GLOBAL\", PyLong_FromLong(RTLD_GLOBAL));\n    MOD_ADD(\"CTYPES_MAX_ARGCOUNT\", PyLong_FromLong(CTYPES_MAX_ARGCOUNT));\n    MOD_ADD(\"ArgumentError\", Py_NewRef(PyExc_ArgError));\n    MOD_ADD(\"SIZEOF_TIME_T\", PyLong_FromSsize_t(SIZEOF_TIME_T));\n    return 0;\n#undef MOD_ADD\n}\n\n\nstatic int\n_ctypes_mod_exec(PyObject *mod)\n{\n    _unpickle = PyObject_GetAttrString(mod, \"_unpickle\");\n    if (_unpickle == NULL) {\n        return -1;\n    }\n\n    _ctypes_ptrtype_cache = PyDict_New();\n    if (_ctypes_ptrtype_cache == NULL) {\n        return -1;\n    }\n\n    PyExc_ArgError = PyErr_NewException(\"ctypes.ArgumentError\", NULL, NULL);\n    if (!PyExc_ArgError) {\n        return -1;\n    }\n\n    if (_ctypes_add_types(mod) < 0) {\n        return -1;\n    }\n\n    if (_ctypes_add_objects(mod) < 0) {\n        return -1;\n    }\n    return 0;\n}\n\n\nPyMODINIT_FUNC\nPyInit__ctypes(void)\n{\n    PyObject *mod = PyModule_Create(&_ctypesmodule);\n    if (!mod) {\n        return NULL;\n    }\n\n    if (_ctypes_mod_exec(mod) < 0) {\n        Py_DECREF(mod);\n        return NULL;\n    }\n    return mod;\n}\n\n/*\n Local Variables:\n compile-command: \"cd .. && python setup.py -q build -g && python setup.py -q build install --home ~\"\n End:\n*/\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-null-dereference", "taxa": [{"id": "476", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "dereference of NULL 'op'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 220, "startColumn": 12, "endColumn": 23}, "contextRegion": {"startLine": 220, "snippet": {"text": "    return ob->ob_type;\n"}}}, "logicalLocations": [{"name": "PyTuple_SET_ITEM", "fullyQualifiedName": "PyTuple_SET_ITEM", "decoratedName": "PyTuple_SET_ITEM", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4014, "startColumn": 1, "endColumn": 14}, "contextRegion": {"startLine": 4014, "snippet": {"text": "_build_result(PyObject *result, PyObject *callargs,\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "entry to '_build_result'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4021, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 4021, "snippet": {"text": "    if (callargs == NULL)\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "following 'false' branch (when 'callargs' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4023, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 4023, "snippet": {"text": "    if (result == NULL || numretvals == 0) {\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4023, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 4023, "snippet": {"text": "    if (result == NULL || numretvals == 0) {\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4027, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 4027, "snippet": {"text": "    Py_DECREF(result);\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4031, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 4031, "snippet": {"text": "    if (numretvals > 1) {\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "following 'false' branch (when 'numretvals <= 1')..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4039, "startColumn": 5, "endColumn": 10}, "contextRegion": {"startLine": 4039, "snippet": {"text": "    index = 0;\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4040, "startColumn": 26, "endColumn": 32}, "contextRegion": {"startLine": 4040, "snippet": {"text": "    for (bit = 1, i = 0; i < 32; ++i, bit <<= 1) {\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "following 'true' branch (when 'i <= 31')..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4041, "startColumn": 9, "endColumn": 17}, "contextRegion": {"startLine": 4041, "snippet": {"text": "        PyObject *v;\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4042, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 4042, "snippet": {"text": "        if (bit & inoutmask) {\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4043, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 4043, "snippet": {"text": "            v = PyTuple_GET_ITEM(callargs, i);\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4043, "startColumn": 17, "endColumn": 18}, "contextRegion": {"startLine": 4043, "snippet": {"text": "            v = PyTuple_GET_ITEM(callargs, i);\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4043, "startColumn": 13, "endColumn": 18}, "contextRegion": {"startLine": 4043, "snippet": {"text": "            v = PyTuple_GET_ITEM(callargs, i);\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4045, "startColumn": 16, "endColumn": 17}, "contextRegion": {"startLine": 4045, "snippet": {"text": "            if (numretvals == 1) {\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "following 'false' branch (when 'numretvals != 1')..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4049, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 4049, "snippet": {"text": "            PyTuple_SET_ITEM(tup, index, v);\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/_ctypes/_ctypes.c", "uriBaseId": "PWD"}, "region": {"startLine": 4049, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 4049, "snippet": {"text": "            PyTuple_SET_ITEM(tup, index, v);\n"}}}, "logicalLocations": [{"name": "_build_result", "fullyQualifiedName": "_build_result", "decoratedName": "_build_result", "kind": "function"}], "message": {"text": "calling 'PyTuple_SET_ITEM' from '_build_result'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/tupleobject.h", "uriBaseId": "PWD"}, "region": {"startLine": 32, "startColumn": 1, "endColumn": 17}, "contextRegion": {"startLine": 32, "snippet": {"text": "PyTuple_SET_ITEM(PyObject *op, Py_ssize_t index, PyObject *value) {\n"}}}, "logicalLocations": [{"name": "PyTuple_SET_ITEM", "fullyQualifiedName": "PyTuple_SET_ITEM", "decoratedName": "PyTuple_SET_ITEM", "kind": "function"}], "message": {"text": "entry to 'PyTuple_SET_ITEM'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/cpython/tupleobject.h", "uriBaseId": "PWD"}, "region": {"startLine": 33, "startColumn": 28, "endColumn": 29}, "contextRegion": {"startLine": 33, "snippet": {"text": "    PyTupleObject *tuple = _PyTuple_CAST(op);\n"}}}, "logicalLocations": [{"name": "PyTuple_SET_ITEM", "fullyQualifiedName": "PyTuple_SET_ITEM", "decoratedName": "PyTuple_SET_ITEM", "kind": "function"}], "message": {"text": "inlined call to 'Py_TYPE' from 'PyTuple_SET_ITEM'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h", "uriBaseId": "PWD"}, "region": {"startLine": 220, "startColumn": 12, "endColumn": 23}, "contextRegion": {"startLine": 220, "snippet": {"text": "    return ob->ob_type;\n"}}}, "logicalLocations": [{"name": "Py_TYPE", "fullyQualifiedName": "Py_TYPE", "decoratedName": "Py_TYPE", "kind": "function"}], "message": {"text": "dereference of NULL 'op'"}}, "kinds": ["danger"], "nestingLevel": 3}]}]}]}]}]}
