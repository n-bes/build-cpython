{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-possible-null-argument",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-possible-null-argument"}]}},
           "taxonomies": [{"name": "CWE",
                           "version": "4.7",
                           "organization": "MITRE",
                           "shortDescription": {"text": "The MITRE Common Weakness Enumeration"},
                           "taxa": [{"id": "690",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/690.html"}]}],
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}},
           "artifacts": [{"location": {"uri": "/usr/include/wchar.h"},
                          "contents": {"text": "/* Copyright (C) 1995-2024 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <https://www.gnu.org/licenses/>.  */\n\n/*\n *      ISO C99 Standard: 7.24\n *\tExtended multibyte and wide character utilities\t<wchar.h>\n */\n\n#ifndef _WCHAR_H\n#define _WCHAR_H 1\n\n#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION\n#include <bits/libc-header-start.h>\n\n/* Gather machine dependent type support.  */\n#include <bits/floatn.h>\n\n#define __need_size_t\n#define __need_wchar_t\n#define __need_NULL\n#include <stddef.h>\n\n#define __need___va_list\n#include <stdarg.h>\n\n#if defined __USE_XOPEN2K || defined __USE_XOPEN2K8\n# ifdef __GNUC__\n#  ifndef _VA_LIST_DEFINED\ntypedef __gnuc_va_list va_list;\n#   define _VA_LIST_DEFINED\n#  endif\n# else\n#  include <stdarg.h>\n# endif\n#endif\n\n#include <bits/wchar.h>\n#include <bits/types/wint_t.h>\n#include <bits/types/mbstate_t.h>\n#include <bits/types/__FILE.h>\n\n#if defined __USE_UNIX98 || defined __USE_XOPEN2K\n# include <bits/types/FILE.h>\n#endif\n#ifdef __USE_XOPEN2K8\n# include <bits/types/locale_t.h>\n#endif\n\n/* Tell the caller that we provide correct C++ prototypes.  */\n#if defined __cplusplus && __GNUC_PREREQ (4, 4)\n# define __CORRECT_ISO_CPP_WCHAR_H_PROTO\n#endif\n\n#ifndef WCHAR_MIN\n/* These constants might also be defined in <inttypes.h>.  */\n# define WCHAR_MIN __WCHAR_MIN\n# define WCHAR_MAX __WCHAR_MAX\n#endif\n\n#ifndef WEOF\n# define WEOF (0xffffffffu)\n#endif\n\n/* All versions of XPG prior to the publication of ISO C99 required\n   the bulk of <wctype.h>'s declarations to appear in this header\n   (because <wctype.h> did not exist prior to C99).  In POSIX.1-2001\n   those declarations were marked as XSI extensions; in -2008 they\n   were additionally marked as obsolescent.  _GNU_SOURCE mode\n   anticipates the removal of these declarations in the next revision\n   of POSIX.  */\n#if (defined __USE_XOPEN && !defined __USE_GNU \\\n     && !(defined __USE_XOPEN2K && !defined __USE_XOPEN2KXSI))\n# include <bits/wctype-wchar.h>\n#endif\n\n__BEGIN_DECLS\n\n/* This incomplete type is defined in <time.h> but needed here because\n   of `wcsftime'.  */\nstruct tm;\n\n\n/* Copy SRC to DEST.  */\nextern wchar_t *wcscpy (wchar_t *__restrict __dest,\n\t\t\tconst wchar_t *__restrict __src)\n     __THROW __nonnull ((1, 2));\n\n/* Copy no more than N wide-characters of SRC to DEST.  */\nextern wchar_t *wcsncpy (wchar_t *__restrict __dest,\n\t\t\t const wchar_t *__restrict __src, size_t __n)\n     __THROW __nonnull ((1, 2));\n\n#ifdef __USE_MISC\n/* Copy at most N - 1 characters from SRC to DEST.  */\nextern size_t wcslcpy (wchar_t *__restrict __dest,\n\t\t       const wchar_t *__restrict __src, size_t __n)\n  __THROW __nonnull ((1, 2)) __attr_access ((__write_only__, 1, 3));\n\n/* Append SRC to DEST, possibly with truncation to keep the total size\n   below N.  */\nextern size_t wcslcat (wchar_t *__restrict __dest,\n\t\t       const wchar_t *__restrict __src, size_t __n)\n  __THROW __nonnull ((1, 2))  __attr_access ((__read_write__, 1, 3));\n#endif\n\n/* Append SRC onto DEST.  */\nextern wchar_t *wcscat (wchar_t *__restrict __dest,\n\t\t\tconst wchar_t *__restrict __src)\n     __THROW __nonnull ((1, 2));\n/* Append no more than N wide-characters of SRC onto DEST.  */\nextern wchar_t *wcsncat (wchar_t *__restrict __dest,\n\t\t\t const wchar_t *__restrict __src, size_t __n)\n     __THROW __nonnull ((1, 2));\n\n/* Compare S1 and S2.  */\nextern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)\n     __THROW __attribute_pure__ __nonnull ((1, 2));\n/* Compare N wide-characters of S1 and S2.  */\nextern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)\n     __THROW __attribute_pure__ __nonnull ((1, 2));\n\n#ifdef __USE_XOPEN2K8\n/* Compare S1 and S2, ignoring case.  */\nextern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) __THROW;\n\n/* Compare no more than N chars of S1 and S2, ignoring case.  */\nextern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,\n\t\t\tsize_t __n) __THROW;\n\n/* Similar to the two functions above but take the information from\n   the provided locale and not the global locale.  */\nextern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,\n\t\t\t locale_t __loc) __THROW;\n\nextern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,\n\t\t\t  size_t __n, locale_t __loc) __THROW;\n#endif\n\n/* Compare S1 and S2, both interpreted as appropriate to the\n   LC_COLLATE category of the current locale.  */\nextern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) __THROW;\n/* Transform S2 into array pointed to by S1 such that if wcscmp is\n   applied to two transformed strings the result is the as applying\n   `wcscoll' to the original strings.  */\nextern size_t wcsxfrm (wchar_t *__restrict __s1,\n\t\t       const wchar_t *__restrict __s2, size_t __n) __THROW;\n\n#ifdef __USE_XOPEN2K8\n/* Similar to the two functions above but take the information from\n   the provided locale and not the global locale.  */\n\n/* Compare S1 and S2, both interpreted as appropriate to the\n   LC_COLLATE category of the given locale.  */\nextern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,\n\t\t      locale_t __loc) __THROW;\n\n/* Transform S2 into array pointed to by S1 such that if wcscmp is\n   applied to two transformed strings the result is the as applying\n   `wcscoll' to the original strings.  */\nextern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,\n\t\t\t size_t __n, locale_t __loc) __THROW;\n\n/* Duplicate S, returning an identical malloc'd string.  */\nextern wchar_t *wcsdup (const wchar_t *__s) __THROW\n  __attribute_malloc__ __attr_dealloc_free;\n#endif\n\n/* Find the first occurrence of WC in WCS.  */\n#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO\nextern \"C++\" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)\n     __THROW __asm (\"wcschr\") __attribute_pure__;\nextern \"C++\" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)\n     __THROW __asm (\"wcschr\") __attribute_pure__;\n#else\nextern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)\n     __THROW __attribute_pure__;\n#endif\n/* Find the last occurrence of WC in WCS.  */\n#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO\nextern \"C++\" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)\n     __THROW __asm (\"wcsrchr\") __attribute_pure__;\nextern \"C++\" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)\n     __THROW __asm (\"wcsrchr\") __attribute_pure__;\n#else\nextern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)\n     __THROW __attribute_pure__;\n#endif\n\n#ifdef __USE_GNU\n/* This function is similar to `wcschr'.  But it returns a pointer to\n   the closing NUL wide character in case C is not found in S.  */\nextern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)\n     __THROW __attribute_pure__;\n#endif\n\n/* Return the length of the initial segmet of WCS which\n   consists entirely of wide characters not in REJECT.  */\nextern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)\n     __THROW __attribute_pure__;\n/* Return the length of the initial segmet of WCS which\n   consists entirely of wide characters in  ACCEPT.  */\nextern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)\n     __THROW __attribute_pure__;\n/* Find the first occurrence in WCS of any character in ACCEPT.  */\n#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO\nextern \"C++\" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)\n     __THROW __asm (\"wcspbrk\") __attribute_pure__;\nextern \"C++\" const wchar_t *wcspbrk (const wchar_t *__wcs,\n\t\t\t\t     const wchar_t *__accept)\n     __THROW __asm (\"wcspbrk\") __attribute_pure__;\n#else\nextern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)\n     __THROW __attribute_pure__;\n#endif\n/* Find the first occurrence of NEEDLE in HAYSTACK.  */\n#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO\nextern \"C++\" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)\n     __THROW __asm (\"wcsstr\") __attribute_pure__;\nextern \"C++\" const wchar_t *wcsstr (const wchar_t *__haystack,\n\t\t\t\t    const wchar_t *__needle)\n     __THROW __asm (\"wcsstr\") __attribute_pure__;\n#else\nextern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)\n     __THROW __attribute_pure__;\n#endif\n\n/* Divide WCS into tokens separated by characters in DELIM.  */\nextern wchar_t *wcstok (wchar_t *__restrict __s,\n\t\t\tconst wchar_t *__restrict __delim,\n\t\t\twchar_t **__restrict __ptr) __THROW;\n\n/* Return the number of wide characters in S.  */\nextern size_t wcslen (const wchar_t *__s) __THROW __attribute_pure__;\n\n#ifdef __USE_XOPEN\n/* Another name for `wcsstr' from XPG4.  */\n# ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO\nextern \"C++\" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)\n     __THROW __asm (\"wcswcs\") __attribute_pure__;\nextern \"C++\" const wchar_t *wcswcs (const wchar_t *__haystack,\n\t\t\t\t    const wchar_t *__needle)\n     __THROW __asm (\"wcswcs\") __attribute_pure__;\n# else\nextern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)\n     __THROW __attribute_pure__;\n# endif\n#endif\n\n#ifdef __USE_XOPEN2K8\n/* Return the number of wide characters in S, but at most MAXLEN.  */\nextern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)\n     __THROW __attribute_pure__;\n#endif\n\n\n/* Search N wide characters of S for C.  */\n#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO\nextern \"C++\" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)\n     __THROW __asm (\"wmemchr\") __attribute_pure__;\nextern \"C++\" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,\n\t\t\t\t     size_t __n)\n     __THROW __asm (\"wmemchr\") __attribute_pure__;\n#else\nextern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)\n     __THROW __attribute_pure__;\n#endif\n\n/* Compare N wide characters of S1 and S2.  */\nextern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)\n     __THROW __attribute_pure__;\n\n/* Copy N wide characters of SRC to DEST.  */\nextern wchar_t *wmemcpy (wchar_t *__restrict __s1,\n\t\t\t const wchar_t *__restrict __s2, size_t __n) __THROW;\n\n/* Copy N wide characters of SRC to DEST, guaranteeing\n   correct behavior for overlapping strings.  */\nextern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)\n     __THROW;\n\n/* Set N wide characters of S to C.  */\nextern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __THROW;\n\n#ifdef __USE_GNU\n/* Copy N wide characters of SRC to DEST and return pointer to following\n   wide character.  */\nextern wchar_t *wmempcpy (wchar_t *__restrict __s1,\n\t\t\t  const wchar_t *__restrict __s2, size_t __n)\n     __THROW;\n#endif\n\n\n/* Determine whether C constitutes a valid (one-byte) multibyte\n   character.  */\nextern wint_t btowc (int __c) __THROW;\n\n/* Determine whether C corresponds to a member of the extended\n   character set whose multibyte representation is a single byte.  */\nextern int wctob (wint_t __c) __THROW;\n\n/* Determine whether PS points to an object representing the initial\n   state.  */\nextern int mbsinit (const mbstate_t *__ps) __THROW __attribute_pure__;\n\n/* Write wide character representation of multibyte character pointed\n   to by S to PWC.  */\nextern size_t mbrtowc (wchar_t *__restrict __pwc,\n\t\t       const char *__restrict __s, size_t __n,\n\t\t       mbstate_t *__restrict __p) __THROW;\n\n/* Write multibyte representation of wide character WC to S.  */\nextern size_t wcrtomb (char *__restrict __s, wchar_t __wc,\n\t\t       mbstate_t *__restrict __ps) __THROW;\n\n/* Return number of bytes in multibyte character pointed to by S.  */\nextern size_t __mbrlen (const char *__restrict __s, size_t __n,\n\t\t\tmbstate_t *__restrict __ps) __THROW;\nextern size_t mbrlen (const char *__restrict __s, size_t __n,\n\t\t      mbstate_t *__restrict __ps) __THROW;\n\n#ifdef __USE_EXTERN_INLINES\n/* Define inline function as optimization.  */\n\n/* We can use the BTOWC and WCTOB optimizations since we know that all\n   locales must use ASCII encoding for the values in the ASCII range\n   and because the wchar_t encoding is always ISO 10646.  */\nextern wint_t __btowc_alias (int __c) __asm (\"btowc\");\n__extern_inline wint_t\n__NTH (btowc (int __c))\n{ return (__builtin_constant_p (__c) && __c >= '\\0' && __c <= '\\x7f'\n\t  ? (wint_t) __c : __btowc_alias (__c)); }\n\nextern int __wctob_alias (wint_t __c) __asm (\"wctob\");\n__extern_inline int\n__NTH (wctob (wint_t __wc))\n{ return (__builtin_constant_p (__wc) && __wc >= L'\\0' && __wc <= L'\\x7f'\n\t  ? (int) __wc : __wctob_alias (__wc)); }\n\n__extern_inline size_t\n__NTH (mbrlen (const char *__restrict __s, size_t __n,\n\t       mbstate_t *__restrict __ps))\n{ return (__ps != NULL\n\t  ? mbrtowc (NULL, __s, __n, __ps) : __mbrlen (__s, __n, NULL)); }\n#endif\n\n/* Write wide character representation of multibyte character string\n   SRC to DST.  */\nextern size_t mbsrtowcs (wchar_t *__restrict __dst,\n\t\t\t const char **__restrict __src, size_t __len,\n\t\t\t mbstate_t *__restrict __ps) __THROW;\n\n/* Write multibyte character representation of wide character string\n   SRC to DST.  */\nextern size_t wcsrtombs (char *__restrict __dst,\n\t\t\t const wchar_t **__restrict __src, size_t __len,\n\t\t\t mbstate_t *__restrict __ps) __THROW;\n\n\n#ifdef\t__USE_XOPEN2K8\n/* Write wide character representation of at most NMC bytes of the\n   multibyte character string SRC to DST.  */\nextern size_t mbsnrtowcs (wchar_t *__restrict __dst,\n\t\t\t  const char **__restrict __src, size_t __nmc,\n\t\t\t  size_t __len, mbstate_t *__restrict __ps) __THROW;\n\n/* Write multibyte character representation of at most NWC characters\n   from the wide character string SRC to DST.  */\nextern size_t wcsnrtombs (char *__restrict __dst,\n\t\t\t  const wchar_t **__restrict __src,\n\t\t\t  size_t __nwc, size_t __len,\n\t\t\t  mbstate_t *__restrict __ps) __THROW;\n#endif\t/* use POSIX 2008 */\n\n\n/* The following functions are extensions found in X/Open CAE.  */\n#ifdef __USE_XOPEN\n/* Determine number of column positions required for C.  */\nextern int wcwidth (wchar_t __c) __THROW;\n\n/* Determine number of column positions required for first N wide\n   characters (or fewer if S ends before this) in S.  */\nextern int wcswidth (const wchar_t *__s, size_t __n) __THROW;\n#endif\t/* Use X/Open.  */\n\n\n/* Convert initial portion of the wide string NPTR to `double'\n   representation.  */\nextern double wcstod (const wchar_t *__restrict __nptr,\n\t\t      wchar_t **__restrict __endptr) __THROW;\n\n#ifdef __USE_ISOC99\n/* Likewise for `float' and `long double' sizes of floating-point numbers.  */\nextern float wcstof (const wchar_t *__restrict __nptr,\n\t\t     wchar_t **__restrict __endptr) __THROW;\nextern long double wcstold (const wchar_t *__restrict __nptr,\n\t\t\t    wchar_t **__restrict __endptr) __THROW;\n#endif /* C99 */\n\n#if __GLIBC_USE (IEC_60559_TYPES_EXT) && __GLIBC_USE (ISOC2X)\n/* Likewise for `_FloatN' and `_FloatNx' when support is enabled.  */\n\n# if __HAVE_FLOAT16\nextern _Float16 wcstof16 (const wchar_t *__restrict __nptr,\n\t\t\t  wchar_t **__restrict __endptr) __THROW;\n# endif\n\n# if __HAVE_FLOAT32\nextern _Float32 wcstof32 (const wchar_t *__restrict __nptr,\n\t\t\t  wchar_t **__restrict __endptr) __THROW;\n# endif\n\n# if __HAVE_FLOAT64\nextern _Float64 wcstof64 (const wchar_t *__restrict __nptr,\n\t\t\t  wchar_t **__restrict __endptr) __THROW;\n# endif\n\n# if __HAVE_FLOAT128\nextern _Float128 wcstof128 (const wchar_t *__restrict __nptr,\n\t\t\t    wchar_t **__restrict __endptr) __THROW;\n# endif\n\n# if __HAVE_FLOAT32X\nextern _Float32x wcstof32x (const wchar_t *__restrict __nptr,\n\t\t\t    wchar_t **__restrict __endptr) __THROW;\n# endif\n\n# if __HAVE_FLOAT64X\nextern _Float64x wcstof64x (const wchar_t *__restrict __nptr,\n\t\t\t    wchar_t **__restrict __endptr) __THROW;\n# endif\n\n# if __HAVE_FLOAT128X\nextern _Float128x wcstof128x (const wchar_t *__restrict __nptr,\n\t\t\t      wchar_t **__restrict __endptr) __THROW;\n# endif\n#endif /* __GLIBC_USE (IEC_60559_TYPES_EXT) && __GLIBC_USE (ISOC2X) */\n\n\n/* Convert initial portion of wide string NPTR to `long int'\n   representation.  */\nextern long int wcstol (const wchar_t *__restrict __nptr,\n\t\t\twchar_t **__restrict __endptr, int __base) __THROW;\n\n/* Convert initial portion of wide string NPTR to `unsigned long int'\n   representation.  */\nextern unsigned long int wcstoul (const wchar_t *__restrict __nptr,\n\t\t\t\t  wchar_t **__restrict __endptr, int __base)\n     __THROW;\n\n#ifdef __USE_ISOC99\n/* Convert initial portion of wide string NPTR to `long long int'\n   representation.  */\n__extension__\nextern long long int wcstoll (const wchar_t *__restrict __nptr,\n\t\t\t      wchar_t **__restrict __endptr, int __base)\n     __THROW;\n\n/* Convert initial portion of wide string NPTR to `unsigned long long int'\n   representation.  */\n__extension__\nextern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,\n\t\t\t\t\twchar_t **__restrict __endptr,\n\t\t\t\t\tint __base) __THROW;\n#endif /* ISO C99.  */\n\n#ifdef __USE_GNU\n/* Convert initial portion of wide string NPTR to `long long int'\n   representation.  */\n__extension__\nextern long long int wcstoq (const wchar_t *__restrict __nptr,\n\t\t\t     wchar_t **__restrict __endptr, int __base)\n     __THROW;\n\n/* Convert initial portion of wide string NPTR to `unsigned long long int'\n   representation.  */\n__extension__\nextern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,\n\t\t\t\t       wchar_t **__restrict __endptr,\n\t\t\t\t       int __base) __THROW;\n#endif /* Use GNU.  */\n\n/* Versions of the above functions that handle '0b' and '0B' prefixes\n   in base 0 or 2.  */\n#if __GLIBC_USE (C2X_STRTOL)\n# ifdef __REDIRECT\nextern long int __REDIRECT_NTH (wcstol, (const wchar_t *__restrict __nptr,\n\t\t\t\t\t wchar_t **__restrict __endptr,\n\t\t\t\t\t int __base), __isoc23_wcstol);\nextern unsigned long int __REDIRECT_NTH (wcstoul,\n\t\t\t\t\t (const wchar_t *__restrict __nptr,\n\t\t\t\t\t  wchar_t **__restrict __endptr,\n\t\t\t\t\t  int __base), __isoc23_wcstoul);\n__extension__\nextern long long int __REDIRECT_NTH (wcstoll,\n\t\t\t\t     (const wchar_t *__restrict __nptr,\n\t\t\t\t      wchar_t **__restrict __endptr,\n\t\t\t\t      int __base), __isoc23_wcstoll);\n__extension__\nextern unsigned long long int __REDIRECT_NTH (wcstoull,\n\t\t\t\t\t      (const wchar_t *__restrict __nptr,\n\t\t\t\t\t       wchar_t **__restrict __endptr,\n\t\t\t\t\t       int __base), __isoc23_wcstoull);\n#  ifdef __USE_GNU\n__extension__\nextern long long int __REDIRECT_NTH (wcstoq, (const wchar_t *__restrict __nptr,\n\t\t\t\t\t      wchar_t **__restrict __endptr,\n\t\t\t\t\t      int __base), __isoc23_wcstoll);\n__extension__\nextern unsigned long long int __REDIRECT_NTH (wcstouq,\n\t\t\t\t\t      (const wchar_t *__restrict __nptr,\n\t\t\t\t\t       wchar_t **__restrict __endptr,\n\t\t\t\t\t       int __base), __isoc23_wcstoull);\n#  endif\n# else\nextern long int __isoc23_wcstol (const wchar_t *__restrict __nptr,\n\t\t\t\t wchar_t **__restrict __endptr, int __base)\n     __THROW;\nextern unsigned long int __isoc23_wcstoul (const wchar_t *__restrict __nptr,\n\t\t\t\t\t   wchar_t **__restrict __endptr,\n\t\t\t\t\t   int __base)\n     __THROW;\n__extension__\nextern long long int __isoc23_wcstoll (const wchar_t *__restrict __nptr,\n\t\t\t\t       wchar_t **__restrict __endptr,\n\t\t\t\t       int __base)\n     __THROW;\n__extension__\nextern unsigned long long int __isoc23_wcstoull (const wchar_t *__restrict __nptr,\n\t\t\t\t\t\t wchar_t **__restrict __endptr,\n\t\t\t\t\t\t int __base)\n     __THROW;\n#  define wcstol __isoc23_wcstol\n#  define wcstoul __isoc23_wcstoul\n#  define wcstoll __isoc23_wcstoll\n#  define wcstoull __isoc23_wcstoull\n#  ifdef __USE_GNU\n#   define wcstoq __isoc23_wcstoll\n#   define wcstouq __isoc23_wcstoull\n#  endif\n# endif\n#endif\n\n#ifdef __USE_GNU\n/* Parallel versions of the functions above which take the locale to\n   use as an additional parameter.  These are GNU extensions inspired\n   by the POSIX.1-2008 extended locale API.  */\nextern long int wcstol_l (const wchar_t *__restrict __nptr,\n\t\t\t  wchar_t **__restrict __endptr, int __base,\n\t\t\t  locale_t __loc) __THROW;\n\nextern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,\n\t\t\t\t    wchar_t **__restrict __endptr,\n\t\t\t\t    int __base, locale_t __loc) __THROW;\n\n__extension__\nextern long long int wcstoll_l (const wchar_t *__restrict __nptr,\n\t\t\t\twchar_t **__restrict __endptr,\n\t\t\t\tint __base, locale_t __loc) __THROW;\n\n__extension__\nextern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,\n\t\t\t\t\t  wchar_t **__restrict __endptr,\n\t\t\t\t\t  int __base, locale_t __loc)\n     __THROW;\n\n/* Versions of the above functions that handle '0b' and '0B' prefixes\n   in base 0 or 2.  */\n# if __GLIBC_USE (C2X_STRTOL)\n#  ifdef __REDIRECT\nextern long int __REDIRECT_NTH (wcstol_l, (const wchar_t *__restrict __nptr,\n\t\t\t\t\t   wchar_t **__restrict __endptr,\n\t\t\t\t\t   int __base, locale_t __loc),\n\t\t\t\t__isoc23_wcstol_l);\nextern unsigned long int __REDIRECT_NTH (wcstoul_l,\n\t\t\t\t\t (const wchar_t *__restrict __nptr,\n\t\t\t\t\t  wchar_t **__restrict __endptr,\n\t\t\t\t\t  int __base, locale_t __loc),\n\t\t\t\t\t __isoc23_wcstoul_l);\n__extension__\nextern long long int __REDIRECT_NTH (wcstoll_l,\n\t\t\t\t     (const wchar_t *__restrict __nptr,\n\t\t\t\t      wchar_t **__restrict __endptr,\n\t\t\t\t      int __base, locale_t __loc),\n\t\t\t\t     __isoc23_wcstoll_l);\n__extension__\nextern unsigned long long int __REDIRECT_NTH (wcstoull_l,\n\t\t\t\t\t      (const wchar_t *__restrict __nptr,\n\t\t\t\t\t       wchar_t **__restrict __endptr,\n\t\t\t\t\t       int __base, locale_t __loc),\n\t\t\t\t\t      __isoc23_wcstoull_l);\n#  else\nextern long int __isoc23_wcstol_l (const wchar_t *__restrict __nptr,\n\t\t\t\t   wchar_t **__restrict __endptr, int __base,\n\t\t\t\t   locale_t __loc) __THROW;\nextern unsigned long int __isoc23_wcstoul_l (const wchar_t *__restrict __nptr,\n\t\t\t\t\t     wchar_t **__restrict __endptr,\n\t\t\t\t\t     int __base, locale_t __loc)\n     __THROW;\n__extension__\nextern long long int __isoc23_wcstoll_l (const wchar_t *__restrict __nptr,\n\t\t\t\t\t wchar_t **__restrict __endptr,\n\t\t\t\t\t int __base, locale_t __loc)\n     __THROW;\n__extension__\nextern unsigned long long int __isoc23_wcstoull_l (const wchar_t *__restrict __nptr,\n\t\t\t\t\t\t   wchar_t **__restrict __endptr,\n\t\t\t\t\t\t   int __base, locale_t __loc)\n     __THROW;\n#   define wcstol_l __isoc23_wcstol_l\n#   define wcstoul_l __isoc23_wcstoul_l\n#   define wcstoll_l __isoc23_wcstoll_l\n#   define wcstoull_l __isoc23_wcstoull_l\n#  endif\n# endif\n\nextern double wcstod_l (const wchar_t *__restrict __nptr,\n\t\t\twchar_t **__restrict __endptr, locale_t __loc)\n     __THROW;\n\nextern float wcstof_l (const wchar_t *__restrict __nptr,\n\t\t       wchar_t **__restrict __endptr, locale_t __loc)\n     __THROW;\n\nextern long double wcstold_l (const wchar_t *__restrict __nptr,\n\t\t\t      wchar_t **__restrict __endptr,\n\t\t\t      locale_t __loc) __THROW;\n\n# if __HAVE_FLOAT16\nextern _Float16 wcstof16_l (const wchar_t *__restrict __nptr,\n\t\t\t    wchar_t **__restrict __endptr,\n\t\t\t    locale_t __loc) __THROW;\n# endif\n\n# if __HAVE_FLOAT32\nextern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,\n\t\t\t    wchar_t **__restrict __endptr,\n\t\t\t    locale_t __loc) __THROW;\n# endif\n\n# if __HAVE_FLOAT64\nextern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,\n\t\t\t    wchar_t **__restrict __endptr,\n\t\t\t    locale_t __loc) __THROW;\n# endif\n\n# if __HAVE_FLOAT128\nextern _Float128 wcstof128_l (const wchar_t *__restrict __nptr,\n\t\t\t      wchar_t **__restrict __endptr,\n\t\t\t      locale_t __loc) __THROW;\n# endif\n\n# if __HAVE_FLOAT32X\nextern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,\n\t\t\t      wchar_t **__restrict __endptr,\n\t\t\t      locale_t __loc) __THROW;\n# endif\n\n# if __HAVE_FLOAT64X\nextern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,\n\t\t\t      wchar_t **__restrict __endptr,\n\t\t\t      locale_t __loc) __THROW;\n# endif\n\n# if __HAVE_FLOAT128X\nextern _Float128x wcstof128x_l (const wchar_t *__restrict __nptr,\n\t\t\t\twchar_t **__restrict __endptr,\n\t\t\t\tlocale_t __loc) __THROW;\n# endif\n#endif\t/* use GNU */\n\n\n#ifdef __USE_XOPEN2K8\n/* Copy SRC to DEST, returning the address of the terminating L'\\0' in\n   DEST.  */\nextern wchar_t *wcpcpy (wchar_t *__restrict __dest,\n\t\t\tconst wchar_t *__restrict __src) __THROW;\n\n/* Copy no more than N characters of SRC to DEST, returning the address of\n   the last character written into DEST.  */\nextern wchar_t *wcpncpy (wchar_t *__restrict __dest,\n\t\t\t const wchar_t *__restrict __src, size_t __n)\n     __THROW;\n#endif\n\n\n/* Wide character I/O functions.  */\n\n#if defined __USE_XOPEN2K8 || __GLIBC_USE (LIB_EXT2)\n# ifndef __attr_dealloc_fclose\n#   if defined __has_builtin\n#     if __has_builtin (__builtin_fclose)\n/* If the attribute macro hasn't been defined yet (by <stdio.h>) and\n   fclose is a built-in, use it.  */\n#      define __attr_dealloc_fclose __attr_dealloc (__builtin_fclose, 1)\n#     endif\n#   endif\n# endif\n# ifndef __attr_dealloc_fclose\n#  define __attr_dealloc_fclose /* empty */\n# endif\n\n/* Like OPEN_MEMSTREAM, but the stream is wide oriented and produces\n   a wide character string.  */\nextern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) __THROW\n  __attribute_malloc__ __attr_dealloc_fclose;\n#endif\n\n#if defined __USE_ISOC95 || defined __USE_UNIX98\n\n/* Select orientation for stream.  */\nextern int fwide (__FILE *__fp, int __mode) __THROW;\n\n\n/* Write formatted output to STREAM.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern int fwprintf (__FILE *__restrict __stream,\n\t\t     const wchar_t *__restrict __format, ...)\n     /* __attribute__ ((__format__ (__wprintf__, 2, 3))) */;\n/* Write formatted output to stdout.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern int wprintf (const wchar_t *__restrict __format, ...)\n     /* __attribute__ ((__format__ (__wprintf__, 1, 2))) */;\n/* Write formatted output of at most N characters to S.  */\nextern int swprintf (wchar_t *__restrict __s, size_t __n,\n\t\t     const wchar_t *__restrict __format, ...)\n     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 4))) */;\n\n/* Write formatted output to S from argument list ARG.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern int vfwprintf (__FILE *__restrict __s,\n\t\t      const wchar_t *__restrict __format,\n\t\t      __gnuc_va_list __arg)\n     /* __attribute__ ((__format__ (__wprintf__, 2, 0))) */;\n/* Write formatted output to stdout from argument list ARG.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern int vwprintf (const wchar_t *__restrict __format,\n\t\t     __gnuc_va_list __arg)\n     /* __attribute__ ((__format__ (__wprintf__, 1, 0))) */;\n/* Write formatted output of at most N character to S from argument\n   list ARG.  */\nextern int vswprintf (wchar_t *__restrict __s, size_t __n,\n\t\t      const wchar_t *__restrict __format,\n\t\t      __gnuc_va_list __arg)\n     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 0))) */;\n\n\n/* Read formatted input from STREAM.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern int fwscanf (__FILE *__restrict __stream,\n\t\t    const wchar_t *__restrict __format, ...)\n     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;\n/* Read formatted input from stdin.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern int wscanf (const wchar_t *__restrict __format, ...)\n     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;\n/* Read formatted input from S.  */\nextern int swscanf (const wchar_t *__restrict __s,\n\t\t    const wchar_t *__restrict __format, ...)\n     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;\n\n/* For historical reasons, the C99-compliant versions of the scanf\n   functions are at alternative names.  When __LDBL_COMPAT or\n   __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI are in effect, this is handled in\n   bits/wchar-ldbl.h.  */\n# if !__GLIBC_USE (DEPRECATED_SCANF) && !defined __LDBL_COMPAT \\\n     && __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI == 0\n#  if __GLIBC_USE (C2X_STRTOL)\n#   ifdef __REDIRECT\nextern int __REDIRECT (fwscanf, (__FILE *__restrict __stream,\n\t\t\t\t const wchar_t *__restrict __format, ...),\n\t\t       __isoc23_fwscanf)\n     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;\nextern int __REDIRECT (wscanf, (const wchar_t *__restrict __format, ...),\n\t\t       __isoc23_wscanf)\n     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;\nextern int __REDIRECT_NTH (swscanf, (const wchar_t *__restrict __s,\n\t\t\t\t     const wchar_t *__restrict __format,\n\t\t\t\t     ...), __isoc23_swscanf)\n     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;\n#   else\nextern int __isoc23_fwscanf (__FILE *__restrict __stream,\n\t\t\t     const wchar_t *__restrict __format, ...);\nextern int __isoc23_wscanf (const wchar_t *__restrict __format, ...);\nextern int __isoc23_swscanf (const wchar_t *__restrict __s,\n\t\t\t     const wchar_t *__restrict __format, ...)\n     __THROW;\n#    define fwscanf __isoc23_fwscanf\n#    define wscanf __isoc23_wscanf\n#    define swscanf __isoc23_swscanf\n#   endif\n#  else\n#   ifdef __REDIRECT\nextern int __REDIRECT (fwscanf, (__FILE *__restrict __stream,\n\t\t\t\t const wchar_t *__restrict __format, ...),\n\t\t       __isoc99_fwscanf)\n     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;\nextern int __REDIRECT (wscanf, (const wchar_t *__restrict __format, ...),\n\t\t       __isoc99_wscanf)\n     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;\nextern int __REDIRECT_NTH (swscanf, (const wchar_t *__restrict __s,\n\t\t\t\t     const wchar_t *__restrict __format,\n\t\t\t\t     ...), __isoc99_swscanf)\n     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;\n#   else\nextern int __isoc99_fwscanf (__FILE *__restrict __stream,\n\t\t\t     const wchar_t *__restrict __format, ...);\nextern int __isoc99_wscanf (const wchar_t *__restrict __format, ...);\nextern int __isoc99_swscanf (const wchar_t *__restrict __s,\n\t\t\t     const wchar_t *__restrict __format, ...)\n     __THROW;\n#    define fwscanf __isoc99_fwscanf\n#    define wscanf __isoc99_wscanf\n#    define swscanf __isoc99_swscanf\n#   endif\n#  endif\n# endif\n\n#endif /* Use ISO C95, C99 and Unix98. */\n\n#ifdef __USE_ISOC99\n/* Read formatted input from S into argument list ARG.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern int vfwscanf (__FILE *__restrict __s,\n\t\t     const wchar_t *__restrict __format,\n\t\t     __gnuc_va_list __arg)\n     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;\n/* Read formatted input from stdin into argument list ARG.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern int vwscanf (const wchar_t *__restrict __format,\n\t\t    __gnuc_va_list __arg)\n     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;\n/* Read formatted input from S into argument list ARG.  */\nextern int vswscanf (const wchar_t *__restrict __s,\n\t\t     const wchar_t *__restrict __format,\n\t\t     __gnuc_va_list __arg)\n     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;\n\n/* Same redirection as above for the v*wscanf family.  */\n# if !__GLIBC_USE (DEPRECATED_SCANF) \\\n     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \\\n     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K) \\\n     && __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI == 0\n#  if __GLIBC_USE (C2X_STRTOL)\n#   ifdef __REDIRECT\nextern int __REDIRECT (vfwscanf, (__FILE *__restrict __s,\n\t\t\t\t  const wchar_t *__restrict __format,\n\t\t\t\t  __gnuc_va_list __arg), __isoc23_vfwscanf)\n     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;\nextern int __REDIRECT (vwscanf, (const wchar_t *__restrict __format,\n\t\t\t\t __gnuc_va_list __arg), __isoc23_vwscanf)\n     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;\nextern int __REDIRECT_NTH (vswscanf, (const wchar_t *__restrict __s,\n\t\t\t\t      const wchar_t *__restrict __format,\n\t\t\t\t      __gnuc_va_list __arg), __isoc23_vswscanf)\n     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;\n#   else\nextern int __isoc23_vfwscanf (__FILE *__restrict __s,\n\t\t\t      const wchar_t *__restrict __format,\n\t\t\t      __gnuc_va_list __arg);\nextern int __isoc23_vwscanf (const wchar_t *__restrict __format,\n\t\t\t     __gnuc_va_list __arg);\nextern int __isoc23_vswscanf (const wchar_t *__restrict __s,\n\t\t\t      const wchar_t *__restrict __format,\n\t\t\t      __gnuc_va_list __arg) __THROW;\n#    define vfwscanf __isoc23_vfwscanf\n#    define vwscanf __isoc23_vwscanf\n#    define vswscanf __isoc23_vswscanf\n#   endif\n#  else\n#   ifdef __REDIRECT\nextern int __REDIRECT (vfwscanf, (__FILE *__restrict __s,\n\t\t\t\t  const wchar_t *__restrict __format,\n\t\t\t\t  __gnuc_va_list __arg), __isoc99_vfwscanf)\n     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;\nextern int __REDIRECT (vwscanf, (const wchar_t *__restrict __format,\n\t\t\t\t __gnuc_va_list __arg), __isoc99_vwscanf)\n     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;\nextern int __REDIRECT_NTH (vswscanf, (const wchar_t *__restrict __s,\n\t\t\t\t      const wchar_t *__restrict __format,\n\t\t\t\t      __gnuc_va_list __arg), __isoc99_vswscanf)\n     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;\n#   else\nextern int __isoc99_vfwscanf (__FILE *__restrict __s,\n\t\t\t      const wchar_t *__restrict __format,\n\t\t\t      __gnuc_va_list __arg);\nextern int __isoc99_vwscanf (const wchar_t *__restrict __format,\n\t\t\t     __gnuc_va_list __arg);\nextern int __isoc99_vswscanf (const wchar_t *__restrict __s,\n\t\t\t      const wchar_t *__restrict __format,\n\t\t\t      __gnuc_va_list __arg) __THROW;\n#    define vfwscanf __isoc99_vfwscanf\n#    define vwscanf __isoc99_vwscanf\n#    define vswscanf __isoc99_vswscanf\n#   endif\n#  endif\n# endif\n\n#endif /* Use ISO C99. */\n\n\n/* Read a character from STREAM.\n\n   These functions are possible cancellation points and therefore not\n   marked with __THROW.  */\nextern wint_t fgetwc (__FILE *__stream);\nextern wint_t getwc (__FILE *__stream);\n\n/* Read a character from stdin.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern wint_t getwchar (void);\n\n\n/* Write a character to STREAM.\n\n   These functions are possible cancellation points and therefore not\n   marked with __THROW.  */\nextern wint_t fputwc (wchar_t __wc, __FILE *__stream);\nextern wint_t putwc (wchar_t __wc, __FILE *__stream);\n\n/* Write a character to stdout.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern wint_t putwchar (wchar_t __wc);\n\n\n/* Get a newline-terminated wide character string of finite length\n   from STREAM.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,\n\t\t\t__FILE *__restrict __stream);\n\n/* Write a string to STREAM.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern int fputws (const wchar_t *__restrict __ws,\n\t\t   __FILE *__restrict __stream);\n\n\n/* Push a character back onto the input buffer of STREAM.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern wint_t ungetwc (wint_t __wc, __FILE *__stream);\n\n\n#ifdef __USE_GNU\n/* These are defined to be equivalent to the `char' functions defined\n   in POSIX.1:1996.\n\n   These functions are not part of POSIX and therefore no official\n   cancellation point.  But due to similarity with an POSIX interface\n   or due to the implementation they are cancellation points and\n   therefore not marked with __THROW.  */\nextern wint_t getwc_unlocked (__FILE *__stream);\nextern wint_t getwchar_unlocked (void);\n\n/* This is the wide character version of a GNU extension.\n\n   This function is not part of POSIX and therefore no official\n   cancellation point.  But due to similarity with an POSIX interface\n   or due to the implementation it is a cancellation point and\n   therefore not marked with __THROW.  */\nextern wint_t fgetwc_unlocked (__FILE *__stream);\n\n/* Faster version when locking is not necessary.\n\n   This function is not part of POSIX and therefore no official\n   cancellation point.  But due to similarity with an POSIX interface\n   or due to the implementation it is a cancellation point and\n   therefore not marked with __THROW.  */\nextern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);\n\n/* These are defined to be equivalent to the `char' functions defined\n   in POSIX.1:1996.\n\n   These functions are not part of POSIX and therefore no official\n   cancellation point.  But due to similarity with an POSIX interface\n   or due to the implementation they are cancellation points and\n   therefore not marked with __THROW.  */\nextern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);\nextern wint_t putwchar_unlocked (wchar_t __wc);\n\n\n/* This function does the same as `fgetws' but does not lock the stream.\n\n   This function is not part of POSIX and therefore no official\n   cancellation point.  But due to similarity with an POSIX interface\n   or due to the implementation it is a cancellation point and\n   therefore not marked with __THROW.  */\nextern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,\n\t\t\t\t __FILE *__restrict __stream);\n\n/* This function does the same as `fputws' but does not lock the stream.\n\n   This function is not part of POSIX and therefore no official\n   cancellation point.  But due to similarity with an POSIX interface\n   or due to the implementation it is a cancellation point and\n   therefore not marked with __THROW.  */\nextern int fputws_unlocked (const wchar_t *__restrict __ws,\n\t\t\t    __FILE *__restrict __stream);\n#endif\n\n\n/* Format TP into S according to FORMAT.\n   Write no more than MAXSIZE wide characters and return the number\n   of wide characters written, or 0 if it would exceed MAXSIZE.  */\nextern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,\n\t\t\tconst wchar_t *__restrict __format,\n\t\t\tconst struct tm *__restrict __tp) __THROW;\n\n# ifdef __USE_GNU\n/* Similar to `wcsftime' but takes the information from\n   the provided locale and not the global locale.  */\nextern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,\n\t\t\t  const wchar_t *__restrict __format,\n\t\t\t  const struct tm *__restrict __tp,\n\t\t\t  locale_t __loc) __THROW;\n# endif\n\n/* Define some macros helping to catch buffer overflows.  */\n#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function\n/* Declare all functions from bits/wchar2-decl.h first.  */\n# include <bits/wchar2-decl.h>\n#endif\n\n/* The following headers provide asm redirections.  These redirections must\n   appear before the first usage of these functions, e.g. in bits/wchar.h.  */\n#if defined __LDBL_COMPAT || __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI == 1\n# include <bits/wchar-ldbl.h>\n#endif\n\n#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function\n/* Now include the function definitions and redirects too.  */\n# include <bits/wchar2.h>\n#endif\n\n__END_DECLS\n\n#endif /* wchar.h  */\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Programs/_testembed.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_BUILD_CORE_MODULE\n#  define Py_BUILD_CORE_MODULE\n#endif\n\n/* Always enable assertion (even in release mode) */\n#undef NDEBUG\n\n#include <Python.h>\n#include \"pycore_initconfig.h\"    // _PyConfig_InitCompatConfig()\n#include \"pycore_runtime.h\"       // _PyRuntime\n#include \"pycore_import.h\"        // _PyImport_FrozenBootstrap\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>               // putenv()\n#include <wchar.h>\n\nint main_argc;\nchar **main_argv;\n\n/*********************************************************\n * Embedded interpreter tests that need a custom exe\n *\n * Executed via Lib/test/test_embed.py\n *********************************************************/\n\n// Use to display the usage\n#define PROGRAM \"test_embed\"\n\n/* Use path starting with \"./\" avoids a search along the PATH */\n#define PROGRAM_NAME L\"./_testembed\"\n\n#define INIT_LOOPS 4\n\n// Ignore Py_DEPRECATED() compiler warnings: deprecated functions are\n// tested on purpose here.\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n\n\nstatic void error(const char *msg)\n{\n    fprintf(stderr, \"ERROR: %s\\n\", msg);\n    fflush(stderr);\n}\n\n\nstatic void config_set_string(PyConfig *config, wchar_t **config_str, const wchar_t *str)\n{\n    PyStatus status = PyConfig_SetString(config, config_str, str);\n    if (PyStatus_Exception(status)) {\n        PyConfig_Clear(config);\n        Py_ExitStatusException(status);\n    }\n}\n\n\nstatic void config_set_program_name(PyConfig *config)\n{\n    const wchar_t *program_name = PROGRAM_NAME;\n    config_set_string(config, &config->program_name, program_name);\n}\n\n\nstatic void init_from_config_clear(PyConfig *config)\n{\n    PyStatus status = Py_InitializeFromConfig(config);\n    PyConfig_Clear(config);\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n}\n\n\nstatic void _testembed_Py_InitializeFromConfig(void)\n{\n    PyConfig config;\n    _PyConfig_InitCompatConfig(&config);\n    config_set_program_name(&config);\n    init_from_config_clear(&config);\n}\n\nstatic void _testembed_Py_Initialize(void)\n{\n   Py_SetProgramName(PROGRAM_NAME);\n   Py_Initialize();\n}\n\n\n/*****************************************************\n * Test repeated initialisation and subinterpreters\n *****************************************************/\n\nstatic void print_subinterp(void)\n{\n    /* Output information about the interpreter in the format\n       expected in Lib/test/test_capi.py (test_subinterps). */\n    PyThreadState *ts = PyThreadState_Get();\n    PyInterpreterState *interp = ts->interp;\n    int64_t id = PyInterpreterState_GetID(interp);\n    printf(\"interp %\" PRId64 \" <0x%\" PRIXPTR \">, thread state <0x%\" PRIXPTR \">: \",\n            id, (uintptr_t)interp, (uintptr_t)ts);\n    fflush(stdout);\n    PyRun_SimpleString(\n        \"import sys;\"\n        \"print('id(modules) =', id(sys.modules));\"\n        \"sys.stdout.flush()\"\n    );\n}\n\nstatic int test_repeated_init_and_subinterpreters(void)\n{\n    PyThreadState *mainstate, *substate;\n    PyGILState_STATE gilstate;\n\n    for (int i=1; i <= INIT_LOOPS; i++) {\n        printf(\"--- Pass %d ---\\n\", i);\n        _testembed_Py_InitializeFromConfig();\n        mainstate = PyThreadState_Get();\n\n        PyEval_ReleaseThread(mainstate);\n\n        gilstate = PyGILState_Ensure();\n        print_subinterp();\n        PyThreadState_Swap(NULL);\n\n        for (int j=0; j<3; j++) {\n            substate = Py_NewInterpreter();\n            print_subinterp();\n            Py_EndInterpreter(substate);\n        }\n\n        PyThreadState_Swap(mainstate);\n        print_subinterp();\n        PyGILState_Release(gilstate);\n\n        PyEval_RestoreThread(mainstate);\n        Py_Finalize();\n    }\n    return 0;\n}\n\n#define EMBEDDED_EXT_NAME \"embedded_ext\"\n\nstatic PyModuleDef embedded_ext = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = EMBEDDED_EXT_NAME,\n    .m_size = 0,\n};\n\nstatic PyObject*\nPyInit_embedded_ext(void)\n{\n    return PyModule_Create(&embedded_ext);\n}\n\n/****************************************************************************\n * Call Py_Initialize()/Py_Finalize() multiple times and execute Python code\n ***************************************************************************/\n\n// Used by bpo-46417 to test that structseq types used by the sys module are\n// cleared properly and initialized again properly when Python is finalized\n// multiple times.\nstatic int test_repeated_init_exec(void)\n{\n    if (main_argc < 3) {\n        fprintf(stderr, \"usage: %s test_repeated_init_exec CODE\\n\", PROGRAM);\n        exit(1);\n    }\n    const char *code = main_argv[2];\n\n    for (int i=1; i <= INIT_LOOPS; i++) {\n        fprintf(stderr, \"--- Loop #%d ---\\n\", i);\n        fflush(stderr);\n\n        _testembed_Py_InitializeFromConfig();\n        int err = PyRun_SimpleString(code);\n        Py_Finalize();\n        if (err) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/****************************************************************************\n * Test the Py_Initialize(Ex) convenience/compatibility wrappers\n ***************************************************************************/\n// This is here to help ensure there are no wrapper resource leaks (gh-96853)\nstatic int test_repeated_simple_init(void)\n{\n    for (int i=1; i <= INIT_LOOPS; i++) {\n        fprintf(stderr, \"--- Loop #%d ---\\n\", i);\n        fflush(stderr);\n\n        _testembed_Py_Initialize();\n        Py_Finalize();\n        printf(\"Finalized\\n\"); // Give test_embed some output to check\n    }\n    return 0;\n}\n\n\n/*****************************************************\n * Test forcing a particular IO encoding\n *****************************************************/\n\nstatic void check_stdio_details(const char *encoding, const char * errors)\n{\n    /* Output info for the test case to check */\n    if (encoding) {\n        printf(\"Expected encoding: %s\\n\", encoding);\n    } else {\n        printf(\"Expected encoding: default\\n\");\n    }\n    if (errors) {\n        printf(\"Expected errors: %s\\n\", errors);\n    } else {\n        printf(\"Expected errors: default\\n\");\n    }\n    fflush(stdout);\n    /* Force the given IO encoding */\n    Py_SetStandardStreamEncoding(encoding, errors);\n    _testembed_Py_InitializeFromConfig();\n    PyRun_SimpleString(\n        \"import sys;\"\n        \"print('stdin: {0.encoding}:{0.errors}'.format(sys.stdin));\"\n        \"print('stdout: {0.encoding}:{0.errors}'.format(sys.stdout));\"\n        \"print('stderr: {0.encoding}:{0.errors}'.format(sys.stderr));\"\n        \"sys.stdout.flush()\"\n    );\n    Py_Finalize();\n}\n\nstatic int test_forced_io_encoding(void)\n{\n    /* Check various combinations */\n    printf(\"--- Use defaults ---\\n\");\n    check_stdio_details(NULL, NULL);\n    printf(\"--- Set errors only ---\\n\");\n    check_stdio_details(NULL, \"ignore\");\n    printf(\"--- Set encoding only ---\\n\");\n    check_stdio_details(\"iso8859-1\", NULL);\n    printf(\"--- Set encoding and errors ---\\n\");\n    check_stdio_details(\"iso8859-1\", \"replace\");\n\n    /* Check calling after initialization fails */\n    Py_Initialize();\n\n    if (Py_SetStandardStreamEncoding(NULL, NULL) == 0) {\n        printf(\"Unexpected success calling Py_SetStandardStreamEncoding\");\n    }\n    Py_Finalize();\n    return 0;\n}\n\n/*********************************************************\n * Test parts of the C-API that work before initialization\n *********************************************************/\n\n/* The pre-initialization tests tend to break by segfaulting, so explicitly\n * flushed progress messages make the broken API easier to find when they fail.\n */\n#define _Py_EMBED_PREINIT_CHECK(msg) \\\n    do {printf(msg); fflush(stdout);} while (0);\n\nstatic int test_pre_initialization_api(void)\n{\n    /* the test doesn't support custom memory allocators */\n    putenv(\"PYTHONMALLOC=\");\n\n    /* Leading \"./\" ensures getpath.c can still find the standard library */\n    _Py_EMBED_PREINIT_CHECK(\"Checking Py_DecodeLocale\\n\");\n    wchar_t *program = Py_DecodeLocale(\"./spam\", NULL);\n    if (program == NULL) {\n        fprintf(stderr, \"Fatal error: cannot decode program name\\n\");\n        return 1;\n    }\n    _Py_EMBED_PREINIT_CHECK(\"Checking Py_SetProgramName\\n\");\n    Py_SetProgramName(program);\n\n    _Py_EMBED_PREINIT_CHECK(\"Initializing interpreter\\n\");\n    Py_Initialize();\n    _Py_EMBED_PREINIT_CHECK(\"Check sys module contents\\n\");\n    PyRun_SimpleString(\"import sys; \"\n                       \"print('sys.executable:', sys.executable)\");\n    _Py_EMBED_PREINIT_CHECK(\"Finalizing interpreter\\n\");\n    Py_Finalize();\n\n    _Py_EMBED_PREINIT_CHECK(\"Freeing memory allocated by Py_DecodeLocale\\n\");\n    PyMem_RawFree(program);\n    return 0;\n}\n\n\n/* bpo-33042: Ensure embedding apps can predefine sys module options */\nstatic int test_pre_initialization_sys_options(void)\n{\n    /* We allocate a couple of the options dynamically, and then delete\n     * them before calling Py_Initialize. This ensures the interpreter isn't\n     * relying on the caller to keep the passed in strings alive.\n     */\n    const wchar_t *static_warnoption = L\"once\";\n    const wchar_t *static_xoption = L\"also_not_an_option=2\";\n    size_t warnoption_len = wcslen(static_warnoption);\n    size_t xoption_len = wcslen(static_xoption);\n    wchar_t *dynamic_once_warnoption = \\\n             (wchar_t *) calloc(warnoption_len+1, sizeof(wchar_t));\n    wchar_t *dynamic_xoption = \\\n             (wchar_t *) calloc(xoption_len+1, sizeof(wchar_t));\n    wcsncpy(dynamic_once_warnoption, static_warnoption, warnoption_len+1);\n    wcsncpy(dynamic_xoption, static_xoption, xoption_len+1);\n\n    _Py_EMBED_PREINIT_CHECK(\"Checking PySys_AddWarnOption\\n\");\n    PySys_AddWarnOption(L\"default\");\n    _Py_EMBED_PREINIT_CHECK(\"Checking PySys_ResetWarnOptions\\n\");\n    PySys_ResetWarnOptions();\n    _Py_EMBED_PREINIT_CHECK(\"Checking PySys_AddWarnOption linked list\\n\");\n    PySys_AddWarnOption(dynamic_once_warnoption);\n    PySys_AddWarnOption(L\"module\");\n    PySys_AddWarnOption(L\"default\");\n    _Py_EMBED_PREINIT_CHECK(\"Checking PySys_AddXOption\\n\");\n    PySys_AddXOption(L\"not_an_option=1\");\n    PySys_AddXOption(dynamic_xoption);\n\n    /* Delete the dynamic options early */\n    free(dynamic_once_warnoption);\n    dynamic_once_warnoption = NULL;\n    free(dynamic_xoption);\n    dynamic_xoption = NULL;\n\n    _Py_EMBED_PREINIT_CHECK(\"Initializing interpreter\\n\");\n    _testembed_Py_InitializeFromConfig();\n    _Py_EMBED_PREINIT_CHECK(\"Check sys module contents\\n\");\n    PyRun_SimpleString(\"import sys; \"\n                       \"print('sys.warnoptions:', sys.warnoptions); \"\n                       \"print('sys._xoptions:', sys._xoptions); \"\n                       \"warnings = sys.modules['warnings']; \"\n                       \"latest_filters = [f[0] for f in warnings.filters[:3]]; \"\n                       \"print('warnings.filters[:3]:', latest_filters)\");\n    _Py_EMBED_PREINIT_CHECK(\"Finalizing interpreter\\n\");\n    Py_Finalize();\n\n    return 0;\n}\n\n\n/* bpo-20891: Avoid race condition when initialising the GIL */\nstatic void bpo20891_thread(void *lockp)\n{\n    PyThread_type_lock lock = *((PyThread_type_lock*)lockp);\n\n    PyGILState_STATE state = PyGILState_Ensure();\n    if (!PyGILState_Check()) {\n        error(\"PyGILState_Check failed!\");\n        abort();\n    }\n\n    PyGILState_Release(state);\n\n    PyThread_release_lock(lock);\n}\n\nstatic int test_bpo20891(void)\n{\n    /* the test doesn't support custom memory allocators */\n    putenv(\"PYTHONMALLOC=\");\n\n    /* bpo-20891: Calling PyGILState_Ensure in a non-Python thread must not\n       crash. */\n    PyThread_type_lock lock = PyThread_allocate_lock();\n    if (!lock) {\n        error(\"PyThread_allocate_lock failed!\");\n        return 1;\n    }\n\n    _testembed_Py_InitializeFromConfig();\n\n    unsigned long thrd = PyThread_start_new_thread(bpo20891_thread, &lock);\n    if (thrd == PYTHREAD_INVALID_THREAD_ID) {\n        error(\"PyThread_start_new_thread failed!\");\n        return 1;\n    }\n    PyThread_acquire_lock(lock, WAIT_LOCK);\n\n    Py_BEGIN_ALLOW_THREADS\n    /* wait until the thread exit */\n    PyThread_acquire_lock(lock, WAIT_LOCK);\n    Py_END_ALLOW_THREADS\n\n    PyThread_free_lock(lock);\n\n    Py_Finalize();\n\n    return 0;\n}\n\nstatic int test_initialize_twice(void)\n{\n    _testembed_Py_InitializeFromConfig();\n\n    /* bpo-33932: Calling Py_Initialize() twice should do nothing\n     * (and not crash!). */\n    Py_Initialize();\n\n    Py_Finalize();\n\n    return 0;\n}\n\nstatic int test_initialize_pymain(void)\n{\n    wchar_t *argv[] = {L\"PYTHON\", L\"-c\",\n                       (L\"import sys; \"\n                        L\"print(f'Py_Main() after Py_Initialize: \"\n                        L\"sys.argv={sys.argv}')\"),\n                       L\"arg2\"};\n    _testembed_Py_InitializeFromConfig();\n\n    /* bpo-34008: Calling Py_Main() after Py_Initialize() must not crash */\n    Py_Main(Py_ARRAY_LENGTH(argv), argv);\n\n    Py_Finalize();\n\n    return 0;\n}\n\n\nstatic void\ndump_config(void)\n{\n    (void) PyRun_SimpleStringFlags(\n        \"import _testinternalcapi, json; \"\n        \"print(json.dumps(_testinternalcapi.get_configs()))\",\n        0);\n}\n\n\nstatic int test_init_initialize_config(void)\n{\n    _testembed_Py_InitializeFromConfig();\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic void config_set_argv(PyConfig *config, Py_ssize_t argc, wchar_t * const *argv)\n{\n    PyStatus status = PyConfig_SetArgv(config, argc, argv);\n    if (PyStatus_Exception(status)) {\n        PyConfig_Clear(config);\n        Py_ExitStatusException(status);\n    }\n}\n\n\nstatic void\nconfig_set_wide_string_list(PyConfig *config, PyWideStringList *list,\n                            Py_ssize_t length, wchar_t **items)\n{\n    PyStatus status = PyConfig_SetWideStringList(config, list, length, items);\n    if (PyStatus_Exception(status)) {\n        PyConfig_Clear(config);\n        Py_ExitStatusException(status);\n    }\n}\n\n\nstatic int check_init_compat_config(int preinit)\n{\n    PyStatus status;\n\n    if (preinit) {\n        PyPreConfig preconfig;\n        _PyPreConfig_InitCompatConfig(&preconfig);\n\n        status = Py_PreInitialize(&preconfig);\n        if (PyStatus_Exception(status)) {\n            Py_ExitStatusException(status);\n        }\n    }\n\n    PyConfig config;\n    _PyConfig_InitCompatConfig(&config);\n\n    config_set_program_name(&config);\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_preinit_compat_config(void)\n{\n    return check_init_compat_config(1);\n}\n\n\nstatic int test_init_compat_config(void)\n{\n    return check_init_compat_config(0);\n}\n\n\nstatic int test_init_global_config(void)\n{\n    /* FIXME: test Py_IgnoreEnvironmentFlag */\n\n    putenv(\"PYTHONUTF8=0\");\n    Py_UTF8Mode = 1;\n\n    /* Test initialization from global configuration variables (Py_xxx) */\n    Py_SetProgramName(L\"./globalvar\");\n\n    /* Py_IsolatedFlag is not tested */\n    Py_NoSiteFlag = 1;\n    Py_BytesWarningFlag = 1;\n\n    putenv(\"PYTHONINSPECT=\");\n    Py_InspectFlag = 1;\n\n    putenv(\"PYTHONOPTIMIZE=0\");\n    Py_InteractiveFlag = 1;\n\n    putenv(\"PYTHONDEBUG=0\");\n    Py_OptimizeFlag = 2;\n\n    /* Py_DebugFlag is not tested */\n\n    putenv(\"PYTHONDONTWRITEBYTECODE=\");\n    Py_DontWriteBytecodeFlag = 1;\n\n    putenv(\"PYTHONVERBOSE=0\");\n    Py_VerboseFlag = 1;\n\n    Py_QuietFlag = 1;\n    Py_NoUserSiteDirectory = 1;\n\n    putenv(\"PYTHONUNBUFFERED=\");\n    Py_UnbufferedStdioFlag = 1;\n\n    Py_FrozenFlag = 1;\n\n    /* FIXME: test Py_LegacyWindowsFSEncodingFlag */\n    /* FIXME: test Py_LegacyWindowsStdioFlag */\n\n    Py_Initialize();\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_init_from_config(void)\n{\n    PyPreConfig preconfig;\n    _PyPreConfig_InitCompatConfig(&preconfig);\n\n    putenv(\"PYTHONMALLOC=malloc_debug\");\n    preconfig.allocator = PYMEM_ALLOCATOR_MALLOC;\n\n    putenv(\"PYTHONUTF8=0\");\n    Py_UTF8Mode = 0;\n    preconfig.utf8_mode = 1;\n\n    PyStatus status = Py_PreInitialize(&preconfig);\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n\n    PyConfig config;\n    _PyConfig_InitCompatConfig(&config);\n\n    config.install_signal_handlers = 0;\n\n    /* FIXME: test use_environment */\n\n    putenv(\"PYTHONHASHSEED=42\");\n    config.use_hash_seed = 1;\n    config.hash_seed = 123;\n\n    /* dev_mode=1 is tested in test_init_dev_mode() */\n\n    putenv(\"PYTHONFAULTHANDLER=\");\n    config.faulthandler = 1;\n\n    putenv(\"PYTHONTRACEMALLOC=0\");\n    config.tracemalloc = 2;\n\n    putenv(\"PYTHONPROFILEIMPORTTIME=0\");\n    config.import_time = 1;\n\n    putenv(\"PYTHONNODEBUGRANGES=0\");\n    config.code_debug_ranges = 0;\n\n    config.show_ref_count = 1;\n    /* FIXME: test dump_refs: bpo-34223 */\n\n    putenv(\"PYTHONMALLOCSTATS=0\");\n    config.malloc_stats = 1;\n\n    putenv(\"PYTHONPYCACHEPREFIX=env_pycache_prefix\");\n    config_set_string(&config, &config.pycache_prefix, L\"conf_pycache_prefix\");\n\n    Py_SetProgramName(L\"./globalvar\");\n    config_set_string(&config, &config.program_name, L\"./conf_program_name\");\n\n    wchar_t* argv[] = {\n        L\"python3\",\n        L\"-W\",\n        L\"cmdline_warnoption\",\n        L\"-X\",\n        L\"cmdline_xoption\",\n        L\"-c\",\n        L\"pass\",\n        L\"arg2\",\n    };\n    config_set_argv(&config, Py_ARRAY_LENGTH(argv), argv);\n    config.parse_argv = 1;\n\n    wchar_t* xoptions[3] = {\n        L\"config_xoption1=3\",\n        L\"config_xoption2=\",\n        L\"config_xoption3\",\n    };\n    config_set_wide_string_list(&config, &config.xoptions,\n                                Py_ARRAY_LENGTH(xoptions), xoptions);\n\n    wchar_t* warnoptions[1] = {\n        L\"config_warnoption\",\n    };\n    config_set_wide_string_list(&config, &config.warnoptions,\n                                Py_ARRAY_LENGTH(warnoptions), warnoptions);\n\n    /* FIXME: test pythonpath_env */\n    /* FIXME: test home */\n    /* FIXME: test path config: module_search_path .. dll_path */\n\n    putenv(\"PYTHONPLATLIBDIR=env_platlibdir\");\n    status = PyConfig_SetBytesString(&config, &config.platlibdir, \"my_platlibdir\");\n    if (PyStatus_Exception(status)) {\n        PyConfig_Clear(&config);\n        Py_ExitStatusException(status);\n    }\n\n    putenv(\"PYTHONVERBOSE=0\");\n    Py_VerboseFlag = 0;\n    config.verbose = 1;\n\n    Py_NoSiteFlag = 0;\n    config.site_import = 0;\n\n    Py_BytesWarningFlag = 0;\n    config.bytes_warning = 1;\n\n    putenv(\"PYTHONINSPECT=\");\n    Py_InspectFlag = 0;\n    config.inspect = 1;\n\n    Py_InteractiveFlag = 0;\n    config.interactive = 1;\n\n    putenv(\"PYTHONOPTIMIZE=0\");\n    Py_OptimizeFlag = 1;\n    config.optimization_level = 2;\n\n    /* FIXME: test parser_debug */\n\n    putenv(\"PYTHONDONTWRITEBYTECODE=\");\n    Py_DontWriteBytecodeFlag = 0;\n    config.write_bytecode = 0;\n\n    Py_QuietFlag = 0;\n    config.quiet = 1;\n\n    config.configure_c_stdio = 1;\n\n    putenv(\"PYTHONUNBUFFERED=\");\n    Py_UnbufferedStdioFlag = 0;\n    config.buffered_stdio = 0;\n\n    putenv(\"PYTHONIOENCODING=cp424\");\n    Py_SetStandardStreamEncoding(\"ascii\", \"ignore\");\n#ifdef MS_WINDOWS\n    /* Py_SetStandardStreamEncoding() sets Py_LegacyWindowsStdioFlag to 1.\n       Force it to 0 through the config. */\n    config.legacy_windows_stdio = 0;\n#endif\n    config_set_string(&config, &config.stdio_encoding, L\"iso8859-1\");\n    config_set_string(&config, &config.stdio_errors, L\"replace\");\n\n    putenv(\"PYTHONNOUSERSITE=\");\n    Py_NoUserSiteDirectory = 0;\n    config.user_site_directory = 0;\n\n    config_set_string(&config, &config.check_hash_pycs_mode, L\"always\");\n\n    Py_FrozenFlag = 0;\n    config.pathconfig_warnings = 0;\n\n    config.safe_path = 1;\n\n    putenv(\"PYTHONINTMAXSTRDIGITS=6666\");\n    config.int_max_str_digits = 31337;\n\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int check_init_parse_argv(int parse_argv)\n{\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    config.parse_argv = parse_argv;\n\n    wchar_t* argv[] = {\n        L\"./argv0\",\n        L\"-E\",\n        L\"-c\",\n        L\"pass\",\n        L\"arg1\",\n        L\"-v\",\n        L\"arg3\",\n    };\n    config_set_argv(&config, Py_ARRAY_LENGTH(argv), argv);\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_init_parse_argv(void)\n{\n    return check_init_parse_argv(1);\n}\n\n\nstatic int test_init_dont_parse_argv(void)\n{\n    return check_init_parse_argv(0);\n}\n\n\nstatic void set_most_env_vars(void)\n{\n    putenv(\"PYTHONHASHSEED=42\");\n    putenv(\"PYTHONMALLOC=malloc\");\n    putenv(\"PYTHONTRACEMALLOC=2\");\n    putenv(\"PYTHONPROFILEIMPORTTIME=1\");\n    putenv(\"PYTHONNODEBUGRANGES=1\");\n    putenv(\"PYTHONMALLOCSTATS=1\");\n    putenv(\"PYTHONUTF8=1\");\n    putenv(\"PYTHONVERBOSE=1\");\n    putenv(\"PYTHONINSPECT=1\");\n    putenv(\"PYTHONOPTIMIZE=2\");\n    putenv(\"PYTHONDONTWRITEBYTECODE=1\");\n    putenv(\"PYTHONUNBUFFERED=1\");\n    putenv(\"PYTHONPYCACHEPREFIX=env_pycache_prefix\");\n    putenv(\"PYTHONNOUSERSITE=1\");\n    putenv(\"PYTHONFAULTHANDLER=1\");\n    putenv(\"PYTHONIOENCODING=iso8859-1:replace\");\n    putenv(\"PYTHONPLATLIBDIR=env_platlibdir\");\n    putenv(\"PYTHONSAFEPATH=1\");\n    putenv(\"PYTHONINTMAXSTRDIGITS=4567\");\n}\n\n\nstatic void set_all_env_vars(void)\n{\n    set_most_env_vars();\n\n    putenv(\"PYTHONWARNINGS=EnvVar\");\n    putenv(\"PYTHONPATH=/my/path\");\n}\n\n\nstatic int test_init_compat_env(void)\n{\n    /* Test initialization from environment variables */\n    Py_IgnoreEnvironmentFlag = 0;\n    set_all_env_vars();\n    _testembed_Py_InitializeFromConfig();\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_init_python_env(void)\n{\n    set_all_env_vars();\n\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    config_set_program_name(&config);\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic void set_all_env_vars_dev_mode(void)\n{\n    putenv(\"PYTHONMALLOC=\");\n    putenv(\"PYTHONFAULTHANDLER=\");\n    putenv(\"PYTHONDEVMODE=1\");\n}\n\n\nstatic int test_init_env_dev_mode(void)\n{\n    /* Test initialization from environment variables */\n    Py_IgnoreEnvironmentFlag = 0;\n    set_all_env_vars_dev_mode();\n    _testembed_Py_InitializeFromConfig();\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_init_env_dev_mode_alloc(void)\n{\n    /* Test initialization from environment variables */\n    Py_IgnoreEnvironmentFlag = 0;\n    set_all_env_vars_dev_mode();\n    putenv(\"PYTHONMALLOC=malloc\");\n    _testembed_Py_InitializeFromConfig();\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_init_isolated_flag(void)\n{\n    /* Test PyConfig.isolated=1 */\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    Py_IsolatedFlag = 0;\n    config.isolated = 1;\n    // These options are set to 1 by isolated=1\n    config.safe_path = 0;\n    config.use_environment = 1;\n    config.user_site_directory = 1;\n\n    config_set_program_name(&config);\n    set_all_env_vars();\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\n/* PyPreConfig.isolated=1, PyConfig.isolated=0 */\nstatic int test_preinit_isolated1(void)\n{\n    PyPreConfig preconfig;\n    _PyPreConfig_InitCompatConfig(&preconfig);\n\n    preconfig.isolated = 1;\n\n    PyStatus status = Py_PreInitialize(&preconfig);\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n\n    PyConfig config;\n    _PyConfig_InitCompatConfig(&config);\n\n    config_set_program_name(&config);\n    set_all_env_vars();\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\n/* PyPreConfig.isolated=0, PyConfig.isolated=1 */\nstatic int test_preinit_isolated2(void)\n{\n    PyPreConfig preconfig;\n    _PyPreConfig_InitCompatConfig(&preconfig);\n\n    preconfig.isolated = 0;\n\n    PyStatus status = Py_PreInitialize(&preconfig);\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n\n    /* Test PyConfig.isolated=1 */\n    PyConfig config;\n    _PyConfig_InitCompatConfig(&config);\n\n    Py_IsolatedFlag = 0;\n    config.isolated = 1;\n\n    config_set_program_name(&config);\n    set_all_env_vars();\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_preinit_dont_parse_argv(void)\n{\n    PyPreConfig preconfig;\n    PyPreConfig_InitIsolatedConfig(&preconfig);\n\n    preconfig.isolated = 0;\n\n    /* -X dev must be ignored by isolated preconfiguration */\n    wchar_t *argv[] = {L\"python3\",\n                       L\"-E\",\n                       L\"-I\",\n                       L\"-P\",\n                       L\"-X\", L\"dev\",\n                       L\"-X\", L\"utf8\",\n                       L\"script.py\"};\n    PyStatus status = Py_PreInitializeFromArgs(&preconfig,\n                                               Py_ARRAY_LENGTH(argv), argv);\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n\n    PyConfig config;\n    PyConfig_InitIsolatedConfig(&config);\n\n    config.isolated = 0;\n\n    /* Pre-initialize implicitly using argv: make sure that -X dev\n       is used to configure the allocation in preinitialization */\n    config_set_argv(&config, Py_ARRAY_LENGTH(argv), argv);\n    config_set_program_name(&config);\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_preinit_parse_argv(void)\n{\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    /* Pre-initialize implicitly using argv: make sure that -X dev\n       is used to configure the allocation in preinitialization */\n    wchar_t *argv[] = {L\"python3\", L\"-X\", L\"dev\", L\"-P\", L\"script.py\"};\n    config_set_argv(&config, Py_ARRAY_LENGTH(argv), argv);\n    config_set_program_name(&config);\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\n\n\nstatic void set_all_global_config_variables(void)\n{\n    Py_IsolatedFlag = 0;\n    Py_IgnoreEnvironmentFlag = 0;\n    Py_BytesWarningFlag = 2;\n    Py_InspectFlag = 1;\n    Py_InteractiveFlag = 1;\n    Py_OptimizeFlag = 1;\n    Py_DebugFlag = 1;\n    Py_VerboseFlag = 1;\n    Py_QuietFlag = 1;\n    Py_FrozenFlag = 0;\n    Py_UnbufferedStdioFlag = 1;\n    Py_NoSiteFlag = 1;\n    Py_DontWriteBytecodeFlag = 1;\n    Py_NoUserSiteDirectory = 1;\n#ifdef MS_WINDOWS\n    Py_LegacyWindowsStdioFlag = 1;\n#endif\n}\n\n\nstatic int check_preinit_isolated_config(int preinit)\n{\n    PyStatus status;\n    PyPreConfig *rt_preconfig;\n\n    /* environment variables must be ignored */\n    set_all_env_vars();\n\n    /* global configuration variables must be ignored */\n    set_all_global_config_variables();\n\n    if (preinit) {\n        PyPreConfig preconfig;\n        PyPreConfig_InitIsolatedConfig(&preconfig);\n\n        status = Py_PreInitialize(&preconfig);\n        if (PyStatus_Exception(status)) {\n            Py_ExitStatusException(status);\n        }\n\n        rt_preconfig = &_PyRuntime.preconfig;\n        assert(rt_preconfig->isolated == 1);\n        assert(rt_preconfig->use_environment == 0);\n    }\n\n    PyConfig config;\n    PyConfig_InitIsolatedConfig(&config);\n\n    config_set_program_name(&config);\n    init_from_config_clear(&config);\n\n    rt_preconfig = &_PyRuntime.preconfig;\n    assert(rt_preconfig->isolated == 1);\n    assert(rt_preconfig->use_environment == 0);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_preinit_isolated_config(void)\n{\n    return check_preinit_isolated_config(1);\n}\n\n\nstatic int test_init_isolated_config(void)\n{\n    return check_preinit_isolated_config(0);\n}\n\n\nstatic int check_init_python_config(int preinit)\n{\n    /* global configuration variables must be ignored */\n    set_all_global_config_variables();\n    Py_IsolatedFlag = 1;\n    Py_IgnoreEnvironmentFlag = 1;\n    Py_FrozenFlag = 1;\n    Py_UnbufferedStdioFlag = 1;\n    Py_NoSiteFlag = 1;\n    Py_DontWriteBytecodeFlag = 1;\n    Py_NoUserSiteDirectory = 1;\n#ifdef MS_WINDOWS\n    Py_LegacyWindowsStdioFlag = 1;\n#endif\n\n    if (preinit) {\n        PyPreConfig preconfig;\n        PyPreConfig_InitPythonConfig(&preconfig);\n\n        PyStatus status = Py_PreInitialize(&preconfig);\n        if (PyStatus_Exception(status)) {\n            Py_ExitStatusException(status);\n        }\n    }\n\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    config_set_program_name(&config);\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_preinit_python_config(void)\n{\n    return check_init_python_config(1);\n}\n\n\nstatic int test_init_python_config(void)\n{\n    return check_init_python_config(0);\n}\n\n\nstatic int test_init_dont_configure_locale(void)\n{\n    PyPreConfig preconfig;\n    PyPreConfig_InitPythonConfig(&preconfig);\n\n    preconfig.configure_locale = 0;\n    preconfig.coerce_c_locale = 1;\n    preconfig.coerce_c_locale_warn = 1;\n\n    PyStatus status = Py_PreInitialize(&preconfig);\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    config_set_program_name(&config);\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_init_dev_mode(void)\n{\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    putenv(\"PYTHONFAULTHANDLER=\");\n    putenv(\"PYTHONMALLOC=\");\n    config.dev_mode = 1;\n    config_set_program_name(&config);\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\nstatic PyObject *_open_code_hook(PyObject *path, void *data)\n{\n    if (PyUnicode_CompareWithASCIIString(path, \"$$test-filename\") == 0) {\n        return PyLong_FromVoidPtr(data);\n    }\n    PyObject *io = PyImport_ImportModule(\"_io\");\n    if (!io) {\n        return NULL;\n    }\n    return PyObject_CallMethod(io, \"open\", \"Os\", path, \"rb\");\n}\n\nstatic int test_open_code_hook(void)\n{\n    int result = 0;\n\n    /* Provide a hook */\n    result = PyFile_SetOpenCodeHook(_open_code_hook, &result);\n    if (result) {\n        printf(\"Failed to set hook\\n\");\n        return 1;\n    }\n    /* A second hook should fail */\n    result = PyFile_SetOpenCodeHook(_open_code_hook, &result);\n    if (!result) {\n        printf(\"Should have failed to set second hook\\n\");\n        return 2;\n    }\n\n    Py_IgnoreEnvironmentFlag = 0;\n    _testembed_Py_InitializeFromConfig();\n    result = 0;\n\n    PyObject *r = PyFile_OpenCode(\"$$test-filename\");\n    if (!r) {\n        PyErr_Print();\n        result = 3;\n    } else {\n        void *cmp = PyLong_AsVoidPtr(r);\n        Py_DECREF(r);\n        if (cmp != &result) {\n            printf(\"Did not get expected result from hook\\n\");\n            result = 4;\n        }\n    }\n\n    if (!result) {\n        PyObject *io = PyImport_ImportModule(\"_io\");\n        PyObject *r = io\n            ? PyObject_CallMethod(io, \"open_code\", \"s\", \"$$test-filename\")\n            : NULL;\n        if (!r) {\n            PyErr_Print();\n            result = 5;\n        } else {\n            void *cmp = PyLong_AsVoidPtr(r);\n            Py_DECREF(r);\n            if (cmp != &result) {\n                printf(\"Did not get expected result from hook\\n\");\n                result = 6;\n            }\n        }\n        Py_XDECREF(io);\n    }\n\n    Py_Finalize();\n    return result;\n}\n\nstatic int _audit_hook_clear_count = 0;\n\nstatic int _audit_hook(const char *event, PyObject *args, void *userdata)\n{\n    assert(args && PyTuple_CheckExact(args));\n    if (strcmp(event, \"_testembed.raise\") == 0) {\n        PyErr_SetString(PyExc_RuntimeError, \"Intentional error\");\n        return -1;\n    } else if (strcmp(event, \"_testembed.set\") == 0) {\n        if (!PyArg_ParseTuple(args, \"n\", userdata)) {\n            return -1;\n        }\n        return 0;\n    } else if (strcmp(event, \"cpython._PySys_ClearAuditHooks\") == 0) {\n        _audit_hook_clear_count += 1;\n    }\n    return 0;\n}\n\nstatic int _test_audit(Py_ssize_t setValue)\n{\n    Py_ssize_t sawSet = 0;\n\n    Py_IgnoreEnvironmentFlag = 0;\n    PySys_AddAuditHook(_audit_hook, &sawSet);\n    _testembed_Py_InitializeFromConfig();\n\n    if (PySys_Audit(\"_testembed.raise\", NULL) == 0) {\n        printf(\"No error raised\");\n        return 1;\n    }\n    if (PySys_Audit(\"_testembed.nop\", NULL) != 0) {\n        printf(\"Nop event failed\");\n        /* Exception from above may still remain */\n        PyErr_Clear();\n        return 2;\n    }\n    if (!PyErr_Occurred()) {\n        printf(\"Exception not preserved\");\n        return 3;\n    }\n    PyErr_Clear();\n\n    if (PySys_Audit(\"_testembed.set\", \"n\", setValue) != 0) {\n        PyErr_Print();\n        printf(\"Set event failed\");\n        return 4;\n    }\n\n    if (sawSet != 42) {\n        printf(\"Failed to see *userData change\\n\");\n        return 5;\n    }\n    return 0;\n}\n\nstatic int test_audit(void)\n{\n    int result = _test_audit(42);\n    Py_Finalize();\n    if (_audit_hook_clear_count != 1) {\n        return 0x1000 | _audit_hook_clear_count;\n    }\n    return result;\n}\n\nstatic volatile int _audit_subinterpreter_interpreter_count = 0;\n\nstatic int _audit_subinterpreter_hook(const char *event, PyObject *args, void *userdata)\n{\n    printf(\"%s\\n\", event);\n    if (strcmp(event, \"cpython.PyInterpreterState_New\") == 0) {\n        _audit_subinterpreter_interpreter_count += 1;\n    }\n    return 0;\n}\n\nstatic int test_audit_subinterpreter(void)\n{\n    Py_IgnoreEnvironmentFlag = 0;\n    PySys_AddAuditHook(_audit_subinterpreter_hook, NULL);\n    _testembed_Py_InitializeFromConfig();\n\n    Py_NewInterpreter();\n    Py_NewInterpreter();\n    Py_NewInterpreter();\n\n    Py_Finalize();\n\n    switch (_audit_subinterpreter_interpreter_count) {\n        case 3: return 0;\n        case 0: return -1;\n        default: return _audit_subinterpreter_interpreter_count;\n    }\n}\n\ntypedef struct {\n    const char* expected;\n    int exit;\n} AuditRunCommandTest;\n\nstatic int _audit_hook_run(const char *eventName, PyObject *args, void *userData)\n{\n    AuditRunCommandTest *test = (AuditRunCommandTest*)userData;\n    if (strcmp(eventName, test->expected)) {\n        return 0;\n    }\n\n    if (test->exit) {\n        PyObject *msg = PyUnicode_FromFormat(\"detected %s(%R)\", eventName, args);\n        if (msg) {\n            printf(\"%s\\n\", PyUnicode_AsUTF8(msg));\n            Py_DECREF(msg);\n        }\n        exit(test->exit);\n    }\n\n    PyErr_Format(PyExc_RuntimeError, \"detected %s(%R)\", eventName, args);\n    return -1;\n}\n\nstatic int test_audit_run_command(void)\n{\n    AuditRunCommandTest test = {\"cpython.run_command\"};\n    wchar_t *argv[] = {PROGRAM_NAME, L\"-c\", L\"pass\"};\n\n    Py_IgnoreEnvironmentFlag = 0;\n    PySys_AddAuditHook(_audit_hook_run, (void*)&test);\n\n    return Py_Main(Py_ARRAY_LENGTH(argv), argv);\n}\n\nstatic int test_audit_run_file(void)\n{\n    AuditRunCommandTest test = {\"cpython.run_file\"};\n    wchar_t *argv[] = {PROGRAM_NAME, L\"filename.py\"};\n\n    Py_IgnoreEnvironmentFlag = 0;\n    PySys_AddAuditHook(_audit_hook_run, (void*)&test);\n\n    return Py_Main(Py_ARRAY_LENGTH(argv), argv);\n}\n\nstatic int run_audit_run_test(int argc, wchar_t **argv, void *test)\n{\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    config.argv.length = argc;\n    config.argv.items = argv;\n    config.parse_argv = 1;\n    config.program_name = argv[0];\n    config.interactive = 1;\n    config.isolated = 0;\n    config.use_environment = 1;\n    config.quiet = 1;\n\n    PySys_AddAuditHook(_audit_hook_run, test);\n\n    PyStatus status = Py_InitializeFromConfig(&config);\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n\n    return Py_RunMain();\n}\n\nstatic int test_audit_run_interactivehook(void)\n{\n    AuditRunCommandTest test = {\"cpython.run_interactivehook\", 10};\n    wchar_t *argv[] = {PROGRAM_NAME};\n    return run_audit_run_test(Py_ARRAY_LENGTH(argv), argv, &test);\n}\n\nstatic int test_audit_run_startup(void)\n{\n    AuditRunCommandTest test = {\"cpython.run_startup\", 10};\n    wchar_t *argv[] = {PROGRAM_NAME};\n    return run_audit_run_test(Py_ARRAY_LENGTH(argv), argv, &test);\n}\n\nstatic int test_audit_run_stdin(void)\n{\n    AuditRunCommandTest test = {\"cpython.run_stdin\"};\n    wchar_t *argv[] = {PROGRAM_NAME};\n    return run_audit_run_test(Py_ARRAY_LENGTH(argv), argv, &test);\n}\n\nstatic int test_init_read_set(void)\n{\n    PyStatus status;\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    status = PyConfig_SetBytesString(&config, &config.program_name,\n                                     \"./init_read_set\");\n    if (PyStatus_Exception(status)) {\n        goto fail;\n    }\n\n    status = PyConfig_Read(&config);\n    if (PyStatus_Exception(status)) {\n        goto fail;\n    }\n\n    status = PyWideStringList_Insert(&config.module_search_paths,\n                                     1, L\"test_path_insert1\");\n    if (PyStatus_Exception(status)) {\n        goto fail;\n    }\n\n    status = PyWideStringList_Append(&config.module_search_paths,\n                                     L\"test_path_append\");\n    if (PyStatus_Exception(status)) {\n        goto fail;\n    }\n\n    /* override executable computed by PyConfig_Read() */\n    config_set_string(&config, &config.executable, L\"my_executable\");\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n\nfail:\n    PyConfig_Clear(&config);\n    Py_ExitStatusException(status);\n}\n\n\nstatic int test_init_sys_add(void)\n{\n    PySys_AddXOption(L\"sysadd_xoption\");\n    PySys_AddXOption(L\"faulthandler\");\n    PySys_AddWarnOption(L\"ignore:::sysadd_warnoption\");\n\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    wchar_t* argv[] = {\n        L\"python3\",\n        L\"-W\",\n        L\"ignore:::cmdline_warnoption\",\n        L\"-X\",\n        L\"cmdline_xoption\",\n    };\n    config_set_argv(&config, Py_ARRAY_LENGTH(argv), argv);\n    config.parse_argv = 1;\n\n    PyStatus status;\n    status = PyWideStringList_Append(&config.xoptions,\n                                     L\"config_xoption\");\n    if (PyStatus_Exception(status)) {\n        goto fail;\n    }\n\n    status = PyWideStringList_Append(&config.warnoptions,\n                                     L\"ignore:::config_warnoption\");\n    if (PyStatus_Exception(status)) {\n        goto fail;\n    }\n\n    config_set_program_name(&config);\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n\nfail:\n    PyConfig_Clear(&config);\n    Py_ExitStatusException(status);\n}\n\n\nstatic int test_init_setpath(void)\n{\n    char *env = getenv(\"TESTPATH\");\n    if (!env) {\n        error(\"missing TESTPATH env var\");\n        return 1;\n    }\n    wchar_t *path = Py_DecodeLocale(env, NULL);\n    if (path == NULL) {\n        error(\"failed to decode TESTPATH\");\n        return 1;\n    }\n    Py_SetPath(path);\n    PyMem_RawFree(path);\n    putenv(\"TESTPATH=\");\n\n    Py_Initialize();\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_init_setpath_config(void)\n{\n    PyPreConfig preconfig;\n    PyPreConfig_InitPythonConfig(&preconfig);\n\n    /* Explicitly preinitializes with Python preconfiguration to avoid\n      Py_SetPath() implicit preinitialization with compat preconfiguration. */\n    PyStatus status = Py_PreInitialize(&preconfig);\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n\n    char *env = getenv(\"TESTPATH\");\n    if (!env) {\n        error(\"missing TESTPATH env var\");\n        return 1;\n    }\n    wchar_t *path = Py_DecodeLocale(env, NULL);\n    if (path == NULL) {\n        error(\"failed to decode TESTPATH\");\n        return 1;\n    }\n    Py_SetPath(path);\n    PyMem_RawFree(path);\n    putenv(\"TESTPATH=\");\n\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    config_set_string(&config, &config.program_name, L\"conf_program_name\");\n    config_set_string(&config, &config.executable, L\"conf_executable\");\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_init_setpythonhome(void)\n{\n    char *env = getenv(\"TESTHOME\");\n    if (!env) {\n        error(\"missing TESTHOME env var\");\n        return 1;\n    }\n    wchar_t *home = Py_DecodeLocale(env, NULL);\n    if (home == NULL) {\n        error(\"failed to decode TESTHOME\");\n        return 1;\n    }\n    Py_SetPythonHome(home);\n    PyMem_RawFree(home);\n    putenv(\"TESTHOME=\");\n\n    Py_Initialize();\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_init_is_python_build(void)\n{\n    // gh-91985: in-tree builds fail to check for build directory landmarks\n    // under the effect of 'home' or PYTHONHOME environment variable.\n    char *env = getenv(\"TESTHOME\");\n    if (!env) {\n        error(\"missing TESTHOME env var\");\n        return 1;\n    }\n    wchar_t *home = Py_DecodeLocale(env, NULL);\n    if (home == NULL) {\n        error(\"failed to decode TESTHOME\");\n        return 1;\n    }\n\n    PyConfig config;\n    _PyConfig_InitCompatConfig(&config);\n    config_set_program_name(&config);\n    config_set_string(&config, &config.home, home);\n    PyMem_RawFree(home);\n    putenv(\"TESTHOME=\");\n\n    // Use an impossible value so we can detect whether it isn't updated\n    // during initialization.\n    config._is_python_build = INT_MAX;\n    env = getenv(\"NEGATIVE_ISPYTHONBUILD\");\n    if (env && strcmp(env, \"0\") != 0) {\n        config._is_python_build = INT_MIN;\n    }\n    init_from_config_clear(&config);\n    Py_Finalize();\n    // Second initialization\n    config._is_python_build = -1;\n    init_from_config_clear(&config);\n    dump_config();  // home and _is_python_build are cached in _Py_path_config\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int test_init_warnoptions(void)\n{\n    putenv(\"PYTHONWARNINGS=ignore:::env1,ignore:::env2\");\n\n    PySys_AddWarnOption(L\"ignore:::PySys_AddWarnOption1\");\n    PySys_AddWarnOption(L\"ignore:::PySys_AddWarnOption2\");\n\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    config.dev_mode = 1;\n    config.bytes_warning = 1;\n\n    config_set_program_name(&config);\n\n    PyStatus status;\n    status = PyWideStringList_Append(&config.warnoptions,\n                                     L\"ignore:::PyConfig_BeforeRead\");\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n\n    wchar_t* argv[] = {\n        L\"python3\",\n        L\"-Wignore:::cmdline1\",\n        L\"-Wignore:::cmdline2\"};\n    config_set_argv(&config, Py_ARRAY_LENGTH(argv), argv);\n    config.parse_argv = 1;\n\n    status = PyConfig_Read(&config);\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n\n    status = PyWideStringList_Append(&config.warnoptions,\n                                     L\"ignore:::PyConfig_AfterRead\");\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n\n    status = PyWideStringList_Insert(&config.warnoptions,\n                                     0, L\"ignore:::PyConfig_Insert0\");\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n\n    init_from_config_clear(&config);\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic int tune_config(void)\n{\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n    if (_PyInterpreterState_GetConfigCopy(&config) < 0) {\n        PyConfig_Clear(&config);\n        PyErr_Print();\n        return -1;\n    }\n\n    config.bytes_warning = 2;\n\n    if (_PyInterpreterState_SetConfig(&config) < 0) {\n        PyConfig_Clear(&config);\n        return -1;\n    }\n    PyConfig_Clear(&config);\n    return 0;\n}\n\n\nstatic int test_init_set_config(void)\n{\n    // Initialize core\n    PyConfig config;\n    PyConfig_InitIsolatedConfig(&config);\n    config_set_string(&config, &config.program_name, PROGRAM_NAME);\n    config._init_main = 0;\n    config.bytes_warning = 0;\n    init_from_config_clear(&config);\n\n    // Tune the configuration using _PyInterpreterState_SetConfig()\n    if (tune_config() < 0) {\n        PyErr_Print();\n        return 1;\n    }\n\n    // Finish initialization: main part\n    PyStatus status = _Py_InitializeMain();\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\n\nstatic void configure_init_main(PyConfig *config)\n{\n    wchar_t* argv[] = {\n        L\"python3\", L\"-c\",\n        (L\"import _testinternalcapi, json; \"\n         L\"print(json.dumps(_testinternalcapi.get_configs()))\"),\n        L\"arg2\"};\n\n    config->parse_argv = 1;\n\n    config_set_argv(config, Py_ARRAY_LENGTH(argv), argv);\n    config_set_string(config, &config->program_name, L\"./python3\");\n}\n\n\nstatic int test_init_run_main(void)\n{\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    configure_init_main(&config);\n    init_from_config_clear(&config);\n\n    return Py_RunMain();\n}\n\n\nstatic int test_init_main(void)\n{\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    configure_init_main(&config);\n    config._init_main = 0;\n    init_from_config_clear(&config);\n\n    /* sys.stdout don't exist yet: it is created by _Py_InitializeMain() */\n    int res = PyRun_SimpleString(\n        \"import sys; \"\n        \"print('Run Python code before _Py_InitializeMain', \"\n               \"file=sys.stderr)\");\n    if (res < 0) {\n        exit(1);\n    }\n\n    PyStatus status = _Py_InitializeMain();\n    if (PyStatus_Exception(status)) {\n        Py_ExitStatusException(status);\n    }\n\n    return Py_RunMain();\n}\n\n\nstatic int test_run_main(void)\n{\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    wchar_t *argv[] = {L\"python3\", L\"-c\",\n                       (L\"import sys; \"\n                        L\"print(f'Py_RunMain(): sys.argv={sys.argv}')\"),\n                       L\"arg2\"};\n    config_set_argv(&config, Py_ARRAY_LENGTH(argv), argv);\n    config_set_string(&config, &config.program_name, L\"./python3\");\n    init_from_config_clear(&config);\n\n    return Py_RunMain();\n}\n\n\nstatic int test_run_main_loop(void)\n{\n    // bpo-40413: Calling Py_InitializeFromConfig()+Py_RunMain() multiple\n    // times must not crash.\n    for (int i=0; i<5; i++) {\n        int exitcode = test_run_main();\n        if (exitcode != 0) {\n            return exitcode;\n        }\n    }\n    return 0;\n}\n\n\nstatic int test_get_argc_argv(void)\n{\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    wchar_t *argv[] = {L\"python3\", L\"-c\", L\"pass\", L\"arg2\"};\n    config_set_argv(&config, Py_ARRAY_LENGTH(argv), argv);\n    config_set_string(&config, &config.program_name, L\"./python3\");\n\n    // Calling PyConfig_Read() twice must not change Py_GetArgcArgv() result.\n    // The second call is done by Py_InitializeFromConfig().\n    PyStatus status = PyConfig_Read(&config);\n    if (PyStatus_Exception(status)) {\n        PyConfig_Clear(&config);\n        Py_ExitStatusException(status);\n    }\n\n    init_from_config_clear(&config);\n\n    int get_argc;\n    wchar_t **get_argv;\n    Py_GetArgcArgv(&get_argc, &get_argv);\n    printf(\"argc: %i\\n\", get_argc);\n    assert(get_argc == Py_ARRAY_LENGTH(argv));\n    for (int i=0; i < get_argc; i++) {\n        printf(\"argv[%i]: %ls\\n\", i, get_argv[i]);\n        assert(wcscmp(get_argv[i], argv[i]) == 0);\n    }\n\n    Py_Finalize();\n\n    printf(\"\\n\");\n    printf(\"test ok\\n\");\n    return 0;\n}\n\n\nstatic int check_use_frozen_modules(const char *rawval)\n{\n    wchar_t optval[100];\n    if (rawval == NULL) {\n        wcscpy(optval, L\"frozen_modules\");\n    }\n    else if (swprintf(optval, 100,\n#if defined(_MSC_VER)\n        L\"frozen_modules=%S\",\n#else\n        L\"frozen_modules=%s\",\n#endif\n        rawval) < 0) {\n        error(\"rawval is too long\");\n        return -1;\n    }\n\n    PyConfig config;\n    PyConfig_InitPythonConfig(&config);\n\n    config.parse_argv = 1;\n\n    wchar_t* argv[] = {\n        L\"./argv0\",\n        L\"-X\",\n        optval,\n        L\"-c\",\n        L\"pass\",\n    };\n    config_set_argv(&config, Py_ARRAY_LENGTH(argv), argv);\n    init_from_config_clear(&config);\n\n    dump_config();\n    Py_Finalize();\n    return 0;\n}\n\nstatic int test_init_use_frozen_modules(void)\n{\n    const char *envvar = getenv(\"TESTFROZEN\");\n    return check_use_frozen_modules(envvar);\n}\n\n\nstatic int test_unicode_id_init(void)\n{\n    // bpo-42882: Test that _PyUnicode_FromId() works\n    // when Python is initialized multiples times.\n\n    // This is equivalent to `_Py_IDENTIFIER(test_unicode_id_init)`\n    // but since `_Py_IDENTIFIER` is disabled when `Py_BUILD_CORE`\n    // is defined, it is manually expanded here.\n    static _Py_Identifier PyId_test_unicode_id_init = {\n        .string = \"test_unicode_id_init\",\n        .index = -1,\n    };\n\n    // Initialize Python once without using the identifier\n    _testembed_Py_InitializeFromConfig();\n    Py_Finalize();\n\n    // Now initialize Python multiple times and use the identifier.\n    // The first _PyUnicode_FromId() call initializes the identifier index.\n    for (int i=0; i<3; i++) {\n        _testembed_Py_InitializeFromConfig();\n\n        PyObject *str1, *str2;\n\n        str1 = _PyUnicode_FromId(&PyId_test_unicode_id_init);\n        assert(str1 != NULL);\n        assert(_Py_IsImmortal(str1));\n\n        str2 = PyUnicode_FromString(\"test_unicode_id_init\");\n        assert(str2 != NULL);\n\n        assert(PyUnicode_Compare(str1, str2) == 0);\n\n        Py_DECREF(str2);\n\n        Py_Finalize();\n    }\n    return 0;\n}\n\n\nstatic int test_init_main_interpreter_settings(void)\n{\n    _testembed_Py_Initialize();\n    (void) PyRun_SimpleStringFlags(\n        \"import _testinternalcapi, json; \"\n        \"print(json.dumps(_testinternalcapi.get_interp_settings(0)))\",\n        0);\n    Py_Finalize();\n    return 0;\n}\n\n\n#ifndef MS_WINDOWS\n#include \"test_frozenmain.h\"      // M_test_frozenmain\n\nstatic int test_frozenmain(void)\n{\n    static struct _frozen frozen_modules[4] = {\n        {\"__main__\", M_test_frozenmain, sizeof(M_test_frozenmain)},\n        {0, 0, 0}   // sentinel\n    };\n\n    char* argv[] = {\n        \"./argv0\",\n        \"-E\",\n        \"arg1\",\n        \"arg2\",\n    };\n    PyImport_FrozenModules = frozen_modules;\n    return Py_FrozenMain(Py_ARRAY_LENGTH(argv), argv);\n}\n#endif  // !MS_WINDOWS\n\nstatic int test_repeated_init_and_inittab(void)\n{\n    // bpo-44441: Py_RunMain() must reset PyImport_Inittab at exit.\n    // It must be possible to call PyImport_AppendInittab() or\n    // PyImport_ExtendInittab() before each Python initialization.\n    for (int i=1; i <= INIT_LOOPS; i++) {\n        printf(\"--- Pass %d ---\\n\", i);\n\n        // Call PyImport_AppendInittab() at each iteration\n        if (PyImport_AppendInittab(EMBEDDED_EXT_NAME,\n                                   &PyInit_embedded_ext) != 0) {\n            fprintf(stderr, \"PyImport_AppendInittab() failed\\n\");\n            return 1;\n        }\n\n        // Initialize Python\n        wchar_t* argv[] = {PROGRAM_NAME, L\"-c\", L\"pass\"};\n        PyConfig config;\n        PyConfig_InitPythonConfig(&config);\n        config.isolated = 1;\n        config_set_argv(&config, Py_ARRAY_LENGTH(argv), argv);\n        init_from_config_clear(&config);\n\n        // Py_RunMain() calls _PyImport_Fini2() which resets PyImport_Inittab\n        int exitcode = Py_RunMain();\n        if (exitcode != 0) {\n            return exitcode;\n        }\n    }\n    return 0;\n}\n\nstatic void wrap_allocator(PyMemAllocatorEx *allocator);\nstatic void unwrap_allocator(PyMemAllocatorEx *allocator);\n\nstatic void *\nmalloc_wrapper(void *ctx, size_t size)\n{\n    PyMemAllocatorEx *allocator = (PyMemAllocatorEx *)ctx;\n    unwrap_allocator(allocator);\n    PyEval_GetFrame();  // BOOM!\n    wrap_allocator(allocator);\n    return allocator->malloc(allocator->ctx, size);\n}\n\nstatic void *\ncalloc_wrapper(void *ctx, size_t nelem, size_t elsize)\n{\n    PyMemAllocatorEx *allocator = (PyMemAllocatorEx *)ctx;\n    return allocator->calloc(allocator->ctx, nelem, elsize);\n}\n\nstatic void *\nrealloc_wrapper(void *ctx, void *ptr, size_t new_size)\n{\n    PyMemAllocatorEx *allocator = (PyMemAllocatorEx *)ctx;\n    return allocator->realloc(allocator->ctx, ptr, new_size);\n}\n\nstatic void\nfree_wrapper(void *ctx, void *ptr)\n{\n    PyMemAllocatorEx *allocator = (PyMemAllocatorEx *)ctx;\n    allocator->free(allocator->ctx, ptr);\n}\n\nstatic void\nwrap_allocator(PyMemAllocatorEx *allocator)\n{\n    PyMem_GetAllocator(PYMEM_DOMAIN_OBJ, allocator);\n    PyMemAllocatorEx wrapper = {\n        .malloc = &malloc_wrapper,\n        .calloc = &calloc_wrapper,\n        .realloc = &realloc_wrapper,\n        .free = &free_wrapper,\n        .ctx = allocator,\n    };\n    PyMem_SetAllocator(PYMEM_DOMAIN_OBJ, &wrapper);\n}\n\nstatic void\nunwrap_allocator(PyMemAllocatorEx *allocator)\n{\n    PyMem_SetAllocator(PYMEM_DOMAIN_OBJ, allocator);\n}\n\nstatic int\ntest_get_incomplete_frame(void)\n{\n    _testembed_Py_InitializeFromConfig();\n    PyMemAllocatorEx allocator;\n    wrap_allocator(&allocator);\n    // Force an allocation with an incomplete (generator) frame:\n    int result = PyRun_SimpleString(\"(_ for _ in ())\");\n    unwrap_allocator(&allocator);\n    Py_Finalize();\n    return result;\n}\n\n\n/* *********************************************************\n * List of test cases and the function that implements it.\n *\n * Names are compared case-sensitively with the first\n * argument. If no match is found, or no first argument was\n * provided, the names of all test cases are printed and\n * the exit code will be -1.\n *\n * The int returned from test functions is used as the exit\n * code, and test_capi treats all non-zero exit codes as a\n * failed test.\n *********************************************************/\nstruct TestCase\n{\n    const char *name;\n    int (*func)(void);\n};\n\nstatic struct TestCase TestCases[] = {\n    // Python initialization\n    {\"test_repeated_init_exec\", test_repeated_init_exec},\n    {\"test_repeated_simple_init\", test_repeated_simple_init},\n    {\"test_forced_io_encoding\", test_forced_io_encoding},\n    {\"test_repeated_init_and_subinterpreters\", test_repeated_init_and_subinterpreters},\n    {\"test_repeated_init_and_inittab\", test_repeated_init_and_inittab},\n    {\"test_pre_initialization_api\", test_pre_initialization_api},\n    {\"test_pre_initialization_sys_options\", test_pre_initialization_sys_options},\n    {\"test_bpo20891\", test_bpo20891},\n    {\"test_initialize_twice\", test_initialize_twice},\n    {\"test_initialize_pymain\", test_initialize_pymain},\n    {\"test_init_initialize_config\", test_init_initialize_config},\n    {\"test_preinit_compat_config\", test_preinit_compat_config},\n    {\"test_init_compat_config\", test_init_compat_config},\n    {\"test_init_global_config\", test_init_global_config},\n    {\"test_init_from_config\", test_init_from_config},\n    {\"test_init_parse_argv\", test_init_parse_argv},\n    {\"test_init_dont_parse_argv\", test_init_dont_parse_argv},\n    {\"test_init_compat_env\", test_init_compat_env},\n    {\"test_init_python_env\", test_init_python_env},\n    {\"test_init_env_dev_mode\", test_init_env_dev_mode},\n    {\"test_init_env_dev_mode_alloc\", test_init_env_dev_mode_alloc},\n    {\"test_init_dont_configure_locale\", test_init_dont_configure_locale},\n    {\"test_init_dev_mode\", test_init_dev_mode},\n    {\"test_init_isolated_flag\", test_init_isolated_flag},\n    {\"test_preinit_isolated_config\", test_preinit_isolated_config},\n    {\"test_init_isolated_config\", test_init_isolated_config},\n    {\"test_preinit_python_config\", test_preinit_python_config},\n    {\"test_init_python_config\", test_init_python_config},\n    {\"test_preinit_isolated1\", test_preinit_isolated1},\n    {\"test_preinit_isolated2\", test_preinit_isolated2},\n    {\"test_preinit_parse_argv\", test_preinit_parse_argv},\n    {\"test_preinit_dont_parse_argv\", test_preinit_dont_parse_argv},\n    {\"test_init_read_set\", test_init_read_set},\n    {\"test_init_run_main\", test_init_run_main},\n    {\"test_init_main\", test_init_main},\n    {\"test_init_sys_add\", test_init_sys_add},\n    {\"test_init_setpath\", test_init_setpath},\n    {\"test_init_setpath_config\", test_init_setpath_config},\n    {\"test_init_setpythonhome\", test_init_setpythonhome},\n    {\"test_init_is_python_build\", test_init_is_python_build},\n    {\"test_init_warnoptions\", test_init_warnoptions},\n    {\"test_init_set_config\", test_init_set_config},\n    {\"test_run_main\", test_run_main},\n    {\"test_run_main_loop\", test_run_main_loop},\n    {\"test_get_argc_argv\", test_get_argc_argv},\n    {\"test_init_use_frozen_modules\", test_init_use_frozen_modules},\n    {\"test_init_main_interpreter_settings\", test_init_main_interpreter_settings},\n\n    // Audit\n    {\"test_open_code_hook\", test_open_code_hook},\n    {\"test_audit\", test_audit},\n    {\"test_audit_subinterpreter\", test_audit_subinterpreter},\n    {\"test_audit_run_command\", test_audit_run_command},\n    {\"test_audit_run_file\", test_audit_run_file},\n    {\"test_audit_run_interactivehook\", test_audit_run_interactivehook},\n    {\"test_audit_run_startup\", test_audit_run_startup},\n    {\"test_audit_run_stdin\", test_audit_run_stdin},\n\n    // Specific C API\n    {\"test_unicode_id_init\", test_unicode_id_init},\n#ifndef MS_WINDOWS\n    {\"test_frozenmain\", test_frozenmain},\n#endif\n    {\"test_get_incomplete_frame\", test_get_incomplete_frame},\n\n    {NULL, NULL}\n};\n\n\nint main(int argc, char *argv[])\n{\n    main_argc = argc;\n    main_argv = argv;\n\n    if (argc > 1) {\n        for (struct TestCase *tc = TestCases; tc && tc->name; tc++) {\n            if (strcmp(argv[1], tc->name) == 0)\n                return (*tc->func)();\n        }\n    }\n\n    /* No match found, or no test name provided, so display usage */\n    printf(\"Python \" PY_VERSION \" _testembed executable for embedded interpreter tests\\n\"\n           \"Normally executed via 'EmbeddingTests' in Lib/test/test_embed.py\\n\\n\"\n           \"Usage: %s TESTNAME\\n\\nAll available tests:\\n\", argv[0]);\n    for (struct TestCase *tc = TestCases; tc && tc->name; tc++) {\n        printf(\"  %s\\n\", tc->name);\n    }\n\n    /* Non-zero exit code will cause test_embed.py tests to fail.\n       This is intentional. */\n    return -1;\n}\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-possible-null-argument",
                        "taxa": [{"id": "690",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 5678,
                                       "gcc/analyzer/saved_diagnostic/snode": 608,
                                       "gcc/analyzer/saved_diagnostic/sval": "&HEAP_ALLOCATED_REGION(6483)",
                                       "gcc/analyzer/saved_diagnostic/state": "unchecked ({free})",
                                       "gcc/analyzer/saved_diagnostic/idx": 0},
                        "level": "warning",
                        "message": {"text": "use of possibly-NULL 'dynamic_once_warnoption' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Programs/_testembed.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 310,
                                                                       "startColumn": 5,
                                                                       "endColumn": 74},
                                                            "contextRegion": {"startLine": 310,
                                                                              "snippet": {"text": "    wcsncpy(dynamic_once_warnoption, static_warnoption, warnoption_len+1);\n"}}},
                                       "logicalLocations": [{"name": "test_pre_initialization_sys_options",
                                                             "fullyQualifiedName": "test_pre_initialization_sys_options",
                                                             "decoratedName": "test_pre_initialization_sys_options",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Programs/_testembed.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 307,
                                                                                                                    "startColumn": 26,
                                                                                                                    "endColumn": 67},
                                                                                                         "contextRegion": {"startLine": 307,
                                                                                                                           "snippet": {"text": "             (wchar_t *) calloc(warnoption_len+1, sizeof(wchar_t));\n"}}},
                                                                                    "logicalLocations": [{"name": "test_pre_initialization_sys_options",
                                                                                                          "fullyQualifiedName": "test_pre_initialization_sys_options",
                                                                                                          "decoratedName": "test_pre_initialization_sys_options",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "this call could return NULL"}},
                                                                       "kinds": ["acquire",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Programs/_testembed.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 310,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 74},
                                                                                                         "contextRegion": {"startLine": 310,
                                                                                                                           "snippet": {"text": "    wcsncpy(dynamic_once_warnoption, static_warnoption, warnoption_len+1);\n"}}},
                                                                                    "logicalLocations": [{"name": "test_pre_initialization_sys_options",
                                                                                                          "fullyQualifiedName": "test_pre_initialization_sys_options",
                                                                                                          "decoratedName": "test_pre_initialization_sys_options",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('dynamic_once_warnoption') from (1) could be NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/wchar.h"},
                                                                   "region": {"startLine": 103,
                                                                              "startColumn": 17,
                                                                              "endColumn": 24},
                                                                   "contextRegion": {"startLine": 103,
                                                                                     "snippet": {"text": "extern wchar_t *wcsncpy (wchar_t *__restrict __dest,\n"}}},
                                              "message": {"text": "argument 1 of 'wcsncpy' must be non-null"}}]},
                       {"ruleId": "-Wanalyzer-possible-null-argument",
                        "taxa": [{"id": "690",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 5679,
                                       "gcc/analyzer/saved_diagnostic/snode": 608,
                                       "gcc/analyzer/saved_diagnostic/sval": "&HEAP_ALLOCATED_REGION(6500)",
                                       "gcc/analyzer/saved_diagnostic/state": "unchecked ({free})",
                                       "gcc/analyzer/saved_diagnostic/idx": 1},
                        "level": "warning",
                        "message": {"text": "use of possibly-NULL 'dynamic_xoption' where non-null expected"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Programs/_testembed.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 311,
                                                                       "startColumn": 5,
                                                                       "endColumn": 60},
                                                            "contextRegion": {"startLine": 311,
                                                                              "snippet": {"text": "    wcsncpy(dynamic_xoption, static_xoption, xoption_len+1);\n"}}},
                                       "logicalLocations": [{"name": "test_pre_initialization_sys_options",
                                                             "fullyQualifiedName": "test_pre_initialization_sys_options",
                                                             "decoratedName": "test_pre_initialization_sys_options",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Programs/_testembed.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 309,
                                                                                                                    "startColumn": 26,
                                                                                                                    "endColumn": 64},
                                                                                                         "contextRegion": {"startLine": 309,
                                                                                                                           "snippet": {"text": "             (wchar_t *) calloc(xoption_len+1, sizeof(wchar_t));\n"}}},
                                                                                    "logicalLocations": [{"name": "test_pre_initialization_sys_options",
                                                                                                          "fullyQualifiedName": "test_pre_initialization_sys_options",
                                                                                                          "decoratedName": "test_pre_initialization_sys_options",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "this call could return NULL"}},
                                                                       "kinds": ["acquire",
                                                                                 "memory"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Programs/_testembed.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 311,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 60},
                                                                                                         "contextRegion": {"startLine": 311,
                                                                                                                           "snippet": {"text": "    wcsncpy(dynamic_xoption, static_xoption, xoption_len+1);\n"}}},
                                                                                    "logicalLocations": [{"name": "test_pre_initialization_sys_options",
                                                                                                          "fullyQualifiedName": "test_pre_initialization_sys_options",
                                                                                                          "decoratedName": "test_pre_initialization_sys_options",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "argument 1 ('dynamic_xoption') from (1) could be NULL where non-null expected"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2}]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/wchar.h"},
                                                                   "region": {"startLine": 103,
                                                                              "startColumn": 17,
                                                                              "endColumn": 24},
                                                                   "contextRegion": {"startLine": 103,
                                                                                     "snippet": {"text": "extern wchar_t *wcsncpy (wchar_t *__restrict __dest,\n"}}},
                                              "message": {"text": "argument 1 of 'wcsncpy' must be non-null"}}]}]}]}
