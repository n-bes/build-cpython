{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-deref-before-check",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-deref-before-check"}]}},
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}},
           "artifacts": [{"location": {"uri": "Python/ceval.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/* Execute compiled code */\n\n#define _PY_INTERPRETER\n\n#include \"Python.h\"\n#include \"pycore_abstract.h\"      // _PyIndex_Check()\n#include \"pycore_call.h\"          // _PyObject_FastCallDictTstate()\n#include \"pycore_ceval.h\"         // _PyEval_SignalAsyncExc()\n#include \"pycore_code.h\"\n#include \"pycore_function.h\"\n#include \"pycore_intrinsics.h\"\n#include \"pycore_long.h\"          // _PyLong_GetZero()\n#include \"pycore_instruments.h\"\n#include \"pycore_object.h\"        // _PyObject_GC_TRACK()\n#include \"pycore_moduleobject.h\"  // PyModuleObject\n#include \"pycore_opcode.h\"        // EXTRA_CASES\n#include \"pycore_pyerrors.h\"      // _PyErr_GetRaisedException()\n#include \"pycore_pymem.h\"         // _PyMem_IsPtrFreed()\n#include \"pycore_pystate.h\"       // _PyInterpreterState_GET()\n#include \"pycore_range.h\"         // _PyRangeIterObject\n#include \"pycore_sliceobject.h\"   // _PyBuildSlice_ConsumeRefs\n#include \"pycore_sysmodule.h\"     // _PySys_Audit()\n#include \"pycore_tuple.h\"         // _PyTuple_ITEMS()\n#include \"pycore_typeobject.h\"    // _PySuper_Lookup()\n#include \"pycore_emscripten_signal.h\"  // _Py_CHECK_EMSCRIPTEN_SIGNALS\n\n#include \"pycore_dict.h\"\n#include \"dictobject.h\"\n#include \"pycore_frame.h\"\n#include \"frameobject.h\"          // _PyInterpreterFrame_GetLine\n#include \"opcode.h\"\n#include \"pydtrace.h\"\n#include \"setobject.h\"\n#include \"structmember.h\"         // struct PyMemberDef, T_OFFSET_EX\n\n#include <ctype.h>\n#include <stdbool.h>\n\n#ifdef Py_DEBUG\n   /* For debugging the interpreter: */\n#  define LLTRACE  1      /* Low-level trace feature */\n#endif\n\n#if !defined(Py_BUILD_CORE)\n#  error \"ceval.c must be build with Py_BUILD_CORE define for best performance\"\n#endif\n\n#if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS)\n// GH-89279: The MSVC compiler does not inline these static inline functions\n// in PGO build in _PyEval_EvalFrameDefault(), because this function is over\n// the limit of PGO, and that limit cannot be configured.\n// Define them as macros to make sure that they are always inlined by the\n// preprocessor.\n\n#undef Py_DECREF\n#define Py_DECREF(arg) \\\n    do { \\\n        PyObject *op = _PyObject_CAST(arg); \\\n        if (_Py_IsImmortal(op)) { \\\n            break; \\\n        } \\\n        _Py_DECREF_STAT_INC(); \\\n        if (--op->ob_refcnt == 0) { \\\n            destructor dealloc = Py_TYPE(op)->tp_dealloc; \\\n            (*dealloc)(op); \\\n        } \\\n    } while (0)\n\n#undef Py_XDECREF\n#define Py_XDECREF(arg) \\\n    do { \\\n        PyObject *xop = _PyObject_CAST(arg); \\\n        if (xop != NULL) { \\\n            Py_DECREF(xop); \\\n        } \\\n    } while (0)\n\n#undef Py_IS_TYPE\n#define Py_IS_TYPE(ob, type) \\\n    (_PyObject_CAST(ob)->ob_type == (type))\n\n#undef _Py_DECREF_SPECIALIZED\n#define _Py_DECREF_SPECIALIZED(arg, dealloc) \\\n    do { \\\n        PyObject *op = _PyObject_CAST(arg); \\\n        if (_Py_IsImmortal(op)) { \\\n            break; \\\n        } \\\n        _Py_DECREF_STAT_INC(); \\\n        if (--op->ob_refcnt == 0) { \\\n            destructor d = (destructor)(dealloc); \\\n            d(op); \\\n        } \\\n    } while (0)\n#endif\n\n// GH-89279: Similar to above, force inlining by using a macro.\n#if defined(_MSC_VER) && SIZEOF_INT == 4\n#define _Py_atomic_load_relaxed_int32(ATOMIC_VAL) (assert(sizeof((ATOMIC_VAL)->_value) == 4), *((volatile int*)&((ATOMIC_VAL)->_value)))\n#else\n#define _Py_atomic_load_relaxed_int32(ATOMIC_VAL) _Py_atomic_load_relaxed(ATOMIC_VAL)\n#endif\n\n\n#ifdef LLTRACE\nstatic void\ndump_stack(_PyInterpreterFrame *frame, PyObject **stack_pointer)\n{\n    PyObject **stack_base = _PyFrame_Stackbase(frame);\n    PyObject *exc = PyErr_GetRaisedException();\n    printf(\"    stack=[\");\n    for (PyObject **ptr = stack_base; ptr < stack_pointer; ptr++) {\n        if (ptr != stack_base) {\n            printf(\", \");\n        }\n        if (PyObject_Print(*ptr, stdout, 0) != 0) {\n            PyErr_Clear();\n            printf(\"<%s object at %p>\",\n                   Py_TYPE(*ptr)->tp_name, (void *)(*ptr));\n        }\n    }\n    printf(\"]\\n\");\n    fflush(stdout);\n    PyErr_SetRaisedException(exc);\n}\n\nstatic void\nlltrace_instruction(_PyInterpreterFrame *frame,\n                    PyObject **stack_pointer,\n                    _Py_CODEUNIT *next_instr)\n{\n    /* This dump_stack() operation is risky, since the repr() of some\n       objects enters the interpreter recursively. It is also slow.\n       So you might want to comment it out. */\n    dump_stack(frame, stack_pointer);\n    int oparg = next_instr->op.arg;\n    int opcode = next_instr->op.code;\n    const char *opname = _PyOpcode_OpName[opcode];\n    assert(opname != NULL);\n    int offset = (int)(next_instr - _PyCode_CODE(frame->f_code));\n    if (HAS_ARG((int)_PyOpcode_Deopt[opcode])) {\n        printf(\"%d: %s %d\\n\", offset * 2, opname, oparg);\n    }\n    else {\n        printf(\"%d: %s\\n\", offset * 2, opname);\n    }\n    fflush(stdout);\n}\nstatic void\nlltrace_resume_frame(_PyInterpreterFrame *frame)\n{\n    PyObject *fobj = frame->f_funcobj;\n    if (frame->owner == FRAME_OWNED_BY_CSTACK ||\n        fobj == NULL ||\n        !PyFunction_Check(fobj)\n    ) {\n        printf(\"\\nResuming frame.\\n\");\n        return;\n    }\n    PyFunctionObject *f = (PyFunctionObject *)fobj;\n    PyObject *exc = PyErr_GetRaisedException();\n    PyObject *name = f->func_qualname;\n    if (name == NULL) {\n        name = f->func_name;\n    }\n    printf(\"\\nResuming frame\");\n    if (name) {\n        printf(\" for \");\n        if (PyObject_Print(name, stdout, 0) < 0) {\n            PyErr_Clear();\n        }\n    }\n    if (f->func_module) {\n        printf(\" in module \");\n        if (PyObject_Print(f->func_module, stdout, 0) < 0) {\n            PyErr_Clear();\n        }\n    }\n    printf(\"\\n\");\n    fflush(stdout);\n    PyErr_SetRaisedException(exc);\n}\n#endif\n\nstatic void monitor_raise(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\nstatic void monitor_reraise(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\nstatic int monitor_stop_iteration(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\nstatic void monitor_unwind(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\nstatic int monitor_handled(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr, PyObject *exc);\nstatic void monitor_throw(PyThreadState *tstate,\n                 _PyInterpreterFrame *frame,\n                 _Py_CODEUNIT *instr);\n\nstatic PyObject * import_name(PyThreadState *, _PyInterpreterFrame *,\n                              PyObject *, PyObject *, PyObject *);\nstatic PyObject * import_from(PyThreadState *, PyObject *, PyObject *);\nstatic void format_exc_check_arg(PyThreadState *, PyObject *, const char *, PyObject *);\nstatic void format_exc_unbound(PyThreadState *tstate, PyCodeObject *co, int oparg);\nstatic int check_args_iterable(PyThreadState *, PyObject *func, PyObject *vararg);\nstatic int check_except_type_valid(PyThreadState *tstate, PyObject* right);\nstatic int check_except_star_type_valid(PyThreadState *tstate, PyObject* right);\nstatic void format_kwargs_error(PyThreadState *, PyObject *func, PyObject *kwargs);\nstatic void format_awaitable_error(PyThreadState *, PyTypeObject *, int);\nstatic int get_exception_handler(PyCodeObject *, int, int*, int*, int*);\nstatic _PyInterpreterFrame *\n_PyEvalFramePushAndInit(PyThreadState *tstate, PyFunctionObject *func,\n                        PyObject *locals, PyObject* const* args,\n                        size_t argcount, PyObject *kwnames);\nstatic  _PyInterpreterFrame *\n_PyEvalFramePushAndInit_Ex(PyThreadState *tstate, PyFunctionObject *func,\n    PyObject *locals, Py_ssize_t nargs, PyObject *callargs, PyObject *kwargs);\nstatic void\n_PyEvalFrameClearAndPop(PyThreadState *tstate, _PyInterpreterFrame *frame);\n\n#define UNBOUNDLOCAL_ERROR_MSG \\\n    \"cannot access local variable '%s' where it is not associated with a value\"\n#define UNBOUNDFREE_ERROR_MSG \\\n    \"cannot access free variable '%s' where it is not associated with a\" \\\n    \" value in enclosing scope\"\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n\nint\nPy_GetRecursionLimit(void)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    return interp->ceval.recursion_limit;\n}\n\nvoid\nPy_SetRecursionLimit(int new_limit)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    interp->ceval.recursion_limit = new_limit;\n    for (PyThreadState *p = interp->threads.head; p != NULL; p = p->next) {\n        int depth = p->py_recursion_limit - p->py_recursion_remaining;\n        p->py_recursion_limit = new_limit;\n        p->py_recursion_remaining = new_limit - depth;\n    }\n}\n\n/* The function _Py_EnterRecursiveCallTstate() only calls _Py_CheckRecursiveCall()\n   if the recursion_depth reaches recursion_limit. */\nint\n_Py_CheckRecursiveCall(PyThreadState *tstate, const char *where)\n{\n#ifdef USE_STACKCHECK\n    if (PyOS_CheckStack()) {\n        ++tstate->c_recursion_remaining;\n        _PyErr_SetString(tstate, PyExc_MemoryError, \"Stack overflow\");\n        return -1;\n    }\n#endif\n    if (tstate->recursion_headroom) {\n        if (tstate->c_recursion_remaining < -50) {\n            /* Overflowing while handling an overflow. Give up. */\n            Py_FatalError(\"Cannot recover from stack overflow.\");\n        }\n    }\n    else {\n        if (tstate->c_recursion_remaining <= 0) {\n            tstate->recursion_headroom++;\n            _PyErr_Format(tstate, PyExc_RecursionError,\n                        \"maximum recursion depth exceeded%s\",\n                        where);\n            tstate->recursion_headroom--;\n            ++tstate->c_recursion_remaining;\n            return -1;\n        }\n    }\n    return 0;\n}\n\n\nstatic const binaryfunc binary_ops[] = {\n    [NB_ADD] = PyNumber_Add,\n    [NB_AND] = PyNumber_And,\n    [NB_FLOOR_DIVIDE] = PyNumber_FloorDivide,\n    [NB_LSHIFT] = PyNumber_Lshift,\n    [NB_MATRIX_MULTIPLY] = PyNumber_MatrixMultiply,\n    [NB_MULTIPLY] = PyNumber_Multiply,\n    [NB_REMAINDER] = PyNumber_Remainder,\n    [NB_OR] = PyNumber_Or,\n    [NB_POWER] = _PyNumber_PowerNoMod,\n    [NB_RSHIFT] = PyNumber_Rshift,\n    [NB_SUBTRACT] = PyNumber_Subtract,\n    [NB_TRUE_DIVIDE] = PyNumber_TrueDivide,\n    [NB_XOR] = PyNumber_Xor,\n    [NB_INPLACE_ADD] = PyNumber_InPlaceAdd,\n    [NB_INPLACE_AND] = PyNumber_InPlaceAnd,\n    [NB_INPLACE_FLOOR_DIVIDE] = PyNumber_InPlaceFloorDivide,\n    [NB_INPLACE_LSHIFT] = PyNumber_InPlaceLshift,\n    [NB_INPLACE_MATRIX_MULTIPLY] = PyNumber_InPlaceMatrixMultiply,\n    [NB_INPLACE_MULTIPLY] = PyNumber_InPlaceMultiply,\n    [NB_INPLACE_REMAINDER] = PyNumber_InPlaceRemainder,\n    [NB_INPLACE_OR] = PyNumber_InPlaceOr,\n    [NB_INPLACE_POWER] = _PyNumber_InPlacePowerNoMod,\n    [NB_INPLACE_RSHIFT] = PyNumber_InPlaceRshift,\n    [NB_INPLACE_SUBTRACT] = PyNumber_InPlaceSubtract,\n    [NB_INPLACE_TRUE_DIVIDE] = PyNumber_InPlaceTrueDivide,\n    [NB_INPLACE_XOR] = PyNumber_InPlaceXor,\n};\n\n\n// PEP 634: Structural Pattern Matching\n\n\n// Return a tuple of values corresponding to keys, with error checks for\n// duplicate/missing keys.\nstatic PyObject*\nmatch_keys(PyThreadState *tstate, PyObject *map, PyObject *keys)\n{\n    assert(PyTuple_CheckExact(keys));\n    Py_ssize_t nkeys = PyTuple_GET_SIZE(keys);\n    if (!nkeys) {\n        // No keys means no items.\n        return PyTuple_New(0);\n    }\n    PyObject *seen = NULL;\n    PyObject *dummy = NULL;\n    PyObject *values = NULL;\n    PyObject *get = NULL;\n    // We use the two argument form of map.get(key, default) for two reasons:\n    // - Atomically check for a key and get its value without error handling.\n    // - Don't cause key creation or resizing in dict subclasses like\n    //   collections.defaultdict that define __missing__ (or similar).\n    int meth_found = _PyObject_GetMethod(map, &_Py_ID(get), &get);\n    if (get == NULL) {\n        goto fail;\n    }\n    seen = PySet_New(NULL);\n    if (seen == NULL) {\n        goto fail;\n    }\n    // dummy = object()\n    dummy = _PyObject_CallNoArgs((PyObject *)&PyBaseObject_Type);\n    if (dummy == NULL) {\n        goto fail;\n    }\n    values = PyTuple_New(nkeys);\n    if (values == NULL) {\n        goto fail;\n    }\n    for (Py_ssize_t i = 0; i < nkeys; i++) {\n        PyObject *key = PyTuple_GET_ITEM(keys, i);\n        if (PySet_Contains(seen, key) || PySet_Add(seen, key)) {\n            if (!_PyErr_Occurred(tstate)) {\n                // Seen it before!\n                _PyErr_Format(tstate, PyExc_ValueError,\n                              \"mapping pattern checks duplicate key (%R)\", key);\n            }\n            goto fail;\n        }\n        PyObject *args[] = { map, key, dummy };\n        PyObject *value = NULL;\n        if (meth_found) {\n            value = PyObject_Vectorcall(get, args, 3, NULL);\n        }\n        else {\n            value = PyObject_Vectorcall(get, &args[1], 2, NULL);\n        }\n        if (value == NULL) {\n            goto fail;\n        }\n        if (value == dummy) {\n            // key not in map!\n            Py_DECREF(value);\n            Py_DECREF(values);\n            // Return None:\n            values = Py_NewRef(Py_None);\n            goto done;\n        }\n        PyTuple_SET_ITEM(values, i, value);\n    }\n    // Success:\ndone:\n    Py_DECREF(get);\n    Py_DECREF(seen);\n    Py_DECREF(dummy);\n    return values;\nfail:\n    Py_XDECREF(get);\n    Py_XDECREF(seen);\n    Py_XDECREF(dummy);\n    Py_XDECREF(values);\n    return NULL;\n}\n\n// Extract a named attribute from the subject, with additional bookkeeping to\n// raise TypeErrors for repeated lookups. On failure, return NULL (with no\n// error set). Use _PyErr_Occurred(tstate) to disambiguate.\nstatic PyObject*\nmatch_class_attr(PyThreadState *tstate, PyObject *subject, PyObject *type,\n                 PyObject *name, PyObject *seen)\n{\n    assert(PyUnicode_CheckExact(name));\n    assert(PySet_CheckExact(seen));\n    if (PySet_Contains(seen, name) || PySet_Add(seen, name)) {\n        if (!_PyErr_Occurred(tstate)) {\n            // Seen it before!\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"%s() got multiple sub-patterns for attribute %R\",\n                          ((PyTypeObject*)type)->tp_name, name);\n        }\n        return NULL;\n    }\n    PyObject *attr = PyObject_GetAttr(subject, name);\n    if (attr == NULL && _PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {\n        _PyErr_Clear(tstate);\n    }\n    return attr;\n}\n\n// On success (match), return a tuple of extracted attributes. On failure (no\n// match), return NULL. Use _PyErr_Occurred(tstate) to disambiguate.\nstatic PyObject*\nmatch_class(PyThreadState *tstate, PyObject *subject, PyObject *type,\n            Py_ssize_t nargs, PyObject *kwargs)\n{\n    if (!PyType_Check(type)) {\n        const char *e = \"called match pattern must be a class\";\n        _PyErr_Format(tstate, PyExc_TypeError, e);\n        return NULL;\n    }\n    assert(PyTuple_CheckExact(kwargs));\n    // First, an isinstance check:\n    if (PyObject_IsInstance(subject, type) <= 0) {\n        return NULL;\n    }\n    // So far so good:\n    PyObject *seen = PySet_New(NULL);\n    if (seen == NULL) {\n        return NULL;\n    }\n    PyObject *attrs = PyList_New(0);\n    if (attrs == NULL) {\n        Py_DECREF(seen);\n        return NULL;\n    }\n    // NOTE: From this point on, goto fail on failure:\n    PyObject *match_args = NULL;\n    // First, the positional subpatterns:\n    if (nargs) {\n        int match_self = 0;\n        match_args = PyObject_GetAttrString(type, \"__match_args__\");\n        if (match_args) {\n            if (!PyTuple_CheckExact(match_args)) {\n                const char *e = \"%s.__match_args__ must be a tuple (got %s)\";\n                _PyErr_Format(tstate, PyExc_TypeError, e,\n                              ((PyTypeObject *)type)->tp_name,\n                              Py_TYPE(match_args)->tp_name);\n                goto fail;\n            }\n        }\n        else if (_PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {\n            _PyErr_Clear(tstate);\n            // _Py_TPFLAGS_MATCH_SELF is only acknowledged if the type does not\n            // define __match_args__. This is natural behavior for subclasses:\n            // it's as if __match_args__ is some \"magic\" value that is lost as\n            // soon as they redefine it.\n            match_args = PyTuple_New(0);\n            match_self = PyType_HasFeature((PyTypeObject*)type,\n                                            _Py_TPFLAGS_MATCH_SELF);\n        }\n        else {\n            goto fail;\n        }\n        assert(PyTuple_CheckExact(match_args));\n        Py_ssize_t allowed = match_self ? 1 : PyTuple_GET_SIZE(match_args);\n        if (allowed < nargs) {\n            const char *plural = (allowed == 1) ? \"\" : \"s\";\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"%s() accepts %d positional sub-pattern%s (%d given)\",\n                          ((PyTypeObject*)type)->tp_name,\n                          allowed, plural, nargs);\n            goto fail;\n        }\n        if (match_self) {\n            // Easy. Copy the subject itself, and move on to kwargs.\n            if (PyList_Append(attrs, subject) < 0) {\n                goto fail;\n            }\n        }\n        else {\n            for (Py_ssize_t i = 0; i < nargs; i++) {\n                PyObject *name = PyTuple_GET_ITEM(match_args, i);\n                if (!PyUnicode_CheckExact(name)) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"__match_args__ elements must be strings \"\n                                  \"(got %s)\", Py_TYPE(name)->tp_name);\n                    goto fail;\n                }\n                PyObject *attr = match_class_attr(tstate, subject, type, name,\n                                                  seen);\n                if (attr == NULL) {\n                    goto fail;\n                }\n                if (PyList_Append(attrs, attr) < 0) {\n                    Py_DECREF(attr);\n                    goto fail;\n                }\n                Py_DECREF(attr);\n            }\n        }\n        Py_CLEAR(match_args);\n    }\n    // Finally, the keyword subpatterns:\n    for (Py_ssize_t i = 0; i < PyTuple_GET_SIZE(kwargs); i++) {\n        PyObject *name = PyTuple_GET_ITEM(kwargs, i);\n        PyObject *attr = match_class_attr(tstate, subject, type, name, seen);\n        if (attr == NULL) {\n            goto fail;\n        }\n        if (PyList_Append(attrs, attr) < 0) {\n            Py_DECREF(attr);\n            goto fail;\n        }\n        Py_DECREF(attr);\n    }\n    Py_SETREF(attrs, PyList_AsTuple(attrs));\n    Py_DECREF(seen);\n    return attrs;\nfail:\n    // We really don't care whether an error was raised or not... that's our\n    // caller's problem. All we know is that the match failed.\n    Py_XDECREF(match_args);\n    Py_DECREF(seen);\n    Py_DECREF(attrs);\n    return NULL;\n}\n\n\nstatic int do_raise(PyThreadState *tstate, PyObject *exc, PyObject *cause);\nstatic int exception_group_match(\n    PyObject* exc_value, PyObject *match_type,\n    PyObject **match, PyObject **rest);\n\nstatic int unpack_iterable(PyThreadState *, PyObject *, int, int, PyObject **);\n\nPyObject *\nPyEval_EvalCode(PyObject *co, PyObject *globals, PyObject *locals)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (locals == NULL) {\n        locals = globals;\n    }\n    PyObject *builtins = _PyEval_BuiltinsFromGlobals(tstate, globals); // borrowed ref\n    if (builtins == NULL) {\n        return NULL;\n    }\n    PyFrameConstructor desc = {\n        .fc_globals = globals,\n        .fc_builtins = builtins,\n        .fc_name = ((PyCodeObject *)co)->co_name,\n        .fc_qualname = ((PyCodeObject *)co)->co_name,\n        .fc_code = co,\n        .fc_defaults = NULL,\n        .fc_kwdefaults = NULL,\n        .fc_closure = NULL\n    };\n    PyFunctionObject *func = _PyFunction_FromConstructor(&desc);\n    if (func == NULL) {\n        return NULL;\n    }\n    EVAL_CALL_STAT_INC(EVAL_CALL_LEGACY);\n    PyObject *res = _PyEval_Vector(tstate, func, locals, NULL, 0, NULL);\n    Py_DECREF(func);\n    return res;\n}\n\n\n/* Interpreter main loop */\n\nPyObject *\nPyEval_EvalFrame(PyFrameObject *f)\n{\n    /* Function kept for backward compatibility */\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _PyEval_EvalFrame(tstate, f->f_frame, 0);\n}\n\nPyObject *\nPyEval_EvalFrameEx(PyFrameObject *f, int throwflag)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _PyEval_EvalFrame(tstate, f->f_frame, throwflag);\n}\n\n#include \"ceval_macros.h\"\n\n\nint _Py_CheckRecursiveCallPy(\n    PyThreadState *tstate)\n{\n    if (tstate->recursion_headroom) {\n        if (tstate->py_recursion_remaining < -50) {\n            /* Overflowing while handling an overflow. Give up. */\n            Py_FatalError(\"Cannot recover from Python stack overflow.\");\n        }\n    }\n    else {\n        if (tstate->py_recursion_remaining <= 0) {\n            tstate->recursion_headroom++;\n            _PyErr_Format(tstate, PyExc_RecursionError,\n                        \"maximum recursion depth exceeded\");\n            tstate->recursion_headroom--;\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic inline int _Py_EnterRecursivePy(PyThreadState *tstate) {\n    return (tstate->py_recursion_remaining-- <= 0) &&\n        _Py_CheckRecursiveCallPy(tstate);\n}\n\n\nstatic inline void _Py_LeaveRecursiveCallPy(PyThreadState *tstate)  {\n    tstate->py_recursion_remaining++;\n}\n\n\n/* Disable unused label warnings.  They are handy for debugging, even\n   if computed gotos aren't used. */\n\n/* TBD - what about other compilers? */\n#if defined(__GNUC__)\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wunused-label\"\n#elif defined(_MSC_VER) /* MS_WINDOWS */\n#  pragma warning(push)\n#  pragma warning(disable:4102)\n#endif\n\n\n/* _PyEval_EvalFrameDefault() is a *big* function,\n * so consume 3 units of C stack */\n#define PY_EVAL_C_STACK_UNITS 2\n\nPyObject* _Py_HOT_FUNCTION\n_PyEval_EvalFrameDefault(PyThreadState *tstate, _PyInterpreterFrame *frame, int throwflag)\n{\n    _Py_EnsureTstateNotNULL(tstate);\n    CALL_STAT_INC(pyeval_calls);\n\n#if USE_COMPUTED_GOTOS\n/* Import the static jump table */\n#include \"opcode_targets.h\"\n#endif\n\n#ifdef Py_STATS\n    int lastopcode = 0;\n#endif\n    // opcode is an 8-bit value to improve the code generated by MSVC\n    // for the big switch below (in combination with the EXTRA_CASES macro).\n    uint8_t opcode;        /* Current opcode */\n    int oparg;         /* Current opcode argument, if any */\n#ifdef LLTRACE\n    int lltrace = 0;\n#endif\n\n    _PyCFrame cframe;\n    _PyInterpreterFrame  entry_frame;\n    PyObject *kwnames = NULL; // Borrowed reference. Reset by CALL instructions.\n\n    /* WARNING: Because the _PyCFrame lives on the C stack,\n     * but can be accessed from a heap allocated object (tstate)\n     * strict stack discipline must be maintained.\n     */\n    _PyCFrame *prev_cframe = tstate->cframe;\n    cframe.previous = prev_cframe;\n    tstate->cframe = &cframe;\n\n    assert(tstate->interp->interpreter_trampoline != NULL);\n#ifdef Py_DEBUG\n    /* Set these to invalid but identifiable values for debugging. */\n    entry_frame.f_funcobj = (PyObject*)0xaaa0;\n    entry_frame.f_locals = (PyObject*)0xaaa1;\n    entry_frame.frame_obj = (PyFrameObject*)0xaaa2;\n    entry_frame.f_globals = (PyObject*)0xaaa3;\n    entry_frame.f_builtins = (PyObject*)0xaaa4;\n#endif\n    entry_frame.f_code = tstate->interp->interpreter_trampoline;\n    entry_frame.prev_instr =\n        _PyCode_CODE(tstate->interp->interpreter_trampoline);\n    entry_frame.stacktop = 0;\n    entry_frame.owner = FRAME_OWNED_BY_CSTACK;\n    entry_frame.return_offset = 0;\n    /* Push frame */\n    entry_frame.previous = prev_cframe->current_frame;\n    frame->previous = &entry_frame;\n    cframe.current_frame = frame;\n\n    tstate->c_recursion_remaining -= (PY_EVAL_C_STACK_UNITS - 1);\n    if (_Py_EnterRecursiveCallTstate(tstate, \"\")) {\n        tstate->c_recursion_remaining--;\n        tstate->py_recursion_remaining--;\n        goto exit_unwind;\n    }\n\n    /* support for generator.throw() */\n    if (throwflag) {\n        if (_Py_EnterRecursivePy(tstate)) {\n            goto exit_unwind;\n        }\n        /* Because this avoids the RESUME,\n         * we need to update instrumentation */\n        _Py_Instrument(frame->f_code, tstate->interp);\n        monitor_throw(tstate, frame, frame->prev_instr);\n        /* TO DO -- Monitor throw entry. */\n        goto resume_with_error;\n    }\n\n    /* Local \"register\" variables.\n     * These are cached values from the frame and code object.  */\n\n    _Py_CODEUNIT *next_instr;\n    PyObject **stack_pointer;\n\n/* Sets the above local variables from the frame */\n#define SET_LOCALS_FROM_FRAME() \\\n    assert(_PyInterpreterFrame_LASTI(frame) >= -1); \\\n    /* Jump back to the last instruction executed... */ \\\n    next_instr = frame->prev_instr + 1; \\\n    stack_pointer = _PyFrame_GetStackPointer(frame);\n\nstart_frame:\n    if (_Py_EnterRecursivePy(tstate)) {\n        goto exit_unwind;\n    }\n\nresume_frame:\n    SET_LOCALS_FROM_FRAME();\n\n#ifdef LLTRACE\n    {\n        if (frame != &entry_frame) {\n            int r = PyDict_Contains(GLOBALS(), &_Py_ID(__lltrace__));\n            if (r < 0) {\n                goto exit_unwind;\n            }\n            lltrace = r;\n        }\n        if (lltrace) {\n            lltrace_resume_frame(frame);\n        }\n    }\n#endif\n\n#ifdef Py_DEBUG\n    /* _PyEval_EvalFrameDefault() must not be called with an exception set,\n       because it can clear it (directly or indirectly) and so the\n       caller loses its exception */\n    assert(!_PyErr_Occurred(tstate));\n#endif\n\n    DISPATCH();\n\nhandle_eval_breaker:\n\n    /* Do periodic things, like check for signals and async I/0.\n     * We need to do reasonably frequently, but not too frequently.\n     * All loops should include a check of the eval breaker.\n     * We also check on return from any builtin function.\n     *\n     * ## More Details ###\n     *\n     * The eval loop (this function) normally executes the instructions\n     * of a code object sequentially.  However, the runtime supports a\n     * number of out-of-band execution scenarios that may pause that\n     * sequential execution long enough to do that out-of-band work\n     * in the current thread using the current PyThreadState.\n     *\n     * The scenarios include:\n     *\n     *  - cyclic garbage collection\n     *  - GIL drop requests\n     *  - \"async\" exceptions\n     *  - \"pending calls\"  (some only in the main thread)\n     *  - signal handling (only in the main thread)\n     *\n     * When the need for one of the above is detected, the eval loop\n     * pauses long enough to handle the detected case.  Then, if doing\n     * so didn't trigger an exception, the eval loop resumes executing\n     * the sequential instructions.\n     *\n     * To make this work, the eval loop periodically checks if any\n     * of the above needs to happen.  The individual checks can be\n     * expensive if computed each time, so a while back we switched\n     * to using pre-computed, per-interpreter variables for the checks,\n     * and later consolidated that to a single \"eval breaker\" variable\n     * (now a PyInterpreterState field).\n     *\n     * For the longest time, the eval breaker check would happen\n     * frequently, every 5 or so times through the loop, regardless\n     * of what instruction ran last or what would run next.  Then, in\n     * early 2021 (gh-18334, commit 4958f5d), we switched to checking\n     * the eval breaker less frequently, by hard-coding the check to\n     * specific places in the eval loop (e.g. certain instructions).\n     * The intent then was to check after returning from calls\n     * and on the back edges of loops.\n     *\n     * In addition to being more efficient, that approach keeps\n     * the eval loop from running arbitrary code between instructions\n     * that don't handle that well.  (See gh-74174.)\n     *\n     * Currently, the eval breaker check happens here at the\n     * \"handle_eval_breaker\" label.  Some instructions come here\n     * explicitly (goto) and some indirectly.  Notably, the check\n     * happens on back edges in the control flow graph, which\n     * pretty much applies to all loops and most calls.\n     * (See bytecodes.c for exact information.)\n     *\n     * One consequence of this approach is that it might not be obvious\n     * how to force any specific thread to pick up the eval breaker,\n     * or for any specific thread to not pick it up.  Mostly this\n     * involves judicious uses of locks and careful ordering of code,\n     * while avoiding code that might trigger the eval breaker\n     * until so desired.\n     */\n    if (_Py_HandlePending(tstate) != 0) {\n        goto error;\n    }\n    DISPATCH();\n\n    {\n    /* Start instructions */\n#if !USE_COMPUTED_GOTOS\n    dispatch_opcode:\n        switch (opcode)\n#endif\n        {\n\n#include \"generated_cases.c.h\"\n\n    /* INSTRUMENTED_LINE has to be here, rather than in bytecodes.c,\n     * because it needs to capture frame->prev_instr before it is updated,\n     * as happens in the standard instruction prologue.\n     */\n#if USE_COMPUTED_GOTOS\n        TARGET_INSTRUMENTED_LINE:\n#else\n        case INSTRUMENTED_LINE:\n#endif\n    {\n        _Py_CODEUNIT *prev = frame->prev_instr;\n        _Py_CODEUNIT *here = frame->prev_instr = next_instr;\n        _PyFrame_SetStackPointer(frame, stack_pointer);\n        int original_opcode = _Py_call_instrumentation_line(\n                tstate, frame, here, prev);\n        stack_pointer = _PyFrame_GetStackPointer(frame);\n        if (original_opcode < 0) {\n            next_instr = here+1;\n            goto error;\n        }\n        next_instr = frame->prev_instr;\n        if (next_instr != here) {\n            DISPATCH();\n        }\n        if (_PyOpcode_Caches[original_opcode]) {\n            _PyBinaryOpCache *cache = (_PyBinaryOpCache *)(next_instr+1);\n            /* Prevent the underlying instruction from specializing\n             * and overwriting the instrumentation. */\n            INCREMENT_ADAPTIVE_COUNTER(cache->counter);\n        }\n        opcode = original_opcode;\n        DISPATCH_GOTO();\n    }\n\n\n#if USE_COMPUTED_GOTOS\n        _unknown_opcode:\n#else\n        EXTRA_CASES  // From opcode.h, a 'case' for each unused opcode\n#endif\n            /* Tell C compilers not to hold the opcode variable in the loop.\n               next_instr points the current instruction without TARGET(). */\n            opcode = next_instr->op.code;\n            _PyErr_Format(tstate, PyExc_SystemError,\n                          \"%U:%d: unknown opcode %d\",\n                          frame->f_code->co_filename,\n                          PyUnstable_InterpreterFrame_GetLine(frame),\n                          opcode);\n            goto error;\n\n        } /* End instructions */\n\n        /* This should never be reached. Every opcode should end with DISPATCH()\n           or goto error. */\n        Py_UNREACHABLE();\n\nunbound_local_error:\n        {\n            format_exc_check_arg(tstate, PyExc_UnboundLocalError,\n                UNBOUNDLOCAL_ERROR_MSG,\n                PyTuple_GetItem(frame->f_code->co_localsplusnames, oparg)\n            );\n            goto error;\n        }\n\npop_4_error:\n    STACK_SHRINK(1);\npop_3_error:\n    STACK_SHRINK(1);\npop_2_error:\n    STACK_SHRINK(1);\npop_1_error:\n    STACK_SHRINK(1);\nerror:\n        kwnames = NULL;\n        /* Double-check exception status. */\n#ifdef NDEBUG\n        if (!_PyErr_Occurred(tstate)) {\n            _PyErr_SetString(tstate, PyExc_SystemError,\n                             \"error return without exception set\");\n        }\n#else\n        assert(_PyErr_Occurred(tstate));\n#endif\n\n        /* Log traceback info. */\n        assert(frame != &entry_frame);\n        if (!_PyFrame_IsIncomplete(frame)) {\n            PyFrameObject *f = _PyFrame_GetFrameObject(frame);\n            if (f != NULL) {\n                PyTraceBack_Here(f);\n            }\n        }\n        monitor_raise(tstate, frame, next_instr-1);\nexception_unwind:\n        {\n            /* We can't use frame->f_lasti here, as RERAISE may have set it */\n            int offset = INSTR_OFFSET()-1;\n            int level, handler, lasti;\n            if (get_exception_handler(frame->f_code, offset, &level, &handler, &lasti) == 0) {\n                // No handlers, so exit.\n                assert(_PyErr_Occurred(tstate));\n\n                /* Pop remaining stack entries. */\n                PyObject **stackbase = _PyFrame_Stackbase(frame);\n                while (stack_pointer > stackbase) {\n                    PyObject *o = POP();\n                    Py_XDECREF(o);\n                }\n                assert(STACK_LEVEL() == 0);\n                _PyFrame_SetStackPointer(frame, stack_pointer);\n                monitor_unwind(tstate, frame, next_instr-1);\n                goto exit_unwind;\n            }\n\n            assert(STACK_LEVEL() >= level);\n            PyObject **new_top = _PyFrame_Stackbase(frame) + level;\n            while (stack_pointer > new_top) {\n                PyObject *v = POP();\n                Py_XDECREF(v);\n            }\n            if (lasti) {\n                int frame_lasti = _PyInterpreterFrame_LASTI(frame);\n                PyObject *lasti = PyLong_FromLong(frame_lasti);\n                if (lasti == NULL) {\n                    goto exception_unwind;\n                }\n                PUSH(lasti);\n            }\n\n            /* Make the raw exception data\n                available to the handler,\n                so a program can emulate the\n                Python main loop. */\n            PyObject *exc = _PyErr_GetRaisedException(tstate);\n            PUSH(exc);\n            JUMPTO(handler);\n            if (monitor_handled(tstate, frame, next_instr, exc) < 0) {\n                goto exception_unwind;\n            }\n            /* Resume normal execution */\n            DISPATCH();\n        }\n    }\n\nexit_unwind:\n    assert(_PyErr_Occurred(tstate));\n    _Py_LeaveRecursiveCallPy(tstate);\n    assert(frame != &entry_frame);\n    // GH-99729: We need to unlink the frame *before* clearing it:\n    _PyInterpreterFrame *dying = frame;\n    frame = cframe.current_frame = dying->previous;\n    _PyEvalFrameClearAndPop(tstate, dying);\n    frame->return_offset = 0;\n    if (frame == &entry_frame) {\n        /* Restore previous cframe and exit */\n        tstate->cframe = cframe.previous;\n        assert(tstate->cframe->current_frame == frame->previous);\n        tstate->c_recursion_remaining += PY_EVAL_C_STACK_UNITS;\n        return NULL;\n    }\n\nresume_with_error:\n    SET_LOCALS_FROM_FRAME();\n    goto error;\n\n}\n#if defined(__GNUC__)\n#  pragma GCC diagnostic pop\n#elif defined(_MSC_VER) /* MS_WINDOWS */\n#  pragma warning(pop)\n#endif\n\nstatic void\nformat_missing(PyThreadState *tstate, const char *kind,\n               PyCodeObject *co, PyObject *names, PyObject *qualname)\n{\n    int err;\n    Py_ssize_t len = PyList_GET_SIZE(names);\n    PyObject *name_str, *comma, *tail, *tmp;\n\n    assert(PyList_CheckExact(names));\n    assert(len >= 1);\n    /* Deal with the joys of natural language. */\n    switch (len) {\n    case 1:\n        name_str = PyList_GET_ITEM(names, 0);\n        Py_INCREF(name_str);\n        break;\n    case 2:\n        name_str = PyUnicode_FromFormat(\"%U and %U\",\n                                        PyList_GET_ITEM(names, len - 2),\n                                        PyList_GET_ITEM(names, len - 1));\n        break;\n    default:\n        tail = PyUnicode_FromFormat(\", %U, and %U\",\n                                    PyList_GET_ITEM(names, len - 2),\n                                    PyList_GET_ITEM(names, len - 1));\n        if (tail == NULL)\n            return;\n        /* Chop off the last two objects in the list. This shouldn't actually\n           fail, but we can't be too careful. */\n        err = PyList_SetSlice(names, len - 2, len, NULL);\n        if (err == -1) {\n            Py_DECREF(tail);\n            return;\n        }\n        /* Stitch everything up into a nice comma-separated list. */\n        comma = PyUnicode_FromString(\", \");\n        if (comma == NULL) {\n            Py_DECREF(tail);\n            return;\n        }\n        tmp = PyUnicode_Join(comma, names);\n        Py_DECREF(comma);\n        if (tmp == NULL) {\n            Py_DECREF(tail);\n            return;\n        }\n        name_str = PyUnicode_Concat(tmp, tail);\n        Py_DECREF(tmp);\n        Py_DECREF(tail);\n        break;\n    }\n    if (name_str == NULL)\n        return;\n    _PyErr_Format(tstate, PyExc_TypeError,\n                  \"%U() missing %i required %s argument%s: %U\",\n                  qualname,\n                  len,\n                  kind,\n                  len == 1 ? \"\" : \"s\",\n                  name_str);\n    Py_DECREF(name_str);\n}\n\nstatic void\nmissing_arguments(PyThreadState *tstate, PyCodeObject *co,\n                  Py_ssize_t missing, Py_ssize_t defcount,\n                  PyObject **localsplus, PyObject *qualname)\n{\n    Py_ssize_t i, j = 0;\n    Py_ssize_t start, end;\n    int positional = (defcount != -1);\n    const char *kind = positional ? \"positional\" : \"keyword-only\";\n    PyObject *missing_names;\n\n    /* Compute the names of the arguments that are missing. */\n    missing_names = PyList_New(missing);\n    if (missing_names == NULL)\n        return;\n    if (positional) {\n        start = 0;\n        end = co->co_argcount - defcount;\n    }\n    else {\n        start = co->co_argcount;\n        end = start + co->co_kwonlyargcount;\n    }\n    for (i = start; i < end; i++) {\n        if (localsplus[i] == NULL) {\n            PyObject *raw = PyTuple_GET_ITEM(co->co_localsplusnames, i);\n            PyObject *name = PyObject_Repr(raw);\n            if (name == NULL) {\n                Py_DECREF(missing_names);\n                return;\n            }\n            PyList_SET_ITEM(missing_names, j++, name);\n        }\n    }\n    assert(j == missing);\n    format_missing(tstate, kind, co, missing_names, qualname);\n    Py_DECREF(missing_names);\n}\n\nstatic void\ntoo_many_positional(PyThreadState *tstate, PyCodeObject *co,\n                    Py_ssize_t given, PyObject *defaults,\n                    PyObject **localsplus, PyObject *qualname)\n{\n    int plural;\n    Py_ssize_t kwonly_given = 0;\n    Py_ssize_t i;\n    PyObject *sig, *kwonly_sig;\n    Py_ssize_t co_argcount = co->co_argcount;\n\n    assert((co->co_flags & CO_VARARGS) == 0);\n    /* Count missing keyword-only args. */\n    for (i = co_argcount; i < co_argcount + co->co_kwonlyargcount; i++) {\n        if (localsplus[i] != NULL) {\n            kwonly_given++;\n        }\n    }\n    Py_ssize_t defcount = defaults == NULL ? 0 : PyTuple_GET_SIZE(defaults);\n    if (defcount) {\n        Py_ssize_t atleast = co_argcount - defcount;\n        plural = 1;\n        sig = PyUnicode_FromFormat(\"from %zd to %zd\", atleast, co_argcount);\n    }\n    else {\n        plural = (co_argcount != 1);\n        sig = PyUnicode_FromFormat(\"%zd\", co_argcount);\n    }\n    if (sig == NULL)\n        return;\n    if (kwonly_given) {\n        const char *format = \" positional argument%s (and %zd keyword-only argument%s)\";\n        kwonly_sig = PyUnicode_FromFormat(format,\n                                          given != 1 ? \"s\" : \"\",\n                                          kwonly_given,\n                                          kwonly_given != 1 ? \"s\" : \"\");\n        if (kwonly_sig == NULL) {\n            Py_DECREF(sig);\n            return;\n        }\n    }\n    else {\n        /* This will not fail. */\n        kwonly_sig = PyUnicode_FromString(\"\");\n        assert(kwonly_sig != NULL);\n    }\n    _PyErr_Format(tstate, PyExc_TypeError,\n                  \"%U() takes %U positional argument%s but %zd%U %s given\",\n                  qualname,\n                  sig,\n                  plural ? \"s\" : \"\",\n                  given,\n                  kwonly_sig,\n                  given == 1 && !kwonly_given ? \"was\" : \"were\");\n    Py_DECREF(sig);\n    Py_DECREF(kwonly_sig);\n}\n\nstatic int\npositional_only_passed_as_keyword(PyThreadState *tstate, PyCodeObject *co,\n                                  Py_ssize_t kwcount, PyObject* kwnames,\n                                  PyObject *qualname)\n{\n    int posonly_conflicts = 0;\n    PyObject* posonly_names = PyList_New(0);\n    if (posonly_names == NULL) {\n        goto fail;\n    }\n    for(int k=0; k < co->co_posonlyargcount; k++){\n        PyObject* posonly_name = PyTuple_GET_ITEM(co->co_localsplusnames, k);\n\n        for (int k2=0; k2<kwcount; k2++){\n            /* Compare the pointers first and fallback to PyObject_RichCompareBool*/\n            PyObject* kwname = PyTuple_GET_ITEM(kwnames, k2);\n            if (kwname == posonly_name){\n                if(PyList_Append(posonly_names, kwname) != 0) {\n                    goto fail;\n                }\n                posonly_conflicts++;\n                continue;\n            }\n\n            int cmp = PyObject_RichCompareBool(posonly_name, kwname, Py_EQ);\n\n            if ( cmp > 0) {\n                if(PyList_Append(posonly_names, kwname) != 0) {\n                    goto fail;\n                }\n                posonly_conflicts++;\n            } else if (cmp < 0) {\n                goto fail;\n            }\n\n        }\n    }\n    if (posonly_conflicts) {\n        PyObject* comma = PyUnicode_FromString(\", \");\n        if (comma == NULL) {\n            goto fail;\n        }\n        PyObject* error_names = PyUnicode_Join(comma, posonly_names);\n        Py_DECREF(comma);\n        if (error_names == NULL) {\n            goto fail;\n        }\n        _PyErr_Format(tstate, PyExc_TypeError,\n                      \"%U() got some positional-only arguments passed\"\n                      \" as keyword arguments: '%U'\",\n                      qualname, error_names);\n        Py_DECREF(error_names);\n        goto fail;\n    }\n\n    Py_DECREF(posonly_names);\n    return 0;\n\nfail:\n    Py_XDECREF(posonly_names);\n    return 1;\n\n}\n\n\nstatic inline unsigned char *\nscan_back_to_entry_start(unsigned char *p) {\n    for (; (p[0]&128) == 0; p--);\n    return p;\n}\n\nstatic inline unsigned char *\nskip_to_next_entry(unsigned char *p, unsigned char *end) {\n    while (p < end && ((p[0] & 128) == 0)) {\n        p++;\n    }\n    return p;\n}\n\n\n#define MAX_LINEAR_SEARCH 40\n\nstatic int\nget_exception_handler(PyCodeObject *code, int index, int *level, int *handler, int *lasti)\n{\n    unsigned char *start = (unsigned char *)PyBytes_AS_STRING(code->co_exceptiontable);\n    unsigned char *end = start + PyBytes_GET_SIZE(code->co_exceptiontable);\n    /* Invariants:\n     * start_table == end_table OR\n     * start_table points to a legal entry and end_table points\n     * beyond the table or to a legal entry that is after index.\n     */\n    if (end - start > MAX_LINEAR_SEARCH) {\n        int offset;\n        parse_varint(start, &offset);\n        if (offset > index) {\n            return 0;\n        }\n        do {\n            unsigned char * mid = start + ((end-start)>>1);\n            mid = scan_back_to_entry_start(mid);\n            parse_varint(mid, &offset);\n            if (offset > index) {\n                end = mid;\n            }\n            else {\n                start = mid;\n            }\n\n        } while (end - start > MAX_LINEAR_SEARCH);\n    }\n    unsigned char *scan = start;\n    while (scan < end) {\n        int start_offset, size;\n        scan = parse_varint(scan, &start_offset);\n        if (start_offset > index) {\n            break;\n        }\n        scan = parse_varint(scan, &size);\n        if (start_offset + size > index) {\n            scan = parse_varint(scan, handler);\n            int depth_and_lasti;\n            parse_varint(scan, &depth_and_lasti);\n            *level = depth_and_lasti >> 1;\n            *lasti = depth_and_lasti & 1;\n            return 1;\n        }\n        scan = skip_to_next_entry(scan, end);\n    }\n    return 0;\n}\n\nstatic int\ninitialize_locals(PyThreadState *tstate, PyFunctionObject *func,\n    PyObject **localsplus, PyObject *const *args,\n    Py_ssize_t argcount, PyObject *kwnames)\n{\n    PyCodeObject *co = (PyCodeObject*)func->func_code;\n    const Py_ssize_t total_args = co->co_argcount + co->co_kwonlyargcount;\n\n    /* Create a dictionary for keyword parameters (**kwags) */\n    PyObject *kwdict;\n    Py_ssize_t i;\n    if (co->co_flags & CO_VARKEYWORDS) {\n        kwdict = PyDict_New();\n        if (kwdict == NULL) {\n            goto fail_pre_positional;\n        }\n        i = total_args;\n        if (co->co_flags & CO_VARARGS) {\n            i++;\n        }\n        assert(localsplus[i] == NULL);\n        localsplus[i] = kwdict;\n    }\n    else {\n        kwdict = NULL;\n    }\n\n    /* Copy all positional arguments into local variables */\n    Py_ssize_t j, n;\n    if (argcount > co->co_argcount) {\n        n = co->co_argcount;\n    }\n    else {\n        n = argcount;\n    }\n    for (j = 0; j < n; j++) {\n        PyObject *x = args[j];\n        assert(localsplus[j] == NULL);\n        localsplus[j] = x;\n    }\n\n    /* Pack other positional arguments into the *args argument */\n    if (co->co_flags & CO_VARARGS) {\n        PyObject *u = NULL;\n        if (argcount == n) {\n            u = Py_NewRef(&_Py_SINGLETON(tuple_empty));\n        }\n        else {\n            assert(args != NULL);\n            u = _PyTuple_FromArraySteal(args + n, argcount - n);\n        }\n        if (u == NULL) {\n            goto fail_post_positional;\n        }\n        assert(localsplus[total_args] == NULL);\n        localsplus[total_args] = u;\n    }\n    else if (argcount > n) {\n        /* Too many postional args. Error is reported later */\n        for (j = n; j < argcount; j++) {\n            Py_DECREF(args[j]);\n        }\n    }\n\n    /* Handle keyword arguments */\n    if (kwnames != NULL) {\n        Py_ssize_t kwcount = PyTuple_GET_SIZE(kwnames);\n        for (i = 0; i < kwcount; i++) {\n            PyObject **co_varnames;\n            PyObject *keyword = PyTuple_GET_ITEM(kwnames, i);\n            PyObject *value = args[i+argcount];\n            Py_ssize_t j;\n\n            if (keyword == NULL || !PyUnicode_Check(keyword)) {\n                _PyErr_Format(tstate, PyExc_TypeError,\n                            \"%U() keywords must be strings\",\n                          func->func_qualname);\n                goto kw_fail;\n            }\n\n            /* Speed hack: do raw pointer compares. As names are\n            normally interned this should almost always hit. */\n            co_varnames = ((PyTupleObject *)(co->co_localsplusnames))->ob_item;\n            for (j = co->co_posonlyargcount; j < total_args; j++) {\n                PyObject *varname = co_varnames[j];\n                if (varname == keyword) {\n                    goto kw_found;\n                }\n            }\n\n            /* Slow fallback, just in case */\n            for (j = co->co_posonlyargcount; j < total_args; j++) {\n                PyObject *varname = co_varnames[j];\n                int cmp = PyObject_RichCompareBool( keyword, varname, Py_EQ);\n                if (cmp > 0) {\n                    goto kw_found;\n                }\n                else if (cmp < 0) {\n                    goto kw_fail;\n                }\n            }\n\n            assert(j >= total_args);\n            if (kwdict == NULL) {\n\n                if (co->co_posonlyargcount\n                    && positional_only_passed_as_keyword(tstate, co,\n                                                        kwcount, kwnames,\n                                                        func->func_qualname))\n                {\n                    goto kw_fail;\n                }\n\n                _PyErr_Format(tstate, PyExc_TypeError,\n                            \"%U() got an unexpected keyword argument '%S'\",\n                          func->func_qualname, keyword);\n                goto kw_fail;\n            }\n\n            if (PyDict_SetItem(kwdict, keyword, value) == -1) {\n                goto kw_fail;\n            }\n            Py_DECREF(value);\n            continue;\n\n        kw_fail:\n            for (;i < kwcount; i++) {\n                PyObject *value = args[i+argcount];\n                Py_DECREF(value);\n            }\n            goto fail_post_args;\n\n        kw_found:\n            if (localsplus[j] != NULL) {\n                _PyErr_Format(tstate, PyExc_TypeError,\n                            \"%U() got multiple values for argument '%S'\",\n                          func->func_qualname, keyword);\n                goto kw_fail;\n            }\n            localsplus[j] = value;\n        }\n    }\n\n    /* Check the number of positional arguments */\n    if ((argcount > co->co_argcount) && !(co->co_flags & CO_VARARGS)) {\n        too_many_positional(tstate, co, argcount, func->func_defaults, localsplus,\n                            func->func_qualname);\n        goto fail_post_args;\n    }\n\n    /* Add missing positional arguments (copy default values from defs) */\n    if (argcount < co->co_argcount) {\n        Py_ssize_t defcount = func->func_defaults == NULL ? 0 : PyTuple_GET_SIZE(func->func_defaults);\n        Py_ssize_t m = co->co_argcount - defcount;\n        Py_ssize_t missing = 0;\n        for (i = argcount; i < m; i++) {\n            if (localsplus[i] == NULL) {\n                missing++;\n            }\n        }\n        if (missing) {\n            missing_arguments(tstate, co, missing, defcount, localsplus,\n                              func->func_qualname);\n            goto fail_post_args;\n        }\n        if (n > m)\n            i = n - m;\n        else\n            i = 0;\n        if (defcount) {\n            PyObject **defs = &PyTuple_GET_ITEM(func->func_defaults, 0);\n            for (; i < defcount; i++) {\n                if (localsplus[m+i] == NULL) {\n                    PyObject *def = defs[i];\n                    localsplus[m+i] = Py_NewRef(def);\n                }\n            }\n        }\n    }\n\n    /* Add missing keyword arguments (copy default values from kwdefs) */\n    if (co->co_kwonlyargcount > 0) {\n        Py_ssize_t missing = 0;\n        for (i = co->co_argcount; i < total_args; i++) {\n            if (localsplus[i] != NULL)\n                continue;\n            PyObject *varname = PyTuple_GET_ITEM(co->co_localsplusnames, i);\n            if (func->func_kwdefaults != NULL) {\n                PyObject *def = PyDict_GetItemWithError(func->func_kwdefaults, varname);\n                if (def) {\n                    localsplus[i] = Py_NewRef(def);\n                    continue;\n                }\n                else if (_PyErr_Occurred(tstate)) {\n                    goto fail_post_args;\n                }\n            }\n            missing++;\n        }\n        if (missing) {\n            missing_arguments(tstate, co, missing, -1, localsplus,\n                              func->func_qualname);\n            goto fail_post_args;\n        }\n    }\n    return 0;\n\nfail_pre_positional:\n    for (j = 0; j < argcount; j++) {\n        Py_DECREF(args[j]);\n    }\n    /* fall through */\nfail_post_positional:\n    if (kwnames) {\n        Py_ssize_t kwcount = PyTuple_GET_SIZE(kwnames);\n        for (j = argcount; j < argcount+kwcount; j++) {\n            Py_DECREF(args[j]);\n        }\n    }\n    /* fall through */\nfail_post_args:\n    return -1;\n}\n\nstatic void\nclear_thread_frame(PyThreadState *tstate, _PyInterpreterFrame * frame)\n{\n    assert(frame->owner == FRAME_OWNED_BY_THREAD);\n    // Make sure that this is, indeed, the top frame. We can't check this in\n    // _PyThreadState_PopFrame, since f_code is already cleared at that point:\n    assert((PyObject **)frame + frame->f_code->co_framesize ==\n        tstate->datastack_top);\n    tstate->c_recursion_remaining--;\n    assert(frame->frame_obj == NULL || frame->frame_obj->f_frame == frame);\n    _PyFrame_ClearExceptCode(frame);\n    Py_DECREF(frame->f_code);\n    tstate->c_recursion_remaining++;\n    _PyThreadState_PopFrame(tstate, frame);\n}\n\nstatic void\nclear_gen_frame(PyThreadState *tstate, _PyInterpreterFrame * frame)\n{\n    assert(frame->owner == FRAME_OWNED_BY_GENERATOR);\n    PyGenObject *gen = _PyFrame_GetGenerator(frame);\n    gen->gi_frame_state = FRAME_CLEARED;\n    assert(tstate->exc_info == &gen->gi_exc_state);\n    tstate->exc_info = gen->gi_exc_state.previous_item;\n    gen->gi_exc_state.previous_item = NULL;\n    tstate->c_recursion_remaining--;\n    assert(frame->frame_obj == NULL || frame->frame_obj->f_frame == frame);\n    _PyFrame_ClearExceptCode(frame);\n    tstate->c_recursion_remaining++;\n    frame->previous = NULL;\n}\n\nstatic void\n_PyEvalFrameClearAndPop(PyThreadState *tstate, _PyInterpreterFrame * frame)\n{\n    if (frame->owner == FRAME_OWNED_BY_THREAD) {\n        clear_thread_frame(tstate, frame);\n    }\n    else {\n        clear_gen_frame(tstate, frame);\n    }\n}\n\n/* Consumes references to func, locals and all the args */\nstatic _PyInterpreterFrame *\n_PyEvalFramePushAndInit(PyThreadState *tstate, PyFunctionObject *func,\n                        PyObject *locals, PyObject* const* args,\n                        size_t argcount, PyObject *kwnames)\n{\n    PyCodeObject * code = (PyCodeObject *)func->func_code;\n    CALL_STAT_INC(frames_pushed);\n    _PyInterpreterFrame *frame = _PyThreadState_PushFrame(tstate, code->co_framesize);\n    if (frame == NULL) {\n        goto fail;\n    }\n    _PyFrame_Initialize(frame, func, locals, code, 0);\n    if (initialize_locals(tstate, func, frame->localsplus, args, argcount, kwnames)) {\n        assert(frame->owner == FRAME_OWNED_BY_THREAD);\n        clear_thread_frame(tstate, frame);\n        return NULL;\n    }\n    return frame;\nfail:\n    /* Consume the references */\n    for (size_t i = 0; i < argcount; i++) {\n        Py_DECREF(args[i]);\n    }\n    if (kwnames) {\n        Py_ssize_t kwcount = PyTuple_GET_SIZE(kwnames);\n        for (Py_ssize_t i = 0; i < kwcount; i++) {\n            Py_DECREF(args[i+argcount]);\n        }\n    }\n    PyErr_NoMemory();\n    return NULL;\n}\n\n/* Same as _PyEvalFramePushAndInit but takes an args tuple and kwargs dict.\n   Steals references to func, callargs and kwargs.\n*/\nstatic _PyInterpreterFrame *\n_PyEvalFramePushAndInit_Ex(PyThreadState *tstate, PyFunctionObject *func,\n    PyObject *locals, Py_ssize_t nargs, PyObject *callargs, PyObject *kwargs)\n{\n    bool has_dict = (kwargs != NULL && PyDict_GET_SIZE(kwargs) > 0);\n    PyObject *kwnames = NULL;\n    PyObject *const *newargs;\n    if (has_dict) {\n        newargs = _PyStack_UnpackDict(tstate, _PyTuple_ITEMS(callargs), nargs, kwargs, &kwnames);\n        if (newargs == NULL) {\n            Py_DECREF(func);\n            goto error;\n        }\n    }\n    else {\n        newargs = &PyTuple_GET_ITEM(callargs, 0);\n        /* We need to incref all our args since the new frame steals the references. */\n        for (Py_ssize_t i = 0; i < nargs; ++i) {\n            Py_INCREF(PyTuple_GET_ITEM(callargs, i));\n        }\n    }\n    _PyInterpreterFrame *new_frame = _PyEvalFramePushAndInit(\n        tstate, (PyFunctionObject *)func, locals,\n        newargs, nargs, kwnames\n    );\n    if (has_dict) {\n        _PyStack_UnpackDict_FreeNoDecRef(newargs, kwnames);\n    }\n    /* No need to decref func here because the reference has been stolen by\n       _PyEvalFramePushAndInit.\n    */\n    Py_DECREF(callargs);\n    Py_XDECREF(kwargs);\n    return new_frame;\nerror:\n    Py_DECREF(callargs);\n    Py_XDECREF(kwargs);\n    return NULL;\n}\n\nPyObject *\n_PyEval_Vector(PyThreadState *tstate, PyFunctionObject *func,\n               PyObject *locals,\n               PyObject* const* args, size_t argcount,\n               PyObject *kwnames)\n{\n    /* _PyEvalFramePushAndInit consumes the references\n     * to func, locals and all its arguments */\n    Py_INCREF(func);\n    Py_XINCREF(locals);\n    for (size_t i = 0; i < argcount; i++) {\n        Py_INCREF(args[i]);\n    }\n    if (kwnames) {\n        Py_ssize_t kwcount = PyTuple_GET_SIZE(kwnames);\n        for (Py_ssize_t i = 0; i < kwcount; i++) {\n            Py_INCREF(args[i+argcount]);\n        }\n    }\n    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n        tstate, func, locals, args, argcount, kwnames);\n    if (frame == NULL) {\n        return NULL;\n    }\n    EVAL_CALL_STAT_INC(EVAL_CALL_VECTOR);\n    return _PyEval_EvalFrame(tstate, frame, 0);\n}\n\n/* Legacy API */\nPyObject *\nPyEval_EvalCodeEx(PyObject *_co, PyObject *globals, PyObject *locals,\n                  PyObject *const *args, int argcount,\n                  PyObject *const *kws, int kwcount,\n                  PyObject *const *defs, int defcount,\n                  PyObject *kwdefs, PyObject *closure)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    PyObject *res = NULL;\n    PyObject *defaults = _PyTuple_FromArray(defs, defcount);\n    if (defaults == NULL) {\n        return NULL;\n    }\n    PyObject *builtins = _PyEval_BuiltinsFromGlobals(tstate, globals); // borrowed ref\n    if (builtins == NULL) {\n        Py_DECREF(defaults);\n        return NULL;\n    }\n    if (locals == NULL) {\n        locals = globals;\n    }\n    PyObject *kwnames = NULL;\n    PyObject *const *allargs;\n    PyObject **newargs = NULL;\n    PyFunctionObject *func = NULL;\n    if (kwcount == 0) {\n        allargs = args;\n    }\n    else {\n        kwnames = PyTuple_New(kwcount);\n        if (kwnames == NULL) {\n            goto fail;\n        }\n        newargs = PyMem_Malloc(sizeof(PyObject *)*(kwcount+argcount));\n        if (newargs == NULL) {\n            goto fail;\n        }\n        for (int i = 0; i < argcount; i++) {\n            newargs[i] = args[i];\n        }\n        for (int i = 0; i < kwcount; i++) {\n            PyTuple_SET_ITEM(kwnames, i, Py_NewRef(kws[2*i]));\n            newargs[argcount+i] = kws[2*i+1];\n        }\n        allargs = newargs;\n    }\n    PyFrameConstructor constr = {\n        .fc_globals = globals,\n        .fc_builtins = builtins,\n        .fc_name = ((PyCodeObject *)_co)->co_name,\n        .fc_qualname = ((PyCodeObject *)_co)->co_name,\n        .fc_code = _co,\n        .fc_defaults = defaults,\n        .fc_kwdefaults = kwdefs,\n        .fc_closure = closure\n    };\n    func = _PyFunction_FromConstructor(&constr);\n    if (func == NULL) {\n        goto fail;\n    }\n    EVAL_CALL_STAT_INC(EVAL_CALL_LEGACY);\n    res = _PyEval_Vector(tstate, func, locals,\n                         allargs, argcount,\n                         kwnames);\nfail:\n    Py_XDECREF(func);\n    Py_XDECREF(kwnames);\n    PyMem_Free(newargs);\n    Py_DECREF(defaults);\n    return res;\n}\n\n\n/* Logic for the raise statement (too complicated for inlining).\n   This *consumes* a reference count to each of its arguments. */\nstatic int\ndo_raise(PyThreadState *tstate, PyObject *exc, PyObject *cause)\n{\n    PyObject *type = NULL, *value = NULL;\n\n    if (exc == NULL) {\n        /* Reraise */\n        _PyErr_StackItem *exc_info = _PyErr_GetTopmostException(tstate);\n        exc = exc_info->exc_value;\n        if (Py_IsNone(exc) || exc == NULL) {\n            _PyErr_SetString(tstate, PyExc_RuntimeError,\n                             \"No active exception to reraise\");\n            return 0;\n        }\n        Py_INCREF(exc);\n        assert(PyExceptionInstance_Check(exc));\n        _PyErr_SetRaisedException(tstate, exc);\n        return 1;\n    }\n\n    /* We support the following forms of raise:\n       raise\n       raise <instance>\n       raise <type> */\n\n    if (PyExceptionClass_Check(exc)) {\n        type = exc;\n        value = _PyObject_CallNoArgs(exc);\n        if (value == NULL)\n            goto raise_error;\n        if (!PyExceptionInstance_Check(value)) {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"calling %R should have returned an instance of \"\n                          \"BaseException, not %R\",\n                          type, Py_TYPE(value));\n             goto raise_error;\n        }\n    }\n    else if (PyExceptionInstance_Check(exc)) {\n        value = exc;\n        type = PyExceptionInstance_Class(exc);\n        Py_INCREF(type);\n    }\n    else {\n        /* Not something you can raise.  You get an exception\n           anyway, just not what you specified :-) */\n        Py_DECREF(exc);\n        _PyErr_SetString(tstate, PyExc_TypeError,\n                         \"exceptions must derive from BaseException\");\n        goto raise_error;\n    }\n\n    assert(type != NULL);\n    assert(value != NULL);\n\n    if (cause) {\n        PyObject *fixed_cause;\n        if (PyExceptionClass_Check(cause)) {\n            fixed_cause = _PyObject_CallNoArgs(cause);\n            if (fixed_cause == NULL)\n                goto raise_error;\n            Py_DECREF(cause);\n        }\n        else if (PyExceptionInstance_Check(cause)) {\n            fixed_cause = cause;\n        }\n        else if (Py_IsNone(cause)) {\n            Py_DECREF(cause);\n            fixed_cause = NULL;\n        }\n        else {\n            _PyErr_SetString(tstate, PyExc_TypeError,\n                             \"exception causes must derive from \"\n                             \"BaseException\");\n            goto raise_error;\n        }\n        PyException_SetCause(value, fixed_cause);\n    }\n\n    _PyErr_SetObject(tstate, type, value);\n    /* _PyErr_SetObject incref's its arguments */\n    Py_DECREF(value);\n    Py_DECREF(type);\n    return 0;\n\nraise_error:\n    Py_XDECREF(value);\n    Py_XDECREF(type);\n    Py_XDECREF(cause);\n    return 0;\n}\n\n/* Logic for matching an exception in an except* clause (too\n   complicated for inlining).\n*/\n\nstatic int\nexception_group_match(PyObject* exc_value, PyObject *match_type,\n                      PyObject **match, PyObject **rest)\n{\n    if (Py_IsNone(exc_value)) {\n        *match = Py_NewRef(Py_None);\n        *rest = Py_NewRef(Py_None);\n        return 0;\n    }\n    assert(PyExceptionInstance_Check(exc_value));\n\n    if (PyErr_GivenExceptionMatches(exc_value, match_type)) {\n        /* Full match of exc itself */\n        bool is_eg = _PyBaseExceptionGroup_Check(exc_value);\n        if (is_eg) {\n            *match = Py_NewRef(exc_value);\n        }\n        else {\n            /* naked exception - wrap it */\n            PyObject *excs = PyTuple_Pack(1, exc_value);\n            if (excs == NULL) {\n                return -1;\n            }\n            PyObject *wrapped = _PyExc_CreateExceptionGroup(\"\", excs);\n            Py_DECREF(excs);\n            if (wrapped == NULL) {\n                return -1;\n            }\n            *match = wrapped;\n        }\n        *rest = Py_NewRef(Py_None);\n        return 0;\n    }\n\n    /* exc_value does not match match_type.\n     * Check for partial match if it's an exception group.\n     */\n    if (_PyBaseExceptionGroup_Check(exc_value)) {\n        PyObject *pair = PyObject_CallMethod(exc_value, \"split\", \"(O)\",\n                                             match_type);\n        if (pair == NULL) {\n            return -1;\n        }\n        assert(PyTuple_CheckExact(pair));\n        assert(PyTuple_GET_SIZE(pair) == 2);\n        *match = Py_NewRef(PyTuple_GET_ITEM(pair, 0));\n        *rest = Py_NewRef(PyTuple_GET_ITEM(pair, 1));\n        Py_DECREF(pair);\n        return 0;\n    }\n    /* no match */\n    *match = Py_NewRef(Py_None);\n    *rest = Py_NewRef(exc_value);\n    return 0;\n}\n\n/* Iterate v argcnt times and store the results on the stack (via decreasing\n   sp).  Return 1 for success, 0 if error.\n\n   If argcntafter == -1, do a simple unpack. If it is >= 0, do an unpack\n   with a variable target.\n*/\n\nstatic int\nunpack_iterable(PyThreadState *tstate, PyObject *v,\n                int argcnt, int argcntafter, PyObject **sp)\n{\n    int i = 0, j = 0;\n    Py_ssize_t ll = 0;\n    PyObject *it;  /* iter(v) */\n    PyObject *w;\n    PyObject *l = NULL; /* variable list */\n\n    assert(v != NULL);\n\n    it = PyObject_GetIter(v);\n    if (it == NULL) {\n        if (_PyErr_ExceptionMatches(tstate, PyExc_TypeError) &&\n            Py_TYPE(v)->tp_iter == NULL && !PySequence_Check(v))\n        {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"cannot unpack non-iterable %.200s object\",\n                          Py_TYPE(v)->tp_name);\n        }\n        return 0;\n    }\n\n    for (; i < argcnt; i++) {\n        w = PyIter_Next(it);\n        if (w == NULL) {\n            /* Iterator done, via error or exhaustion. */\n            if (!_PyErr_Occurred(tstate)) {\n                if (argcntafter == -1) {\n                    _PyErr_Format(tstate, PyExc_ValueError,\n                                  \"not enough values to unpack \"\n                                  \"(expected %d, got %d)\",\n                                  argcnt, i);\n                }\n                else {\n                    _PyErr_Format(tstate, PyExc_ValueError,\n                                  \"not enough values to unpack \"\n                                  \"(expected at least %d, got %d)\",\n                                  argcnt + argcntafter, i);\n                }\n            }\n            goto Error;\n        }\n        *--sp = w;\n    }\n\n    if (argcntafter == -1) {\n        /* We better have exhausted the iterator now. */\n        w = PyIter_Next(it);\n        if (w == NULL) {\n            if (_PyErr_Occurred(tstate))\n                goto Error;\n            Py_DECREF(it);\n            return 1;\n        }\n        Py_DECREF(w);\n        _PyErr_Format(tstate, PyExc_ValueError,\n                      \"too many values to unpack (expected %d)\",\n                      argcnt);\n        goto Error;\n    }\n\n    l = PySequence_List(it);\n    if (l == NULL)\n        goto Error;\n    *--sp = l;\n    i++;\n\n    ll = PyList_GET_SIZE(l);\n    if (ll < argcntafter) {\n        _PyErr_Format(tstate, PyExc_ValueError,\n            \"not enough values to unpack (expected at least %d, got %zd)\",\n            argcnt + argcntafter, argcnt + ll);\n        goto Error;\n    }\n\n    /* Pop the \"after-variable\" args off the list. */\n    for (j = argcntafter; j > 0; j--, i++) {\n        *--sp = PyList_GET_ITEM(l, ll - j);\n    }\n    /* Resize the list. */\n    Py_SET_SIZE(l, ll - argcntafter);\n    Py_DECREF(it);\n    return 1;\n\nError:\n    for (; i > 0; i--, sp++)\n        Py_DECREF(*sp);\n    Py_XDECREF(it);\n    return 0;\n}\n\nstatic int\ndo_monitor_exc(PyThreadState *tstate, _PyInterpreterFrame *frame,\n               _Py_CODEUNIT *instr, int event)\n{\n    assert(event < _PY_MONITORING_UNGROUPED_EVENTS);\n    PyObject *exc = PyErr_GetRaisedException();\n    assert(exc != NULL);\n    int err = _Py_call_instrumentation_arg(tstate, event, frame, instr, exc);\n    if (err == 0) {\n        PyErr_SetRaisedException(exc);\n    }\n    else {\n        assert(PyErr_Occurred());\n        Py_DECREF(exc);\n    }\n    return err;\n}\n\nstatic inline bool\nno_tools_for_global_event(PyThreadState *tstate, int event)\n{\n    return tstate->interp->monitors.tools[event] == 0;\n}\n\nstatic inline bool\nno_tools_for_local_event(PyThreadState *tstate, _PyInterpreterFrame *frame, int event)\n{\n    assert(event < _PY_MONITORING_LOCAL_EVENTS);\n    _PyCoMonitoringData *data = frame->f_code->_co_monitoring;\n    if (data) {\n        return data->active_monitors.tools[event] == 0;\n    }\n    else {\n        return no_tools_for_global_event(tstate, event);\n    }\n}\n\nstatic void\nmonitor_raise(PyThreadState *tstate, _PyInterpreterFrame *frame,\n              _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_RAISE)) {\n        return;\n    }\n    do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_RAISE);\n}\n\nstatic void\nmonitor_reraise(PyThreadState *tstate, _PyInterpreterFrame *frame,\n              _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_RERAISE)) {\n        return;\n    }\n    do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_RERAISE);\n}\n\nstatic int\nmonitor_stop_iteration(PyThreadState *tstate, _PyInterpreterFrame *frame,\n                       _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_local_event(tstate, frame, PY_MONITORING_EVENT_STOP_ITERATION)) {\n        return 0;\n    }\n    return do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_STOP_ITERATION);\n}\n\nstatic void\nmonitor_unwind(PyThreadState *tstate,\n               _PyInterpreterFrame *frame,\n               _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_PY_UNWIND)) {\n        return;\n    }\n    do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_PY_UNWIND);\n}\n\n\nstatic int\nmonitor_handled(PyThreadState *tstate,\n                _PyInterpreterFrame *frame,\n                _Py_CODEUNIT *instr, PyObject *exc)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_EXCEPTION_HANDLED)) {\n        return 0;\n    }\n    return _Py_call_instrumentation_arg(tstate, PY_MONITORING_EVENT_EXCEPTION_HANDLED, frame, instr, exc);\n}\n\nstatic void\nmonitor_throw(PyThreadState *tstate,\n              _PyInterpreterFrame *frame,\n              _Py_CODEUNIT *instr)\n{\n    if (no_tools_for_global_event(tstate, PY_MONITORING_EVENT_PY_THROW)) {\n        return;\n    }\n    do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_PY_THROW);\n}\n\nvoid\nPyThreadState_EnterTracing(PyThreadState *tstate)\n{\n    assert(tstate->tracing >= 0);\n    tstate->tracing++;\n}\n\nvoid\nPyThreadState_LeaveTracing(PyThreadState *tstate)\n{\n    assert(tstate->tracing > 0);\n    tstate->tracing--;\n}\n\n\nPyObject*\n_PyEval_CallTracing(PyObject *func, PyObject *args)\n{\n    // Save and disable tracing\n    PyThreadState *tstate = _PyThreadState_GET();\n    int save_tracing = tstate->tracing;\n    tstate->tracing = 0;\n\n    // Call the tracing function\n    PyObject *result = PyObject_Call(func, args, NULL);\n\n    // Restore tracing\n    tstate->tracing = save_tracing;\n    return result;\n}\n\nvoid\nPyEval_SetProfile(Py_tracefunc func, PyObject *arg)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (_PyEval_SetProfile(tstate, func, arg) < 0) {\n        /* Log _PySys_Audit() error */\n        _PyErr_WriteUnraisableMsg(\"in PyEval_SetProfile\", NULL);\n    }\n}\n\nvoid\nPyEval_SetProfileAllThreads(Py_tracefunc func, PyObject *arg)\n{\n    PyThreadState *this_tstate = _PyThreadState_GET();\n    PyInterpreterState* interp = this_tstate->interp;\n\n    _PyRuntimeState *runtime = &_PyRuntime;\n    HEAD_LOCK(runtime);\n    PyThreadState* ts = PyInterpreterState_ThreadHead(interp);\n    HEAD_UNLOCK(runtime);\n\n    while (ts) {\n        if (_PyEval_SetProfile(ts, func, arg) < 0) {\n            _PyErr_WriteUnraisableMsg(\"in PyEval_SetProfileAllThreads\", NULL);\n        }\n        HEAD_LOCK(runtime);\n        ts = PyThreadState_Next(ts);\n        HEAD_UNLOCK(runtime);\n    }\n}\n\nvoid\nPyEval_SetTrace(Py_tracefunc func, PyObject *arg)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (_PyEval_SetTrace(tstate, func, arg) < 0) {\n        /* Log _PySys_Audit() error */\n        _PyErr_WriteUnraisableMsg(\"in PyEval_SetTrace\", NULL);\n    }\n}\n\nvoid\nPyEval_SetTraceAllThreads(Py_tracefunc func, PyObject *arg)\n{\n    PyThreadState *this_tstate = _PyThreadState_GET();\n    PyInterpreterState* interp = this_tstate->interp;\n\n    _PyRuntimeState *runtime = &_PyRuntime;\n    HEAD_LOCK(runtime);\n    PyThreadState* ts = PyInterpreterState_ThreadHead(interp);\n    HEAD_UNLOCK(runtime);\n\n    while (ts) {\n        if (_PyEval_SetTrace(ts, func, arg) < 0) {\n            _PyErr_WriteUnraisableMsg(\"in PyEval_SetTraceAllThreads\", NULL);\n        }\n        HEAD_LOCK(runtime);\n        ts = PyThreadState_Next(ts);\n        HEAD_UNLOCK(runtime);\n    }\n}\n\nint\n_PyEval_SetCoroutineOriginTrackingDepth(int depth)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (depth < 0) {\n        _PyErr_SetString(tstate, PyExc_ValueError, \"depth must be >= 0\");\n        return -1;\n    }\n    tstate->coroutine_origin_tracking_depth = depth;\n    return 0;\n}\n\n\nint\n_PyEval_GetCoroutineOriginTrackingDepth(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return tstate->coroutine_origin_tracking_depth;\n}\n\nint\n_PyEval_SetAsyncGenFirstiter(PyObject *firstiter)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    if (_PySys_Audit(tstate, \"sys.set_asyncgen_hook_firstiter\", NULL) < 0) {\n        return -1;\n    }\n\n    Py_XSETREF(tstate->async_gen_firstiter, Py_XNewRef(firstiter));\n    return 0;\n}\n\nPyObject *\n_PyEval_GetAsyncGenFirstiter(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return tstate->async_gen_firstiter;\n}\n\nint\n_PyEval_SetAsyncGenFinalizer(PyObject *finalizer)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    if (_PySys_Audit(tstate, \"sys.set_asyncgen_hook_finalizer\", NULL) < 0) {\n        return -1;\n    }\n\n    Py_XSETREF(tstate->async_gen_finalizer, Py_XNewRef(finalizer));\n    return 0;\n}\n\nPyObject *\n_PyEval_GetAsyncGenFinalizer(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return tstate->async_gen_finalizer;\n}\n\n_PyInterpreterFrame *\n_PyEval_GetFrame(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _PyThreadState_GetFrame(tstate);\n}\n\nPyFrameObject *\nPyEval_GetFrame(void)\n{\n    _PyInterpreterFrame *frame = _PyEval_GetFrame();\n    if (frame == NULL) {\n        return NULL;\n    }\n    PyFrameObject *f = _PyFrame_GetFrameObject(frame);\n    if (f == NULL) {\n        PyErr_Clear();\n    }\n    return f;\n}\n\nPyObject *\n_PyEval_GetBuiltins(PyThreadState *tstate)\n{\n    _PyInterpreterFrame *frame = _PyThreadState_GetFrame(tstate);\n    if (frame != NULL) {\n        return frame->f_builtins;\n    }\n    return tstate->interp->builtins;\n}\n\nPyObject *\nPyEval_GetBuiltins(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _PyEval_GetBuiltins(tstate);\n}\n\n/* Convenience function to get a builtin from its name */\nPyObject *\n_PyEval_GetBuiltin(PyObject *name)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    PyObject *attr = PyObject_GetItem(PyEval_GetBuiltins(), name);\n    if (attr == NULL && _PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n        _PyErr_SetObject(tstate, PyExc_AttributeError, name);\n    }\n    return attr;\n}\n\nPyObject *\n_PyEval_GetBuiltinId(_Py_Identifier *name)\n{\n    return _PyEval_GetBuiltin(_PyUnicode_FromId(name));\n}\n\nPyObject *\nPyEval_GetLocals(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n     _PyInterpreterFrame *current_frame = _PyThreadState_GetFrame(tstate);\n    if (current_frame == NULL) {\n        _PyErr_SetString(tstate, PyExc_SystemError, \"frame does not exist\");\n        return NULL;\n    }\n\n    if (_PyFrame_FastToLocalsWithError(current_frame) < 0) {\n        return NULL;\n    }\n\n    PyObject *locals = current_frame->f_locals;\n    assert(locals != NULL);\n    return locals;\n}\n\nPyObject *\n_PyEval_GetFrameLocals(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n     _PyInterpreterFrame *current_frame = _PyThreadState_GetFrame(tstate);\n    if (current_frame == NULL) {\n        _PyErr_SetString(tstate, PyExc_SystemError, \"frame does not exist\");\n        return NULL;\n    }\n\n    return _PyFrame_GetLocals(current_frame, 1);\n}\n\nPyObject *\nPyEval_GetGlobals(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    _PyInterpreterFrame *current_frame = _PyThreadState_GetFrame(tstate);\n    if (current_frame == NULL) {\n        return NULL;\n    }\n    return current_frame->f_globals;\n}\n\nint\nPyEval_MergeCompilerFlags(PyCompilerFlags *cf)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    _PyInterpreterFrame *current_frame = tstate->cframe->current_frame;\n    int result = cf->cf_flags != 0;\n\n    if (current_frame != NULL) {\n        const int codeflags = current_frame->f_code->co_flags;\n        const int compilerflags = codeflags & PyCF_MASK;\n        if (compilerflags) {\n            result = 1;\n            cf->cf_flags |= compilerflags;\n        }\n    }\n    return result;\n}\n\n\nconst char *\nPyEval_GetFuncName(PyObject *func)\n{\n    if (PyMethod_Check(func))\n        return PyEval_GetFuncName(PyMethod_GET_FUNCTION(func));\n    else if (PyFunction_Check(func))\n        return PyUnicode_AsUTF8(((PyFunctionObject*)func)->func_name);\n    else if (PyCFunction_Check(func))\n        return ((PyCFunctionObject*)func)->m_ml->ml_name;\n    else\n        return Py_TYPE(func)->tp_name;\n}\n\nconst char *\nPyEval_GetFuncDesc(PyObject *func)\n{\n    if (PyMethod_Check(func))\n        return \"()\";\n    else if (PyFunction_Check(func))\n        return \"()\";\n    else if (PyCFunction_Check(func))\n        return \"()\";\n    else\n        return \" object\";\n}\n\n/* Extract a slice index from a PyLong or an object with the\n   nb_index slot defined, and store in *pi.\n   Silently reduce values larger than PY_SSIZE_T_MAX to PY_SSIZE_T_MAX,\n   and silently boost values less than PY_SSIZE_T_MIN to PY_SSIZE_T_MIN.\n   Return 0 on error, 1 on success.\n*/\nint\n_PyEval_SliceIndex(PyObject *v, Py_ssize_t *pi)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (!Py_IsNone(v)) {\n        Py_ssize_t x;\n        if (_PyIndex_Check(v)) {\n            x = PyNumber_AsSsize_t(v, NULL);\n            if (x == -1 && _PyErr_Occurred(tstate))\n                return 0;\n        }\n        else {\n            _PyErr_SetString(tstate, PyExc_TypeError,\n                             \"slice indices must be integers or \"\n                             \"None or have an __index__ method\");\n            return 0;\n        }\n        *pi = x;\n    }\n    return 1;\n}\n\nint\n_PyEval_SliceIndexNotNone(PyObject *v, Py_ssize_t *pi)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    Py_ssize_t x;\n    if (_PyIndex_Check(v)) {\n        x = PyNumber_AsSsize_t(v, NULL);\n        if (x == -1 && _PyErr_Occurred(tstate))\n            return 0;\n    }\n    else {\n        _PyErr_SetString(tstate, PyExc_TypeError,\n                         \"slice indices must be integers or \"\n                         \"have an __index__ method\");\n        return 0;\n    }\n    *pi = x;\n    return 1;\n}\n\nstatic PyObject *\nimport_name(PyThreadState *tstate, _PyInterpreterFrame *frame,\n            PyObject *name, PyObject *fromlist, PyObject *level)\n{\n    PyObject *import_func, *res;\n    PyObject* stack[5];\n\n    import_func = PyObject_GetItem(frame->f_builtins, &_Py_ID(__import__));\n    if (import_func == NULL) {\n        if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n            _PyErr_SetString(tstate, PyExc_ImportError, \"__import__ not found\");\n        }\n        return NULL;\n    }\n    PyObject *locals = frame->f_locals;\n    /* Fast path for not overloaded __import__. */\n    if (_PyImport_IsDefaultImportFunc(tstate->interp, import_func)) {\n        Py_DECREF(import_func);\n        int ilevel = _PyLong_AsInt(level);\n        if (ilevel == -1 && _PyErr_Occurred(tstate)) {\n            return NULL;\n        }\n        res = PyImport_ImportModuleLevelObject(\n                        name,\n                        frame->f_globals,\n                        locals == NULL ? Py_None :locals,\n                        fromlist,\n                        ilevel);\n        return res;\n    }\n\n    stack[0] = name;\n    stack[1] = frame->f_globals;\n    stack[2] = locals == NULL ? Py_None : locals;\n    stack[3] = fromlist;\n    stack[4] = level;\n    res = _PyObject_FastCall(import_func, stack, 5);\n    Py_DECREF(import_func);\n    return res;\n}\n\nstatic PyObject *\nimport_from(PyThreadState *tstate, PyObject *v, PyObject *name)\n{\n    PyObject *x;\n    PyObject *fullmodname, *pkgname, *pkgpath, *pkgname_or_unknown, *errmsg;\n\n    if (_PyObject_LookupAttr(v, name, &x) != 0) {\n        return x;\n    }\n    /* Issue #17636: in case this failed because of a circular relative\n       import, try to fallback on reading the module directly from\n       sys.modules. */\n    pkgname = PyObject_GetAttr(v, &_Py_ID(__name__));\n    if (pkgname == NULL) {\n        goto error;\n    }\n    if (!PyUnicode_Check(pkgname)) {\n        Py_CLEAR(pkgname);\n        goto error;\n    }\n    fullmodname = PyUnicode_FromFormat(\"%U.%U\", pkgname, name);\n    if (fullmodname == NULL) {\n        Py_DECREF(pkgname);\n        return NULL;\n    }\n    x = PyImport_GetModule(fullmodname);\n    Py_DECREF(fullmodname);\n    if (x == NULL && !_PyErr_Occurred(tstate)) {\n        goto error;\n    }\n    Py_DECREF(pkgname);\n    return x;\n error:\n    pkgpath = PyModule_GetFilenameObject(v);\n    if (pkgname == NULL) {\n        pkgname_or_unknown = PyUnicode_FromString(\"<unknown module name>\");\n        if (pkgname_or_unknown == NULL) {\n            Py_XDECREF(pkgpath);\n            return NULL;\n        }\n    } else {\n        pkgname_or_unknown = pkgname;\n    }\n\n    if (pkgpath == NULL || !PyUnicode_Check(pkgpath)) {\n        _PyErr_Clear(tstate);\n        errmsg = PyUnicode_FromFormat(\n            \"cannot import name %R from %R (unknown location)\",\n            name, pkgname_or_unknown\n        );\n        /* NULL checks for errmsg and pkgname done by PyErr_SetImportError. */\n        _PyErr_SetImportErrorWithNameFrom(errmsg, pkgname, NULL, name);\n    }\n    else {\n        PyObject *spec = PyObject_GetAttr(v, &_Py_ID(__spec__));\n        const char *fmt =\n            _PyModuleSpec_IsInitializing(spec) ?\n            \"cannot import name %R from partially initialized module %R \"\n            \"(most likely due to a circular import) (%S)\" :\n            \"cannot import name %R from %R (%S)\";\n        Py_XDECREF(spec);\n\n        errmsg = PyUnicode_FromFormat(fmt, name, pkgname_or_unknown, pkgpath);\n        /* NULL checks for errmsg and pkgname done by PyErr_SetImportError. */\n        _PyErr_SetImportErrorWithNameFrom(errmsg, pkgname, pkgpath, name);\n    }\n\n    Py_XDECREF(errmsg);\n    Py_XDECREF(pkgname_or_unknown);\n    Py_XDECREF(pkgpath);\n    return NULL;\n}\n\n#define CANNOT_CATCH_MSG \"catching classes that do not inherit from \"\\\n                         \"BaseException is not allowed\"\n\n#define CANNOT_EXCEPT_STAR_EG \"catching ExceptionGroup with except* \"\\\n                              \"is not allowed. Use except instead.\"\n\nstatic int\ncheck_except_type_valid(PyThreadState *tstate, PyObject* right)\n{\n    if (PyTuple_Check(right)) {\n        Py_ssize_t i, length;\n        length = PyTuple_GET_SIZE(right);\n        for (i = 0; i < length; i++) {\n            PyObject *exc = PyTuple_GET_ITEM(right, i);\n            if (!PyExceptionClass_Check(exc)) {\n                _PyErr_SetString(tstate, PyExc_TypeError,\n                    CANNOT_CATCH_MSG);\n                return -1;\n            }\n        }\n    }\n    else {\n        if (!PyExceptionClass_Check(right)) {\n            _PyErr_SetString(tstate, PyExc_TypeError,\n                CANNOT_CATCH_MSG);\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic int\ncheck_except_star_type_valid(PyThreadState *tstate, PyObject* right)\n{\n    if (check_except_type_valid(tstate, right) < 0) {\n        return -1;\n    }\n\n    /* reject except *ExceptionGroup */\n\n    int is_subclass = 0;\n    if (PyTuple_Check(right)) {\n        Py_ssize_t length = PyTuple_GET_SIZE(right);\n        for (Py_ssize_t i = 0; i < length; i++) {\n            PyObject *exc = PyTuple_GET_ITEM(right, i);\n            is_subclass = PyObject_IsSubclass(exc, PyExc_BaseExceptionGroup);\n            if (is_subclass < 0) {\n                return -1;\n            }\n            if (is_subclass) {\n                break;\n            }\n        }\n    }\n    else {\n        is_subclass = PyObject_IsSubclass(right, PyExc_BaseExceptionGroup);\n        if (is_subclass < 0) {\n            return -1;\n        }\n    }\n    if (is_subclass) {\n        _PyErr_SetString(tstate, PyExc_TypeError,\n            CANNOT_EXCEPT_STAR_EG);\n            return -1;\n    }\n    return 0;\n}\n\nstatic int\ncheck_args_iterable(PyThreadState *tstate, PyObject *func, PyObject *args)\n{\n    if (Py_TYPE(args)->tp_iter == NULL && !PySequence_Check(args)) {\n        /* check_args_iterable() may be called with a live exception:\n         * clear it to prevent calling _PyObject_FunctionStr() with an\n         * exception set. */\n        _PyErr_Clear(tstate);\n        PyObject *funcstr = _PyObject_FunctionStr(func);\n        if (funcstr != NULL) {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"%U argument after * must be an iterable, not %.200s\",\n                          funcstr, Py_TYPE(args)->tp_name);\n            Py_DECREF(funcstr);\n        }\n        return -1;\n    }\n    return 0;\n}\n\nstatic void\nformat_kwargs_error(PyThreadState *tstate, PyObject *func, PyObject *kwargs)\n{\n    /* _PyDict_MergeEx raises attribute\n     * error (percolated from an attempt\n     * to get 'keys' attribute) instead of\n     * a type error if its second argument\n     * is not a mapping.\n     */\n    if (_PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {\n        _PyErr_Clear(tstate);\n        PyObject *funcstr = _PyObject_FunctionStr(func);\n        if (funcstr != NULL) {\n            _PyErr_Format(\n                tstate, PyExc_TypeError,\n                \"%U argument after ** must be a mapping, not %.200s\",\n                funcstr, Py_TYPE(kwargs)->tp_name);\n            Py_DECREF(funcstr);\n        }\n    }\n    else if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n        PyObject *exc = _PyErr_GetRaisedException(tstate);\n        PyObject *args = ((PyBaseExceptionObject *)exc)->args;\n        if (exc && PyTuple_Check(args) && PyTuple_GET_SIZE(args) == 1) {\n            _PyErr_Clear(tstate);\n            PyObject *funcstr = _PyObject_FunctionStr(func);\n            if (funcstr != NULL) {\n                PyObject *key = PyTuple_GET_ITEM(args, 0);\n                _PyErr_Format(\n                    tstate, PyExc_TypeError,\n                    \"%U got multiple values for keyword argument '%S'\",\n                    funcstr, key);\n                Py_DECREF(funcstr);\n            }\n            Py_XDECREF(exc);\n        }\n        else {\n            _PyErr_SetRaisedException(tstate, exc);\n        }\n    }\n}\n\nstatic void\nformat_exc_check_arg(PyThreadState *tstate, PyObject *exc,\n                     const char *format_str, PyObject *obj)\n{\n    const char *obj_str;\n\n    if (!obj)\n        return;\n\n    obj_str = PyUnicode_AsUTF8(obj);\n    if (!obj_str)\n        return;\n\n    _PyErr_Format(tstate, exc, format_str, obj_str);\n\n    if (exc == PyExc_NameError) {\n        // Include the name in the NameError exceptions to offer suggestions later.\n        PyObject *exc = PyErr_GetRaisedException();\n        if (PyErr_GivenExceptionMatches(exc, PyExc_NameError)) {\n            if (((PyNameErrorObject*)exc)->name == NULL) {\n                // We do not care if this fails because we are going to restore the\n                // NameError anyway.\n                (void)PyObject_SetAttr(exc, &_Py_ID(name), obj);\n            }\n        }\n        PyErr_SetRaisedException(exc);\n    }\n}\n\nstatic void\nformat_exc_unbound(PyThreadState *tstate, PyCodeObject *co, int oparg)\n{\n    PyObject *name;\n    /* Don't stomp existing exception */\n    if (_PyErr_Occurred(tstate))\n        return;\n    name = PyTuple_GET_ITEM(co->co_localsplusnames, oparg);\n    if (oparg < PyCode_GetFirstFree(co)) {\n        format_exc_check_arg(tstate, PyExc_UnboundLocalError,\n                             UNBOUNDLOCAL_ERROR_MSG, name);\n    } else {\n        format_exc_check_arg(tstate, PyExc_NameError,\n                             UNBOUNDFREE_ERROR_MSG, name);\n    }\n}\n\nstatic void\nformat_awaitable_error(PyThreadState *tstate, PyTypeObject *type, int oparg)\n{\n    if (type->tp_as_async == NULL || type->tp_as_async->am_await == NULL) {\n        if (oparg == 1) {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"'async with' received an object from __aenter__ \"\n                          \"that does not implement __await__: %.100s\",\n                          type->tp_name);\n        }\n        else if (oparg == 2) {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"'async with' received an object from __aexit__ \"\n                          \"that does not implement __await__: %.100s\",\n                          type->tp_name);\n        }\n    }\n}\n\n\nPy_ssize_t\nPyUnstable_Eval_RequestCodeExtraIndex(freefunc free)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    Py_ssize_t new_index;\n\n    if (interp->co_extra_user_count == MAX_CO_EXTRA_USERS - 1) {\n        return -1;\n    }\n    new_index = interp->co_extra_user_count++;\n    interp->co_extra_freefuncs[new_index] = free;\n    return new_index;\n}\n\n/* Implement Py_EnterRecursiveCall() and Py_LeaveRecursiveCall() as functions\n   for the limited API. */\n\nint Py_EnterRecursiveCall(const char *where)\n{\n    return _Py_EnterRecursiveCall(where);\n}\n\nvoid Py_LeaveRecursiveCall(void)\n{\n    _Py_LeaveRecursiveCall();\n}\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/internal/pycore_pyerrors.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_INTERNAL_PYERRORS_H\n#define Py_INTERNAL_PYERRORS_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_BUILD_CORE\n#  error \"this header requires Py_BUILD_CORE define\"\n#endif\n\n\n/* runtime lifecycle */\n\nextern PyStatus _PyErr_InitTypes(PyInterpreterState *);\nextern void _PyErr_FiniTypes(PyInterpreterState *);\n\n\n/* other API */\n\nstatic inline PyObject* _PyErr_Occurred(PyThreadState *tstate)\n{\n    assert(tstate != NULL);\n    if (tstate->current_exception == NULL) {\n        return NULL;\n    }\n    return (PyObject *)Py_TYPE(tstate->current_exception);\n}\n\nstatic inline void _PyErr_ClearExcState(_PyErr_StackItem *exc_state)\n{\n    Py_CLEAR(exc_state->exc_value);\n}\n\nPyAPI_FUNC(PyObject*) _PyErr_StackItemToExcInfoTuple(\n    _PyErr_StackItem *err_info);\n\nPyAPI_FUNC(void) _PyErr_Fetch(\n    PyThreadState *tstate,\n    PyObject **type,\n    PyObject **value,\n    PyObject **traceback);\n\nextern PyObject *\n_PyErr_GetRaisedException(PyThreadState *tstate);\n\nPyAPI_FUNC(int) _PyErr_ExceptionMatches(\n    PyThreadState *tstate,\n    PyObject *exc);\n\nvoid\n_PyErr_SetRaisedException(PyThreadState *tstate, PyObject *exc);\n\nPyAPI_FUNC(void) _PyErr_Restore(\n    PyThreadState *tstate,\n    PyObject *type,\n    PyObject *value,\n    PyObject *traceback);\n\nPyAPI_FUNC(void) _PyErr_SetObject(\n    PyThreadState *tstate,\n    PyObject *type,\n    PyObject *value);\n\nPyAPI_FUNC(void) _PyErr_ChainStackItem(\n    _PyErr_StackItem *exc_info);\n\nPyAPI_FUNC(void) _PyErr_Clear(PyThreadState *tstate);\n\nPyAPI_FUNC(void) _PyErr_SetNone(PyThreadState *tstate, PyObject *exception);\n\nPyAPI_FUNC(PyObject *) _PyErr_NoMemory(PyThreadState *tstate);\n\nPyAPI_FUNC(void) _PyErr_SetString(\n    PyThreadState *tstate,\n    PyObject *exception,\n    const char *string);\n\nPyAPI_FUNC(PyObject *) _PyErr_Format(\n    PyThreadState *tstate,\n    PyObject *exception,\n    const char *format,\n    ...);\n\nPyAPI_FUNC(void) _PyErr_NormalizeException(\n    PyThreadState *tstate,\n    PyObject **exc,\n    PyObject **val,\n    PyObject **tb);\n\nPyAPI_FUNC(PyObject *) _PyErr_FormatFromCauseTstate(\n    PyThreadState *tstate,\n    PyObject *exception,\n    const char *format,\n    ...);\n\nPyAPI_FUNC(PyObject *) _PyExc_CreateExceptionGroup(\n    const char *msg,\n    PyObject *excs);\n\nPyAPI_FUNC(PyObject *) _PyExc_PrepReraiseStar(\n    PyObject *orig,\n    PyObject *excs);\n\nPyAPI_FUNC(int) _PyErr_CheckSignalsTstate(PyThreadState *tstate);\n\nPyAPI_FUNC(void) _Py_DumpExtensionModules(int fd, PyInterpreterState *interp);\n\nextern PyObject* _Py_Offer_Suggestions(PyObject* exception);\nPyAPI_FUNC(Py_ssize_t) _Py_UTF8_Edit_Cost(PyObject *str_a, PyObject *str_b,\n                                          Py_ssize_t max_cost);\n\nvoid _PyErr_FormatNote(const char *format, ...);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_INTERNAL_PYERRORS_H */\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "Python/bytecodes.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "// This file contains instruction definitions.\n// It is read by Tools/cases_generator/generate_cases.py\n// to generate Python/generated_cases.c.h.\n// Note that there is some dummy C code at the top and bottom of the file\n// to fool text editors like VS Code into believing this is valid C code.\n// The actual instruction definitions start at // BEGIN BYTECODES //.\n// See Tools/cases_generator/README.md for more information.\n\n#include \"Python.h\"\n#include \"pycore_abstract.h\"      // _PyIndex_Check()\n#include \"pycore_call.h\"          // _PyObject_FastCallDictTstate()\n#include \"pycore_ceval.h\"         // _PyEval_SignalAsyncExc()\n#include \"pycore_code.h\"\n#include \"pycore_function.h\"\n#include \"pycore_intrinsics.h\"\n#include \"pycore_long.h\"          // _PyLong_GetZero()\n#include \"pycore_instruments.h\"\n#include \"pycore_object.h\"        // _PyObject_GC_TRACK()\n#include \"pycore_moduleobject.h\"  // PyModuleObject\n#include \"pycore_opcode.h\"        // EXTRA_CASES\n#include \"pycore_pyerrors.h\"      // _PyErr_GetRaisedException()\n#include \"pycore_pymem.h\"         // _PyMem_IsPtrFreed()\n#include \"pycore_pystate.h\"       // _PyInterpreterState_GET()\n#include \"pycore_range.h\"         // _PyRangeIterObject\n#include \"pycore_sliceobject.h\"   // _PyBuildSlice_ConsumeRefs\n#include \"pycore_sysmodule.h\"     // _PySys_Audit()\n#include \"pycore_tuple.h\"         // _PyTuple_ITEMS()\n#include \"pycore_typeobject.h\"    // _PySuper_Lookup()\n#include \"pycore_emscripten_signal.h\"  // _Py_CHECK_EMSCRIPTEN_SIGNALS\n\n#include \"pycore_dict.h\"\n#include \"dictobject.h\"\n#include \"pycore_frame.h\"\n#include \"opcode.h\"\n#include \"pydtrace.h\"\n#include \"setobject.h\"\n#include \"structmember.h\"         // struct PyMemberDef, T_OFFSET_EX\n\n#define USE_COMPUTED_GOTOS 0\n#include \"ceval_macros.h\"\n\n/* Flow control macros */\n#define DEOPT_IF(cond, instname) ((void)0)\n#define ERROR_IF(cond, labelname) ((void)0)\n#define GO_TO_INSTRUCTION(instname) ((void)0)\n#define PREDICT(opname) ((void)0)\n\n#define inst(name, ...) case name:\n#define op(name, ...) /* NAME is ignored */\n#define macro(name) static int MACRO_##name\n#define super(name) static int SUPER_##name\n#define family(name, ...) static int family_##name\n\n// Dummy variables for stack effects.\nstatic PyObject *value, *value1, *value2, *left, *right, *res, *sum, *prod, *sub;\nstatic PyObject *container, *start, *stop, *v, *lhs, *rhs, *res2;\nstatic PyObject *list, *tuple, *dict, *owner, *set, *str, *tup, *map, *keys;\nstatic PyObject *exit_func, *lasti, *val, *retval, *obj, *iter;\nstatic PyObject *aiter, *awaitable, *iterable, *w, *exc_value, *bc, *locals;\nstatic PyObject *orig, *excs, *update, *b, *fromlist, *level, *from;\nstatic PyObject **pieces, **values;\nstatic size_t jump;\n// Dummy variables for cache effects\nstatic uint16_t invert, counter, index, hint;\nstatic uint32_t type_version;\n\nstatic PyObject *\ndummy_func(\n    PyThreadState *tstate,\n    _PyInterpreterFrame *frame,\n    unsigned char opcode,\n    unsigned int oparg,\n    _PyCFrame cframe,\n    _Py_CODEUNIT *next_instr,\n    PyObject **stack_pointer,\n    PyObject *kwnames,\n    int throwflag,\n    binaryfunc binary_ops[],\n    PyObject *args[]\n)\n{\n    // Dummy labels.\n    pop_1_error:\n    // Dummy locals.\n    PyObject *annotations;\n    PyObject *attrs;\n    PyObject *bottom;\n    PyObject *callable;\n    PyObject *callargs;\n    PyObject *closure;\n    PyObject *codeobj;\n    PyObject *cond;\n    PyObject *defaults;\n    PyObject *descr;\n    _PyInterpreterFrame  entry_frame;\n    PyObject *exc;\n    PyObject *exit;\n    PyObject *fget;\n    PyObject *fmt_spec;\n    PyObject *func;\n    uint32_t func_version;\n    PyObject *getattribute;\n    PyObject *kwargs;\n    PyObject *kwdefaults;\n    PyObject *len_o;\n    PyObject *match;\n    PyObject *match_type;\n    PyObject *method;\n    PyObject *mgr;\n    Py_ssize_t min_args;\n    PyObject *names;\n    PyObject *new_exc;\n    PyObject *next;\n    PyObject *none;\n    PyObject *null;\n    PyObject *prev_exc;\n    PyObject *receiver;\n    PyObject *rest;\n    int result;\n    PyObject *self;\n    PyObject *seq;\n    PyObject *slice;\n    PyObject *step;\n    PyObject *subject;\n    PyObject *top;\n    PyObject *type;\n    PyObject *typevars;\n    int values_or_none;\n\n    switch (opcode) {\n\n// BEGIN BYTECODES //\n        inst(NOP, (--)) {\n        }\n\n        inst(RESUME, (--)) {\n            assert(tstate->cframe == &cframe);\n            assert(frame == cframe.current_frame);\n            /* Possibly combine this with eval breaker */\n            if (frame->f_code->_co_instrumentation_version != tstate->interp->monitoring_version) {\n                int err = _Py_Instrument(frame->f_code, tstate->interp);\n                ERROR_IF(err, error);\n                next_instr--;\n            }\n            else if (_Py_atomic_load_relaxed_int32(&tstate->interp->ceval.eval_breaker) && oparg < 2) {\n                goto handle_eval_breaker;\n            }\n        }\n\n        inst(INSTRUMENTED_RESUME, (--)) {\n            /* Possible performance enhancement:\n             *   We need to check the eval breaker anyway, can we\n             * combine the instrument verison check and the eval breaker test?\n             */\n            if (frame->f_code->_co_instrumentation_version != tstate->interp->monitoring_version) {\n                if (_Py_Instrument(frame->f_code, tstate->interp)) {\n                    goto error;\n                }\n                next_instr--;\n            }\n            else {\n                _PyFrame_SetStackPointer(frame, stack_pointer);\n                int err = _Py_call_instrumentation(\n                        tstate, oparg > 0, frame, next_instr-1);\n                stack_pointer = _PyFrame_GetStackPointer(frame);\n                ERROR_IF(err, error);\n                if (frame->prev_instr != next_instr-1) {\n                    /* Instrumentation has jumped */\n                    next_instr = frame->prev_instr;\n                    DISPATCH();\n                }\n                if (_Py_atomic_load_relaxed_int32(&tstate->interp->ceval.eval_breaker) && oparg < 2) {\n                    goto handle_eval_breaker;\n                }\n            }\n        }\n\n        inst(LOAD_CLOSURE, (-- value)) {\n            /* We keep LOAD_CLOSURE so that the bytecode stays more readable. */\n            value = GETLOCAL(oparg);\n            ERROR_IF(value == NULL, unbound_local_error);\n            Py_INCREF(value);\n        }\n\n        inst(LOAD_FAST_CHECK, (-- value)) {\n            value = GETLOCAL(oparg);\n            ERROR_IF(value == NULL, unbound_local_error);\n            Py_INCREF(value);\n        }\n\n        inst(LOAD_FAST, (-- value)) {\n            value = GETLOCAL(oparg);\n            assert(value != NULL);\n            Py_INCREF(value);\n        }\n\n        inst(LOAD_FAST_AND_CLEAR, (-- value)) {\n            value = GETLOCAL(oparg);\n            // do not use SETLOCAL here, it decrefs the old value\n            GETLOCAL(oparg) = NULL;\n        }\n\n        inst(LOAD_CONST, (-- value)) {\n            value = GETITEM(frame->f_code->co_consts, oparg);\n            Py_INCREF(value);\n        }\n\n        inst(STORE_FAST, (value --)) {\n            SETLOCAL(oparg, value);\n        }\n\n        super(LOAD_FAST__LOAD_FAST) = LOAD_FAST + LOAD_FAST;\n        super(LOAD_FAST__LOAD_CONST) = LOAD_FAST + LOAD_CONST;\n        super(STORE_FAST__LOAD_FAST)  = STORE_FAST + LOAD_FAST;\n        super(STORE_FAST__STORE_FAST) = STORE_FAST + STORE_FAST;\n        super(LOAD_CONST__LOAD_FAST) = LOAD_CONST + LOAD_FAST;\n\n        inst(POP_TOP, (value --)) {\n            DECREF_INPUTS();\n        }\n\n        inst(PUSH_NULL, (-- res)) {\n            res = NULL;\n        }\n\n        macro(END_FOR) = POP_TOP + POP_TOP;\n\n        inst(INSTRUMENTED_END_FOR, (receiver, value --)) {\n            /* Need to create a fake StopIteration error here,\n             * to conform to PEP 380 */\n            if (PyGen_Check(receiver)) {\n                PyErr_SetObject(PyExc_StopIteration, value);\n                if (monitor_stop_iteration(tstate, frame, next_instr-1)) {\n                    goto error;\n                }\n                PyErr_SetRaisedException(NULL);\n            }\n            DECREF_INPUTS();\n        }\n\n        inst(END_SEND, (receiver, value -- value)) {\n            Py_DECREF(receiver);\n        }\n\n        inst(INSTRUMENTED_END_SEND, (receiver, value -- value)) {\n            if (PyGen_Check(receiver) || PyCoro_CheckExact(receiver)) {\n                PyErr_SetObject(PyExc_StopIteration, value);\n                if (monitor_stop_iteration(tstate, frame, next_instr-1)) {\n                    goto error;\n                }\n                PyErr_SetRaisedException(NULL);\n            }\n            Py_DECREF(receiver);\n        }\n\n        inst(UNARY_NEGATIVE, (value -- res)) {\n            res = PyNumber_Negative(value);\n            DECREF_INPUTS();\n            ERROR_IF(res == NULL, error);\n        }\n\n        inst(UNARY_NOT, (value -- res)) {\n            int err = PyObject_IsTrue(value);\n            DECREF_INPUTS();\n            ERROR_IF(err < 0, error);\n            if (err == 0) {\n                res = Py_True;\n            }\n            else {\n                res = Py_False;\n            }\n        }\n\n        inst(UNARY_INVERT, (value -- res)) {\n            res = PyNumber_Invert(value);\n            DECREF_INPUTS();\n            ERROR_IF(res == NULL, error);\n        }\n\n        family(binary_op, INLINE_CACHE_ENTRIES_BINARY_OP) = {\n            BINARY_OP,\n            BINARY_OP_ADD_FLOAT,\n            BINARY_OP_ADD_INT,\n            BINARY_OP_ADD_UNICODE,\n            // BINARY_OP_INPLACE_ADD_UNICODE,  // This is an odd duck.\n            BINARY_OP_MULTIPLY_FLOAT,\n            BINARY_OP_MULTIPLY_INT,\n            BINARY_OP_SUBTRACT_FLOAT,\n            BINARY_OP_SUBTRACT_INT,\n        };\n\n\n        inst(BINARY_OP_MULTIPLY_INT, (unused/1, left, right -- prod)) {\n            DEOPT_IF(!PyLong_CheckExact(left), BINARY_OP);\n            DEOPT_IF(!PyLong_CheckExact(right), BINARY_OP);\n            STAT_INC(BINARY_OP, hit);\n            prod = _PyLong_Multiply((PyLongObject *)left, (PyLongObject *)right);\n            _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);\n            _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);\n            ERROR_IF(prod == NULL, error);\n        }\n\n        inst(BINARY_OP_MULTIPLY_FLOAT, (unused/1, left, right -- prod)) {\n            DEOPT_IF(!PyFloat_CheckExact(left), BINARY_OP);\n            DEOPT_IF(!PyFloat_CheckExact(right), BINARY_OP);\n            STAT_INC(BINARY_OP, hit);\n            double dprod = ((PyFloatObject *)left)->ob_fval *\n                ((PyFloatObject *)right)->ob_fval;\n            DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dprod, prod);\n        }\n\n        inst(BINARY_OP_SUBTRACT_INT, (unused/1, left, right -- sub)) {\n            DEOPT_IF(!PyLong_CheckExact(left), BINARY_OP);\n            DEOPT_IF(!PyLong_CheckExact(right), BINARY_OP);\n            STAT_INC(BINARY_OP, hit);\n            sub = _PyLong_Subtract((PyLongObject *)left, (PyLongObject *)right);\n            _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);\n            _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);\n            ERROR_IF(sub == NULL, error);\n        }\n\n        inst(BINARY_OP_SUBTRACT_FLOAT, (unused/1, left, right -- sub)) {\n            DEOPT_IF(!PyFloat_CheckExact(left), BINARY_OP);\n            DEOPT_IF(!PyFloat_CheckExact(right), BINARY_OP);\n            STAT_INC(BINARY_OP, hit);\n            double dsub = ((PyFloatObject *)left)->ob_fval - ((PyFloatObject *)right)->ob_fval;\n            DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dsub, sub);\n        }\n\n        inst(BINARY_OP_ADD_UNICODE, (unused/1, left, right -- res)) {\n            DEOPT_IF(!PyUnicode_CheckExact(left), BINARY_OP);\n            DEOPT_IF(Py_TYPE(right) != Py_TYPE(left), BINARY_OP);\n            STAT_INC(BINARY_OP, hit);\n            res = PyUnicode_Concat(left, right);\n            _Py_DECREF_SPECIALIZED(left, _PyUnicode_ExactDealloc);\n            _Py_DECREF_SPECIALIZED(right, _PyUnicode_ExactDealloc);\n            ERROR_IF(res == NULL, error);\n        }\n\n        // This is a subtle one. It's a super-instruction for\n        // BINARY_OP_ADD_UNICODE followed by STORE_FAST\n        // where the store goes into the left argument.\n        // So the inputs are the same as for all BINARY_OP\n        // specializations, but there is no output.\n        // At the end we just skip over the STORE_FAST.\n        inst(BINARY_OP_INPLACE_ADD_UNICODE, (left, right --)) {\n            DEOPT_IF(!PyUnicode_CheckExact(left), BINARY_OP);\n            DEOPT_IF(Py_TYPE(right) != Py_TYPE(left), BINARY_OP);\n            _Py_CODEUNIT true_next = next_instr[INLINE_CACHE_ENTRIES_BINARY_OP];\n            assert(true_next.op.code == STORE_FAST ||\n                   true_next.op.code == STORE_FAST__LOAD_FAST);\n            PyObject **target_local = &GETLOCAL(true_next.op.arg);\n            DEOPT_IF(*target_local != left, BINARY_OP);\n            STAT_INC(BINARY_OP, hit);\n            /* Handle `left = left + right` or `left += right` for str.\n             *\n             * When possible, extend `left` in place rather than\n             * allocating a new PyUnicodeObject. This attempts to avoid\n             * quadratic behavior when one neglects to use str.join().\n             *\n             * If `left` has only two references remaining (one from\n             * the stack, one in the locals), DECREFing `left` leaves\n             * only the locals reference, so PyUnicode_Append knows\n             * that the string is safe to mutate.\n             */\n            assert(Py_REFCNT(left) >= 2);\n            _Py_DECREF_NO_DEALLOC(left);\n            PyUnicode_Append(target_local, right);\n            _Py_DECREF_SPECIALIZED(right, _PyUnicode_ExactDealloc);\n            ERROR_IF(*target_local == NULL, error);\n            // The STORE_FAST is already done.\n            JUMPBY(INLINE_CACHE_ENTRIES_BINARY_OP + 1);\n        }\n\n        inst(BINARY_OP_ADD_FLOAT, (unused/1, left, right -- sum)) {\n            DEOPT_IF(!PyFloat_CheckExact(left), BINARY_OP);\n            DEOPT_IF(Py_TYPE(right) != Py_TYPE(left), BINARY_OP);\n            STAT_INC(BINARY_OP, hit);\n            double dsum = ((PyFloatObject *)left)->ob_fval +\n                ((PyFloatObject *)right)->ob_fval;\n            DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dsum, sum);\n        }\n\n        inst(BINARY_OP_ADD_INT, (unused/1, left, right -- sum)) {\n            DEOPT_IF(!PyLong_CheckExact(left), BINARY_OP);\n            DEOPT_IF(Py_TYPE(right) != Py_TYPE(left), BINARY_OP);\n            STAT_INC(BINARY_OP, hit);\n            sum = _PyLong_Add((PyLongObject *)left, (PyLongObject *)right);\n            _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);\n            _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);\n            ERROR_IF(sum == NULL, error);\n        }\n\n        family(binary_subscr, INLINE_CACHE_ENTRIES_BINARY_SUBSCR) = {\n            BINARY_SUBSCR,\n            BINARY_SUBSCR_DICT,\n            BINARY_SUBSCR_GETITEM,\n            BINARY_SUBSCR_LIST_INT,\n            BINARY_SUBSCR_TUPLE_INT,\n        };\n\n        inst(BINARY_SUBSCR, (unused/1, container, sub -- res)) {\n            #if ENABLE_SPECIALIZATION\n            _PyBinarySubscrCache *cache = (_PyBinarySubscrCache *)next_instr;\n            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {\n                next_instr--;\n                _Py_Specialize_BinarySubscr(container, sub, next_instr);\n                DISPATCH_SAME_OPARG();\n            }\n            STAT_INC(BINARY_SUBSCR, deferred);\n            DECREMENT_ADAPTIVE_COUNTER(cache->counter);\n            #endif  /* ENABLE_SPECIALIZATION */\n            res = PyObject_GetItem(container, sub);\n            DECREF_INPUTS();\n            ERROR_IF(res == NULL, error);\n        }\n\n        inst(BINARY_SLICE, (container, start, stop -- res)) {\n            PyObject *slice = _PyBuildSlice_ConsumeRefs(start, stop);\n            // Can't use ERROR_IF() here, because we haven't\n            // DECREF'ed container yet, and we still own slice.\n            if (slice == NULL) {\n                res = NULL;\n            }\n            else {\n                res = PyObject_GetItem(container, slice);\n                Py_DECREF(slice);\n            }\n            Py_DECREF(container);\n            ERROR_IF(res == NULL, error);\n        }\n\n        inst(STORE_SLICE, (v, container, start, stop -- )) {\n            PyObject *slice = _PyBuildSlice_ConsumeRefs(start, stop);\n            int err;\n            if (slice == NULL) {\n                err = 1;\n            }\n            else {\n                err = PyObject_SetItem(container, slice, v);\n                Py_DECREF(slice);\n            }\n            Py_DECREF(v);\n            Py_DECREF(container);\n            ERROR_IF(err, error);\n        }\n\n        inst(BINARY_SUBSCR_LIST_INT, (unused/1, list, sub -- res)) {\n            DEOPT_IF(!PyLong_CheckExact(sub), BINARY_SUBSCR);\n            DEOPT_IF(!PyList_CheckExact(list), BINARY_SUBSCR);\n\n            // Deopt unless 0 <= sub < PyList_Size(list)\n            DEOPT_IF(!_PyLong_IsNonNegativeCompact((PyLongObject *)sub), BINARY_SUBSCR);\n            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];\n            DEOPT_IF(index >= PyList_GET_SIZE(list), BINARY_SUBSCR);\n            STAT_INC(BINARY_SUBSCR, hit);\n            res = PyList_GET_ITEM(list, index);\n            assert(res != NULL);\n            Py_INCREF(res);\n            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);\n            Py_DECREF(list);\n        }\n\n        inst(BINARY_SUBSCR_TUPLE_INT, (unused/1, tuple, sub -- res)) {\n            DEOPT_IF(!PyLong_CheckExact(sub), BINARY_SUBSCR);\n            DEOPT_IF(!PyTuple_CheckExact(tuple), BINARY_SUBSCR);\n\n            // Deopt unless 0 <= sub < PyTuple_Size(list)\n            DEOPT_IF(!_PyLong_IsNonNegativeCompact((PyLongObject *)sub), BINARY_SUBSCR);\n            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];\n            DEOPT_IF(index >= PyTuple_GET_SIZE(tuple), BINARY_SUBSCR);\n            STAT_INC(BINARY_SUBSCR, hit);\n            res = PyTuple_GET_ITEM(tuple, index);\n            assert(res != NULL);\n            Py_INCREF(res);\n            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);\n            Py_DECREF(tuple);\n        }\n\n        inst(BINARY_SUBSCR_DICT, (unused/1, dict, sub -- res)) {\n            DEOPT_IF(!PyDict_CheckExact(dict), BINARY_SUBSCR);\n            STAT_INC(BINARY_SUBSCR, hit);\n            res = PyDict_GetItemWithError(dict, sub);\n            if (res == NULL) {\n                if (!_PyErr_Occurred(tstate)) {\n                    _PyErr_SetKeyError(sub);\n                }\n                DECREF_INPUTS();\n                ERROR_IF(true, error);\n            }\n            Py_INCREF(res);  // Do this before DECREF'ing dict, sub\n            DECREF_INPUTS();\n        }\n\n        inst(BINARY_SUBSCR_GETITEM, (unused/1, container, sub -- unused)) {\n            DEOPT_IF(tstate->interp->eval_frame, BINARY_SUBSCR);\n            PyTypeObject *tp = Py_TYPE(container);\n            DEOPT_IF(!PyType_HasFeature(tp, Py_TPFLAGS_HEAPTYPE), BINARY_SUBSCR);\n            PyHeapTypeObject *ht = (PyHeapTypeObject *)tp;\n            PyObject *cached = ht->_spec_cache.getitem;\n            DEOPT_IF(cached == NULL, BINARY_SUBSCR);\n            assert(PyFunction_Check(cached));\n            PyFunctionObject *getitem = (PyFunctionObject *)cached;\n            uint32_t cached_version = ht->_spec_cache.getitem_version;\n            DEOPT_IF(getitem->func_version != cached_version, BINARY_SUBSCR);\n            PyCodeObject *code = (PyCodeObject *)getitem->func_code;\n            assert(code->co_argcount == 2);\n            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), BINARY_SUBSCR);\n            STAT_INC(BINARY_SUBSCR, hit);\n            Py_INCREF(getitem);\n            _PyInterpreterFrame *new_frame = _PyFrame_PushUnchecked(tstate, getitem, 2);\n            STACK_SHRINK(2);\n            new_frame->localsplus[0] = container;\n            new_frame->localsplus[1] = sub;\n            JUMPBY(INLINE_CACHE_ENTRIES_BINARY_SUBSCR);\n            frame->return_offset = 0;\n            DISPATCH_INLINED(new_frame);\n        }\n\n        inst(LIST_APPEND, (list, unused[oparg-1], v -- list, unused[oparg-1])) {\n            ERROR_IF(_PyList_AppendTakeRef((PyListObject *)list, v) < 0, error);\n            PREDICT(JUMP_BACKWARD);\n        }\n\n        inst(SET_ADD, (set, unused[oparg-1], v -- set, unused[oparg-1])) {\n            int err = PySet_Add(set, v);\n            DECREF_INPUTS();\n            ERROR_IF(err, error);\n            PREDICT(JUMP_BACKWARD);\n        }\n\n        family(store_subscr, INLINE_CACHE_ENTRIES_STORE_SUBSCR) = {\n            STORE_SUBSCR,\n            STORE_SUBSCR_DICT,\n            STORE_SUBSCR_LIST_INT,\n        };\n\n        inst(STORE_SUBSCR, (counter/1, v, container, sub -- )) {\n            #if ENABLE_SPECIALIZATION\n            if (ADAPTIVE_COUNTER_IS_ZERO(counter)) {\n                next_instr--;\n                _Py_Specialize_StoreSubscr(container, sub, next_instr);\n                DISPATCH_SAME_OPARG();\n            }\n            STAT_INC(STORE_SUBSCR, deferred);\n            _PyStoreSubscrCache *cache = (_PyStoreSubscrCache *)next_instr;\n            DECREMENT_ADAPTIVE_COUNTER(cache->counter);\n            #else\n            (void)counter;  // Unused.\n            #endif  /* ENABLE_SPECIALIZATION */\n            /* container[sub] = v */\n            int err = PyObject_SetItem(container, sub, v);\n            DECREF_INPUTS();\n            ERROR_IF(err, error);\n        }\n\n        inst(STORE_SUBSCR_LIST_INT, (unused/1, value, list, sub -- )) {\n            DEOPT_IF(!PyLong_CheckExact(sub), STORE_SUBSCR);\n            DEOPT_IF(!PyList_CheckExact(list), STORE_SUBSCR);\n\n            // Ensure nonnegative, zero-or-one-digit ints.\n            DEOPT_IF(!_PyLong_IsNonNegativeCompact((PyLongObject *)sub), STORE_SUBSCR);\n            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];\n            // Ensure index < len(list)\n            DEOPT_IF(index >= PyList_GET_SIZE(list), STORE_SUBSCR);\n            STAT_INC(STORE_SUBSCR, hit);\n\n            PyObject *old_value = PyList_GET_ITEM(list, index);\n            PyList_SET_ITEM(list, index, value);\n            assert(old_value != NULL);\n            Py_DECREF(old_value);\n            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);\n            Py_DECREF(list);\n        }\n\n        inst(STORE_SUBSCR_DICT, (unused/1, value, dict, sub -- )) {\n            DEOPT_IF(!PyDict_CheckExact(dict), STORE_SUBSCR);\n            STAT_INC(STORE_SUBSCR, hit);\n            int err = _PyDict_SetItem_Take2((PyDictObject *)dict, sub, value);\n            Py_DECREF(dict);\n            ERROR_IF(err, error);\n        }\n\n        inst(DELETE_SUBSCR, (container, sub --)) {\n            /* del container[sub] */\n            int err = PyObject_DelItem(container, sub);\n            DECREF_INPUTS();\n            ERROR_IF(err, error);\n        }\n\n        inst(CALL_INTRINSIC_1, (value -- res)) {\n            assert(oparg <= MAX_INTRINSIC_1);\n            res = _PyIntrinsics_UnaryFunctions[oparg](tstate, value);\n            DECREF_INPUTS();\n            ERROR_IF(res == NULL, error);\n        }\n\n        inst(CALL_INTRINSIC_2, (value2, value1 -- res)) {\n            assert(oparg <= MAX_INTRINSIC_2);\n            res = _PyIntrinsics_BinaryFunctions[oparg](tstate, value2, value1);\n            DECREF_INPUTS();\n            ERROR_IF(res == NULL, error);\n        }\n\n        inst(RAISE_VARARGS, (args[oparg] -- )) {\n            PyObject *cause = NULL, *exc = NULL;\n            switch (oparg) {\n            case 2:\n                cause = args[1];\n                /* fall through */\n            case 1:\n                exc = args[0];\n                /* fall through */\n            case 0:\n                if (do_raise(tstate, exc, cause)) {\n                    assert(oparg == 0);\n                    monitor_reraise(tstate, frame, next_instr-1);\n                    goto exception_unwind;\n                }\n                break;\n            default:\n                _PyErr_SetString(tstate, PyExc_SystemError,\n                                 \"bad RAISE_VARARGS oparg\");\n                break;\n            }\n            ERROR_IF(true, error);\n        }\n\n        inst(INTERPRETER_EXIT, (retval --)) {\n            assert(frame == &entry_frame);\n            assert(_PyFrame_IsIncomplete(frame));\n            STACK_SHRINK(1);  // Since we're not going to DISPATCH()\n            assert(EMPTY());\n            /* Restore previous cframe and return. */\n            tstate->cframe = cframe.previous;\n            assert(tstate->cframe->current_frame == frame->previous);\n            assert(!_PyErr_Occurred(tstate));\n            tstate->c_recursion_remaining += PY_EVAL_C_STACK_UNITS;\n            return retval;\n        }\n\n        inst(RETURN_VALUE, (retval --)) {\n            STACK_SHRINK(1);\n            assert(EMPTY());\n            _PyFrame_SetStackPointer(frame, stack_pointer);\n            _Py_LeaveRecursiveCallPy(tstate);\n            assert(frame != &entry_frame);\n            // GH-99729: We need to unlink the frame *before* clearing it:\n            _PyInterpreterFrame *dying = frame;\n            frame = cframe.current_frame = dying->previous;\n            _PyEvalFrameClearAndPop(tstate, dying);\n            frame->prev_instr += frame->return_offset;\n            _PyFrame_StackPush(frame, retval);\n            goto resume_frame;\n        }\n\n        inst(INSTRUMENTED_RETURN_VALUE, (retval --)) {\n            int err = _Py_call_instrumentation_arg(\n                    tstate, PY_MONITORING_EVENT_PY_RETURN,\n                    frame, next_instr-1, retval);\n            if (err) goto error;\n            STACK_SHRINK(1);\n            assert(EMPTY());\n            _PyFrame_SetStackPointer(frame, stack_pointer);\n            _Py_LeaveRecursiveCallPy(tstate);\n            assert(frame != &entry_frame);\n            // GH-99729: We need to unlink the frame *before* clearing it:\n            _PyInterpreterFrame *dying = frame;\n            frame = cframe.current_frame = dying->previous;\n            _PyEvalFrameClearAndPop(tstate, dying);\n            frame->prev_instr += frame->return_offset;\n            _PyFrame_StackPush(frame, retval);\n            goto resume_frame;\n        }\n\n        inst(RETURN_CONST, (--)) {\n            PyObject *retval = GETITEM(frame->f_code->co_consts, oparg);\n            Py_INCREF(retval);\n            assert(EMPTY());\n            _PyFrame_SetStackPointer(frame, stack_pointer);\n            _Py_LeaveRecursiveCallPy(tstate);\n            assert(frame != &entry_frame);\n            // GH-99729: We need to unlink the frame *before* clearing it:\n            _PyInterpreterFrame *dying = frame;\n            frame = cframe.current_frame = dying->previous;\n            _PyEvalFrameClearAndPop(tstate, dying);\n            frame->prev_instr += frame->return_offset;\n            _PyFrame_StackPush(frame, retval);\n            goto resume_frame;\n        }\n\n        inst(INSTRUMENTED_RETURN_CONST, (--)) {\n            PyObject *retval = GETITEM(frame->f_code->co_consts, oparg);\n            int err = _Py_call_instrumentation_arg(\n                    tstate, PY_MONITORING_EVENT_PY_RETURN,\n                    frame, next_instr-1, retval);\n            if (err) goto error;\n            Py_INCREF(retval);\n            assert(EMPTY());\n            _PyFrame_SetStackPointer(frame, stack_pointer);\n            _Py_LeaveRecursiveCallPy(tstate);\n            assert(frame != &entry_frame);\n            // GH-99729: We need to unlink the frame *before* clearing it:\n            _PyInterpreterFrame *dying = frame;\n            frame = cframe.current_frame = dying->previous;\n            _PyEvalFrameClearAndPop(tstate, dying);\n            frame->prev_instr += frame->return_offset;\n            _PyFrame_StackPush(frame, retval);\n            goto resume_frame;\n        }\n\n        inst(GET_AITER, (obj -- iter)) {\n            unaryfunc getter = NULL;\n            PyTypeObject *type = Py_TYPE(obj);\n\n            if (type->tp_as_async != NULL) {\n                getter = type->tp_as_async->am_aiter;\n            }\n\n            if (getter == NULL) {\n                _PyErr_Format(tstate, PyExc_TypeError,\n                              \"'async for' requires an object with \"\n                              \"__aiter__ method, got %.100s\",\n                              type->tp_name);\n                DECREF_INPUTS();\n                ERROR_IF(true, error);\n            }\n\n            iter = (*getter)(obj);\n            DECREF_INPUTS();\n            ERROR_IF(iter == NULL, error);\n\n            if (Py_TYPE(iter)->tp_as_async == NULL ||\n                    Py_TYPE(iter)->tp_as_async->am_anext == NULL) {\n\n                _PyErr_Format(tstate, PyExc_TypeError,\n                              \"'async for' received an object from __aiter__ \"\n                              \"that does not implement __anext__: %.100s\",\n                              Py_TYPE(iter)->tp_name);\n                Py_DECREF(iter);\n                ERROR_IF(true, error);\n            }\n        }\n\n        inst(GET_ANEXT, (aiter -- aiter, awaitable)) {\n            unaryfunc getter = NULL;\n            PyObject *next_iter = NULL;\n            PyTypeObject *type = Py_TYPE(aiter);\n\n            if (PyAsyncGen_CheckExact(aiter)) {\n                awaitable = type->tp_as_async->am_anext(aiter);\n                if (awaitable == NULL) {\n                    goto error;\n                }\n            } else {\n                if (type->tp_as_async != NULL){\n                    getter = type->tp_as_async->am_anext;\n                }\n\n                if (getter != NULL) {\n                    next_iter = (*getter)(aiter);\n                    if (next_iter == NULL) {\n                        goto error;\n                    }\n                }\n                else {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"'async for' requires an iterator with \"\n                                  \"__anext__ method, got %.100s\",\n                                  type->tp_name);\n                    goto error;\n                }\n\n                awaitable = _PyCoro_GetAwaitableIter(next_iter);\n                if (awaitable == NULL) {\n                    _PyErr_FormatFromCause(\n                        PyExc_TypeError,\n                        \"'async for' received an invalid object \"\n                        \"from __anext__: %.100s\",\n                        Py_TYPE(next_iter)->tp_name);\n\n                    Py_DECREF(next_iter);\n                    goto error;\n                } else {\n                    Py_DECREF(next_iter);\n                }\n            }\n\n            PREDICT(LOAD_CONST);\n        }\n\n        inst(GET_AWAITABLE, (iterable -- iter)) {\n            iter = _PyCoro_GetAwaitableIter(iterable);\n\n            if (iter == NULL) {\n                format_awaitable_error(tstate, Py_TYPE(iterable), oparg);\n            }\n\n            DECREF_INPUTS();\n\n            if (iter != NULL && PyCoro_CheckExact(iter)) {\n                PyObject *yf = _PyGen_yf((PyGenObject*)iter);\n                if (yf != NULL) {\n                    /* `iter` is a coroutine object that is being\n                       awaited, `yf` is a pointer to the current awaitable\n                       being awaited on. */\n                    Py_DECREF(yf);\n                    Py_CLEAR(iter);\n                    _PyErr_SetString(tstate, PyExc_RuntimeError,\n                                     \"coroutine is being awaited already\");\n                    /* The code below jumps to `error` if `iter` is NULL. */\n                }\n            }\n\n            ERROR_IF(iter == NULL, error);\n\n            PREDICT(LOAD_CONST);\n        }\n\n        family(send, INLINE_CACHE_ENTRIES_SEND) = {\n            SEND,\n            SEND_GEN,\n        };\n\n        inst(SEND, (unused/1, receiver, v -- receiver, retval)) {\n            #if ENABLE_SPECIALIZATION\n            _PySendCache *cache = (_PySendCache *)next_instr;\n            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {\n                next_instr--;\n                _Py_Specialize_Send(receiver, next_instr);\n                DISPATCH_SAME_OPARG();\n            }\n            STAT_INC(SEND, deferred);\n            DECREMENT_ADAPTIVE_COUNTER(cache->counter);\n            #endif  /* ENABLE_SPECIALIZATION */\n            assert(frame != &entry_frame);\n            if ((tstate->interp->eval_frame == NULL) &&\n                (Py_TYPE(receiver) == &PyGen_Type || Py_TYPE(receiver) == &PyCoro_Type) &&\n                ((PyGenObject *)receiver)->gi_frame_state < FRAME_EXECUTING)\n            {\n                PyGenObject *gen = (PyGenObject *)receiver;\n                _PyInterpreterFrame *gen_frame = (_PyInterpreterFrame *)gen->gi_iframe;\n                frame->return_offset = oparg;\n                STACK_SHRINK(1);\n                _PyFrame_StackPush(gen_frame, v);\n                gen->gi_frame_state = FRAME_EXECUTING;\n                gen->gi_exc_state.previous_item = tstate->exc_info;\n                tstate->exc_info = &gen->gi_exc_state;\n                JUMPBY(INLINE_CACHE_ENTRIES_SEND);\n                DISPATCH_INLINED(gen_frame);\n            }\n            if (Py_IsNone(v) && PyIter_Check(receiver)) {\n                retval = Py_TYPE(receiver)->tp_iternext(receiver);\n            }\n            else {\n                retval = PyObject_CallMethodOneArg(receiver, &_Py_ID(send), v);\n            }\n            if (retval == NULL) {\n                if (_PyErr_ExceptionMatches(tstate, PyExc_StopIteration)\n                ) {\n                    monitor_raise(tstate, frame, next_instr-1);\n                }\n                if (_PyGen_FetchStopIterationValue(&retval) == 0) {\n                    assert(retval != NULL);\n                    JUMPBY(oparg);\n                }\n                else {\n                    goto error;\n                }\n            }\n            Py_DECREF(v);\n        }\n\n        inst(SEND_GEN, (unused/1, receiver, v -- receiver, unused)) {\n            DEOPT_IF(tstate->interp->eval_frame, SEND);\n            PyGenObject *gen = (PyGenObject *)receiver;\n            DEOPT_IF(Py_TYPE(gen) != &PyGen_Type &&\n                     Py_TYPE(gen) != &PyCoro_Type, SEND);\n            DEOPT_IF(gen->gi_frame_state >= FRAME_EXECUTING, SEND);\n            STAT_INC(SEND, hit);\n            _PyInterpreterFrame *gen_frame = (_PyInterpreterFrame *)gen->gi_iframe;\n            frame->return_offset = oparg;\n            STACK_SHRINK(1);\n            _PyFrame_StackPush(gen_frame, v);\n            gen->gi_frame_state = FRAME_EXECUTING;\n            gen->gi_exc_state.previous_item = tstate->exc_info;\n            tstate->exc_info = &gen->gi_exc_state;\n            JUMPBY(INLINE_CACHE_ENTRIES_SEND);\n            DISPATCH_INLINED(gen_frame);\n        }\n\n        inst(INSTRUMENTED_YIELD_VALUE, (retval -- unused)) {\n            assert(frame != &entry_frame);\n            PyGenObject *gen = _PyFrame_GetGenerator(frame);\n            gen->gi_frame_state = FRAME_SUSPENDED;\n            _PyFrame_SetStackPointer(frame, stack_pointer - 1);\n            int err = _Py_call_instrumentation_arg(\n                    tstate, PY_MONITORING_EVENT_PY_YIELD,\n                    frame, next_instr-1, retval);\n            if (err) goto error;\n            tstate->exc_info = gen->gi_exc_state.previous_item;\n            gen->gi_exc_state.previous_item = NULL;\n            _Py_LeaveRecursiveCallPy(tstate);\n            _PyInterpreterFrame *gen_frame = frame;\n            frame = cframe.current_frame = frame->previous;\n            gen_frame->previous = NULL;\n            _PyFrame_StackPush(frame, retval);\n            goto resume_frame;\n        }\n\n        inst(YIELD_VALUE, (retval -- unused)) {\n            // NOTE: It's important that YIELD_VALUE never raises an exception!\n            // The compiler treats any exception raised here as a failed close()\n            // or throw() call.\n            assert(frame != &entry_frame);\n            PyGenObject *gen = _PyFrame_GetGenerator(frame);\n            gen->gi_frame_state = FRAME_SUSPENDED;\n            _PyFrame_SetStackPointer(frame, stack_pointer - 1);\n            tstate->exc_info = gen->gi_exc_state.previous_item;\n            gen->gi_exc_state.previous_item = NULL;\n            _Py_LeaveRecursiveCallPy(tstate);\n            _PyInterpreterFrame *gen_frame = frame;\n            frame = cframe.current_frame = frame->previous;\n            gen_frame->previous = NULL;\n            _PyFrame_StackPush(frame, retval);\n            goto resume_frame;\n        }\n\n        inst(POP_EXCEPT, (exc_value -- )) {\n            _PyErr_StackItem *exc_info = tstate->exc_info;\n            Py_XSETREF(exc_info->exc_value, exc_value);\n        }\n\n        inst(RERAISE, (values[oparg], exc -- values[oparg])) {\n            assert(oparg >= 0 && oparg <= 2);\n            if (oparg) {\n                PyObject *lasti = values[0];\n                if (PyLong_Check(lasti)) {\n                    frame->prev_instr = _PyCode_CODE(frame->f_code) + PyLong_AsLong(lasti);\n                    assert(!_PyErr_Occurred(tstate));\n                }\n                else {\n                    assert(PyLong_Check(lasti));\n                    _PyErr_SetString(tstate, PyExc_SystemError, \"lasti is not an int\");\n                    goto error;\n                }\n            }\n            assert(exc && PyExceptionInstance_Check(exc));\n            Py_INCREF(exc);\n            _PyErr_SetRaisedException(tstate, exc);\n            monitor_reraise(tstate, frame, next_instr-1);\n            goto exception_unwind;\n        }\n\n        inst(END_ASYNC_FOR, (awaitable, exc -- )) {\n            assert(exc && PyExceptionInstance_Check(exc));\n            if (PyErr_GivenExceptionMatches(exc, PyExc_StopAsyncIteration)) {\n                DECREF_INPUTS();\n            }\n            else {\n                Py_INCREF(exc);\n                _PyErr_SetRaisedException(tstate, exc);\n                monitor_reraise(tstate, frame, next_instr-1);\n                goto exception_unwind;\n            }\n        }\n\n        inst(CLEANUP_THROW, (sub_iter, last_sent_val, exc_value -- none, value)) {\n            assert(throwflag);\n            assert(exc_value && PyExceptionInstance_Check(exc_value));\n            if (PyErr_GivenExceptionMatches(exc_value, PyExc_StopIteration)) {\n                value = Py_NewRef(((PyStopIterationObject *)exc_value)->value);\n                DECREF_INPUTS();\n                none = Py_None;\n            }\n            else {\n                _PyErr_SetRaisedException(tstate, Py_NewRef(exc_value));\n                monitor_reraise(tstate, frame, next_instr-1);\n                goto exception_unwind;\n            }\n        }\n\n        inst(LOAD_ASSERTION_ERROR, ( -- value)) {\n            value = Py_NewRef(PyExc_AssertionError);\n        }\n\n        inst(LOAD_BUILD_CLASS, ( -- bc)) {\n            if (PyDict_CheckExact(BUILTINS())) {\n                bc = _PyDict_GetItemWithError(BUILTINS(),\n                                              &_Py_ID(__build_class__));\n                if (bc == NULL) {\n                    if (!_PyErr_Occurred(tstate)) {\n                        _PyErr_SetString(tstate, PyExc_NameError,\n                                         \"__build_class__ not found\");\n                    }\n                    ERROR_IF(true, error);\n                }\n                Py_INCREF(bc);\n            }\n            else {\n                bc = PyObject_GetItem(BUILTINS(), &_Py_ID(__build_class__));\n                if (bc == NULL) {\n                    if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError))\n                        _PyErr_SetString(tstate, PyExc_NameError,\n                                         \"__build_class__ not found\");\n                    ERROR_IF(true, error);\n                }\n            }\n        }\n\n\n        inst(STORE_NAME, (v -- )) {\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg);\n            PyObject *ns = LOCALS();\n            int err;\n            if (ns == NULL) {\n                _PyErr_Format(tstate, PyExc_SystemError,\n                              \"no locals found when storing %R\", name);\n                DECREF_INPUTS();\n                ERROR_IF(true, error);\n            }\n            if (PyDict_CheckExact(ns))\n                err = PyDict_SetItem(ns, name, v);\n            else\n                err = PyObject_SetItem(ns, name, v);\n            DECREF_INPUTS();\n            ERROR_IF(err, error);\n        }\n\n        inst(DELETE_NAME, (--)) {\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg);\n            PyObject *ns = LOCALS();\n            int err;\n            if (ns == NULL) {\n                _PyErr_Format(tstate, PyExc_SystemError,\n                              \"no locals when deleting %R\", name);\n                goto error;\n            }\n            err = PyObject_DelItem(ns, name);\n            // Can't use ERROR_IF here.\n            if (err != 0) {\n                format_exc_check_arg(tstate, PyExc_NameError,\n                                     NAME_ERROR_MSG,\n                                     name);\n                goto error;\n            }\n        }\n\n        family(unpack_sequence, INLINE_CACHE_ENTRIES_UNPACK_SEQUENCE) = {\n            UNPACK_SEQUENCE,\n            UNPACK_SEQUENCE_TWO_TUPLE,\n            UNPACK_SEQUENCE_TUPLE,\n            UNPACK_SEQUENCE_LIST,\n        };\n\n        inst(UNPACK_SEQUENCE, (unused/1, seq -- unused[oparg])) {\n            #if ENABLE_SPECIALIZATION\n            _PyUnpackSequenceCache *cache = (_PyUnpackSequenceCache *)next_instr;\n            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {\n                next_instr--;\n                _Py_Specialize_UnpackSequence(seq, next_instr, oparg);\n                DISPATCH_SAME_OPARG();\n            }\n            STAT_INC(UNPACK_SEQUENCE, deferred);\n            DECREMENT_ADAPTIVE_COUNTER(cache->counter);\n            #endif  /* ENABLE_SPECIALIZATION */\n            PyObject **top = stack_pointer + oparg - 1;\n            int res = unpack_iterable(tstate, seq, oparg, -1, top);\n            DECREF_INPUTS();\n            ERROR_IF(res == 0, error);\n        }\n\n        inst(UNPACK_SEQUENCE_TWO_TUPLE, (unused/1, seq -- values[oparg])) {\n            DEOPT_IF(!PyTuple_CheckExact(seq), UNPACK_SEQUENCE);\n            DEOPT_IF(PyTuple_GET_SIZE(seq) != 2, UNPACK_SEQUENCE);\n            assert(oparg == 2);\n            STAT_INC(UNPACK_SEQUENCE, hit);\n            values[0] = Py_NewRef(PyTuple_GET_ITEM(seq, 1));\n            values[1] = Py_NewRef(PyTuple_GET_ITEM(seq, 0));\n            DECREF_INPUTS();\n        }\n\n        inst(UNPACK_SEQUENCE_TUPLE, (unused/1, seq -- values[oparg])) {\n            DEOPT_IF(!PyTuple_CheckExact(seq), UNPACK_SEQUENCE);\n            DEOPT_IF(PyTuple_GET_SIZE(seq) != oparg, UNPACK_SEQUENCE);\n            STAT_INC(UNPACK_SEQUENCE, hit);\n            PyObject **items = _PyTuple_ITEMS(seq);\n            for (int i = oparg; --i >= 0; ) {\n                *values++ = Py_NewRef(items[i]);\n            }\n            DECREF_INPUTS();\n        }\n\n        inst(UNPACK_SEQUENCE_LIST, (unused/1, seq -- values[oparg])) {\n            DEOPT_IF(!PyList_CheckExact(seq), UNPACK_SEQUENCE);\n            DEOPT_IF(PyList_GET_SIZE(seq) != oparg, UNPACK_SEQUENCE);\n            STAT_INC(UNPACK_SEQUENCE, hit);\n            PyObject **items = _PyList_ITEMS(seq);\n            for (int i = oparg; --i >= 0; ) {\n                *values++ = Py_NewRef(items[i]);\n            }\n            DECREF_INPUTS();\n        }\n\n        inst(UNPACK_EX, (seq -- unused[oparg & 0xFF], unused, unused[oparg >> 8])) {\n            int totalargs = 1 + (oparg & 0xFF) + (oparg >> 8);\n            PyObject **top = stack_pointer + totalargs - 1;\n            int res = unpack_iterable(tstate, seq, oparg & 0xFF, oparg >> 8, top);\n            DECREF_INPUTS();\n            ERROR_IF(res == 0, error);\n        }\n\n        family(store_attr, INLINE_CACHE_ENTRIES_STORE_ATTR) = {\n            STORE_ATTR,\n            STORE_ATTR_INSTANCE_VALUE,\n            STORE_ATTR_SLOT,\n            STORE_ATTR_WITH_HINT,\n        };\n\n        inst(STORE_ATTR, (counter/1, unused/3, v, owner --)) {\n            #if ENABLE_SPECIALIZATION\n            if (ADAPTIVE_COUNTER_IS_ZERO(counter)) {\n                PyObject *name = GETITEM(frame->f_code->co_names, oparg);\n                next_instr--;\n                _Py_Specialize_StoreAttr(owner, next_instr, name);\n                DISPATCH_SAME_OPARG();\n            }\n            STAT_INC(STORE_ATTR, deferred);\n            _PyAttrCache *cache = (_PyAttrCache *)next_instr;\n            DECREMENT_ADAPTIVE_COUNTER(cache->counter);\n            #else\n            (void)counter;  // Unused.\n            #endif  /* ENABLE_SPECIALIZATION */\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg);\n            int err = PyObject_SetAttr(owner, name, v);\n            DECREF_INPUTS();\n            ERROR_IF(err, error);\n        }\n\n        inst(DELETE_ATTR, (owner --)) {\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg);\n            int err = PyObject_SetAttr(owner, name, (PyObject *)NULL);\n            DECREF_INPUTS();\n            ERROR_IF(err, error);\n        }\n\n        inst(STORE_GLOBAL, (v --)) {\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg);\n            int err = PyDict_SetItem(GLOBALS(), name, v);\n            DECREF_INPUTS();\n            ERROR_IF(err, error);\n        }\n\n        inst(DELETE_GLOBAL, (--)) {\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg);\n            int err;\n            err = PyDict_DelItem(GLOBALS(), name);\n            // Can't use ERROR_IF here.\n            if (err != 0) {\n                if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n                    format_exc_check_arg(tstate, PyExc_NameError,\n                                         NAME_ERROR_MSG, name);\n                }\n                goto error;\n            }\n        }\n\n        inst(LOAD_LOCALS, ( -- locals)) {\n            locals = LOCALS();\n            if (locals == NULL) {\n                _PyErr_SetString(tstate, PyExc_SystemError,\n                                 \"no locals found\");\n                ERROR_IF(true, error);\n            }\n            Py_INCREF(locals);\n        }\n\n        inst(LOAD_FROM_DICT_OR_GLOBALS, (mod_or_class_dict -- v)) {\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg);\n            if (PyDict_CheckExact(mod_or_class_dict)) {\n                v = PyDict_GetItemWithError(mod_or_class_dict, name);\n                if (v != NULL) {\n                    Py_INCREF(v);\n                }\n                else if (_PyErr_Occurred(tstate)) {\n                    goto error;\n                }\n            }\n            else {\n                v = PyObject_GetItem(mod_or_class_dict, name);\n                if (v == NULL) {\n                    if (!_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n                        goto error;\n                    }\n                    _PyErr_Clear(tstate);\n                }\n            }\n            if (v == NULL) {\n                if (PyDict_CheckExact(GLOBALS())\n                    && PyDict_CheckExact(BUILTINS()))\n                {\n                    v = _PyDict_LoadGlobal((PyDictObject *)GLOBALS(),\n                                        (PyDictObject *)BUILTINS(),\n                                        name);\n                    if (v == NULL) {\n                        if (!_PyErr_Occurred(tstate)) {\n                            /* _PyDict_LoadGlobal() returns NULL without raising\n                            * an exception if the key doesn't exist */\n                            format_exc_check_arg(tstate, PyExc_NameError,\n                                                NAME_ERROR_MSG, name);\n                        }\n                        Py_DECREF(mod_or_class_dict);\n                        ERROR_IF(true, error);\n                    }\n                    Py_INCREF(v);\n                }\n                else {\n                    /* Slow-path if globals or builtins is not a dict */\n\n                    /* namespace 1: globals */\n                    v = PyObject_GetItem(GLOBALS(), name);\n                    if (v == NULL) {\n                        ERROR_IF(!_PyErr_ExceptionMatches(tstate, PyExc_KeyError), error);\n                        _PyErr_Clear(tstate);\n\n                        /* namespace 2: builtins */\n                        v = PyObject_GetItem(BUILTINS(), name);\n                        if (v == NULL) {\n                            if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n                                format_exc_check_arg(\n                                            tstate, PyExc_NameError,\n                                            NAME_ERROR_MSG, name);\n                            }\n                            Py_DECREF(mod_or_class_dict);\n                            ERROR_IF(true, error);\n                        }\n                    }\n                }\n            }\n            DECREF_INPUTS();\n        }\n\n        inst(LOAD_NAME, (-- v)) {\n            PyObject *mod_or_class_dict = LOCALS();\n            if (mod_or_class_dict == NULL) {\n                _PyErr_SetString(tstate, PyExc_SystemError,\n                                 \"no locals found\");\n                ERROR_IF(true, error);\n            }\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg);\n            if (PyDict_CheckExact(mod_or_class_dict)) {\n                v = PyDict_GetItemWithError(mod_or_class_dict, name);\n                if (v != NULL) {\n                    Py_INCREF(v);\n                }\n                else if (_PyErr_Occurred(tstate)) {\n                    goto error;\n                }\n            }\n            else {\n                v = PyObject_GetItem(mod_or_class_dict, name);\n                if (v == NULL) {\n                    if (!_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n                        goto error;\n                    }\n                    _PyErr_Clear(tstate);\n                }\n            }\n            if (v == NULL) {\n                v = PyDict_GetItemWithError(GLOBALS(), name);\n                if (v != NULL) {\n                    Py_INCREF(v);\n                }\n                else if (_PyErr_Occurred(tstate)) {\n                    goto error;\n                }\n                else {\n                    if (PyDict_CheckExact(BUILTINS())) {\n                        v = PyDict_GetItemWithError(BUILTINS(), name);\n                        if (v == NULL) {\n                            if (!_PyErr_Occurred(tstate)) {\n                                format_exc_check_arg(\n                                        tstate, PyExc_NameError,\n                                        NAME_ERROR_MSG, name);\n                            }\n                            goto error;\n                        }\n                        Py_INCREF(v);\n                    }\n                    else {\n                        v = PyObject_GetItem(BUILTINS(), name);\n                        if (v == NULL) {\n                            if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n                                format_exc_check_arg(\n                                            tstate, PyExc_NameError,\n                                            NAME_ERROR_MSG, name);\n                            }\n                            goto error;\n                        }\n                    }\n                }\n            }\n        }\n\n        family(load_global, INLINE_CACHE_ENTRIES_LOAD_GLOBAL) = {\n            LOAD_GLOBAL,\n            LOAD_GLOBAL_MODULE,\n            LOAD_GLOBAL_BUILTIN,\n        };\n\n        inst(LOAD_GLOBAL, (unused/1, unused/1, unused/1, unused/1 -- null if (oparg & 1), v)) {\n            #if ENABLE_SPECIALIZATION\n            _PyLoadGlobalCache *cache = (_PyLoadGlobalCache *)next_instr;\n            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {\n                PyObject *name = GETITEM(frame->f_code->co_names, oparg>>1);\n                next_instr--;\n                _Py_Specialize_LoadGlobal(GLOBALS(), BUILTINS(), next_instr, name);\n                DISPATCH_SAME_OPARG();\n            }\n            STAT_INC(LOAD_GLOBAL, deferred);\n            DECREMENT_ADAPTIVE_COUNTER(cache->counter);\n            #endif  /* ENABLE_SPECIALIZATION */\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg>>1);\n            if (PyDict_CheckExact(GLOBALS())\n                && PyDict_CheckExact(BUILTINS()))\n            {\n                v = _PyDict_LoadGlobal((PyDictObject *)GLOBALS(),\n                                       (PyDictObject *)BUILTINS(),\n                                       name);\n                if (v == NULL) {\n                    if (!_PyErr_Occurred(tstate)) {\n                        /* _PyDict_LoadGlobal() returns NULL without raising\n                         * an exception if the key doesn't exist */\n                        format_exc_check_arg(tstate, PyExc_NameError,\n                                             NAME_ERROR_MSG, name);\n                    }\n                    ERROR_IF(true, error);\n                }\n                Py_INCREF(v);\n            }\n            else {\n                /* Slow-path if globals or builtins is not a dict */\n\n                /* namespace 1: globals */\n                v = PyObject_GetItem(GLOBALS(), name);\n                if (v == NULL) {\n                    ERROR_IF(!_PyErr_ExceptionMatches(tstate, PyExc_KeyError), error);\n                    _PyErr_Clear(tstate);\n\n                    /* namespace 2: builtins */\n                    v = PyObject_GetItem(BUILTINS(), name);\n                    if (v == NULL) {\n                        if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n                            format_exc_check_arg(\n                                        tstate, PyExc_NameError,\n                                        NAME_ERROR_MSG, name);\n                        }\n                        ERROR_IF(true, error);\n                    }\n                }\n            }\n            null = NULL;\n        }\n\n        inst(LOAD_GLOBAL_MODULE, (unused/1, index/1, version/1, unused/1 -- null if (oparg & 1), res)) {\n            DEOPT_IF(!PyDict_CheckExact(GLOBALS()), LOAD_GLOBAL);\n            PyDictObject *dict = (PyDictObject *)GLOBALS();\n            DEOPT_IF(dict->ma_keys->dk_version != version, LOAD_GLOBAL);\n            assert(DK_IS_UNICODE(dict->ma_keys));\n            PyDictUnicodeEntry *entries = DK_UNICODE_ENTRIES(dict->ma_keys);\n            res = entries[index].me_value;\n            DEOPT_IF(res == NULL, LOAD_GLOBAL);\n            Py_INCREF(res);\n            STAT_INC(LOAD_GLOBAL, hit);\n            null = NULL;\n        }\n\n        inst(LOAD_GLOBAL_BUILTIN, (unused/1, index/1, mod_version/1, bltn_version/1 -- null if (oparg & 1), res)) {\n            DEOPT_IF(!PyDict_CheckExact(GLOBALS()), LOAD_GLOBAL);\n            DEOPT_IF(!PyDict_CheckExact(BUILTINS()), LOAD_GLOBAL);\n            PyDictObject *mdict = (PyDictObject *)GLOBALS();\n            PyDictObject *bdict = (PyDictObject *)BUILTINS();\n            assert(opcode == LOAD_GLOBAL_BUILTIN);\n            DEOPT_IF(mdict->ma_keys->dk_version != mod_version, LOAD_GLOBAL);\n            DEOPT_IF(bdict->ma_keys->dk_version != bltn_version, LOAD_GLOBAL);\n            assert(DK_IS_UNICODE(bdict->ma_keys));\n            PyDictUnicodeEntry *entries = DK_UNICODE_ENTRIES(bdict->ma_keys);\n            res = entries[index].me_value;\n            DEOPT_IF(res == NULL, LOAD_GLOBAL);\n            Py_INCREF(res);\n            STAT_INC(LOAD_GLOBAL, hit);\n            null = NULL;\n        }\n\n        inst(DELETE_FAST, (--)) {\n            PyObject *v = GETLOCAL(oparg);\n            ERROR_IF(v == NULL, unbound_local_error);\n            SETLOCAL(oparg, NULL);\n        }\n\n        inst(MAKE_CELL, (--)) {\n            // \"initial\" is probably NULL but not if it's an arg (or set\n            // via PyFrame_LocalsToFast() before MAKE_CELL has run).\n            PyObject *initial = GETLOCAL(oparg);\n            PyObject *cell = PyCell_New(initial);\n            if (cell == NULL) {\n                goto resume_with_error;\n            }\n            SETLOCAL(oparg, cell);\n        }\n\n        inst(DELETE_DEREF, (--)) {\n            PyObject *cell = GETLOCAL(oparg);\n            PyObject *oldobj = PyCell_GET(cell);\n            // Can't use ERROR_IF here.\n            // Fortunately we don't need its superpower.\n            if (oldobj == NULL) {\n                format_exc_unbound(tstate, frame->f_code, oparg);\n                goto error;\n            }\n            PyCell_SET(cell, NULL);\n            Py_DECREF(oldobj);\n        }\n\n        inst(LOAD_FROM_DICT_OR_DEREF, (class_dict -- value)) {\n            PyObject *name;\n            assert(class_dict);\n            assert(oparg >= 0 && oparg < frame->f_code->co_nlocalsplus);\n            name = PyTuple_GET_ITEM(frame->f_code->co_localsplusnames, oparg);\n            if (PyDict_CheckExact(class_dict)) {\n                value = PyDict_GetItemWithError(class_dict, name);\n                if (value != NULL) {\n                    Py_INCREF(value);\n                }\n                else if (_PyErr_Occurred(tstate)) {\n                    goto error;\n                }\n            }\n            else {\n                value = PyObject_GetItem(class_dict, name);\n                if (value == NULL) {\n                    if (!_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n                        goto error;\n                    }\n                    _PyErr_Clear(tstate);\n                }\n            }\n            if (!value) {\n                PyObject *cell = GETLOCAL(oparg);\n                value = PyCell_GET(cell);\n                if (value == NULL) {\n                    format_exc_unbound(tstate, frame->f_code, oparg);\n                    goto error;\n                }\n                Py_INCREF(value);\n            }\n            Py_DECREF(class_dict);\n        }\n\n        inst(LOAD_DEREF, ( -- value)) {\n            PyObject *cell = GETLOCAL(oparg);\n            value = PyCell_GET(cell);\n            if (value == NULL) {\n                format_exc_unbound(tstate, frame->f_code, oparg);\n                ERROR_IF(true, error);\n            }\n            Py_INCREF(value);\n        }\n\n        inst(STORE_DEREF, (v --)) {\n            PyObject *cell = GETLOCAL(oparg);\n            PyObject *oldobj = PyCell_GET(cell);\n            PyCell_SET(cell, v);\n            Py_XDECREF(oldobj);\n        }\n\n        inst(COPY_FREE_VARS, (--)) {\n            /* Copy closure variables to free variables */\n            PyCodeObject *co = frame->f_code;\n            assert(PyFunction_Check(frame->f_funcobj));\n            PyObject *closure = ((PyFunctionObject *)frame->f_funcobj)->func_closure;\n            assert(oparg == co->co_nfreevars);\n            int offset = co->co_nlocalsplus - oparg;\n            for (int i = 0; i < oparg; ++i) {\n                PyObject *o = PyTuple_GET_ITEM(closure, i);\n                frame->localsplus[offset + i] = Py_NewRef(o);\n            }\n        }\n\n        inst(BUILD_STRING, (pieces[oparg] -- str)) {\n            str = _PyUnicode_JoinArray(&_Py_STR(empty), pieces, oparg);\n            DECREF_INPUTS();\n            ERROR_IF(str == NULL, error);\n        }\n\n        inst(BUILD_TUPLE, (values[oparg] -- tup)) {\n            tup = _PyTuple_FromArraySteal(values, oparg);\n            ERROR_IF(tup == NULL, error);\n        }\n\n        inst(BUILD_LIST, (values[oparg] -- list)) {\n            list = _PyList_FromArraySteal(values, oparg);\n            ERROR_IF(list == NULL, error);\n        }\n\n        inst(LIST_EXTEND, (list, unused[oparg-1], iterable -- list, unused[oparg-1])) {\n            PyObject *none_val = _PyList_Extend((PyListObject *)list, iterable);\n            if (none_val == NULL) {\n                if (_PyErr_ExceptionMatches(tstate, PyExc_TypeError) &&\n                   (Py_TYPE(iterable)->tp_iter == NULL && !PySequence_Check(iterable)))\n                {\n                    _PyErr_Clear(tstate);\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                          \"Value after * must be an iterable, not %.200s\",\n                          Py_TYPE(iterable)->tp_name);\n                }\n                DECREF_INPUTS();\n                ERROR_IF(true, error);\n            }\n            assert(Py_IsNone(none_val));\n            DECREF_INPUTS();\n        }\n\n        inst(SET_UPDATE, (set, unused[oparg-1], iterable -- set, unused[oparg-1])) {\n            int err = _PySet_Update(set, iterable);\n            DECREF_INPUTS();\n            ERROR_IF(err < 0, error);\n        }\n\n        inst(BUILD_SET, (values[oparg] -- set)) {\n            set = PySet_New(NULL);\n            if (set == NULL)\n                goto error;\n            int err = 0;\n            for (int i = 0; i < oparg; i++) {\n                PyObject *item = values[i];\n                if (err == 0)\n                    err = PySet_Add(set, item);\n                Py_DECREF(item);\n            }\n            if (err != 0) {\n                Py_DECREF(set);\n                ERROR_IF(true, error);\n            }\n        }\n\n        inst(BUILD_MAP, (values[oparg*2] -- map)) {\n            map = _PyDict_FromItems(\n                    values, 2,\n                    values+1, 2,\n                    oparg);\n            DECREF_INPUTS();\n            ERROR_IF(map == NULL, error);\n        }\n\n        inst(SETUP_ANNOTATIONS, (--)) {\n            int err;\n            PyObject *ann_dict;\n            if (LOCALS() == NULL) {\n                _PyErr_Format(tstate, PyExc_SystemError,\n                              \"no locals found when setting up annotations\");\n                ERROR_IF(true, error);\n            }\n            /* check if __annotations__ in locals()... */\n            if (PyDict_CheckExact(LOCALS())) {\n                ann_dict = _PyDict_GetItemWithError(LOCALS(),\n                                                    &_Py_ID(__annotations__));\n                if (ann_dict == NULL) {\n                    ERROR_IF(_PyErr_Occurred(tstate), error);\n                    /* ...if not, create a new one */\n                    ann_dict = PyDict_New();\n                    ERROR_IF(ann_dict == NULL, error);\n                    err = PyDict_SetItem(LOCALS(), &_Py_ID(__annotations__),\n                                         ann_dict);\n                    Py_DECREF(ann_dict);\n                    ERROR_IF(err, error);\n                }\n            }\n            else {\n                /* do the same if locals() is not a dict */\n                ann_dict = PyObject_GetItem(LOCALS(), &_Py_ID(__annotations__));\n                if (ann_dict == NULL) {\n                    ERROR_IF(!_PyErr_ExceptionMatches(tstate, PyExc_KeyError), error);\n                    _PyErr_Clear(tstate);\n                    ann_dict = PyDict_New();\n                    ERROR_IF(ann_dict == NULL, error);\n                    err = PyObject_SetItem(LOCALS(), &_Py_ID(__annotations__),\n                                           ann_dict);\n                    Py_DECREF(ann_dict);\n                    ERROR_IF(err, error);\n                }\n                else {\n                    Py_DECREF(ann_dict);\n                }\n            }\n        }\n\n        inst(BUILD_CONST_KEY_MAP, (values[oparg], keys -- map)) {\n            if (!PyTuple_CheckExact(keys) ||\n                PyTuple_GET_SIZE(keys) != (Py_ssize_t)oparg) {\n                _PyErr_SetString(tstate, PyExc_SystemError,\n                                 \"bad BUILD_CONST_KEY_MAP keys argument\");\n                goto error;  // Pop the keys and values.\n            }\n            map = _PyDict_FromItems(\n                    &PyTuple_GET_ITEM(keys, 0), 1,\n                    values, 1, oparg);\n            DECREF_INPUTS();\n            ERROR_IF(map == NULL, error);\n        }\n\n        inst(DICT_UPDATE, (update --)) {\n            PyObject *dict = PEEK(oparg + 1);  // update is still on the stack\n            if (PyDict_Update(dict, update) < 0) {\n                if (_PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                    \"'%.200s' object is not a mapping\",\n                                    Py_TYPE(update)->tp_name);\n                }\n                DECREF_INPUTS();\n                ERROR_IF(true, error);\n            }\n            DECREF_INPUTS();\n        }\n\n        inst(DICT_MERGE, (update --)) {\n            PyObject *dict = PEEK(oparg + 1);  // update is still on the stack\n\n            if (_PyDict_MergeEx(dict, update, 2) < 0) {\n                format_kwargs_error(tstate, PEEK(3 + oparg), update);\n                DECREF_INPUTS();\n                ERROR_IF(true, error);\n            }\n            DECREF_INPUTS();\n            PREDICT(CALL_FUNCTION_EX);\n        }\n\n        inst(MAP_ADD, (key, value --)) {\n            PyObject *dict = PEEK(oparg + 2);  // key, value are still on the stack\n            assert(PyDict_CheckExact(dict));\n            /* dict[key] = value */\n            // Do not DECREF INPUTS because the function steals the references\n            ERROR_IF(_PyDict_SetItem_Take2((PyDictObject *)dict, key, value) != 0, error);\n            PREDICT(JUMP_BACKWARD);\n        }\n\n        inst(INSTRUMENTED_LOAD_SUPER_ATTR, (unused/9, unused, unused, unused -- unused if (oparg & 1), unused)) {\n            _PySuperAttrCache *cache = (_PySuperAttrCache *)next_instr;\n            // cancel out the decrement that will happen in LOAD_SUPER_ATTR; we\n            // don't want to specialize instrumented instructions\n            INCREMENT_ADAPTIVE_COUNTER(cache->counter);\n            GO_TO_INSTRUCTION(LOAD_SUPER_ATTR);\n        }\n\n        family(load_super_attr, INLINE_CACHE_ENTRIES_LOAD_SUPER_ATTR) = {\n            LOAD_SUPER_ATTR,\n            LOAD_SUPER_ATTR_ATTR,\n            LOAD_SUPER_ATTR_METHOD,\n        };\n\n        inst(LOAD_SUPER_ATTR, (unused/1, global_super, class, self -- res2 if (oparg & 1), res)) {\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg >> 2);\n            int load_method = oparg & 1;\n            #if ENABLE_SPECIALIZATION\n            _PySuperAttrCache *cache = (_PySuperAttrCache *)next_instr;\n            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {\n                next_instr--;\n                _Py_Specialize_LoadSuperAttr(global_super, class, next_instr, load_method);\n                DISPATCH_SAME_OPARG();\n            }\n            STAT_INC(LOAD_SUPER_ATTR, deferred);\n            DECREMENT_ADAPTIVE_COUNTER(cache->counter);\n            #endif  /* ENABLE_SPECIALIZATION */\n\n            if (opcode == INSTRUMENTED_LOAD_SUPER_ATTR) {\n                PyObject *arg = oparg & 2 ? class : &_PyInstrumentation_MISSING;\n                int err = _Py_call_instrumentation_2args(\n                        tstate, PY_MONITORING_EVENT_CALL,\n                        frame, next_instr-1, global_super, arg);\n                ERROR_IF(err, error);\n            }\n\n            // we make no attempt to optimize here; specializations should\n            // handle any case whose performance we care about\n            PyObject *stack[] = {class, self};\n            PyObject *super = PyObject_Vectorcall(global_super, stack, oparg & 2, NULL);\n            if (opcode == INSTRUMENTED_LOAD_SUPER_ATTR) {\n                PyObject *arg = oparg & 2 ? class : &_PyInstrumentation_MISSING;\n                if (super == NULL) {\n                    _Py_call_instrumentation_exc2(\n                        tstate, PY_MONITORING_EVENT_C_RAISE,\n                        frame, next_instr-1, global_super, arg);\n                }\n                else {\n                    int err = _Py_call_instrumentation_2args(\n                        tstate, PY_MONITORING_EVENT_C_RETURN,\n                        frame, next_instr-1, global_super, arg);\n                    if (err < 0) {\n                        Py_CLEAR(super);\n                    }\n                }\n            }\n            DECREF_INPUTS();\n            ERROR_IF(super == NULL, error);\n            res = PyObject_GetAttr(super, name);\n            Py_DECREF(super);\n            ERROR_IF(res == NULL, error);\n        }\n\n        inst(LOAD_SUPER_ATTR_ATTR, (unused/1, global_super, class, self -- res2 if (oparg & 1), res)) {\n            assert(!(oparg & 1));\n            DEOPT_IF(global_super != (PyObject *)&PySuper_Type, LOAD_SUPER_ATTR);\n            DEOPT_IF(!PyType_Check(class), LOAD_SUPER_ATTR);\n            STAT_INC(LOAD_SUPER_ATTR, hit);\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg >> 2);\n            res = _PySuper_Lookup((PyTypeObject *)class, self, name, NULL);\n            DECREF_INPUTS();\n            ERROR_IF(res == NULL, error);\n        }\n\n        inst(LOAD_SUPER_ATTR_METHOD, (unused/1, global_super, class, self -- res2, res)) {\n            assert(oparg & 1);\n            DEOPT_IF(global_super != (PyObject *)&PySuper_Type, LOAD_SUPER_ATTR);\n            DEOPT_IF(!PyType_Check(class), LOAD_SUPER_ATTR);\n            STAT_INC(LOAD_SUPER_ATTR, hit);\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg >> 2);\n            PyTypeObject *cls = (PyTypeObject *)class;\n            int method_found = 0;\n            res2 = _PySuper_Lookup(cls, self, name,\n                                   Py_TYPE(self)->tp_getattro == PyObject_GenericGetAttr ? &method_found : NULL);\n            Py_DECREF(global_super);\n            Py_DECREF(class);\n            if (res2 == NULL) {\n                Py_DECREF(self);\n                ERROR_IF(true, error);\n            }\n            if (method_found) {\n                res = self; // transfer ownership\n            } else {\n                Py_DECREF(self);\n                res = res2;\n                res2 = NULL;\n            }\n        }\n\n        family(load_attr, INLINE_CACHE_ENTRIES_LOAD_ATTR) = {\n            LOAD_ATTR,\n            LOAD_ATTR_INSTANCE_VALUE,\n            LOAD_ATTR_MODULE,\n            LOAD_ATTR_WITH_HINT,\n            LOAD_ATTR_SLOT,\n            LOAD_ATTR_CLASS,\n            LOAD_ATTR_PROPERTY,\n            LOAD_ATTR_GETATTRIBUTE_OVERRIDDEN,\n            LOAD_ATTR_METHOD_WITH_VALUES,\n            LOAD_ATTR_METHOD_NO_DICT,\n            LOAD_ATTR_METHOD_LAZY_DICT,\n        };\n\n        inst(LOAD_ATTR, (unused/9, owner -- res2 if (oparg & 1), res)) {\n            #if ENABLE_SPECIALIZATION\n            _PyAttrCache *cache = (_PyAttrCache *)next_instr;\n            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {\n                PyObject *name = GETITEM(frame->f_code->co_names, oparg>>1);\n                next_instr--;\n                _Py_Specialize_LoadAttr(owner, next_instr, name);\n                DISPATCH_SAME_OPARG();\n            }\n            STAT_INC(LOAD_ATTR, deferred);\n            DECREMENT_ADAPTIVE_COUNTER(cache->counter);\n            #endif  /* ENABLE_SPECIALIZATION */\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg >> 1);\n            if (oparg & 1) {\n                /* Designed to work in tandem with CALL, pushes two values. */\n                PyObject* meth = NULL;\n                if (_PyObject_GetMethod(owner, name, &meth)) {\n                    /* We can bypass temporary bound method object.\n                       meth is unbound method and obj is self.\n\n                       meth | self | arg1 | ... | argN\n                     */\n                    assert(meth != NULL);  // No errors on this branch\n                    res2 = meth;\n                    res = owner;  // Transfer ownership\n                }\n                else {\n                    /* meth is not an unbound method (but a regular attr, or\n                       something was returned by a descriptor protocol).  Set\n                       the second element of the stack to NULL, to signal\n                       CALL that it's not a method call.\n\n                       NULL | meth | arg1 | ... | argN\n                    */\n                    DECREF_INPUTS();\n                    ERROR_IF(meth == NULL, error);\n                    res2 = NULL;\n                    res = meth;\n                }\n            }\n            else {\n                /* Classic, pushes one value. */\n                res = PyObject_GetAttr(owner, name);\n                DECREF_INPUTS();\n                ERROR_IF(res == NULL, error);\n            }\n        }\n\n        inst(LOAD_ATTR_INSTANCE_VALUE, (unused/1, type_version/2, index/1, unused/5, owner -- res2 if (oparg & 1), res)) {\n            PyTypeObject *tp = Py_TYPE(owner);\n            assert(type_version != 0);\n            DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);\n            assert(tp->tp_dictoffset < 0);\n            assert(tp->tp_flags & Py_TPFLAGS_MANAGED_DICT);\n            PyDictOrValues dorv = *_PyObject_DictOrValuesPointer(owner);\n            DEOPT_IF(!_PyDictOrValues_IsValues(dorv), LOAD_ATTR);\n            res = _PyDictOrValues_GetValues(dorv)->values[index];\n            DEOPT_IF(res == NULL, LOAD_ATTR);\n            STAT_INC(LOAD_ATTR, hit);\n            Py_INCREF(res);\n            res2 = NULL;\n            DECREF_INPUTS();\n        }\n\n        inst(LOAD_ATTR_MODULE, (unused/1, type_version/2, index/1, unused/5, owner -- res2 if (oparg & 1), res)) {\n            DEOPT_IF(!PyModule_CheckExact(owner), LOAD_ATTR);\n            PyDictObject *dict = (PyDictObject *)((PyModuleObject *)owner)->md_dict;\n            assert(dict != NULL);\n            DEOPT_IF(dict->ma_keys->dk_version != type_version, LOAD_ATTR);\n            assert(dict->ma_keys->dk_kind == DICT_KEYS_UNICODE);\n            assert(index < dict->ma_keys->dk_nentries);\n            PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(dict->ma_keys) + index;\n            res = ep->me_value;\n            DEOPT_IF(res == NULL, LOAD_ATTR);\n            STAT_INC(LOAD_ATTR, hit);\n            Py_INCREF(res);\n            res2 = NULL;\n            DECREF_INPUTS();\n        }\n\n        inst(LOAD_ATTR_WITH_HINT, (unused/1, type_version/2, index/1, unused/5, owner -- res2 if (oparg & 1), res)) {\n            PyTypeObject *tp = Py_TYPE(owner);\n            assert(type_version != 0);\n            DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);\n            assert(tp->tp_flags & Py_TPFLAGS_MANAGED_DICT);\n            PyDictOrValues dorv = *_PyObject_DictOrValuesPointer(owner);\n            DEOPT_IF(_PyDictOrValues_IsValues(dorv), LOAD_ATTR);\n            PyDictObject *dict = (PyDictObject *)_PyDictOrValues_GetDict(dorv);\n            DEOPT_IF(dict == NULL, LOAD_ATTR);\n            assert(PyDict_CheckExact((PyObject *)dict));\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg>>1);\n            uint16_t hint = index;\n            DEOPT_IF(hint >= (size_t)dict->ma_keys->dk_nentries, LOAD_ATTR);\n            if (DK_IS_UNICODE(dict->ma_keys)) {\n                PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(dict->ma_keys) + hint;\n                DEOPT_IF(ep->me_key != name, LOAD_ATTR);\n                res = ep->me_value;\n            }\n            else {\n                PyDictKeyEntry *ep = DK_ENTRIES(dict->ma_keys) + hint;\n                DEOPT_IF(ep->me_key != name, LOAD_ATTR);\n                res = ep->me_value;\n            }\n            DEOPT_IF(res == NULL, LOAD_ATTR);\n            STAT_INC(LOAD_ATTR, hit);\n            Py_INCREF(res);\n            res2 = NULL;\n            DECREF_INPUTS();\n        }\n\n        inst(LOAD_ATTR_SLOT, (unused/1, type_version/2, index/1, unused/5, owner -- res2 if (oparg & 1), res)) {\n            PyTypeObject *tp = Py_TYPE(owner);\n            assert(type_version != 0);\n            DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);\n            char *addr = (char *)owner + index;\n            res = *(PyObject **)addr;\n            DEOPT_IF(res == NULL, LOAD_ATTR);\n            STAT_INC(LOAD_ATTR, hit);\n            Py_INCREF(res);\n            res2 = NULL;\n            DECREF_INPUTS();\n        }\n\n        inst(LOAD_ATTR_CLASS, (unused/1, type_version/2, unused/2, descr/4, cls -- res2 if (oparg & 1), res)) {\n\n            DEOPT_IF(!PyType_Check(cls), LOAD_ATTR);\n            DEOPT_IF(((PyTypeObject *)cls)->tp_version_tag != type_version,\n                LOAD_ATTR);\n            assert(type_version != 0);\n\n            STAT_INC(LOAD_ATTR, hit);\n            res2 = NULL;\n            res = descr;\n            assert(res != NULL);\n            Py_INCREF(res);\n            DECREF_INPUTS();\n        }\n\n        inst(LOAD_ATTR_PROPERTY, (unused/1, type_version/2, func_version/2, fget/4, owner -- unused if (oparg & 1), unused)) {\n            DEOPT_IF(tstate->interp->eval_frame, LOAD_ATTR);\n\n            PyTypeObject *cls = Py_TYPE(owner);\n            DEOPT_IF(cls->tp_version_tag != type_version, LOAD_ATTR);\n            assert(type_version != 0);\n            assert(Py_IS_TYPE(fget, &PyFunction_Type));\n            PyFunctionObject *f = (PyFunctionObject *)fget;\n            assert(func_version != 0);\n            DEOPT_IF(f->func_version != func_version, LOAD_ATTR);\n            PyCodeObject *code = (PyCodeObject *)f->func_code;\n            assert(code->co_argcount == 1);\n            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), LOAD_ATTR);\n            STAT_INC(LOAD_ATTR, hit);\n            Py_INCREF(fget);\n            _PyInterpreterFrame *new_frame = _PyFrame_PushUnchecked(tstate, f, 1);\n            // Manipulate stack directly because we exit with DISPATCH_INLINED().\n            SET_TOP(NULL);\n            int shrink_stack = !(oparg & 1);\n            STACK_SHRINK(shrink_stack);\n            new_frame->localsplus[0] = owner;\n            JUMPBY(INLINE_CACHE_ENTRIES_LOAD_ATTR);\n            frame->return_offset = 0;\n            DISPATCH_INLINED(new_frame);\n        }\n\n        inst(LOAD_ATTR_GETATTRIBUTE_OVERRIDDEN, (unused/1, type_version/2, func_version/2, getattribute/4, owner -- unused if (oparg & 1), unused)) {\n            DEOPT_IF(tstate->interp->eval_frame, LOAD_ATTR);\n            PyTypeObject *cls = Py_TYPE(owner);\n            DEOPT_IF(cls->tp_version_tag != type_version, LOAD_ATTR);\n            assert(type_version != 0);\n            assert(Py_IS_TYPE(getattribute, &PyFunction_Type));\n            PyFunctionObject *f = (PyFunctionObject *)getattribute;\n            assert(func_version != 0);\n            DEOPT_IF(f->func_version != func_version, LOAD_ATTR);\n            PyCodeObject *code = (PyCodeObject *)f->func_code;\n            assert(code->co_argcount == 2);\n            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), LOAD_ATTR);\n            STAT_INC(LOAD_ATTR, hit);\n\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg >> 1);\n            Py_INCREF(f);\n            _PyInterpreterFrame *new_frame = _PyFrame_PushUnchecked(tstate, f, 2);\n            // Manipulate stack directly because we exit with DISPATCH_INLINED().\n            SET_TOP(NULL);\n            int shrink_stack = !(oparg & 1);\n            STACK_SHRINK(shrink_stack);\n            new_frame->localsplus[0] = owner;\n            new_frame->localsplus[1] = Py_NewRef(name);\n            JUMPBY(INLINE_CACHE_ENTRIES_LOAD_ATTR);\n            frame->return_offset = 0;\n            DISPATCH_INLINED(new_frame);\n        }\n\n        inst(STORE_ATTR_INSTANCE_VALUE, (unused/1, type_version/2, index/1, value, owner --)) {\n            PyTypeObject *tp = Py_TYPE(owner);\n            assert(type_version != 0);\n            DEOPT_IF(tp->tp_version_tag != type_version, STORE_ATTR);\n            assert(tp->tp_flags & Py_TPFLAGS_MANAGED_DICT);\n            PyDictOrValues dorv = *_PyObject_DictOrValuesPointer(owner);\n            DEOPT_IF(!_PyDictOrValues_IsValues(dorv), STORE_ATTR);\n            STAT_INC(STORE_ATTR, hit);\n            PyDictValues *values = _PyDictOrValues_GetValues(dorv);\n            PyObject *old_value = values->values[index];\n            values->values[index] = value;\n            if (old_value == NULL) {\n                _PyDictValues_AddToInsertionOrder(values, index);\n            }\n            else {\n                Py_DECREF(old_value);\n            }\n            Py_DECREF(owner);\n        }\n\n        inst(STORE_ATTR_WITH_HINT, (unused/1, type_version/2, hint/1, value, owner --)) {\n            PyTypeObject *tp = Py_TYPE(owner);\n            assert(type_version != 0);\n            DEOPT_IF(tp->tp_version_tag != type_version, STORE_ATTR);\n            assert(tp->tp_flags & Py_TPFLAGS_MANAGED_DICT);\n            PyDictOrValues dorv = *_PyObject_DictOrValuesPointer(owner);\n            DEOPT_IF(_PyDictOrValues_IsValues(dorv), STORE_ATTR);\n            PyDictObject *dict = (PyDictObject *)_PyDictOrValues_GetDict(dorv);\n            DEOPT_IF(dict == NULL, STORE_ATTR);\n            assert(PyDict_CheckExact((PyObject *)dict));\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg);\n            DEOPT_IF(hint >= (size_t)dict->ma_keys->dk_nentries, STORE_ATTR);\n            PyObject *old_value;\n            uint64_t new_version;\n            if (DK_IS_UNICODE(dict->ma_keys)) {\n                PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(dict->ma_keys) + hint;\n                DEOPT_IF(ep->me_key != name, STORE_ATTR);\n                old_value = ep->me_value;\n                DEOPT_IF(old_value == NULL, STORE_ATTR);\n                new_version = _PyDict_NotifyEvent(tstate->interp, PyDict_EVENT_MODIFIED, dict, name, value);\n                ep->me_value = value;\n            }\n            else {\n                PyDictKeyEntry *ep = DK_ENTRIES(dict->ma_keys) + hint;\n                DEOPT_IF(ep->me_key != name, STORE_ATTR);\n                old_value = ep->me_value;\n                DEOPT_IF(old_value == NULL, STORE_ATTR);\n                new_version = _PyDict_NotifyEvent(tstate->interp, PyDict_EVENT_MODIFIED, dict, name, value);\n                ep->me_value = value;\n            }\n            Py_DECREF(old_value);\n            STAT_INC(STORE_ATTR, hit);\n            /* Ensure dict is GC tracked if it needs to be */\n            if (!_PyObject_GC_IS_TRACKED(dict) && _PyObject_GC_MAY_BE_TRACKED(value)) {\n                _PyObject_GC_TRACK(dict);\n            }\n            /* PEP 509 */\n            dict->ma_version_tag = new_version;\n            Py_DECREF(owner);\n        }\n\n        inst(STORE_ATTR_SLOT, (unused/1, type_version/2, index/1, value, owner --)) {\n            PyTypeObject *tp = Py_TYPE(owner);\n            assert(type_version != 0);\n            DEOPT_IF(tp->tp_version_tag != type_version, STORE_ATTR);\n            char *addr = (char *)owner + index;\n            STAT_INC(STORE_ATTR, hit);\n            PyObject *old_value = *(PyObject **)addr;\n            *(PyObject **)addr = value;\n            Py_XDECREF(old_value);\n            Py_DECREF(owner);\n        }\n\n        family(compare_op, INLINE_CACHE_ENTRIES_COMPARE_OP) = {\n            COMPARE_OP,\n            COMPARE_OP_FLOAT,\n            COMPARE_OP_INT,\n            COMPARE_OP_STR,\n        };\n\n        inst(COMPARE_OP, (unused/1, left, right -- res)) {\n            #if ENABLE_SPECIALIZATION\n            _PyCompareOpCache *cache = (_PyCompareOpCache *)next_instr;\n            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {\n                next_instr--;\n                _Py_Specialize_CompareOp(left, right, next_instr, oparg);\n                DISPATCH_SAME_OPARG();\n            }\n            STAT_INC(COMPARE_OP, deferred);\n            DECREMENT_ADAPTIVE_COUNTER(cache->counter);\n            #endif  /* ENABLE_SPECIALIZATION */\n            assert((oparg >> 4) <= Py_GE);\n            res = PyObject_RichCompare(left, right, oparg>>4);\n            DECREF_INPUTS();\n            ERROR_IF(res == NULL, error);\n        }\n\n        inst(COMPARE_OP_FLOAT, (unused/1, left, right -- res)) {\n            DEOPT_IF(!PyFloat_CheckExact(left), COMPARE_OP);\n            DEOPT_IF(!PyFloat_CheckExact(right), COMPARE_OP);\n            STAT_INC(COMPARE_OP, hit);\n            double dleft = PyFloat_AS_DOUBLE(left);\n            double dright = PyFloat_AS_DOUBLE(right);\n            // 1 if NaN, 2 if <, 4 if >, 8 if ==; this matches low four bits of the oparg\n            int sign_ish = COMPARISON_BIT(dleft, dright);\n            _Py_DECREF_SPECIALIZED(left, _PyFloat_ExactDealloc);\n            _Py_DECREF_SPECIALIZED(right, _PyFloat_ExactDealloc);\n            res = (sign_ish & oparg) ? Py_True : Py_False;\n        }\n\n        // Similar to COMPARE_OP_FLOAT\n        inst(COMPARE_OP_INT, (unused/1, left, right -- res)) {\n            DEOPT_IF(!PyLong_CheckExact(left), COMPARE_OP);\n            DEOPT_IF(!PyLong_CheckExact(right), COMPARE_OP);\n            DEOPT_IF(!_PyLong_IsCompact((PyLongObject *)left), COMPARE_OP);\n            DEOPT_IF(!_PyLong_IsCompact((PyLongObject *)right), COMPARE_OP);\n            STAT_INC(COMPARE_OP, hit);\n            assert(_PyLong_DigitCount((PyLongObject *)left) <= 1 &&\n                   _PyLong_DigitCount((PyLongObject *)right) <= 1);\n            Py_ssize_t ileft = _PyLong_CompactValue((PyLongObject *)left);\n            Py_ssize_t iright = _PyLong_CompactValue((PyLongObject *)right);\n            // 2 if <, 4 if >, 8 if ==; this matches the low 4 bits of the oparg\n            int sign_ish = COMPARISON_BIT(ileft, iright);\n            _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);\n            _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);\n            res = (sign_ish & oparg) ? Py_True : Py_False;\n        }\n\n        // Similar to COMPARE_OP_FLOAT, but for ==, != only\n        inst(COMPARE_OP_STR, (unused/1, left, right -- res)) {\n            DEOPT_IF(!PyUnicode_CheckExact(left), COMPARE_OP);\n            DEOPT_IF(!PyUnicode_CheckExact(right), COMPARE_OP);\n            STAT_INC(COMPARE_OP, hit);\n            int eq = _PyUnicode_Equal(left, right);\n            assert((oparg >>4) == Py_EQ || (oparg >>4) == Py_NE);\n            _Py_DECREF_SPECIALIZED(left, _PyUnicode_ExactDealloc);\n            _Py_DECREF_SPECIALIZED(right, _PyUnicode_ExactDealloc);\n            assert(eq == 0 || eq == 1);\n            assert((oparg & 0xf) == COMPARISON_NOT_EQUALS || (oparg & 0xf) == COMPARISON_EQUALS);\n            assert(COMPARISON_NOT_EQUALS + 1 == COMPARISON_EQUALS);\n            res = ((COMPARISON_NOT_EQUALS + eq) & oparg) ? Py_True : Py_False;\n        }\n\n        inst(IS_OP, (left, right -- b)) {\n            int res = Py_Is(left, right) ^ oparg;\n            DECREF_INPUTS();\n            b = res ? Py_True : Py_False;\n        }\n\n        inst(CONTAINS_OP, (left, right -- b)) {\n            int res = PySequence_Contains(right, left);\n            DECREF_INPUTS();\n            ERROR_IF(res < 0, error);\n            b = (res ^ oparg) ? Py_True : Py_False;\n        }\n\n        inst(CHECK_EG_MATCH, (exc_value, match_type -- rest, match)) {\n            if (check_except_star_type_valid(tstate, match_type) < 0) {\n                DECREF_INPUTS();\n                ERROR_IF(true, error);\n            }\n\n            match = NULL;\n            rest = NULL;\n            int res = exception_group_match(exc_value, match_type,\n                                            &match, &rest);\n            DECREF_INPUTS();\n            ERROR_IF(res < 0, error);\n\n            assert((match == NULL) == (rest == NULL));\n            ERROR_IF(match == NULL, error);\n\n            if (!Py_IsNone(match)) {\n                PyErr_SetHandledException(match);\n            }\n        }\n\n        inst(CHECK_EXC_MATCH, (left, right -- left, b)) {\n            assert(PyExceptionInstance_Check(left));\n            if (check_except_type_valid(tstate, right) < 0) {\n                 DECREF_INPUTS();\n                 ERROR_IF(true, error);\n            }\n\n            int res = PyErr_GivenExceptionMatches(left, right);\n            DECREF_INPUTS();\n            b = res ? Py_True : Py_False;\n        }\n\n         inst(IMPORT_NAME, (level, fromlist -- res)) {\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg);\n            res = import_name(tstate, frame, name, fromlist, level);\n            DECREF_INPUTS();\n            ERROR_IF(res == NULL, error);\n        }\n\n        inst(IMPORT_FROM, (from -- from, res)) {\n            PyObject *name = GETITEM(frame->f_code->co_names, oparg);\n            res = import_from(tstate, from, name);\n            ERROR_IF(res == NULL, error);\n        }\n\n        inst(JUMP_FORWARD, (--)) {\n            JUMPBY(oparg);\n        }\n\n        inst(JUMP_BACKWARD, (--)) {\n            assert(oparg < INSTR_OFFSET());\n            JUMPBY(-oparg);\n            CHECK_EVAL_BREAKER();\n        }\n\n        inst(POP_JUMP_IF_FALSE, (cond -- )) {\n            if (Py_IsFalse(cond)) {\n                JUMPBY(oparg);\n            }\n            else if (!Py_IsTrue(cond)) {\n                int err = PyObject_IsTrue(cond);\n                DECREF_INPUTS();\n                if (err == 0) {\n                    JUMPBY(oparg);\n                }\n                else {\n                    ERROR_IF(err < 0, error);\n                }\n            }\n        }\n\n        inst(POP_JUMP_IF_TRUE, (cond -- )) {\n            if (Py_IsTrue(cond)) {\n                JUMPBY(oparg);\n            }\n            else if (!Py_IsFalse(cond)) {\n                int err = PyObject_IsTrue(cond);\n                DECREF_INPUTS();\n                if (err > 0) {\n                    JUMPBY(oparg);\n                }\n                else {\n                    ERROR_IF(err < 0, error);\n                }\n            }\n        }\n\n        inst(POP_JUMP_IF_NOT_NONE, (value -- )) {\n            if (!Py_IsNone(value)) {\n                DECREF_INPUTS();\n                JUMPBY(oparg);\n            }\n        }\n\n        inst(POP_JUMP_IF_NONE, (value -- )) {\n            if (Py_IsNone(value)) {\n                JUMPBY(oparg);\n            }\n            else {\n                DECREF_INPUTS();\n            }\n        }\n\n        inst(JUMP_BACKWARD_NO_INTERRUPT, (--)) {\n            /* This bytecode is used in the `yield from` or `await` loop.\n             * If there is an interrupt, we want it handled in the innermost\n             * generator or coroutine, so we deliberately do not check it here.\n             * (see bpo-30039).\n             */\n            JUMPBY(-oparg);\n        }\n\n        inst(GET_LEN, (obj -- obj, len_o)) {\n            // PUSH(len(TOS))\n            Py_ssize_t len_i = PyObject_Length(obj);\n            ERROR_IF(len_i < 0, error);\n            len_o = PyLong_FromSsize_t(len_i);\n            ERROR_IF(len_o == NULL, error);\n        }\n\n        inst(MATCH_CLASS, (subject, type, names -- attrs)) {\n            // Pop TOS and TOS1. Set TOS to a tuple of attributes on success, or\n            // None on failure.\n            assert(PyTuple_CheckExact(names));\n            attrs = match_class(tstate, subject, type, oparg, names);\n            DECREF_INPUTS();\n            if (attrs) {\n                assert(PyTuple_CheckExact(attrs));  // Success!\n            }\n            else {\n                ERROR_IF(_PyErr_Occurred(tstate), error);  // Error!\n                attrs = Py_None;  // Failure!\n            }\n        }\n\n        inst(MATCH_MAPPING, (subject -- subject, res)) {\n            int match = Py_TYPE(subject)->tp_flags & Py_TPFLAGS_MAPPING;\n            res = match ? Py_True : Py_False;\n            PREDICT(POP_JUMP_IF_FALSE);\n        }\n\n        inst(MATCH_SEQUENCE, (subject -- subject, res)) {\n            int match = Py_TYPE(subject)->tp_flags & Py_TPFLAGS_SEQUENCE;\n            res = match ? Py_True : Py_False;\n            PREDICT(POP_JUMP_IF_FALSE);\n        }\n\n        inst(MATCH_KEYS, (subject, keys -- subject, keys, values_or_none)) {\n            // On successful match, PUSH(values). Otherwise, PUSH(None).\n            values_or_none = match_keys(tstate, subject, keys);\n            ERROR_IF(values_or_none == NULL, error);\n        }\n\n        inst(GET_ITER, (iterable -- iter)) {\n            /* before: [obj]; after [getiter(obj)] */\n            iter = PyObject_GetIter(iterable);\n            DECREF_INPUTS();\n            ERROR_IF(iter == NULL, error);\n        }\n\n        inst(GET_YIELD_FROM_ITER, (iterable -- iter)) {\n            /* before: [obj]; after [getiter(obj)] */\n            if (PyCoro_CheckExact(iterable)) {\n                /* `iterable` is a coroutine */\n                if (!(frame->f_code->co_flags & (CO_COROUTINE | CO_ITERABLE_COROUTINE))) {\n                    /* and it is used in a 'yield from' expression of a\n                       regular generator. */\n                    _PyErr_SetString(tstate, PyExc_TypeError,\n                                     \"cannot 'yield from' a coroutine object \"\n                                     \"in a non-coroutine generator\");\n                    goto error;\n                }\n                iter = iterable;\n            }\n            else if (PyGen_CheckExact(iterable)) {\n                iter = iterable;\n            }\n            else {\n                /* `iterable` is not a generator. */\n                iter = PyObject_GetIter(iterable);\n                if (iter == NULL) {\n                    goto error;\n                }\n                DECREF_INPUTS();\n            }\n            PREDICT(LOAD_CONST);\n        }\n\n        // Most members of this family are \"secretly\" super-instructions.\n        // When the loop is exhausted, they jump, and the jump target is\n        // always END_FOR, which pops two values off the stack.\n        // This is optimized by skipping that instruction and combining\n        // its effect (popping 'iter' instead of pushing 'next'.)\n\n        family(for_iter, INLINE_CACHE_ENTRIES_FOR_ITER) = {\n            FOR_ITER,\n            FOR_ITER_LIST,\n            FOR_ITER_TUPLE,\n            FOR_ITER_RANGE,\n            FOR_ITER_GEN,\n        };\n\n        inst(FOR_ITER, (unused/1, iter -- iter, next)) {\n            #if ENABLE_SPECIALIZATION\n            _PyForIterCache *cache = (_PyForIterCache *)next_instr;\n            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {\n                next_instr--;\n                _Py_Specialize_ForIter(iter, next_instr, oparg);\n                DISPATCH_SAME_OPARG();\n            }\n            STAT_INC(FOR_ITER, deferred);\n            DECREMENT_ADAPTIVE_COUNTER(cache->counter);\n            #endif  /* ENABLE_SPECIALIZATION */\n            /* before: [iter]; after: [iter, iter()] *or* [] (and jump over END_FOR.) */\n            next = (*Py_TYPE(iter)->tp_iternext)(iter);\n            if (next == NULL) {\n                if (_PyErr_Occurred(tstate)) {\n                    if (!_PyErr_ExceptionMatches(tstate, PyExc_StopIteration)) {\n                        goto error;\n                    }\n                    monitor_raise(tstate, frame, next_instr-1);\n                    _PyErr_Clear(tstate);\n                }\n                /* iterator ended normally */\n                assert(next_instr[INLINE_CACHE_ENTRIES_FOR_ITER + oparg].op.code == END_FOR ||\n                       next_instr[INLINE_CACHE_ENTRIES_FOR_ITER + oparg].op.code == INSTRUMENTED_END_FOR);\n                Py_DECREF(iter);\n                STACK_SHRINK(1);\n                /* Jump forward oparg, then skip following END_FOR instruction */\n                JUMPBY(INLINE_CACHE_ENTRIES_FOR_ITER + oparg + 1);\n                DISPATCH();\n            }\n            // Common case: no jump, leave it to the code generator\n        }\n\n        inst(INSTRUMENTED_FOR_ITER, ( -- )) {\n            _Py_CODEUNIT *here = next_instr-1;\n            _Py_CODEUNIT *target;\n            PyObject *iter = TOP();\n            PyObject *next = (*Py_TYPE(iter)->tp_iternext)(iter);\n            if (next != NULL) {\n                PUSH(next);\n                target = next_instr + INLINE_CACHE_ENTRIES_FOR_ITER;\n            }\n            else {\n                if (_PyErr_Occurred(tstate)) {\n                    if (!_PyErr_ExceptionMatches(tstate, PyExc_StopIteration)) {\n                        goto error;\n                    }\n                    monitor_raise(tstate, frame, here);\n                    _PyErr_Clear(tstate);\n                }\n                /* iterator ended normally */\n                assert(next_instr[INLINE_CACHE_ENTRIES_FOR_ITER + oparg].op.code == END_FOR ||\n                       next_instr[INLINE_CACHE_ENTRIES_FOR_ITER + oparg].op.code == INSTRUMENTED_END_FOR);\n                STACK_SHRINK(1);\n                Py_DECREF(iter);\n                /* Skip END_FOR */\n                target = next_instr + INLINE_CACHE_ENTRIES_FOR_ITER + oparg + 1;\n            }\n            INSTRUMENTED_JUMP(here, target, PY_MONITORING_EVENT_BRANCH);\n        }\n\n        inst(FOR_ITER_LIST, (unused/1, iter -- iter, next)) {\n            DEOPT_IF(Py_TYPE(iter) != &PyListIter_Type, FOR_ITER);\n            _PyListIterObject *it = (_PyListIterObject *)iter;\n            STAT_INC(FOR_ITER, hit);\n            PyListObject *seq = it->it_seq;\n            if (seq) {\n                if (it->it_index < PyList_GET_SIZE(seq)) {\n                    next = Py_NewRef(PyList_GET_ITEM(seq, it->it_index++));\n                    goto end_for_iter_list;  // End of this instruction\n                }\n                it->it_seq = NULL;\n                Py_DECREF(seq);\n            }\n            Py_DECREF(iter);\n            STACK_SHRINK(1);\n            /* Jump forward oparg, then skip following END_FOR instruction */\n            JUMPBY(INLINE_CACHE_ENTRIES_FOR_ITER + oparg + 1);\n            DISPATCH();\n        end_for_iter_list:\n            // Common case: no jump, leave it to the code generator\n        }\n\n        inst(FOR_ITER_TUPLE, (unused/1, iter -- iter, next)) {\n            _PyTupleIterObject *it = (_PyTupleIterObject *)iter;\n            DEOPT_IF(Py_TYPE(it) != &PyTupleIter_Type, FOR_ITER);\n            STAT_INC(FOR_ITER, hit);\n            PyTupleObject *seq = it->it_seq;\n            if (seq) {\n                if (it->it_index < PyTuple_GET_SIZE(seq)) {\n                    next = Py_NewRef(PyTuple_GET_ITEM(seq, it->it_index++));\n                    goto end_for_iter_tuple;  // End of this instruction\n                }\n                it->it_seq = NULL;\n                Py_DECREF(seq);\n            }\n            Py_DECREF(iter);\n            STACK_SHRINK(1);\n            /* Jump forward oparg, then skip following END_FOR instruction */\n            JUMPBY(INLINE_CACHE_ENTRIES_FOR_ITER + oparg + 1);\n            DISPATCH();\n        end_for_iter_tuple:\n            // Common case: no jump, leave it to the code generator\n        }\n\n        inst(FOR_ITER_RANGE, (unused/1, iter -- iter, next)) {\n            _PyRangeIterObject *r = (_PyRangeIterObject *)iter;\n            DEOPT_IF(Py_TYPE(r) != &PyRangeIter_Type, FOR_ITER);\n            STAT_INC(FOR_ITER, hit);\n            if (r->len <= 0) {\n                STACK_SHRINK(1);\n                Py_DECREF(r);\n                // Jump over END_FOR instruction.\n                JUMPBY(INLINE_CACHE_ENTRIES_FOR_ITER + oparg + 1);\n                DISPATCH();\n            }\n            long value = r->start;\n            r->start = value + r->step;\n            r->len--;\n            next = PyLong_FromLong(value);\n            if (next == NULL) {\n                goto error;\n            }\n        }\n\n        inst(FOR_ITER_GEN, (unused/1, iter -- iter, unused)) {\n            DEOPT_IF(tstate->interp->eval_frame, FOR_ITER);\n            PyGenObject *gen = (PyGenObject *)iter;\n            DEOPT_IF(Py_TYPE(gen) != &PyGen_Type, FOR_ITER);\n            DEOPT_IF(gen->gi_frame_state >= FRAME_EXECUTING, FOR_ITER);\n            STAT_INC(FOR_ITER, hit);\n            _PyInterpreterFrame *gen_frame = (_PyInterpreterFrame *)gen->gi_iframe;\n            frame->return_offset = oparg;\n            _PyFrame_StackPush(gen_frame, Py_None);\n            gen->gi_frame_state = FRAME_EXECUTING;\n            gen->gi_exc_state.previous_item = tstate->exc_info;\n            tstate->exc_info = &gen->gi_exc_state;\n            JUMPBY(INLINE_CACHE_ENTRIES_FOR_ITER);\n            assert(next_instr[oparg].op.code == END_FOR ||\n                   next_instr[oparg].op.code == INSTRUMENTED_END_FOR);\n            DISPATCH_INLINED(gen_frame);\n        }\n\n        inst(BEFORE_ASYNC_WITH, (mgr -- exit, res)) {\n            PyObject *enter = _PyObject_LookupSpecial(mgr, &_Py_ID(__aenter__));\n            if (enter == NULL) {\n                if (!_PyErr_Occurred(tstate)) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"'%.200s' object does not support the \"\n                                  \"asynchronous context manager protocol\",\n                                  Py_TYPE(mgr)->tp_name);\n                }\n                goto error;\n            }\n            exit = _PyObject_LookupSpecial(mgr, &_Py_ID(__aexit__));\n            if (exit == NULL) {\n                if (!_PyErr_Occurred(tstate)) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"'%.200s' object does not support the \"\n                                  \"asynchronous context manager protocol \"\n                                  \"(missed __aexit__ method)\",\n                                  Py_TYPE(mgr)->tp_name);\n                }\n                Py_DECREF(enter);\n                goto error;\n            }\n            DECREF_INPUTS();\n            res = _PyObject_CallNoArgs(enter);\n            Py_DECREF(enter);\n            if (res == NULL) {\n                Py_DECREF(exit);\n                ERROR_IF(true, error);\n            }\n            PREDICT(GET_AWAITABLE);\n        }\n\n        inst(BEFORE_WITH, (mgr -- exit, res)) {\n            /* pop the context manager, push its __exit__ and the\n             * value returned from calling its __enter__\n             */\n            PyObject *enter = _PyObject_LookupSpecial(mgr, &_Py_ID(__enter__));\n            if (enter == NULL) {\n                if (!_PyErr_Occurred(tstate)) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"'%.200s' object does not support the \"\n                                  \"context manager protocol\",\n                                  Py_TYPE(mgr)->tp_name);\n                }\n                goto error;\n            }\n            exit = _PyObject_LookupSpecial(mgr, &_Py_ID(__exit__));\n            if (exit == NULL) {\n                if (!_PyErr_Occurred(tstate)) {\n                    _PyErr_Format(tstate, PyExc_TypeError,\n                                  \"'%.200s' object does not support the \"\n                                  \"context manager protocol \"\n                                  \"(missed __exit__ method)\",\n                                  Py_TYPE(mgr)->tp_name);\n                }\n                Py_DECREF(enter);\n                goto error;\n            }\n            DECREF_INPUTS();\n            res = _PyObject_CallNoArgs(enter);\n            Py_DECREF(enter);\n            if (res == NULL) {\n                Py_DECREF(exit);\n                ERROR_IF(true, error);\n            }\n        }\n\n        inst(WITH_EXCEPT_START, (exit_func, lasti, unused, val -- exit_func, lasti, unused, val, res)) {\n            /* At the top of the stack are 4 values:\n               - val: TOP = exc_info()\n               - unused: SECOND = previous exception\n               - lasti: THIRD = lasti of exception in exc_info()\n               - exit_func: FOURTH = the context.__exit__ bound method\n               We call FOURTH(type(TOP), TOP, GetTraceback(TOP)).\n               Then we push the __exit__ return value.\n            */\n            PyObject *exc, *tb;\n\n            assert(val && PyExceptionInstance_Check(val));\n            exc = PyExceptionInstance_Class(val);\n            tb = PyException_GetTraceback(val);\n            if (tb == NULL) {\n                tb = Py_None;\n            }\n            else {\n                Py_DECREF(tb);\n            }\n            assert(PyLong_Check(lasti));\n            (void)lasti; // Shut up compiler warning if asserts are off\n            PyObject *stack[4] = {NULL, exc, val, tb};\n            res = PyObject_Vectorcall(exit_func, stack + 1,\n                    3 | PY_VECTORCALL_ARGUMENTS_OFFSET, NULL);\n            ERROR_IF(res == NULL, error);\n        }\n\n        inst(PUSH_EXC_INFO, (new_exc -- prev_exc, new_exc)) {\n            _PyErr_StackItem *exc_info = tstate->exc_info;\n            if (exc_info->exc_value != NULL) {\n                prev_exc = exc_info->exc_value;\n            }\n            else {\n                prev_exc = Py_None;\n            }\n            assert(PyExceptionInstance_Check(new_exc));\n            exc_info->exc_value = Py_NewRef(new_exc);\n        }\n\n        inst(LOAD_ATTR_METHOD_WITH_VALUES, (unused/1, type_version/2, keys_version/2, descr/4, self -- res2 if (oparg & 1), res)) {\n            /* Cached method object */\n            PyTypeObject *self_cls = Py_TYPE(self);\n            assert(type_version != 0);\n            DEOPT_IF(self_cls->tp_version_tag != type_version, LOAD_ATTR);\n            assert(self_cls->tp_flags & Py_TPFLAGS_MANAGED_DICT);\n            PyDictOrValues dorv = *_PyObject_DictOrValuesPointer(self);\n            DEOPT_IF(!_PyDictOrValues_IsValues(dorv), LOAD_ATTR);\n            PyHeapTypeObject *self_heap_type = (PyHeapTypeObject *)self_cls;\n            DEOPT_IF(self_heap_type->ht_cached_keys->dk_version !=\n                     keys_version, LOAD_ATTR);\n            STAT_INC(LOAD_ATTR, hit);\n            assert(descr != NULL);\n            res2 = Py_NewRef(descr);\n            assert(_PyType_HasFeature(Py_TYPE(res2), Py_TPFLAGS_METHOD_DESCRIPTOR));\n            res = self;\n            assert(oparg & 1);\n        }\n\n        inst(LOAD_ATTR_METHOD_NO_DICT, (unused/1, type_version/2, unused/2, descr/4, self -- res2 if (oparg & 1), res)) {\n            PyTypeObject *self_cls = Py_TYPE(self);\n            DEOPT_IF(self_cls->tp_version_tag != type_version, LOAD_ATTR);\n            assert(self_cls->tp_dictoffset == 0);\n            STAT_INC(LOAD_ATTR, hit);\n            assert(descr != NULL);\n            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));\n            res2 = Py_NewRef(descr);\n            res = self;\n            assert(oparg & 1);\n        }\n\n        inst(LOAD_ATTR_METHOD_LAZY_DICT, (unused/1, type_version/2, unused/2, descr/4, self -- res2 if (oparg & 1), res)) {\n            PyTypeObject *self_cls = Py_TYPE(self);\n            DEOPT_IF(self_cls->tp_version_tag != type_version, LOAD_ATTR);\n            Py_ssize_t dictoffset = self_cls->tp_dictoffset;\n            assert(dictoffset > 0);\n            PyObject *dict = *(PyObject **)((char *)self + dictoffset);\n            /* This object has a __dict__, just not yet created */\n            DEOPT_IF(dict != NULL, LOAD_ATTR);\n            STAT_INC(LOAD_ATTR, hit);\n            assert(descr != NULL);\n            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));\n            res2 = Py_NewRef(descr);\n            res = self;\n            assert(oparg & 1);\n        }\n\n        inst(KW_NAMES, (--)) {\n            assert(kwnames == NULL);\n            assert(oparg < PyTuple_GET_SIZE(frame->f_code->co_consts));\n            kwnames = GETITEM(frame->f_code->co_consts, oparg);\n        }\n\n        inst(INSTRUMENTED_CALL, ( -- )) {\n            int is_meth = PEEK(oparg+2) != NULL;\n            int total_args = oparg + is_meth;\n            PyObject *function = PEEK(total_args + 1);\n            PyObject *arg = total_args == 0 ?\n                &_PyInstrumentation_MISSING : PEEK(total_args);\n            int err = _Py_call_instrumentation_2args(\n                    tstate, PY_MONITORING_EVENT_CALL,\n                    frame, next_instr-1, function, arg);\n            ERROR_IF(err, error);\n            _PyCallCache *cache = (_PyCallCache *)next_instr;\n            INCREMENT_ADAPTIVE_COUNTER(cache->counter);\n            GO_TO_INSTRUCTION(CALL);\n        }\n\n        // Cache layout: counter/1, func_version/2\n        // Neither CALL_INTRINSIC_1/2 nor CALL_FUNCTION_EX are members!\n        family(call, INLINE_CACHE_ENTRIES_CALL) = {\n            CALL,\n            CALL_BOUND_METHOD_EXACT_ARGS,\n            CALL_PY_EXACT_ARGS,\n            CALL_PY_WITH_DEFAULTS,\n            CALL_NO_KW_TYPE_1,\n            CALL_NO_KW_STR_1,\n            CALL_NO_KW_TUPLE_1,\n            CALL_BUILTIN_CLASS,\n            CALL_NO_KW_BUILTIN_O,\n            CALL_NO_KW_BUILTIN_FAST,\n            CALL_BUILTIN_FAST_WITH_KEYWORDS,\n            CALL_NO_KW_LEN,\n            CALL_NO_KW_ISINSTANCE,\n            CALL_NO_KW_LIST_APPEND,\n            CALL_NO_KW_METHOD_DESCRIPTOR_O,\n            CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS,\n            CALL_NO_KW_METHOD_DESCRIPTOR_NOARGS,\n            CALL_NO_KW_METHOD_DESCRIPTOR_FAST,\n        };\n\n        // On entry, the stack is either\n        //   [NULL, callable, arg1, arg2, ...]\n        // or\n        //   [method, self, arg1, arg2, ...]\n        // (Some args may be keywords, see KW_NAMES, which sets 'kwnames'.)\n        // On exit, the stack is [result].\n        // When calling Python, inline the call using DISPATCH_INLINED().\n        inst(CALL, (unused/1, unused/2, method, callable, args[oparg] -- res)) {\n            int is_meth = method != NULL;\n            int total_args = oparg;\n            if (is_meth) {\n                callable = method;\n                args--;\n                total_args++;\n            }\n            #if ENABLE_SPECIALIZATION\n            _PyCallCache *cache = (_PyCallCache *)next_instr;\n            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {\n                next_instr--;\n                _Py_Specialize_Call(callable, next_instr, total_args, kwnames);\n                DISPATCH_SAME_OPARG();\n            }\n            STAT_INC(CALL, deferred);\n            DECREMENT_ADAPTIVE_COUNTER(cache->counter);\n            #endif  /* ENABLE_SPECIALIZATION */\n            if (!is_meth && Py_TYPE(callable) == &PyMethod_Type) {\n                is_meth = 1;  // For consistenct; it's dead, though\n                args--;\n                total_args++;\n                PyObject *self = ((PyMethodObject *)callable)->im_self;\n                args[0] = Py_NewRef(self);\n                method = ((PyMethodObject *)callable)->im_func;\n                args[-1] = Py_NewRef(method);\n                Py_DECREF(callable);\n                callable = method;\n            }\n            int positional_args = total_args - KWNAMES_LEN();\n            // Check if the call can be inlined or not\n            if (Py_TYPE(callable) == &PyFunction_Type &&\n                tstate->interp->eval_frame == NULL &&\n                ((PyFunctionObject *)callable)->vectorcall == _PyFunction_Vectorcall)\n            {\n                int code_flags = ((PyCodeObject*)PyFunction_GET_CODE(callable))->co_flags;\n                PyObject *locals = code_flags & CO_OPTIMIZED ? NULL : Py_NewRef(PyFunction_GET_GLOBALS(callable));\n                _PyInterpreterFrame *new_frame = _PyEvalFramePushAndInit(\n                    tstate, (PyFunctionObject *)callable, locals,\n                    args, positional_args, kwnames\n                );\n                kwnames = NULL;\n                // Manipulate stack directly since we leave using DISPATCH_INLINED().\n                STACK_SHRINK(oparg + 2);\n                // The frame has stolen all the arguments from the stack,\n                // so there is no need to clean them up.\n                if (new_frame == NULL) {\n                    goto error;\n                }\n                JUMPBY(INLINE_CACHE_ENTRIES_CALL);\n                frame->return_offset = 0;\n                DISPATCH_INLINED(new_frame);\n            }\n            /* Callable is not a normal Python function */\n            res = PyObject_Vectorcall(\n                callable, args,\n                positional_args | PY_VECTORCALL_ARGUMENTS_OFFSET,\n                kwnames);\n            if (opcode == INSTRUMENTED_CALL) {\n                PyObject *arg = total_args == 0 ?\n                    &_PyInstrumentation_MISSING : PEEK(total_args);\n                if (res == NULL) {\n                    _Py_call_instrumentation_exc2(\n                        tstate, PY_MONITORING_EVENT_C_RAISE,\n                        frame, next_instr-1, callable, arg);\n                }\n                else {\n                    int err = _Py_call_instrumentation_2args(\n                        tstate, PY_MONITORING_EVENT_C_RETURN,\n                        frame, next_instr-1, callable, arg);\n                    if (err < 0) {\n                        Py_CLEAR(res);\n                    }\n                }\n            }\n            kwnames = NULL;\n            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n            Py_DECREF(callable);\n            for (int i = 0; i < total_args; i++) {\n                Py_DECREF(args[i]);\n            }\n            ERROR_IF(res == NULL, error);\n            CHECK_EVAL_BREAKER();\n        }\n\n        // Start out with [NULL, bound_method, arg1, arg2, ...]\n        // Transform to [callable, self, arg1, arg2, ...]\n        // Then fall through to CALL_PY_EXACT_ARGS\n        inst(CALL_BOUND_METHOD_EXACT_ARGS, (unused/1, unused/2, method, callable, unused[oparg] -- unused)) {\n            DEOPT_IF(method != NULL, CALL);\n            DEOPT_IF(Py_TYPE(callable) != &PyMethod_Type, CALL);\n            STAT_INC(CALL, hit);\n            PyObject *self = ((PyMethodObject *)callable)->im_self;\n            PEEK(oparg + 1) = Py_NewRef(self);  // callable\n            PyObject *meth = ((PyMethodObject *)callable)->im_func;\n            PEEK(oparg + 2) = Py_NewRef(meth);  // method\n            Py_DECREF(callable);\n            GO_TO_INSTRUCTION(CALL_PY_EXACT_ARGS);\n        }\n\n        inst(CALL_PY_EXACT_ARGS, (unused/1, func_version/2, method, callable, args[oparg] -- unused)) {\n            assert(kwnames == NULL);\n            DEOPT_IF(tstate->interp->eval_frame, CALL);\n            int is_meth = method != NULL;\n            int argcount = oparg;\n            if (is_meth) {\n                callable = method;\n                args--;\n                argcount++;\n            }\n            DEOPT_IF(!PyFunction_Check(callable), CALL);\n            PyFunctionObject *func = (PyFunctionObject *)callable;\n            DEOPT_IF(func->func_version != func_version, CALL);\n            PyCodeObject *code = (PyCodeObject *)func->func_code;\n            DEOPT_IF(code->co_argcount != argcount, CALL);\n            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), CALL);\n            STAT_INC(CALL, hit);\n            _PyInterpreterFrame *new_frame = _PyFrame_PushUnchecked(tstate, func, argcount);\n            for (int i = 0; i < argcount; i++) {\n                new_frame->localsplus[i] = args[i];\n            }\n            // Manipulate stack directly since we leave using DISPATCH_INLINED().\n            STACK_SHRINK(oparg + 2);\n            JUMPBY(INLINE_CACHE_ENTRIES_CALL);\n            frame->return_offset = 0;\n            DISPATCH_INLINED(new_frame);\n        }\n\n        inst(CALL_PY_WITH_DEFAULTS, (unused/1, func_version/2, method, callable, args[oparg] -- unused)) {\n            assert(kwnames == NULL);\n            DEOPT_IF(tstate->interp->eval_frame, CALL);\n            int is_meth = method != NULL;\n            int argcount = oparg;\n            if (is_meth) {\n                callable = method;\n                args--;\n                argcount++;\n            }\n            DEOPT_IF(!PyFunction_Check(callable), CALL);\n            PyFunctionObject *func = (PyFunctionObject *)callable;\n            DEOPT_IF(func->func_version != func_version, CALL);\n            PyCodeObject *code = (PyCodeObject *)func->func_code;\n            assert(func->func_defaults);\n            assert(PyTuple_CheckExact(func->func_defaults));\n            int defcount = (int)PyTuple_GET_SIZE(func->func_defaults);\n            assert(defcount <= code->co_argcount);\n            int min_args = code->co_argcount - defcount;\n            DEOPT_IF(argcount > code->co_argcount, CALL);\n            DEOPT_IF(argcount < min_args, CALL);\n            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), CALL);\n            STAT_INC(CALL, hit);\n            _PyInterpreterFrame *new_frame = _PyFrame_PushUnchecked(tstate, func, code->co_argcount);\n            for (int i = 0; i < argcount; i++) {\n                new_frame->localsplus[i] = args[i];\n            }\n            for (int i = argcount; i < code->co_argcount; i++) {\n                PyObject *def = PyTuple_GET_ITEM(func->func_defaults, i - min_args);\n                new_frame->localsplus[i] = Py_NewRef(def);\n            }\n            // Manipulate stack and cache directly since we leave using DISPATCH_INLINED().\n            STACK_SHRINK(oparg + 2);\n            JUMPBY(INLINE_CACHE_ENTRIES_CALL);\n            frame->return_offset = 0;\n            DISPATCH_INLINED(new_frame);\n        }\n\n        inst(CALL_NO_KW_TYPE_1, (unused/1, unused/2, null, callable, args[oparg] -- res)) {\n            assert(kwnames == NULL);\n            assert(oparg == 1);\n            DEOPT_IF(null != NULL, CALL);\n            PyObject *obj = args[0];\n            DEOPT_IF(callable != (PyObject *)&PyType_Type, CALL);\n            STAT_INC(CALL, hit);\n            res = Py_NewRef(Py_TYPE(obj));\n            Py_DECREF(obj);\n            Py_DECREF(&PyType_Type);  // I.e., callable\n        }\n\n        inst(CALL_NO_KW_STR_1, (unused/1, unused/2, null, callable, args[oparg] -- res)) {\n            assert(kwnames == NULL);\n            assert(oparg == 1);\n            DEOPT_IF(null != NULL, CALL);\n            DEOPT_IF(callable != (PyObject *)&PyUnicode_Type, CALL);\n            STAT_INC(CALL, hit);\n            PyObject *arg = args[0];\n            res = PyObject_Str(arg);\n            Py_DECREF(arg);\n            Py_DECREF(&PyUnicode_Type);  // I.e., callable\n            ERROR_IF(res == NULL, error);\n            CHECK_EVAL_BREAKER();\n        }\n\n        inst(CALL_NO_KW_TUPLE_1, (unused/1, unused/2, null, callable, args[oparg] -- res)) {\n            assert(kwnames == NULL);\n            assert(oparg == 1);\n            DEOPT_IF(null != NULL, CALL);\n            DEOPT_IF(callable != (PyObject *)&PyTuple_Type, CALL);\n            STAT_INC(CALL, hit);\n            PyObject *arg = args[0];\n            res = PySequence_Tuple(arg);\n            Py_DECREF(arg);\n            Py_DECREF(&PyTuple_Type);  // I.e., tuple\n            ERROR_IF(res == NULL, error);\n            CHECK_EVAL_BREAKER();\n        }\n\n        inst(CALL_BUILTIN_CLASS, (unused/1, unused/2, method, callable, args[oparg] -- res)) {\n            int is_meth = method != NULL;\n            int total_args = oparg;\n            if (is_meth) {\n                callable = method;\n                args--;\n                total_args++;\n            }\n            int kwnames_len = KWNAMES_LEN();\n            DEOPT_IF(!PyType_Check(callable), CALL);\n            PyTypeObject *tp = (PyTypeObject *)callable;\n            DEOPT_IF(tp->tp_vectorcall == NULL, CALL);\n            STAT_INC(CALL, hit);\n            res = tp->tp_vectorcall((PyObject *)tp, args,\n                                    total_args - kwnames_len, kwnames);\n            kwnames = NULL;\n            /* Free the arguments. */\n            for (int i = 0; i < total_args; i++) {\n                Py_DECREF(args[i]);\n            }\n            Py_DECREF(tp);\n            ERROR_IF(res == NULL, error);\n            CHECK_EVAL_BREAKER();\n        }\n\n        inst(CALL_NO_KW_BUILTIN_O, (unused/1, unused/2, method, callable, args[oparg] -- res)) {\n            /* Builtin METH_O functions */\n            assert(kwnames == NULL);\n            int is_meth = method != NULL;\n            int total_args = oparg;\n            if (is_meth) {\n                callable = method;\n                args--;\n                total_args++;\n            }\n            DEOPT_IF(total_args != 1, CALL);\n            DEOPT_IF(!PyCFunction_CheckExact(callable), CALL);\n            DEOPT_IF(PyCFunction_GET_FLAGS(callable) != METH_O, CALL);\n            STAT_INC(CALL, hit);\n            PyCFunction cfunc = PyCFunction_GET_FUNCTION(callable);\n            // This is slower but CPython promises to check all non-vectorcall\n            // function calls.\n            if (_Py_EnterRecursiveCallTstate(tstate, \" while calling a Python object\")) {\n                goto error;\n            }\n            PyObject *arg = args[0];\n            res = _PyCFunction_TrampolineCall(cfunc, PyCFunction_GET_SELF(callable), arg);\n            _Py_LeaveRecursiveCallTstate(tstate);\n            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n\n            Py_DECREF(arg);\n            Py_DECREF(callable);\n            ERROR_IF(res == NULL, error);\n            CHECK_EVAL_BREAKER();\n        }\n\n        inst(CALL_NO_KW_BUILTIN_FAST, (unused/1, unused/2, method, callable, args[oparg] -- res)) {\n            /* Builtin METH_FASTCALL functions, without keywords */\n            assert(kwnames == NULL);\n            int is_meth = method != NULL;\n            int total_args = oparg;\n            if (is_meth) {\n                callable = method;\n                args--;\n                total_args++;\n            }\n            DEOPT_IF(!PyCFunction_CheckExact(callable), CALL);\n            DEOPT_IF(PyCFunction_GET_FLAGS(callable) != METH_FASTCALL, CALL);\n            STAT_INC(CALL, hit);\n            PyCFunction cfunc = PyCFunction_GET_FUNCTION(callable);\n            /* res = func(self, args, nargs) */\n            res = ((_PyCFunctionFast)(void(*)(void))cfunc)(\n                PyCFunction_GET_SELF(callable),\n                args,\n                total_args);\n            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n\n            /* Free the arguments. */\n            for (int i = 0; i < total_args; i++) {\n                Py_DECREF(args[i]);\n            }\n            Py_DECREF(callable);\n            ERROR_IF(res == NULL, error);\n                /* Not deopting because this doesn't mean our optimization was\n                   wrong. `res` can be NULL for valid reasons. Eg. getattr(x,\n                   'invalid'). In those cases an exception is set, so we must\n                   handle it.\n                */\n            CHECK_EVAL_BREAKER();\n        }\n\n        inst(CALL_BUILTIN_FAST_WITH_KEYWORDS, (unused/1, unused/2, method, callable, args[oparg] -- res)) {\n            /* Builtin METH_FASTCALL | METH_KEYWORDS functions */\n            int is_meth = method != NULL;\n            int total_args = oparg;\n            if (is_meth) {\n                callable = method;\n                args--;\n                total_args++;\n            }\n            DEOPT_IF(!PyCFunction_CheckExact(callable), CALL);\n            DEOPT_IF(PyCFunction_GET_FLAGS(callable) !=\n                (METH_FASTCALL | METH_KEYWORDS), CALL);\n            STAT_INC(CALL, hit);\n            /* res = func(self, args, nargs, kwnames) */\n            _PyCFunctionFastWithKeywords cfunc =\n                (_PyCFunctionFastWithKeywords)(void(*)(void))\n                PyCFunction_GET_FUNCTION(callable);\n            res = cfunc(\n                PyCFunction_GET_SELF(callable),\n                args,\n                total_args - KWNAMES_LEN(),\n                kwnames\n            );\n            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n            kwnames = NULL;\n\n            /* Free the arguments. */\n            for (int i = 0; i < total_args; i++) {\n                Py_DECREF(args[i]);\n            }\n            Py_DECREF(callable);\n            ERROR_IF(res == NULL, error);\n            CHECK_EVAL_BREAKER();\n        }\n\n        inst(CALL_NO_KW_LEN, (unused/1, unused/2, method, callable, args[oparg] -- res)) {\n            assert(kwnames == NULL);\n            /* len(o) */\n            int is_meth = method != NULL;\n            int total_args = oparg;\n            if (is_meth) {\n                callable = method;\n                args--;\n                total_args++;\n            }\n            DEOPT_IF(total_args != 1, CALL);\n            PyInterpreterState *interp = _PyInterpreterState_GET();\n            DEOPT_IF(callable != interp->callable_cache.len, CALL);\n            STAT_INC(CALL, hit);\n            PyObject *arg = args[0];\n            Py_ssize_t len_i = PyObject_Length(arg);\n            if (len_i < 0) {\n                goto error;\n            }\n            res = PyLong_FromSsize_t(len_i);\n            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n\n            Py_DECREF(callable);\n            Py_DECREF(arg);\n            ERROR_IF(res == NULL, error);\n        }\n\n        inst(CALL_NO_KW_ISINSTANCE, (unused/1, unused/2, method, callable, args[oparg] -- res)) {\n            assert(kwnames == NULL);\n            /* isinstance(o, o2) */\n            int is_meth = method != NULL;\n            int total_args = oparg;\n            if (is_meth) {\n                callable = method;\n                args--;\n                total_args++;\n            }\n            DEOPT_IF(total_args != 2, CALL);\n            PyInterpreterState *interp = _PyInterpreterState_GET();\n            DEOPT_IF(callable != interp->callable_cache.isinstance, CALL);\n            STAT_INC(CALL, hit);\n            PyObject *cls = args[1];\n            PyObject *inst = args[0];\n            int retval = PyObject_IsInstance(inst, cls);\n            if (retval < 0) {\n                goto error;\n            }\n            res = PyBool_FromLong(retval);\n            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n\n            Py_DECREF(inst);\n            Py_DECREF(cls);\n            Py_DECREF(callable);\n            ERROR_IF(res == NULL, error);\n        }\n\n        // This is secretly a super-instruction\n        inst(CALL_NO_KW_LIST_APPEND, (unused/1, unused/2, method, self, args[oparg] -- unused)) {\n            assert(kwnames == NULL);\n            assert(oparg == 1);\n            PyInterpreterState *interp = _PyInterpreterState_GET();\n            DEOPT_IF(method != interp->callable_cache.list_append, CALL);\n            assert(self != NULL);\n            DEOPT_IF(!PyList_Check(self), CALL);\n            STAT_INC(CALL, hit);\n            if (_PyList_AppendTakeRef((PyListObject *)self, args[0]) < 0) {\n                goto pop_1_error;  // Since arg is DECREF'ed already\n            }\n            Py_DECREF(self);\n            Py_DECREF(method);\n            STACK_SHRINK(3);\n            // CALL + POP_TOP\n            JUMPBY(INLINE_CACHE_ENTRIES_CALL + 1);\n            assert(next_instr[-1].op.code == POP_TOP);\n            DISPATCH();\n        }\n\n        inst(CALL_NO_KW_METHOD_DESCRIPTOR_O, (unused/1, unused/2, method, unused, args[oparg] -- res)) {\n            assert(kwnames == NULL);\n            int is_meth = method != NULL;\n            int total_args = oparg;\n            if (is_meth) {\n                args--;\n                total_args++;\n            }\n            PyMethodDescrObject *callable =\n                (PyMethodDescrObject *)PEEK(total_args + 1);\n            DEOPT_IF(total_args != 2, CALL);\n            DEOPT_IF(!Py_IS_TYPE(callable, &PyMethodDescr_Type), CALL);\n            PyMethodDef *meth = callable->d_method;\n            DEOPT_IF(meth->ml_flags != METH_O, CALL);\n            PyObject *arg = args[1];\n            PyObject *self = args[0];\n            DEOPT_IF(!Py_IS_TYPE(self, callable->d_common.d_type), CALL);\n            STAT_INC(CALL, hit);\n            PyCFunction cfunc = meth->ml_meth;\n            // This is slower but CPython promises to check all non-vectorcall\n            // function calls.\n            if (_Py_EnterRecursiveCallTstate(tstate, \" while calling a Python object\")) {\n                goto error;\n            }\n            res = _PyCFunction_TrampolineCall(cfunc, self, arg);\n            _Py_LeaveRecursiveCallTstate(tstate);\n            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n            Py_DECREF(self);\n            Py_DECREF(arg);\n            Py_DECREF(callable);\n            ERROR_IF(res == NULL, error);\n            CHECK_EVAL_BREAKER();\n        }\n\n        inst(CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS, (unused/1, unused/2, method, unused, args[oparg] -- res)) {\n            int is_meth = method != NULL;\n            int total_args = oparg;\n            if (is_meth) {\n                args--;\n                total_args++;\n            }\n            PyMethodDescrObject *callable =\n                (PyMethodDescrObject *)PEEK(total_args + 1);\n            DEOPT_IF(!Py_IS_TYPE(callable, &PyMethodDescr_Type), CALL);\n            PyMethodDef *meth = callable->d_method;\n            DEOPT_IF(meth->ml_flags != (METH_FASTCALL|METH_KEYWORDS), CALL);\n            PyTypeObject *d_type = callable->d_common.d_type;\n            PyObject *self = args[0];\n            DEOPT_IF(!Py_IS_TYPE(self, d_type), CALL);\n            STAT_INC(CALL, hit);\n            int nargs = total_args - 1;\n            _PyCFunctionFastWithKeywords cfunc =\n                (_PyCFunctionFastWithKeywords)(void(*)(void))meth->ml_meth;\n            res = cfunc(self, args + 1, nargs - KWNAMES_LEN(), kwnames);\n            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n            kwnames = NULL;\n\n            /* Free the arguments. */\n            for (int i = 0; i < total_args; i++) {\n                Py_DECREF(args[i]);\n            }\n            Py_DECREF(callable);\n            ERROR_IF(res == NULL, error);\n            CHECK_EVAL_BREAKER();\n        }\n\n        inst(CALL_NO_KW_METHOD_DESCRIPTOR_NOARGS, (unused/1, unused/2, method, unused, args[oparg] -- res)) {\n            assert(kwnames == NULL);\n            assert(oparg == 0 || oparg == 1);\n            int is_meth = method != NULL;\n            int total_args = oparg;\n            if (is_meth) {\n                args--;\n                total_args++;\n            }\n            DEOPT_IF(total_args != 1, CALL);\n            PyMethodDescrObject *callable = (PyMethodDescrObject *)SECOND();\n            DEOPT_IF(!Py_IS_TYPE(callable, &PyMethodDescr_Type), CALL);\n            PyMethodDef *meth = callable->d_method;\n            PyObject *self = args[0];\n            DEOPT_IF(!Py_IS_TYPE(self, callable->d_common.d_type), CALL);\n            DEOPT_IF(meth->ml_flags != METH_NOARGS, CALL);\n            STAT_INC(CALL, hit);\n            PyCFunction cfunc = meth->ml_meth;\n            // This is slower but CPython promises to check all non-vectorcall\n            // function calls.\n            if (_Py_EnterRecursiveCallTstate(tstate, \" while calling a Python object\")) {\n                goto error;\n            }\n            res = _PyCFunction_TrampolineCall(cfunc, self, NULL);\n            _Py_LeaveRecursiveCallTstate(tstate);\n            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n            Py_DECREF(self);\n            Py_DECREF(callable);\n            ERROR_IF(res == NULL, error);\n            CHECK_EVAL_BREAKER();\n        }\n\n        inst(CALL_NO_KW_METHOD_DESCRIPTOR_FAST, (unused/1, unused/2, method, unused, args[oparg] -- res)) {\n            assert(kwnames == NULL);\n            int is_meth = method != NULL;\n            int total_args = oparg;\n            if (is_meth) {\n                args--;\n                total_args++;\n            }\n            PyMethodDescrObject *callable =\n                (PyMethodDescrObject *)PEEK(total_args + 1);\n            /* Builtin METH_FASTCALL methods, without keywords */\n            DEOPT_IF(!Py_IS_TYPE(callable, &PyMethodDescr_Type), CALL);\n            PyMethodDef *meth = callable->d_method;\n            DEOPT_IF(meth->ml_flags != METH_FASTCALL, CALL);\n            PyObject *self = args[0];\n            DEOPT_IF(!Py_IS_TYPE(self, callable->d_common.d_type), CALL);\n            STAT_INC(CALL, hit);\n            _PyCFunctionFast cfunc =\n                (_PyCFunctionFast)(void(*)(void))meth->ml_meth;\n            int nargs = total_args - 1;\n            res = cfunc(self, args + 1, nargs);\n            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));\n            /* Clear the stack of the arguments. */\n            for (int i = 0; i < total_args; i++) {\n                Py_DECREF(args[i]);\n            }\n            Py_DECREF(callable);\n            ERROR_IF(res == NULL, error);\n            CHECK_EVAL_BREAKER();\n        }\n\n        inst(INSTRUMENTED_CALL_FUNCTION_EX, ( -- )) {\n            GO_TO_INSTRUCTION(CALL_FUNCTION_EX);\n        }\n\n        inst(CALL_FUNCTION_EX, (unused, func, callargs, kwargs if (oparg & 1) -- result)) {\n            // DICT_MERGE is called before this opcode if there are kwargs.\n            // It converts all dict subtypes in kwargs into regular dicts.\n            assert(kwargs == NULL || PyDict_CheckExact(kwargs));\n            if (!PyTuple_CheckExact(callargs)) {\n                if (check_args_iterable(tstate, func, callargs) < 0) {\n                    goto error;\n                }\n                PyObject *tuple = PySequence_Tuple(callargs);\n                if (tuple == NULL) {\n                    goto error;\n                }\n                Py_SETREF(callargs, tuple);\n            }\n            assert(PyTuple_CheckExact(callargs));\n            EVAL_CALL_STAT_INC_IF_FUNCTION(EVAL_CALL_FUNCTION_EX, func);\n            if (opcode == INSTRUMENTED_CALL_FUNCTION_EX) {\n                PyObject *arg = PyTuple_GET_SIZE(callargs) > 0 ?\n                    PyTuple_GET_ITEM(callargs, 0) : &_PyInstrumentation_MISSING;\n                int err = _Py_call_instrumentation_2args(\n                    tstate, PY_MONITORING_EVENT_CALL,\n                    frame, next_instr-1, func, arg);\n                if (err) goto error;\n                result = PyObject_Call(func, callargs, kwargs);\n                if (!PyFunction_Check(func) && !PyMethod_Check(func)) {\n                    if (result == NULL) {\n                        _Py_call_instrumentation_exc2(\n                            tstate, PY_MONITORING_EVENT_C_RAISE,\n                            frame, next_instr-1, func, arg);\n                    }\n                    else {\n                        int err = _Py_call_instrumentation_2args(\n                            tstate, PY_MONITORING_EVENT_C_RETURN,\n                            frame, next_instr-1, func, arg);\n                        if (err < 0) {\n                            Py_CLEAR(result);\n                        }\n                    }\n                }\n            }\n            else {\n                if (Py_TYPE(func) == &PyFunction_Type &&\n                    tstate->interp->eval_frame == NULL &&\n                    ((PyFunctionObject *)func)->vectorcall == _PyFunction_Vectorcall) {\n                    assert(PyTuple_CheckExact(callargs));\n                    Py_ssize_t nargs = PyTuple_GET_SIZE(callargs);\n                    int code_flags = ((PyCodeObject *)PyFunction_GET_CODE(func))->co_flags;\n                    PyObject *locals = code_flags & CO_OPTIMIZED ? NULL : Py_NewRef(PyFunction_GET_GLOBALS(func));\n\n                    _PyInterpreterFrame *new_frame = _PyEvalFramePushAndInit_Ex(tstate,\n                                                                                (PyFunctionObject *)func, locals,\n                                                                                nargs, callargs, kwargs);\n                    // Need to manually shrink the stack since we exit with DISPATCH_INLINED.\n                    STACK_SHRINK(oparg + 3);\n                    if (new_frame == NULL) {\n                        goto error;\n                    }\n                    frame->return_offset = 0;\n                    DISPATCH_INLINED(new_frame);\n                }\n                result = PyObject_Call(func, callargs, kwargs);\n            }\n            DECREF_INPUTS();\n            assert(PEEK(3 + (oparg & 1)) == NULL);\n            ERROR_IF(result == NULL, error);\n            CHECK_EVAL_BREAKER();\n        }\n\n        inst(MAKE_FUNCTION, (defaults    if (oparg & 0x01),\n                             kwdefaults  if (oparg & 0x02),\n                             annotations if (oparg & 0x04),\n                             closure     if (oparg & 0x08),\n                             codeobj -- func)) {\n\n            PyFunctionObject *func_obj = (PyFunctionObject *)\n                PyFunction_New(codeobj, GLOBALS());\n\n            Py_DECREF(codeobj);\n            if (func_obj == NULL) {\n                goto error;\n            }\n\n            if (oparg & 0x08) {\n                assert(PyTuple_CheckExact(closure));\n                func_obj->func_closure = closure;\n            }\n            if (oparg & 0x04) {\n                assert(PyTuple_CheckExact(annotations));\n                func_obj->func_annotations = annotations;\n            }\n            if (oparg & 0x02) {\n                assert(PyDict_CheckExact(kwdefaults));\n                func_obj->func_kwdefaults = kwdefaults;\n            }\n            if (oparg & 0x01) {\n                assert(PyTuple_CheckExact(defaults));\n                func_obj->func_defaults = defaults;\n            }\n\n            func_obj->func_version = ((PyCodeObject *)codeobj)->co_version;\n            func = (PyObject *)func_obj;\n        }\n\n        inst(RETURN_GENERATOR, (--)) {\n            assert(PyFunction_Check(frame->f_funcobj));\n            PyFunctionObject *func = (PyFunctionObject *)frame->f_funcobj;\n            PyGenObject *gen = (PyGenObject *)_Py_MakeCoro(func);\n            if (gen == NULL) {\n                goto error;\n            }\n            assert(EMPTY());\n            _PyFrame_SetStackPointer(frame, stack_pointer);\n            _PyInterpreterFrame *gen_frame = (_PyInterpreterFrame *)gen->gi_iframe;\n            _PyFrame_Copy(frame, gen_frame);\n            assert(frame->frame_obj == NULL);\n            gen->gi_frame_state = FRAME_CREATED;\n            gen_frame->owner = FRAME_OWNED_BY_GENERATOR;\n            _Py_LeaveRecursiveCallPy(tstate);\n            assert(frame != &entry_frame);\n            _PyInterpreterFrame *prev = frame->previous;\n            _PyThreadState_PopFrame(tstate, frame);\n            frame = cframe.current_frame = prev;\n            _PyFrame_StackPush(frame, (PyObject *)gen);\n            goto resume_frame;\n        }\n\n        inst(BUILD_SLICE, (start, stop, step if (oparg == 3) -- slice)) {\n            slice = PySlice_New(start, stop, step);\n            DECREF_INPUTS();\n            ERROR_IF(slice == NULL, error);\n        }\n\n        inst(FORMAT_VALUE, (value, fmt_spec if ((oparg & FVS_MASK) == FVS_HAVE_SPEC) -- result)) {\n            /* Handles f-string value formatting. */\n            PyObject *(*conv_fn)(PyObject *);\n            int which_conversion = oparg & FVC_MASK;\n\n            /* See if any conversion is specified. */\n            switch (which_conversion) {\n            case FVC_NONE:  conv_fn = NULL;           break;\n            case FVC_STR:   conv_fn = PyObject_Str;   break;\n            case FVC_REPR:  conv_fn = PyObject_Repr;  break;\n            case FVC_ASCII: conv_fn = PyObject_ASCII; break;\n            default:\n                _PyErr_Format(tstate, PyExc_SystemError,\n                              \"unexpected conversion flag %d\",\n                              which_conversion);\n                goto error;\n            }\n\n            /* If there's a conversion function, call it and replace\n               value with that result. Otherwise, just use value,\n               without conversion. */\n            if (conv_fn != NULL) {\n                result = conv_fn(value);\n                Py_DECREF(value);\n                if (result == NULL) {\n                    Py_XDECREF(fmt_spec);\n                    ERROR_IF(true, error);\n                }\n                value = result;\n            }\n\n            result = PyObject_Format(value, fmt_spec);\n            Py_DECREF(value);\n            Py_XDECREF(fmt_spec);\n            ERROR_IF(result == NULL, error);\n        }\n\n        inst(COPY, (bottom, unused[oparg-1] -- bottom, unused[oparg-1], top)) {\n            assert(oparg > 0);\n            top = Py_NewRef(bottom);\n        }\n\n        inst(BINARY_OP, (unused/1, lhs, rhs -- res)) {\n            #if ENABLE_SPECIALIZATION\n            _PyBinaryOpCache *cache = (_PyBinaryOpCache *)next_instr;\n            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {\n                next_instr--;\n                _Py_Specialize_BinaryOp(lhs, rhs, next_instr, oparg, &GETLOCAL(0));\n                DISPATCH_SAME_OPARG();\n            }\n            STAT_INC(BINARY_OP, deferred);\n            DECREMENT_ADAPTIVE_COUNTER(cache->counter);\n            #endif  /* ENABLE_SPECIALIZATION */\n            assert(0 <= oparg);\n            assert((unsigned)oparg < Py_ARRAY_LENGTH(binary_ops));\n            assert(binary_ops[oparg]);\n            res = binary_ops[oparg](lhs, rhs);\n            DECREF_INPUTS();\n            ERROR_IF(res == NULL, error);\n        }\n\n        inst(SWAP, (bottom, unused[oparg-2], top --\n                    top, unused[oparg-2], bottom)) {\n            assert(oparg >= 2);\n        }\n\n        inst(INSTRUMENTED_INSTRUCTION, ( -- )) {\n            int next_opcode = _Py_call_instrumentation_instruction(\n                tstate, frame, next_instr-1);\n            ERROR_IF(next_opcode < 0, error);\n            next_instr--;\n            if (_PyOpcode_Caches[next_opcode]) {\n                _PyBinaryOpCache *cache = (_PyBinaryOpCache *)(next_instr+1);\n                INCREMENT_ADAPTIVE_COUNTER(cache->counter);\n            }\n            assert(next_opcode > 0 && next_opcode < 256);\n            opcode = next_opcode;\n            DISPATCH_GOTO();\n        }\n\n        inst(INSTRUMENTED_JUMP_FORWARD, ( -- )) {\n            INSTRUMENTED_JUMP(next_instr-1, next_instr+oparg, PY_MONITORING_EVENT_JUMP);\n        }\n\n        inst(INSTRUMENTED_JUMP_BACKWARD, ( -- )) {\n            INSTRUMENTED_JUMP(next_instr-1, next_instr-oparg, PY_MONITORING_EVENT_JUMP);\n            CHECK_EVAL_BREAKER();\n        }\n\n        inst(INSTRUMENTED_POP_JUMP_IF_TRUE, ( -- )) {\n            PyObject *cond = POP();\n            int err = PyObject_IsTrue(cond);\n            Py_DECREF(cond);\n            ERROR_IF(err < 0, error);\n            _Py_CODEUNIT *here = next_instr-1;\n            assert(err == 0 || err == 1);\n            int offset = err*oparg;\n            INSTRUMENTED_JUMP(here, next_instr + offset, PY_MONITORING_EVENT_BRANCH);\n        }\n\n        inst(INSTRUMENTED_POP_JUMP_IF_FALSE, ( -- )) {\n            PyObject *cond = POP();\n            int err = PyObject_IsTrue(cond);\n            Py_DECREF(cond);\n            ERROR_IF(err < 0, error);\n            _Py_CODEUNIT *here = next_instr-1;\n            assert(err == 0 || err == 1);\n            int offset = (1-err)*oparg;\n            INSTRUMENTED_JUMP(here, next_instr + offset, PY_MONITORING_EVENT_BRANCH);\n        }\n\n        inst(INSTRUMENTED_POP_JUMP_IF_NONE, ( -- )) {\n            PyObject *value = POP();\n            _Py_CODEUNIT *here = next_instr-1;\n            int offset;\n            if (Py_IsNone(value)) {\n                offset = oparg;\n            }\n            else {\n                Py_DECREF(value);\n                offset = 0;\n            }\n            INSTRUMENTED_JUMP(here, next_instr + offset, PY_MONITORING_EVENT_BRANCH);\n        }\n\n        inst(INSTRUMENTED_POP_JUMP_IF_NOT_NONE, ( -- )) {\n            PyObject *value = POP();\n            _Py_CODEUNIT *here = next_instr-1;\n            int offset;\n            if (Py_IsNone(value)) {\n                offset = 0;\n            }\n            else {\n                Py_DECREF(value);\n                 offset = oparg;\n            }\n            INSTRUMENTED_JUMP(here, next_instr + offset, PY_MONITORING_EVENT_BRANCH);\n        }\n\n        inst(EXTENDED_ARG, ( -- )) {\n            assert(oparg);\n            opcode = next_instr->op.code;\n            oparg = oparg << 8 | next_instr->op.arg;\n            PRE_DISPATCH_GOTO();\n            DISPATCH_GOTO();\n        }\n\n        inst(CACHE, (--)) {\n            assert(0 && \"Executing a cache.\");\n            Py_UNREACHABLE();\n        }\n\n        inst(RESERVED, (--)) {\n            assert(0 && \"Executing RESERVED instruction.\");\n            Py_UNREACHABLE();\n        }\n\n\n// END BYTECODES //\n\n    }\n dispatch_opcode:\n error:\n exception_unwind:\n exit_unwind:\n handle_eval_breaker:\n resume_frame:\n resume_with_error:\n start_frame:\n unbound_local_error:\n    ;\n}\n\n// Future families go below this point //\n\nfamily(store_fast) = { STORE_FAST, STORE_FAST__LOAD_FAST, STORE_FAST__STORE_FAST };\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/internal/pycore_pystate.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_INTERNAL_PYSTATE_H\n#define Py_INTERNAL_PYSTATE_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_BUILD_CORE\n#  error \"this header requires Py_BUILD_CORE define\"\n#endif\n\n#include \"pycore_runtime.h\"   /* PyRuntimeState */\n\n\n/* Check if the current thread is the main thread.\n   Use _Py_IsMainInterpreter() to check if it's the main interpreter. */\nstatic inline int\n_Py_IsMainThread(void)\n{\n    unsigned long thread = PyThread_get_thread_ident();\n    return (thread == _PyRuntime.main_thread);\n}\n\n\nstatic inline PyInterpreterState *\n_PyInterpreterState_Main(void)\n{\n    return _PyRuntime.interpreters.main;\n}\n\nstatic inline int\n_Py_IsMainInterpreter(PyInterpreterState *interp)\n{\n    return (interp == _PyInterpreterState_Main());\n}\n\nstatic inline int\n_Py_IsMainInterpreterFinalizing(PyInterpreterState *interp)\n{\n    /* bpo-39877: Access _PyRuntime directly rather than using\n       tstate->interp->runtime to support calls from Python daemon threads.\n       After Py_Finalize() has been called, tstate can be a dangling pointer:\n       point to PyThreadState freed memory. */\n    return (_PyRuntimeState_GetFinalizing(&_PyRuntime) != NULL &&\n            interp == &_PyRuntime._main_interpreter);\n}\n\n// Export for _xxsubinterpreters module.\nPyAPI_FUNC(int) _PyInterpreterState_SetRunningMain(PyInterpreterState *);\nPyAPI_FUNC(void) _PyInterpreterState_SetNotRunningMain(PyInterpreterState *);\nPyAPI_FUNC(int) _PyInterpreterState_IsRunningMain(PyInterpreterState *);\n\n\nstatic inline const PyConfig *\n_Py_GetMainConfig(void)\n{\n    PyInterpreterState *interp = _PyInterpreterState_Main();\n    if (interp == NULL) {\n        return NULL;\n    }\n    return _PyInterpreterState_GetConfig(interp);\n}\n\n\n/* Only handle signals on the main thread of the main interpreter. */\nstatic inline int\n_Py_ThreadCanHandleSignals(PyInterpreterState *interp)\n{\n    return (_Py_IsMainThread() && _Py_IsMainInterpreter(interp));\n}\n\n\n/* Variable and static inline functions for in-line access to current thread\n   and interpreter state */\n\n#if defined(HAVE_THREAD_LOCAL) && !defined(Py_BUILD_CORE_MODULE)\nextern _Py_thread_local PyThreadState *_Py_tss_tstate;\n#endif\nPyAPI_DATA(PyThreadState *) _PyThreadState_GetCurrent(void);\n\n#ifndef NDEBUG\nextern int _PyThreadState_CheckConsistency(PyThreadState *tstate);\n#endif\n\nextern int _PyThreadState_MustExit(PyThreadState *tstate);\n\n/* Get the current Python thread state.\n\n   This function is unsafe: it does not check for error and it can return NULL.\n\n   The caller must hold the GIL.\n\n   See also PyThreadState_Get() and _PyThreadState_UncheckedGet(). */\nstatic inline PyThreadState*\n_PyThreadState_GET(void)\n{\n#if defined(HAVE_THREAD_LOCAL) && !defined(Py_BUILD_CORE_MODULE)\n    return _Py_tss_tstate;\n#else\n    return _PyThreadState_GetCurrent();\n#endif\n}\n\n\nstatic inline void\n_Py_EnsureFuncTstateNotNULL(const char *func, PyThreadState *tstate)\n{\n    if (tstate == NULL) {\n        _Py_FatalErrorFunc(func,\n            \"the function must be called with the GIL held, \"\n            \"after Python initialization and before Python finalization, \"\n            \"but the GIL is released (the current Python thread state is NULL)\");\n    }\n}\n\n// Call Py_FatalError() if tstate is NULL\n#define _Py_EnsureTstateNotNULL(tstate) \\\n    _Py_EnsureFuncTstateNotNULL(__func__, (tstate))\n\n\n/* Get the current interpreter state.\n\n   The function is unsafe: it does not check for error and it can return NULL.\n\n   The caller must hold the GIL.\n\n   See also _PyInterpreterState_Get()\n   and _PyGILState_GetInterpreterStateUnsafe(). */\nstatic inline PyInterpreterState* _PyInterpreterState_GET(void) {\n    PyThreadState *tstate = _PyThreadState_GET();\n#ifdef Py_DEBUG\n    _Py_EnsureTstateNotNULL(tstate);\n#endif\n    return tstate->interp;\n}\n\n\n// PyThreadState functions\n\nPyAPI_FUNC(PyThreadState *) _PyThreadState_New(PyInterpreterState *interp);\nPyAPI_FUNC(void) _PyThreadState_Bind(PyThreadState *tstate);\n// We keep this around exclusively for stable ABI compatibility.\nPyAPI_FUNC(void) _PyThreadState_Init(\n    PyThreadState *tstate);\nPyAPI_FUNC(void) _PyThreadState_DeleteExcept(PyThreadState *tstate);\n\n\n/* Other */\n\nPyAPI_FUNC(PyThreadState *) _PyThreadState_Swap(\n    _PyRuntimeState *runtime,\n    PyThreadState *newts);\n\nPyAPI_FUNC(PyStatus) _PyInterpreterState_Enable(_PyRuntimeState *runtime);\n\n#ifdef HAVE_FORK\nextern PyStatus _PyInterpreterState_DeleteExceptMain(_PyRuntimeState *runtime);\nextern void _PySignal_AfterFork(void);\n#endif\n\nPyAPI_FUNC(int) _PyCrossInterpreterData_ReleaseAndRawFree(_PyCrossInterpreterData *);\n\n\nPyAPI_FUNC(int) _PyState_AddModule(\n    PyThreadState *tstate,\n    PyObject* module,\n    PyModuleDef* def);\n\n\nPyAPI_FUNC(int) _PyOS_InterruptOccurred(PyThreadState *tstate);\n\n#define HEAD_LOCK(runtime) \\\n    PyThread_acquire_lock((runtime)->interpreters.mutex, WAIT_LOCK)\n#define HEAD_UNLOCK(runtime) \\\n    PyThread_release_lock((runtime)->interpreters.mutex)\n\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_INTERNAL_PYSTATE_H */\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/internal/pycore_ceval.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_INTERNAL_CEVAL_H\n#define Py_INTERNAL_CEVAL_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_BUILD_CORE\n#  error \"this header requires Py_BUILD_CORE define\"\n#endif\n\n/* Forward declarations */\nstruct pyruntimestate;\nstruct _ceval_runtime_state;\n\n#ifndef Py_DEFAULT_RECURSION_LIMIT\n#  define Py_DEFAULT_RECURSION_LIMIT 1000\n#endif\n\n#include \"pycore_interp.h\"        // PyInterpreterState.eval_frame\n#include \"pycore_pystate.h\"       // _PyThreadState_GET()\n\n\nextern void _Py_FinishPendingCalls(PyThreadState *tstate);\nextern void _PyEval_InitState(PyInterpreterState *, PyThread_type_lock);\nextern void _PyEval_FiniState(struct _ceval_state *ceval);\nPyAPI_FUNC(void) _PyEval_SignalReceived(PyInterpreterState *interp);\nPyAPI_FUNC(int) _PyEval_AddPendingCall(\n    PyInterpreterState *interp,\n    int (*func)(void *),\n    void *arg,\n    int mainthreadonly);\nPyAPI_FUNC(void) _PyEval_SignalAsyncExc(PyInterpreterState *interp);\n#ifdef HAVE_FORK\nextern PyStatus _PyEval_ReInitThreads(PyThreadState *tstate);\n#endif\n\n// Used by sys.call_tracing()\nextern PyObject* _PyEval_CallTracing(PyObject *func, PyObject *args);\n\n// Used by sys.get_asyncgen_hooks()\nextern PyObject* _PyEval_GetAsyncGenFirstiter(void);\nextern PyObject* _PyEval_GetAsyncGenFinalizer(void);\n\n// Used by sys.set_asyncgen_hooks()\nextern int _PyEval_SetAsyncGenFirstiter(PyObject *);\nextern int _PyEval_SetAsyncGenFinalizer(PyObject *);\n\n// Used by sys.get_coroutine_origin_tracking_depth()\n// and sys.set_coroutine_origin_tracking_depth()\nextern int _PyEval_GetCoroutineOriginTrackingDepth(void);\nextern int _PyEval_SetCoroutineOriginTrackingDepth(int depth);\n\nextern void _PyEval_Fini(void);\n\n\nextern PyObject* _PyEval_GetBuiltins(PyThreadState *tstate);\nextern PyObject* _PyEval_BuiltinsFromGlobals(\n    PyThreadState *tstate,\n    PyObject *globals);\n\n// Trampoline API\n\ntypedef struct {\n    // Callback to initialize the trampoline state\n    void* (*init_state)(void);\n    // Callback to register every trampoline being created\n    void (*write_state)(void* state, const void *code_addr,\n                        unsigned int code_size, PyCodeObject* code);\n    // Callback to free the trampoline state\n    int (*free_state)(void* state);\n} _PyPerf_Callbacks;\n\nextern int _PyPerfTrampoline_SetCallbacks(_PyPerf_Callbacks *);\nextern void _PyPerfTrampoline_GetCallbacks(_PyPerf_Callbacks *);\nextern int _PyPerfTrampoline_Init(int activate);\nextern int _PyPerfTrampoline_Fini(void);\nextern void _PyPerfTrampoline_FreeArenas(void);\nextern int _PyIsPerfTrampolineActive(void);\nextern PyStatus _PyPerfTrampoline_AfterFork_Child(void);\n#ifdef PY_HAVE_PERF_TRAMPOLINE\nextern _PyPerf_Callbacks _Py_perfmap_callbacks;\n#endif\n\nstatic inline PyObject*\n_PyEval_EvalFrame(PyThreadState *tstate, struct _PyInterpreterFrame *frame, int throwflag)\n{\n    EVAL_CALL_STAT_INC(EVAL_CALL_TOTAL);\n    if (tstate->interp->eval_frame == NULL) {\n        return _PyEval_EvalFrameDefault(tstate, frame, throwflag);\n    }\n    return tstate->interp->eval_frame(tstate, frame, throwflag);\n}\n\nextern PyObject*\n_PyEval_Vector(PyThreadState *tstate,\n            PyFunctionObject *func, PyObject *locals,\n            PyObject* const* args, size_t argcount,\n            PyObject *kwnames);\n\nextern int _PyEval_ThreadsInitialized(void);\nextern PyStatus _PyEval_InitGIL(PyThreadState *tstate, int own_gil);\nextern void _PyEval_FiniGIL(PyInterpreterState *interp);\n\nextern void _PyEval_AcquireLock(PyThreadState *tstate);\nextern void _PyEval_ReleaseLock(PyInterpreterState *, PyThreadState *);\nextern PyThreadState * _PyThreadState_SwapNoGIL(PyThreadState *);\n\nextern void _PyEval_DeactivateOpCache(void);\n\n\n/* --- _Py_EnterRecursiveCall() ----------------------------------------- */\n\n#ifdef USE_STACKCHECK\n/* With USE_STACKCHECK macro defined, trigger stack checks in\n   _Py_CheckRecursiveCall() on every 64th call to _Py_EnterRecursiveCall. */\nstatic inline int _Py_MakeRecCheck(PyThreadState *tstate)  {\n    return (tstate->c_recursion_remaining-- <= 0\n            || (tstate->c_recursion_remaining & 63) == 0);\n}\n#else\nstatic inline int _Py_MakeRecCheck(PyThreadState *tstate) {\n    return tstate->c_recursion_remaining-- <= 0;\n}\n#endif\n\nPyAPI_FUNC(int) _Py_CheckRecursiveCall(\n    PyThreadState *tstate,\n    const char *where);\n\nint _Py_CheckRecursiveCallPy(\n    PyThreadState *tstate);\n\nstatic inline int _Py_EnterRecursiveCallTstate(PyThreadState *tstate,\n                                               const char *where) {\n    return (_Py_MakeRecCheck(tstate) && _Py_CheckRecursiveCall(tstate, where));\n}\n\nstatic inline int _Py_EnterRecursiveCall(const char *where) {\n    PyThreadState *tstate = _PyThreadState_GET();\n    return _Py_EnterRecursiveCallTstate(tstate, where);\n}\n\nstatic inline void _Py_LeaveRecursiveCallTstate(PyThreadState *tstate)  {\n    tstate->c_recursion_remaining++;\n}\n\nstatic inline void _Py_LeaveRecursiveCall(void)  {\n    PyThreadState *tstate = _PyThreadState_GET();\n    _Py_LeaveRecursiveCallTstate(tstate);\n}\n\nextern struct _PyInterpreterFrame* _PyEval_GetFrame(void);\n\nextern PyObject* _Py_MakeCoro(PyFunctionObject *func);\n\nextern int _Py_HandlePending(PyThreadState *tstate);\n\nextern PyObject * _PyEval_GetFrameLocals(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_INTERNAL_CEVAL_H */\n"},
                          "sourceLanguage": "c"},
                         {"location": {"uri": "./Include/object.h",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#ifndef Py_OBJECT_H\n#define Py_OBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Object and type object interface */\n\n/*\nObjects are structures allocated on the heap.  Special rules apply to\nthe use of objects to ensure they are properly garbage-collected.\nObjects are never allocated statically or on the stack; they must be\naccessed through special macros and functions only.  (Type objects are\nexceptions to the first rule; the standard types are represented by\nstatically initialized type objects, although work on type/class unification\nfor Python 2.2 made it possible to have heap-allocated type objects too).\n\nAn object has a 'reference count' that is increased or decreased when a\npointer to the object is copied or deleted; when the reference count\nreaches zero there are no references to the object left and it can be\nremoved from the heap.\n\nAn object has a 'type' that determines what it represents and what kind\nof data it contains.  An object's type is fixed when it is created.\nTypes themselves are represented as objects; an object contains a\npointer to the corresponding type object.  The type itself has a type\npointer pointing to the object representing the type 'type', which\ncontains a pointer to itself!.\n\nObjects do not float around in memory; once allocated an object keeps\nthe same size and address.  Objects that must hold variable-size data\ncan contain pointers to variable-size parts of the object.  Not all\nobjects of the same type have the same size; but the size cannot change\nafter allocation.  (These restrictions are made so a reference to an\nobject can be simply a pointer -- moving an object would require\nupdating all the pointers, and changing an object's size would require\nmoving it if there was another object right next to it.)\n\nObjects are always accessed through pointers of the type 'PyObject *'.\nThe type 'PyObject' is a structure that only contains the reference count\nand the type pointer.  The actual memory allocated for an object\ncontains other data that can only be accessed after casting the pointer\nto a pointer to a longer structure type.  This longer type must start\nwith the reference count and type fields; the macro PyObject_HEAD should be\nused for this (to accommodate for future changes).  The implementation\nof a particular object type can cast the object pointer to the proper\ntype and back.\n\nA standard interface exists for objects that contain an array of items\nwhose size is determined when the object is allocated.\n*/\n\n#include \"pystats.h\"\n\n/* Py_DEBUG implies Py_REF_DEBUG. */\n#if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)\n#  define Py_REF_DEBUG\n#endif\n\n#if defined(Py_LIMITED_API) && defined(Py_TRACE_REFS)\n#  error Py_LIMITED_API is incompatible with Py_TRACE_REFS\n#endif\n\n#ifdef Py_TRACE_REFS\n/* Define pointers to support a doubly-linked list of all live heap objects. */\n#define _PyObject_HEAD_EXTRA            \\\n    PyObject *_ob_next;           \\\n    PyObject *_ob_prev;\n\n#define _PyObject_EXTRA_INIT _Py_NULL, _Py_NULL,\n\n#else\n#  define _PyObject_HEAD_EXTRA\n#  define _PyObject_EXTRA_INIT\n#endif\n\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   PyObject ob_base;\n\n/*\nImmortalization:\n\nThe following indicates the immortalization strategy depending on the amount\nof available bits in the reference count field. All strategies are backwards\ncompatible but the specific reference count value or immortalization check\nmight change depending on the specializations for the underlying system.\n\nProper deallocation of immortal instances requires distinguishing between\nstatically allocated immortal instances vs those promoted by the runtime to be\nimmortal. The latter should be the only instances that require\ncleanup during runtime finalization.\n*/\n\n#if SIZEOF_VOID_P > 4\n/*\nIn 64+ bit systems, an object will be marked as immortal by setting all of the\nlower 32 bits of the reference count field, which is equal to: 0xFFFFFFFF\n\nUsing the lower 32 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases will use saturated arithmetic, taking advantage of\nhaving all the lower 32 bits set, which will avoid the reference count to go\nbeyond the refcount limit. Immortality checks for reference count decreases will\nbe done by checking the bit sign flag in the lower 32 bits.\n*/\n#define _Py_IMMORTAL_REFCNT UINT_MAX\n\n#else\n/*\nIn 32 bit systems, an object will be marked as immortal by setting all of the\nlower 30 bits of the reference count field, which is equal to: 0x3FFFFFFF\n\nUsing the lower 30 bits makes the value backwards compatible by allowing\nC-Extensions without the updated checks in Py_INCREF and Py_DECREF to safely\nincrease and decrease the objects reference count. The object would lose its\nimmortality, but the execution would still be correct.\n\nReference count increases and decreases will first go through an immortality\ncheck by comparing the reference count field to the immortality reference count.\n*/\n#define _Py_IMMORTAL_REFCNT (UINT_MAX >> 2)\n#endif\n\n// Make all internal uses of PyObject_HEAD_INIT immortal while preserving the\n// C-API expectation that the refcnt will be set to 1.\n#ifdef Py_BUILD_CORE\n#define PyObject_HEAD_INIT(type)    \\\n    {                               \\\n        _PyObject_EXTRA_INIT        \\\n        { _Py_IMMORTAL_REFCNT },    \\\n        (type)                      \\\n    },\n#else\n#define PyObject_HEAD_INIT(type) \\\n    {                            \\\n        _PyObject_EXTRA_INIT     \\\n        { 1 },                   \\\n        (type)                   \\\n    },\n#endif /* Py_BUILD_CORE */\n\n#define PyVarObject_HEAD_INIT(type, size) \\\n    {                                     \\\n        PyObject_HEAD_INIT(type)          \\\n        (size)                            \\\n    },\n\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD      PyVarObject ob_base;\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\nstruct _object {\n    _PyObject_HEAD_EXTRA\n\n#if (defined(__GNUC__) || defined(__clang__)) \\\n        && !(defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L)\n    // On C99 and older, anonymous union is a GCC and clang extension\n    __extension__\n#endif\n#ifdef _MSC_VER\n    // Ignore MSC warning C4201: \"nonstandard extension used:\n    // nameless struct/union\"\n    __pragma(warning(push))\n    __pragma(warning(disable: 4201))\n#endif\n    union {\n       Py_ssize_t ob_refcnt;\n#if SIZEOF_VOID_P > 4\n       PY_UINT32_T ob_refcnt_split[2];\n#endif\n    };\n#ifdef _MSC_VER\n    __pragma(warning(pop))\n#endif\n\n    PyTypeObject *ob_type;\n};\n\n/* Cast argument to PyObject* type. */\n#define _PyObject_CAST(op) _Py_CAST(PyObject*, (op))\n\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n/* Cast argument to PyVarObject* type. */\n#define _PyVarObject_CAST(op) _Py_CAST(PyVarObject*, (op))\n\n\n// Test if the 'x' object is the 'y' object, the same as \"x is y\" in Python.\nPyAPI_FUNC(int) Py_Is(PyObject *x, PyObject *y);\n#define Py_Is(x, y) ((x) == (y))\n\n\nstatic inline Py_ssize_t Py_REFCNT(PyObject *ob) {\n    return ob->ob_refcnt;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_REFCNT(ob) Py_REFCNT(_PyObject_CAST(ob))\n#endif\n\n\n// bpo-39573: The Py_SET_TYPE() function must be used to set an object type.\nstatic inline PyTypeObject* Py_TYPE(PyObject *ob) {\n    return ob->ob_type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_TYPE(ob) Py_TYPE(_PyObject_CAST(ob))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyLong_Type;\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n\n// bpo-39573: The Py_SET_SIZE() function must be used to set an object size.\nstatic inline Py_ssize_t Py_SIZE(PyObject *ob) {\n    assert(ob->ob_type != &PyLong_Type);\n    assert(ob->ob_type != &PyBool_Type);\n    return  _PyVarObject_CAST(ob)->ob_size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SIZE(ob) Py_SIZE(_PyObject_CAST(ob))\n#endif\n\nstatic inline Py_ALWAYS_INLINE int _Py_IsImmortal(PyObject *op)\n{\n#if SIZEOF_VOID_P > 4\n    return _Py_CAST(PY_INT32_T, op->ob_refcnt) < 0;\n#else\n    return op->ob_refcnt == _Py_IMMORTAL_REFCNT;\n#endif\n}\n#define _Py_IsImmortal(op) _Py_IsImmortal(_PyObject_CAST(op))\n\nstatic inline int Py_IS_TYPE(PyObject *ob, PyTypeObject *type) {\n    return Py_TYPE(ob) == type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_IS_TYPE(ob, type) Py_IS_TYPE(_PyObject_CAST(ob), (type))\n#endif\n\n\nstatic inline void Py_SET_REFCNT(PyObject *ob, Py_ssize_t refcnt) {\n    // This immortal check is for code that is unaware of immortal objects.\n    // The runtime tracks these objects and we should avoid as much\n    // as possible having extensions inadvertently change the refcnt\n    // of an immortalized object.\n    if (_Py_IsImmortal(ob)) {\n        return;\n    }\n    ob->ob_refcnt = refcnt;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_REFCNT(ob, refcnt) Py_SET_REFCNT(_PyObject_CAST(ob), (refcnt))\n#endif\n\n\nstatic inline void Py_SET_TYPE(PyObject *ob, PyTypeObject *type) {\n    ob->ob_type = type;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_TYPE(ob, type) Py_SET_TYPE(_PyObject_CAST(ob), type)\n#endif\n\nstatic inline void Py_SET_SIZE(PyVarObject *ob, Py_ssize_t size) {\n    assert(ob->ob_base.ob_type != &PyLong_Type);\n    assert(ob->ob_base.ob_type != &PyBool_Type);\n    ob->ob_size = size;\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_SET_SIZE(ob, size) Py_SET_SIZE(_PyVarObject_CAST(ob), (size))\n#endif\n\n\n/*\nType objects contain a string containing the type name (to help somewhat\nin debugging), the allocation parameters (see PyObject_New() and\nPyObject_NewVar()),\nand methods for accessing objects of the type.  Methods are optional, a\nnil pointer meaning that particular kind of access is not available for\nthis type.  The Py_DECREF() macro uses the tp_dealloc method without\nchecking for a nil pointer; it should always be implemented except if\nthe implementation can guarantee that the reference count will never\nreach zero (e.g., for statically allocated type objects).\n\nNB: the methods for certain type groups are now contained in separate\nmethod blocks.\n*/\n\ntypedef PyObject * (*unaryfunc)(PyObject *);\ntypedef PyObject * (*binaryfunc)(PyObject *, PyObject *);\ntypedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);\ntypedef int (*inquiry)(PyObject *);\ntypedef Py_ssize_t (*lenfunc)(PyObject *);\ntypedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);\ntypedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);\ntypedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);\ntypedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);\ntypedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);\n\ntypedef int (*objobjproc)(PyObject *, PyObject *);\ntypedef int (*visitproc)(PyObject *, void *);\ntypedef int (*traverseproc)(PyObject *, visitproc, void *);\n\n\ntypedef void (*freefunc)(void *);\ntypedef void (*destructor)(PyObject *);\ntypedef PyObject *(*getattrfunc)(PyObject *, char *);\ntypedef PyObject *(*getattrofunc)(PyObject *, PyObject *);\ntypedef int (*setattrfunc)(PyObject *, char *, PyObject *);\ntypedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*reprfunc)(PyObject *);\ntypedef Py_hash_t (*hashfunc)(PyObject *);\ntypedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);\ntypedef PyObject *(*getiterfunc) (PyObject *);\ntypedef PyObject *(*iternextfunc) (PyObject *);\ntypedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*initproc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*newfunc)(PyTypeObject *, PyObject *, PyObject *);\ntypedef PyObject *(*allocfunc)(PyTypeObject *, Py_ssize_t);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030c0000 // 3.12\ntypedef PyObject *(*vectorcallfunc)(PyObject *callable, PyObject *const *args,\n                                    size_t nargsf, PyObject *kwnames);\n#endif\n\ntypedef struct{\n    int slot;    /* slot id, see below */\n    void *pfunc; /* function pointer */\n} PyType_Slot;\n\ntypedef struct{\n    const char* name;\n    int basicsize;\n    int itemsize;\n    unsigned int flags;\n    PyType_Slot *slots; /* terminated by slot==0. */\n} PyType_Spec;\n\nPyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000\nPyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);\nPyAPI_FUNC(PyObject *) PyType_GetModule(PyTypeObject *);\nPyAPI_FUNC(void *) PyType_GetModuleState(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000\nPyAPI_FUNC(PyObject *) PyType_GetName(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GetQualName(PyTypeObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\nPyAPI_FUNC(PyObject *) PyType_FromMetaclass(PyTypeObject*, PyObject*, PyType_Spec*, PyObject*);\nPyAPI_FUNC(void *) PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls);\nPyAPI_FUNC(Py_ssize_t) PyType_GetTypeDataSize(PyTypeObject *cls);\n#endif\n\n/* Generic type check */\nPyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);\n\nstatic inline int PyObject_TypeCheck(PyObject *ob, PyTypeObject *type) {\n    return Py_IS_TYPE(ob, type) || PyType_IsSubtype(Py_TYPE(ob), type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyObject_TypeCheck(ob, type) PyObject_TypeCheck(_PyObject_CAST(ob), (type))\n#endif\n\nPyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */\nPyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */\nPyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */\n\nPyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);\n\nPyAPI_FUNC(int) PyType_Ready(PyTypeObject *);\nPyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,\n                                               PyObject *, PyObject *);\nPyAPI_FUNC(unsigned int) PyType_ClearCache(void);\nPyAPI_FUNC(void) PyType_Modified(PyTypeObject *);\n\n/* Generic operations on objects */\nPyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);\nPyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);\nPyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);\nPyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);\n#endif\nPyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);\nPyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);\nPyAPI_FUNC(int) PyObject_IsTrue(PyObject *);\nPyAPI_FUNC(int) PyObject_Not(PyObject *);\nPyAPI_FUNC(int) PyCallable_Check(PyObject *);\nPyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);\n\n/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a\n   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),\n   returning the names of the current locals.  In this case, if there are\n   no current locals, NULL is returned, and PyErr_Occurred() is false.\n*/\nPyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);\n\n/* Pickle support. */\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyObject_GetState(PyObject *);\n#endif\n\n\n/* Helpers for printing recursive container types */\nPyAPI_FUNC(int) Py_ReprEnter(PyObject *);\nPyAPI_FUNC(void) Py_ReprLeave(PyObject *);\n\n/* Flag bits for printing: */\n#define Py_PRINT_RAW    1       /* No string quotes etc. */\n\n/*\nType flags (tp_flags)\n\nThese flags are used to change expected features and behavior for a\nparticular type.\n\nArbitration of the flag bit positions will need to be coordinated among\nall extension writers who publicly release their extensions (this will\nbe fewer than you might expect!).\n\nMost flags were removed as of Python 3.0 to make room for new flags.  (Some\nflags are not for backwards compatibility but to indicate the presence of an\noptional feature; these flags remain of course.)\n\nType definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.\n\nCode can use PyType_HasFeature(type_ob, flag_value) to test whether the\ngiven type object has a specified feature.\n*/\n\n#ifndef Py_LIMITED_API\n\n/* Track types initialized using _PyStaticType_InitBuiltin(). */\n#define _Py_TPFLAGS_STATIC_BUILTIN (1 << 1)\n\n/* Placement of weakref pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_weaklistoffset.\n */\n#define Py_TPFLAGS_MANAGED_WEAKREF (1 << 3)\n\n/* Placement of dict (and values) pointers are managed by the VM, not by the type.\n * The VM will automatically set tp_dictoffset.\n */\n#define Py_TPFLAGS_MANAGED_DICT (1 << 4)\n\n#define Py_TPFLAGS_PREHEADER (Py_TPFLAGS_MANAGED_WEAKREF | Py_TPFLAGS_MANAGED_DICT)\n\n/* Set if instances of the type object are treated as sequences for pattern matching */\n#define Py_TPFLAGS_SEQUENCE (1 << 5)\n/* Set if instances of the type object are treated as mappings for pattern matching */\n#define Py_TPFLAGS_MAPPING (1 << 6)\n#endif\n\n/* Disallow creating instances of the type: set tp_new to NULL and don't create\n * the \"__new__\" key in the type dictionary. */\n#define Py_TPFLAGS_DISALLOW_INSTANTIATION (1UL << 7)\n\n/* Set if the type object is immutable: type attributes cannot be set nor deleted */\n#define Py_TPFLAGS_IMMUTABLETYPE (1UL << 8)\n\n/* Set if the type object is dynamically allocated */\n#define Py_TPFLAGS_HEAPTYPE (1UL << 9)\n\n/* Set if the type allows subclassing */\n#define Py_TPFLAGS_BASETYPE (1UL << 10)\n\n/* Set if the type implements the vectorcall protocol (PEP 590) */\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000\n#define Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)\n#ifndef Py_LIMITED_API\n// Backwards compatibility alias for API that was provisional in Python 3.8\n#define _Py_TPFLAGS_HAVE_VECTORCALL Py_TPFLAGS_HAVE_VECTORCALL\n#endif\n#endif\n\n/* Set if the type is 'ready' -- fully initialized */\n#define Py_TPFLAGS_READY (1UL << 12)\n\n/* Set while the type is being 'readied', to prevent recursive ready calls */\n#define Py_TPFLAGS_READYING (1UL << 13)\n\n/* Objects support garbage collection (see objimpl.h) */\n#define Py_TPFLAGS_HAVE_GC (1UL << 14)\n\n/* These two bits are preserved for Stackless Python, next after this is 17 */\n#ifdef STACKLESS\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)\n#else\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0\n#endif\n\n/* Objects behave like an unbound method */\n#define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)\n\n/* Object has up-to-date type attribute cache */\n#define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)\n\n/* Type is abstract and cannot be instantiated */\n#define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)\n\n// This undocumented flag gives certain built-ins their unique pattern-matching\n// behavior, which allows a single positional subpattern to match against the\n// subject itself (rather than a mapped attribute on it):\n#define _Py_TPFLAGS_MATCH_SELF (1UL << 22)\n\n/* Items (ob_size*tp_itemsize) are found at the end of an instance's memory */\n#define Py_TPFLAGS_ITEMS_AT_END (1UL << 23)\n\n/* These flags are used to determine if a type is a subclass. */\n#define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)\n#define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)\n#define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)\n#define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)\n#define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)\n#define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)\n#define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)\n#define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)\n\n#define Py_TPFLAGS_DEFAULT  ( \\\n                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \\\n                0)\n\n/* NOTE: Some of the following flags reuse lower bits (removed as part of the\n * Python 3.0 transition). */\n\n/* The following flags are kept for compatibility; in previous\n * versions they indicated presence of newer tp_* fields on the\n * type struct.\n * Starting with 3.8, binary compatibility of C extensions across\n * feature releases of Python is not supported anymore (except when\n * using the stable ABI, in which all classes are created dynamically,\n * using the interpreter's memory layout.)\n * Note that older extensions using the stable ABI set these flags,\n * so the bits must not be repurposed.\n */\n#define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)\n#define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)\n\n\n/*\nThe macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement\nreference counts.  Py_DECREF calls the object's deallocator function when\nthe refcount falls to 0; for\nobjects that don't contain references to other objects or heap memory\nthis can be the standard function free().  Both macros can be used\nwherever a void expression is allowed.  The argument must not be a\nNULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.\nThe macro _Py_NewReference(op) initialize reference counts to 1, and\nin special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional\nbookkeeping appropriate to the special build.\n\nWe assume that the reference count field can never overflow; this can\nbe proven when the size of the field is the same as the pointer size, so\nwe ignore the possibility.  Provided a C int is at least 32 bits (which\nis implicitly assumed in many parts of this code), that's enough for\nabout 2**31 references to an object.\n\nXXX The following became out of date in Python 2.2, but I'm not sure\nXXX what the full truth is now.  Certainly, heap-allocated type objects\nXXX can and should be deallocated.\nType objects should never be deallocated; the type pointer in an object\nis not considered to be a reference to the type object, to save\ncomplications in the deallocation function.  (This is actually a\ndecision that's up to the implementer of each new type so if you want,\nyou can count such references to the type object.)\n*/\n\n#if defined(Py_REF_DEBUG) && !defined(Py_LIMITED_API)\nPyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,\n                                      PyObject *op);\nPyAPI_FUNC(void) _Py_INCREF_IncRefTotal(void);\nPyAPI_FUNC(void) _Py_DECREF_DecRefTotal(void);\n#endif  // Py_REF_DEBUG && !Py_LIMITED_API\n\nPyAPI_FUNC(void) _Py_Dealloc(PyObject *);\n\n/*\nThese are provided as conveniences to Python runtime embedders, so that\nthey can have object code that is not dependent on Python compilation flags.\n*/\nPyAPI_FUNC(void) Py_IncRef(PyObject *);\nPyAPI_FUNC(void) Py_DecRef(PyObject *);\n\n// Similar to Py_IncRef() and Py_DecRef() but the argument must be non-NULL.\n// Private functions used by Py_INCREF() and Py_DECREF().\nPyAPI_FUNC(void) _Py_IncRef(PyObject *);\nPyAPI_FUNC(void) _Py_DecRef(PyObject *);\n\nstatic inline Py_ALWAYS_INLINE void Py_INCREF(PyObject *op)\n{\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n    // Stable ABI implements Py_INCREF() as a function call on limited C API\n    // version 3.12 and newer, and on Python built in debug mode. _Py_IncRef()\n    // was added to Python 3.10.0a7, use Py_IncRef() on older Python versions.\n    // Py_IncRef() accepts NULL whereas _Py_IncRef() doesn't.\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_IncRef(op);\n#  else\n    Py_IncRef(op);\n#  endif\n#else\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n#if SIZEOF_VOID_P > 4\n    // Portable saturated add, branching on the carry flag and set low bits\n    PY_UINT32_T cur_refcnt = op->ob_refcnt_split[PY_BIG_ENDIAN];\n    PY_UINT32_T new_refcnt = cur_refcnt + 1;\n    if (new_refcnt == 0) {\n        return;\n    }\n    op->ob_refcnt_split[PY_BIG_ENDIAN] = new_refcnt;\n#else\n    // Explicitly check immortality against the immortal value\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    op->ob_refcnt++;\n#endif\n    _Py_INCREF_STAT_INC();\n#ifdef Py_REF_DEBUG\n    _Py_INCREF_IncRefTotal();\n#endif\n#endif\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_INCREF(op) Py_INCREF(_PyObject_CAST(op))\n#endif\n\n#if defined(Py_LIMITED_API) && (Py_LIMITED_API+0 >= 0x030c0000 || defined(Py_REF_DEBUG))\n// Stable ABI implements Py_DECREF() as a function call on limited C API\n// version 3.12 and newer, and on Python built in debug mode. _Py_DecRef() was\n// added to Python 3.10.0a7, use Py_DecRef() on older Python versions.\n// Py_DecRef() accepts NULL whereas _Py_IncRef() doesn't.\nstatic inline void Py_DECREF(PyObject *op) {\n#  if Py_LIMITED_API+0 >= 0x030a00A7\n    _Py_DecRef(op);\n#  else\n    Py_DecRef(op);\n#  endif\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n\n#elif defined(Py_REF_DEBUG)\nstatic inline void Py_DECREF(const char *filename, int lineno, PyObject *op)\n{\n    if (op->ob_refcnt <= 0) {\n        _Py_NegativeRefcount(filename, lineno, op);\n    }\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    _Py_DECREF_DecRefTotal();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n#else\nstatic inline Py_ALWAYS_INLINE void Py_DECREF(PyObject *op)\n{\n    // Non-limited C API and limited C API for Python 3.9 and older access\n    // directly PyObject.ob_refcnt.\n    if (_Py_IsImmortal(op)) {\n        return;\n    }\n    _Py_DECREF_STAT_INC();\n    if (--op->ob_refcnt == 0) {\n        _Py_Dealloc(op);\n    }\n}\n#define Py_DECREF(op) Py_DECREF(_PyObject_CAST(op))\n#endif\n\n\n/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear\n * and tp_dealloc implementations.\n *\n * Note that \"the obvious\" code can be deadly:\n *\n *     Py_XDECREF(op);\n *     op = NULL;\n *\n * Typically, `op` is something like self->containee, and `self` is done\n * using its `containee` member.  In the code sequence above, suppose\n * `containee` is non-NULL with a refcount of 1.  Its refcount falls to\n * 0 on the first line, which can trigger an arbitrary amount of code,\n * possibly including finalizers (like __del__ methods or weakref callbacks)\n * coded in Python, which in turn can release the GIL and allow other threads\n * to run, etc.  Such code may even invoke methods of `self` again, or cause\n * cyclic gc to trigger, but-- oops! --self->containee still points to the\n * object being torn down, and it may be in an insane state while being torn\n * down.  This has in fact been a rich historic source of miserable (rare &\n * hard-to-diagnose) segfaulting (and other) bugs.\n *\n * The safe way is:\n *\n *      Py_CLEAR(op);\n *\n * That arranges to set `op` to NULL _before_ decref'ing, so that any code\n * triggered as a side-effect of `op` getting torn down no longer believes\n * `op` points to a valid object.\n *\n * There are cases where it's safe to use the naive code, but they're brittle.\n * For example, if `op` points to a Python integer, you know that destroying\n * one of those can't cause problems -- but in part that relies on that\n * Python integers aren't currently weakly referencable.  Best practice is\n * to use Py_CLEAR() even if you can't think of a reason for why you need to.\n *\n * gh-98724: Use a temporary variable to only evaluate the macro argument once,\n * to avoid the duplication of side effects if the argument has side effects.\n *\n * gh-99701: If the PyObject* type is used with casting arguments to PyObject*,\n * the code can be miscompiled with strict aliasing because of type punning.\n * With strict aliasing, a compiler considers that two pointers of different\n * types cannot read or write the same memory which enables optimization\n * opportunities.\n *\n * If available, use _Py_TYPEOF() to use the 'op' type for temporary variables,\n * and so avoid type punning. Otherwise, use memcpy() which causes type erasure\n * and so prevents the compiler to reuse an old cached 'op' value after\n * Py_CLEAR().\n */\n#ifdef _Py_TYPEOF\n#define Py_CLEAR(op) \\\n    do { \\\n        _Py_TYPEOF(op)* _tmp_op_ptr = &(op); \\\n        _Py_TYPEOF(op) _tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            *_tmp_op_ptr = _Py_NULL; \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#else\n#define Py_CLEAR(op) \\\n    do { \\\n        PyObject **_tmp_op_ptr = _Py_CAST(PyObject**, &(op)); \\\n        PyObject *_tmp_old_op = (*_tmp_op_ptr); \\\n        if (_tmp_old_op != NULL) { \\\n            PyObject *_null_ptr = _Py_NULL; \\\n            memcpy(_tmp_op_ptr, &_null_ptr, sizeof(PyObject*)); \\\n            Py_DECREF(_tmp_old_op); \\\n        } \\\n    } while (0)\n#endif\n\n\n/* Function to use in case the object pointer can be NULL: */\nstatic inline void Py_XINCREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_INCREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XINCREF(op) Py_XINCREF(_PyObject_CAST(op))\n#endif\n\nstatic inline void Py_XDECREF(PyObject *op)\n{\n    if (op != _Py_NULL) {\n        Py_DECREF(op);\n    }\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_XDECREF(op) Py_XDECREF(_PyObject_CAST(op))\n#endif\n\n// Create a new strong reference to an object:\n// increment the reference count of the object and return the object.\nPyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);\n\n// Similar to Py_NewRef(), but the object can be NULL.\nPyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);\n\nstatic inline PyObject* _Py_NewRef(PyObject *obj)\n{\n    Py_INCREF(obj);\n    return obj;\n}\n\nstatic inline PyObject* _Py_XNewRef(PyObject *obj)\n{\n    Py_XINCREF(obj);\n    return obj;\n}\n\n// Py_NewRef() and Py_XNewRef() are exported as functions for the stable ABI.\n// Names overridden with macros by static inline functions for best\n// performances.\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define Py_NewRef(obj) _Py_NewRef(_PyObject_CAST(obj))\n#  define Py_XNewRef(obj) _Py_XNewRef(_PyObject_CAST(obj))\n#else\n#  define Py_NewRef(obj) _Py_NewRef(obj)\n#  define Py_XNewRef(obj) _Py_XNewRef(obj)\n#endif\n\n\n/*\n_Py_NoneStruct is an object of undefined type which can be used in contexts\nwhere NULL (nil) is not suitable (since NULL often means 'error').\n\nDon't forget to apply Py_INCREF() when returning this value!!!\n*/\nPyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n#define Py_None (&_Py_NoneStruct)\n\n// Test if an object is the None singleton, the same as \"x is None\" in Python.\nPyAPI_FUNC(int) Py_IsNone(PyObject *x);\n#define Py_IsNone(x) Py_Is((x), Py_None)\n\n/* Macro for returning Py_None from a function */\n#define Py_RETURN_NONE return Py_None\n\n/*\nPy_NotImplemented is a singleton used to signal that an operation is\nnot implemented for a given type combination.\n*/\nPyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */\n#define Py_NotImplemented (&_Py_NotImplementedStruct)\n\n/* Macro for returning Py_NotImplemented from a function */\n#define Py_RETURN_NOTIMPLEMENTED return Py_NotImplemented\n\n/* Rich comparison opcodes */\n#define Py_LT 0\n#define Py_LE 1\n#define Py_EQ 2\n#define Py_NE 3\n#define Py_GT 4\n#define Py_GE 5\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000\n/* Result of calling PyIter_Send */\ntypedef enum {\n    PYGEN_RETURN = 0,\n    PYGEN_ERROR = -1,\n    PYGEN_NEXT = 1,\n} PySendResult;\n#endif\n\n/*\n * Macro for implementing rich comparisons\n *\n * Needs to be a macro because any C-comparable type can be used.\n */\n#define Py_RETURN_RICHCOMPARE(val1, val2, op)                               \\\n    do {                                                                    \\\n        switch (op) {                                                       \\\n        case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        default:                                                            \\\n            Py_UNREACHABLE();                                               \\\n        }                                                                   \\\n    } while (0)\n\n\n/*\nMore conventions\n================\n\nArgument Checking\n-----------------\n\nFunctions that take objects as arguments normally don't check for nil\narguments, but they do check the type of the argument, and return an\nerror if the function doesn't apply to the type.\n\nFailure Modes\n-------------\n\nFunctions may fail for a variety of reasons, including running out of\nmemory.  This is communicated to the caller in two ways: an error string\nis set (see errors.h), and the function result differs: functions that\nnormally return a pointer return NULL for failure, functions returning\nan integer return -1 (which could be a legal return value too!), and\nother functions return 0 for success and -1 for failure.\nCallers should always check for errors before using the result.  If\nan error was set, the caller must either explicitly clear it, or pass\nthe error on to its caller.\n\nReference Counts\n----------------\n\nIt takes a while to get used to the proper usage of reference counts.\n\nFunctions that create an object set the reference count to 1; such new\nobjects must be stored somewhere or destroyed again with Py_DECREF().\nSome functions that 'store' objects, such as PyTuple_SetItem() and\nPyList_SetItem(),\ndon't increment the reference count of the object, since the most\nfrequent use is to store a fresh object.  Functions that 'retrieve'\nobjects, such as PyTuple_GetItem() and PyDict_GetItemString(), also\ndon't increment\nthe reference count, since most frequently the object is only looked at\nquickly.  Thus, to retrieve an object and store it again, the caller\nmust call Py_INCREF() explicitly.\n\nNOTE: functions that 'consume' a reference count, like\nPyList_SetItem(), consume the reference even if the object wasn't\nsuccessfully stored, to simplify error handling.\n\nIt seems attractive to make other functions that take an object as\nargument consume a reference count; however, this may quickly get\nconfusing (even the current practice is already confusing).  Consider\nit carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at\ntimes.\n*/\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_OBJECT_H\n#  include \"cpython/object.h\"\n#  undef Py_CPYTHON_OBJECT_H\n#endif\n\n\nstatic inline int\nPyType_HasFeature(PyTypeObject *type, unsigned long feature)\n{\n    unsigned long flags;\n#ifdef Py_LIMITED_API\n    // PyTypeObject is opaque in the limited C API\n    flags = PyType_GetFlags(type);\n#else\n    flags = type->tp_flags;\n#endif\n    return ((flags & feature) != 0);\n}\n\n#define PyType_FastSubclass(type, flag) PyType_HasFeature((type), (flag))\n\nstatic inline int PyType_Check(PyObject *op) {\n    return PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_Check(op) PyType_Check(_PyObject_CAST(op))\n#endif\n\n#define _PyType_CAST(op) \\\n    (assert(PyType_Check(op)), _Py_CAST(PyTypeObject*, (op)))\n\nstatic inline int PyType_CheckExact(PyObject *op) {\n    return Py_IS_TYPE(op, &PyType_Type);\n}\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000\n#  define PyType_CheckExact(op) PyType_CheckExact(_PyObject_CAST(op))\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif   // !Py_OBJECT_H\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-deref-before-check",
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 648,
                                       "gcc/analyzer/saved_diagnostic/snode": 51,
                                       "gcc/analyzer/saved_diagnostic/sval": "CONJURED(exc_16 = _PyErr_GetRaisedException (tstate_12(D));, exc_16)",
                                       "gcc/analyzer/saved_diagnostic/state": "assumed-non-null (in frame: 'format_kwargs_error'@1)",
                                       "gcc/analyzer/saved_diagnostic/idx": 0},
                        "level": "warning",
                        "message": {"text": "check of 'exc' for NULL after already dereferencing it"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 2685,
                                                                       "startColumn": 12,
                                                                       "endColumn": 13},
                                                            "contextRegion": {"startLine": 2685,
                                                                              "snippet": {"text": "        if (exc && PyTuple_Check(args) && PyTuple_GET_SIZE(args) == 1) {\n"}}},
                                       "logicalLocations": [{"name": "format_kwargs_error",
                                                             "fullyQualifiedName": "format_kwargs_error",
                                                             "decoratedName": "format_kwargs_error",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 46,
                                                                                                                                 "dst_idx": 50,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2671,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 2671,
                                                                                                                           "snippet": {"text": "    if (_PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "format_kwargs_error",
                                                                                                          "fullyQualifiedName": "format_kwargs_error",
                                                                                                          "decoratedName": "format_kwargs_error",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 46,
                                                                                                                                 "dst_idx": 50,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2682,
                                                                                                                    "startColumn": 14,
                                                                                                                    "endColumn": 61},
                                                                                                         "contextRegion": {"startLine": 2682,
                                                                                                                           "snippet": {"text": "    else if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "format_kwargs_error",
                                                                                                          "fullyQualifiedName": "format_kwargs_error",
                                                                                                          "decoratedName": "format_kwargs_error",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 50,
                                                                                                                                 "dst_idx": 51,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2682,
                                                                                                                    "startColumn": 13,
                                                                                                                    "endColumn": 14},
                                                                                                         "contextRegion": {"startLine": 2682,
                                                                                                                           "snippet": {"text": "    else if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "format_kwargs_error",
                                                                                                          "fullyQualifiedName": "format_kwargs_error",
                                                                                                          "decoratedName": "format_kwargs_error",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 50,
                                                                                                                                 "dst_idx": 51,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2683,
                                                                                                                    "startColumn": 25,
                                                                                                                    "endColumn": 58},
                                                                                                         "contextRegion": {"startLine": 2683,
                                                                                                                           "snippet": {"text": "        PyObject *exc = _PyErr_GetRaisedException(tstate);\n"}}},
                                                                                    "logicalLocations": [{"name": "format_kwargs_error",
                                                                                                          "fullyQualifiedName": "format_kwargs_error",
                                                                                                          "decoratedName": "format_kwargs_error",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2684,
                                                                                                                    "startColumn": 19,
                                                                                                                    "endColumn": 23},
                                                                                                         "contextRegion": {"startLine": 2684,
                                                                                                                           "snippet": {"text": "        PyObject *args = ((PyBaseExceptionObject *)exc)->args;\n"}}},
                                                                                    "logicalLocations": [{"name": "format_kwargs_error",
                                                                                                          "fullyQualifiedName": "format_kwargs_error",
                                                                                                          "decoratedName": "format_kwargs_error",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "pointer 'exc' is dereferenced here"}},
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2685,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 2685,
                                                                                                                           "snippet": {"text": "        if (exc && PyTuple_Check(args) && PyTuple_GET_SIZE(args) == 1) {\n"}}},
                                                                                    "logicalLocations": [{"name": "format_kwargs_error",
                                                                                                          "fullyQualifiedName": "format_kwargs_error",
                                                                                                          "decoratedName": "format_kwargs_error",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "pointer 'exc' is checked for NULL here but it was already dereferenced at (5)"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 6}]}]}]},
                       {"ruleId": "-Wanalyzer-deref-before-check",
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 46139,
                                       "gcc/analyzer/saved_diagnostic/snode": 51,
                                       "gcc/analyzer/saved_diagnostic/sval": "CONJURED(exc_16 = _PyErr_GetRaisedException (tstate_12(D));, exc_16)",
                                       "gcc/analyzer/saved_diagnostic/state": "assumed-non-null (in frame: 'format_kwargs_error'@5)",
                                       "gcc/analyzer/saved_diagnostic/idx": 1},
                        "level": "warning",
                        "message": {"text": "check of 'exc' for NULL after already dereferencing it"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 2685,
                                                                       "startColumn": 12,
                                                                       "endColumn": 13},
                                                            "contextRegion": {"startLine": 2685,
                                                                              "snippet": {"text": "        if (exc && PyTuple_Check(args) && PyTuple_GET_SIZE(args) == 1) {\n"}}},
                                       "logicalLocations": [{"name": "format_kwargs_error",
                                                             "fullyQualifiedName": "format_kwargs_error",
                                                             "decoratedName": "format_kwargs_error",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1688,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 1688,
                                                                                                                           "snippet": {"text": "PyEval_EvalCodeEx(PyObject *_co, PyObject *globals, PyObject *locals,\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'PyEval_EvalCodeEx'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 526,
                                                                                                                                 "dst_idx": 527,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1697,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1697,
                                                                                                                           "snippet": {"text": "    if (defaults == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'defaults' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 526,
                                                                                                                                 "dst_idx": 527,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1700,
                                                                                                                    "startColumn": 26,
                                                                                                                    "endColumn": 70},
                                                                                                         "contextRegion": {"startLine": 1700,
                                                                                                                           "snippet": {"text": "    PyObject *builtins = _PyEval_BuiltinsFromGlobals(tstate, globals); // borrowed ref\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 527,
                                                                                                                                 "dst_idx": 530,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1701,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1701,
                                                                                                                           "snippet": {"text": "    if (builtins == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'builtins' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 527,
                                                                                                                                 "dst_idx": 530,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1705,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1705,
                                                                                                                           "snippet": {"text": "    if (locals == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 532,
                                                                                                                                 "dst_idx": 546,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1712,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1712,
                                                                                                                           "snippet": {"text": "    if (kwcount == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'kwcount == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 532,
                                                                                                                                 "dst_idx": 546,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1733,
                                                                                                                    "startColumn": 24,
                                                                                                                    "endColumn": 30},
                                                                                                         "contextRegion": {"startLine": 1733,
                                                                                                                           "snippet": {"text": "    PyFrameConstructor constr = {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 546,
                                                                                                                                 "dst_idx": 548,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1744,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1744,
                                                                                                                           "snippet": {"text": "    if (func == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'func' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 546,
                                                                                                                                 "dst_idx": 548,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1748,
                                                                                                                    "startColumn": 11,
                                                                                                                    "endLine": 1750,
                                                                                                                    "endColumn": 34},
                                                                                                         "contextRegion": {"startLine": 1748,
                                                                                                                           "endLine": 1750,
                                                                                                                           "snippet": {"text": "    res = _PyEval_Vector(tstate, func, locals,\n                         allargs, argcount,\n                         kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 548,
                                                                                                                                 "dst_idx": 556,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1748,
                                                                                                                    "startColumn": 11,
                                                                                                                    "endLine": 1750,
                                                                                                                    "endColumn": 34},
                                                                                                         "contextRegion": {"startLine": 1748,
                                                                                                                           "endLine": 1750,
                                                                                                                           "snippet": {"text": "    res = _PyEval_Vector(tstate, func, locals,\n                         allargs, argcount,\n                         kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "PyEval_EvalCodeEx",
                                                                                                          "fullyQualifiedName": "PyEval_EvalCodeEx",
                                                                                                          "decoratedName": "PyEval_EvalCodeEx",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyEval_Vector' from 'PyEval_EvalCodeEx'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1659,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1659,
                                                                                                                           "snippet": {"text": "_PyEval_Vector(PyThreadState *tstate, PyFunctionObject *func,\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyEval_Vector'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 11},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(12)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 565,
                                                                                                                                 "dst_idx": 572,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1671,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1671,
                                                                                                                           "snippet": {"text": "    if (kwnames) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'kwnames' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 12},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(13)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 565,
                                                                                                                                 "dst_idx": 572,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1677,
                                                                                                                    "startColumn": 34,
                                                                                                                    "endLine": 1678,
                                                                                                                    "endColumn": 55},
                                                                                                         "contextRegion": {"startLine": 1677,
                                                                                                                           "endLine": 1678,
                                                                                                                           "snippet": {"text": "    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n        tstate, func, locals, args, argcount, kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 13},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(14)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 572,
                                                                                                                                 "dst_idx": 606,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1677,
                                                                                                                    "startColumn": 34,
                                                                                                                    "endLine": 1678,
                                                                                                                    "endColumn": 55},
                                                                                                         "contextRegion": {"startLine": 1677,
                                                                                                                           "endLine": 1678,
                                                                                                                           "snippet": {"text": "    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n        tstate, func, locals, args, argcount, kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyEvalFramePushAndInit' from '_PyEval_Vector'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 14},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(15)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1583,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 24},
                                                                                                         "contextRegion": {"startLine": 1583,
                                                                                                                           "snippet": {"text": "_PyEvalFramePushAndInit(PyThreadState *tstate, PyFunctionObject *func,\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyEvalFramePushAndInit'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 15},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(16)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 607,
                                                                                                                                 "dst_idx": 609,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1590,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1590,
                                                                                                                           "snippet": {"text": "    if (frame == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'frame' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 16},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(17)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 607,
                                                                                                                                 "dst_idx": 609,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1593,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 54},
                                                                                                         "contextRegion": {"startLine": 1593,
                                                                                                                           "snippet": {"text": "    _PyFrame_Initialize(frame, func, locals, code, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 17},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(18)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 610,
                                                                                                                                 "dst_idx": 658,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1594,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 84},
                                                                                                         "contextRegion": {"startLine": 1594,
                                                                                                                           "snippet": {"text": "    if (initialize_locals(tstate, func, frame->localsplus, args, argcount, kwnames)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'initialize_locals' from '_PyEvalFramePushAndInit'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 18},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(19)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1315,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 1315,
                                                                                                                           "snippet": {"text": "initialize_locals(PyThreadState *tstate, PyFunctionObject *func,\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'initialize_locals'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 19},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(20)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 675,
                                                                                                                                 "dst_idx": 676,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1358,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 1358,
                                                                                                                           "snippet": {"text": "        if (argcount == n) {\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'n == argcount')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 20},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(21)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1359,
                                                                                                                    "startColumn": 17,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 1359,
                                                                                                                           "snippet": {"text": "            u = Py_NewRef(&_Py_SINGLETON(tuple_empty));\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to '_Py_NewRef' from 'initialize_locals'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 21},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(22)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 814,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 814,
                                                                                                                           "snippet": {"text": "    Py_INCREF(obj);\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_NewRef",
                                                                                                          "fullyQualifiedName": "_Py_NewRef",
                                                                                                          "decoratedName": "_Py_NewRef",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to 'Py_INCREF' from '_Py_NewRef'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 22},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(23)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "initialize_locals",
                                                                                                                                     "fullyQualifiedName": "initialize_locals",
                                                                                                                                     "decoratedName": "initialize_locals",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 4,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 675,
                                                                                                                                 "dst_idx": 676,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 641,
                                                                                                                    "startColumn": 17,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 641,
                                                                                                                           "snippet": {"text": "    PY_UINT32_T cur_refcnt = op->ob_refcnt_split[PY_BIG_ENDIAN];\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 6,
                                                                       "executionOrder": 23},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(24)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "initialize_locals",
                                                                                                                                     "fullyQualifiedName": "initialize_locals",
                                                                                                                                     "decoratedName": "initialize_locals",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 4,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 676,
                                                                                                                                 "dst_idx": 682,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/object.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 643,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 643,
                                                                                                                           "snippet": {"text": "    if (new_refcnt == 0) {\n"}}},
                                                                                    "logicalLocations": [{"name": "Py_INCREF",
                                                                                                          "fullyQualifiedName": "Py_INCREF",
                                                                                                          "decoratedName": "Py_INCREF",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch (when 'new_refcnt == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 6,
                                                                       "executionOrder": 24},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(25)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 676,
                                                                                                                                 "dst_idx": 682,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1368,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 1368,
                                                                                                                           "snippet": {"text": "        assert(localsplus[total_args] == NULL);\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 25},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(26)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 682,
                                                                                                                                 "dst_idx": 684,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1368,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 10},
                                                                                                         "contextRegion": {"startLine": 1368,
                                                                                                                           "snippet": {"text": "        assert(localsplus[total_args] == NULL);\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 26},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(27)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 682,
                                                                                                                                 "dst_idx": 684,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1369,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 35},
                                                                                                         "contextRegion": {"startLine": 1369,
                                                                                                                           "snippet": {"text": "        localsplus[total_args] = u;\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 27},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(28)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 690,
                                                                                                                                 "dst_idx": 730,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1379,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1379,
                                                                                                                           "snippet": {"text": "    if (kwnames != NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'kwnames' is NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 28},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(29)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 690,
                                                                                                                                 "dst_idx": 730,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1458,
                                                                                                                    "startColumn": 21,
                                                                                                                    "endColumn": 36},
                                                                                                         "contextRegion": {"startLine": 1458,
                                                                                                                           "snippet": {"text": "    if ((argcount > co->co_argcount) && !(co->co_flags & CO_VARARGS)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "initialize_locals",
                                                                                                          "fullyQualifiedName": "initialize_locals",
                                                                                                          "decoratedName": "initialize_locals",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 29},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(30)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 788,
                                                                                                                                 "dst_idx": 611,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1594,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 84},
                                                                                                         "contextRegion": {"startLine": 1594,
                                                                                                                           "snippet": {"text": "    if (initialize_locals(tstate, func, frame->localsplus, args, argcount, kwnames)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to '_PyEvalFramePushAndInit' from 'initialize_locals'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 30},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(31)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 611,
                                                                                                                                 "dst_idx": 626,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1594,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1594,
                                                                                                                           "snippet": {"text": "    if (initialize_locals(tstate, func, frame->localsplus, args, argcount, kwnames)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 31},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(32)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 611,
                                                                                                                                 "dst_idx": 626,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"logicalLocations": [{"name": "_PyEvalFramePushAndInit",
                                                                                                          "fullyQualifiedName": "_PyEvalFramePushAndInit",
                                                                                                          "decoratedName": "_PyEvalFramePushAndInit",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 32},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(33)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 627,
                                                                                                                                 "dst_idx": 573,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1677,
                                                                                                                    "startColumn": 34,
                                                                                                                    "endLine": 1678,
                                                                                                                    "endColumn": 55},
                                                                                                         "contextRegion": {"startLine": 1677,
                                                                                                                           "endLine": 1678,
                                                                                                                           "snippet": {"text": "    _PyInterpreterFrame *frame = _PyEvalFramePushAndInit(\n        tstate, func, locals, args, argcount, kwnames);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to '_PyEval_Vector' from '_PyEvalFramePushAndInit'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 33},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(34)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 573,
                                                                                                                                 "dst_idx": 574,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1679,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1679,
                                                                                                                           "snippet": {"text": "    if (frame == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'frame' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 34},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(35)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 573,
                                                                                                                                 "dst_idx": 574,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1683,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 47},
                                                                                                         "contextRegion": {"startLine": 1683,
                                                                                                                           "snippet": {"text": "    return _PyEval_EvalFrame(tstate, frame, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 35},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(36)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 574,
                                                                                                                                 "dst_idx": 5097,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1683,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 47},
                                                                                                         "contextRegion": {"startLine": 1683,
                                                                                                                           "snippet": {"text": "    return _PyEval_EvalFrame(tstate, frame, 0);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_Vector",
                                                                                                          "fullyQualifiedName": "_PyEval_Vector",
                                                                                                          "decoratedName": "_PyEval_Vector",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyEval_EvalFrame' from '_PyEval_Vector'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 36},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(37)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_ceval.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 85,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 85,
                                                                                                                           "snippet": {"text": "_PyEval_EvalFrame(PyThreadState *tstate, struct _PyInterpreterFrame *frame, int throwflag)\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrame",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrame",
                                                                                                          "decoratedName": "_PyEval_EvalFrame",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyEval_EvalFrame'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 37},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(38)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 5098,
                                                                                                                                 "dst_idx": 5099,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_ceval.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 88,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 88,
                                                                                                                           "snippet": {"text": "    if (tstate->interp->eval_frame == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrame",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrame",
                                                                                                          "decoratedName": "_PyEval_EvalFrame",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 38},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(39)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 5098,
                                                                                                                                 "dst_idx": 5099,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_ceval.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 89,
                                                                                                                    "startColumn": 16,
                                                                                                                    "endColumn": 66},
                                                                                                         "contextRegion": {"startLine": 89,
                                                                                                                           "snippet": {"text": "        return _PyEval_EvalFrameDefault(tstate, frame, throwflag);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrame",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrame",
                                                                                                          "decoratedName": "_PyEval_EvalFrame",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 39},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(40)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 5099,
                                                                                                                                 "dst_idx": 955,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_ceval.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 89,
                                                                                                                    "startColumn": 16,
                                                                                                                    "endColumn": 66},
                                                                                                         "contextRegion": {"startLine": 89,
                                                                                                                           "snippet": {"text": "        return _PyEval_EvalFrameDefault(tstate, frame, throwflag);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrame",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrame",
                                                                                                          "decoratedName": "_PyEval_EvalFrame",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyEval_EvalFrameDefault' from '_PyEval_EvalFrame'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 40},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(41)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 654,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 25},
                                                                                                         "contextRegion": {"startLine": 654,
                                                                                                                           "snippet": {"text": "_PyEval_EvalFrameDefault(PyThreadState *tstate, _PyInterpreterFrame *frame, int throwflag)\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyEval_EvalFrameDefault'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 41},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(42)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_INLINED_CALL"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 656,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 656,
                                                                                                                           "snippet": {"text": "    _Py_EnsureTstateNotNULL(tstate);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "inlined call to '_Py_EnsureFuncTstateNotNULL' from '_PyEval_EvalFrameDefault'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 42},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(43)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/checker_event/original_fndecl": {"name": "_PyEval_EvalFrameDefault",
                                                                                                                                     "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                                                     "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                                                     "kind": "function"},
                                                                                      "gcc/analyzer/checker_event/original_depth": 4,
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 956,
                                                                                                                                 "dst_idx": 958,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_pystate.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 107,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 107,
                                                                                                                           "snippet": {"text": "    if (tstate == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_Py_EnsureFuncTstateNotNULL",
                                                                                                          "fullyQualifiedName": "_Py_EnsureFuncTstateNotNULL",
                                                                                                          "decoratedName": "_Py_EnsureFuncTstateNotNULL",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'tstate' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 43},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(44)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 956,
                                                                                                                                 "dst_idx": 958,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 683,
                                                                                                                    "startColumn": 16,
                                                                                                                    "endColumn": 27},
                                                                                                         "contextRegion": {"startLine": 683,
                                                                                                                           "snippet": {"text": "    _PyCFrame *prev_cframe = tstate->cframe;\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 44},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(45)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 958,
                                                                                                                                 "dst_idx": 960,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 687,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 687,
                                                                                                                           "snippet": {"text": "    assert(tstate->interp->interpreter_trampoline != NULL);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 45},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(46)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 958,
                                                                                                                                 "dst_idx": 960,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 690,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 46},
                                                                                                         "contextRegion": {"startLine": 690,
                                                                                                                           "snippet": {"text": "    entry_frame.f_funcobj = (PyObject*)0xaaa0;\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 46},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(47)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 961,
                                                                                                                                 "dst_idx": 963,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 708,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 708,
                                                                                                                           "snippet": {"text": "    if (_Py_EnterRecursiveCallTstate(tstate, \"\")) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 47},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(48)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 961,
                                                                                                                                 "dst_idx": 963,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 715,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 715,
                                                                                                                           "snippet": {"text": "    if (throwflag) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 48},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(49)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 963,
                                                                                                                                 "dst_idx": 969,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 715,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 715,
                                                                                                                           "snippet": {"text": "    if (throwflag) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'throwflag == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 49},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(50)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 963,
                                                                                                                                 "dst_idx": 969,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 740,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 12},
                                                                                                         "contextRegion": {"startLine": 740,
                                                                                                                           "snippet": {"text": "start_frame:\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 50},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(51)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 970,
                                                                                                                                 "dst_idx": 972,
                                                                                                                                 "desc": "false (flags IRREDUCIBLE_LOOP | FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 741,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 741,
                                                                                                                           "snippet": {"text": "    if (_Py_EnterRecursivePy(tstate)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 51},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(52)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 970,
                                                                                                                                 "dst_idx": 972,
                                                                                                                                 "desc": "false (flags IRREDUCIBLE_LOOP | FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 745,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 745,
                                                                                                                           "snippet": {"text": "resume_frame:\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 52},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(53)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 972,
                                                                                                                                 "dst_idx": 974,
                                                                                                                                 "desc": "false (flags IRREDUCIBLE_LOOP | FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 746,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 746,
                                                                                                                           "snippet": {"text": "    SET_LOCALS_FROM_FRAME();\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 53},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(54)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 972,
                                                                                                                                 "dst_idx": 974,
                                                                                                                                 "desc": "false (flags IRREDUCIBLE_LOOP | FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 746,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 746,
                                                                                                                           "snippet": {"text": "    SET_LOCALS_FROM_FRAME();\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 54},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(55)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 977,
                                                                                                                                 "dst_idx": 980,
                                                                                                                                 "desc": "false (flags IRREDUCIBLE_LOOP | FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 757,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 757,
                                                                                                                           "snippet": {"text": "        if (lltrace) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'lltrace == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 55},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(56)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 977,
                                                                                                                                 "dst_idx": 980,
                                                                                                                                 "desc": "false (flags IRREDUCIBLE_LOOP | FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 767,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 767,
                                                                                                                           "snippet": {"text": "    assert(!_PyErr_Occurred(tstate));\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 56},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(57)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 980,
                                                                                                                                 "dst_idx": 5032,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 767,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 767,
                                                                                                                           "snippet": {"text": "    assert(!_PyErr_Occurred(tstate));\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling '_PyErr_Occurred' from '_PyEval_EvalFrameDefault'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 57},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(58)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_pyerrors.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 20,
                                                                                                                    "startColumn": 25,
                                                                                                                    "endColumn": 40},
                                                                                                         "contextRegion": {"startLine": 20,
                                                                                                                           "snippet": {"text": "static inline PyObject* _PyErr_Occurred(PyThreadState *tstate)\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyErr_Occurred",
                                                                                                          "fullyQualifiedName": "_PyErr_Occurred",
                                                                                                          "decoratedName": "_PyErr_Occurred",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to '_PyErr_Occurred'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 58},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(59)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 5033,
                                                                                                                                 "dst_idx": 5035,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_pyerrors.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 22,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 22,
                                                                                                                           "snippet": {"text": "    assert(tstate != NULL);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyErr_Occurred",
                                                                                                          "fullyQualifiedName": "_PyErr_Occurred",
                                                                                                          "decoratedName": "_PyErr_Occurred",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'tstate' is non-NULL)..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 59},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(60)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 5033,
                                                                                                                                 "dst_idx": 5035,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Include/internal/pycore_pyerrors.h",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 23,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 34},
                                                                                                         "contextRegion": {"startLine": 23,
                                                                                                                           "snippet": {"text": "    if (tstate->current_exception == NULL) {\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyErr_Occurred",
                                                                                                          "fullyQualifiedName": "_PyErr_Occurred",
                                                                                                          "decoratedName": "_PyErr_Occurred",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 60},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(61)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 5038,
                                                                                                                                 "dst_idx": 981,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 767,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 767,
                                                                                                                           "snippet": {"text": "    assert(!_PyErr_Occurred(tstate));\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to '_PyEval_EvalFrameDefault' from '_PyErr_Occurred'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 61},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(62)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 981,
                                                                                                                                 "dst_idx": 983,
                                                                                                                                 "desc": "false (flags IRREDUCIBLE_LOOP | FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 767,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 767,
                                                                                                                           "snippet": {"text": "    assert(!_PyErr_Occurred(tstate));\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 62},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(63)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 981,
                                                                                                                                 "dst_idx": 983,
                                                                                                                                 "desc": "false (flags IRREDUCIBLE_LOOP | FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 770,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 770,
                                                                                                                           "snippet": {"text": "    DISPATCH();\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 63},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(64)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 983,
                                                                                                                                 "dst_idx": 986,
                                                                                                                                 "desc": "false (flags IRREDUCIBLE_LOOP | FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 770,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 770,
                                                                                                                           "snippet": {"text": "    DISPATCH();\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch (when 'lltrace == 0')..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 64},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(65)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 983,
                                                                                                                                 "dst_idx": 986,
                                                                                                                                 "desc": "false (flags IRREDUCIBLE_LOOP | FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 770,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 770,
                                                                                                                           "snippet": {"text": "    DISPATCH();\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 65},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(66)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 2590,
                                                                                                                                 "dst_idx": 45,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/bytecodes.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1630,
                                                                                                                    "startColumn": 17,
                                                                                                                    "endColumn": 69},
                                                                                                         "contextRegion": {"startLine": 1630,
                                                                                                                           "snippet": {"text": "                format_kwargs_error(tstate, PEEK(3 + oparg), update);\n"}}},
                                                                                    "logicalLocations": [{"name": "_PyEval_EvalFrameDefault",
                                                                                                          "fullyQualifiedName": "_PyEval_EvalFrameDefault",
                                                                                                          "decoratedName": "_PyEval_EvalFrameDefault",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'format_kwargs_error' from '_PyEval_EvalFrameDefault'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 4,
                                                                       "executionOrder": 66},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(67)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2663,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 20},
                                                                                                         "contextRegion": {"startLine": 2663,
                                                                                                                           "snippet": {"text": "format_kwargs_error(PyThreadState *tstate, PyObject *func, PyObject *kwargs)\n"}}},
                                                                                    "logicalLocations": [{"name": "format_kwargs_error",
                                                                                                          "fullyQualifiedName": "format_kwargs_error",
                                                                                                          "decoratedName": "format_kwargs_error",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'format_kwargs_error'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 67},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(68)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 46,
                                                                                                                                 "dst_idx": 50,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2671,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 2671,
                                                                                                                           "snippet": {"text": "    if (_PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "format_kwargs_error",
                                                                                                          "fullyQualifiedName": "format_kwargs_error",
                                                                                                          "decoratedName": "format_kwargs_error",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 68},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(69)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 46,
                                                                                                                                 "dst_idx": 50,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2682,
                                                                                                                    "startColumn": 14,
                                                                                                                    "endColumn": 61},
                                                                                                         "contextRegion": {"startLine": 2682,
                                                                                                                           "snippet": {"text": "    else if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "format_kwargs_error",
                                                                                                          "fullyQualifiedName": "format_kwargs_error",
                                                                                                          "decoratedName": "format_kwargs_error",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 69},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(70)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 50,
                                                                                                                                 "dst_idx": 51,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2682,
                                                                                                                    "startColumn": 13,
                                                                                                                    "endColumn": 14},
                                                                                                         "contextRegion": {"startLine": 2682,
                                                                                                                           "snippet": {"text": "    else if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {\n"}}},
                                                                                    "logicalLocations": [{"name": "format_kwargs_error",
                                                                                                          "fullyQualifiedName": "format_kwargs_error",
                                                                                                          "decoratedName": "format_kwargs_error",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 70},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(71)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 50,
                                                                                                                                 "dst_idx": 51,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2683,
                                                                                                                    "startColumn": 25,
                                                                                                                    "endColumn": 58},
                                                                                                         "contextRegion": {"startLine": 2683,
                                                                                                                           "snippet": {"text": "        PyObject *exc = _PyErr_GetRaisedException(tstate);\n"}}},
                                                                                    "logicalLocations": [{"name": "format_kwargs_error",
                                                                                                          "fullyQualifiedName": "format_kwargs_error",
                                                                                                          "decoratedName": "format_kwargs_error",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 71},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(72)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2684,
                                                                                                                    "startColumn": 19,
                                                                                                                    "endColumn": 23},
                                                                                                         "contextRegion": {"startLine": 2684,
                                                                                                                           "snippet": {"text": "        PyObject *args = ((PyBaseExceptionObject *)exc)->args;\n"}}},
                                                                                    "logicalLocations": [{"name": "format_kwargs_error",
                                                                                                          "fullyQualifiedName": "format_kwargs_error",
                                                                                                          "decoratedName": "format_kwargs_error",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "pointer 'exc' is dereferenced here"}},
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 72},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(73)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Python/ceval.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 2685,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 13},
                                                                                                         "contextRegion": {"startLine": 2685,
                                                                                                                           "snippet": {"text": "        if (exc && PyTuple_Check(args) && PyTuple_GET_SIZE(args) == 1) {\n"}}},
                                                                                    "logicalLocations": [{"name": "format_kwargs_error",
                                                                                                          "fullyQualifiedName": "format_kwargs_error",
                                                                                                          "decoratedName": "format_kwargs_error",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "pointer 'exc' is checked for NULL here but it was already dereferenced at (72)"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 5,
                                                                       "executionOrder": 73}]}]}]}]}]}
