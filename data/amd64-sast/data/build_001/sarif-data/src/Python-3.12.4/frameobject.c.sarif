{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-deref-before-check",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-deref-before-check"}]}},
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.12.4/"}},
           "artifacts": [{"location": {"uri": "Objects/frameobject.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "/* Frame object implementation */\n\n#include \"Python.h\"\n#include \"pycore_ceval.h\"         // _PyEval_BuiltinsFromGlobals()\n#include \"pycore_code.h\"          // CO_FAST_LOCAL, etc.\n#include \"pycore_function.h\"      // _PyFunction_FromConstructor()\n#include \"pycore_moduleobject.h\"  // _PyModule_GetDict()\n#include \"pycore_object.h\"        // _PyObject_GC_UNTRACK()\n#include \"pycore_opcode.h\"        // _PyOpcode_Caches\n\n#include \"frameobject.h\"          // PyFrameObject\n#include \"pycore_frame.h\"\n#include \"opcode.h\"               // EXTENDED_ARG\n#include \"structmember.h\"         // PyMemberDef\n\n#define OFF(x) offsetof(PyFrameObject, x)\n\nstatic PyMemberDef frame_memberlist[] = {\n    {\"f_trace_lines\",   T_BOOL,         OFF(f_trace_lines), 0},\n    {NULL}      /* Sentinel */\n};\n\n\nstatic PyObject *\nframe_getlocals(PyFrameObject *f, void *closure)\n{\n    if (f == NULL) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n    assert(!_PyFrame_IsIncomplete(f->f_frame));\n    PyObject *locals = _PyFrame_GetLocals(f->f_frame, 1);\n    if (locals) {\n        f->f_fast_as_locals = 1;\n    }\n    return locals;\n}\n\nint\nPyFrame_GetLineNumber(PyFrameObject *f)\n{\n    assert(f != NULL);\n    if (f->f_lineno != 0) {\n        return f->f_lineno;\n    }\n    else {\n        return PyUnstable_InterpreterFrame_GetLine(f->f_frame);\n    }\n}\n\nstatic PyObject *\nframe_getlineno(PyFrameObject *f, void *closure)\n{\n    int lineno = PyFrame_GetLineNumber(f);\n    if (lineno < 0) {\n        Py_RETURN_NONE;\n    }\n    else {\n        return PyLong_FromLong(lineno);\n    }\n}\n\nstatic PyObject *\nframe_getlasti(PyFrameObject *f, void *closure)\n{\n    int lasti = _PyInterpreterFrame_LASTI(f->f_frame);\n    if (lasti < 0) {\n        return PyLong_FromLong(-1);\n    }\n    return PyLong_FromLong(lasti * sizeof(_Py_CODEUNIT));\n}\n\nstatic PyObject *\nframe_getglobals(PyFrameObject *f, void *closure)\n{\n    PyObject *globals = f->f_frame->f_globals;\n    if (globals == NULL) {\n        globals = Py_None;\n    }\n    return Py_NewRef(globals);\n}\n\nstatic PyObject *\nframe_getbuiltins(PyFrameObject *f, void *closure)\n{\n    PyObject *builtins = f->f_frame->f_builtins;\n    if (builtins == NULL) {\n        builtins = Py_None;\n    }\n    return Py_NewRef(builtins);\n}\n\nstatic PyObject *\nframe_getcode(PyFrameObject *f, void *closure)\n{\n    if (PySys_Audit(\"object.__getattr__\", \"Os\", f, \"f_code\") < 0) {\n        return NULL;\n    }\n    return (PyObject *)PyFrame_GetCode(f);\n}\n\nstatic PyObject *\nframe_getback(PyFrameObject *f, void *closure)\n{\n    PyObject *res = (PyObject *)PyFrame_GetBack(f);\n    if (res == NULL) {\n        Py_RETURN_NONE;\n    }\n    return res;\n}\n\nstatic PyObject *\nframe_gettrace_opcodes(PyFrameObject *f, void *closure)\n{\n    PyObject *result = f->f_trace_opcodes ? Py_True : Py_False;\n    return Py_NewRef(result);\n}\n\nstatic int\nframe_settrace_opcodes(PyFrameObject *f, PyObject* value, void *Py_UNUSED(ignored))\n{\n    if (!PyBool_Check(value)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"attribute value type must be bool\");\n        return -1;\n    }\n    if (value == Py_True) {\n        f->f_trace_opcodes = 1;\n        _PyInterpreterState_GET()->f_opcode_trace_set = true;\n    }\n    else {\n        f->f_trace_opcodes = 0;\n    }\n    return 0;\n}\n\n/* Model the evaluation stack, to determine which jumps\n * are safe and how many values needs to be popped.\n * The stack is modelled by a 64 integer, treating any\n * stack that can't fit into 64 bits as \"overflowed\".\n */\n\ntypedef enum kind {\n    Iterator = 1,\n    Except = 2,\n    Object = 3,\n    Null = 4,\n    Lasti = 5,\n} Kind;\n\nstatic int\ncompatible_kind(Kind from, Kind to) {\n    if (to == 0) {\n        return 0;\n    }\n    if (to == Object) {\n        return from != Null;\n    }\n    if (to == Null) {\n        return 1;\n    }\n    return from == to;\n}\n\n#define BITS_PER_BLOCK 3\n\n#define UNINITIALIZED -2\n#define OVERFLOWED -1\n\n#define MAX_STACK_ENTRIES (63/BITS_PER_BLOCK)\n#define WILL_OVERFLOW (1ULL<<((MAX_STACK_ENTRIES-1)*BITS_PER_BLOCK))\n\n#define EMPTY_STACK 0\n\nstatic inline int64_t\npush_value(int64_t stack, Kind kind)\n{\n    if (((uint64_t)stack) >= WILL_OVERFLOW) {\n        return OVERFLOWED;\n    }\n    else {\n        return (stack << BITS_PER_BLOCK) | kind;\n    }\n}\n\nstatic inline int64_t\npop_value(int64_t stack)\n{\n    return Py_ARITHMETIC_RIGHT_SHIFT(int64_t, stack, BITS_PER_BLOCK);\n}\n\n#define MASK ((1<<BITS_PER_BLOCK)-1)\n\nstatic inline Kind\ntop_of_stack(int64_t stack)\n{\n    return stack & MASK;\n}\n\nstatic inline Kind\npeek(int64_t stack, int n)\n{\n    assert(n >= 1);\n    return (stack>>(BITS_PER_BLOCK*(n-1))) & MASK;\n}\n\nstatic Kind\nstack_swap(int64_t stack, int n)\n{\n    assert(n >= 1);\n    Kind to_swap = peek(stack, n);\n    Kind top = top_of_stack(stack);\n    int shift = BITS_PER_BLOCK*(n-1);\n    int64_t replaced_low = (stack & ~(MASK << shift)) | (top << shift);\n    int64_t replaced_top = (replaced_low & ~MASK) | to_swap;\n    return replaced_top;\n}\n\nstatic int64_t\npop_to_level(int64_t stack, int level) {\n    if (level == 0) {\n        return EMPTY_STACK;\n    }\n    int64_t max_item = (1<<BITS_PER_BLOCK) - 1;\n    int64_t level_max_stack = max_item << ((level-1) * BITS_PER_BLOCK);\n    while (stack > level_max_stack) {\n        stack = pop_value(stack);\n    }\n    return stack;\n}\n\n#if 0\n/* These functions are useful for debugging the stack marking code */\n\nstatic char\ntos_char(int64_t stack) {\n    switch(top_of_stack(stack)) {\n        case Iterator:\n            return 'I';\n        case Except:\n            return 'E';\n        case Object:\n            return 'O';\n        case Lasti:\n            return 'L';\n        case Null:\n            return 'N';\n    }\n    return '?';\n}\n\nstatic void\nprint_stack(int64_t stack) {\n    if (stack < 0) {\n        if (stack == UNINITIALIZED) {\n            printf(\"---\");\n        }\n        else if (stack == OVERFLOWED) {\n            printf(\"OVERFLOWED\");\n        }\n        else {\n            printf(\"??\");\n        }\n        return;\n    }\n    while (stack) {\n        printf(\"%c\", tos_char(stack));\n        stack = pop_value(stack);\n    }\n}\n\nstatic void\nprint_stacks(int64_t *stacks, int n) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d: \", i);\n        print_stack(stacks[i]);\n        printf(\"\\n\");\n    }\n}\n\n#endif\n\nstatic int64_t *\nmark_stacks(PyCodeObject *code_obj, int len)\n{\n    PyObject *co_code = _PyCode_GetCode(code_obj);\n    if (co_code == NULL) {\n        return NULL;\n    }\n    _Py_CODEUNIT *code = (_Py_CODEUNIT *)PyBytes_AS_STRING(co_code);\n    int64_t *stacks = PyMem_New(int64_t, len+1);\n    int i, j, opcode;\n\n    if (stacks == NULL) {\n        PyErr_NoMemory();\n        Py_DECREF(co_code);\n        return NULL;\n    }\n    for (int i = 1; i <= len; i++) {\n        stacks[i] = UNINITIALIZED;\n    }\n    stacks[0] = EMPTY_STACK;\n    if (code_obj->co_flags & (CO_GENERATOR | CO_COROUTINE | CO_ASYNC_GENERATOR))\n    {\n        // Generators get sent None while starting:\n        stacks[0] = push_value(stacks[0], Object);\n    }\n    int todo = 1;\n    while (todo) {\n        todo = 0;\n        /* Scan instructions */\n        for (i = 0; i < len;) {\n            int64_t next_stack = stacks[i];\n            opcode = _Py_GetBaseOpcode(code_obj, i);\n            int oparg = 0;\n            while (opcode == EXTENDED_ARG) {\n                oparg = (oparg << 8) | code[i].op.arg;\n                i++;\n                opcode = _Py_GetBaseOpcode(code_obj, i);\n                stacks[i] = next_stack;\n            }\n            int next_i = i + _PyOpcode_Caches[opcode] + 1;\n            if (next_stack == UNINITIALIZED) {\n                i = next_i;\n                continue;\n            }\n            oparg = (oparg << 8) | code[i].op.arg;\n            switch (opcode) {\n                case POP_JUMP_IF_FALSE:\n                case POP_JUMP_IF_TRUE:\n                case POP_JUMP_IF_NONE:\n                case POP_JUMP_IF_NOT_NONE:\n                {\n                    int64_t target_stack;\n                    int j = next_i + oparg;\n                    assert(j < len);\n                    next_stack = pop_value(next_stack);\n                    target_stack = next_stack;\n                    assert(stacks[j] == UNINITIALIZED || stacks[j] == target_stack);\n                    stacks[j] = target_stack;\n                    stacks[next_i] = next_stack;\n                    break;\n                }\n                case SEND:\n                    j = oparg + i + INLINE_CACHE_ENTRIES_SEND + 1;\n                    assert(j < len);\n                    assert(stacks[j] == UNINITIALIZED || stacks[j] == next_stack);\n                    stacks[j] = next_stack;\n                    stacks[next_i] = next_stack;\n                    break;\n                case JUMP_FORWARD:\n                    j = oparg + i + 1;\n                    assert(j < len);\n                    assert(stacks[j] == UNINITIALIZED || stacks[j] == next_stack);\n                    stacks[j] = next_stack;\n                    break;\n                case JUMP_BACKWARD:\n                case JUMP_BACKWARD_NO_INTERRUPT:\n                    j = i + 1 - oparg;\n                    assert(j >= 0);\n                    assert(j < len);\n                    if (stacks[j] == UNINITIALIZED && j < i) {\n                        todo = 1;\n                    }\n                    assert(stacks[j] == UNINITIALIZED || stacks[j] == next_stack);\n                    stacks[j] = next_stack;\n                    break;\n                case GET_ITER:\n                case GET_AITER:\n                    next_stack = push_value(pop_value(next_stack), Iterator);\n                    stacks[next_i] = next_stack;\n                    break;\n                case FOR_ITER:\n                {\n                    int64_t target_stack = push_value(next_stack, Object);\n                    stacks[next_i] = target_stack;\n                    j = oparg + 1 + INLINE_CACHE_ENTRIES_FOR_ITER + i;\n                    assert(j < len);\n                    assert(stacks[j] == UNINITIALIZED || stacks[j] == target_stack);\n                    stacks[j] = target_stack;\n                    break;\n                }\n                case END_ASYNC_FOR:\n                    next_stack = pop_value(pop_value(next_stack));\n                    stacks[next_i] = next_stack;\n                    break;\n                case PUSH_EXC_INFO:\n                    next_stack = push_value(next_stack, Except);\n                    stacks[next_i] = next_stack;\n                    break;\n                case POP_EXCEPT:\n                    assert(top_of_stack(next_stack) == Except);\n                    next_stack = pop_value(next_stack);\n                    stacks[next_i] = next_stack;\n                    break;\n                case RETURN_VALUE:\n                    assert(pop_value(next_stack) == EMPTY_STACK);\n                    assert(top_of_stack(next_stack) == Object);\n                    break;\n                case RETURN_CONST:\n                    break;\n                case RAISE_VARARGS:\n                    break;\n                case RERAISE:\n                    assert(top_of_stack(next_stack) == Except);\n                    /* End of block */\n                    break;\n                case PUSH_NULL:\n                    next_stack = push_value(next_stack, Null);\n                    stacks[next_i] = next_stack;\n                    break;\n                case LOAD_GLOBAL:\n                {\n                    int j = oparg;\n                    if (j & 1) {\n                        next_stack = push_value(next_stack, Null);\n                    }\n                    next_stack = push_value(next_stack, Object);\n                    stacks[next_i] = next_stack;\n                    break;\n                }\n                case LOAD_ATTR:\n                {\n                    assert(top_of_stack(next_stack) == Object);\n                    int j = oparg;\n                    if (j & 1) {\n                        next_stack = pop_value(next_stack);\n                        next_stack = push_value(next_stack, Null);\n                        next_stack = push_value(next_stack, Object);\n                    }\n                    stacks[next_i] = next_stack;\n                    break;\n                }\n                case CALL:\n                {\n                    int args = oparg;\n                    for (int j = 0; j < args+2; j++) {\n                        next_stack = pop_value(next_stack);\n                    }\n                    next_stack = push_value(next_stack, Object);\n                    stacks[next_i] = next_stack;\n                    break;\n                }\n                case SWAP:\n                {\n                    int n = oparg;\n                    next_stack = stack_swap(next_stack, n);\n                    stacks[next_i] = next_stack;\n                    break;\n                }\n                case COPY:\n                {\n                    int n = oparg;\n                    next_stack = push_value(next_stack, peek(next_stack, n));\n                    stacks[next_i] = next_stack;\n                    break;\n                }\n                case CACHE:\n                case RESERVED:\n                {\n                    assert(0);\n                }\n                default:\n                {\n                    int delta = PyCompile_OpcodeStackEffect(opcode, oparg);\n                    assert(delta != PY_INVALID_STACK_EFFECT);\n                    while (delta < 0) {\n                        next_stack = pop_value(next_stack);\n                        delta++;\n                    }\n                    while (delta > 0) {\n                        next_stack = push_value(next_stack, Object);\n                        delta--;\n                    }\n                    stacks[next_i] = next_stack;\n                }\n            }\n            i = next_i;\n        }\n        /* Scan exception table */\n        unsigned char *start = (unsigned char *)PyBytes_AS_STRING(code_obj->co_exceptiontable);\n        unsigned char *end = start + PyBytes_GET_SIZE(code_obj->co_exceptiontable);\n        unsigned char *scan = start;\n        while (scan < end) {\n            int start_offset, size, handler;\n            scan = parse_varint(scan, &start_offset);\n            assert(start_offset >= 0 && start_offset < len);\n            scan = parse_varint(scan, &size);\n            assert(size >= 0 && start_offset+size <= len);\n            scan = parse_varint(scan, &handler);\n            assert(handler >= 0 && handler < len);\n            int depth_and_lasti;\n            scan = parse_varint(scan, &depth_and_lasti);\n            int level = depth_and_lasti >> 1;\n            int lasti = depth_and_lasti & 1;\n            if (stacks[start_offset] != UNINITIALIZED) {\n                if (stacks[handler] == UNINITIALIZED) {\n                    todo = 1;\n                    uint64_t target_stack = pop_to_level(stacks[start_offset], level);\n                    if (lasti) {\n                        target_stack = push_value(target_stack, Lasti);\n                    }\n                    target_stack = push_value(target_stack, Except);\n                    stacks[handler] = target_stack;\n                }\n            }\n        }\n    }\n    Py_DECREF(co_code);\n    return stacks;\n}\n\nstatic int\ncompatible_stack(int64_t from_stack, int64_t to_stack)\n{\n    if (from_stack < 0 || to_stack < 0) {\n        return 0;\n    }\n    while(from_stack > to_stack) {\n        from_stack = pop_value(from_stack);\n    }\n    while(from_stack) {\n        Kind from_top = top_of_stack(from_stack);\n        Kind to_top = top_of_stack(to_stack);\n        if (!compatible_kind(from_top, to_top)) {\n            return 0;\n        }\n        from_stack = pop_value(from_stack);\n        to_stack = pop_value(to_stack);\n    }\n    return to_stack == 0;\n}\n\nstatic const char *\nexplain_incompatible_stack(int64_t to_stack)\n{\n    assert(to_stack != 0);\n    if (to_stack == OVERFLOWED) {\n        return \"stack is too deep to analyze\";\n    }\n    if (to_stack == UNINITIALIZED) {\n        return \"can't jump into an exception handler, or code may be unreachable\";\n    }\n    Kind target_kind = top_of_stack(to_stack);\n    switch(target_kind) {\n        case Except:\n            return \"can't jump into an 'except' block as there's no exception\";\n        case Lasti:\n            return \"can't jump into a re-raising block as there's no location\";\n        case Object:\n        case Null:\n            return \"incompatible stacks\";\n        case Iterator:\n            return \"can't jump into the body of a for loop\";\n        default:\n            Py_UNREACHABLE();\n    }\n}\n\nstatic int *\nmarklines(PyCodeObject *code, int len)\n{\n    PyCodeAddressRange bounds;\n    _PyCode_InitAddressRange(code, &bounds);\n    assert (bounds.ar_end == 0);\n    int last_line = -1;\n\n    int *linestarts = PyMem_New(int, len);\n    if (linestarts == NULL) {\n        return NULL;\n    }\n    for (int i = 0; i < len; i++) {\n        linestarts[i] = -1;\n    }\n\n    while (_PyLineTable_NextAddressRange(&bounds)) {\n        assert(bounds.ar_start / (int)sizeof(_Py_CODEUNIT) < len);\n        if (bounds.ar_line != last_line && bounds.ar_line != -1) {\n            linestarts[bounds.ar_start / sizeof(_Py_CODEUNIT)] = bounds.ar_line;\n            last_line = bounds.ar_line;\n        }\n    }\n    return linestarts;\n}\n\nstatic int\nfirst_line_not_before(int *lines, int len, int line)\n{\n    int result = INT_MAX;\n    for (int i = 0; i < len; i++) {\n        if (lines[i] < result && lines[i] >= line) {\n            result = lines[i];\n        }\n    }\n    if (result == INT_MAX) {\n        return -1;\n    }\n    return result;\n}\n\nstatic PyFrameState\n_PyFrame_GetState(PyFrameObject *frame)\n{\n    assert(!_PyFrame_IsIncomplete(frame->f_frame));\n    if (frame->f_frame->stacktop == 0) {\n        return FRAME_CLEARED;\n    }\n    switch(frame->f_frame->owner) {\n        case FRAME_OWNED_BY_GENERATOR:\n        {\n            PyGenObject *gen = _PyFrame_GetGenerator(frame->f_frame);\n            return gen->gi_frame_state;\n        }\n        case FRAME_OWNED_BY_THREAD:\n        {\n            if (_PyInterpreterFrame_LASTI(frame->f_frame) < 0) {\n                return FRAME_CREATED;\n            }\n            switch (frame->f_frame->prev_instr->op.code)\n            {\n                case COPY_FREE_VARS:\n                case MAKE_CELL:\n                case RETURN_GENERATOR:\n                    /* Frame not fully initialized */\n                    return FRAME_CREATED;\n                default:\n                    return FRAME_EXECUTING;\n            }\n        }\n        case FRAME_OWNED_BY_FRAME_OBJECT:\n            return FRAME_COMPLETED;\n    }\n    Py_UNREACHABLE();\n}\n\n/* Setter for f_lineno - you can set f_lineno from within a trace function in\n * order to jump to a given line of code, subject to some restrictions.  Most\n * lines are OK to jump to because they don't make any assumptions about the\n * state of the stack (obvious because you could remove the line and the code\n * would still work without any stack errors), but there are some constructs\n * that limit jumping:\n *\n *  o Any exception handlers.\n *  o 'for' and 'async for' loops can't be jumped into because the\n *    iterator needs to be on the stack.\n *  o Jumps cannot be made from within a trace function invoked with a\n *    'return' or 'exception' event since the eval loop has been exited at\n *    that time.\n */\nstatic int\nframe_setlineno(PyFrameObject *f, PyObject* p_new_lineno, void *Py_UNUSED(ignored))\n{\n    if (p_new_lineno == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"cannot delete attribute\");\n        return -1;\n    }\n    /* f_lineno must be an integer. */\n    if (!PyLong_CheckExact(p_new_lineno)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"lineno must be an integer\");\n        return -1;\n    }\n\n    PyFrameState state = _PyFrame_GetState(f);\n    /*\n     * This code preserves the historical restrictions on\n     * setting the line number of a frame.\n     * Jumps are forbidden on a 'return' trace event (except after a yield).\n     * Jumps from 'call' trace events are also forbidden.\n     * In addition, jumps are forbidden when not tracing,\n     * as this is a debugging feature.\n     */\n    int what_event = PyThreadState_GET()->what_event;\n    if (what_event < 0) {\n        PyErr_Format(PyExc_ValueError,\n                    \"f_lineno can only be set in a trace function\");\n        return -1;\n    }\n    switch (what_event) {\n        case PY_MONITORING_EVENT_PY_RESUME:\n        case PY_MONITORING_EVENT_JUMP:\n        case PY_MONITORING_EVENT_BRANCH:\n        case PY_MONITORING_EVENT_LINE:\n        case PY_MONITORING_EVENT_PY_YIELD:\n            /* Setting f_lineno is allowed for the above events */\n            break;\n        case PY_MONITORING_EVENT_PY_START:\n            PyErr_Format(PyExc_ValueError,\n                     \"can't jump from the 'call' trace event of a new frame\");\n            return -1;\n        case PY_MONITORING_EVENT_CALL:\n        case PY_MONITORING_EVENT_C_RETURN:\n            PyErr_SetString(PyExc_ValueError,\n                \"can't jump during a call\");\n            return -1;\n        case PY_MONITORING_EVENT_PY_RETURN:\n        case PY_MONITORING_EVENT_PY_UNWIND:\n        case PY_MONITORING_EVENT_PY_THROW:\n        case PY_MONITORING_EVENT_RAISE:\n        case PY_MONITORING_EVENT_C_RAISE:\n        case PY_MONITORING_EVENT_INSTRUCTION:\n        case PY_MONITORING_EVENT_EXCEPTION_HANDLED:\n            PyErr_Format(PyExc_ValueError,\n                \"can only jump from a 'line' trace event\");\n            return -1;\n        default:\n            PyErr_SetString(PyExc_SystemError,\n                \"unexpected event type\");\n            return -1;\n    }\n\n    int new_lineno;\n\n    /* Fail if the line falls outside the code block and\n        select first line with actual code. */\n    int overflow;\n    long l_new_lineno = PyLong_AsLongAndOverflow(p_new_lineno, &overflow);\n    if (overflow\n#if SIZEOF_LONG > SIZEOF_INT\n        || l_new_lineno > INT_MAX\n        || l_new_lineno < INT_MIN\n#endif\n    ) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"lineno out of range\");\n        return -1;\n    }\n    new_lineno = (int)l_new_lineno;\n\n    if (new_lineno < f->f_frame->f_code->co_firstlineno) {\n        PyErr_Format(PyExc_ValueError,\n                    \"line %d comes before the current code block\",\n                    new_lineno);\n        return -1;\n    }\n\n    /* PyCode_NewWithPosOnlyArgs limits co_code to be under INT_MAX so this\n     * should never overflow. */\n    int len = (int)Py_SIZE(f->f_frame->f_code);\n    int *lines = marklines(f->f_frame->f_code, len);\n    if (lines == NULL) {\n        return -1;\n    }\n\n    new_lineno = first_line_not_before(lines, len, new_lineno);\n    if (new_lineno < 0) {\n        PyErr_Format(PyExc_ValueError,\n                    \"line %d comes after the current code block\",\n                    (int)l_new_lineno);\n        PyMem_Free(lines);\n        return -1;\n    }\n\n    int64_t *stacks = mark_stacks(f->f_frame->f_code, len);\n    if (stacks == NULL) {\n        PyMem_Free(lines);\n        return -1;\n    }\n\n    int64_t best_stack = OVERFLOWED;\n    int best_addr = -1;\n    int64_t start_stack = stacks[_PyInterpreterFrame_LASTI(f->f_frame)];\n    int err = -1;\n    const char *msg = \"cannot find bytecode for specified line\";\n    for (int i = 0; i < len; i++) {\n        if (lines[i] == new_lineno) {\n            int64_t target_stack = stacks[i];\n            if (compatible_stack(start_stack, target_stack)) {\n                err = 0;\n                if (target_stack > best_stack) {\n                    best_stack = target_stack;\n                    best_addr = i;\n                }\n            }\n            else if (err < 0) {\n                if (start_stack == OVERFLOWED) {\n                    msg = \"stack to deep to analyze\";\n                }\n                else if (start_stack == UNINITIALIZED) {\n                    msg = \"can't jump from unreachable code\";\n                }\n                else {\n                    msg = explain_incompatible_stack(target_stack);\n                    err = 1;\n                }\n            }\n        }\n    }\n    PyMem_Free(stacks);\n    PyMem_Free(lines);\n    if (err) {\n        PyErr_SetString(PyExc_ValueError, msg);\n        return -1;\n    }\n    // Populate any NULL locals that the compiler might have \"proven\" to exist\n    // in the new location. Rather than crashing or changing co_code, just bind\n    // None instead:\n    int unbound = 0;\n    for (int i = 0; i < f->f_frame->f_code->co_nlocalsplus; i++) {\n        // Counting every unbound local is overly-cautious, but a full flow\n        // analysis (like we do in the compiler) is probably too expensive:\n        unbound += f->f_frame->localsplus[i] == NULL;\n    }\n    if (unbound) {\n        const char *e = \"assigning None to %d unbound local%s\";\n        const char *s = (unbound == 1) ? \"\" : \"s\";\n        if (PyErr_WarnFormat(PyExc_RuntimeWarning, 0, e, unbound, s)) {\n            return -1;\n        }\n        // Do this in a second pass to avoid writing a bunch of Nones when\n        // warnings are being treated as errors and the previous bit raises:\n        for (int i = 0; i < f->f_frame->f_code->co_nlocalsplus; i++) {\n            if (f->f_frame->localsplus[i] == NULL) {\n                f->f_frame->localsplus[i] = Py_NewRef(Py_None);\n                unbound--;\n            }\n        }\n        assert(unbound == 0);\n    }\n    if (state == FRAME_SUSPENDED) {\n        /* Account for value popped by yield */\n        start_stack = pop_value(start_stack);\n    }\n    while (start_stack > best_stack) {\n        if (top_of_stack(start_stack) == Except) {\n            /* Pop exception stack as well as the evaluation stack */\n            PyThreadState *tstate = _PyThreadState_GET();\n            _PyErr_StackItem *exc_info = tstate->exc_info;\n            PyObject *value = exc_info->exc_value;\n            PyObject *exc = _PyFrame_StackPop(f->f_frame);\n            assert(PyExceptionInstance_Check(exc) || exc == Py_None);\n            exc_info->exc_value = exc;\n            Py_XDECREF(value);\n        }\n        else {\n            PyObject *v = _PyFrame_StackPop(f->f_frame);\n            Py_XDECREF(v);\n        }\n        start_stack = pop_value(start_stack);\n    }\n    /* Finally set the new lasti and return OK. */\n    f->f_lineno = 0;\n    f->f_frame->prev_instr = _PyCode_CODE(f->f_frame->f_code) + best_addr;\n    return 0;\n}\n\nstatic PyObject *\nframe_gettrace(PyFrameObject *f, void *closure)\n{\n    PyObject* trace = f->f_trace;\n    if (trace == NULL)\n        trace = Py_None;\n    return Py_NewRef(trace);\n}\n\nstatic int\nframe_settrace(PyFrameObject *f, PyObject* v, void *closure)\n{\n    if (v == Py_None) {\n        v = NULL;\n    }\n    if (v != f->f_trace) {\n        Py_XSETREF(f->f_trace, Py_XNewRef(v));\n    }\n    return 0;\n}\n\n\nstatic PyGetSetDef frame_getsetlist[] = {\n    {\"f_back\",          (getter)frame_getback, NULL, NULL},\n    {\"f_locals\",        (getter)frame_getlocals, NULL, NULL},\n    {\"f_lineno\",        (getter)frame_getlineno,\n                    (setter)frame_setlineno, NULL},\n    {\"f_trace\",         (getter)frame_gettrace, (setter)frame_settrace, NULL},\n    {\"f_lasti\",         (getter)frame_getlasti, NULL, NULL},\n    {\"f_globals\",       (getter)frame_getglobals, NULL, NULL},\n    {\"f_builtins\",      (getter)frame_getbuiltins, NULL, NULL},\n    {\"f_code\",          (getter)frame_getcode, NULL, NULL},\n    {\"f_trace_opcodes\", (getter)frame_gettrace_opcodes, (setter)frame_settrace_opcodes, NULL},\n    {0}\n};\n\nstatic void\nframe_dealloc(PyFrameObject *f)\n{\n    /* It is the responsibility of the owning generator/coroutine\n     * to have cleared the generator pointer */\n\n    if (_PyObject_GC_IS_TRACKED(f)) {\n        _PyObject_GC_UNTRACK(f);\n    }\n\n    Py_TRASHCAN_BEGIN(f, frame_dealloc);\n    PyCodeObject *co = NULL;\n\n    /* GH-106092: If f->f_frame was on the stack and we reached the maximum\n     * nesting depth for deallocations, the trashcan may have delayed this\n     * deallocation until after f->f_frame is freed. Avoid dereferencing\n     * f->f_frame unless we know it still points to valid memory. */\n    _PyInterpreterFrame *frame = (_PyInterpreterFrame *)f->_f_frame_data;\n\n    /* Kill all local variables including specials, if we own them */\n    if (f->f_frame == frame && frame->owner == FRAME_OWNED_BY_FRAME_OBJECT) {\n        /* Don't clear code object until the end */\n        co = frame->f_code;\n        frame->f_code = NULL;\n        Py_CLEAR(frame->f_funcobj);\n        Py_CLEAR(frame->f_locals);\n        PyObject **locals = _PyFrame_GetLocalsArray(frame);\n        for (int i = 0; i < frame->stacktop; i++) {\n            Py_CLEAR(locals[i]);\n        }\n    }\n    Py_CLEAR(f->f_back);\n    Py_CLEAR(f->f_trace);\n    PyObject_GC_Del(f);\n    Py_XDECREF(co);\n    Py_TRASHCAN_END;\n}\n\nstatic int\nframe_traverse(PyFrameObject *f, visitproc visit, void *arg)\n{\n    Py_VISIT(f->f_back);\n    Py_VISIT(f->f_trace);\n    if (f->f_frame->owner != FRAME_OWNED_BY_FRAME_OBJECT) {\n        return 0;\n    }\n    assert(f->f_frame->frame_obj == NULL);\n    return _PyFrame_Traverse(f->f_frame, visit, arg);\n}\n\nstatic int\nframe_tp_clear(PyFrameObject *f)\n{\n    Py_CLEAR(f->f_trace);\n\n    /* locals and stack */\n    PyObject **locals = _PyFrame_GetLocalsArray(f->f_frame);\n    assert(f->f_frame->stacktop >= 0);\n    for (int i = 0; i < f->f_frame->stacktop; i++) {\n        Py_CLEAR(locals[i]);\n    }\n    f->f_frame->stacktop = 0;\n    return 0;\n}\n\nstatic PyObject *\nframe_clear(PyFrameObject *f, PyObject *Py_UNUSED(ignored))\n{\n    if (f->f_frame->owner == FRAME_OWNED_BY_GENERATOR) {\n        PyGenObject *gen = _PyFrame_GetGenerator(f->f_frame);\n        if (gen->gi_frame_state == FRAME_EXECUTING) {\n            goto running;\n        }\n        _PyGen_Finalize((PyObject *)gen);\n    }\n    else if (f->f_frame->owner == FRAME_OWNED_BY_THREAD) {\n        goto running;\n    }\n    else {\n        assert(f->f_frame->owner == FRAME_OWNED_BY_FRAME_OBJECT);\n        (void)frame_tp_clear(f);\n    }\n    Py_RETURN_NONE;\nrunning:\n    PyErr_SetString(PyExc_RuntimeError,\n                    \"cannot clear an executing frame\");\n    return NULL;\n}\n\nPyDoc_STRVAR(clear__doc__,\n\"F.clear(): clear most references held by the frame\");\n\nstatic PyObject *\nframe_sizeof(PyFrameObject *f, PyObject *Py_UNUSED(ignored))\n{\n    Py_ssize_t res;\n    res = offsetof(PyFrameObject, _f_frame_data) + offsetof(_PyInterpreterFrame, localsplus);\n    PyCodeObject *code = f->f_frame->f_code;\n    res += _PyFrame_NumSlotsForCodeObject(code) * sizeof(PyObject *);\n    return PyLong_FromSsize_t(res);\n}\n\nPyDoc_STRVAR(sizeof__doc__,\n\"F.__sizeof__() -> size of F in memory, in bytes\");\n\nstatic PyObject *\nframe_repr(PyFrameObject *f)\n{\n    int lineno = PyFrame_GetLineNumber(f);\n    PyCodeObject *code = f->f_frame->f_code;\n    return PyUnicode_FromFormat(\n        \"<frame at %p, file %R, line %d, code %S>\",\n        f, code->co_filename, lineno, code->co_name);\n}\n\nstatic PyMethodDef frame_methods[] = {\n    {\"clear\",           (PyCFunction)frame_clear,       METH_NOARGS,\n     clear__doc__},\n    {\"__sizeof__\",      (PyCFunction)frame_sizeof,      METH_NOARGS,\n     sizeof__doc__},\n    {NULL,              NULL}   /* sentinel */\n};\n\nPyTypeObject PyFrame_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"frame\",\n    offsetof(PyFrameObject, _f_frame_data) +\n    offsetof(_PyInterpreterFrame, localsplus),\n    sizeof(PyObject *),\n    (destructor)frame_dealloc,                  /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    (reprfunc)frame_repr,                       /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    PyObject_GenericSetAttr,                    /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)frame_traverse,               /* tp_traverse */\n    (inquiry)frame_tp_clear,                    /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    frame_methods,                              /* tp_methods */\n    frame_memberlist,                           /* tp_members */\n    frame_getsetlist,                           /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n};\n\nstatic void\ninit_frame(_PyInterpreterFrame *frame, PyFunctionObject *func, PyObject *locals)\n{\n    PyCodeObject *code = (PyCodeObject *)func->func_code;\n    _PyFrame_Initialize(frame, (PyFunctionObject*)Py_NewRef(func),\n                        Py_XNewRef(locals), code, 0);\n    frame->previous = NULL;\n}\n\nPyFrameObject*\n_PyFrame_New_NoTrack(PyCodeObject *code)\n{\n    CALL_STAT_INC(frame_objects_created);\n    int slots = code->co_nlocalsplus + code->co_stacksize;\n    PyFrameObject *f = PyObject_GC_NewVar(PyFrameObject, &PyFrame_Type, slots);\n    if (f == NULL) {\n        return NULL;\n    }\n    f->f_back = NULL;\n    f->f_trace = NULL;\n    f->f_trace_lines = 1;\n    f->f_trace_opcodes = 0;\n    f->f_fast_as_locals = 0;\n    f->f_lineno = 0;\n    return f;\n}\n\n/* Legacy API */\nPyFrameObject*\nPyFrame_New(PyThreadState *tstate, PyCodeObject *code,\n            PyObject *globals, PyObject *locals)\n{\n    PyObject *builtins = _PyEval_BuiltinsFromGlobals(tstate, globals); // borrowed ref\n    if (builtins == NULL) {\n        return NULL;\n    }\n    PyFrameConstructor desc = {\n        .fc_globals = globals,\n        .fc_builtins = builtins,\n        .fc_name = code->co_name,\n        .fc_qualname = code->co_name,\n        .fc_code = (PyObject *)code,\n        .fc_defaults = NULL,\n        .fc_kwdefaults = NULL,\n        .fc_closure = NULL\n    };\n    PyFunctionObject *func = _PyFunction_FromConstructor(&desc);\n    if (func == NULL) {\n        return NULL;\n    }\n    PyFrameObject *f = _PyFrame_New_NoTrack(code);\n    if (f == NULL) {\n        Py_DECREF(func);\n        return NULL;\n    }\n    init_frame((_PyInterpreterFrame *)f->_f_frame_data, func, locals);\n    f->f_frame = (_PyInterpreterFrame *)f->_f_frame_data;\n    f->f_frame->owner = FRAME_OWNED_BY_FRAME_OBJECT;\n    // This frame needs to be \"complete\", so pretend that the first RESUME ran:\n    f->f_frame->prev_instr = _PyCode_CODE(code) + code->_co_firsttraceable;\n    assert(!_PyFrame_IsIncomplete(f->f_frame));\n    Py_DECREF(func);\n    _PyObject_GC_TRACK(f);\n    return f;\n}\n\nstatic int\n_PyFrame_OpAlreadyRan(_PyInterpreterFrame *frame, int opcode, int oparg)\n{\n    // This only works when opcode is a non-quickened form:\n    assert(_PyOpcode_Deopt[opcode] == opcode);\n    int check_oparg = 0;\n    for (_Py_CODEUNIT *instruction = _PyCode_CODE(frame->f_code);\n         instruction < frame->prev_instr; instruction++)\n    {\n        int check_opcode = _PyOpcode_Deopt[instruction->op.code];\n        check_oparg |= instruction->op.arg;\n        if (check_opcode == opcode && check_oparg == oparg) {\n            return 1;\n        }\n        if (check_opcode == EXTENDED_ARG) {\n            check_oparg <<= 8;\n        }\n        else {\n            check_oparg = 0;\n        }\n        instruction += _PyOpcode_Caches[check_opcode];\n    }\n    return 0;\n}\n\n\n// Initialize frame free variables if needed\nstatic void\nframe_init_get_vars(_PyInterpreterFrame *frame)\n{\n    // COPY_FREE_VARS has no quickened forms, so no need to use _PyOpcode_Deopt\n    // here:\n    PyCodeObject *co = frame->f_code;\n    int lasti = _PyInterpreterFrame_LASTI(frame);\n    if (!(lasti < 0 && _PyCode_CODE(co)->op.code == COPY_FREE_VARS\n          && PyFunction_Check(frame->f_funcobj)))\n    {\n        /* Free vars are initialized */\n        return;\n    }\n\n    /* Free vars have not been initialized -- Do that */\n    PyObject *closure = ((PyFunctionObject *)frame->f_funcobj)->func_closure;\n    int offset = PyCode_GetFirstFree(co);\n    for (int i = 0; i < co->co_nfreevars; ++i) {\n        PyObject *o = PyTuple_GET_ITEM(closure, i);\n        frame->localsplus[offset + i] = Py_NewRef(o);\n    }\n    // COPY_FREE_VARS doesn't have inline CACHEs, either:\n    frame->prev_instr = _PyCode_CODE(frame->f_code);\n}\n\n\nstatic int\nframe_get_var(_PyInterpreterFrame *frame, PyCodeObject *co, int i,\n              PyObject **pvalue)\n{\n    _PyLocals_Kind kind = _PyLocals_GetKind(co->co_localspluskinds, i);\n\n    /* If the namespace is unoptimized, then one of the\n       following cases applies:\n       1. It does not contain free variables, because it\n          uses import * or is a top-level namespace.\n       2. It is a class namespace.\n       We don't want to accidentally copy free variables\n       into the locals dict used by the class.\n    */\n    if (kind & CO_FAST_FREE && !(co->co_flags & CO_OPTIMIZED)) {\n        return 0;\n    }\n\n    PyObject *value = frame->localsplus[i];\n    if (frame->stacktop) {\n        if (kind & CO_FAST_FREE) {\n            // The cell was set by COPY_FREE_VARS.\n            assert(value != NULL && PyCell_Check(value));\n            value = PyCell_GET(value);\n        }\n        else if (kind & CO_FAST_CELL) {\n            // Note that no *_DEREF ops can happen before MAKE_CELL\n            // executes.  So there's no need to duplicate the work\n            // that MAKE_CELL would otherwise do later, if it hasn't\n            // run yet.\n            if (value != NULL) {\n                if (PyCell_Check(value) &&\n                        _PyFrame_OpAlreadyRan(frame, MAKE_CELL, i)) {\n                    // (likely) MAKE_CELL must have executed already.\n                    value = PyCell_GET(value);\n                }\n                // (likely) Otherwise it it is an arg (kind & CO_FAST_LOCAL),\n                // with the initial value set when the frame was created...\n                // (unlikely) ...or it was set to some initial value by\n                // an earlier call to PyFrame_LocalsToFast().\n            }\n        }\n    }\n    else {\n        assert(value == NULL);\n    }\n    *pvalue = value;\n    return 1;\n}\n\n\nPyObject *\n_PyFrame_GetLocals(_PyInterpreterFrame *frame, int include_hidden)\n{\n    /* Merge fast locals into f->f_locals */\n    PyObject *locals = frame->f_locals;\n    if (locals == NULL) {\n        locals = frame->f_locals = PyDict_New();\n        if (locals == NULL) {\n            return NULL;\n        }\n    }\n    PyObject *hidden = NULL;\n\n    /* If include_hidden, \"hidden\" fast locals (from inlined comprehensions in\n       module/class scopes) will be included in the returned dict, but not in\n       frame->f_locals; the returned dict will be a modified copy. Non-hidden\n       locals will still be updated in frame->f_locals. */\n    if (include_hidden) {\n        hidden = PyDict_New();\n        if (hidden == NULL) {\n            return NULL;\n        }\n    }\n\n    frame_init_get_vars(frame);\n\n    PyCodeObject *co = frame->f_code;\n    for (int i = 0; i < co->co_nlocalsplus; i++) {\n        PyObject *value;  // borrowed reference\n        if (!frame_get_var(frame, co, i, &value)) {\n            continue;\n        }\n\n        PyObject *name = PyTuple_GET_ITEM(co->co_localsplusnames, i);\n        _PyLocals_Kind kind = _PyLocals_GetKind(co->co_localspluskinds, i);\n        if (kind & CO_FAST_HIDDEN) {\n            if (include_hidden && value != NULL) {\n                if (PyObject_SetItem(hidden, name, value) != 0) {\n                    goto error;\n                }\n            }\n            continue;\n        }\n        if (value == NULL) {\n            if (PyObject_DelItem(locals, name) != 0) {\n                if (PyErr_ExceptionMatches(PyExc_KeyError)) {\n                    PyErr_Clear();\n                }\n                else {\n                    goto error;\n                }\n            }\n        }\n        else {\n            if (PyObject_SetItem(locals, name, value) != 0) {\n                goto error;\n            }\n        }\n    }\n\n    if (include_hidden && PyDict_Size(hidden)) {\n        PyObject *innerlocals = PyDict_New();\n        if (innerlocals == NULL) {\n            goto error;\n        }\n        if (PyDict_Merge(innerlocals, locals, 1) != 0) {\n            Py_DECREF(innerlocals);\n            goto error;\n        }\n        if (PyDict_Merge(innerlocals, hidden, 1) != 0) {\n            Py_DECREF(innerlocals);\n            goto error;\n        }\n        locals = innerlocals;\n    }\n    else {\n        Py_INCREF(locals);\n    }\n    Py_CLEAR(hidden);\n\n    return locals;\n\n  error:\n    Py_XDECREF(hidden);\n    return NULL;\n}\n\n\nint\n_PyFrame_FastToLocalsWithError(_PyInterpreterFrame *frame)\n{\n    PyObject *locals = _PyFrame_GetLocals(frame, 0);\n    if (locals == NULL) {\n        return -1;\n    }\n    Py_DECREF(locals);\n    return 0;\n}\n\n\nPyObject *\nPyFrame_GetVar(PyFrameObject *frame_obj, PyObject *name)\n{\n    if (!PyUnicode_Check(name)) {\n        PyErr_Format(PyExc_TypeError, \"name must be str, not %s\",\n                     Py_TYPE(name)->tp_name);\n        return NULL;\n    }\n\n    _PyInterpreterFrame *frame = frame_obj->f_frame;\n    frame_init_get_vars(frame);\n\n    PyCodeObject *co = frame->f_code;\n    for (int i = 0; i < co->co_nlocalsplus; i++) {\n        PyObject *var_name = PyTuple_GET_ITEM(co->co_localsplusnames, i);\n        if (!_PyUnicode_Equal(var_name, name)) {\n            continue;\n        }\n\n        PyObject *value;  // borrowed reference\n        if (!frame_get_var(frame, co, i, &value)) {\n            break;\n        }\n        if (value == NULL) {\n            break;\n        }\n        return Py_NewRef(value);\n    }\n\n    PyErr_Format(PyExc_NameError, \"variable %R does not exist\", name);\n    return NULL;\n}\n\n\nPyObject *\nPyFrame_GetVarString(PyFrameObject *frame, const char *name)\n{\n    PyObject *name_obj = PyUnicode_FromString(name);\n    if (name_obj == NULL) {\n        return NULL;\n    }\n    PyObject *value = PyFrame_GetVar(frame, name_obj);\n    Py_DECREF(name_obj);\n    return value;\n}\n\n\nint\nPyFrame_FastToLocalsWithError(PyFrameObject *f)\n{\n    if (f == NULL) {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    assert(!_PyFrame_IsIncomplete(f->f_frame));\n    int err = _PyFrame_FastToLocalsWithError(f->f_frame);\n    if (err == 0) {\n        f->f_fast_as_locals = 1;\n    }\n    return err;\n}\n\nvoid\nPyFrame_FastToLocals(PyFrameObject *f)\n{\n    int res;\n    assert(!_PyFrame_IsIncomplete(f->f_frame));\n    assert(!PyErr_Occurred());\n\n    res = PyFrame_FastToLocalsWithError(f);\n    if (res < 0)\n        PyErr_Clear();\n}\n\nvoid\n_PyFrame_LocalsToFast(_PyInterpreterFrame *frame, int clear)\n{\n    /* Merge locals into fast locals */\n    PyObject *locals;\n    PyObject **fast;\n    PyCodeObject *co;\n    locals = frame->f_locals;\n    if (locals == NULL) {\n        return;\n    }\n    fast = _PyFrame_GetLocalsArray(frame);\n    co = frame->f_code;\n\n    PyObject *exc = PyErr_GetRaisedException();\n    for (int i = 0; i < co->co_nlocalsplus; i++) {\n        _PyLocals_Kind kind = _PyLocals_GetKind(co->co_localspluskinds, i);\n\n        /* Same test as in PyFrame_FastToLocals() above. */\n        if (kind & CO_FAST_FREE && !(co->co_flags & CO_OPTIMIZED)) {\n            continue;\n        }\n        PyObject *name = PyTuple_GET_ITEM(co->co_localsplusnames, i);\n        PyObject *value = PyObject_GetItem(locals, name);\n        /* We only care about NULLs if clear is true. */\n        if (value == NULL) {\n            PyErr_Clear();\n            if (!clear) {\n                continue;\n            }\n        }\n        PyObject *oldvalue = fast[i];\n        PyObject *cell = NULL;\n        if (kind == CO_FAST_FREE) {\n            // The cell was set when the frame was created from\n            // the function's closure.\n            assert(oldvalue != NULL && PyCell_Check(oldvalue));\n            cell = oldvalue;\n        }\n        else if (kind & CO_FAST_CELL && oldvalue != NULL) {\n            /* Same test as in PyFrame_FastToLocals() above. */\n            if (PyCell_Check(oldvalue) &&\n                    _PyFrame_OpAlreadyRan(frame, MAKE_CELL, i)) {\n                // (likely) MAKE_CELL must have executed already.\n                cell = oldvalue;\n            }\n            // (unlikely) Otherwise, it must have been set to some\n            // initial value by an earlier call to PyFrame_LocalsToFast().\n        }\n        if (cell != NULL) {\n            oldvalue = PyCell_GET(cell);\n            if (value != oldvalue) {\n                PyCell_SET(cell, Py_XNewRef(value));\n                Py_XDECREF(oldvalue);\n            }\n        }\n        else if (value != oldvalue) {\n            if (value == NULL) {\n                // Probably can't delete this, since the compiler's flow\n                // analysis may have already \"proven\" that it exists here:\n                const char *e = \"assigning None to unbound local %R\";\n                if (PyErr_WarnFormat(PyExc_RuntimeWarning, 0, e, name)) {\n                    // It's okay if frame_obj is NULL, just try anyways:\n                    PyErr_WriteUnraisable((PyObject *)frame->frame_obj);\n                }\n                value = Py_NewRef(Py_None);\n            }\n            Py_XSETREF(fast[i], Py_NewRef(value));\n        }\n        Py_XDECREF(value);\n    }\n    PyErr_SetRaisedException(exc);\n}\n\nvoid\nPyFrame_LocalsToFast(PyFrameObject *f, int clear)\n{\n    assert(!_PyFrame_IsIncomplete(f->f_frame));\n    if (f && f->f_fast_as_locals && _PyFrame_GetState(f) != FRAME_CLEARED) {\n        _PyFrame_LocalsToFast(f->f_frame, clear);\n        f->f_fast_as_locals = 0;\n    }\n}\n\nint\n_PyFrame_IsEntryFrame(PyFrameObject *frame)\n{\n    assert(frame != NULL);\n    _PyInterpreterFrame *f = frame->f_frame;\n    assert(!_PyFrame_IsIncomplete(f));\n    return f->previous && f->previous->owner == FRAME_OWNED_BY_CSTACK;\n}\n\nPyCodeObject *\nPyFrame_GetCode(PyFrameObject *frame)\n{\n    assert(frame != NULL);\n    assert(!_PyFrame_IsIncomplete(frame->f_frame));\n    PyCodeObject *code = frame->f_frame->f_code;\n    assert(code != NULL);\n    return (PyCodeObject*)Py_NewRef(code);\n}\n\n\nPyFrameObject*\nPyFrame_GetBack(PyFrameObject *frame)\n{\n    assert(frame != NULL);\n    assert(!_PyFrame_IsIncomplete(frame->f_frame));\n    PyFrameObject *back = frame->f_back;\n    if (back == NULL) {\n        _PyInterpreterFrame *prev = frame->f_frame->previous;\n        prev = _PyFrame_GetFirstComplete(prev);\n        if (prev) {\n            back = _PyFrame_GetFrameObject(prev);\n        }\n    }\n    return (PyFrameObject*)Py_XNewRef(back);\n}\n\nPyObject*\nPyFrame_GetLocals(PyFrameObject *frame)\n{\n    assert(!_PyFrame_IsIncomplete(frame->f_frame));\n    return frame_getlocals(frame, NULL);\n}\n\nPyObject*\nPyFrame_GetGlobals(PyFrameObject *frame)\n{\n    assert(!_PyFrame_IsIncomplete(frame->f_frame));\n    return frame_getglobals(frame, NULL);\n}\n\nPyObject*\nPyFrame_GetBuiltins(PyFrameObject *frame)\n{\n    assert(!_PyFrame_IsIncomplete(frame->f_frame));\n    return frame_getbuiltins(frame, NULL);\n}\n\nint\nPyFrame_GetLasti(PyFrameObject *frame)\n{\n    assert(!_PyFrame_IsIncomplete(frame->f_frame));\n    int lasti = _PyInterpreterFrame_LASTI(frame->f_frame);\n    if (lasti < 0) {\n        return -1;\n    }\n    return lasti * sizeof(_Py_CODEUNIT);\n}\n\nPyObject *\nPyFrame_GetGenerator(PyFrameObject *frame)\n{\n    assert(!_PyFrame_IsIncomplete(frame->f_frame));\n    if (frame->f_frame->owner != FRAME_OWNED_BY_GENERATOR) {\n        return NULL;\n    }\n    PyGenObject *gen = _PyFrame_GetGenerator(frame->f_frame);\n    return Py_NewRef(gen);\n}\n\nPyObject*\n_PyEval_BuiltinsFromGlobals(PyThreadState *tstate, PyObject *globals)\n{\n    PyObject *builtins = PyDict_GetItemWithError(globals, &_Py_ID(__builtins__));\n    if (builtins) {\n        if (PyModule_Check(builtins)) {\n            builtins = _PyModule_GetDict(builtins);\n            assert(builtins != NULL);\n        }\n        return builtins;\n    }\n    if (PyErr_Occurred()) {\n        return NULL;\n    }\n\n    return _PyEval_GetBuiltins(tstate);\n}\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-deref-before-check",
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 1632,
                                       "gcc/analyzer/saved_diagnostic/snode": 92,
                                       "gcc/analyzer/saved_diagnostic/sval": "INIT_VAL(f_6(D))",
                                       "gcc/analyzer/saved_diagnostic/state": "assumed-non-null (in frame: 'PyFrame_LocalsToFast'@1)",
                                       "gcc/analyzer/saved_diagnostic/idx": 0},
                        "level": "warning",
                        "message": {"text": "check of 'f' for NULL after already dereferencing it"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/frameobject.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 1464,
                                                                       "startColumn": 8,
                                                                       "endColumn": 9},
                                                            "contextRegion": {"startLine": 1464,
                                                                              "snippet": {"text": "    if (f && f->f_fast_as_locals && _PyFrame_GetState(f) != FRAME_CLEARED) {\n"}}},
                                       "logicalLocations": [{"name": "PyFrame_LocalsToFast",
                                                             "fullyQualifiedName": "PyFrame_LocalsToFast",
                                                             "decoratedName": "PyFrame_LocalsToFast",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_STATE_CHANGE"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/frameobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1463,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 6},
                                                                                                         "contextRegion": {"startLine": 1463,
                                                                                                                           "snippet": {"text": "    assert(!_PyFrame_IsIncomplete(f->f_frame));\n"}}},
                                                                                    "logicalLocations": [{"name": "PyFrame_LocalsToFast",
                                                                                                          "fullyQualifiedName": "PyFrame_LocalsToFast",
                                                                                                          "decoratedName": "PyFrame_LocalsToFast",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "pointer 'f' is dereferenced here"}},
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/frameobject.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1464,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1464,
                                                                                                                           "snippet": {"text": "    if (f && f->f_fast_as_locals && _PyFrame_GetState(f) != FRAME_CLEARED) {\n"}}},
                                                                                    "logicalLocations": [{"name": "PyFrame_LocalsToFast",
                                                                                                          "fullyQualifiedName": "PyFrame_LocalsToFast",
                                                                                                          "decoratedName": "PyFrame_LocalsToFast",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "pointer 'f' is checked for NULL here but it was already dereferenced at (1)"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2}]}]}]}]}]}
