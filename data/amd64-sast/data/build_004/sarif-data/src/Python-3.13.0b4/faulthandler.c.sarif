{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C11",
                               "fullName": "GNU C11 (GCC) version 14.2.1 20240801 (Red Hat 14.2.1-1) (x86_64-redhat-linux)",
                               "version": "14.2.1 20240801 (Red Hat 14.2.1-1)",
                               "informationUri": "https://gcc.gnu.org/gcc-14/",
                               "rules": [{"id": "-Wanalyzer-use-of-pointer-in-stale-stack-frame",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-use-of-pointer-in-stale-stack-frame"},
                                         {"id": "-Wanalyzer-null-dereference",
                                          "helpUri": "https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-dereference"}]}},
           "taxonomies": [{"name": "CWE",
                           "version": "4.7",
                           "organization": "MITRE",
                           "shortDescription": {"text": "The MITRE Common Weakness Enumeration"},
                           "taxa": [{"id": "476",
                                     "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}],
           "invocations": [{"executionSuccessful": true,
                            "toolExecutionNotifications": []}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.13.0b4/"}},
           "artifacts": [{"location": {"uri": "./Modules/faulthandler.c",
                                       "uriBaseId": "PWD"},
                          "contents": {"text": "#include \"Python.h\"\n#include \"pycore_initconfig.h\"    // _PyStatus_ERR\n#include \"pycore_pyerrors.h\"      // _Py_DumpExtensionModules\n#include \"pycore_pystate.h\"       // _PyThreadState_GET()\n#include \"pycore_signal.h\"        // Py_NSIG\n#include \"pycore_sysmodule.h\"     // _PySys_GetAttr()\n#include \"pycore_time.h\"          // _PyTime_FromSecondsObject()\n#include \"pycore_traceback.h\"     // _Py_DumpTracebackThreads\n\n#ifdef HAVE_UNISTD_H\n#  include <unistd.h>             // _exit()\n#endif\n#include <signal.h>               // sigaction()\n#include <stdlib.h>               // abort()\n#if defined(HAVE_PTHREAD_SIGMASK) && !defined(HAVE_BROKEN_PTHREAD_SIGMASK) && defined(HAVE_PTHREAD_H)\n#  include <pthread.h>\n#endif\n#ifdef MS_WINDOWS\n#  include <windows.h>\n#endif\n#ifdef HAVE_SYS_RESOURCE_H\n#  include <sys/resource.h>       // setrlimit()\n#endif\n\n#if defined(FAULTHANDLER_USE_ALT_STACK) && defined(HAVE_LINUX_AUXVEC_H) && defined(HAVE_SYS_AUXV_H)\n#  include <linux/auxvec.h>       // AT_MINSIGSTKSZ\n#  include <sys/auxv.h>           // getauxval()\n#endif\n\n\n/* Allocate at maximum 100 MiB of the stack to raise the stack overflow */\n#define STACK_OVERFLOW_MAX_SIZE (100 * 1024 * 1024)\n\n#define PUTS(fd, str) (void)_Py_write_noraise(fd, str, strlen(str))\n\n\n// clang uses __attribute__((no_sanitize(\"undefined\")))\n// GCC 4.9+ uses __attribute__((no_sanitize_undefined))\n#if defined(__has_feature)  // Clang\n#  if __has_feature(undefined_behavior_sanitizer)\n#    define _Py_NO_SANITIZE_UNDEFINED __attribute__((no_sanitize(\"undefined\")))\n#  endif\n#endif\n#if defined(__GNUC__) \\\n    && ((__GNUC__ >= 5) || (__GNUC__ == 4) && (__GNUC_MINOR__ >= 9))\n#  define _Py_NO_SANITIZE_UNDEFINED __attribute__((no_sanitize_undefined))\n#endif\n#ifndef _Py_NO_SANITIZE_UNDEFINED\n#  define _Py_NO_SANITIZE_UNDEFINED\n#endif\n\n\ntypedef struct {\n    int signum;\n    int enabled;\n    const char* name;\n    _Py_sighandler_t previous;\n    int all_threads;\n} fault_handler_t;\n\n#define fatal_error _PyRuntime.faulthandler.fatal_error\n#define thread _PyRuntime.faulthandler.thread\n\n#ifdef FAULTHANDLER_USER\n#define user_signals _PyRuntime.faulthandler.user_signals\ntypedef struct faulthandler_user_signal user_signal_t;\nstatic void faulthandler_user(int signum);\n#endif /* FAULTHANDLER_USER */\n\n\nstatic fault_handler_t faulthandler_handlers[] = {\n#ifdef SIGBUS\n    {SIGBUS, 0, \"Bus error\", },\n#endif\n#ifdef SIGILL\n    {SIGILL, 0, \"Illegal instruction\", },\n#endif\n    {SIGFPE, 0, \"Floating point exception\", },\n    {SIGABRT, 0, \"Aborted\", },\n    /* define SIGSEGV at the end to make it the default choice if searching the\n       handler fails in faulthandler_fatal_error() */\n    {SIGSEGV, 0, \"Segmentation fault\", }\n};\nstatic const size_t faulthandler_nsignals = \\\n    Py_ARRAY_LENGTH(faulthandler_handlers);\n\n#ifdef FAULTHANDLER_USE_ALT_STACK\n#  define stack _PyRuntime.faulthandler.stack\n#  define old_stack _PyRuntime.faulthandler.old_stack\n#endif\n\n\n/* Get the file descriptor of a file by calling its fileno() method and then\n   call its flush() method.\n\n   If file is NULL or Py_None, use sys.stderr as the new file.\n   If file is an integer, it will be treated as file descriptor.\n\n   On success, return the file descriptor and write the new file into *file_ptr.\n   On error, return -1. */\n\nstatic int\nfaulthandler_get_fileno(PyObject **file_ptr)\n{\n    PyObject *result;\n    long fd_long;\n    int fd;\n    PyObject *file = *file_ptr;\n\n    if (file == NULL || file == Py_None) {\n        PyThreadState *tstate = _PyThreadState_GET();\n        file = _PySys_GetAttr(tstate, &_Py_ID(stderr));\n        if (file == NULL) {\n            PyErr_SetString(PyExc_RuntimeError, \"unable to get sys.stderr\");\n            return -1;\n        }\n        if (file == Py_None) {\n            PyErr_SetString(PyExc_RuntimeError, \"sys.stderr is None\");\n            return -1;\n        }\n    }\n    else if (PyLong_Check(file)) {\n        if (PyBool_Check(file)) {\n            if (PyErr_WarnEx(PyExc_RuntimeWarning,\n                    \"bool is used as a file descriptor\", 1))\n            {\n                return -1;\n            }\n        }\n        fd = PyLong_AsInt(file);\n        if (fd == -1 && PyErr_Occurred())\n            return -1;\n        if (fd < 0) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"file is not a valid file descriptor\");\n            return -1;\n        }\n        *file_ptr = NULL;\n        return fd;\n    }\n\n    result = PyObject_CallMethodNoArgs(file, &_Py_ID(fileno));\n    if (result == NULL)\n        return -1;\n\n    fd = -1;\n    if (PyLong_Check(result)) {\n        fd_long = PyLong_AsLong(result);\n        if (0 <= fd_long && fd_long < INT_MAX)\n            fd = (int)fd_long;\n    }\n    Py_DECREF(result);\n\n    if (fd == -1) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"file.fileno() is not a valid file descriptor\");\n        return -1;\n    }\n\n    if (_PyFile_Flush(file) < 0) {\n        /* ignore flush() error */\n        PyErr_Clear();\n    }\n    *file_ptr = file;\n    return fd;\n}\n\n/* Get the state of the current thread: only call this function if the current\n   thread holds the GIL. Raise an exception on error. */\nstatic PyThreadState*\nget_thread_state(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (tstate == NULL) {\n        /* just in case but very unlikely... */\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"unable to get the current thread state\");\n        return NULL;\n    }\n    return tstate;\n}\n\nstatic void\nfaulthandler_dump_traceback(int fd, int all_threads,\n                            PyInterpreterState *interp)\n{\n    static volatile int reentrant = 0;\n\n    if (reentrant)\n        return;\n\n    reentrant = 1;\n\n    /* SIGSEGV, SIGFPE, SIGABRT, SIGBUS and SIGILL are synchronous signals and\n       are thus delivered to the thread that caused the fault. Get the Python\n       thread state of the current thread.\n\n       PyThreadState_Get() doesn't give the state of the thread that caused the\n       fault if the thread released the GIL, and so this function cannot be\n       used. Read the thread specific storage (TSS) instead: call\n       PyGILState_GetThisThreadState(). */\n    PyThreadState *tstate = PyGILState_GetThisThreadState();\n\n    if (all_threads) {\n        (void)_Py_DumpTracebackThreads(fd, NULL, tstate);\n    }\n    else {\n        if (tstate != NULL)\n            _Py_DumpTraceback(fd, tstate);\n    }\n\n    reentrant = 0;\n}\n\nstatic PyObject*\nfaulthandler_dump_traceback_py(PyObject *self,\n                               PyObject *args, PyObject *kwargs)\n{\n    static char *kwlist[] = {\"file\", \"all_threads\", NULL};\n    PyObject *file = NULL;\n    int all_threads = 1;\n    PyThreadState *tstate;\n    const char *errmsg;\n    int fd;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwargs,\n        \"|Op:dump_traceback\", kwlist,\n        &file, &all_threads))\n        return NULL;\n\n    fd = faulthandler_get_fileno(&file);\n    if (fd < 0)\n        return NULL;\n\n    tstate = get_thread_state();\n    if (tstate == NULL)\n        return NULL;\n\n    if (all_threads) {\n        errmsg = _Py_DumpTracebackThreads(fd, NULL, tstate);\n        if (errmsg != NULL) {\n            PyErr_SetString(PyExc_RuntimeError, errmsg);\n            return NULL;\n        }\n    }\n    else {\n        _Py_DumpTraceback(fd, tstate);\n    }\n\n    if (PyErr_CheckSignals())\n        return NULL;\n\n    Py_RETURN_NONE;\n}\n\nstatic void\nfaulthandler_disable_fatal_handler(fault_handler_t *handler)\n{\n    if (!handler->enabled)\n        return;\n    handler->enabled = 0;\n#ifdef HAVE_SIGACTION\n    (void)sigaction(handler->signum, &handler->previous, NULL);\n#else\n    (void)signal(handler->signum, handler->previous);\n#endif\n}\n\n\n/* Handler for SIGSEGV, SIGFPE, SIGABRT, SIGBUS and SIGILL signals.\n\n   Display the current Python traceback, restore the previous handler and call\n   the previous handler.\n\n   On Windows, don't explicitly call the previous handler, because the Windows\n   signal handler would not be called (for an unknown reason). The execution of\n   the program continues at faulthandler_fatal_error() exit, but the same\n   instruction will raise the same fault (signal), and so the previous handler\n   will be called.\n\n   This function is signal-safe and should only call signal-safe functions. */\n\nstatic void\nfaulthandler_fatal_error(int signum)\n{\n    const int fd = fatal_error.fd;\n    size_t i;\n    fault_handler_t *handler = NULL;\n    int save_errno = errno;\n    int found = 0;\n\n    if (!fatal_error.enabled)\n        return;\n\n    for (i=0; i < faulthandler_nsignals; i++) {\n        handler = &faulthandler_handlers[i];\n        if (handler->signum == signum) {\n            found = 1;\n            break;\n        }\n    }\n    if (handler == NULL) {\n        /* faulthandler_nsignals == 0 (unlikely) */\n        return;\n    }\n\n    /* restore the previous handler */\n    faulthandler_disable_fatal_handler(handler);\n\n    if (found) {\n        PUTS(fd, \"Fatal Python error: \");\n        PUTS(fd, handler->name);\n        PUTS(fd, \"\\n\\n\");\n    }\n    else {\n        char unknown_signum[23] = {0,};\n        snprintf(unknown_signum, 23, \"%d\", signum);\n        PUTS(fd, \"Fatal Python error from unexpected signum: \");\n        PUTS(fd, unknown_signum);\n        PUTS(fd, \"\\n\\n\");\n    }\n\n    faulthandler_dump_traceback(fd, fatal_error.all_threads,\n                                fatal_error.interp);\n\n    _Py_DumpExtensionModules(fd, fatal_error.interp);\n\n    errno = save_errno;\n#ifdef MS_WINDOWS\n    if (signum == SIGSEGV) {\n        /* don't explicitly call the previous handler for SIGSEGV in this signal\n           handler, because the Windows signal handler would not be called */\n        return;\n    }\n#endif\n    /* call the previous signal handler: it is called immediately if we use\n       sigaction() thanks to SA_NODEFER flag, otherwise it is deferred */\n    raise(signum);\n}\n\n#ifdef MS_WINDOWS\nstatic int\nfaulthandler_ignore_exception(DWORD code)\n{\n    /* bpo-30557: ignore exceptions which are not errors */\n    if (!(code & 0x80000000)) {\n        return 1;\n    }\n    /* bpo-31701: ignore MSC and COM exceptions\n       E0000000 + code */\n    if (code == 0xE06D7363 /* MSC exception (\"Emsc\") */\n        || code == 0xE0434352 /* COM Callable Runtime exception (\"ECCR\") */) {\n        return 1;\n    }\n    /* Interesting exception: log it with the Python traceback */\n    return 0;\n}\n\nstatic LONG WINAPI\nfaulthandler_exc_handler(struct _EXCEPTION_POINTERS *exc_info)\n{\n    const int fd = fatal_error.fd;\n    DWORD code = exc_info->ExceptionRecord->ExceptionCode;\n    DWORD flags = exc_info->ExceptionRecord->ExceptionFlags;\n\n    if (faulthandler_ignore_exception(code)) {\n        /* ignore the exception: call the next exception handler */\n        return EXCEPTION_CONTINUE_SEARCH;\n    }\n\n    PUTS(fd, \"Windows fatal exception: \");\n    switch (code)\n    {\n    /* only format most common errors */\n    case EXCEPTION_ACCESS_VIOLATION: PUTS(fd, \"access violation\"); break;\n    case EXCEPTION_FLT_DIVIDE_BY_ZERO: PUTS(fd, \"float divide by zero\"); break;\n    case EXCEPTION_FLT_OVERFLOW: PUTS(fd, \"float overflow\"); break;\n    case EXCEPTION_INT_DIVIDE_BY_ZERO: PUTS(fd, \"int divide by zero\"); break;\n    case EXCEPTION_INT_OVERFLOW: PUTS(fd, \"integer overflow\"); break;\n    case EXCEPTION_IN_PAGE_ERROR: PUTS(fd, \"page error\"); break;\n    case EXCEPTION_STACK_OVERFLOW: PUTS(fd, \"stack overflow\"); break;\n    default:\n        PUTS(fd, \"code 0x\");\n        _Py_DumpHexadecimal(fd, code, 8);\n    }\n    PUTS(fd, \"\\n\\n\");\n\n    if (code == EXCEPTION_ACCESS_VIOLATION) {\n        /* disable signal handler for SIGSEGV */\n        for (size_t i=0; i < faulthandler_nsignals; i++) {\n            fault_handler_t *handler = &faulthandler_handlers[i];\n            if (handler->signum == SIGSEGV) {\n                faulthandler_disable_fatal_handler(handler);\n                break;\n            }\n        }\n    }\n\n    faulthandler_dump_traceback(fd, fatal_error.all_threads,\n                                fatal_error.interp);\n\n    /* call the next exception handler */\n    return EXCEPTION_CONTINUE_SEARCH;\n}\n#endif\n\n\n#ifdef FAULTHANDLER_USE_ALT_STACK\nstatic int\nfaulthandler_allocate_stack(void)\n{\n    if (stack.ss_sp != NULL) {\n        return 0;\n    }\n    /* Allocate an alternate stack for faulthandler() signal handler\n       to be able to execute a signal handler on a stack overflow error */\n    stack.ss_sp = PyMem_Malloc(stack.ss_size);\n    if (stack.ss_sp == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n\n    int err = sigaltstack(&stack, &old_stack);\n    if (err) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        /* Release the stack to retry sigaltstack() next time */\n        PyMem_Free(stack.ss_sp);\n        stack.ss_sp = NULL;\n        return -1;\n    }\n    return 0;\n}\n#endif\n\n\n/* Install the handler for fatal signals, faulthandler_fatal_error(). */\n\nstatic int\nfaulthandler_enable(void)\n{\n    if (fatal_error.enabled) {\n        return 0;\n    }\n    fatal_error.enabled = 1;\n\n#ifdef FAULTHANDLER_USE_ALT_STACK\n    if (faulthandler_allocate_stack() < 0) {\n        return -1;\n    }\n#endif\n\n    for (size_t i=0; i < faulthandler_nsignals; i++) {\n        fault_handler_t *handler;\n        int err;\n\n        handler = &faulthandler_handlers[i];\n        assert(!handler->enabled);\n#ifdef HAVE_SIGACTION\n        struct sigaction action;\n        action.sa_handler = faulthandler_fatal_error;\n        sigemptyset(&action.sa_mask);\n        /* Do not prevent the signal from being received from within\n           its own signal handler */\n        action.sa_flags = SA_NODEFER;\n#ifdef FAULTHANDLER_USE_ALT_STACK\n        assert(stack.ss_sp != NULL);\n        /* Call the signal handler on an alternate signal stack\n           provided by sigaltstack() */\n        action.sa_flags |= SA_ONSTACK;\n#endif\n        err = sigaction(handler->signum, &action, &handler->previous);\n#else\n        handler->previous = signal(handler->signum,\n                                   faulthandler_fatal_error);\n        err = (handler->previous == SIG_ERR);\n#endif\n        if (err) {\n            PyErr_SetFromErrno(PyExc_RuntimeError);\n            return -1;\n        }\n\n        handler->enabled = 1;\n    }\n\n#ifdef MS_WINDOWS\n    assert(fatal_error.exc_handler == NULL);\n    fatal_error.exc_handler = AddVectoredExceptionHandler(1, faulthandler_exc_handler);\n#endif\n    return 0;\n}\n\nstatic PyObject*\nfaulthandler_py_enable(PyObject *self, PyObject *args, PyObject *kwargs)\n{\n    static char *kwlist[] = {\"file\", \"all_threads\", NULL};\n    PyObject *file = NULL;\n    int all_threads = 1;\n    int fd;\n    PyThreadState *tstate;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwargs,\n        \"|Op:enable\", kwlist, &file, &all_threads))\n        return NULL;\n\n    fd = faulthandler_get_fileno(&file);\n    if (fd < 0)\n        return NULL;\n\n    tstate = get_thread_state();\n    if (tstate == NULL)\n        return NULL;\n\n    Py_XINCREF(file);\n    Py_XSETREF(fatal_error.file, file);\n    fatal_error.fd = fd;\n    fatal_error.all_threads = all_threads;\n    fatal_error.interp = PyThreadState_GetInterpreter(tstate);\n\n    if (faulthandler_enable() < 0) {\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\nstatic void\nfaulthandler_disable(void)\n{\n    if (fatal_error.enabled) {\n        fatal_error.enabled = 0;\n        for (size_t i=0; i < faulthandler_nsignals; i++) {\n            fault_handler_t *handler;\n            handler = &faulthandler_handlers[i];\n            faulthandler_disable_fatal_handler(handler);\n        }\n    }\n#ifdef MS_WINDOWS\n    if (fatal_error.exc_handler != NULL) {\n        RemoveVectoredExceptionHandler(fatal_error.exc_handler);\n        fatal_error.exc_handler = NULL;\n    }\n#endif\n    Py_CLEAR(fatal_error.file);\n}\n\nstatic PyObject*\nfaulthandler_disable_py(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    if (!fatal_error.enabled) {\n        Py_RETURN_FALSE;\n    }\n    faulthandler_disable();\n    Py_RETURN_TRUE;\n}\n\nstatic PyObject*\nfaulthandler_is_enabled(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    return PyBool_FromLong(fatal_error.enabled);\n}\n\nstatic void\nfaulthandler_thread(void *unused)\n{\n    PyLockStatus st;\n    const char* errmsg;\n    int ok;\n#if defined(HAVE_PTHREAD_SIGMASK) && !defined(HAVE_BROKEN_PTHREAD_SIGMASK)\n    sigset_t set;\n\n    /* we don't want to receive any signal */\n    sigfillset(&set);\n    pthread_sigmask(SIG_SETMASK, &set, NULL);\n#endif\n\n    do {\n        st = PyThread_acquire_lock_timed(thread.cancel_event,\n                                         thread.timeout_us, 0);\n        if (st == PY_LOCK_ACQUIRED) {\n            PyThread_release_lock(thread.cancel_event);\n            break;\n        }\n        /* Timeout => dump traceback */\n        assert(st == PY_LOCK_FAILURE);\n\n        (void)_Py_write_noraise(thread.fd, thread.header, (int)thread.header_len);\n\n        errmsg = _Py_DumpTracebackThreads(thread.fd, thread.interp, NULL);\n        ok = (errmsg == NULL);\n\n        if (thread.exit)\n            _exit(1);\n    } while (ok && thread.repeat);\n\n    /* The only way out */\n    PyThread_release_lock(thread.running);\n}\n\nstatic void\ncancel_dump_traceback_later(void)\n{\n    /* If not scheduled, nothing to cancel */\n    if (!thread.cancel_event) {\n        return;\n    }\n\n    /* Notify cancellation */\n    PyThread_release_lock(thread.cancel_event);\n\n    /* Wait for thread to join */\n    PyThread_acquire_lock(thread.running, 1);\n    PyThread_release_lock(thread.running);\n\n    /* The main thread should always hold the cancel_event lock */\n    PyThread_acquire_lock(thread.cancel_event, 1);\n\n    Py_CLEAR(thread.file);\n    if (thread.header) {\n        PyMem_Free(thread.header);\n        thread.header = NULL;\n    }\n}\n\n#define SEC_TO_US (1000 * 1000)\n\nstatic char*\nformat_timeout(PyTime_t us)\n{\n    unsigned long sec, min, hour;\n    char buffer[100];\n\n    /* the downcast is safe: the caller check that 0 < us <= LONG_MAX */\n    sec = (unsigned long)(us / SEC_TO_US);\n    us %= SEC_TO_US;\n\n    min = sec / 60;\n    sec %= 60;\n    hour = min / 60;\n    min %= 60;\n\n    if (us != 0) {\n        PyOS_snprintf(buffer, sizeof(buffer),\n                      \"Timeout (%lu:%02lu:%02lu.%06u)!\\n\",\n                      hour, min, sec, (unsigned int)us);\n    }\n    else {\n        PyOS_snprintf(buffer, sizeof(buffer),\n                      \"Timeout (%lu:%02lu:%02lu)!\\n\",\n                      hour, min, sec);\n    }\n    return _PyMem_Strdup(buffer);\n}\n\nstatic PyObject*\nfaulthandler_dump_traceback_later(PyObject *self,\n                                   PyObject *args, PyObject *kwargs)\n{\n    static char *kwlist[] = {\"timeout\", \"repeat\", \"file\", \"exit\", NULL};\n    PyObject *timeout_obj;\n    PyTime_t timeout, timeout_us;\n    int repeat = 0;\n    PyObject *file = NULL;\n    int fd;\n    int exit = 0;\n    PyThreadState *tstate;\n    char *header;\n    size_t header_len;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwargs,\n        \"O|iOi:dump_traceback_later\", kwlist,\n        &timeout_obj, &repeat, &file, &exit))\n        return NULL;\n\n    if (_PyTime_FromSecondsObject(&timeout, timeout_obj,\n                                  _PyTime_ROUND_TIMEOUT) < 0) {\n        return NULL;\n    }\n    timeout_us = _PyTime_AsMicroseconds(timeout, _PyTime_ROUND_TIMEOUT);\n    if (timeout_us <= 0) {\n        PyErr_SetString(PyExc_ValueError, \"timeout must be greater than 0\");\n        return NULL;\n    }\n    /* Limit to LONG_MAX seconds for format_timeout() */\n    if (timeout_us > PY_TIMEOUT_MAX || timeout_us / SEC_TO_US > LONG_MAX) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"timeout value is too large\");\n        return NULL;\n    }\n\n    tstate = get_thread_state();\n    if (tstate == NULL) {\n        return NULL;\n    }\n\n    fd = faulthandler_get_fileno(&file);\n    if (fd < 0) {\n        return NULL;\n    }\n\n    if (!thread.running) {\n        thread.running = PyThread_allocate_lock();\n        if (!thread.running) {\n            return PyErr_NoMemory();\n        }\n    }\n    if (!thread.cancel_event) {\n        thread.cancel_event = PyThread_allocate_lock();\n        if (!thread.cancel_event || !thread.running) {\n            return PyErr_NoMemory();\n        }\n\n        /* cancel_event starts to be acquired: it's only released to cancel\n           the thread. */\n        PyThread_acquire_lock(thread.cancel_event, 1);\n    }\n\n    /* format the timeout */\n    header = format_timeout(timeout_us);\n    if (header == NULL) {\n        return PyErr_NoMemory();\n    }\n    header_len = strlen(header);\n\n    /* Cancel previous thread, if running */\n    cancel_dump_traceback_later();\n\n    Py_XINCREF(file);\n    Py_XSETREF(thread.file, file);\n    thread.fd = fd;\n    /* the downcast is safe: we check that 0 < timeout_us < PY_TIMEOUT_MAX */\n    thread.timeout_us = (PY_TIMEOUT_T)timeout_us;\n    thread.repeat = repeat;\n    thread.interp = PyThreadState_GetInterpreter(tstate);\n    thread.exit = exit;\n    thread.header = header;\n    thread.header_len = header_len;\n\n    /* Arm these locks to serve as events when released */\n    PyThread_acquire_lock(thread.running, 1);\n\n    if (PyThread_start_new_thread(faulthandler_thread, NULL) == PYTHREAD_INVALID_THREAD_ID) {\n        PyThread_release_lock(thread.running);\n        Py_CLEAR(thread.file);\n        PyMem_Free(header);\n        thread.header = NULL;\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"unable to start watchdog thread\");\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject*\nfaulthandler_cancel_dump_traceback_later_py(PyObject *self,\n                                            PyObject *Py_UNUSED(ignored))\n{\n    cancel_dump_traceback_later();\n    Py_RETURN_NONE;\n}\n\n\n#ifdef FAULTHANDLER_USER\nstatic int\nfaulthandler_register(int signum, int chain, _Py_sighandler_t *previous_p)\n{\n#ifdef HAVE_SIGACTION\n    struct sigaction action;\n    action.sa_handler = faulthandler_user;\n    sigemptyset(&action.sa_mask);\n    /* if the signal is received while the kernel is executing a system\n       call, try to restart the system call instead of interrupting it and\n       return EINTR. */\n    action.sa_flags = SA_RESTART;\n    if (chain) {\n        /* do not prevent the signal from being received from within its\n           own signal handler */\n        action.sa_flags = SA_NODEFER;\n    }\n#ifdef FAULTHANDLER_USE_ALT_STACK\n    assert(stack.ss_sp != NULL);\n    /* Call the signal handler on an alternate signal stack\n       provided by sigaltstack() */\n    action.sa_flags |= SA_ONSTACK;\n#endif\n    return sigaction(signum, &action, previous_p);\n#else\n    _Py_sighandler_t previous;\n    previous = signal(signum, faulthandler_user);\n    if (previous_p != NULL) {\n        *previous_p = previous;\n    }\n    return (previous == SIG_ERR);\n#endif\n}\n\n/* Handler of user signals (e.g. SIGUSR1).\n\n   Dump the traceback of the current thread, or of all threads if\n   thread.all_threads is true.\n\n   This function is signal safe and should only call signal safe functions. */\n\nstatic void\nfaulthandler_user(int signum)\n{\n    user_signal_t *user;\n    int save_errno = errno;\n\n    user = &user_signals[signum];\n    if (!user->enabled)\n        return;\n\n    faulthandler_dump_traceback(user->fd, user->all_threads, user->interp);\n\n#ifdef HAVE_SIGACTION\n    if (user->chain) {\n        (void)sigaction(signum, &user->previous, NULL);\n        errno = save_errno;\n\n        /* call the previous signal handler */\n        raise(signum);\n\n        save_errno = errno;\n        (void)faulthandler_register(signum, user->chain, NULL);\n        errno = save_errno;\n    }\n#else\n    if (user->chain && user->previous != NULL) {\n        errno = save_errno;\n        /* call the previous signal handler */\n        user->previous(signum);\n    }\n#endif\n}\n\nstatic int\ncheck_signum(int signum)\n{\n    for (size_t i=0; i < faulthandler_nsignals; i++) {\n        if (faulthandler_handlers[i].signum == signum) {\n            PyErr_Format(PyExc_RuntimeError,\n                         \"signal %i cannot be registered, \"\n                         \"use enable() instead\",\n                         signum);\n            return 0;\n        }\n    }\n    if (signum < 1 || Py_NSIG <= signum) {\n        PyErr_SetString(PyExc_ValueError, \"signal number out of range\");\n        return 0;\n    }\n    return 1;\n}\n\nstatic PyObject*\nfaulthandler_register_py(PyObject *self,\n                         PyObject *args, PyObject *kwargs)\n{\n    static char *kwlist[] = {\"signum\", \"file\", \"all_threads\", \"chain\", NULL};\n    int signum;\n    PyObject *file = NULL;\n    int all_threads = 1;\n    int chain = 0;\n    int fd;\n    user_signal_t *user;\n    _Py_sighandler_t previous;\n    PyThreadState *tstate;\n    int err;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwargs,\n        \"i|Opp:register\", kwlist,\n        &signum, &file, &all_threads, &chain))\n        return NULL;\n\n    if (!check_signum(signum))\n        return NULL;\n\n    tstate = get_thread_state();\n    if (tstate == NULL)\n        return NULL;\n\n    fd = faulthandler_get_fileno(&file);\n    if (fd < 0)\n        return NULL;\n\n    if (user_signals == NULL) {\n        user_signals = PyMem_Calloc(Py_NSIG, sizeof(user_signal_t));\n        if (user_signals == NULL)\n            return PyErr_NoMemory();\n    }\n    user = &user_signals[signum];\n\n    if (!user->enabled) {\n#ifdef FAULTHANDLER_USE_ALT_STACK\n        if (faulthandler_allocate_stack() < 0) {\n            return NULL;\n        }\n#endif\n\n        err = faulthandler_register(signum, chain, &previous);\n        if (err) {\n            PyErr_SetFromErrno(PyExc_OSError);\n            return NULL;\n        }\n\n        user->previous = previous;\n    }\n\n    Py_XINCREF(file);\n    Py_XSETREF(user->file, file);\n    user->fd = fd;\n    user->all_threads = all_threads;\n    user->chain = chain;\n    user->interp = PyThreadState_GetInterpreter(tstate);\n    user->enabled = 1;\n\n    Py_RETURN_NONE;\n}\n\nstatic int\nfaulthandler_unregister(user_signal_t *user, int signum)\n{\n    if (!user->enabled)\n        return 0;\n    user->enabled = 0;\n#ifdef HAVE_SIGACTION\n    (void)sigaction(signum, &user->previous, NULL);\n#else\n    (void)signal(signum, user->previous);\n#endif\n    Py_CLEAR(user->file);\n    user->fd = -1;\n    return 1;\n}\n\nstatic PyObject*\nfaulthandler_unregister_py(PyObject *self, PyObject *args)\n{\n    int signum;\n    user_signal_t *user;\n    int change;\n\n    if (!PyArg_ParseTuple(args, \"i:unregister\", &signum))\n        return NULL;\n\n    if (!check_signum(signum))\n        return NULL;\n\n    if (user_signals == NULL)\n        Py_RETURN_FALSE;\n\n    user = &user_signals[signum];\n    change = faulthandler_unregister(user, signum);\n    return PyBool_FromLong(change);\n}\n#endif   /* FAULTHANDLER_USER */\n\n\nstatic void\nfaulthandler_suppress_crash_report(void)\n{\n#ifdef MS_WINDOWS_DESKTOP\n    UINT mode;\n\n    /* Configure Windows to not display the Windows Error Reporting dialog */\n    mode = SetErrorMode(SEM_NOGPFAULTERRORBOX);\n    SetErrorMode(mode | SEM_NOGPFAULTERRORBOX);\n#endif\n\n#ifdef HAVE_SYS_RESOURCE_H\n    struct rlimit rl;\n\n    /* Disable creation of core dump */\n    if (getrlimit(RLIMIT_CORE, &rl) == 0) {\n        rl.rlim_cur = 0;\n        setrlimit(RLIMIT_CORE, &rl);\n    }\n#endif\n\n#ifdef _MSC_VER\n    /* Visual Studio: configure abort() to not display an error message nor\n       open a popup asking to report the fault. */\n    _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n#endif\n}\n\nstatic PyObject* _Py_NO_SANITIZE_UNDEFINED\nfaulthandler_read_null(PyObject *self, PyObject *args)\n{\n    volatile int *x;\n    volatile int y;\n\n    faulthandler_suppress_crash_report();\n    x = NULL;\n    y = *x;\n    return PyLong_FromLong(y);\n\n}\n\nstatic void\nfaulthandler_raise_sigsegv(void)\n{\n    faulthandler_suppress_crash_report();\n#if defined(MS_WINDOWS)\n    /* For SIGSEGV, faulthandler_fatal_error() restores the previous signal\n       handler and then gives back the execution flow to the program (without\n       explicitly calling the previous error handler). In a normal case, the\n       SIGSEGV was raised by the kernel because of a fault, and so if the\n       program retries to execute the same instruction, the fault will be\n       raised again.\n\n       Here the fault is simulated by a fake SIGSEGV signal raised by the\n       application. We have to raise SIGSEGV at lease twice: once for\n       faulthandler_fatal_error(), and one more time for the previous signal\n       handler. */\n    while(1)\n        raise(SIGSEGV);\n#else\n    raise(SIGSEGV);\n#endif\n}\n\nstatic PyObject *\nfaulthandler_sigsegv(PyObject *self, PyObject *args)\n{\n    int release_gil = 0;\n    if (!PyArg_ParseTuple(args, \"|i:_sigsegv\", &release_gil))\n        return NULL;\n\n    if (release_gil) {\n        Py_BEGIN_ALLOW_THREADS\n        faulthandler_raise_sigsegv();\n        Py_END_ALLOW_THREADS\n    } else {\n        faulthandler_raise_sigsegv();\n    }\n    Py_RETURN_NONE;\n}\n\nstatic void _Py_NO_RETURN\nfaulthandler_fatal_error_thread(void *plock)\n{\n    Py_FatalError(\"in new thread\");\n}\n\nstatic PyObject *\nfaulthandler_fatal_error_c_thread(PyObject *self, PyObject *args)\n{\n    long tid;\n    PyThread_type_lock lock;\n\n    faulthandler_suppress_crash_report();\n\n    lock = PyThread_allocate_lock();\n    if (lock == NULL)\n        return PyErr_NoMemory();\n\n    PyThread_acquire_lock(lock, WAIT_LOCK);\n\n    tid = PyThread_start_new_thread(faulthandler_fatal_error_thread, lock);\n    if (tid == -1) {\n        PyThread_free_lock(lock);\n        PyErr_SetString(PyExc_RuntimeError, \"unable to start the thread\");\n        return NULL;\n    }\n\n    /* wait until the thread completes: it will never occur, since Py_FatalError()\n       exits the process immediately. */\n    PyThread_acquire_lock(lock, WAIT_LOCK);\n    PyThread_release_lock(lock);\n    PyThread_free_lock(lock);\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject* _Py_NO_SANITIZE_UNDEFINED\nfaulthandler_sigfpe(PyObject *self, PyObject *args)\n{\n    faulthandler_suppress_crash_report();\n\n    /* Do an integer division by zero: raise a SIGFPE on Intel CPU, but not on\n       PowerPC. Use volatile to disable compile-time optimizations. */\n    volatile int x = 1, y = 0, z;\n    z = x / y;\n\n    /* If the division by zero didn't raise a SIGFPE (e.g. on PowerPC),\n       raise it manually. */\n    raise(SIGFPE);\n\n    /* This line is never reached, but we pretend to make something with z\n       to silence a compiler warning. */\n    return PyLong_FromLong(z);\n}\n\nstatic PyObject *\nfaulthandler_sigabrt(PyObject *self, PyObject *args)\n{\n    faulthandler_suppress_crash_report();\n    abort();\n    Py_RETURN_NONE;\n}\n\n#if defined(FAULTHANDLER_USE_ALT_STACK)\n#define FAULTHANDLER_STACK_OVERFLOW\n\nstatic uintptr_t\nstack_overflow(uintptr_t min_sp, uintptr_t max_sp, size_t *depth)\n{\n    /* Allocate (at least) 4096 bytes on the stack at each call.\n\n       bpo-23654, bpo-38965: use volatile keyword to prevent tail call\n       optimization. */\n    volatile unsigned char buffer[4096];\n    uintptr_t sp = (uintptr_t)&buffer;\n    *depth += 1;\n    if (sp < min_sp || max_sp < sp)\n        return sp;\n    buffer[0] = 1;\n    buffer[4095] = 0;\n    return stack_overflow(min_sp, max_sp, depth);\n}\n\nstatic PyObject *\nfaulthandler_stack_overflow(PyObject *self, PyObject *Py_UNUSED(ignored))\n{\n    size_t depth, size;\n    uintptr_t sp = (uintptr_t)&depth;\n    uintptr_t stop, lower_limit, upper_limit;\n\n    faulthandler_suppress_crash_report();\n    depth = 0;\n\n    if (STACK_OVERFLOW_MAX_SIZE <= sp) {\n        lower_limit = sp - STACK_OVERFLOW_MAX_SIZE;\n    }\n    else {\n        lower_limit = 0;\n    }\n\n    if (UINTPTR_MAX - STACK_OVERFLOW_MAX_SIZE >= sp) {\n        upper_limit = sp + STACK_OVERFLOW_MAX_SIZE;\n    }\n    else {\n        upper_limit = UINTPTR_MAX;\n    }\n\n    stop = stack_overflow(lower_limit, upper_limit, &depth);\n    if (sp < stop)\n        size = stop - sp;\n    else\n        size = sp - stop;\n    PyErr_Format(PyExc_RuntimeError,\n        \"unable to raise a stack overflow (allocated %zu bytes \"\n        \"on the stack, %zu recursive calls)\",\n        size, depth);\n    return NULL;\n}\n#endif   /* defined(FAULTHANDLER_USE_ALT_STACK) && defined(HAVE_SIGACTION) */\n\n\nstatic int\nfaulthandler_traverse(PyObject *module, visitproc visit, void *arg)\n{\n    Py_VISIT(thread.file);\n#ifdef FAULTHANDLER_USER\n    if (user_signals != NULL) {\n        for (size_t signum=0; signum < Py_NSIG; signum++)\n            Py_VISIT(user_signals[signum].file);\n    }\n#endif\n    Py_VISIT(fatal_error.file);\n    return 0;\n}\n\n#ifdef MS_WINDOWS\nstatic PyObject *\nfaulthandler_raise_exception(PyObject *self, PyObject *args)\n{\n    unsigned int code, flags = 0;\n    if (!PyArg_ParseTuple(args, \"I|I:_raise_exception\", &code, &flags))\n        return NULL;\n    faulthandler_suppress_crash_report();\n    RaiseException(code, flags, 0, NULL);\n    Py_RETURN_NONE;\n}\n#endif\n\nPyDoc_STRVAR(module_doc,\n\"faulthandler module.\");\n\nstatic PyMethodDef module_methods[] = {\n    {\"enable\",\n     _PyCFunction_CAST(faulthandler_py_enable), METH_VARARGS|METH_KEYWORDS,\n     PyDoc_STR(\"enable($module, /, file=sys.stderr, all_threads=True)\\n--\\n\\n\"\n               \"Enable the fault handler.\")},\n    {\"disable\", faulthandler_disable_py, METH_NOARGS,\n     PyDoc_STR(\"disable($module, /)\\n--\\n\\n\"\n               \"Disable the fault handler.\")},\n    {\"is_enabled\", faulthandler_is_enabled, METH_NOARGS,\n     PyDoc_STR(\"is_enabled($module, /)\\n--\\n\\n\"\n               \"Check if the handler is enabled.\")},\n    {\"dump_traceback\",\n     _PyCFunction_CAST(faulthandler_dump_traceback_py), METH_VARARGS|METH_KEYWORDS,\n     PyDoc_STR(\"dump_traceback($module, /, file=sys.stderr, all_threads=True)\\n--\\n\\n\"\n               \"Dump the traceback of the current thread, or of all threads \"\n               \"if all_threads is True, into file.\")},\n    {\"dump_traceback_later\",\n     _PyCFunction_CAST(faulthandler_dump_traceback_later), METH_VARARGS|METH_KEYWORDS,\n     PyDoc_STR(\"dump_traceback_later($module, /, timeout, repeat=False, file=sys.stderr, exit=False)\\n--\\n\\n\"\n               \"Dump the traceback of all threads in timeout seconds,\\n\"\n               \"or each timeout seconds if repeat is True. If exit is True, \"\n               \"call _exit(1) which is not safe.\")},\n    {\"cancel_dump_traceback_later\",\n     faulthandler_cancel_dump_traceback_later_py, METH_NOARGS,\n     PyDoc_STR(\"cancel_dump_traceback_later($module, /)\\n--\\n\\n\"\n               \"Cancel the previous call to dump_traceback_later().\")},\n#ifdef FAULTHANDLER_USER\n    {\"register\",\n     _PyCFunction_CAST(faulthandler_register_py), METH_VARARGS|METH_KEYWORDS,\n     PyDoc_STR(\"register($module, /, signum, file=sys.stderr, all_threads=True, chain=False)\\n--\\n\\n\"\n               \"Register a handler for the signal 'signum': dump the \"\n               \"traceback of the current thread, or of all threads if \"\n               \"all_threads is True, into file.\")},\n    {\"unregister\",\n     _PyCFunction_CAST(faulthandler_unregister_py), METH_VARARGS,\n     PyDoc_STR(\"unregister($module, signum, /)\\n--\\n\\n\"\n               \"Unregister the handler of the signal \"\n               \"'signum' registered by register().\")},\n#endif\n    {\"_read_null\", faulthandler_read_null, METH_NOARGS,\n     PyDoc_STR(\"_read_null($module, /)\\n--\\n\\n\"\n               \"Read from NULL, raise \"\n               \"a SIGSEGV or SIGBUS signal depending on the platform.\")},\n    {\"_sigsegv\", faulthandler_sigsegv, METH_VARARGS,\n     PyDoc_STR(\"_sigsegv($module, release_gil=False, /)\\n--\\n\\n\"\n               \"Raise a SIGSEGV signal.\")},\n    {\"_fatal_error_c_thread\", faulthandler_fatal_error_c_thread, METH_NOARGS,\n     PyDoc_STR(\"_fatal_error_c_thread($module, /)\\n--\\n\\n\"\n               \"Call Py_FatalError() in a new C thread.\")},\n    {\"_sigabrt\", faulthandler_sigabrt, METH_NOARGS,\n     PyDoc_STR(\"_sigabrt($module, /)\\n--\\n\\n\"\n               \"Raise a SIGABRT signal.\")},\n    {\"_sigfpe\", (PyCFunction)faulthandler_sigfpe, METH_NOARGS,\n     PyDoc_STR(\"_sigfpe($module, /)\\n--\\n\\n\"\n               \"Raise a SIGFPE signal.\")},\n#ifdef FAULTHANDLER_STACK_OVERFLOW\n    {\"_stack_overflow\", faulthandler_stack_overflow, METH_NOARGS,\n     PyDoc_STR(\"_stack_overflow($module, /)\\n--\\n\\n\"\n               \"Recursive call to raise a stack overflow.\")},\n#endif\n#ifdef MS_WINDOWS\n    {\"_raise_exception\", faulthandler_raise_exception, METH_VARARGS,\n     PyDoc_STR(\"_raise_exception($module, code, flags=0, /)\\n--\\n\\n\"\n               \"Call RaiseException(code, flags).\")},\n#endif\n    {NULL, NULL}  /* sentinel */\n};\n\nstatic int\nPyExec_faulthandler(PyObject *module) {\n    /* Add constants for unit tests */\n#ifdef MS_WINDOWS\n    /* RaiseException() codes (prefixed by an underscore) */\n    if (PyModule_AddIntConstant(module, \"_EXCEPTION_ACCESS_VIOLATION\",\n                                EXCEPTION_ACCESS_VIOLATION)) {\n        return -1;\n    }\n    if (PyModule_AddIntConstant(module, \"_EXCEPTION_INT_DIVIDE_BY_ZERO\",\n                                EXCEPTION_INT_DIVIDE_BY_ZERO)) {\n        return -1;\n    }\n    if (PyModule_AddIntConstant(module, \"_EXCEPTION_STACK_OVERFLOW\",\n                                EXCEPTION_STACK_OVERFLOW)) {\n        return -1;\n    }\n\n    /* RaiseException() flags (prefixed by an underscore) */\n    if (PyModule_AddIntConstant(module, \"_EXCEPTION_NONCONTINUABLE\",\n                                EXCEPTION_NONCONTINUABLE)) {\n        return -1;\n    }\n    if (PyModule_AddIntConstant(module, \"_EXCEPTION_NONCONTINUABLE_EXCEPTION\",\n                                EXCEPTION_NONCONTINUABLE_EXCEPTION)) {\n        return -1;\n    }\n#endif\n    return 0;\n}\n\nstatic PyModuleDef_Slot faulthandler_slots[] = {\n    {Py_mod_exec, PyExec_faulthandler},\n    // XXX gh-103092: fix isolation.\n    //{Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},\n    {Py_mod_gil, Py_MOD_GIL_NOT_USED},\n    {0, NULL}\n};\n\nstatic struct PyModuleDef module_def = {\n    PyModuleDef_HEAD_INIT,\n    .m_name = \"faulthandler\",\n    .m_doc = module_doc,\n    .m_methods = module_methods,\n    .m_traverse = faulthandler_traverse,\n    .m_slots = faulthandler_slots\n};\n\nPyMODINIT_FUNC\nPyInit_faulthandler(void)\n{\n    return PyModuleDef_Init(&module_def);\n}\n\nstatic int\nfaulthandler_init_enable(void)\n{\n    PyObject *enable = _PyImport_GetModuleAttrString(\"faulthandler\", \"enable\");\n    if (enable == NULL) {\n        return -1;\n    }\n\n    PyObject *res = PyObject_CallNoArgs(enable);\n    Py_DECREF(enable);\n    if (res == NULL) {\n        return -1;\n    }\n    Py_DECREF(res);\n\n    return 0;\n}\n\nPyStatus\n_PyFaulthandler_Init(int enable)\n{\n#ifdef FAULTHANDLER_USE_ALT_STACK\n    memset(&stack, 0, sizeof(stack));\n    stack.ss_flags = 0;\n    /* bpo-21131: allocate dedicated stack of SIGSTKSZ*2 bytes, instead of just\n       SIGSTKSZ bytes. Calling the previous signal handler in faulthandler\n       signal handler uses more than SIGSTKSZ bytes of stack memory on some\n       platforms. */\n    stack.ss_size = SIGSTKSZ * 2;\n#ifdef AT_MINSIGSTKSZ\n    /* bpo-46968: Query Linux for minimal stack size to ensure signal delivery\n       for the hardware running CPython. This OS feature is available in\n       Linux kernel version >= 5.14 */\n    unsigned long at_minstack_size = getauxval(AT_MINSIGSTKSZ);\n    if (at_minstack_size != 0) {\n        stack.ss_size = SIGSTKSZ + at_minstack_size;\n    }\n#endif\n#endif\n\n    memset(&thread, 0, sizeof(thread));\n\n    if (enable) {\n        if (faulthandler_init_enable() < 0) {\n            return _PyStatus_ERR(\"failed to enable faulthandler\");\n        }\n    }\n    return _PyStatus_OK();\n}\n\nvoid _PyFaulthandler_Fini(void)\n{\n    /* later */\n    if (thread.cancel_event) {\n        cancel_dump_traceback_later();\n        PyThread_release_lock(thread.cancel_event);\n        PyThread_free_lock(thread.cancel_event);\n        thread.cancel_event = NULL;\n    }\n    if (thread.running) {\n        PyThread_free_lock(thread.running);\n        thread.running = NULL;\n    }\n\n#ifdef FAULTHANDLER_USER\n    /* user */\n    if (user_signals != NULL) {\n        for (size_t signum=0; signum < Py_NSIG; signum++) {\n            faulthandler_unregister(&user_signals[signum], signum);\n        }\n        PyMem_Free(user_signals);\n        user_signals = NULL;\n    }\n#endif\n\n    /* fatal */\n    faulthandler_disable();\n\n#ifdef FAULTHANDLER_USE_ALT_STACK\n    if (stack.ss_sp != NULL) {\n        /* Fetch the current alt stack */\n        stack_t current_stack;\n        memset(&current_stack, 0, sizeof(current_stack));\n        if (sigaltstack(NULL, &current_stack) == 0) {\n            if (current_stack.ss_sp == stack.ss_sp) {\n                /* The current alt stack is the one that we installed.\n                 It is safe to restore the old stack that we found when\n                 we installed ours */\n                sigaltstack(&old_stack, NULL);\n            } else {\n                /* Someone switched to a different alt stack and didn't\n                   restore ours when they were done (if they're done).\n                   There's not much we can do in this unlikely case */\n            }\n        }\n        PyMem_Free(stack.ss_sp);\n        stack.ss_sp = NULL;\n    }\n#endif\n}\n"},
                          "sourceLanguage": "c"}],
           "results": [{"ruleId": "-Wanalyzer-use-of-pointer-in-stale-stack-frame",
                        "properties": {"gcc/analyzer/saved_diagnostic/enode": 1300,
                                       "gcc/analyzer/saved_diagnostic/snode": 76,
                                       "gcc/analyzer/saved_diagnostic/idx": 1},
                        "level": "warning",
                        "message": {"text": "dereferencing pointer '<unknown>' to within stale stack frame"},
                        "locations": [{"logicalLocations": [{"name": "stack_overflow",
                                                             "fullyQualifiedName": "stack_overflow",
                                                             "decoratedName": "stack_overflow",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1125,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 28},
                                                                                                         "contextRegion": {"startLine": 1125,
                                                                                                                           "snippet": {"text": "faulthandler_stack_overflow(PyObject *self, PyObject *Py_UNUSED(ignored))\n"}}},
                                                                                    "logicalLocations": [{"name": "faulthandler_stack_overflow",
                                                                                                          "fullyQualifiedName": "faulthandler_stack_overflow",
                                                                                                          "decoratedName": "faulthandler_stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'faulthandler_stack_overflow'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 66,
                                                                                                                                 "dst_idx": 72,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1148,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 60},
                                                                                                         "contextRegion": {"startLine": 1148,
                                                                                                                           "snippet": {"text": "    stop = stack_overflow(lower_limit, upper_limit, &depth);\n"}}},
                                                                                    "logicalLocations": [{"name": "faulthandler_stack_overflow",
                                                                                                          "fullyQualifiedName": "faulthandler_stack_overflow",
                                                                                                          "decoratedName": "faulthandler_stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'stack_overflow' from 'faulthandler_stack_overflow'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1108,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1108,
                                                                                                                           "snippet": {"text": "stack_overflow(uintptr_t min_sp, uintptr_t max_sp, size_t *depth)\n"}}},
                                                                                    "logicalLocations": [{"name": "stack_overflow",
                                                                                                          "fullyQualifiedName": "stack_overflow",
                                                                                                          "decoratedName": "stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'stack_overflow'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 73,
                                                                                                                                 "dst_idx": 74,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1117,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1117,
                                                                                                                           "snippet": {"text": "    if (sp < min_sp || max_sp < sp)\n"}}},
                                                                                    "logicalLocations": [{"name": "stack_overflow",
                                                                                                          "fullyQualifiedName": "stack_overflow",
                                                                                                          "decoratedName": "stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'false' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 73,
                                                                                                                                 "dst_idx": 74,
                                                                                                                                 "desc": "false (flags FALSE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1119,
                                                                                                                    "startColumn": 5,
                                                                                                                    "endColumn": 18},
                                                                                                         "contextRegion": {"startLine": 1119,
                                                                                                                           "snippet": {"text": "    buffer[0] = 1;\n"}}},
                                                                                    "logicalLocations": [{"name": "stack_overflow",
                                                                                                          "fullyQualifiedName": "stack_overflow",
                                                                                                          "decoratedName": "stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "false"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 74,
                                                                                                                                 "dst_idx": 72,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1121,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 49},
                                                                                                         "contextRegion": {"startLine": 1121,
                                                                                                                           "snippet": {"text": "    return stack_overflow(min_sp, max_sp, depth);\n"}}},
                                                                                    "logicalLocations": [{"name": "stack_overflow",
                                                                                                          "fullyQualifiedName": "stack_overflow",
                                                                                                          "decoratedName": "stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'stack_overflow' from 'stack_overflow'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1108,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1108,
                                                                                                                           "snippet": {"text": "stack_overflow(uintptr_t min_sp, uintptr_t max_sp, size_t *depth)\n"}}},
                                                                                    "logicalLocations": [{"name": "stack_overflow",
                                                                                                          "fullyQualifiedName": "stack_overflow",
                                                                                                          "decoratedName": "stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'stack_overflow'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 7},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(8)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 73,
                                                                                                                                 "dst_idx": 76,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1117,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1117,
                                                                                                                           "snippet": {"text": "    if (sp < min_sp || max_sp < sp)\n"}}},
                                                                                    "logicalLocations": [{"name": "stack_overflow",
                                                                                                          "fullyQualifiedName": "stack_overflow",
                                                                                                          "decoratedName": "stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 8},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(9)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 73,
                                                                                                                                 "dst_idx": 76,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"logicalLocations": [{"name": "stack_overflow",
                                                                                                          "fullyQualifiedName": "stack_overflow",
                                                                                                          "decoratedName": "stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 3,
                                                                       "executionOrder": 9},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(10)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 77,
                                                                                                                                 "dst_idx": 75,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1121,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 49},
                                                                                                         "contextRegion": {"startLine": 1121,
                                                                                                                           "snippet": {"text": "    return stack_overflow(min_sp, max_sp, depth);\n"}}},
                                                                                    "logicalLocations": [{"name": "stack_overflow",
                                                                                                          "fullyQualifiedName": "stack_overflow",
                                                                                                          "decoratedName": "stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'stack_overflow' from 'stack_overflow'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 10},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(11)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"logicalLocations": [{"name": "stack_overflow",
                                                                                                          "fullyQualifiedName": "stack_overflow",
                                                                                                          "decoratedName": "stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "dereferencing pointer '<unknown>' to within stale stack frame"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 11}]}]}]},
                       {"ruleId": "-Wanalyzer-null-dereference",
                        "taxa": [{"id": "476",
                                  "toolComponent": {"name": "cwe"}}],
                        "properties": {"gcc/analyzer/saved_diagnostic/sm": "malloc",
                                       "gcc/analyzer/saved_diagnostic/enode": 1550,
                                       "gcc/analyzer/saved_diagnostic/snode": 113,
                                       "gcc/analyzer/saved_diagnostic/sval": "(volatile int *)0B",
                                       "gcc/analyzer/saved_diagnostic/state": "null",
                                       "gcc/analyzer/saved_diagnostic/idx": 4},
                        "level": "warning",
                        "message": {"text": "dereference of NULL '0'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 996,
                                                                       "startColumn": 9,
                                                                       "endColumn": 11},
                                                            "contextRegion": {"startLine": 996,
                                                                              "snippet": {"text": "    y = *x;\n"}}},
                                       "logicalLocations": [{"name": "faulthandler_read_null",
                                                             "fullyQualifiedName": "faulthandler_read_null",
                                                             "decoratedName": "faulthandler_read_null",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 996,
                                                                                                                    "startColumn": 9,
                                                                                                                    "endColumn": 11},
                                                                                                         "contextRegion": {"startLine": 996,
                                                                                                                           "snippet": {"text": "    y = *x;\n"}}},
                                                                                    "logicalLocations": [{"name": "faulthandler_read_null",
                                                                                                          "fullyQualifiedName": "faulthandler_read_null",
                                                                                                          "decoratedName": "faulthandler_read_null",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "dereference of NULL '0'"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1}]}]}]},
                       {"ruleId": "-Wanalyzer-use-of-pointer-in-stale-stack-frame",
                        "properties": {"gcc/analyzer/saved_diagnostic/enode": 1306,
                                       "gcc/analyzer/saved_diagnostic/snode": 67,
                                       "gcc/analyzer/saved_diagnostic/idx": 2},
                        "level": "warning",
                        "message": {"text": "dereferencing pointer 'stop' to within stale stack frame"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                 "uriBaseId": "PWD"},
                                                            "region": {"startLine": 1149,
                                                                       "startColumn": 8,
                                                                       "endColumn": 9},
                                                            "contextRegion": {"startLine": 1149,
                                                                              "snippet": {"text": "    if (sp < stop)\n"}}},
                                       "logicalLocations": [{"name": "faulthandler_stack_overflow",
                                                             "fullyQualifiedName": "faulthandler_stack_overflow",
                                                             "decoratedName": "faulthandler_stack_overflow",
                                                             "kind": "function"}]}],
                        "codeFlows": [{"threadFlows": [{"id": "main",
                                                        "locations": [{"properties": {"gcc/analyzer/checker_event/emission_id": "(1)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1125,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 28},
                                                                                                         "contextRegion": {"startLine": 1125,
                                                                                                                           "snippet": {"text": "faulthandler_stack_overflow(PyObject *self, PyObject *Py_UNUSED(ignored))\n"}}},
                                                                                    "logicalLocations": [{"name": "faulthandler_stack_overflow",
                                                                                                          "fullyQualifiedName": "faulthandler_stack_overflow",
                                                                                                          "decoratedName": "faulthandler_stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'faulthandler_stack_overflow'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 1},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(2)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_CALL_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CALL",
                                                                                                                                 "src_idx": 66,
                                                                                                                                 "dst_idx": 72,
                                                                                                                                 "desc": "call"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1148,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 60},
                                                                                                         "contextRegion": {"startLine": 1148,
                                                                                                                           "snippet": {"text": "    stop = stack_overflow(lower_limit, upper_limit, &depth);\n"}}},
                                                                                    "logicalLocations": [{"name": "faulthandler_stack_overflow",
                                                                                                          "fullyQualifiedName": "faulthandler_stack_overflow",
                                                                                                          "decoratedName": "faulthandler_stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "calling 'stack_overflow' from 'faulthandler_stack_overflow'"}},
                                                                       "kinds": ["call",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 2},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(3)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_FUNCTION_ENTRY"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1108,
                                                                                                                    "startColumn": 1,
                                                                                                                    "endColumn": 15},
                                                                                                         "contextRegion": {"startLine": 1108,
                                                                                                                           "snippet": {"text": "stack_overflow(uintptr_t min_sp, uintptr_t max_sp, size_t *depth)\n"}}},
                                                                                    "logicalLocations": [{"name": "stack_overflow",
                                                                                                          "fullyQualifiedName": "stack_overflow",
                                                                                                          "decoratedName": "stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "entry to 'stack_overflow'"}},
                                                                       "kinds": ["enter",
                                                                                 "function"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 3},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(4)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_START_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 73,
                                                                                                                                 "dst_idx": 76,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1117,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1117,
                                                                                                                           "snippet": {"text": "    if (sp < min_sp || max_sp < sp)\n"}}},
                                                                                    "logicalLocations": [{"name": "stack_overflow",
                                                                                                          "fullyQualifiedName": "stack_overflow",
                                                                                                          "decoratedName": "stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "following 'true' branch..."}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 4},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(5)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_END_CFG_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_CFG_EDGE",
                                                                                                                                 "src_idx": 73,
                                                                                                                                 "dst_idx": 76,
                                                                                                                                 "desc": "true (flags TRUE_VALUE | EXECUTABLE) (has goto_locus)"}},
                                                                       "location": {"logicalLocations": [{"name": "stack_overflow",
                                                                                                          "fullyQualifiedName": "stack_overflow",
                                                                                                          "decoratedName": "stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "...to here"}},
                                                                       "kinds": ["branch",
                                                                                 "true"],
                                                                       "nestingLevel": 2,
                                                                       "executionOrder": 5},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(6)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_RETURN_EDGE",
                                                                                      "gcc/analyzer/superedge_event/superedge": {"kind": "SUPEREDGE_RETURN",
                                                                                                                                 "src_idx": 77,
                                                                                                                                 "dst_idx": 67,
                                                                                                                                 "desc": "return"}},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1148,
                                                                                                                    "startColumn": 12,
                                                                                                                    "endColumn": 60},
                                                                                                         "contextRegion": {"startLine": 1148,
                                                                                                                           "snippet": {"text": "    stop = stack_overflow(lower_limit, upper_limit, &depth);\n"}}},
                                                                                    "logicalLocations": [{"name": "faulthandler_stack_overflow",
                                                                                                          "fullyQualifiedName": "faulthandler_stack_overflow",
                                                                                                          "decoratedName": "faulthandler_stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "returning to 'faulthandler_stack_overflow' from 'stack_overflow'"}},
                                                                       "kinds": ["return",
                                                                                 "function"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 6},
                                                                      {"properties": {"gcc/analyzer/checker_event/emission_id": "(7)",
                                                                                      "gcc/analyzer/checker_event/kind": "EK_WARNING"},
                                                                       "location": {"physicalLocation": {"artifactLocation": {"uri": "./Modules/faulthandler.c",
                                                                                                                              "uriBaseId": "PWD"},
                                                                                                         "region": {"startLine": 1149,
                                                                                                                    "startColumn": 8,
                                                                                                                    "endColumn": 9},
                                                                                                         "contextRegion": {"startLine": 1149,
                                                                                                                           "snippet": {"text": "    if (sp < stop)\n"}}},
                                                                                    "logicalLocations": [{"name": "faulthandler_stack_overflow",
                                                                                                          "fullyQualifiedName": "faulthandler_stack_overflow",
                                                                                                          "decoratedName": "faulthandler_stack_overflow",
                                                                                                          "kind": "function"}],
                                                                                    "message": {"text": "dereferencing pointer 'stop' to within stale stack frame"}},
                                                                       "kinds": ["danger"],
                                                                       "nestingLevel": 1,
                                                                       "executionOrder": 7}]}]}]}]}]}
