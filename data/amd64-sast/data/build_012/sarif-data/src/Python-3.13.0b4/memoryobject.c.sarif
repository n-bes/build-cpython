{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-null-dereference", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-null-dereference"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "476", "helpUri": "https://cwe.mitre.org/data/definitions/476.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.13.0b4/"}}, "artifacts": [{"location": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "contents": {"text": "/*\n * Memoryview object implementation\n * --------------------------------\n *\n *   This implementation is a complete rewrite contributed by Stefan Krah in\n *   Python 3.3.  Substantial credit goes to Antoine Pitrou (who had already\n *   fortified and rewritten the previous implementation) and Nick Coghlan\n *   (who came up with the idea of the ManagedBuffer) for analyzing the complex\n *   ownership rules.\n *\n */\n\n#include \"Python.h\"\n#include \"pycore_abstract.h\"      // _PyIndex_Check()\n#include \"pycore_memoryobject.h\"  // _PyManagedBuffer_Type\n#include \"pycore_object.h\"        // _PyObject_GC_UNTRACK()\n#include \"pycore_strhex.h\"        // _Py_strhex_with_sep()\n#include <stddef.h>               // offsetof()\n\n/*[clinic input]\nclass memoryview \"PyMemoryViewObject *\" \"&PyMemoryView_Type\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=e2e49d2192835219]*/\n\n#include \"clinic/memoryobject.c.h\"\n\n/****************************************************************************/\n/*                           ManagedBuffer Object                           */\n/****************************************************************************/\n\n/*\n   ManagedBuffer Object:\n   ---------------------\n\n     The purpose of this object is to facilitate the handling of chained\n     memoryviews that have the same underlying exporting object. PEP-3118\n     allows the underlying object to change while a view is exported. This\n     could lead to unexpected results when constructing a new memoryview\n     from an existing memoryview.\n\n     Rather than repeatedly redirecting buffer requests to the original base\n     object, all chained memoryviews use a single buffer snapshot. This\n     snapshot is generated by the constructor _PyManagedBuffer_FromObject().\n\n   Ownership rules:\n   ----------------\n\n     The master buffer inside a managed buffer is filled in by the original\n     base object. shape, strides, suboffsets and format are read-only for\n     all consumers.\n\n     A memoryview's buffer is a private copy of the exporter's buffer. shape,\n     strides and suboffsets belong to the memoryview and are thus writable.\n\n     If a memoryview itself exports several buffers via memory_getbuf(), all\n     buffer copies share shape, strides and suboffsets. In this case, the\n     arrays are NOT writable.\n\n   Reference count assumptions:\n   ----------------------------\n\n     The 'obj' member of a Py_buffer must either be NULL or refer to the\n     exporting base object. In the Python codebase, all getbufferprocs\n     return a new reference to view.obj (example: bytes_buffer_getbuffer()).\n\n     PyBuffer_Release() decrements view.obj (if non-NULL), so the\n     releasebufferprocs must NOT decrement view.obj.\n*/\n\n\nstatic inline _PyManagedBufferObject *\nmbuf_alloc(void)\n{\n    _PyManagedBufferObject *mbuf;\n\n    mbuf = (_PyManagedBufferObject *)\n        PyObject_GC_New(_PyManagedBufferObject, &_PyManagedBuffer_Type);\n    if (mbuf == NULL)\n        return NULL;\n    mbuf->flags = 0;\n    mbuf->exports = 0;\n    mbuf->master.obj = NULL;\n    _PyObject_GC_TRACK(mbuf);\n\n    return mbuf;\n}\n\nstatic PyObject *\n_PyManagedBuffer_FromObject(PyObject *base, int flags)\n{\n    _PyManagedBufferObject *mbuf;\n\n    mbuf = mbuf_alloc();\n    if (mbuf == NULL)\n        return NULL;\n\n    if (PyObject_GetBuffer(base, &mbuf->master, flags) < 0) {\n        mbuf->master.obj = NULL;\n        Py_DECREF(mbuf);\n        return NULL;\n    }\n\n    return (PyObject *)mbuf;\n}\n\nstatic void\nmbuf_release(_PyManagedBufferObject *self)\n{\n    if (self->flags&_Py_MANAGED_BUFFER_RELEASED)\n        return;\n\n    /* NOTE: at this point self->exports can still be > 0 if this function\n       is called from mbuf_clear() to break up a reference cycle. */\n    self->flags |= _Py_MANAGED_BUFFER_RELEASED;\n\n    /* PyBuffer_Release() decrements master->obj and sets it to NULL. */\n    _PyObject_GC_UNTRACK(self);\n    PyBuffer_Release(&self->master);\n}\n\nstatic void\nmbuf_dealloc(PyObject *_self)\n{\n    _PyManagedBufferObject *self = (_PyManagedBufferObject *)_self;\n    assert(self->exports == 0);\n    mbuf_release(self);\n    if (self->flags&_Py_MANAGED_BUFFER_FREE_FORMAT)\n        PyMem_Free(self->master.format);\n    PyObject_GC_Del(self);\n}\n\nstatic int\nmbuf_traverse(PyObject *_self, visitproc visit, void *arg)\n{\n    _PyManagedBufferObject *self = (_PyManagedBufferObject *)_self;\n    Py_VISIT(self->master.obj);\n    return 0;\n}\n\nstatic int\nmbuf_clear(PyObject *_self)\n{\n    _PyManagedBufferObject *self = (_PyManagedBufferObject *)_self;\n    assert(self->exports >= 0);\n    mbuf_release(self);\n    return 0;\n}\n\nPyTypeObject _PyManagedBuffer_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"managedbuffer\",\n    sizeof(_PyManagedBufferObject),\n    0,\n    mbuf_dealloc,                            /* tp_dealloc */\n    0,                                       /* tp_vectorcall_offset */\n    0,                                       /* tp_getattr */\n    0,                                       /* tp_setattr */\n    0,                                       /* tp_as_async */\n    0,                                       /* tp_repr */\n    0,                                       /* tp_as_number */\n    0,                                       /* tp_as_sequence */\n    0,                                       /* tp_as_mapping */\n    0,                                       /* tp_hash */\n    0,                                       /* tp_call */\n    0,                                       /* tp_str */\n    PyObject_GenericGetAttr,                 /* tp_getattro */\n    0,                                       /* tp_setattro */\n    0,                                       /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    0,                                       /* tp_doc */\n    mbuf_traverse,                           /* tp_traverse */\n    mbuf_clear                               /* tp_clear */\n};\n\n\n/****************************************************************************/\n/*                             MemoryView Object                            */\n/****************************************************************************/\n\n/* In the process of breaking reference cycles mbuf_release() can be\n   called before memory_release(). */\n#define BASE_INACCESSIBLE(mv) \\\n    (((PyMemoryViewObject *)mv)->flags&_Py_MEMORYVIEW_RELEASED || \\\n     ((PyMemoryViewObject *)mv)->mbuf->flags&_Py_MANAGED_BUFFER_RELEASED)\n\n#define CHECK_RELEASED(mv) \\\n    if (BASE_INACCESSIBLE(mv)) {                                  \\\n        PyErr_SetString(PyExc_ValueError,                         \\\n            \"operation forbidden on released memoryview object\"); \\\n        return NULL;                                              \\\n    }\n\n#define CHECK_RELEASED_INT(mv) \\\n    if (BASE_INACCESSIBLE(mv)) {                                  \\\n        PyErr_SetString(PyExc_ValueError,                         \\\n            \"operation forbidden on released memoryview object\"); \\\n        return -1;                                                \\\n    }\n\n#define CHECK_RESTRICTED(mv) \\\n    if (((PyMemoryViewObject *)(mv))->flags & _Py_MEMORYVIEW_RESTRICTED) { \\\n        PyErr_SetString(PyExc_ValueError,                                  \\\n            \"cannot create new view on restricted memoryview\");            \\\n        return NULL;                                                       \\\n    }\n\n#define CHECK_RESTRICTED_INT(mv) \\\n    if (((PyMemoryViewObject *)(mv))->flags & _Py_MEMORYVIEW_RESTRICTED) { \\\n        PyErr_SetString(PyExc_ValueError,                                  \\\n            \"cannot create new view on restricted memoryview\");            \\\n        return -1;                                                       \\\n    }\n\n/* See gh-92888. These macros signal that we need to check the memoryview\n   again due to possible read after frees. */\n#define CHECK_RELEASED_AGAIN(mv) CHECK_RELEASED(mv)\n#define CHECK_RELEASED_INT_AGAIN(mv) CHECK_RELEASED_INT(mv)\n\n#define CHECK_LIST_OR_TUPLE(v) \\\n    if (!PyList_Check(v) && !PyTuple_Check(v)) { \\\n        PyErr_SetString(PyExc_TypeError,         \\\n            #v \" must be a list or a tuple\");    \\\n        return NULL;                             \\\n    }\n\n#define VIEW_ADDR(mv) (&((PyMemoryViewObject *)mv)->view)\n\n/* Check for the presence of suboffsets in the first dimension. */\n#define HAVE_PTR(suboffsets, dim) (suboffsets && suboffsets[dim] >= 0)\n/* Adjust ptr if suboffsets are present. */\n#define ADJUST_PTR(ptr, suboffsets, dim) \\\n    (HAVE_PTR(suboffsets, dim) ? *((char**)ptr) + suboffsets[dim] : ptr)\n\n/* Memoryview buffer properties */\n#define MV_C_CONTIGUOUS(flags) (flags&(_Py_MEMORYVIEW_SCALAR|_Py_MEMORYVIEW_C))\n#define MV_F_CONTIGUOUS(flags) \\\n    (flags&(_Py_MEMORYVIEW_SCALAR|_Py_MEMORYVIEW_FORTRAN))\n#define MV_ANY_CONTIGUOUS(flags) \\\n    (flags&(_Py_MEMORYVIEW_SCALAR|_Py_MEMORYVIEW_C|_Py_MEMORYVIEW_FORTRAN))\n\n/* Fast contiguity test. Caller must ensure suboffsets==NULL and ndim==1. */\n#define MV_CONTIGUOUS_NDIM1(view) \\\n    ((view)->shape[0] == 1 || (view)->strides[0] == (view)->itemsize)\n\n/* getbuffer() requests */\n#define REQ_INDIRECT(flags) ((flags&PyBUF_INDIRECT) == PyBUF_INDIRECT)\n#define REQ_C_CONTIGUOUS(flags) ((flags&PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS)\n#define REQ_F_CONTIGUOUS(flags) ((flags&PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS)\n#define REQ_ANY_CONTIGUOUS(flags) ((flags&PyBUF_ANY_CONTIGUOUS) == PyBUF_ANY_CONTIGUOUS)\n#define REQ_STRIDES(flags) ((flags&PyBUF_STRIDES) == PyBUF_STRIDES)\n#define REQ_SHAPE(flags) ((flags&PyBUF_ND) == PyBUF_ND)\n#define REQ_WRITABLE(flags) (flags&PyBUF_WRITABLE)\n#define REQ_FORMAT(flags) (flags&PyBUF_FORMAT)\n\n\n/**************************************************************************/\n/*                       Copy memoryview buffers                          */\n/**************************************************************************/\n\n/* The functions in this section take a source and a destination buffer\n   with the same logical structure: format, itemsize, ndim and shape\n   are identical, with ndim > 0.\n\n   NOTE: All buffers are assumed to have PyBUF_FULL information, which\n   is the case for memoryviews! */\n\n\n/* Assumptions: ndim >= 1. The macro tests for a corner case that should\n   perhaps be explicitly forbidden in the PEP. */\n#define HAVE_SUBOFFSETS_IN_LAST_DIM(view) \\\n    (view->suboffsets && view->suboffsets[view->ndim-1] >= 0)\n\nstatic inline int\nlast_dim_is_contiguous(const Py_buffer *dest, const Py_buffer *src)\n{\n    assert(dest->ndim > 0 && src->ndim > 0);\n    return (!HAVE_SUBOFFSETS_IN_LAST_DIM(dest) &&\n            !HAVE_SUBOFFSETS_IN_LAST_DIM(src) &&\n            dest->strides[dest->ndim-1] == dest->itemsize &&\n            src->strides[src->ndim-1] == src->itemsize);\n}\n\n/* This is not a general function for determining format equivalence.\n   It is used in copy_single() and copy_buffer() to weed out non-matching\n   formats. Skipping the '@' character is specifically used in slice\n   assignments, where the lvalue is already known to have a single character\n   format. This is a performance hack that could be rewritten (if properly\n   benchmarked). */\nstatic inline int\nequiv_format(const Py_buffer *dest, const Py_buffer *src)\n{\n    const char *dfmt, *sfmt;\n\n    assert(dest->format && src->format);\n    dfmt = dest->format[0] == '@' ? dest->format+1 : dest->format;\n    sfmt = src->format[0] == '@' ? src->format+1 : src->format;\n\n    if (strcmp(dfmt, sfmt) != 0 ||\n        dest->itemsize != src->itemsize) {\n        return 0;\n    }\n\n    return 1;\n}\n\n/* Two shapes are equivalent if they are either equal or identical up\n   to a zero element at the same position. For example, in NumPy arrays\n   the shapes [1, 0, 5] and [1, 0, 7] are equivalent. */\nstatic inline int\nequiv_shape(const Py_buffer *dest, const Py_buffer *src)\n{\n    int i;\n\n    if (dest->ndim != src->ndim)\n        return 0;\n\n    for (i = 0; i < dest->ndim; i++) {\n        if (dest->shape[i] != src->shape[i])\n            return 0;\n        if (dest->shape[i] == 0)\n            break;\n    }\n\n    return 1;\n}\n\n/* Check that the logical structure of the destination and source buffers\n   is identical. */\nstatic int\nequiv_structure(const Py_buffer *dest, const Py_buffer *src)\n{\n    if (!equiv_format(dest, src) ||\n        !equiv_shape(dest, src)) {\n        PyErr_SetString(PyExc_ValueError,\n            \"memoryview assignment: lvalue and rvalue have different \"\n            \"structures\");\n        return 0;\n    }\n\n    return 1;\n}\n\n/* Base case for recursive multi-dimensional copying. Contiguous arrays are\n   copied with very little overhead. Assumptions: ndim == 1, mem == NULL or\n   sizeof(mem) == shape[0] * itemsize. */\nstatic void\ncopy_base(const Py_ssize_t *shape, Py_ssize_t itemsize,\n          char *dptr, const Py_ssize_t *dstrides, const Py_ssize_t *dsuboffsets,\n          char *sptr, const Py_ssize_t *sstrides, const Py_ssize_t *ssuboffsets,\n          char *mem)\n{\n    if (mem == NULL) { /* contiguous */\n        Py_ssize_t size = shape[0] * itemsize;\n        if (dptr + size < sptr || sptr + size < dptr)\n            memcpy(dptr, sptr, size); /* no overlapping */\n        else\n            memmove(dptr, sptr, size);\n    }\n    else {\n        char *p;\n        Py_ssize_t i;\n        for (i=0, p=mem; i < shape[0]; p+=itemsize, sptr+=sstrides[0], i++) {\n            char *xsptr = ADJUST_PTR(sptr, ssuboffsets, 0);\n            memcpy(p, xsptr, itemsize);\n        }\n        for (i=0, p=mem; i < shape[0]; p+=itemsize, dptr+=dstrides[0], i++) {\n            char *xdptr = ADJUST_PTR(dptr, dsuboffsets, 0);\n            memcpy(xdptr, p, itemsize);\n        }\n    }\n\n}\n\n/* Recursively copy a source buffer to a destination buffer. The two buffers\n   have the same ndim, shape and itemsize. */\nstatic void\ncopy_rec(const Py_ssize_t *shape, Py_ssize_t ndim, Py_ssize_t itemsize,\n         char *dptr, const Py_ssize_t *dstrides, const Py_ssize_t *dsuboffsets,\n         char *sptr, const Py_ssize_t *sstrides, const Py_ssize_t *ssuboffsets,\n         char *mem)\n{\n    Py_ssize_t i;\n\n    assert(ndim >= 1);\n\n    if (ndim == 1) {\n        copy_base(shape, itemsize,\n                  dptr, dstrides, dsuboffsets,\n                  sptr, sstrides, ssuboffsets,\n                  mem);\n        return;\n    }\n\n    for (i = 0; i < shape[0]; dptr+=dstrides[0], sptr+=sstrides[0], i++) {\n        char *xdptr = ADJUST_PTR(dptr, dsuboffsets, 0);\n        char *xsptr = ADJUST_PTR(sptr, ssuboffsets, 0);\n\n        copy_rec(shape+1, ndim-1, itemsize,\n                 xdptr, dstrides+1, dsuboffsets ? dsuboffsets+1 : NULL,\n                 xsptr, sstrides+1, ssuboffsets ? ssuboffsets+1 : NULL,\n                 mem);\n    }\n}\n\n/* Faster copying of one-dimensional arrays. */\nstatic int\ncopy_single(PyMemoryViewObject *self, const Py_buffer *dest, const Py_buffer *src)\n{\n    CHECK_RELEASED_INT_AGAIN(self);\n    char *mem = NULL;\n\n    assert(dest->ndim == 1);\n\n    if (!equiv_structure(dest, src))\n        return -1;\n\n    if (!last_dim_is_contiguous(dest, src)) {\n        mem = PyMem_Malloc(dest->shape[0] * dest->itemsize);\n        if (mem == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n    }\n\n    copy_base(dest->shape, dest->itemsize,\n              dest->buf, dest->strides, dest->suboffsets,\n              src->buf, src->strides, src->suboffsets,\n              mem);\n\n    if (mem)\n        PyMem_Free(mem);\n\n    return 0;\n}\n\n/* Recursively copy src to dest. Both buffers must have the same basic\n   structure. Copying is atomic, the function never fails with a partial\n   copy. */\nstatic int\ncopy_buffer(const Py_buffer *dest, const Py_buffer *src)\n{\n    char *mem = NULL;\n\n    assert(dest->ndim > 0);\n\n    if (!equiv_structure(dest, src))\n        return -1;\n\n    if (!last_dim_is_contiguous(dest, src)) {\n        mem = PyMem_Malloc(dest->shape[dest->ndim-1] * dest->itemsize);\n        if (mem == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n    }\n\n    copy_rec(dest->shape, dest->ndim, dest->itemsize,\n             dest->buf, dest->strides, dest->suboffsets,\n             src->buf, src->strides, src->suboffsets,\n             mem);\n\n    if (mem)\n        PyMem_Free(mem);\n\n    return 0;\n}\n\n/* Initialize strides for a C-contiguous array. */\nstatic inline void\ninit_strides_from_shape(Py_buffer *view)\n{\n    Py_ssize_t i;\n\n    assert(view->ndim > 0);\n\n    view->strides[view->ndim-1] = view->itemsize;\n    for (i = view->ndim-2; i >= 0; i--)\n        view->strides[i] = view->strides[i+1] * view->shape[i+1];\n}\n\n/* Initialize strides for a Fortran-contiguous array. */\nstatic inline void\ninit_fortran_strides_from_shape(Py_buffer *view)\n{\n    Py_ssize_t i;\n\n    assert(view->ndim > 0);\n\n    view->strides[0] = view->itemsize;\n    for (i = 1; i < view->ndim; i++)\n        view->strides[i] = view->strides[i-1] * view->shape[i-1];\n}\n\n/* Copy src to a contiguous representation. order is one of 'C', 'F' (Fortran)\n   or 'A' (Any). Assumptions: src has PyBUF_FULL information, src->ndim >= 1,\n   len(mem) == src->len. */\nstatic int\nbuffer_to_contiguous(char *mem, const Py_buffer *src, char order)\n{\n    Py_buffer dest;\n    Py_ssize_t *strides;\n    int ret;\n\n    assert(src->ndim >= 1);\n    assert(src->shape != NULL);\n    assert(src->strides != NULL);\n\n    strides = PyMem_Malloc(src->ndim * (sizeof *src->strides));\n    if (strides == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n\n    /* initialize dest */\n    dest = *src;\n    dest.buf = mem;\n    /* shape is constant and shared: the logical representation of the\n       array is unaltered. */\n\n    /* The physical representation determined by strides (and possibly\n       suboffsets) may change. */\n    dest.strides = strides;\n    if (order == 'C' || order == 'A') {\n        init_strides_from_shape(&dest);\n    }\n    else {\n        init_fortran_strides_from_shape(&dest);\n    }\n\n    dest.suboffsets = NULL;\n\n    ret = copy_buffer(&dest, src);\n\n    PyMem_Free(strides);\n    return ret;\n}\n\n\n/****************************************************************************/\n/*                               Constructors                               */\n/****************************************************************************/\n\n/* Initialize values that are shared with the managed buffer. */\nstatic inline void\ninit_shared_values(Py_buffer *dest, const Py_buffer *src)\n{\n    dest->obj = src->obj;\n    dest->buf = src->buf;\n    dest->len = src->len;\n    dest->itemsize = src->itemsize;\n    dest->readonly = src->readonly;\n    dest->format = src->format ? src->format : \"B\";\n    dest->internal = src->internal;\n}\n\n/* Copy shape and strides. Reconstruct missing values. */\nstatic void\ninit_shape_strides(Py_buffer *dest, const Py_buffer *src)\n{\n    Py_ssize_t i;\n\n    if (src->ndim == 0) {\n        dest->shape = NULL;\n        dest->strides = NULL;\n        return;\n    }\n    if (src->ndim == 1) {\n        dest->shape[0] = src->shape ? src->shape[0] : src->len / src->itemsize;\n        dest->strides[0] = src->strides ? src->strides[0] : src->itemsize;\n        return;\n    }\n\n    for (i = 0; i < src->ndim; i++)\n        dest->shape[i] = src->shape[i];\n    if (src->strides) {\n        for (i = 0; i < src->ndim; i++)\n            dest->strides[i] = src->strides[i];\n    }\n    else {\n        init_strides_from_shape(dest);\n    }\n}\n\nstatic inline void\ninit_suboffsets(Py_buffer *dest, const Py_buffer *src)\n{\n    Py_ssize_t i;\n\n    if (src->suboffsets == NULL) {\n        dest->suboffsets = NULL;\n        return;\n    }\n    for (i = 0; i < src->ndim; i++)\n        dest->suboffsets[i] = src->suboffsets[i];\n}\n\n/* len = product(shape) * itemsize */\nstatic inline void\ninit_len(Py_buffer *view)\n{\n    Py_ssize_t i, len;\n\n    len = 1;\n    for (i = 0; i < view->ndim; i++)\n        len *= view->shape[i];\n    len *= view->itemsize;\n\n    view->len = len;\n}\n\n/* Initialize memoryview buffer properties. */\nstatic void\ninit_flags(PyMemoryViewObject *mv)\n{\n    const Py_buffer *view = &mv->view;\n    int flags = 0;\n\n    switch (view->ndim) {\n    case 0:\n        flags |= (_Py_MEMORYVIEW_SCALAR|_Py_MEMORYVIEW_C|\n                  _Py_MEMORYVIEW_FORTRAN);\n        break;\n    case 1:\n        if (MV_CONTIGUOUS_NDIM1(view))\n            flags |= (_Py_MEMORYVIEW_C|_Py_MEMORYVIEW_FORTRAN);\n        break;\n    default:\n        if (PyBuffer_IsContiguous(view, 'C'))\n            flags |= _Py_MEMORYVIEW_C;\n        if (PyBuffer_IsContiguous(view, 'F'))\n            flags |= _Py_MEMORYVIEW_FORTRAN;\n        break;\n    }\n\n    if (view->suboffsets) {\n        flags |= _Py_MEMORYVIEW_PIL;\n        flags &= ~(_Py_MEMORYVIEW_C|_Py_MEMORYVIEW_FORTRAN);\n    }\n\n    mv->flags = flags;\n}\n\n/* Allocate a new memoryview and perform basic initialization. New memoryviews\n   are exclusively created through the mbuf_add functions. */\nstatic inline PyMemoryViewObject *\nmemory_alloc(int ndim)\n{\n    PyMemoryViewObject *mv;\n\n    mv = (PyMemoryViewObject *)\n        PyObject_GC_NewVar(PyMemoryViewObject, &PyMemoryView_Type, 3*ndim);\n    if (mv == NULL)\n        return NULL;\n\n    mv->mbuf = NULL;\n    mv->hash = -1;\n    mv->flags = 0;\n    mv->exports = 0;\n    mv->view.ndim = ndim;\n    mv->view.shape = mv->ob_array;\n    mv->view.strides = mv->ob_array + ndim;\n    mv->view.suboffsets = mv->ob_array + 2 * ndim;\n    mv->weakreflist = NULL;\n\n    _PyObject_GC_TRACK(mv);\n    return mv;\n}\n\n/*\n   Return a new memoryview that is registered with mbuf. If src is NULL,\n   use mbuf->master as the underlying buffer. Otherwise, use src.\n\n   The new memoryview has full buffer information: shape and strides\n   are always present, suboffsets as needed. Arrays are copied to\n   the memoryview's ob_array field.\n */\nstatic PyObject *\nmbuf_add_view(_PyManagedBufferObject *mbuf, const Py_buffer *src)\n{\n    PyMemoryViewObject *mv;\n    Py_buffer *dest;\n\n    if (src == NULL)\n        src = &mbuf->master;\n\n    if (src->ndim > PyBUF_MAX_NDIM) {\n        PyErr_SetString(PyExc_ValueError,\n            \"memoryview: number of dimensions must not exceed \"\n            Py_STRINGIFY(PyBUF_MAX_NDIM));\n        return NULL;\n    }\n\n    mv = memory_alloc(src->ndim);\n    if (mv == NULL)\n        return NULL;\n\n    dest = &mv->view;\n    init_shared_values(dest, src);\n    init_shape_strides(dest, src);\n    init_suboffsets(dest, src);\n    init_flags(mv);\n\n    mv->mbuf = (_PyManagedBufferObject*)Py_NewRef(mbuf);\n    mbuf->exports++;\n\n    return (PyObject *)mv;\n}\n\n/* Register an incomplete view: shape, strides, suboffsets and flags still\n   need to be initialized. Use 'ndim' instead of src->ndim to determine the\n   size of the memoryview's ob_array.\n\n   Assumption: ndim <= PyBUF_MAX_NDIM. */\nstatic PyObject *\nmbuf_add_incomplete_view(_PyManagedBufferObject *mbuf, const Py_buffer *src,\n                         int ndim)\n{\n    PyMemoryViewObject *mv;\n    Py_buffer *dest;\n\n    if (src == NULL)\n        src = &mbuf->master;\n\n    assert(ndim <= PyBUF_MAX_NDIM);\n\n    mv = memory_alloc(ndim);\n    if (mv == NULL)\n        return NULL;\n\n    dest = &mv->view;\n    init_shared_values(dest, src);\n\n    mv->mbuf = (_PyManagedBufferObject*)Py_NewRef(mbuf);\n    mbuf->exports++;\n\n    return (PyObject *)mv;\n}\n\n/* Expose a raw memory area as a view of contiguous bytes. flags can be\n   PyBUF_READ or PyBUF_WRITE. view->format is set to \"B\" (unsigned bytes).\n   The memoryview has complete buffer information. */\nPyObject *\nPyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)\n{\n    _PyManagedBufferObject *mbuf;\n    PyObject *mv;\n    int readonly;\n\n    assert(mem != NULL);\n    assert(flags == PyBUF_READ || flags == PyBUF_WRITE);\n\n    mbuf = mbuf_alloc();\n    if (mbuf == NULL)\n        return NULL;\n\n    readonly = (flags == PyBUF_WRITE) ? 0 : 1;\n    (void)PyBuffer_FillInfo(&mbuf->master, NULL, mem, size, readonly,\n                            PyBUF_FULL_RO);\n\n    mv = mbuf_add_view(mbuf, NULL);\n    Py_DECREF(mbuf);\n\n    return mv;\n}\n\n/* Create a memoryview from a given Py_buffer. For simple byte views,\n   PyMemoryView_FromMemory() should be used instead.\n   This function is the only entry point that can create a master buffer\n   without full information. Because of this fact init_shape_strides()\n   must be able to reconstruct missing values.  */\nPyObject *\nPyMemoryView_FromBuffer(const Py_buffer *info)\n{\n    _PyManagedBufferObject *mbuf;\n    PyObject *mv;\n\n    if (info->buf == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n            \"PyMemoryView_FromBuffer(): info->buf must not be NULL\");\n        return NULL;\n    }\n\n    mbuf = mbuf_alloc();\n    if (mbuf == NULL)\n        return NULL;\n\n    /* info->obj is either NULL or a borrowed reference. This reference\n       should not be decremented in PyBuffer_Release(). */\n    mbuf->master = *info;\n    mbuf->master.obj = NULL;\n\n    mv = mbuf_add_view(mbuf, NULL);\n    Py_DECREF(mbuf);\n\n    return mv;\n}\n\n/* Create a memoryview from an object that implements the buffer protocol,\n   using the given flags.\n   If the object is a memoryview, the new memoryview must be registered\n   with the same managed buffer. Otherwise, a new managed buffer is created. */\nstatic PyObject *\nPyMemoryView_FromObjectAndFlags(PyObject *v, int flags)\n{\n    _PyManagedBufferObject *mbuf;\n\n    if (PyMemoryView_Check(v)) {\n        PyMemoryViewObject *mv = (PyMemoryViewObject *)v;\n        CHECK_RELEASED(mv);\n        CHECK_RESTRICTED(mv);\n        return mbuf_add_view(mv->mbuf, &mv->view);\n    }\n    else if (PyObject_CheckBuffer(v)) {\n        PyObject *ret;\n        mbuf = (_PyManagedBufferObject *)_PyManagedBuffer_FromObject(v, flags);\n        if (mbuf == NULL)\n            return NULL;\n        ret = mbuf_add_view(mbuf, NULL);\n        Py_DECREF(mbuf);\n        return ret;\n    }\n\n    PyErr_Format(PyExc_TypeError,\n        \"memoryview: a bytes-like object is required, not '%.200s'\",\n        Py_TYPE(v)->tp_name);\n    return NULL;\n}\n\n/* Create a memoryview from an object that implements the buffer protocol,\n   using the given flags.\n   If the object is a memoryview, the new memoryview must be registered\n   with the same managed buffer. Otherwise, a new managed buffer is created. */\nPyObject *\n_PyMemoryView_FromBufferProc(PyObject *v, int flags, getbufferproc bufferproc)\n{\n    _PyManagedBufferObject *mbuf = mbuf_alloc();\n    if (mbuf == NULL)\n        return NULL;\n\n    int res = bufferproc(v, &mbuf->master, flags);\n    if (res < 0) {\n        mbuf->master.obj = NULL;\n        Py_DECREF(mbuf);\n        return NULL;\n    }\n\n    PyObject *ret = mbuf_add_view(mbuf, NULL);\n    Py_DECREF(mbuf);\n    return ret;\n}\n\n/* Create a memoryview from an object that implements the buffer protocol.\n   If the object is a memoryview, the new memoryview must be registered\n   with the same managed buffer. Otherwise, a new managed buffer is created. */\nPyObject *\nPyMemoryView_FromObject(PyObject *v)\n{\n    return PyMemoryView_FromObjectAndFlags(v, PyBUF_FULL_RO);\n}\n\n/* Copy the format string from a base object that might vanish. */\nstatic int\nmbuf_copy_format(_PyManagedBufferObject *mbuf, const char *fmt)\n{\n    if (fmt != NULL) {\n        char *cp = PyMem_Malloc(strlen(fmt)+1);\n        if (cp == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        mbuf->master.format = strcpy(cp, fmt);\n        mbuf->flags |= _Py_MANAGED_BUFFER_FREE_FORMAT;\n    }\n\n    return 0;\n}\n\n/*\n   Return a memoryview that is based on a contiguous copy of src.\n   Assumptions: src has PyBUF_FULL_RO information, src->ndim > 0.\n\n   Ownership rules:\n     1) As usual, the returned memoryview has a private copy\n        of src->shape, src->strides and src->suboffsets.\n     2) src->format is copied to the master buffer and released\n        in mbuf_dealloc(). The releasebufferproc of the bytes\n        object is NULL, so it does not matter that mbuf_release()\n        passes the altered format pointer to PyBuffer_Release().\n*/\nstatic PyObject *\nmemory_from_contiguous_copy(const Py_buffer *src, char order)\n{\n    _PyManagedBufferObject *mbuf;\n    PyMemoryViewObject *mv;\n    PyObject *bytes;\n    Py_buffer *dest;\n    int i;\n\n    assert(src->ndim > 0);\n    assert(src->shape != NULL);\n\n    bytes = PyBytes_FromStringAndSize(NULL, src->len);\n    if (bytes == NULL)\n        return NULL;\n\n    mbuf = (_PyManagedBufferObject *)_PyManagedBuffer_FromObject(bytes, PyBUF_FULL_RO);\n    Py_DECREF(bytes);\n    if (mbuf == NULL)\n        return NULL;\n\n    if (mbuf_copy_format(mbuf, src->format) < 0) {\n        Py_DECREF(mbuf);\n        return NULL;\n    }\n\n    mv = (PyMemoryViewObject *)mbuf_add_incomplete_view(mbuf, NULL, src->ndim);\n    Py_DECREF(mbuf);\n    if (mv == NULL)\n        return NULL;\n\n    dest = &mv->view;\n\n    /* shared values are initialized correctly except for itemsize */\n    dest->itemsize = src->itemsize;\n\n    /* shape and strides */\n    for (i = 0; i < src->ndim; i++) {\n        dest->shape[i] = src->shape[i];\n    }\n    if (order == 'C' || order == 'A') {\n        init_strides_from_shape(dest);\n    }\n    else {\n        init_fortran_strides_from_shape(dest);\n    }\n    /* suboffsets */\n    dest->suboffsets = NULL;\n\n    /* flags */\n    init_flags(mv);\n\n    if (copy_buffer(dest, src) < 0) {\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    return (PyObject *)mv;\n}\n\n/*\n   Return a new memoryview object based on a contiguous exporter with\n   buffertype={PyBUF_READ, PyBUF_WRITE} and order={'C', 'F'ortran, or 'A'ny}.\n   The logical structure of the input and output buffers is the same\n   (i.e. tolist(input) == tolist(output)), but the physical layout in\n   memory can be explicitly chosen.\n\n   As usual, if buffertype=PyBUF_WRITE, the exporter's buffer must be writable,\n   otherwise it may be writable or read-only.\n\n   If the exporter is already contiguous with the desired target order,\n   the memoryview will be directly based on the exporter.\n\n   Otherwise, if the buffertype is PyBUF_READ, the memoryview will be\n   based on a new bytes object. If order={'C', 'A'ny}, use 'C' order,\n   'F'ortran order otherwise.\n*/\nPyObject *\nPyMemoryView_GetContiguous(PyObject *obj, int buffertype, char order)\n{\n    PyMemoryViewObject *mv;\n    PyObject *ret;\n    Py_buffer *view;\n\n    assert(buffertype == PyBUF_READ || buffertype == PyBUF_WRITE);\n    assert(order == 'C' || order == 'F' || order == 'A');\n\n    mv = (PyMemoryViewObject *)PyMemoryView_FromObject(obj);\n    if (mv == NULL)\n        return NULL;\n\n    view = &mv->view;\n    if (buffertype == PyBUF_WRITE && view->readonly) {\n        PyErr_SetString(PyExc_BufferError,\n            \"underlying buffer is not writable\");\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (PyBuffer_IsContiguous(view, order))\n        return (PyObject *)mv;\n\n    if (buffertype == PyBUF_WRITE) {\n        PyErr_SetString(PyExc_BufferError,\n            \"writable contiguous buffer requested \"\n            \"for a non-contiguous object.\");\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    ret = memory_from_contiguous_copy(view, order);\n    Py_DECREF(mv);\n    return ret;\n}\n\n\n/*[clinic input]\n@classmethod\nmemoryview.__new__\n\n    object: object\n\nCreate a new memoryview object which references the given object.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_impl(PyTypeObject *type, PyObject *object)\n/*[clinic end generated code: output=7de78e184ed66db8 input=f04429eb0bdf8c6e]*/\n{\n    return PyMemoryView_FromObject(object);\n}\n\n\n/*[clinic input]\n@classmethod\nmemoryview._from_flags\n\n    object: object\n    flags: int\n\nCreate a new memoryview object which references the given object.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview__from_flags_impl(PyTypeObject *type, PyObject *object, int flags)\n/*[clinic end generated code: output=bf71f9906c266ee2 input=f5f82fd0e744356b]*/\n{\n    return PyMemoryView_FromObjectAndFlags(object, flags);\n}\n\n\n/****************************************************************************/\n/*                         Previously in abstract.c                         */\n/****************************************************************************/\n\ntypedef struct {\n    Py_buffer view;\n    Py_ssize_t array[1];\n} Py_buffer_full;\n\nint\nPyBuffer_ToContiguous(void *buf, const Py_buffer *src, Py_ssize_t len, char order)\n{\n    Py_buffer_full *fb = NULL;\n    int ret;\n\n    assert(order == 'C' || order == 'F' || order == 'A');\n\n    if (len != src->len) {\n        PyErr_SetString(PyExc_ValueError,\n            \"PyBuffer_ToContiguous: len != view->len\");\n        return -1;\n    }\n\n    if (PyBuffer_IsContiguous(src, order)) {\n        memcpy((char *)buf, src->buf, len);\n        return 0;\n    }\n\n    /* buffer_to_contiguous() assumes PyBUF_FULL */\n    fb = PyMem_Malloc(sizeof *fb + 3 * src->ndim * (sizeof *fb->array));\n    if (fb == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    fb->view.ndim = src->ndim;\n    fb->view.shape = fb->array;\n    fb->view.strides = fb->array + src->ndim;\n    fb->view.suboffsets = fb->array + 2 * src->ndim;\n\n    init_shared_values(&fb->view, src);\n    init_shape_strides(&fb->view, src);\n    init_suboffsets(&fb->view, src);\n\n    src = &fb->view;\n\n    ret = buffer_to_contiguous(buf, src, order);\n    PyMem_Free(fb);\n    return ret;\n}\n\n\n/****************************************************************************/\n/*                           Release/GC management                          */\n/****************************************************************************/\n\n/* Inform the managed buffer that this particular memoryview will not access\n   the underlying buffer again. If no other memoryviews are registered with\n   the managed buffer, the underlying buffer is released instantly and\n   marked as inaccessible for both the memoryview and the managed buffer.\n\n   This function fails if the memoryview itself has exported buffers. */\nstatic int\n_memory_release(PyMemoryViewObject *self)\n{\n    if (self->flags & _Py_MEMORYVIEW_RELEASED)\n        return 0;\n\n    if (self->exports == 0) {\n        self->flags |= _Py_MEMORYVIEW_RELEASED;\n        assert(self->mbuf->exports > 0);\n        if (--self->mbuf->exports == 0)\n            mbuf_release(self->mbuf);\n        return 0;\n    }\n    if (self->exports > 0) {\n        PyErr_Format(PyExc_BufferError,\n            \"memoryview has %zd exported buffer%s\", self->exports,\n            self->exports==1 ? \"\" : \"s\");\n        return -1;\n    }\n\n    PyErr_SetString(PyExc_SystemError,\n                    \"_memory_release(): negative export count\");\n    return -1;\n}\n\n/*[clinic input]\nmemoryview.release\n\nRelease the underlying buffer exposed by the memoryview object.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_release_impl(PyMemoryViewObject *self)\n/*[clinic end generated code: output=d0b7e3ba95b7fcb9 input=bc71d1d51f4a52f0]*/\n{\n    if (_memory_release(self) < 0)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\nstatic void\nmemory_dealloc(PyObject *_self)\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    assert(self->exports == 0);\n    _PyObject_GC_UNTRACK(self);\n    (void)_memory_release(self);\n    Py_CLEAR(self->mbuf);\n    if (self->weakreflist != NULL)\n        PyObject_ClearWeakRefs((PyObject *) self);\n    PyObject_GC_Del(self);\n}\n\nstatic int\nmemory_traverse(PyObject *_self, visitproc visit, void *arg)\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    Py_VISIT(self->mbuf);\n    return 0;\n}\n\nstatic int\nmemory_clear(PyObject *_self)\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    (void)_memory_release(self);\n    Py_CLEAR(self->mbuf);\n    return 0;\n}\n\nstatic PyObject *\nmemory_enter(PyObject *self, PyObject *args)\n{\n    CHECK_RELEASED(self);\n    return Py_NewRef(self);\n}\n\nstatic PyObject *\nmemory_exit(PyObject *self, PyObject *args)\n{\n    return memoryview_release_impl((PyMemoryViewObject *)self);\n}\n\n\n/****************************************************************************/\n/*                         Casting format and shape                         */\n/****************************************************************************/\n\n#define IS_BYTE_FORMAT(f) (f == 'b' || f == 'B' || f == 'c')\n\nstatic inline Py_ssize_t\nget_native_fmtchar(char *result, const char *fmt)\n{\n    Py_ssize_t size = -1;\n\n    if (fmt[0] == '@') fmt++;\n\n    switch (fmt[0]) {\n    case 'c': case 'b': case 'B': size = sizeof(char); break;\n    case 'h': case 'H': size = sizeof(short); break;\n    case 'i': case 'I': size = sizeof(int); break;\n    case 'l': case 'L': size = sizeof(long); break;\n    case 'q': case 'Q': size = sizeof(long long); break;\n    case 'n': case 'N': size = sizeof(Py_ssize_t); break;\n    case 'f': size = sizeof(float); break;\n    case 'd': size = sizeof(double); break;\n    case 'e': size = sizeof(float) / 2; break;\n    case '?': size = sizeof(_Bool); break;\n    case 'P': size = sizeof(void *); break;\n    }\n\n    if (size > 0 && fmt[1] == '\\0') {\n        *result = fmt[0];\n        return size;\n    }\n\n    return -1;\n}\n\nstatic inline const char *\nget_native_fmtstr(const char *fmt)\n{\n    int at = 0;\n\n    if (fmt[0] == '@') {\n        at = 1;\n        fmt++;\n    }\n    if (fmt[0] == '\\0' || fmt[1] != '\\0') {\n        return NULL;\n    }\n\n#define RETURN(s) do { return at ? \"@\" s : s; } while (0)\n\n    switch (fmt[0]) {\n    case 'c': RETURN(\"c\");\n    case 'b': RETURN(\"b\");\n    case 'B': RETURN(\"B\");\n    case 'h': RETURN(\"h\");\n    case 'H': RETURN(\"H\");\n    case 'i': RETURN(\"i\");\n    case 'I': RETURN(\"I\");\n    case 'l': RETURN(\"l\");\n    case 'L': RETURN(\"L\");\n    case 'q': RETURN(\"q\");\n    case 'Q': RETURN(\"Q\");\n    case 'n': RETURN(\"n\");\n    case 'N': RETURN(\"N\");\n    case 'f': RETURN(\"f\");\n    case 'd': RETURN(\"d\");\n    case 'e': RETURN(\"e\");\n    case '?': RETURN(\"?\");\n    case 'P': RETURN(\"P\");\n    }\n\n    return NULL;\n}\n\n\n/* Cast a memoryview's data type to 'format'. The input array must be\n   C-contiguous. At least one of input-format, output-format must have\n   byte size. The output array is 1-D, with the same byte length as the\n   input array. Thus, view->len must be a multiple of the new itemsize. */\nstatic int\ncast_to_1D(PyMemoryViewObject *mv, PyObject *format)\n{\n    Py_buffer *view = &mv->view;\n    PyObject *asciifmt;\n    char srcchar, destchar;\n    Py_ssize_t itemsize;\n    int ret = -1;\n\n    assert(view->ndim >= 1);\n    assert(Py_SIZE(mv) == 3*view->ndim);\n    assert(view->shape == mv->ob_array);\n    assert(view->strides == mv->ob_array + view->ndim);\n    assert(view->suboffsets == mv->ob_array + 2*view->ndim);\n\n    asciifmt = PyUnicode_AsASCIIString(format);\n    if (asciifmt == NULL)\n        return ret;\n\n    itemsize = get_native_fmtchar(&destchar, PyBytes_AS_STRING(asciifmt));\n    if (itemsize < 0) {\n        PyErr_SetString(PyExc_ValueError,\n            \"memoryview: destination format must be a native single \"\n            \"character format prefixed with an optional '@'\");\n        goto out;\n    }\n\n    if ((get_native_fmtchar(&srcchar, view->format) < 0 ||\n         !IS_BYTE_FORMAT(srcchar)) && !IS_BYTE_FORMAT(destchar)) {\n        PyErr_SetString(PyExc_TypeError,\n            \"memoryview: cannot cast between two non-byte formats\");\n        goto out;\n    }\n    if (view->len % itemsize) {\n        PyErr_SetString(PyExc_TypeError,\n            \"memoryview: length is not a multiple of itemsize\");\n        goto out;\n    }\n\n    view->format = (char *)get_native_fmtstr(PyBytes_AS_STRING(asciifmt));\n    if (view->format == NULL) {\n        /* NOT_REACHED: get_native_fmtchar() already validates the format. */\n        PyErr_SetString(PyExc_RuntimeError,\n            \"memoryview: internal error\");\n        goto out;\n    }\n    view->itemsize = itemsize;\n\n    view->ndim = 1;\n    view->shape[0] = view->len / view->itemsize;\n    view->strides[0] = view->itemsize;\n    view->suboffsets = NULL;\n\n    init_flags(mv);\n\n    ret = 0;\n\nout:\n    Py_DECREF(asciifmt);\n    return ret;\n}\n\n/* The memoryview must have space for 3*len(seq) elements. */\nstatic Py_ssize_t\ncopy_shape(Py_ssize_t *shape, const PyObject *seq, Py_ssize_t ndim,\n           Py_ssize_t itemsize)\n{\n    Py_ssize_t x, i;\n    Py_ssize_t len = itemsize;\n\n    for (i = 0; i < ndim; i++) {\n        PyObject *tmp = PySequence_Fast_GET_ITEM(seq, i);\n        if (!PyLong_Check(tmp)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"memoryview.cast(): elements of shape must be integers\");\n            return -1;\n        }\n        x = PyLong_AsSsize_t(tmp);\n        if (x == -1 && PyErr_Occurred()) {\n            return -1;\n        }\n        if (x <= 0) {\n            /* In general elements of shape may be 0, but not for casting. */\n            PyErr_Format(PyExc_ValueError,\n                \"memoryview.cast(): elements of shape must be integers > 0\");\n            return -1;\n        }\n        if (x > PY_SSIZE_T_MAX / len) {\n            PyErr_Format(PyExc_ValueError,\n                \"memoryview.cast(): product(shape) > SSIZE_MAX\");\n            return -1;\n        }\n        len *= x;\n        shape[i] = x;\n    }\n\n    return len;\n}\n\n/* Cast a 1-D array to a new shape. The result array will be C-contiguous.\n   If the result array does not have exactly the same byte length as the\n   input array, raise ValueError. */\nstatic int\ncast_to_ND(PyMemoryViewObject *mv, const PyObject *shape, int ndim)\n{\n    Py_buffer *view = &mv->view;\n    Py_ssize_t len;\n\n    assert(view->ndim == 1); /* ndim from cast_to_1D() */\n    assert(Py_SIZE(mv) == 3*(ndim==0?1:ndim)); /* ndim of result array */\n    assert(view->shape == mv->ob_array);\n    assert(view->strides == mv->ob_array + (ndim==0?1:ndim));\n    assert(view->suboffsets == NULL);\n\n    view->ndim = ndim;\n    if (view->ndim == 0) {\n        view->shape = NULL;\n        view->strides = NULL;\n        len = view->itemsize;\n    }\n    else {\n        len = copy_shape(view->shape, shape, ndim, view->itemsize);\n        if (len < 0)\n            return -1;\n        init_strides_from_shape(view);\n    }\n\n    if (view->len != len) {\n        PyErr_SetString(PyExc_TypeError,\n            \"memoryview: product(shape) * itemsize != buffer size\");\n        return -1;\n    }\n\n    init_flags(mv);\n\n    return 0;\n}\n\nstatic int\nzero_in_shape(PyMemoryViewObject *mv)\n{\n    Py_buffer *view = &mv->view;\n    Py_ssize_t i;\n\n    for (i = 0; i < view->ndim; i++)\n        if (view->shape[i] == 0)\n            return 1;\n\n    return 0;\n}\n\n/*\n   Cast a copy of 'self' to a different view. The input view must\n   be C-contiguous. The function always casts the input view to a\n   1-D output according to 'format'. At least one of input-format,\n   output-format must have byte size.\n\n   If 'shape' is given, the 1-D view from the previous step will\n   be cast to a C-contiguous view with new shape and strides.\n\n   All casts must result in views that will have the exact byte\n   size of the original input. Otherwise, an error is raised.\n*/\n/*[clinic input]\nmemoryview.cast\n\n    format: unicode\n    shape: object = NULL\n\nCast a memoryview to a new format or shape.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_cast_impl(PyMemoryViewObject *self, PyObject *format,\n                     PyObject *shape)\n/*[clinic end generated code: output=bae520b3a389cbab input=138936cc9041b1a3]*/\n{\n    PyMemoryViewObject *mv = NULL;\n    Py_ssize_t ndim = 1;\n\n    CHECK_RELEASED(self);\n    CHECK_RESTRICTED(self);\n\n    if (!MV_C_CONTIGUOUS(self->flags)) {\n        PyErr_SetString(PyExc_TypeError,\n            \"memoryview: casts are restricted to C-contiguous views\");\n        return NULL;\n    }\n    if ((shape || self->view.ndim != 1) && zero_in_shape(self)) {\n        PyErr_SetString(PyExc_TypeError,\n            \"memoryview: cannot cast view with zeros in shape or strides\");\n        return NULL;\n    }\n    if (shape) {\n        CHECK_LIST_OR_TUPLE(shape)\n        ndim = PySequence_Fast_GET_SIZE(shape);\n        if (ndim > PyBUF_MAX_NDIM) {\n            PyErr_SetString(PyExc_ValueError,\n                \"memoryview: number of dimensions must not exceed \"\n                Py_STRINGIFY(PyBUF_MAX_NDIM));\n            return NULL;\n        }\n        if (self->view.ndim != 1 && ndim != 1) {\n            PyErr_SetString(PyExc_TypeError,\n                \"memoryview: cast must be 1D -> ND or ND -> 1D\");\n            return NULL;\n        }\n    }\n\n    mv = (PyMemoryViewObject *)\n        mbuf_add_incomplete_view(self->mbuf, &self->view, ndim==0 ? 1 : (int)ndim);\n    if (mv == NULL)\n        return NULL;\n\n    if (cast_to_1D(mv, format) < 0)\n        goto error;\n    if (shape && cast_to_ND(mv, shape, (int)ndim) < 0)\n        goto error;\n\n    return (PyObject *)mv;\n\nerror:\n    Py_DECREF(mv);\n    return NULL;\n}\n\n/*[clinic input]\nmemoryview.toreadonly\n\nReturn a readonly version of the memoryview.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_toreadonly_impl(PyMemoryViewObject *self)\n/*[clinic end generated code: output=2c7e056f04c99e62 input=dc06d20f19ba236f]*/\n{\n    CHECK_RELEASED(self);\n    CHECK_RESTRICTED(self);\n    /* Even if self is already readonly, we still need to create a new\n     * object for .release() to work correctly.\n     */\n    self = (PyMemoryViewObject *) mbuf_add_view(self->mbuf, &self->view);\n    if (self != NULL) {\n        self->view.readonly = 1;\n    };\n    return (PyObject *) self;\n}\n\n\n/**************************************************************************/\n/*                               getbuffer                                */\n/**************************************************************************/\n\nstatic int\nmemory_getbuf(PyObject *_self, Py_buffer *view, int flags)\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    Py_buffer *base = &self->view;\n    int baseflags = self->flags;\n\n    CHECK_RELEASED_INT(self);\n    CHECK_RESTRICTED_INT(self);\n\n    /* start with complete information */\n    *view = *base;\n    view->obj = NULL;\n\n    if (REQ_WRITABLE(flags) && base->readonly) {\n        PyErr_SetString(PyExc_BufferError,\n            \"memoryview: underlying buffer is not writable\");\n        return -1;\n    }\n    if (!REQ_FORMAT(flags)) {\n        /* NULL indicates that the buffer's data type has been cast to 'B'.\n           view->itemsize is the _previous_ itemsize. If shape is present,\n           the equality product(shape) * itemsize = len still holds at this\n           point. The equality calcsize(format) = itemsize does _not_ hold\n           from here on! */\n        view->format = NULL;\n    }\n\n    if (REQ_C_CONTIGUOUS(flags) && !MV_C_CONTIGUOUS(baseflags)) {\n        PyErr_SetString(PyExc_BufferError,\n            \"memoryview: underlying buffer is not C-contiguous\");\n        return -1;\n    }\n    if (REQ_F_CONTIGUOUS(flags) && !MV_F_CONTIGUOUS(baseflags)) {\n        PyErr_SetString(PyExc_BufferError,\n            \"memoryview: underlying buffer is not Fortran contiguous\");\n        return -1;\n    }\n    if (REQ_ANY_CONTIGUOUS(flags) && !MV_ANY_CONTIGUOUS(baseflags)) {\n        PyErr_SetString(PyExc_BufferError,\n            \"memoryview: underlying buffer is not contiguous\");\n        return -1;\n    }\n    if (!REQ_INDIRECT(flags) && (baseflags & _Py_MEMORYVIEW_PIL)) {\n        PyErr_SetString(PyExc_BufferError,\n            \"memoryview: underlying buffer requires suboffsets\");\n        return -1;\n    }\n    if (!REQ_STRIDES(flags)) {\n        if (!MV_C_CONTIGUOUS(baseflags)) {\n            PyErr_SetString(PyExc_BufferError,\n                \"memoryview: underlying buffer is not C-contiguous\");\n            return -1;\n        }\n        view->strides = NULL;\n    }\n    if (!REQ_SHAPE(flags)) {\n        /* PyBUF_SIMPLE or PyBUF_WRITABLE: at this point buf is C-contiguous,\n           so base->buf = ndbuf->data. */\n        if (view->format != NULL) {\n            /* PyBUF_SIMPLE|PyBUF_FORMAT and PyBUF_WRITABLE|PyBUF_FORMAT do\n               not make sense. */\n            PyErr_Format(PyExc_BufferError,\n                \"memoryview: cannot cast to unsigned bytes if the format flag \"\n                \"is present\");\n            return -1;\n        }\n        /* product(shape) * itemsize = len and calcsize(format) = itemsize\n           do _not_ hold from here on! */\n        view->ndim = 1;\n        view->shape = NULL;\n    }\n\n\n    view->obj = Py_NewRef(self);\n    self->exports++;\n\n    return 0;\n}\n\nstatic void\nmemory_releasebuf(PyObject *_self, Py_buffer *view)\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    self->exports--;\n    return;\n    /* PyBuffer_Release() decrements view->obj after this function returns. */\n}\n\n/* Buffer methods */\nstatic PyBufferProcs memory_as_buffer = {\n    memory_getbuf,         /* bf_getbuffer */\n    memory_releasebuf,                    /* bf_releasebuffer */\n};\n\n\n/****************************************************************************/\n/*           Optimized pack/unpack for all native format specifiers         */\n/****************************************************************************/\n\n/*\n  Fix exceptions:\n     1) Include format string in the error message.\n     2) OverflowError -> ValueError.\n     3) The error message from PyNumber_Index() is not ideal.\n*/\nstatic int\ntype_error_int(const char *fmt)\n{\n    PyErr_Format(PyExc_TypeError,\n        \"memoryview: invalid type for format '%s'\", fmt);\n    return -1;\n}\n\nstatic int\nvalue_error_int(const char *fmt)\n{\n    PyErr_Format(PyExc_ValueError,\n        \"memoryview: invalid value for format '%s'\", fmt);\n    return -1;\n}\n\nstatic int\nfix_error_int(const char *fmt)\n{\n    assert(PyErr_Occurred());\n    if (PyErr_ExceptionMatches(PyExc_TypeError)) {\n        PyErr_Clear();\n        return type_error_int(fmt);\n    }\n    else if (PyErr_ExceptionMatches(PyExc_OverflowError) ||\n             PyErr_ExceptionMatches(PyExc_ValueError)) {\n        PyErr_Clear();\n        return value_error_int(fmt);\n    }\n\n    return -1;\n}\n\n/* Accept integer objects or objects with an __index__() method. */\nstatic long\npylong_as_ld(PyObject *item)\n{\n    PyObject *tmp;\n    long ld;\n\n    tmp = _PyNumber_Index(item);\n    if (tmp == NULL)\n        return -1;\n\n    ld = PyLong_AsLong(tmp);\n    Py_DECREF(tmp);\n    return ld;\n}\n\nstatic unsigned long\npylong_as_lu(PyObject *item)\n{\n    PyObject *tmp;\n    unsigned long lu;\n\n    tmp = _PyNumber_Index(item);\n    if (tmp == NULL)\n        return (unsigned long)-1;\n\n    lu = PyLong_AsUnsignedLong(tmp);\n    Py_DECREF(tmp);\n    return lu;\n}\n\nstatic long long\npylong_as_lld(PyObject *item)\n{\n    PyObject *tmp;\n    long long lld;\n\n    tmp = _PyNumber_Index(item);\n    if (tmp == NULL)\n        return -1;\n\n    lld = PyLong_AsLongLong(tmp);\n    Py_DECREF(tmp);\n    return lld;\n}\n\nstatic unsigned long long\npylong_as_llu(PyObject *item)\n{\n    PyObject *tmp;\n    unsigned long long llu;\n\n    tmp = _PyNumber_Index(item);\n    if (tmp == NULL)\n        return (unsigned long long)-1;\n\n    llu = PyLong_AsUnsignedLongLong(tmp);\n    Py_DECREF(tmp);\n    return llu;\n}\n\nstatic Py_ssize_t\npylong_as_zd(PyObject *item)\n{\n    PyObject *tmp;\n    Py_ssize_t zd;\n\n    tmp = _PyNumber_Index(item);\n    if (tmp == NULL)\n        return -1;\n\n    zd = PyLong_AsSsize_t(tmp);\n    Py_DECREF(tmp);\n    return zd;\n}\n\nstatic size_t\npylong_as_zu(PyObject *item)\n{\n    PyObject *tmp;\n    size_t zu;\n\n    tmp = _PyNumber_Index(item);\n    if (tmp == NULL)\n        return (size_t)-1;\n\n    zu = PyLong_AsSize_t(tmp);\n    Py_DECREF(tmp);\n    return zu;\n}\n\n/* Timings with the ndarray from _testbuffer.c indicate that using the\n   struct module is around 15x slower than the two functions below. */\n\n#define UNPACK_SINGLE(dest, ptr, type) \\\n    do {                                   \\\n        type x;                            \\\n        memcpy((char *)&x, ptr, sizeof x); \\\n        dest = x;                          \\\n    } while (0)\n\n/* Unpack a single item. 'fmt' can be any native format character in struct\n   module syntax. This function is very sensitive to small changes. With this\n   layout gcc automatically generates a fast jump table. */\nstatic inline PyObject *\nunpack_single(PyMemoryViewObject *self, const char *ptr, const char *fmt)\n{\n    unsigned long long llu;\n    unsigned long lu;\n    size_t zu;\n    long long lld;\n    long ld;\n    Py_ssize_t zd;\n    double d;\n    unsigned char uc;\n    void *p;\n\n    CHECK_RELEASED_AGAIN(self);\n\n#if PY_LITTLE_ENDIAN\n    int endian = 1;\n#else\n    int endian = 0;\n#endif\n\n    switch (fmt[0]) {\n\n    /* signed integers and fast path for 'B' */\n    case 'B': uc = *((const unsigned char *)ptr); goto convert_uc;\n    case 'b': ld =   *((const signed char *)ptr); goto convert_ld;\n    case 'h': UNPACK_SINGLE(ld, ptr, short); goto convert_ld;\n    case 'i': UNPACK_SINGLE(ld, ptr, int); goto convert_ld;\n    case 'l': UNPACK_SINGLE(ld, ptr, long); goto convert_ld;\n\n    /* boolean */\n    case '?': UNPACK_SINGLE(ld, ptr, _Bool); goto convert_bool;\n\n    /* unsigned integers */\n    case 'H': UNPACK_SINGLE(lu, ptr, unsigned short); goto convert_lu;\n    case 'I': UNPACK_SINGLE(lu, ptr, unsigned int); goto convert_lu;\n    case 'L': UNPACK_SINGLE(lu, ptr, unsigned long); goto convert_lu;\n\n    /* native 64-bit */\n    case 'q': UNPACK_SINGLE(lld, ptr, long long); goto convert_lld;\n    case 'Q': UNPACK_SINGLE(llu, ptr, unsigned long long); goto convert_llu;\n\n    /* ssize_t and size_t */\n    case 'n': UNPACK_SINGLE(zd, ptr, Py_ssize_t); goto convert_zd;\n    case 'N': UNPACK_SINGLE(zu, ptr, size_t); goto convert_zu;\n\n    /* floats */\n    case 'f': UNPACK_SINGLE(d, ptr, float); goto convert_double;\n    case 'd': UNPACK_SINGLE(d, ptr, double); goto convert_double;\n    case 'e': d = PyFloat_Unpack2(ptr, endian); goto convert_double;\n\n    /* bytes object */\n    case 'c': goto convert_bytes;\n\n    /* pointer */\n    case 'P': UNPACK_SINGLE(p, ptr, void *); goto convert_pointer;\n\n    /* default */\n    default: goto err_format;\n    }\n\nconvert_uc:\n    /* PyLong_FromUnsignedLong() is slower */\n    return PyLong_FromLong(uc);\nconvert_ld:\n    return PyLong_FromLong(ld);\nconvert_lu:\n    return PyLong_FromUnsignedLong(lu);\nconvert_lld:\n    return PyLong_FromLongLong(lld);\nconvert_llu:\n    return PyLong_FromUnsignedLongLong(llu);\nconvert_zd:\n    return PyLong_FromSsize_t(zd);\nconvert_zu:\n    return PyLong_FromSize_t(zu);\nconvert_double:\n    return PyFloat_FromDouble(d);\nconvert_bool:\n    return PyBool_FromLong(ld);\nconvert_bytes:\n    return PyBytes_FromStringAndSize(ptr, 1);\nconvert_pointer:\n    return PyLong_FromVoidPtr(p);\nerr_format:\n    PyErr_Format(PyExc_NotImplementedError,\n        \"memoryview: format %s not supported\", fmt);\n    return NULL;\n}\n\n#define PACK_SINGLE(ptr, src, type) \\\n    do {                                     \\\n        type x;                              \\\n        x = (type)src;                       \\\n        memcpy(ptr, (char *)&x, sizeof x);   \\\n    } while (0)\n\n/* Pack a single item. 'fmt' can be any native format character in\n   struct module syntax. */\nstatic int\npack_single(PyMemoryViewObject *self, char *ptr, PyObject *item, const char *fmt)\n{\n    unsigned long long llu;\n    unsigned long lu;\n    size_t zu;\n    long long lld;\n    long ld;\n    Py_ssize_t zd;\n    double d;\n    void *p;\n\n#if PY_LITTLE_ENDIAN\n    int endian = 1;\n#else\n    int endian = 0;\n#endif\n    switch (fmt[0]) {\n    /* signed integers */\n    case 'b': case 'h': case 'i': case 'l':\n        ld = pylong_as_ld(item);\n        if (ld == -1 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        switch (fmt[0]) {\n        case 'b':\n            if (ld < SCHAR_MIN || ld > SCHAR_MAX) goto err_range;\n            *((signed char *)ptr) = (signed char)ld; break;\n        case 'h':\n            if (ld < SHRT_MIN || ld > SHRT_MAX) goto err_range;\n            PACK_SINGLE(ptr, ld, short); break;\n        case 'i':\n            if (ld < INT_MIN || ld > INT_MAX) goto err_range;\n            PACK_SINGLE(ptr, ld, int); break;\n        default: /* 'l' */\n            PACK_SINGLE(ptr, ld, long); break;\n        }\n        break;\n\n    /* unsigned integers */\n    case 'B': case 'H': case 'I': case 'L':\n        lu = pylong_as_lu(item);\n        if (lu == (unsigned long)-1 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        switch (fmt[0]) {\n        case 'B':\n            if (lu > UCHAR_MAX) goto err_range;\n            *((unsigned char *)ptr) = (unsigned char)lu; break;\n        case 'H':\n            if (lu > USHRT_MAX) goto err_range;\n            PACK_SINGLE(ptr, lu, unsigned short); break;\n        case 'I':\n            if (lu > UINT_MAX) goto err_range;\n            PACK_SINGLE(ptr, lu, unsigned int); break;\n        default: /* 'L' */\n            PACK_SINGLE(ptr, lu, unsigned long); break;\n        }\n        break;\n\n    /* native 64-bit */\n    case 'q':\n        lld = pylong_as_lld(item);\n        if (lld == -1 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        PACK_SINGLE(ptr, lld, long long);\n        break;\n    case 'Q':\n        llu = pylong_as_llu(item);\n        if (llu == (unsigned long long)-1 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        PACK_SINGLE(ptr, llu, unsigned long long);\n        break;\n\n    /* ssize_t and size_t */\n    case 'n':\n        zd = pylong_as_zd(item);\n        if (zd == -1 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        PACK_SINGLE(ptr, zd, Py_ssize_t);\n        break;\n    case 'N':\n        zu = pylong_as_zu(item);\n        if (zu == (size_t)-1 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        PACK_SINGLE(ptr, zu, size_t);\n        break;\n\n    /* floats */\n    case 'f': case 'd': case 'e':\n        d = PyFloat_AsDouble(item);\n        if (d == -1.0 && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        if (fmt[0] == 'f') {\n            PACK_SINGLE(ptr, d, float);\n        }\n        else if (fmt[0] == 'd') {\n            PACK_SINGLE(ptr, d, double);\n        }\n        else {\n            if (PyFloat_Pack2(d, ptr, endian) < 0) {\n                goto err_occurred;\n            }\n        }\n        break;\n\n    /* bool */\n    case '?':\n        ld = PyObject_IsTrue(item);\n        if (ld < 0)\n            return -1; /* preserve original error */\n        CHECK_RELEASED_INT_AGAIN(self);\n        PACK_SINGLE(ptr, ld, _Bool);\n        break;\n\n    /* bytes object */\n    case 'c':\n        if (!PyBytes_Check(item))\n            return type_error_int(fmt);\n        if (PyBytes_GET_SIZE(item) != 1)\n            return value_error_int(fmt);\n        *ptr = PyBytes_AS_STRING(item)[0];\n        break;\n\n    /* pointer */\n    case 'P':\n        p = PyLong_AsVoidPtr(item);\n        if (p == NULL && PyErr_Occurred())\n            goto err_occurred;\n        CHECK_RELEASED_INT_AGAIN(self);\n        PACK_SINGLE(ptr, p, void *);\n        break;\n\n    /* default */\n    default: goto err_format;\n    }\n\n    return 0;\n\nerr_occurred:\n    return fix_error_int(fmt);\nerr_range:\n    return value_error_int(fmt);\nerr_format:\n    PyErr_Format(PyExc_NotImplementedError,\n        \"memoryview: format %s not supported\", fmt);\n    return -1;\n}\n\n\n/****************************************************************************/\n/*                       unpack using the struct module                     */\n/****************************************************************************/\n\n/* For reasonable performance it is necessary to cache all objects required\n   for unpacking. An unpacker can handle the format passed to unpack_from().\n   Invariant: All pointer fields of the struct should either be NULL or valid\n   pointers. */\nstruct unpacker {\n    PyObject *unpack_from; /* Struct.unpack_from(format) */\n    PyObject *mview;       /* cached memoryview */\n    char *item;            /* buffer for mview */\n    Py_ssize_t itemsize;   /* len(item) */\n};\n\nstatic struct unpacker *\nunpacker_new(void)\n{\n    struct unpacker *x = PyMem_Malloc(sizeof *x);\n\n    if (x == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    x->unpack_from = NULL;\n    x->mview = NULL;\n    x->item = NULL;\n    x->itemsize = 0;\n\n    return x;\n}\n\nstatic void\nunpacker_free(struct unpacker *x)\n{\n    if (x) {\n        Py_XDECREF(x->unpack_from);\n        Py_XDECREF(x->mview);\n        PyMem_Free(x->item);\n        PyMem_Free(x);\n    }\n}\n\n/* Return a new unpacker for the given format. */\nstatic struct unpacker *\nstruct_get_unpacker(const char *fmt, Py_ssize_t itemsize)\n{\n    PyObject *Struct = NULL;    /* XXX cache it in globals? */\n    PyObject *structobj = NULL;\n    PyObject *format = NULL;\n    struct unpacker *x = NULL;\n\n    Struct = _PyImport_GetModuleAttrString(\"struct\", \"Struct\");\n    if (Struct == NULL)\n        return NULL;\n\n    x = unpacker_new();\n    if (x == NULL)\n        goto error;\n\n    format = PyBytes_FromString(fmt);\n    if (format == NULL)\n        goto error;\n\n    structobj = PyObject_CallOneArg(Struct, format);\n    if (structobj == NULL)\n        goto error;\n\n    x->unpack_from = PyObject_GetAttrString(structobj, \"unpack_from\");\n    if (x->unpack_from == NULL)\n        goto error;\n\n    x->item = PyMem_Malloc(itemsize);\n    if (x->item == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n    x->itemsize = itemsize;\n\n    x->mview = PyMemoryView_FromMemory(x->item, itemsize, PyBUF_WRITE);\n    if (x->mview == NULL)\n        goto error;\n\n\nout:\n    Py_XDECREF(Struct);\n    Py_XDECREF(format);\n    Py_XDECREF(structobj);\n    return x;\n\nerror:\n    unpacker_free(x);\n    x = NULL;\n    goto out;\n}\n\n/* unpack a single item */\nstatic PyObject *\nstruct_unpack_single(const char *ptr, struct unpacker *x)\n{\n    PyObject *v;\n\n    memcpy(x->item, ptr, x->itemsize);\n    v = PyObject_CallOneArg(x->unpack_from, x->mview);\n    if (v == NULL)\n        return NULL;\n\n    if (PyTuple_GET_SIZE(v) == 1) {\n        PyObject *res = Py_NewRef(PyTuple_GET_ITEM(v, 0));\n        Py_DECREF(v);\n        return res;\n    }\n\n    return v;\n}\n\n\n/****************************************************************************/\n/*                              Representations                             */\n/****************************************************************************/\n\n/* allow explicit form of native format */\nstatic inline const char *\nadjust_fmt(const Py_buffer *view)\n{\n    const char *fmt;\n\n    fmt = (view->format[0] == '@') ? view->format+1 : view->format;\n    if (fmt[0] && fmt[1] == '\\0')\n        return fmt;\n\n    PyErr_Format(PyExc_NotImplementedError,\n        \"memoryview: unsupported format %s\", view->format);\n    return NULL;\n}\n\n/* Base case for multi-dimensional unpacking. Assumption: ndim == 1. */\nstatic PyObject *\ntolist_base(PyMemoryViewObject *self, const char *ptr, const Py_ssize_t *shape,\n            const Py_ssize_t *strides, const Py_ssize_t *suboffsets,\n            const char *fmt)\n{\n    PyObject *lst, *item;\n    Py_ssize_t i;\n\n    lst = PyList_New(shape[0]);\n    if (lst == NULL)\n        return NULL;\n\n    for (i = 0; i < shape[0]; ptr+=strides[0], i++) {\n        const char *xptr = ADJUST_PTR(ptr, suboffsets, 0);\n        item = unpack_single(self, xptr, fmt);\n        if (item == NULL) {\n            Py_DECREF(lst);\n            return NULL;\n        }\n        PyList_SET_ITEM(lst, i, item);\n    }\n\n    return lst;\n}\n\n/* Unpack a multi-dimensional array into a nested list.\n   Assumption: ndim >= 1. */\nstatic PyObject *\ntolist_rec(PyMemoryViewObject *self, const char *ptr, Py_ssize_t ndim, const Py_ssize_t *shape,\n           const Py_ssize_t *strides, const Py_ssize_t *suboffsets,\n           const char *fmt)\n{\n    PyObject *lst, *item;\n    Py_ssize_t i;\n\n    assert(ndim >= 1);\n    assert(shape != NULL);\n    assert(strides != NULL);\n\n    if (ndim == 1)\n        return tolist_base(self, ptr, shape, strides, suboffsets, fmt);\n\n    lst = PyList_New(shape[0]);\n    if (lst == NULL)\n        return NULL;\n\n    for (i = 0; i < shape[0]; ptr+=strides[0], i++) {\n        const char *xptr = ADJUST_PTR(ptr, suboffsets, 0);\n        item = tolist_rec(self, xptr, ndim-1, shape+1,\n                          strides+1, suboffsets ? suboffsets+1 : NULL,\n                          fmt);\n        if (item == NULL) {\n            Py_DECREF(lst);\n            return NULL;\n        }\n        PyList_SET_ITEM(lst, i, item);\n    }\n\n    return lst;\n}\n\n/* Return a list representation of the memoryview. Currently only buffers\n   with native format strings are supported. */\n/*[clinic input]\nmemoryview.tolist\n\nReturn the data in the buffer as a list of elements.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_tolist_impl(PyMemoryViewObject *self)\n/*[clinic end generated code: output=a6cda89214fd5a1b input=21e7d0c1860b211a]*/\n{\n    const Py_buffer *view = &self->view;\n    const char *fmt;\n\n    CHECK_RELEASED(self);\n\n    fmt = adjust_fmt(view);\n    if (fmt == NULL)\n        return NULL;\n    if (view->ndim == 0) {\n        return unpack_single(self, view->buf, fmt);\n    }\n    else if (view->ndim == 1) {\n        return tolist_base(self, view->buf, view->shape,\n                           view->strides, view->suboffsets,\n                           fmt);\n    }\n    else {\n        return tolist_rec(self, view->buf, view->ndim, view->shape,\n                          view->strides, view->suboffsets,\n                          fmt);\n    }\n}\n\n/*[clinic input]\nmemoryview.tobytes\n\n    order: str(accept={str, NoneType}, c_default=\"NULL\") = 'C'\n\nReturn the data in the buffer as a byte string.\n\nOrder can be {'C', 'F', 'A'}. When order is 'C' or 'F', the data of the\noriginal array is converted to C or Fortran order. For contiguous views,\n'A' returns an exact copy of the physical memory. In particular, in-memory\nFortran order is preserved. For non-contiguous views, the data is converted\nto C first. order=None is the same as order='C'.\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_tobytes_impl(PyMemoryViewObject *self, const char *order)\n/*[clinic end generated code: output=1288b62560a32a23 input=0efa3ddaeda573a8]*/\n{\n    Py_buffer *src = VIEW_ADDR(self);\n    char ord = 'C';\n    PyObject *bytes;\n\n    CHECK_RELEASED(self);\n\n    if (order) {\n        if (strcmp(order, \"F\") == 0) {\n            ord = 'F';\n        }\n        else if (strcmp(order, \"A\") == 0) {\n            ord = 'A';\n        }\n        else if (strcmp(order, \"C\") != 0) {\n            PyErr_SetString(PyExc_ValueError,\n                \"order must be 'C', 'F' or 'A'\");\n            return NULL;\n        }\n    }\n\n    bytes = PyBytes_FromStringAndSize(NULL, src->len);\n    if (bytes == NULL)\n        return NULL;\n\n    if (PyBuffer_ToContiguous(PyBytes_AS_STRING(bytes), src, src->len, ord) < 0) {\n        Py_DECREF(bytes);\n        return NULL;\n    }\n\n    return bytes;\n}\n\n/*[clinic input]\nmemoryview.hex\n\n    sep: object = NULL\n        An optional single character or byte to separate hex bytes.\n    bytes_per_sep: int = 1\n        How many bytes between separators.  Positive values count from the\n        right, negative values count from the left.\n\nReturn the data in the buffer as a str of hexadecimal numbers.\n\nExample:\n>>> value = memoryview(b'\\xb9\\x01\\xef')\n>>> value.hex()\n'b901ef'\n>>> value.hex(':')\n'b9:01:ef'\n>>> value.hex(':', 2)\n'b9:01ef'\n>>> value.hex(':', -2)\n'b901:ef'\n[clinic start generated code]*/\n\nstatic PyObject *\nmemoryview_hex_impl(PyMemoryViewObject *self, PyObject *sep,\n                    int bytes_per_sep)\n/*[clinic end generated code: output=430ca760f94f3ca7 input=539f6a3a5fb56946]*/\n{\n    Py_buffer *src = VIEW_ADDR(self);\n    PyObject *bytes;\n    PyObject *ret;\n\n    CHECK_RELEASED(self);\n\n    if (MV_C_CONTIGUOUS(self->flags)) {\n        return _Py_strhex_with_sep(src->buf, src->len, sep, bytes_per_sep);\n    }\n\n    bytes = PyBytes_FromStringAndSize(NULL, src->len);\n    if (bytes == NULL)\n        return NULL;\n\n    if (PyBuffer_ToContiguous(PyBytes_AS_STRING(bytes), src, src->len, 'C') < 0) {\n        Py_DECREF(bytes);\n        return NULL;\n    }\n\n    ret = _Py_strhex_with_sep(\n            PyBytes_AS_STRING(bytes), PyBytes_GET_SIZE(bytes),\n            sep, bytes_per_sep);\n    Py_DECREF(bytes);\n\n    return ret;\n}\n\nstatic PyObject *\nmemory_repr(PyObject *_self)\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    if (self->flags & _Py_MEMORYVIEW_RELEASED)\n        return PyUnicode_FromFormat(\"<released memory at %p>\", self);\n    else\n        return PyUnicode_FromFormat(\"<memory at %p>\", self);\n}\n\n\n/**************************************************************************/\n/*                          Indexing and slicing                          */\n/**************************************************************************/\n\nstatic char *\nlookup_dimension(const Py_buffer *view, char *ptr, int dim, Py_ssize_t index)\n{\n    Py_ssize_t nitems; /* items in the given dimension */\n\n    assert(view->shape);\n    assert(view->strides);\n\n    nitems = view->shape[dim];\n    if (index < 0) {\n        index += nitems;\n    }\n    if (index < 0 || index >= nitems) {\n        PyErr_Format(PyExc_IndexError,\n                     \"index out of bounds on dimension %d\", dim + 1);\n        return NULL;\n    }\n\n    ptr += view->strides[dim] * index;\n\n    ptr = ADJUST_PTR(ptr, view->suboffsets, dim);\n\n    return ptr;\n}\n\n/* Get the pointer to the item at index. */\nstatic char *\nptr_from_index(const Py_buffer *view, Py_ssize_t index)\n{\n    char *ptr = (char *)view->buf;\n    return lookup_dimension(view, ptr, 0, index);\n}\n\n/* Get the pointer to the item at tuple. */\nstatic char *\nptr_from_tuple(const Py_buffer *view, PyObject *tup)\n{\n    char *ptr = (char *)view->buf;\n    Py_ssize_t dim, nindices = PyTuple_GET_SIZE(tup);\n\n    if (nindices > view->ndim) {\n        PyErr_Format(PyExc_TypeError,\n                     \"cannot index %zd-dimension view with %zd-element tuple\",\n                     view->ndim, nindices);\n        return NULL;\n    }\n\n    for (dim = 0; dim < nindices; dim++) {\n        Py_ssize_t index;\n        index = PyNumber_AsSsize_t(PyTuple_GET_ITEM(tup, dim),\n                                   PyExc_IndexError);\n        if (index == -1 && PyErr_Occurred())\n            return NULL;\n        ptr = lookup_dimension(view, ptr, (int)dim, index);\n        if (ptr == NULL)\n            return NULL;\n    }\n    return ptr;\n}\n\n/* Return the item at index. In a one-dimensional view, this is an object\n   with the type specified by view->format. Otherwise, the item is a sub-view.\n   The function is used in memory_subscript() and memory_as_sequence. */\nstatic PyObject *\nmemory_item(PyObject *_self, Py_ssize_t index)\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    Py_buffer *view = &(self->view);\n    const char *fmt;\n\n    CHECK_RELEASED(self);\n\n    fmt = adjust_fmt(view);\n    if (fmt == NULL)\n        return NULL;\n\n    if (view->ndim == 0) {\n        PyErr_SetString(PyExc_TypeError, \"invalid indexing of 0-dim memory\");\n        return NULL;\n    }\n    if (view->ndim == 1) {\n        char *ptr = ptr_from_index(view, index);\n        if (ptr == NULL)\n            return NULL;\n        return unpack_single(self, ptr, fmt);\n    }\n\n    PyErr_SetString(PyExc_NotImplementedError,\n        \"multi-dimensional sub-views are not implemented\");\n    return NULL;\n}\n\n/* Return the item at position *key* (a tuple of indices). */\nstatic PyObject *\nmemory_item_multi(PyMemoryViewObject *self, PyObject *tup)\n{\n    Py_buffer *view = &(self->view);\n    const char *fmt;\n    Py_ssize_t nindices = PyTuple_GET_SIZE(tup);\n    char *ptr;\n\n    CHECK_RELEASED(self);\n\n    fmt = adjust_fmt(view);\n    if (fmt == NULL)\n        return NULL;\n\n    if (nindices < view->ndim) {\n        PyErr_SetString(PyExc_NotImplementedError,\n                        \"sub-views are not implemented\");\n        return NULL;\n    }\n    ptr = ptr_from_tuple(view, tup);\n    if (ptr == NULL)\n        return NULL;\n    return unpack_single(self, ptr, fmt);\n}\n\nstatic inline int\ninit_slice(Py_buffer *base, PyObject *key, int dim)\n{\n    Py_ssize_t start, stop, step, slicelength;\n\n    if (PySlice_Unpack(key, &start, &stop, &step) < 0) {\n        return -1;\n    }\n    slicelength = PySlice_AdjustIndices(base->shape[dim], &start, &stop, step);\n\n\n    if (base->suboffsets == NULL || dim == 0) {\n    adjust_buf:\n        base->buf = (char *)base->buf + base->strides[dim] * start;\n    }\n    else {\n        Py_ssize_t n = dim-1;\n        while (n >= 0 && base->suboffsets[n] < 0)\n            n--;\n        if (n < 0)\n            goto adjust_buf; /* all suboffsets are negative */\n        base->suboffsets[n] = base->suboffsets[n] + base->strides[dim] * start;\n    }\n    base->shape[dim] = slicelength;\n    base->strides[dim] = base->strides[dim] * step;\n\n    return 0;\n}\n\nstatic int\nis_multislice(PyObject *key)\n{\n    Py_ssize_t size, i;\n\n    if (!PyTuple_Check(key))\n        return 0;\n    size = PyTuple_GET_SIZE(key);\n    if (size == 0)\n        return 0;\n\n    for (i = 0; i < size; i++) {\n        PyObject *x = PyTuple_GET_ITEM(key, i);\n        if (!PySlice_Check(x))\n            return 0;\n    }\n    return 1;\n}\n\nstatic Py_ssize_t\nis_multiindex(PyObject *key)\n{\n    Py_ssize_t size, i;\n\n    if (!PyTuple_Check(key))\n        return 0;\n    size = PyTuple_GET_SIZE(key);\n    for (i = 0; i < size; i++) {\n        PyObject *x = PyTuple_GET_ITEM(key, i);\n        if (!_PyIndex_Check(x)) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\n/* mv[obj] returns an object holding the data for one element if obj\n   fully indexes the memoryview or another memoryview object if it\n   does not.\n\n   0-d memoryview objects can be referenced using mv[...] or mv[()]\n   but not with anything else. */\nstatic PyObject *\nmemory_subscript(PyObject *_self, PyObject *key)\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    Py_buffer *view;\n    view = &(self->view);\n\n    CHECK_RELEASED(self);\n\n    if (view->ndim == 0) {\n        if (PyTuple_Check(key) && PyTuple_GET_SIZE(key) == 0) {\n            const char *fmt = adjust_fmt(view);\n            if (fmt == NULL)\n                return NULL;\n            return unpack_single(self, view->buf, fmt);\n        }\n        else if (key == Py_Ellipsis) {\n            return Py_NewRef(self);\n        }\n        else {\n            PyErr_SetString(PyExc_TypeError,\n                \"invalid indexing of 0-dim memory\");\n            return NULL;\n        }\n    }\n\n    if (_PyIndex_Check(key)) {\n        Py_ssize_t index;\n        index = PyNumber_AsSsize_t(key, PyExc_IndexError);\n        if (index == -1 && PyErr_Occurred())\n            return NULL;\n        return memory_item((PyObject *)self, index);\n    }\n    else if (PySlice_Check(key)) {\n        CHECK_RESTRICTED(self);\n        PyMemoryViewObject *sliced;\n\n        sliced = (PyMemoryViewObject *)mbuf_add_view(self->mbuf, view);\n        if (sliced == NULL)\n            return NULL;\n\n        if (init_slice(&sliced->view, key, 0) < 0) {\n            Py_DECREF(sliced);\n            return NULL;\n        }\n        init_len(&sliced->view);\n        init_flags(sliced);\n\n        return (PyObject *)sliced;\n    }\n    else if (is_multiindex(key)) {\n        return memory_item_multi(self, key);\n    }\n    else if (is_multislice(key)) {\n        PyErr_SetString(PyExc_NotImplementedError,\n            \"multi-dimensional slicing is not implemented\");\n        return NULL;\n    }\n\n    PyErr_SetString(PyExc_TypeError, \"memoryview: invalid slice key\");\n    return NULL;\n}\n\nstatic int\nmemory_ass_sub(PyObject *_self, PyObject *key, PyObject *value)\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    Py_buffer *view = &(self->view);\n    Py_buffer src;\n    const char *fmt;\n    char *ptr;\n\n    CHECK_RELEASED_INT(self);\n\n    fmt = adjust_fmt(view);\n    if (fmt == NULL)\n        return -1;\n\n    if (view->readonly) {\n        PyErr_SetString(PyExc_TypeError, \"cannot modify read-only memory\");\n        return -1;\n    }\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError, \"cannot delete memory\");\n        return -1;\n    }\n    if (view->ndim == 0) {\n        if (key == Py_Ellipsis ||\n            (PyTuple_Check(key) && PyTuple_GET_SIZE(key)==0)) {\n            ptr = (char *)view->buf;\n            return pack_single(self, ptr, value, fmt);\n        }\n        else {\n            PyErr_SetString(PyExc_TypeError,\n                \"invalid indexing of 0-dim memory\");\n            return -1;\n        }\n    }\n\n    if (_PyIndex_Check(key)) {\n        Py_ssize_t index;\n        if (1 < view->ndim) {\n            PyErr_SetString(PyExc_NotImplementedError,\n                            \"sub-views are not implemented\");\n            return -1;\n        }\n        index = PyNumber_AsSsize_t(key, PyExc_IndexError);\n        if (index == -1 && PyErr_Occurred())\n            return -1;\n        ptr = ptr_from_index(view, index);\n        if (ptr == NULL)\n            return -1;\n        return pack_single(self, ptr, value, fmt);\n    }\n    /* one-dimensional: fast path */\n    if (PySlice_Check(key) && view->ndim == 1) {\n        Py_buffer dest; /* sliced view */\n        Py_ssize_t arrays[3];\n        int ret = -1;\n\n        /* rvalue must be an exporter */\n        if (PyObject_GetBuffer(value, &src, PyBUF_FULL_RO) < 0)\n            return ret;\n\n        dest = *view;\n        dest.shape = &arrays[0]; dest.shape[0] = view->shape[0];\n        dest.strides = &arrays[1]; dest.strides[0] = view->strides[0];\n        if (view->suboffsets) {\n            dest.suboffsets = &arrays[2]; dest.suboffsets[0] = view->suboffsets[0];\n        }\n\n        if (init_slice(&dest, key, 0) < 0)\n            goto end_block;\n        dest.len = dest.shape[0] * dest.itemsize;\n\n        ret = copy_single(self, &dest, &src);\n\n    end_block:\n        PyBuffer_Release(&src);\n        return ret;\n    }\n    if (is_multiindex(key)) {\n        char *ptr;\n        if (PyTuple_GET_SIZE(key) < view->ndim) {\n            PyErr_SetString(PyExc_NotImplementedError,\n                            \"sub-views are not implemented\");\n            return -1;\n        }\n        ptr = ptr_from_tuple(view, key);\n        if (ptr == NULL)\n            return -1;\n        return pack_single(self, ptr, value, fmt);\n    }\n    if (PySlice_Check(key) || is_multislice(key)) {\n        /* Call memory_subscript() to produce a sliced lvalue, then copy\n           rvalue into lvalue. This is already implemented in _testbuffer.c. */\n        PyErr_SetString(PyExc_NotImplementedError,\n            \"memoryview slice assignments are currently restricted \"\n            \"to ndim = 1\");\n        return -1;\n    }\n\n    PyErr_SetString(PyExc_TypeError, \"memoryview: invalid slice key\");\n    return -1;\n}\n\nstatic Py_ssize_t\nmemory_length(PyObject *_self)\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    CHECK_RELEASED_INT(self);\n    if (self->view.ndim == 0) {\n        PyErr_SetString(PyExc_TypeError, \"0-dim memory has no length\");\n        return -1;\n    }\n    return self->view.shape[0];\n}\n\n/* As mapping */\nstatic PyMappingMethods memory_as_mapping = {\n    memory_length,                        /* mp_length */\n    memory_subscript,                     /* mp_subscript */\n    memory_ass_sub,                       /* mp_ass_subscript */\n};\n\n/* As sequence */\nstatic PySequenceMethods memory_as_sequence = {\n        memory_length,                    /* sq_length */\n        0,                                /* sq_concat */\n        0,                                /* sq_repeat */\n        memory_item,                      /* sq_item */\n};\n\n\n/**************************************************************************/\n/*                             Comparisons                                */\n/**************************************************************************/\n\n#define MV_COMPARE_EX -1       /* exception */\n#define MV_COMPARE_NOT_IMPL -2 /* not implemented */\n\n/* Translate a StructError to \"not equal\". Preserve other exceptions. */\nstatic int\nfix_struct_error_int(void)\n{\n    assert(PyErr_Occurred());\n    /* XXX Cannot get at StructError directly? */\n    if (PyErr_ExceptionMatches(PyExc_ImportError) ||\n        PyErr_ExceptionMatches(PyExc_MemoryError)) {\n        return MV_COMPARE_EX;\n    }\n    /* StructError: invalid or unknown format -> not equal */\n    PyErr_Clear();\n    return 0;\n}\n\n/* Unpack and compare single items of p and q using the struct module. */\nstatic int\nstruct_unpack_cmp(const char *p, const char *q,\n                  struct unpacker *unpack_p, struct unpacker *unpack_q)\n{\n    PyObject *v, *w;\n    int ret;\n\n    /* At this point any exception from the struct module should not be\n       StructError, since both formats have been accepted already. */\n    v = struct_unpack_single(p, unpack_p);\n    if (v == NULL)\n        return MV_COMPARE_EX;\n\n    w = struct_unpack_single(q, unpack_q);\n    if (w == NULL) {\n        Py_DECREF(v);\n        return MV_COMPARE_EX;\n    }\n\n    /* MV_COMPARE_EX == -1: exceptions are preserved */\n    ret = PyObject_RichCompareBool(v, w, Py_EQ);\n    Py_DECREF(v);\n    Py_DECREF(w);\n\n    return ret;\n}\n\n/* Unpack and compare single items of p and q. If both p and q have the same\n   single element native format, the comparison uses a fast path (gcc creates\n   a jump table and converts memcpy into simple assignments on x86/x64).\n\n   Otherwise, the comparison is delegated to the struct module, which is\n   30-60x slower. */\n#define CMP_SINGLE(p, q, type) \\\n    do {                                 \\\n        type x;                          \\\n        type y;                          \\\n        memcpy((char *)&x, p, sizeof x); \\\n        memcpy((char *)&y, q, sizeof y); \\\n        equal = (x == y);                \\\n    } while (0)\n\nstatic inline int\nunpack_cmp(const char *p, const char *q, char fmt,\n           struct unpacker *unpack_p, struct unpacker *unpack_q)\n{\n    int equal;\n\n    switch (fmt) {\n\n    /* signed integers and fast path for 'B' */\n    case 'B': return *((const unsigned char *)p) == *((const unsigned char *)q);\n    case 'b': return *((const signed char *)p) == *((const signed char *)q);\n    case 'h': CMP_SINGLE(p, q, short); return equal;\n    case 'i': CMP_SINGLE(p, q, int); return equal;\n    case 'l': CMP_SINGLE(p, q, long); return equal;\n\n    /* boolean */\n    case '?': CMP_SINGLE(p, q, _Bool); return equal;\n\n    /* unsigned integers */\n    case 'H': CMP_SINGLE(p, q, unsigned short); return equal;\n    case 'I': CMP_SINGLE(p, q, unsigned int); return equal;\n    case 'L': CMP_SINGLE(p, q, unsigned long); return equal;\n\n    /* native 64-bit */\n    case 'q': CMP_SINGLE(p, q, long long); return equal;\n    case 'Q': CMP_SINGLE(p, q, unsigned long long); return equal;\n\n    /* ssize_t and size_t */\n    case 'n': CMP_SINGLE(p, q, Py_ssize_t); return equal;\n    case 'N': CMP_SINGLE(p, q, size_t); return equal;\n\n    /* floats */\n    /* XXX DBL_EPSILON? */\n    case 'f': CMP_SINGLE(p, q, float); return equal;\n    case 'd': CMP_SINGLE(p, q, double); return equal;\n    case 'e': {\n#if PY_LITTLE_ENDIAN\n        int endian = 1;\n#else\n        int endian = 0;\n#endif\n        /* Note: PyFloat_Unpack2 should never fail */\n        double u = PyFloat_Unpack2(p, endian);\n        double v = PyFloat_Unpack2(q, endian);\n        return (u == v);\n    }\n\n    /* bytes object */\n    case 'c': return *p == *q;\n\n    /* pointer */\n    case 'P': CMP_SINGLE(p, q, void *); return equal;\n\n    /* use the struct module */\n    case '_':\n        assert(unpack_p);\n        assert(unpack_q);\n        return struct_unpack_cmp(p, q, unpack_p, unpack_q);\n    }\n\n    /* NOT REACHED */\n    PyErr_SetString(PyExc_RuntimeError,\n        \"memoryview: internal error in richcompare\");\n    return MV_COMPARE_EX;\n}\n\n/* Base case for recursive array comparisons. Assumption: ndim == 1. */\nstatic int\ncmp_base(const char *p, const char *q, const Py_ssize_t *shape,\n         const Py_ssize_t *pstrides, const Py_ssize_t *psuboffsets,\n         const Py_ssize_t *qstrides, const Py_ssize_t *qsuboffsets,\n         char fmt, struct unpacker *unpack_p, struct unpacker *unpack_q)\n{\n    Py_ssize_t i;\n    int equal;\n\n    for (i = 0; i < shape[0]; p+=pstrides[0], q+=qstrides[0], i++) {\n        const char *xp = ADJUST_PTR(p, psuboffsets, 0);\n        const char *xq = ADJUST_PTR(q, qsuboffsets, 0);\n        equal = unpack_cmp(xp, xq, fmt, unpack_p, unpack_q);\n        if (equal <= 0)\n            return equal;\n    }\n\n    return 1;\n}\n\n/* Recursively compare two multi-dimensional arrays that have the same\n   logical structure. Assumption: ndim >= 1. */\nstatic int\ncmp_rec(const char *p, const char *q,\n        Py_ssize_t ndim, const Py_ssize_t *shape,\n        const Py_ssize_t *pstrides, const Py_ssize_t *psuboffsets,\n        const Py_ssize_t *qstrides, const Py_ssize_t *qsuboffsets,\n        char fmt, struct unpacker *unpack_p, struct unpacker *unpack_q)\n{\n    Py_ssize_t i;\n    int equal;\n\n    assert(ndim >= 1);\n    assert(shape != NULL);\n    assert(pstrides != NULL);\n    assert(qstrides != NULL);\n\n    if (ndim == 1) {\n        return cmp_base(p, q, shape,\n                        pstrides, psuboffsets,\n                        qstrides, qsuboffsets,\n                        fmt, unpack_p, unpack_q);\n    }\n\n    for (i = 0; i < shape[0]; p+=pstrides[0], q+=qstrides[0], i++) {\n        const char *xp = ADJUST_PTR(p, psuboffsets, 0);\n        const char *xq = ADJUST_PTR(q, qsuboffsets, 0);\n        equal = cmp_rec(xp, xq, ndim-1, shape+1,\n                        pstrides+1, psuboffsets ? psuboffsets+1 : NULL,\n                        qstrides+1, qsuboffsets ? qsuboffsets+1 : NULL,\n                        fmt, unpack_p, unpack_q);\n        if (equal <= 0)\n            return equal;\n    }\n\n    return 1;\n}\n\nstatic PyObject *\nmemory_richcompare(PyObject *v, PyObject *w, int op)\n{\n    PyObject *res;\n    Py_buffer wbuf, *vv;\n    Py_buffer *ww = NULL;\n    struct unpacker *unpack_v = NULL;\n    struct unpacker *unpack_w = NULL;\n    char vfmt, wfmt;\n    int equal = MV_COMPARE_NOT_IMPL;\n\n    if (op != Py_EQ && op != Py_NE)\n        goto result; /* Py_NotImplemented */\n\n    assert(PyMemoryView_Check(v));\n    if (BASE_INACCESSIBLE(v)) {\n        equal = (v == w);\n        goto result;\n    }\n    vv = VIEW_ADDR(v);\n\n    if (PyMemoryView_Check(w)) {\n        if (BASE_INACCESSIBLE(w)) {\n            equal = (v == w);\n            goto result;\n        }\n        ww = VIEW_ADDR(w);\n    }\n    else {\n        if (PyObject_GetBuffer(w, &wbuf, PyBUF_FULL_RO) < 0) {\n            PyErr_Clear();\n            goto result; /* Py_NotImplemented */\n        }\n        ww = &wbuf;\n    }\n\n    if (!equiv_shape(vv, ww)) {\n        PyErr_Clear();\n        equal = 0;\n        goto result;\n    }\n\n    /* Use fast unpacking for identical primitive C type formats. */\n    if (get_native_fmtchar(&vfmt, vv->format) < 0)\n        vfmt = '_';\n    if (get_native_fmtchar(&wfmt, ww->format) < 0)\n        wfmt = '_';\n    if (vfmt == '_' || wfmt == '_' || vfmt != wfmt) {\n        /* Use struct module unpacking. NOTE: Even for equal format strings,\n           memcmp() cannot be used for item comparison since it would give\n           incorrect results in the case of NaNs or uninitialized padding\n           bytes. */\n        vfmt = '_';\n        unpack_v = struct_get_unpacker(vv->format, vv->itemsize);\n        if (unpack_v == NULL) {\n            equal = fix_struct_error_int();\n            goto result;\n        }\n        unpack_w = struct_get_unpacker(ww->format, ww->itemsize);\n        if (unpack_w == NULL) {\n            equal = fix_struct_error_int();\n            goto result;\n        }\n    }\n\n    if (vv->ndim == 0) {\n        equal = unpack_cmp(vv->buf, ww->buf,\n                           vfmt, unpack_v, unpack_w);\n    }\n    else if (vv->ndim == 1) {\n        equal = cmp_base(vv->buf, ww->buf, vv->shape,\n                         vv->strides, vv->suboffsets,\n                         ww->strides, ww->suboffsets,\n                         vfmt, unpack_v, unpack_w);\n    }\n    else {\n        equal = cmp_rec(vv->buf, ww->buf, vv->ndim, vv->shape,\n                        vv->strides, vv->suboffsets,\n                        ww->strides, ww->suboffsets,\n                        vfmt, unpack_v, unpack_w);\n    }\n\nresult:\n    if (equal < 0) {\n        if (equal == MV_COMPARE_NOT_IMPL)\n            res = Py_NotImplemented;\n        else /* exception */\n            res = NULL;\n    }\n    else if ((equal && op == Py_EQ) || (!equal && op == Py_NE))\n        res = Py_True;\n    else\n        res = Py_False;\n\n    if (ww == &wbuf)\n        PyBuffer_Release(ww);\n\n    unpacker_free(unpack_v);\n    unpacker_free(unpack_w);\n\n    return Py_XNewRef(res);\n}\n\n/**************************************************************************/\n/*                                Hash                                    */\n/**************************************************************************/\n\nstatic Py_hash_t\nmemory_hash(PyObject *_self)\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    if (self->hash == -1) {\n        Py_buffer *view = &self->view;\n        char *mem = view->buf;\n        Py_ssize_t ret;\n        char fmt;\n\n        CHECK_RELEASED_INT(self);\n\n        if (!view->readonly) {\n            PyErr_SetString(PyExc_ValueError,\n                \"cannot hash writable memoryview object\");\n            return -1;\n        }\n        ret = get_native_fmtchar(&fmt, view->format);\n        if (ret < 0 || !IS_BYTE_FORMAT(fmt)) {\n            PyErr_SetString(PyExc_ValueError,\n                \"memoryview: hashing is restricted to formats 'B', 'b' or 'c'\");\n            return -1;\n        }\n        if (view->obj != NULL && PyObject_Hash(view->obj) == -1) {\n            /* Keep the original error message */\n            return -1;\n        }\n\n        if (!MV_C_CONTIGUOUS(self->flags)) {\n            mem = PyMem_Malloc(view->len);\n            if (mem == NULL) {\n                PyErr_NoMemory();\n                return -1;\n            }\n            if (buffer_to_contiguous(mem, view, 'C') < 0) {\n                PyMem_Free(mem);\n                return -1;\n            }\n        }\n\n        /* Can't fail */\n        self->hash = _Py_HashBytes(mem, view->len);\n\n        if (mem != view->buf)\n            PyMem_Free(mem);\n    }\n\n    return self->hash;\n}\n\n\n/**************************************************************************/\n/*                                 getters                                */\n/**************************************************************************/\n\nstatic PyObject *\n_IntTupleFromSsizet(int len, Py_ssize_t *vals)\n{\n    int i;\n    PyObject *o;\n    PyObject *intTuple;\n\n    if (vals == NULL)\n        return PyTuple_New(0);\n\n    intTuple = PyTuple_New(len);\n    if (!intTuple)\n        return NULL;\n    for (i=0; i<len; i++) {\n        o = PyLong_FromSsize_t(vals[i]);\n        if (!o) {\n            Py_DECREF(intTuple);\n            return NULL;\n        }\n        PyTuple_SET_ITEM(intTuple, i, o);\n    }\n    return intTuple;\n}\n\nstatic PyObject *\nmemory_obj_get(PyObject *_self, void *Py_UNUSED(ignored))\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    Py_buffer *view = &self->view;\n\n    CHECK_RELEASED(self);\n    if (view->obj == NULL) {\n        Py_RETURN_NONE;\n    }\n    return Py_NewRef(view->obj);\n}\n\nstatic PyObject *\nmemory_nbytes_get(PyObject *_self, void *Py_UNUSED(ignored))\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    CHECK_RELEASED(self);\n    return PyLong_FromSsize_t(self->view.len);\n}\n\nstatic PyObject *\nmemory_format_get(PyObject *_self, void *Py_UNUSED(ignored))\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    CHECK_RELEASED(self);\n    return PyUnicode_FromString(self->view.format);\n}\n\nstatic PyObject *\nmemory_itemsize_get(PyObject *_self, void *Py_UNUSED(ignored))\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    CHECK_RELEASED(self);\n    return PyLong_FromSsize_t(self->view.itemsize);\n}\n\nstatic PyObject *\nmemory_shape_get(PyObject *_self, void *Py_UNUSED(ignored))\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    CHECK_RELEASED(self);\n    return _IntTupleFromSsizet(self->view.ndim, self->view.shape);\n}\n\nstatic PyObject *\nmemory_strides_get(PyObject *_self, void *Py_UNUSED(ignored))\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    CHECK_RELEASED(self);\n    return _IntTupleFromSsizet(self->view.ndim, self->view.strides);\n}\n\nstatic PyObject *\nmemory_suboffsets_get(PyObject *_self, void *Py_UNUSED(ignored))\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    CHECK_RELEASED(self);\n    return _IntTupleFromSsizet(self->view.ndim, self->view.suboffsets);\n}\n\nstatic PyObject *\nmemory_readonly_get(PyObject *_self, void *Py_UNUSED(ignored))\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    CHECK_RELEASED(self);\n    return PyBool_FromLong(self->view.readonly);\n}\n\nstatic PyObject *\nmemory_ndim_get(PyObject *_self, void *Py_UNUSED(ignored))\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    CHECK_RELEASED(self);\n    return PyLong_FromLong(self->view.ndim);\n}\n\nstatic PyObject *\nmemory_c_contiguous(PyObject *_self, void *Py_UNUSED(ignored))\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    CHECK_RELEASED(self);\n    return PyBool_FromLong(MV_C_CONTIGUOUS(self->flags));\n}\n\nstatic PyObject *\nmemory_f_contiguous(PyObject *_self, void *Py_UNUSED(ignored))\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    CHECK_RELEASED(self);\n    return PyBool_FromLong(MV_F_CONTIGUOUS(self->flags));\n}\n\nstatic PyObject *\nmemory_contiguous(PyObject *_self, void *Py_UNUSED(ignored))\n{\n    PyMemoryViewObject *self = (PyMemoryViewObject *)_self;\n    CHECK_RELEASED(self);\n    return PyBool_FromLong(MV_ANY_CONTIGUOUS(self->flags));\n}\n\nPyDoc_STRVAR(memory_obj_doc,\n             \"The underlying object of the memoryview.\");\nPyDoc_STRVAR(memory_nbytes_doc,\n             \"The amount of space in bytes that the array would use in\\n\"\n             \" a contiguous representation.\");\nPyDoc_STRVAR(memory_readonly_doc,\n             \"A bool indicating whether the memory is read only.\");\nPyDoc_STRVAR(memory_itemsize_doc,\n             \"The size in bytes of each element of the memoryview.\");\nPyDoc_STRVAR(memory_format_doc,\n             \"A string containing the format (in struct module style)\\n\"\n             \" for each element in the view.\");\nPyDoc_STRVAR(memory_ndim_doc,\n             \"An integer indicating how many dimensions of a multi-dimensional\\n\"\n             \" array the memory represents.\");\nPyDoc_STRVAR(memory_shape_doc,\n             \"A tuple of ndim integers giving the shape of the memory\\n\"\n             \" as an N-dimensional array.\");\nPyDoc_STRVAR(memory_strides_doc,\n             \"A tuple of ndim integers giving the size in bytes to access\\n\"\n             \" each element for each dimension of the array.\");\nPyDoc_STRVAR(memory_suboffsets_doc,\n             \"A tuple of integers used internally for PIL-style arrays.\");\nPyDoc_STRVAR(memory_c_contiguous_doc,\n             \"A bool indicating whether the memory is C contiguous.\");\nPyDoc_STRVAR(memory_f_contiguous_doc,\n             \"A bool indicating whether the memory is Fortran contiguous.\");\nPyDoc_STRVAR(memory_contiguous_doc,\n             \"A bool indicating whether the memory is contiguous.\");\nPyDoc_STRVAR(memory_exit_doc,\n             \"__exit__($self, /, *exc_info)\\n--\\n\\n\"\n             \"Release the underlying buffer exposed by the memoryview object.\");\n\n\nstatic PyGetSetDef memory_getsetlist[] = {\n    {\"obj\",             memory_obj_get,        NULL, memory_obj_doc},\n    {\"nbytes\",          memory_nbytes_get,     NULL, memory_nbytes_doc},\n    {\"readonly\",        memory_readonly_get,   NULL, memory_readonly_doc},\n    {\"itemsize\",        memory_itemsize_get,   NULL, memory_itemsize_doc},\n    {\"format\",          memory_format_get,     NULL, memory_format_doc},\n    {\"ndim\",            memory_ndim_get,       NULL, memory_ndim_doc},\n    {\"shape\",           memory_shape_get,      NULL, memory_shape_doc},\n    {\"strides\",         memory_strides_get,    NULL, memory_strides_doc},\n    {\"suboffsets\",      memory_suboffsets_get, NULL, memory_suboffsets_doc},\n    {\"c_contiguous\",    memory_c_contiguous,   NULL, memory_c_contiguous_doc},\n    {\"f_contiguous\",    memory_f_contiguous,   NULL, memory_f_contiguous_doc},\n    {\"contiguous\",      memory_contiguous,     NULL, memory_contiguous_doc},\n    {NULL, NULL, NULL, NULL},\n};\n\n\nstatic PyMethodDef memory_methods[] = {\n    MEMORYVIEW_RELEASE_METHODDEF\n    MEMORYVIEW_TOBYTES_METHODDEF\n    MEMORYVIEW_HEX_METHODDEF\n    MEMORYVIEW_TOLIST_METHODDEF\n    MEMORYVIEW_CAST_METHODDEF\n    MEMORYVIEW_TOREADONLY_METHODDEF\n    MEMORYVIEW__FROM_FLAGS_METHODDEF\n    {\"__enter__\",   memory_enter, METH_NOARGS, NULL},\n    {\"__exit__\",    memory_exit, METH_VARARGS, memory_exit_doc},\n    {NULL,          NULL}\n};\n\n/**************************************************************************/\n/*                          Memoryview Iterator                           */\n/**************************************************************************/\n\nPyTypeObject _PyMemoryIter_Type;\n\ntypedef struct {\n    PyObject_HEAD\n    Py_ssize_t it_index;\n    PyMemoryViewObject *it_seq; // Set to NULL when iterator is exhausted\n    Py_ssize_t it_length;\n    const char *it_fmt;\n} memoryiterobject;\n\nstatic void\nmemoryiter_dealloc(PyObject *self)\n{\n    memoryiterobject *it = (memoryiterobject *)self;\n    _PyObject_GC_UNTRACK(it);\n    Py_XDECREF(it->it_seq);\n    PyObject_GC_Del(it);\n}\n\nstatic int\nmemoryiter_traverse(PyObject *self, visitproc visit, void *arg)\n{\n    memoryiterobject *it = (memoryiterobject *)self;\n    Py_VISIT(it->it_seq);\n    return 0;\n}\n\nstatic PyObject *\nmemoryiter_next(PyObject *self)\n{\n    memoryiterobject *it = (memoryiterobject *)self;\n    PyMemoryViewObject *seq;\n    seq = it->it_seq;\n    if (seq == NULL) {\n        return NULL;\n    }\n\n    if (it->it_index < it->it_length) {\n        CHECK_RELEASED(seq);\n        Py_buffer *view = &(seq->view);\n        char *ptr = (char *)seq->view.buf;\n\n        ptr += view->strides[0] * it->it_index++;\n        ptr = ADJUST_PTR(ptr, view->suboffsets, 0);\n        if (ptr == NULL) {\n            return NULL;\n        }\n        return unpack_single(seq, ptr, it->it_fmt);\n    }\n\n    it->it_seq = NULL;\n    Py_DECREF(seq);\n    return NULL;\n}\n\nstatic PyObject *\nmemory_iter(PyObject *seq)\n{\n    if (!PyMemoryView_Check(seq)) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n    PyMemoryViewObject *obj = (PyMemoryViewObject *)seq;\n    int ndims = obj->view.ndim;\n    if (ndims == 0) {\n        PyErr_SetString(PyExc_TypeError, \"invalid indexing of 0-dim memory\");\n        return NULL;\n    }\n    if (ndims != 1) {\n        PyErr_SetString(PyExc_NotImplementedError,\n            \"multi-dimensional sub-views are not implemented\");\n        return NULL;\n    }\n\n    const char *fmt = adjust_fmt(&obj->view);\n    if (fmt == NULL) {\n        return NULL;\n    }\n\n    memoryiterobject *it;\n    it = PyObject_GC_New(memoryiterobject, &_PyMemoryIter_Type);\n    if (it == NULL) {\n        return NULL;\n    }\n    it->it_fmt = fmt;\n    it->it_length = memory_length((PyObject *)obj);\n    it->it_index = 0;\n    it->it_seq = (PyMemoryViewObject*)Py_NewRef(obj);\n    _PyObject_GC_TRACK(it);\n    return (PyObject *)it;\n}\n\nPyTypeObject _PyMemoryIter_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    .tp_name = \"memory_iterator\",\n    .tp_basicsize = sizeof(memoryiterobject),\n    // methods\n    .tp_dealloc = memoryiter_dealloc,\n    .tp_getattro = PyObject_GenericGetAttr,\n    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,\n    .tp_traverse = memoryiter_traverse,\n    .tp_iter = PyObject_SelfIter,\n    .tp_iternext = memoryiter_next,\n};\n\nPyTypeObject PyMemoryView_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"memoryview\",                             /* tp_name */\n    offsetof(PyMemoryViewObject, ob_array),   /* tp_basicsize */\n    sizeof(Py_ssize_t),                       /* tp_itemsize */\n    memory_dealloc,                           /* tp_dealloc */\n    0,                                        /* tp_vectorcall_offset */\n    0,                                        /* tp_getattr */\n    0,                                        /* tp_setattr */\n    0,                                        /* tp_as_async */\n    memory_repr,                              /* tp_repr */\n    0,                                        /* tp_as_number */\n    &memory_as_sequence,                      /* tp_as_sequence */\n    &memory_as_mapping,                       /* tp_as_mapping */\n    memory_hash,                              /* tp_hash */\n    0,                                        /* tp_call */\n    0,                                        /* tp_str */\n    PyObject_GenericGetAttr,                  /* tp_getattro */\n    0,                                        /* tp_setattro */\n    &memory_as_buffer,                        /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n       Py_TPFLAGS_SEQUENCE,                   /* tp_flags */\n    memoryview__doc__,                        /* tp_doc */\n    memory_traverse,                          /* tp_traverse */\n    memory_clear,                             /* tp_clear */\n    memory_richcompare,                       /* tp_richcompare */\n    offsetof(PyMemoryViewObject, weakreflist),/* tp_weaklistoffset */\n    memory_iter,                              /* tp_iter */\n    0,                                        /* tp_iternext */\n    memory_methods,                           /* tp_methods */\n    0,                                        /* tp_members */\n    memory_getsetlist,                        /* tp_getset */\n    0,                                        /* tp_base */\n    0,                                        /* tp_dict */\n    0,                                        /* tp_descr_get */\n    0,                                        /* tp_descr_set */\n    0,                                        /* tp_dictoffset */\n    0,                                        /* tp_init */\n    0,                                        /* tp_alloc */\n    memoryview,                               /* tp_new */\n};\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-null-dereference", "taxa": [{"id": "476", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "dereference of NULL '*mv.view.suboffsets'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 624, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 624, "snippet": {"text": "        if (MV_CONTIGUOUS_NDIM1(view))\n"}}}, "logicalLocations": [{"name": "init_flags", "fullyQualifiedName": "init_flags", "decoratedName": "init_flags", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2559, "startColumn": 1, "endColumn": 17}, "contextRegion": {"startLine": 2559, "snippet": {"text": "memory_subscript(PyObject *_self, PyObject *key)\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "entry to 'memory_subscript'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2565, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2565, "snippet": {"text": "    CHECK_RELEASED(self);\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2565, "startColumn": 25, "endColumn": 26}, "contextRegion": {"startLine": 2565, "snippet": {"text": "    CHECK_RELEASED(self);\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2567, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2567, "snippet": {"text": "    if (view->ndim == 0) {\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2584, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 2584, "snippet": {"text": "    if (_PyIndex_Check(key)) {\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2591, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 2591, "snippet": {"text": "    else if (PySlice_Check(key)) {\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2592, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 2592, "snippet": {"text": "        CHECK_RESTRICTED(self);\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2592, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 2592, "snippet": {"text": "        CHECK_RESTRICTED(self);\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2592, "startColumn": 31, "endColumn": 32}, "contextRegion": {"startLine": 2592, "snippet": {"text": "        CHECK_RESTRICTED(self);\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2595, "startColumn": 40, "endColumn": 71}, "contextRegion": {"startLine": 2595, "snippet": {"text": "        sliced = (PyMemoryViewObject *)mbuf_add_view(self->mbuf, view);\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "calling 'mbuf_add_view' from 'memory_subscript'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 678, "startColumn": 1, "endColumn": 14}, "contextRegion": {"startLine": 678, "snippet": {"text": "mbuf_add_view(_PyManagedBufferObject *mbuf, const Py_buffer *src)\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "entry to 'mbuf_add_view'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 683, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 683, "snippet": {"text": "    if (src == NULL)\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "following 'false' branch (when 'src' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 686, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 686, "snippet": {"text": "    if (src->ndim > PyBUF_MAX_NDIM) {\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 686, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 686, "snippet": {"text": "    if (src->ndim > PyBUF_MAX_NDIM) {\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 693, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 693, "snippet": {"text": "    mv = memory_alloc(src->ndim);\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 694, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 694, "snippet": {"text": "    if (mv == NULL)\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "following 'false' branch (when 'mv' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 697, "startColumn": 5, "endColumn": 9}, "contextRegion": {"startLine": 697, "snippet": {"text": "    dest = &mv->view;\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 699, "startColumn": 5, "endColumn": 34}, "contextRegion": {"startLine": 699, "snippet": {"text": "    init_shape_strides(dest, src);\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "calling 'init_shape_strides' from 'mbuf_add_view'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 558, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 558, "snippet": {"text": "init_shape_strides(Py_buffer *dest, const Py_buffer *src)\n"}}}, "logicalLocations": [{"name": "init_shape_strides", "fullyQualifiedName": "init_shape_strides", "decoratedName": "init_shape_strides", "kind": "function"}], "message": {"text": "entry to 'init_shape_strides'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 562, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 562, "snippet": {"text": "    if (src->ndim == 0) {\n"}}}, "logicalLocations": [{"name": "init_shape_strides", "fullyQualifiedName": "init_shape_strides", "decoratedName": "init_shape_strides", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 563, "startColumn": 9, "endColumn": 13}, "contextRegion": {"startLine": 563, "snippet": {"text": "        dest->shape = NULL;\n"}}}, "logicalLocations": [{"name": "init_shape_strides", "fullyQualifiedName": "init_shape_strides", "decoratedName": "init_shape_strides", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 563, "startColumn": 9, "endColumn": 24}, "contextRegion": {"startLine": 563, "snippet": {"text": "        dest->shape = NULL;\n"}}}, "logicalLocations": [{"name": "init_shape_strides", "fullyQualifiedName": "init_shape_strides", "decoratedName": "init_shape_strides", "kind": "function"}], "message": {"text": "'*mv.view.shape' is NULL"}}, "kinds": ["release", "memory"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 564, "startColumn": 9, "endColumn": 26}, "contextRegion": {"startLine": 564, "snippet": {"text": "        dest->strides = NULL;\n"}}}, "logicalLocations": [{"name": "init_shape_strides", "fullyQualifiedName": "init_shape_strides", "decoratedName": "init_shape_strides", "kind": "function"}], "message": {"text": "'*mv.view.shape' is NULL"}}, "kinds": ["release", "memory"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 699, "startColumn": 5, "endColumn": 34}, "contextRegion": {"startLine": 699, "snippet": {"text": "    init_shape_strides(dest, src);\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "returning to 'mbuf_add_view' from 'init_shape_strides'"}}, "kinds": ["return", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 700, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 700, "snippet": {"text": "    init_suboffsets(dest, src);\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "inlined call to 'init_suboffsets' from 'mbuf_add_view'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 589, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 589, "snippet": {"text": "    if (src->suboffsets == NULL) {\n"}}}, "logicalLocations": [{"name": "init_suboffsets", "fullyQualifiedName": "init_suboffsets", "decoratedName": "init_suboffsets", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 590, "startColumn": 9, "endColumn": 13}, "contextRegion": {"startLine": 590, "snippet": {"text": "        dest->suboffsets = NULL;\n"}}}, "logicalLocations": [{"name": "init_suboffsets", "fullyQualifiedName": "init_suboffsets", "decoratedName": "init_suboffsets", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 590, "startColumn": 9, "endColumn": 29}, "contextRegion": {"startLine": 590, "snippet": {"text": "        dest->suboffsets = NULL;\n"}}}, "logicalLocations": [{"name": "init_suboffsets", "fullyQualifiedName": "init_suboffsets", "decoratedName": "init_suboffsets", "kind": "function"}], "message": {"text": "'*mv.view.suboffsets' is NULL"}}, "kinds": ["release", "memory"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 701, "startColumn": 5, "endColumn": 19}, "contextRegion": {"startLine": 701, "snippet": {"text": "    init_flags(mv);\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "calling 'init_flags' from 'mbuf_add_view'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 613, "startColumn": 1, "endColumn": 11}, "contextRegion": {"startLine": 613, "snippet": {"text": "init_flags(PyMemoryViewObject *mv)\n"}}}, "logicalLocations": [{"name": "init_flags", "fullyQualifiedName": "init_flags", "decoratedName": "init_flags", "kind": "function"}], "message": {"text": "entry to 'init_flags'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 618, "startColumn": 5, "endColumn": 11}, "contextRegion": {"startLine": 618, "snippet": {"text": "    switch (view->ndim) {\n"}}}, "logicalLocations": [{"name": "init_flags", "fullyQualifiedName": "init_flags", "decoratedName": "init_flags", "kind": "function"}], "message": {"text": "following 'case 1:' branch..."}}, "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 623, "startColumn": 5, "endColumn": 9}, "contextRegion": {"startLine": 623, "snippet": {"text": "    case 1:\n"}}}, "logicalLocations": [{"name": "init_flags", "fullyQualifiedName": "init_flags", "decoratedName": "init_flags", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 624, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 624, "snippet": {"text": "        if (MV_CONTIGUOUS_NDIM1(view))\n"}}}, "logicalLocations": [{"name": "init_flags", "fullyQualifiedName": "init_flags", "decoratedName": "init_flags", "kind": "function"}], "message": {"text": "'*mv.view.suboffsets' is NULL"}}, "kinds": ["release", "memory"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 624, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 624, "snippet": {"text": "        if (MV_CONTIGUOUS_NDIM1(view))\n"}}}, "logicalLocations": [{"name": "init_flags", "fullyQualifiedName": "init_flags", "decoratedName": "init_flags", "kind": "function"}], "message": {"text": "dereference of NULL '*(const Py_buffer *)((char *)mv + 56).shape'"}}, "kinds": ["danger"], "nestingLevel": 3}]}]}]}, {"ruleId": "-Wanalyzer-null-dereference", "taxa": [{"id": "476", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "dereference of NULL '*mv.view.shape'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 624, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 624, "snippet": {"text": "        if (MV_CONTIGUOUS_NDIM1(view))\n"}}}, "logicalLocations": [{"name": "init_flags", "fullyQualifiedName": "init_flags", "decoratedName": "init_flags", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2559, "startColumn": 1, "endColumn": 17}, "contextRegion": {"startLine": 2559, "snippet": {"text": "memory_subscript(PyObject *_self, PyObject *key)\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "entry to 'memory_subscript'"}}, "kinds": ["enter", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2565, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 2565, "snippet": {"text": "    CHECK_RELEASED(self);\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2565, "startColumn": 25, "endColumn": 26}, "contextRegion": {"startLine": 2565, "snippet": {"text": "    CHECK_RELEASED(self);\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2567, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2567, "snippet": {"text": "    if (view->ndim == 0) {\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2584, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 2584, "snippet": {"text": "    if (_PyIndex_Check(key)) {\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2591, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 2591, "snippet": {"text": "    else if (PySlice_Check(key)) {\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2592, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 2592, "snippet": {"text": "        CHECK_RESTRICTED(self);\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2592, "startColumn": 9, "endColumn": 10}, "contextRegion": {"startLine": 2592, "snippet": {"text": "        CHECK_RESTRICTED(self);\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2592, "startColumn": 31, "endColumn": 32}, "contextRegion": {"startLine": 2592, "snippet": {"text": "        CHECK_RESTRICTED(self);\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 2595, "startColumn": 40, "endColumn": 71}, "contextRegion": {"startLine": 2595, "snippet": {"text": "        sliced = (PyMemoryViewObject *)mbuf_add_view(self->mbuf, view);\n"}}}, "logicalLocations": [{"name": "memory_subscript", "fullyQualifiedName": "memory_subscript", "decoratedName": "memory_subscript", "kind": "function"}], "message": {"text": "calling 'mbuf_add_view' from 'memory_subscript'"}}, "kinds": ["call", "function"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 678, "startColumn": 1, "endColumn": 14}, "contextRegion": {"startLine": 678, "snippet": {"text": "mbuf_add_view(_PyManagedBufferObject *mbuf, const Py_buffer *src)\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "entry to 'mbuf_add_view'"}}, "kinds": ["enter", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 683, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 683, "snippet": {"text": "    if (src == NULL)\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "following 'false' branch (when 'src' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 686, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 686, "snippet": {"text": "    if (src->ndim > PyBUF_MAX_NDIM) {\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 686, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 686, "snippet": {"text": "    if (src->ndim > PyBUF_MAX_NDIM) {\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 693, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 693, "snippet": {"text": "    mv = memory_alloc(src->ndim);\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 694, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 694, "snippet": {"text": "    if (mv == NULL)\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "following 'false' branch (when 'mv' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 697, "startColumn": 5, "endColumn": 9}, "contextRegion": {"startLine": 697, "snippet": {"text": "    dest = &mv->view;\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 699, "startColumn": 5, "endColumn": 34}, "contextRegion": {"startLine": 699, "snippet": {"text": "    init_shape_strides(dest, src);\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "calling 'init_shape_strides' from 'mbuf_add_view'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 558, "startColumn": 1, "endColumn": 19}, "contextRegion": {"startLine": 558, "snippet": {"text": "init_shape_strides(Py_buffer *dest, const Py_buffer *src)\n"}}}, "logicalLocations": [{"name": "init_shape_strides", "fullyQualifiedName": "init_shape_strides", "decoratedName": "init_shape_strides", "kind": "function"}], "message": {"text": "entry to 'init_shape_strides'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 562, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 562, "snippet": {"text": "    if (src->ndim == 0) {\n"}}}, "logicalLocations": [{"name": "init_shape_strides", "fullyQualifiedName": "init_shape_strides", "decoratedName": "init_shape_strides", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 563, "startColumn": 9, "endColumn": 13}, "contextRegion": {"startLine": 563, "snippet": {"text": "        dest->shape = NULL;\n"}}}, "logicalLocations": [{"name": "init_shape_strides", "fullyQualifiedName": "init_shape_strides", "decoratedName": "init_shape_strides", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 563, "startColumn": 9, "endColumn": 24}, "contextRegion": {"startLine": 563, "snippet": {"text": "        dest->shape = NULL;\n"}}}, "logicalLocations": [{"name": "init_shape_strides", "fullyQualifiedName": "init_shape_strides", "decoratedName": "init_shape_strides", "kind": "function"}], "message": {"text": "'*mv.view.shape' is NULL"}}, "kinds": ["release", "memory"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 564, "startColumn": 9, "endColumn": 26}, "contextRegion": {"startLine": 564, "snippet": {"text": "        dest->strides = NULL;\n"}}}, "logicalLocations": [{"name": "init_shape_strides", "fullyQualifiedName": "init_shape_strides", "decoratedName": "init_shape_strides", "kind": "function"}], "message": {"text": "'*mv.view.shape' is NULL"}}, "kinds": ["release", "memory"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 699, "startColumn": 5, "endColumn": 34}, "contextRegion": {"startLine": 699, "snippet": {"text": "    init_shape_strides(dest, src);\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "returning to 'mbuf_add_view' from 'init_shape_strides'"}}, "kinds": ["return", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 700, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 700, "snippet": {"text": "    init_suboffsets(dest, src);\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "inlined call to 'init_suboffsets' from 'mbuf_add_view'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 589, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 589, "snippet": {"text": "    if (src->suboffsets == NULL) {\n"}}}, "logicalLocations": [{"name": "init_suboffsets", "fullyQualifiedName": "init_suboffsets", "decoratedName": "init_suboffsets", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 700, "startColumn": 5, "endColumn": 6}, "contextRegion": {"startLine": 700, "snippet": {"text": "    init_suboffsets(dest, src);\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "inlined call to 'init_suboffsets' from 'mbuf_add_view'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 593, "startColumn": 17, "endColumn": 30}, "contextRegion": {"startLine": 593, "snippet": {"text": "    for (i = 0; i < src->ndim; i++)\n"}}}, "logicalLocations": [{"name": "init_suboffsets", "fullyQualifiedName": "init_suboffsets", "decoratedName": "init_suboffsets", "kind": "function"}], "message": {"text": "following 'false' branch..."}}, "kinds": ["branch", "false"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 700, "startColumn": 5, "endColumn": 31}, "contextRegion": {"startLine": 700, "snippet": {"text": "    init_suboffsets(dest, src);\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 701, "startColumn": 5, "endColumn": 19}, "contextRegion": {"startLine": 701, "snippet": {"text": "    init_flags(mv);\n"}}}, "logicalLocations": [{"name": "mbuf_add_view", "fullyQualifiedName": "mbuf_add_view", "decoratedName": "mbuf_add_view", "kind": "function"}], "message": {"text": "calling 'init_flags' from 'mbuf_add_view'"}}, "kinds": ["call", "function"], "nestingLevel": 2}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 613, "startColumn": 1, "endColumn": 11}, "contextRegion": {"startLine": 613, "snippet": {"text": "init_flags(PyMemoryViewObject *mv)\n"}}}, "logicalLocations": [{"name": "init_flags", "fullyQualifiedName": "init_flags", "decoratedName": "init_flags", "kind": "function"}], "message": {"text": "entry to 'init_flags'"}}, "kinds": ["enter", "function"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 618, "startColumn": 5, "endColumn": 11}, "contextRegion": {"startLine": 618, "snippet": {"text": "    switch (view->ndim) {\n"}}}, "logicalLocations": [{"name": "init_flags", "fullyQualifiedName": "init_flags", "decoratedName": "init_flags", "kind": "function"}], "message": {"text": "following 'case 1:' branch..."}}, "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 623, "startColumn": 5, "endColumn": 9}, "contextRegion": {"startLine": 623, "snippet": {"text": "    case 1:\n"}}}, "logicalLocations": [{"name": "init_flags", "fullyQualifiedName": "init_flags", "decoratedName": "init_flags", "kind": "function"}], "message": {"text": "...to here"}}, "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 624, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 624, "snippet": {"text": "        if (MV_CONTIGUOUS_NDIM1(view))\n"}}}, "logicalLocations": [{"name": "init_flags", "fullyQualifiedName": "init_flags", "decoratedName": "init_flags", "kind": "function"}], "message": {"text": "'*mv.view.shape' is NULL"}}, "kinds": ["release", "memory"], "nestingLevel": 3}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "Objects/memoryobject.c", "uriBaseId": "PWD"}, "region": {"startLine": 624, "startColumn": 13, "endColumn": 14}, "contextRegion": {"startLine": 624, "snippet": {"text": "        if (MV_CONTIGUOUS_NDIM1(view))\n"}}}, "logicalLocations": [{"name": "init_flags", "fullyQualifiedName": "init_flags", "decoratedName": "init_flags", "kind": "function"}], "message": {"text": "dereference of NULL '*(const Py_buffer *)((char *)mv + 56).shape'"}}, "kinds": ["danger"], "nestingLevel": 3}]}]}]}]}]}
