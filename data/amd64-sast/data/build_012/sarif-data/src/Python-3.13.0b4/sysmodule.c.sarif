{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C11", "fullName": "GNU C11 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wanalyzer-file-leak", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-file-leak"}, {"id": "-Wanalyzer-malloc-leak", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-malloc-leak"}]}}, "taxonomies": [{"name": "CWE", "version": "4.7", "organization": "MITRE", "shortDescription": {"text": "The MITRE Common Weakness Enumeration"}, "taxa": [{"id": "775", "helpUri": "https://cwe.mitre.org/data/definitions/775.html"}, {"id": "401", "helpUri": "https://cwe.mitre.org/data/definitions/401.html"}]}], "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///src/Python-3.13.0b4/"}}, "artifacts": [{"location": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "contents": {"text": "\n/* System module */\n\n/*\nVarious bits of information used by the interpreter are collected in\nmodule 'sys'.\nFunction member:\n- exit(sts): raise SystemExit\nData members:\n- stdin, stdout, stderr: standard file objects\n- modules: the table of modules (dictionary)\n- path: module search path (list of strings)\n- argv: script arguments (list of strings)\n- ps1, ps2: optional primary and secondary prompts (strings)\n*/\n\n#include \"Python.h\"\n#include \"pycore_call.h\"          // _PyObject_CallNoArgs()\n#include \"pycore_ceval.h\"         // _PyEval_SetAsyncGenFinalizer()\n#include \"pycore_dict.h\"          // _PyDict_GetItemWithError()\n#include \"pycore_frame.h\"         // _PyInterpreterFrame\n#include \"pycore_initconfig.h\"    // _PyStatus_EXCEPTION()\n#include \"pycore_long.h\"          // _PY_LONG_MAX_STR_DIGITS_THRESHOLD\n#include \"pycore_modsupport.h\"    // _PyModule_CreateInitialized()\n#include \"pycore_namespace.h\"     // _PyNamespace_New()\n#include \"pycore_object.h\"        // _PyObject_DebugTypeStats()\n#include \"pycore_pathconfig.h\"    // _PyPathConfig_ComputeSysPath0()\n#include \"pycore_pyerrors.h\"      // _PyErr_GetRaisedException()\n#include \"pycore_pylifecycle.h\"   // _PyErr_WriteUnraisableDefaultHook()\n#include \"pycore_pymath.h\"        // _PY_SHORT_FLOAT_REPR\n#include \"pycore_pymem.h\"         // _PyMem_SetDefaultAllocator()\n#include \"pycore_pystate.h\"       // _PyThreadState_GET()\n#include \"pycore_pystats.h\"       // _Py_PrintSpecializationStats()\n#include \"pycore_structseq.h\"     // _PyStructSequence_InitBuiltinWithFlags()\n#include \"pycore_sysmodule.h\"     // export _PySys_GetSizeOf()\n#include \"pycore_tuple.h\"         // _PyTuple_FromArray()\n\n#include \"pydtrace.h\"             // PyDTrace_AUDIT()\n#include \"osdefs.h\"               // DELIM\n#include \"stdlib_module_names.h\"  // _Py_stdlib_module_names\n\n#ifdef HAVE_UNISTD_H\n#  include <unistd.h>             // getpid()\n#endif\n\n#ifdef MS_WINDOWS\n#  define WIN32_LEAN_AND_MEAN\n#  include <windows.h>\n#endif /* MS_WINDOWS */\n\n#ifdef MS_COREDLL\nextern void *PyWin_DLLhModule;\n/* A string loaded from the DLL at startup: */\nextern const char *PyWin_DLLVersionString;\n#endif\n\n#ifdef __EMSCRIPTEN__\n#  include <emscripten.h>\n#endif\n\n#ifdef HAVE_FCNTL_H\n#  include <fcntl.h>\n#endif\n\n/*[clinic input]\nmodule sys\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=3726b388feee8cea]*/\n\n#include \"clinic/sysmodule.c.h\"\n\n\nPyObject *\n_PySys_GetAttr(PyThreadState *tstate, PyObject *name)\n{\n    PyObject *sd = tstate->interp->sysdict;\n    if (sd == NULL) {\n        return NULL;\n    }\n    PyObject *exc = _PyErr_GetRaisedException(tstate);\n    /* XXX Suppress a new exception if it was raised and restore\n     * the old one. */\n    PyObject *value = _PyDict_GetItemWithError(sd, name);\n    _PyErr_SetRaisedException(tstate, exc);\n    return value;\n}\n\nstatic PyObject *\n_PySys_GetObject(PyInterpreterState *interp, const char *name)\n{\n    PyObject *sysdict = interp->sysdict;\n    if (sysdict == NULL) {\n        return NULL;\n    }\n    PyObject *value;\n    if (PyDict_GetItemStringRef(sysdict, name, &value) != 1) {\n        return NULL;\n    }\n    Py_DECREF(value);  // return a borrowed reference\n    return value;\n}\n\nPyObject *\nPySys_GetObject(const char *name)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    PyObject *exc = _PyErr_GetRaisedException(tstate);\n    PyObject *value = _PySys_GetObject(tstate->interp, name);\n    /* XXX Suppress a new exception if it was raised and restore\n     * the old one. */\n    if (_PyErr_Occurred(tstate)) {\n        PyErr_FormatUnraisable(\"Exception ignored in PySys_GetObject()\");\n    }\n    _PyErr_SetRaisedException(tstate, exc);\n    return value;\n}\n\nstatic int\nsys_set_object(PyInterpreterState *interp, PyObject *key, PyObject *v)\n{\n    if (key == NULL) {\n        return -1;\n    }\n    PyObject *sd = interp->sysdict;\n    if (v == NULL) {\n        if (PyDict_Pop(sd, key, NULL) < 0) {\n            return -1;\n        }\n        return 0;\n    }\n    else {\n        return PyDict_SetItem(sd, key, v);\n    }\n}\n\nint\n_PySys_SetAttr(PyObject *key, PyObject *v)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    return sys_set_object(interp, key, v);\n}\n\nstatic int\nsys_set_object_str(PyInterpreterState *interp, const char *name, PyObject *v)\n{\n    PyObject *key = v ? PyUnicode_InternFromString(name)\n                      : PyUnicode_FromString(name);\n    int r = sys_set_object(interp, key, v);\n    Py_XDECREF(key);\n    return r;\n}\n\nint\nPySys_SetObject(const char *name, PyObject *v)\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    return sys_set_object_str(interp, name, v);\n}\n\nint\n_PySys_ClearAttrString(PyInterpreterState *interp,\n                       const char *name, int verbose)\n{\n    if (verbose) {\n        PySys_WriteStderr(\"# clear sys.%s\\n\", name);\n    }\n    /* To play it safe, we set the attr to None instead of deleting it. */\n    if (PyDict_SetItemString(interp->sysdict, name, Py_None) < 0) {\n        return -1;\n    }\n    return 0;\n}\n\n\nstatic int\nshould_audit(PyInterpreterState *interp)\n{\n    /* interp must not be NULL, but test it just in case for extra safety */\n    assert(interp != NULL);\n    if (!interp) {\n        return 0;\n    }\n    return (interp->runtime->audit_hooks.head\n            || interp->audit_hooks\n            || PyDTrace_AUDIT_ENABLED());\n}\n\n\nstatic int\nsys_audit_tstate(PyThreadState *ts, const char *event,\n                 const char *argFormat, va_list vargs)\n{\n    assert(event != NULL);\n    assert(!argFormat || !strchr(argFormat, 'N'));\n\n    if (!ts) {\n        /* Audit hooks cannot be called with a NULL thread state */\n        return 0;\n    }\n\n    /* The current implementation cannot be called if tstate is not\n       the current Python thread state. */\n    assert(ts == _PyThreadState_GET());\n\n    /* Early exit when no hooks are registered */\n    PyInterpreterState *is = ts->interp;\n    if (!should_audit(is)) {\n        return 0;\n    }\n\n    PyObject *eventName = NULL;\n    PyObject *eventArgs = NULL;\n    PyObject *hooks = NULL;\n    PyObject *hook = NULL;\n    int res = -1;\n\n    int dtrace = PyDTrace_AUDIT_ENABLED();\n\n\n    PyObject *exc = _PyErr_GetRaisedException(ts);\n\n    /* Initialize event args now */\n    if (argFormat && argFormat[0]) {\n        eventArgs = Py_VaBuildValue(argFormat, vargs);\n        if (eventArgs && !PyTuple_Check(eventArgs)) {\n            PyObject *argTuple = PyTuple_Pack(1, eventArgs);\n            Py_SETREF(eventArgs, argTuple);\n        }\n    }\n    else {\n        eventArgs = PyTuple_New(0);\n    }\n    if (!eventArgs) {\n        goto exit;\n    }\n\n    /* Call global hooks\n     *\n     * We don't worry about any races on hooks getting added,\n     * since that would not leave is in an inconsistent state. */\n    _Py_AuditHookEntry *e = is->runtime->audit_hooks.head;\n    for (; e; e = e->next) {\n        if (e->hookCFunction(event, eventArgs, e->userData) < 0) {\n            goto exit;\n        }\n    }\n\n    /* Dtrace USDT point */\n    if (dtrace) {\n        PyDTrace_AUDIT(event, (void *)eventArgs);\n    }\n\n    /* Call interpreter hooks */\n    if (is->audit_hooks) {\n        eventName = PyUnicode_FromString(event);\n        if (!eventName) {\n            goto exit;\n        }\n\n        hooks = PyObject_GetIter(is->audit_hooks);\n        if (!hooks) {\n            goto exit;\n        }\n\n        /* Disallow tracing in hooks unless explicitly enabled */\n        PyThreadState_EnterTracing(ts);\n        while ((hook = PyIter_Next(hooks)) != NULL) {\n            PyObject *o;\n            int canTrace = PyObject_GetOptionalAttr(hook, &_Py_ID(__cantrace__), &o);\n            if (o) {\n                canTrace = PyObject_IsTrue(o);\n                Py_DECREF(o);\n            }\n            if (canTrace < 0) {\n                break;\n            }\n            if (canTrace) {\n                PyThreadState_LeaveTracing(ts);\n            }\n            PyObject* args[2] = {eventName, eventArgs};\n            o = _PyObject_VectorcallTstate(ts, hook, args, 2, NULL);\n            if (canTrace) {\n                PyThreadState_EnterTracing(ts);\n            }\n            if (!o) {\n                break;\n            }\n            Py_DECREF(o);\n            Py_CLEAR(hook);\n        }\n        PyThreadState_LeaveTracing(ts);\n        if (_PyErr_Occurred(ts)) {\n            goto exit;\n        }\n    }\n\n    res = 0;\n\nexit:\n    Py_XDECREF(hook);\n    Py_XDECREF(hooks);\n    Py_XDECREF(eventName);\n    Py_XDECREF(eventArgs);\n\n    if (!res) {\n        _PyErr_SetRaisedException(ts, exc);\n    }\n    else {\n        assert(_PyErr_Occurred(ts));\n        Py_XDECREF(exc);\n    }\n\n    return res;\n}\n\nint\n_PySys_Audit(PyThreadState *tstate, const char *event,\n             const char *argFormat, ...)\n{\n    va_list vargs;\n    va_start(vargs, argFormat);\n    int res = sys_audit_tstate(tstate, event, argFormat, vargs);\n    va_end(vargs);\n    return res;\n}\n\nint\nPySys_Audit(const char *event, const char *argFormat, ...)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    va_list vargs;\n    va_start(vargs, argFormat);\n    int res = sys_audit_tstate(tstate, event, argFormat, vargs);\n    va_end(vargs);\n    return res;\n}\n\nint\nPySys_AuditTuple(const char *event, PyObject *args)\n{\n    if (args == NULL) {\n        return PySys_Audit(event, NULL);\n    }\n\n    if (!PyTuple_Check(args)) {\n        PyErr_Format(PyExc_TypeError, \"args must be tuple, got %s\",\n                     Py_TYPE(args)->tp_name);\n        return -1;\n    }\n    return PySys_Audit(event, \"O\", args);\n}\n\n/* We expose this function primarily for our own cleanup during\n * finalization. In general, it should not need to be called,\n * and as such the function is not exported.\n *\n * Must be finalizing to clear hooks */\nvoid\n_PySys_ClearAuditHooks(PyThreadState *ts)\n{\n    assert(ts != NULL);\n    if (!ts) {\n        return;\n    }\n\n    _PyRuntimeState *runtime = ts->interp->runtime;\n    /* The hooks are global so we have to check for runtime finalization. */\n    PyThreadState *finalizing = _PyRuntimeState_GetFinalizing(runtime);\n    assert(finalizing == ts);\n    if (finalizing != ts) {\n        return;\n    }\n\n    const PyConfig *config = _PyInterpreterState_GetConfig(ts->interp);\n    if (config->verbose) {\n        PySys_WriteStderr(\"# clear sys.audit hooks\\n\");\n    }\n\n    /* Hooks can abort later hooks for this event, but cannot\n       abort the clear operation itself. */\n    _PySys_Audit(ts, \"cpython._PySys_ClearAuditHooks\", NULL);\n    _PyErr_Clear(ts);\n\n    /* We don't worry about the very unlikely race right here,\n     * since it's entirely benign.  Nothing else removes entries\n     * from the list and adding an entry right now would not cause\n     * any trouble. */\n    _Py_AuditHookEntry *e = runtime->audit_hooks.head, *n;\n    runtime->audit_hooks.head = NULL;\n    while (e) {\n        n = e->next;\n        PyMem_RawFree(e);\n        e = n;\n    }\n}\n\nstatic void\nadd_audit_hook_entry_unlocked(_PyRuntimeState *runtime,\n                              _Py_AuditHookEntry *entry)\n{\n    if (runtime->audit_hooks.head == NULL) {\n        runtime->audit_hooks.head = entry;\n    }\n    else {\n        _Py_AuditHookEntry *last = runtime->audit_hooks.head;\n        while (last->next) {\n            last = last->next;\n        }\n        last->next = entry;\n    }\n}\n\nint\nPySys_AddAuditHook(Py_AuditHookFunction hook, void *userData)\n{\n    /* tstate can be NULL, so access directly _PyRuntime:\n       PySys_AddAuditHook() can be called before Python is initialized. */\n    _PyRuntimeState *runtime = &_PyRuntime;\n    PyThreadState *tstate;\n    if (runtime->initialized) {\n        tstate = _PyThreadState_GET();\n    }\n    else {\n        tstate = NULL;\n    }\n\n    /* Invoke existing audit hooks to allow them an opportunity to abort. */\n    /* Cannot invoke hooks until we are initialized */\n    if (tstate != NULL) {\n        if (_PySys_Audit(tstate, \"sys.addaudithook\", NULL) < 0) {\n            if (_PyErr_ExceptionMatches(tstate, PyExc_RuntimeError)) {\n                /* We do not report errors derived from RuntimeError */\n                _PyErr_Clear(tstate);\n                return 0;\n            }\n            return -1;\n        }\n    }\n\n    _Py_AuditHookEntry *e = (_Py_AuditHookEntry*)PyMem_RawMalloc(\n            sizeof(_Py_AuditHookEntry));\n    if (!e) {\n        if (tstate != NULL) {\n            _PyErr_NoMemory(tstate);\n        }\n        return -1;\n    }\n    e->next = NULL;\n    e->hookCFunction = (Py_AuditHookFunction)hook;\n    e->userData = userData;\n\n    PyMutex_Lock(&runtime->audit_hooks.mutex);\n    add_audit_hook_entry_unlocked(runtime, e);\n    PyMutex_Unlock(&runtime->audit_hooks.mutex);\n\n    return 0;\n}\n\n/*[clinic input]\nsys.addaudithook\n\n    hook: object\n\nAdds a new audit hook callback.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_addaudithook_impl(PyObject *module, PyObject *hook)\n/*[clinic end generated code: output=4f9c17aaeb02f44e input=0f3e191217a45e34]*/\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    /* Invoke existing audit hooks to allow them an opportunity to abort. */\n    if (_PySys_Audit(tstate, \"sys.addaudithook\", NULL) < 0) {\n        if (_PyErr_ExceptionMatches(tstate, PyExc_Exception)) {\n            /* We do not report errors derived from Exception */\n            _PyErr_Clear(tstate);\n            Py_RETURN_NONE;\n        }\n        return NULL;\n    }\n\n    PyInterpreterState *interp = tstate->interp;\n    if (interp->audit_hooks == NULL) {\n        interp->audit_hooks = PyList_New(0);\n        if (interp->audit_hooks == NULL) {\n            return NULL;\n        }\n        /* Avoid having our list of hooks show up in the GC module */\n        PyObject_GC_UnTrack(interp->audit_hooks);\n    }\n\n    if (PyList_Append(interp->audit_hooks, hook) < 0) {\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(audit_doc,\n\"audit($module, event, /, *args)\\n\\\n--\\n\\\n\\n\\\nPasses the event to any audit hooks that are attached.\");\n\nstatic PyObject *\nsys_audit(PyObject *self, PyObject *const *args, Py_ssize_t argc)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    _Py_EnsureTstateNotNULL(tstate);\n\n    if (argc == 0) {\n        _PyErr_SetString(tstate, PyExc_TypeError,\n                         \"audit() missing 1 required positional argument: \"\n                         \"'event'\");\n        return NULL;\n    }\n\n    assert(args[0] != NULL);\n    assert(PyUnicode_Check(args[0]));\n\n    if (!should_audit(tstate->interp)) {\n        Py_RETURN_NONE;\n    }\n\n    PyObject *auditEvent = args[0];\n    if (!auditEvent) {\n        _PyErr_SetString(tstate, PyExc_TypeError,\n                         \"expected str for argument 'event'\");\n        return NULL;\n    }\n    if (!PyUnicode_Check(auditEvent)) {\n        _PyErr_Format(tstate, PyExc_TypeError,\n                      \"expected str for argument 'event', not %.200s\",\n                      Py_TYPE(auditEvent)->tp_name);\n        return NULL;\n    }\n    const char *event = PyUnicode_AsUTF8(auditEvent);\n    if (!event) {\n        return NULL;\n    }\n\n    PyObject *auditArgs = _PyTuple_FromArray(args + 1, argc - 1);\n    if (!auditArgs) {\n        return NULL;\n    }\n\n    int res = _PySys_Audit(tstate, event, \"O\", auditArgs);\n    Py_DECREF(auditArgs);\n\n    if (res < 0) {\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\n\nstatic PyObject *\nsys_breakpointhook(PyObject *self, PyObject *const *args, Py_ssize_t nargs, PyObject *keywords)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    assert(!_PyErr_Occurred(tstate));\n    char *envar = Py_GETENV(\"PYTHONBREAKPOINT\");\n\n    if (envar == NULL || strlen(envar) == 0) {\n        envar = \"pdb.set_trace\";\n    }\n    else if (!strcmp(envar, \"0\")) {\n        /* The breakpoint is explicitly no-op'd. */\n        Py_RETURN_NONE;\n    }\n    /* According to POSIX the string returned by getenv() might be invalidated\n     * or the string content might be overwritten by a subsequent call to\n     * getenv().  Since importing a module can performs the getenv() calls,\n     * we need to save a copy of envar. */\n    envar = _PyMem_RawStrdup(envar);\n    if (envar == NULL) {\n        _PyErr_NoMemory(tstate);\n        return NULL;\n    }\n    const char *last_dot = strrchr(envar, '.');\n    const char *attrname = NULL;\n    PyObject *modulepath = NULL;\n\n    if (last_dot == NULL) {\n        /* The breakpoint is a built-in, e.g. PYTHONBREAKPOINT=int */\n        modulepath = PyUnicode_FromString(\"builtins\");\n        attrname = envar;\n    }\n    else if (last_dot != envar) {\n        /* Split on the last dot; */\n        modulepath = PyUnicode_FromStringAndSize(envar, last_dot - envar);\n        attrname = last_dot + 1;\n    }\n    else {\n        goto warn;\n    }\n    if (modulepath == NULL) {\n        PyMem_RawFree(envar);\n        return NULL;\n    }\n\n    PyObject *module = PyImport_Import(modulepath);\n    Py_DECREF(modulepath);\n\n    if (module == NULL) {\n        if (_PyErr_ExceptionMatches(tstate, PyExc_ImportError)) {\n            goto warn;\n        }\n        PyMem_RawFree(envar);\n        return NULL;\n    }\n\n    PyObject *hook = PyObject_GetAttrString(module, attrname);\n    Py_DECREF(module);\n\n    if (hook == NULL) {\n        if (_PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {\n            goto warn;\n        }\n        PyMem_RawFree(envar);\n        return NULL;\n    }\n    PyMem_RawFree(envar);\n    PyObject *retval = PyObject_Vectorcall(hook, args, nargs, keywords);\n    Py_DECREF(hook);\n    return retval;\n\n  warn:\n    /* If any of the imports went wrong, then warn and ignore. */\n    _PyErr_Clear(tstate);\n    int status = PyErr_WarnFormat(\n        PyExc_RuntimeWarning, 0,\n        \"Ignoring unimportable $PYTHONBREAKPOINT: \\\"%s\\\"\", envar);\n    PyMem_RawFree(envar);\n    if (status < 0) {\n        /* Printing the warning raised an exception. */\n        return NULL;\n    }\n    /* The warning was (probably) issued. */\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(breakpointhook_doc,\n\"breakpointhook($module, /, *args, **kwargs)\\n\"\n\"--\\n\"\n\"\\n\"\n\"This hook function is called by built-in breakpoint().\\n\"\n);\n\n/* Write repr(o) to sys.stdout using sys.stdout.encoding and 'backslashreplace'\n   error handler. If sys.stdout has a buffer attribute, use\n   sys.stdout.buffer.write(encoded), otherwise redecode the string and use\n   sys.stdout.write(redecoded).\n\n   Helper function for sys_displayhook(). */\nstatic int\nsys_displayhook_unencodable(PyObject *outf, PyObject *o)\n{\n    PyObject *stdout_encoding = NULL;\n    PyObject *encoded, *escaped_str, *repr_str, *buffer, *result;\n    const char *stdout_encoding_str;\n    int ret;\n\n    stdout_encoding = PyObject_GetAttr(outf, &_Py_ID(encoding));\n    if (stdout_encoding == NULL)\n        goto error;\n    stdout_encoding_str = PyUnicode_AsUTF8(stdout_encoding);\n    if (stdout_encoding_str == NULL)\n        goto error;\n\n    repr_str = PyObject_Repr(o);\n    if (repr_str == NULL)\n        goto error;\n    encoded = PyUnicode_AsEncodedString(repr_str,\n                                        stdout_encoding_str,\n                                        \"backslashreplace\");\n    Py_DECREF(repr_str);\n    if (encoded == NULL)\n        goto error;\n\n    if (PyObject_GetOptionalAttr(outf, &_Py_ID(buffer), &buffer) < 0) {\n        Py_DECREF(encoded);\n        goto error;\n    }\n    if (buffer) {\n        result = PyObject_CallMethodOneArg(buffer, &_Py_ID(write), encoded);\n        Py_DECREF(buffer);\n        Py_DECREF(encoded);\n        if (result == NULL)\n            goto error;\n        Py_DECREF(result);\n    }\n    else {\n        escaped_str = PyUnicode_FromEncodedObject(encoded,\n                                                  stdout_encoding_str,\n                                                  \"strict\");\n        Py_DECREF(encoded);\n        if (PyFile_WriteObject(escaped_str, outf, Py_PRINT_RAW) != 0) {\n            Py_DECREF(escaped_str);\n            goto error;\n        }\n        Py_DECREF(escaped_str);\n    }\n    ret = 0;\n    goto finally;\n\nerror:\n    ret = -1;\nfinally:\n    Py_XDECREF(stdout_encoding);\n    return ret;\n}\n\n/*[clinic input]\nsys.displayhook\n\n    object as o: object\n    /\n\nPrint an object to sys.stdout and also save it in builtins._\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_displayhook(PyObject *module, PyObject *o)\n/*[clinic end generated code: output=347477d006df92ed input=08ba730166d7ef72]*/\n{\n    PyObject *outf;\n    PyObject *builtins;\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    builtins = PyImport_GetModule(&_Py_ID(builtins));\n    if (builtins == NULL) {\n        if (!_PyErr_Occurred(tstate)) {\n            _PyErr_SetString(tstate, PyExc_RuntimeError,\n                             \"lost builtins module\");\n        }\n        return NULL;\n    }\n    Py_DECREF(builtins);\n\n    /* Print value except if None */\n    /* After printing, also assign to '_' */\n    /* Before, set '_' to None to avoid recursion */\n    if (o == Py_None) {\n        Py_RETURN_NONE;\n    }\n    if (PyObject_SetAttr(builtins, _Py_LATIN1_CHR('_'), Py_None) != 0)\n        return NULL;\n    outf = _PySys_GetAttr(tstate, &_Py_ID(stdout));\n    if (outf == NULL || outf == Py_None) {\n        _PyErr_SetString(tstate, PyExc_RuntimeError, \"lost sys.stdout\");\n        return NULL;\n    }\n    if (PyFile_WriteObject(o, outf, 0) != 0) {\n        if (_PyErr_ExceptionMatches(tstate, PyExc_UnicodeEncodeError)) {\n            int err;\n            /* repr(o) is not encodable to sys.stdout.encoding with\n             * sys.stdout.errors error handler (which is probably 'strict') */\n            _PyErr_Clear(tstate);\n            err = sys_displayhook_unencodable(outf, o);\n            if (err) {\n                return NULL;\n            }\n        }\n        else {\n            return NULL;\n        }\n    }\n    if (PyFile_WriteObject(_Py_LATIN1_CHR('\\n'), outf, Py_PRINT_RAW) != 0)\n        return NULL;\n    if (PyObject_SetAttr(builtins, _Py_LATIN1_CHR('_'), o) != 0)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n\n/*[clinic input]\nsys.excepthook\n\n    exctype:   object\n    value:     object\n    traceback: object\n    /\n\nHandle an exception by displaying it with a traceback on sys.stderr.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_excepthook_impl(PyObject *module, PyObject *exctype, PyObject *value,\n                    PyObject *traceback)\n/*[clinic end generated code: output=18d99fdda21b6b5e input=ecf606fa826f19d9]*/\n{\n    PyErr_Display(NULL, value, traceback);\n    Py_RETURN_NONE;\n}\n\n\n/*[clinic input]\nsys.exception\n\nReturn the current exception.\n\nReturn the most recent exception caught by an except clause\nin the current stack frame or in an older stack frame, or None\nif no such exception exists.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_exception_impl(PyObject *module)\n/*[clinic end generated code: output=2381ee2f25953e40 input=c88fbb94b6287431]*/\n{\n    _PyErr_StackItem *err_info = _PyErr_GetTopmostException(_PyThreadState_GET());\n    if (err_info->exc_value != NULL) {\n        return Py_NewRef(err_info->exc_value);\n    }\n    Py_RETURN_NONE;\n}\n\n\n/*[clinic input]\nsys.exc_info\n\nReturn current exception information: (type, value, traceback).\n\nReturn information about the most recent exception caught by an except\nclause in the current stack frame or in an older stack frame.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_exc_info_impl(PyObject *module)\n/*[clinic end generated code: output=3afd0940cf3a4d30 input=b5c5bf077788a3e5]*/\n{\n    _PyErr_StackItem *err_info = _PyErr_GetTopmostException(_PyThreadState_GET());\n    return _PyErr_StackItemToExcInfoTuple(err_info);\n}\n\n\n/*[clinic input]\nsys.unraisablehook\n\n    unraisable: object\n    /\n\nHandle an unraisable exception.\n\nThe unraisable argument has the following attributes:\n\n* exc_type: Exception type.\n* exc_value: Exception value, can be None.\n* exc_traceback: Exception traceback, can be None.\n* err_msg: Error message, can be None.\n* object: Object causing the exception, can be None.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_unraisablehook(PyObject *module, PyObject *unraisable)\n/*[clinic end generated code: output=bb92838b32abaa14 input=ec3af148294af8d3]*/\n{\n    return _PyErr_WriteUnraisableDefaultHook(unraisable);\n}\n\n\n/*[clinic input]\nsys.exit\n\n    status: object = None\n    /\n\nExit the interpreter by raising SystemExit(status).\n\nIf the status is omitted or None, it defaults to zero (i.e., success).\nIf the status is an integer, it will be used as the system exit status.\nIf it is another kind of object, it will be printed and the system\nexit status will be one (i.e., failure).\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_exit_impl(PyObject *module, PyObject *status)\n/*[clinic end generated code: output=13870986c1ab2ec0 input=b86ca9497baa94f2]*/\n{\n    /* Raise SystemExit so callers may catch it or clean up. */\n    PyErr_SetObject(PyExc_SystemExit, status);\n    return NULL;\n}\n\n\nstatic PyObject *\nget_utf8_unicode(void)\n{\n    _Py_DECLARE_STR(utf_8, \"utf-8\");\n    PyObject *ret = &_Py_STR(utf_8);\n    return Py_NewRef(ret);\n}\n\n/*[clinic input]\nsys.getdefaultencoding\n\nReturn the current default encoding used by the Unicode implementation.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_getdefaultencoding_impl(PyObject *module)\n/*[clinic end generated code: output=256d19dfcc0711e6 input=d416856ddbef6909]*/\n{\n    return get_utf8_unicode();\n}\n\n/*[clinic input]\nsys.getfilesystemencoding\n\nReturn the encoding used to convert Unicode filenames to OS filenames.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_getfilesystemencoding_impl(PyObject *module)\n/*[clinic end generated code: output=1dc4bdbe9be44aa7 input=8475f8649b8c7d8c]*/\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    const PyConfig *config = _PyInterpreterState_GetConfig(interp);\n\n    if (wcscmp(config->filesystem_encoding, L\"utf-8\") == 0) {\n        return get_utf8_unicode();\n    }\n\n    PyObject *u = PyUnicode_FromWideChar(config->filesystem_encoding, -1);\n    if (u == NULL) {\n        return NULL;\n    }\n    _PyUnicode_InternImmortal(interp, &u);\n    return u;\n}\n\n/*[clinic input]\nsys.getfilesystemencodeerrors\n\nReturn the error mode used Unicode to OS filename conversion.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_getfilesystemencodeerrors_impl(PyObject *module)\n/*[clinic end generated code: output=ba77b36bbf7c96f5 input=22a1e8365566f1e5]*/\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    const PyConfig *config = _PyInterpreterState_GetConfig(interp);\n    PyObject *u = PyUnicode_FromWideChar(config->filesystem_errors, -1);\n    if (u == NULL) {\n        return NULL;\n    }\n    _PyUnicode_InternImmortal(interp, &u);\n    return u;\n}\n\n/*[clinic input]\nsys.intern\n\n    string as s: unicode\n    /\n\n``Intern'' the given string.\n\nThis enters the string in the (global) table of interned strings whose\npurpose is to speed up dictionary lookups. Return the string itself or\nthe previously interned string object with the same value.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_intern_impl(PyObject *module, PyObject *s)\n/*[clinic end generated code: output=be680c24f5c9e5d6 input=849483c006924e2f]*/\n{\n    if (PyUnicode_CheckExact(s)) {\n        PyInterpreterState *interp = _PyInterpreterState_GET();\n        Py_INCREF(s);\n        _PyUnicode_InternMortal(interp, &s);\n        return s;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"can't intern %.400s\", Py_TYPE(s)->tp_name);\n        return NULL;\n    }\n}\n\n\n/*[clinic input]\nsys._is_interned -> bool\n\n  string: unicode\n  /\n\nReturn True if the given string is \"interned\".\n[clinic start generated code]*/\n\nstatic int\nsys__is_interned_impl(PyObject *module, PyObject *string)\n/*[clinic end generated code: output=c3678267b4e9d7ed input=039843e17883b606]*/\n{\n    return PyUnicode_CHECK_INTERNED(string);\n}\n\n\n/*\n * Cached interned string objects used for calling the profile and\n * trace functions.\n */\nstatic PyObject *whatstrings[8] = {\n   &_Py_ID(call),\n   &_Py_ID(exception),\n   &_Py_ID(line),\n   &_Py_ID(return),\n   &_Py_ID(c_call),\n   &_Py_ID(c_exception),\n   &_Py_ID(c_return),\n   &_Py_ID(opcode),\n};\n\n\nstatic PyObject *\ncall_trampoline(PyThreadState *tstate, PyObject* callback,\n                PyFrameObject *frame, int what, PyObject *arg)\n{\n    /* call the Python-level function */\n    if (arg == NULL) {\n        arg = Py_None;\n    }\n    PyObject *args[3] = {(PyObject *)frame, whatstrings[what], arg};\n    PyObject *result = _PyObject_VectorcallTstate(tstate, callback, args, 3, NULL);\n\n    return result;\n}\n\nstatic int\nprofile_trampoline(PyObject *self, PyFrameObject *frame,\n                   int what, PyObject *arg)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    PyObject *result = call_trampoline(tstate, self, frame, what, arg);\n    if (result == NULL) {\n        _PyEval_SetProfile(tstate, NULL, NULL);\n        return -1;\n    }\n\n    Py_DECREF(result);\n    return 0;\n}\n\nstatic int\ntrace_trampoline(PyObject *self, PyFrameObject *frame,\n                 int what, PyObject *arg)\n{\n    PyObject *callback;\n    if (what == PyTrace_CALL) {\n        callback = self;\n    }\n    else {\n        callback = frame->f_trace;\n    }\n    if (callback == NULL) {\n        return 0;\n    }\n\n    PyThreadState *tstate = _PyThreadState_GET();\n    PyObject *result = call_trampoline(tstate, callback, frame, what, arg);\n    if (result == NULL) {\n        _PyEval_SetTrace(tstate, NULL, NULL);\n        Py_CLEAR(frame->f_trace);\n        return -1;\n    }\n\n    if (result != Py_None) {\n        Py_XSETREF(frame->f_trace, result);\n    }\n    else {\n        Py_DECREF(result);\n    }\n    return 0;\n}\n\n/*[clinic input]\nsys.settrace\n\n    function: object\n    /\n\nSet the global debug tracing function.\n\nIt will be called on each function call.  See the debugger chapter\nin the library manual.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_settrace(PyObject *module, PyObject *function)\n/*[clinic end generated code: output=999d12e9d6ec4678 input=8107feb01c5f1c4e]*/\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (function == Py_None) {\n        if (_PyEval_SetTrace(tstate, NULL, NULL) < 0) {\n            return NULL;\n        }\n    }\n    else {\n        if (_PyEval_SetTrace(tstate, trace_trampoline, function) < 0) {\n            return NULL;\n        }\n    }\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nsys._settraceallthreads\n\n    function as arg: object\n    /\n\nSet the global debug tracing function in all running threads belonging to the current interpreter.\n\nIt will be called on each function call. See the debugger chapter\nin the library manual.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__settraceallthreads(PyObject *module, PyObject *arg)\n/*[clinic end generated code: output=161cca30207bf3ca input=d4bde1f810d73675]*/\n{\n    PyObject* argument = NULL;\n    Py_tracefunc func = NULL;\n\n    if (arg != Py_None) {\n        func = trace_trampoline;\n        argument = arg;\n    }\n\n\n    PyEval_SetTraceAllThreads(func, argument);\n\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nsys.gettrace\n\nReturn the global debug tracing function set with sys.settrace.\n\nSee the debugger chapter in the library manual.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_gettrace_impl(PyObject *module)\n/*[clinic end generated code: output=e97e3a4d8c971b6e input=373b51bb2147f4d8]*/\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    PyObject *temp = tstate->c_traceobj;\n\n    if (temp == NULL)\n        temp = Py_None;\n    return Py_NewRef(temp);\n}\n\n/*[clinic input]\nsys.setprofile\n\n    function: object\n    /\n\nSet the profiling function.\n\nIt will be called on each function call and return.  See the profiler\nchapter in the library manual.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_setprofile(PyObject *module, PyObject *function)\n/*[clinic end generated code: output=1c3503105939db9c input=055d0d7961413a62]*/\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (function == Py_None) {\n        if (_PyEval_SetProfile(tstate, NULL, NULL) < 0) {\n            return NULL;\n        }\n    }\n    else {\n        if (_PyEval_SetProfile(tstate, profile_trampoline, function) < 0) {\n            return NULL;\n        }\n    }\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nsys._setprofileallthreads\n\n    function as arg: object\n    /\n\nSet the profiling function in all running threads belonging to the current interpreter.\n\nIt will be called on each function call and return.  See the profiler\nchapter in the library manual.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__setprofileallthreads(PyObject *module, PyObject *arg)\n/*[clinic end generated code: output=2d61319e27b309fe input=a10589439ba20cee]*/\n{\n    PyObject* argument = NULL;\n    Py_tracefunc func = NULL;\n\n    if (arg != Py_None) {\n        func = profile_trampoline;\n        argument = arg;\n    }\n\n    PyEval_SetProfileAllThreads(func, argument);\n\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nsys.getprofile\n\nReturn the profiling function set with sys.setprofile.\n\nSee the profiler chapter in the library manual.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_getprofile_impl(PyObject *module)\n/*[clinic end generated code: output=579b96b373448188 input=1b3209d89a32965d]*/\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    PyObject *temp = tstate->c_profileobj;\n\n    if (temp == NULL)\n        temp = Py_None;\n    return Py_NewRef(temp);\n}\n\n\n/*[clinic input]\nsys.setswitchinterval\n\n    interval: double\n    /\n\nSet the ideal thread switching delay inside the Python interpreter.\n\nThe actual frequency of switching threads can be lower if the\ninterpreter executes long sequences of uninterruptible code\n(this is implementation-specific and workload-dependent).\n\nThe parameter must represent the desired switching delay in seconds\nA typical value is 0.005 (5 milliseconds).\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_setswitchinterval_impl(PyObject *module, double interval)\n/*[clinic end generated code: output=65a19629e5153983 input=561b477134df91d9]*/\n{\n    if (interval <= 0.0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"switch interval must be strictly positive\");\n        return NULL;\n    }\n    _PyEval_SetSwitchInterval((unsigned long) (1e6 * interval));\n    Py_RETURN_NONE;\n}\n\n\n/*[clinic input]\nsys.getswitchinterval -> double\n\nReturn the current thread switch interval; see sys.setswitchinterval().\n[clinic start generated code]*/\n\nstatic double\nsys_getswitchinterval_impl(PyObject *module)\n/*[clinic end generated code: output=a38c277c85b5096d input=bdf9d39c0ebbbb6f]*/\n{\n    return 1e-6 * _PyEval_GetSwitchInterval();\n}\n\n/*[clinic input]\nsys.setrecursionlimit\n\n    limit as new_limit: int\n    /\n\nSet the maximum depth of the Python interpreter stack to n.\n\nThis limit prevents infinite recursion from causing an overflow of the C\nstack and crashing Python.  The highest possible limit is platform-\ndependent.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_setrecursionlimit_impl(PyObject *module, int new_limit)\n/*[clinic end generated code: output=35e1c64754800ace input=b0f7a23393924af3]*/\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    if (new_limit < 1) {\n        _PyErr_SetString(tstate, PyExc_ValueError,\n                         \"recursion limit must be greater or equal than 1\");\n        return NULL;\n    }\n\n    /* Reject too low new limit if the current recursion depth is higher than\n       the new low-water mark. */\n    int depth = tstate->py_recursion_limit - tstate->py_recursion_remaining;\n    if (depth >= new_limit) {\n        _PyErr_Format(tstate, PyExc_RecursionError,\n                      \"cannot set the recursion limit to %i at \"\n                      \"the recursion depth %i: the limit is too low\",\n                      new_limit, depth);\n        return NULL;\n    }\n\n    Py_SetRecursionLimit(new_limit);\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nsys.set_coroutine_origin_tracking_depth\n\n  depth: int\n\nEnable or disable origin tracking for coroutine objects in this thread.\n\nCoroutine objects will track 'depth' frames of traceback information\nabout where they came from, available in their cr_origin attribute.\n\nSet a depth of 0 to disable.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_set_coroutine_origin_tracking_depth_impl(PyObject *module, int depth)\n/*[clinic end generated code: output=0a2123c1cc6759c5 input=a1d0a05f89d2c426]*/\n{\n    if (_PyEval_SetCoroutineOriginTrackingDepth(depth) < 0) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nsys.get_coroutine_origin_tracking_depth -> int\n\nCheck status of origin tracking for coroutine objects in this thread.\n[clinic start generated code]*/\n\nstatic int\nsys_get_coroutine_origin_tracking_depth_impl(PyObject *module)\n/*[clinic end generated code: output=3699f7be95a3afb8 input=335266a71205b61a]*/\n{\n    return _PyEval_GetCoroutineOriginTrackingDepth();\n}\n\nstatic PyTypeObject AsyncGenHooksType;\n\nPyDoc_STRVAR(asyncgen_hooks_doc,\n\"asyncgen_hooks\\n\\\n\\n\\\nA named tuple providing information about asynchronous\\n\\\ngenerators hooks.  The attributes are read only.\");\n\nstatic PyStructSequence_Field asyncgen_hooks_fields[] = {\n    {\"firstiter\", \"Hook to intercept first iteration\"},\n    {\"finalizer\", \"Hook to intercept finalization\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc asyncgen_hooks_desc = {\n    \"asyncgen_hooks\",          /* name */\n    asyncgen_hooks_doc,        /* doc */\n    asyncgen_hooks_fields ,    /* fields */\n    2\n};\n\nstatic PyObject *\nsys_set_asyncgen_hooks(PyObject *self, PyObject *args, PyObject *kw)\n{\n    static char *keywords[] = {\"firstiter\", \"finalizer\", NULL};\n    PyObject *firstiter = NULL;\n    PyObject *finalizer = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(\n            args, kw, \"|OO\", keywords,\n            &firstiter, &finalizer)) {\n        return NULL;\n    }\n\n    if (finalizer && finalizer != Py_None) {\n        if (!PyCallable_Check(finalizer)) {\n            PyErr_Format(PyExc_TypeError,\n                         \"callable finalizer expected, got %.50s\",\n                         Py_TYPE(finalizer)->tp_name);\n            return NULL;\n        }\n    }\n\n    if (firstiter && firstiter != Py_None) {\n        if (!PyCallable_Check(firstiter)) {\n            PyErr_Format(PyExc_TypeError,\n                         \"callable firstiter expected, got %.50s\",\n                         Py_TYPE(firstiter)->tp_name);\n            return NULL;\n        }\n    }\n\n    PyObject *cur_finalizer = _PyEval_GetAsyncGenFinalizer();\n\n    if (finalizer && finalizer != Py_None) {\n        if (_PyEval_SetAsyncGenFinalizer(finalizer) < 0) {\n            return NULL;\n        }\n    }\n    else if (finalizer == Py_None && _PyEval_SetAsyncGenFinalizer(NULL) < 0) {\n        return NULL;\n    }\n\n    if (firstiter && firstiter != Py_None) {\n        if (_PyEval_SetAsyncGenFirstiter(firstiter) < 0) {\n            goto error;\n        }\n    }\n    else if (firstiter == Py_None && _PyEval_SetAsyncGenFirstiter(NULL) < 0) {\n        goto error;\n    }\n\n    Py_RETURN_NONE;\n\nerror:\n    _PyEval_SetAsyncGenFinalizer(cur_finalizer);\n    return NULL;\n}\n\nPyDoc_STRVAR(set_asyncgen_hooks_doc,\n\"set_asyncgen_hooks([firstiter] [, finalizer])\\n\\\n\\n\\\nSet a finalizer for async generators objects.\"\n);\n\n/*[clinic input]\nsys.get_asyncgen_hooks\n\nReturn the installed asynchronous generators hooks.\n\nThis returns a namedtuple of the form (firstiter, finalizer).\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_get_asyncgen_hooks_impl(PyObject *module)\n/*[clinic end generated code: output=53a253707146f6cf input=3676b9ea62b14625]*/\n{\n    PyObject *res;\n    PyObject *firstiter = _PyEval_GetAsyncGenFirstiter();\n    PyObject *finalizer = _PyEval_GetAsyncGenFinalizer();\n\n    res = PyStructSequence_New(&AsyncGenHooksType);\n    if (res == NULL) {\n        return NULL;\n    }\n\n    if (firstiter == NULL) {\n        firstiter = Py_None;\n    }\n\n    if (finalizer == NULL) {\n        finalizer = Py_None;\n    }\n\n    PyStructSequence_SET_ITEM(res, 0, Py_NewRef(firstiter));\n    PyStructSequence_SET_ITEM(res, 1, Py_NewRef(finalizer));\n\n    return res;\n}\n\n\nstatic PyTypeObject Hash_InfoType;\n\nPyDoc_STRVAR(hash_info_doc,\n\"hash_info\\n\\\n\\n\\\nA named tuple providing parameters used for computing\\n\\\nhashes. The attributes are read only.\");\n\nstatic PyStructSequence_Field hash_info_fields[] = {\n    {\"width\", \"width of the type used for hashing, in bits\"},\n    {\"modulus\", \"prime number giving the modulus on which the hash \"\n                \"function is based\"},\n    {\"inf\", \"value to be used for hash of a positive infinity\"},\n    {\"nan\", \"value to be used for hash of a nan\"},\n    {\"imag\", \"multiplier used for the imaginary part of a complex number\"},\n    {\"algorithm\", \"name of the algorithm for hashing of str, bytes and \"\n                  \"memoryviews\"},\n    {\"hash_bits\", \"internal output size of hash algorithm\"},\n    {\"seed_bits\", \"seed size of hash algorithm\"},\n    {\"cutoff\", \"small string optimization cutoff\"},\n    {NULL, NULL}\n};\n\nstatic PyStructSequence_Desc hash_info_desc = {\n    \"sys.hash_info\",\n    hash_info_doc,\n    hash_info_fields,\n    9,\n};\n\nstatic PyObject *\nget_hash_info(PyThreadState *tstate)\n{\n    PyObject *hash_info;\n    int field = 0;\n    PyHash_FuncDef *hashfunc;\n    hash_info = PyStructSequence_New(&Hash_InfoType);\n    if (hash_info == NULL) {\n        return NULL;\n    }\n    hashfunc = PyHash_GetFuncDef();\n\n#define SET_HASH_INFO_ITEM(CALL)                             \\\n    do {                                                     \\\n        PyObject *item = (CALL);                             \\\n        if (item == NULL) {                                  \\\n            Py_CLEAR(hash_info);                             \\\n            return NULL;                                     \\\n        }                                                    \\\n        PyStructSequence_SET_ITEM(hash_info, field++, item); \\\n    } while(0)\n\n    SET_HASH_INFO_ITEM(PyLong_FromLong(8 * sizeof(Py_hash_t)));\n    SET_HASH_INFO_ITEM(PyLong_FromSsize_t(_PyHASH_MODULUS));\n    SET_HASH_INFO_ITEM(PyLong_FromLong(_PyHASH_INF));\n    SET_HASH_INFO_ITEM(PyLong_FromLong(0));  // This is no longer used\n    SET_HASH_INFO_ITEM(PyLong_FromLong(_PyHASH_IMAG));\n    SET_HASH_INFO_ITEM(PyUnicode_FromString(hashfunc->name));\n    SET_HASH_INFO_ITEM(PyLong_FromLong(hashfunc->hash_bits));\n    SET_HASH_INFO_ITEM(PyLong_FromLong(hashfunc->seed_bits));\n    SET_HASH_INFO_ITEM(PyLong_FromLong(Py_HASH_CUTOFF));\n\n#undef SET_HASH_INFO_ITEM\n\n    return hash_info;\n}\n/*[clinic input]\nsys.getrecursionlimit\n\nReturn the current value of the recursion limit.\n\nThe recursion limit is the maximum depth of the Python interpreter\nstack.  This limit prevents infinite recursion from causing an overflow\nof the C stack and crashing Python.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_getrecursionlimit_impl(PyObject *module)\n/*[clinic end generated code: output=d571fb6b4549ef2e input=1c6129fd2efaeea8]*/\n{\n    return PyLong_FromLong(Py_GetRecursionLimit());\n}\n\n#ifdef MS_WINDOWS\n\nstatic PyTypeObject WindowsVersionType = {0, 0, 0, 0, 0, 0};\n\nstatic PyStructSequence_Field windows_version_fields[] = {\n    {\"major\", \"Major version number\"},\n    {\"minor\", \"Minor version number\"},\n    {\"build\", \"Build number\"},\n    {\"platform\", \"Operating system platform\"},\n    {\"service_pack\", \"Latest Service Pack installed on the system\"},\n    {\"service_pack_major\", \"Service Pack major version number\"},\n    {\"service_pack_minor\", \"Service Pack minor version number\"},\n    {\"suite_mask\", \"Bit mask identifying available product suites\"},\n    {\"product_type\", \"System product type\"},\n    {\"platform_version\", \"Diagnostic version number\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc windows_version_desc = {\n    \"sys.getwindowsversion\",       /* name */\n    sys_getwindowsversion__doc__,  /* doc */\n    windows_version_fields,        /* fields */\n    5                              /* For backward compatibility,\n                                      only the first 5 items are accessible\n                                      via indexing, the rest are name only */\n};\n\nstatic PyObject *\n_sys_getwindowsversion_from_kernel32(void)\n{\n#ifndef MS_WINDOWS_DESKTOP\n    return NULL;\n#else\n    HANDLE hKernel32;\n    wchar_t kernel32_path[MAX_PATH];\n    LPVOID verblock;\n    DWORD verblock_size;\n    VS_FIXEDFILEINFO *ffi;\n    UINT ffi_len;\n    DWORD realMajor, realMinor, realBuild;\n\n    Py_BEGIN_ALLOW_THREADS\n    hKernel32 = GetModuleHandleW(L\"kernel32.dll\");\n    Py_END_ALLOW_THREADS\n    if (!hKernel32 || !GetModuleFileNameW(hKernel32, kernel32_path, MAX_PATH)) {\n        PyErr_SetFromWindowsErr(0);\n        return NULL;\n    }\n    verblock_size = GetFileVersionInfoSizeW(kernel32_path, NULL);\n    if (!verblock_size) {\n        PyErr_SetFromWindowsErr(0);\n        return NULL;\n    }\n    verblock = PyMem_RawMalloc(verblock_size);\n    if (!verblock ||\n        !GetFileVersionInfoW(kernel32_path, 0, verblock_size, verblock) ||\n        !VerQueryValueW(verblock, L\"\", (LPVOID)&ffi, &ffi_len)) {\n        PyErr_SetFromWindowsErr(0);\n        return NULL;\n    }\n\n    realMajor = HIWORD(ffi->dwProductVersionMS);\n    realMinor = LOWORD(ffi->dwProductVersionMS);\n    realBuild = HIWORD(ffi->dwProductVersionLS);\n    PyMem_RawFree(verblock);\n    return Py_BuildValue(\"(kkk)\", realMajor, realMinor, realBuild);\n#endif /* !MS_WINDOWS_DESKTOP */\n}\n\n/* Disable deprecation warnings about GetVersionEx as the result is\n   being passed straight through to the caller, who is responsible for\n   using it correctly. */\n#pragma warning(push)\n#pragma warning(disable:4996)\n\n/*[clinic input]\nsys.getwindowsversion\n\nReturn info about the running version of Windows as a named tuple.\n\nThe members are named: major, minor, build, platform, service_pack,\nservice_pack_major, service_pack_minor, suite_mask, product_type and\nplatform_version. For backward compatibility, only the first 5 items\nare available by indexing. All elements are numbers, except\nservice_pack and platform_type which are strings, and platform_version\nwhich is a 3-tuple. Platform is always 2. Product_type may be 1 for a\nworkstation, 2 for a domain controller, 3 for a server.\nPlatform_version is a 3-tuple containing a version number that is\nintended for identifying the OS rather than feature detection.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_getwindowsversion_impl(PyObject *module)\n/*[clinic end generated code: output=1ec063280b932857 input=73a228a328fee63a]*/\n{\n    PyObject *version;\n    int pos = 0;\n    OSVERSIONINFOEXW ver;\n\n    if (PyObject_GetOptionalAttrString(module, \"_cached_windows_version\", &version) < 0) {\n        return NULL;\n    };\n    if (version && PyObject_TypeCheck(version, &WindowsVersionType)) {\n        return version;\n    }\n    Py_XDECREF(version);\n\n    ver.dwOSVersionInfoSize = sizeof(ver);\n    if (!GetVersionExW((OSVERSIONINFOW*) &ver))\n        return PyErr_SetFromWindowsErr(0);\n\n    version = PyStructSequence_New(&WindowsVersionType);\n    if (version == NULL)\n        return NULL;\n\n#define SET_VERSION_INFO(CALL)                               \\\n    do {                                                     \\\n        PyObject *item = (CALL);                             \\\n        if (item == NULL) {                                  \\\n            goto error;                                      \\\n        }                                                    \\\n        PyStructSequence_SET_ITEM(version, pos++, item);     \\\n    } while(0)\n\n    SET_VERSION_INFO(PyLong_FromLong(ver.dwMajorVersion));\n    SET_VERSION_INFO(PyLong_FromLong(ver.dwMinorVersion));\n    SET_VERSION_INFO(PyLong_FromLong(ver.dwBuildNumber));\n    SET_VERSION_INFO(PyLong_FromLong(ver.dwPlatformId));\n    SET_VERSION_INFO(PyUnicode_FromWideChar(ver.szCSDVersion, -1));\n    SET_VERSION_INFO(PyLong_FromLong(ver.wServicePackMajor));\n    SET_VERSION_INFO(PyLong_FromLong(ver.wServicePackMinor));\n    SET_VERSION_INFO(PyLong_FromLong(ver.wSuiteMask));\n    SET_VERSION_INFO(PyLong_FromLong(ver.wProductType));\n\n    // GetVersion will lie if we are running in a compatibility mode.\n    // We need to read the version info from a system file resource\n    // to accurately identify the OS version. If we fail for any reason,\n    // just return whatever GetVersion said.\n    PyObject *realVersion = _sys_getwindowsversion_from_kernel32();\n    if (!realVersion) {\n        if (!PyErr_ExceptionMatches(PyExc_WindowsError)) {\n            return NULL;\n        }\n\n        PyErr_Clear();\n        realVersion = Py_BuildValue(\"(kkk)\",\n            ver.dwMajorVersion,\n            ver.dwMinorVersion,\n            ver.dwBuildNumber\n        );\n    }\n\n    SET_VERSION_INFO(realVersion);\n\n#undef SET_VERSION_INFO\n\n    if (PyObject_SetAttrString(module, \"_cached_windows_version\", version) < 0) {\n        goto error;\n    }\n\n    return version;\n\nerror:\n    Py_DECREF(version);\n    return NULL;\n}\n\n#pragma warning(pop)\n\n/*[clinic input]\nsys._enablelegacywindowsfsencoding\n\nChanges the default filesystem encoding to mbcs:replace.\n\nThis is done for consistency with earlier versions of Python. See PEP\n529 for more information.\n\nThis is equivalent to defining the PYTHONLEGACYWINDOWSFSENCODING\nenvironment variable before launching Python.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__enablelegacywindowsfsencoding_impl(PyObject *module)\n/*[clinic end generated code: output=f5c3855b45e24fe9 input=2bfa931a20704492]*/\n{\n    if (PyErr_WarnEx(PyExc_DeprecationWarning,\n        \"sys._enablelegacywindowsfsencoding() is deprecated and will be \"\n        \"removed in Python 3.16. Use PYTHONLEGACYWINDOWSFSENCODING \"\n        \"instead.\", 1))\n    {\n        return NULL;\n    }\n    if (_PyUnicode_EnableLegacyWindowsFSEncoding() < 0) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\n#endif /* MS_WINDOWS */\n\n#ifdef HAVE_DLOPEN\n\n/*[clinic input]\nsys.setdlopenflags\n\n    flags as new_val: int\n    /\n\nSet the flags used by the interpreter for dlopen calls.\n\nThis is used, for example, when the interpreter loads extension\nmodules. Among other things, this will enable a lazy resolving of\nsymbols when importing a module, if called as sys.setdlopenflags(0).\nTo share symbols across extension modules, call as\nsys.setdlopenflags(os.RTLD_GLOBAL).  Symbolic names for the flag\nmodules can be found in the os module (RTLD_xxx constants, e.g.\nos.RTLD_LAZY).\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_setdlopenflags_impl(PyObject *module, int new_val)\n/*[clinic end generated code: output=ec918b7fe0a37281 input=4c838211e857a77f]*/\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    _PyImport_SetDLOpenFlags(interp, new_val);\n    Py_RETURN_NONE;\n}\n\n\n/*[clinic input]\nsys.getdlopenflags\n\nReturn the current value of the flags that are used for dlopen calls.\n\nThe flag constants are defined in the os module.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_getdlopenflags_impl(PyObject *module)\n/*[clinic end generated code: output=e92cd1bc5005da6e input=dc4ea0899c53b4b6]*/\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    return PyLong_FromLong(\n            _PyImport_GetDLOpenFlags(interp));\n}\n\n#endif  /* HAVE_DLOPEN */\n\n#ifdef USE_MALLOPT\n/* Link with -lmalloc (or -lmpc) on an SGI */\n#include <malloc.h>\n\n/*[clinic input]\nsys.mdebug\n\n    flag: int\n    /\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_mdebug_impl(PyObject *module, int flag)\n/*[clinic end generated code: output=5431d545847c3637 input=151d150ae1636f8a]*/\n{\n    int flag;\n    mallopt(M_DEBUG, flag);\n    Py_RETURN_NONE;\n}\n#endif /* USE_MALLOPT */\n\n\n/*[clinic input]\nsys.get_int_max_str_digits\n\nReturn the maximum string digits limit for non-binary int<->str conversions.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_get_int_max_str_digits_impl(PyObject *module)\n/*[clinic end generated code: output=0042f5e8ae0e8631 input=61bf9f99bc8b112d]*/\n{\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    return PyLong_FromLong(interp->long_state.max_str_digits);\n}\n\n/*[clinic input]\nsys.set_int_max_str_digits\n\n    maxdigits: int\n\nSet the maximum string digits limit for non-binary int<->str conversions.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_set_int_max_str_digits_impl(PyObject *module, int maxdigits)\n/*[clinic end generated code: output=734d4c2511f2a56d input=d7e3f325db6910c5]*/\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if ((!maxdigits) || (maxdigits >= _PY_LONG_MAX_STR_DIGITS_THRESHOLD)) {\n        tstate->interp->long_state.max_str_digits = maxdigits;\n        Py_RETURN_NONE;\n    } else {\n        PyErr_Format(\n            PyExc_ValueError, \"maxdigits must be 0 or larger than %d\",\n            _PY_LONG_MAX_STR_DIGITS_THRESHOLD);\n        return NULL;\n    }\n}\n\nsize_t\n_PySys_GetSizeOf(PyObject *o)\n{\n    PyObject *res = NULL;\n    PyObject *method;\n    Py_ssize_t size;\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    /* Make sure the type is initialized. float gets initialized late */\n    if (PyType_Ready(Py_TYPE(o)) < 0) {\n        return (size_t)-1;\n    }\n\n    method = _PyObject_LookupSpecial(o, &_Py_ID(__sizeof__));\n    if (method == NULL) {\n        if (!_PyErr_Occurred(tstate)) {\n            _PyErr_Format(tstate, PyExc_TypeError,\n                          \"Type %.100s doesn't define __sizeof__\",\n                          Py_TYPE(o)->tp_name);\n        }\n    }\n    else {\n        res = _PyObject_CallNoArgs(method);\n        Py_DECREF(method);\n    }\n\n    if (res == NULL)\n        return (size_t)-1;\n\n    size = PyLong_AsSsize_t(res);\n    Py_DECREF(res);\n    if (size == -1 && _PyErr_Occurred(tstate))\n        return (size_t)-1;\n\n    if (size < 0) {\n        _PyErr_SetString(tstate, PyExc_ValueError,\n                          \"__sizeof__() should return >= 0\");\n        return (size_t)-1;\n    }\n\n    size_t presize = 0;\n    if (!Py_IS_TYPE(o, &PyType_Type) ||\n         PyType_HasFeature((PyTypeObject *)o, Py_TPFLAGS_HEAPTYPE))\n    {\n        /* Add the size of the pre-header if \"o\" is not a static type */\n        presize = _PyType_PreHeaderSize(Py_TYPE(o));\n    }\n\n    return (size_t)size + presize;\n}\n\nstatic PyObject *\nsys_getsizeof(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"object\", \"default\", 0};\n    size_t size;\n    PyObject *o, *dflt = NULL;\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O|O:getsizeof\",\n                                     kwlist, &o, &dflt)) {\n        return NULL;\n    }\n\n    size = _PySys_GetSizeOf(o);\n\n    if (size == (size_t)-1 && _PyErr_Occurred(tstate)) {\n        /* Has a default value been given */\n        if (dflt != NULL && _PyErr_ExceptionMatches(tstate, PyExc_TypeError)) {\n            _PyErr_Clear(tstate);\n            return Py_NewRef(dflt);\n        }\n        else\n            return NULL;\n    }\n\n    return PyLong_FromSize_t(size);\n}\n\nPyDoc_STRVAR(getsizeof_doc,\n\"getsizeof(object [, default]) -> int\\n\\\n\\n\\\nReturn the size of object in bytes.\");\n\n/*[clinic input]\nsys.getrefcount -> Py_ssize_t\n\n    object:  object\n    /\n\nReturn the reference count of object.\n\nThe count returned is generally one higher than you might expect,\nbecause it includes the (temporary) reference as an argument to\ngetrefcount().\n[clinic start generated code]*/\n\nstatic Py_ssize_t\nsys_getrefcount_impl(PyObject *module, PyObject *object)\n/*[clinic end generated code: output=5fd477f2264b85b2 input=bf474efd50a21535]*/\n{\n    return Py_REFCNT(object);\n}\n\n#ifdef Py_REF_DEBUG\n/*[clinic input]\nsys.gettotalrefcount -> Py_ssize_t\n[clinic start generated code]*/\n\nstatic Py_ssize_t\nsys_gettotalrefcount_impl(PyObject *module)\n/*[clinic end generated code: output=4103886cf17c25bc input=53b744faa5d2e4f6]*/\n{\n    /* It may make sense to return the total for the current interpreter\n       or have a second function that does so. */\n    return _Py_GetGlobalRefTotal();\n}\n\n#endif /* Py_REF_DEBUG */\n\n/*[clinic input]\nsys.getallocatedblocks -> Py_ssize_t\n\nReturn the number of memory blocks currently allocated.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\nsys_getallocatedblocks_impl(PyObject *module)\n/*[clinic end generated code: output=f0c4e873f0b6dcf7 input=dab13ee346a0673e]*/\n{\n    // It might make sense to return the count\n    // for just the current interpreter.\n    return _Py_GetGlobalAllocatedBlocks();\n}\n\n/*[clinic input]\nsys.getunicodeinternedsize -> Py_ssize_t\n\n    *\n    _only_immortal: bool = False\n\nReturn the number of elements of the unicode interned dictionary\n[clinic start generated code]*/\n\nstatic Py_ssize_t\nsys_getunicodeinternedsize_impl(PyObject *module, int _only_immortal)\n/*[clinic end generated code: output=29a6377a94a14f70 input=0330b3408dd5bcc6]*/\n{\n    if (_only_immortal) {\n        return _PyUnicode_InternedSize_Immortal();\n    }\n    else {\n        return _PyUnicode_InternedSize();\n    }\n}\n\n/*[clinic input]\nsys._getframe\n\n    depth: int = 0\n    /\n\nReturn a frame object from the call stack.\n\nIf optional integer depth is given, return the frame object that many\ncalls below the top of the stack.  If that is deeper than the call\nstack, ValueError is raised.  The default for depth is zero, returning\nthe frame at the top of the call stack.\n\nThis function should be used for internal and specialized purposes\nonly.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__getframe_impl(PyObject *module, int depth)\n/*[clinic end generated code: output=d438776c04d59804 input=c1be8a6464b11ee5]*/\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    _PyInterpreterFrame *frame = tstate->current_frame;\n\n    if (frame != NULL) {\n        while (depth > 0) {\n            frame = _PyFrame_GetFirstComplete(frame->previous);\n            if (frame == NULL) {\n                break;\n            }\n            --depth;\n        }\n    }\n    if (frame == NULL) {\n        _PyErr_SetString(tstate, PyExc_ValueError,\n                         \"call stack is not deep enough\");\n        return NULL;\n    }\n\n    PyObject *pyFrame = Py_XNewRef((PyObject *)_PyFrame_GetFrameObject(frame));\n    if (pyFrame && _PySys_Audit(tstate, \"sys._getframe\", \"(O)\", pyFrame) < 0) {\n        Py_DECREF(pyFrame);\n        return NULL;\n    }\n    return pyFrame;\n}\n\n/*[clinic input]\nsys._current_frames\n\nReturn a dict mapping each thread's thread id to its current stack frame.\n\nThis function should be used for specialized purposes only.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__current_frames_impl(PyObject *module)\n/*[clinic end generated code: output=d2a41ac0a0a3809a input=2a9049c5f5033691]*/\n{\n    return _PyThread_CurrentFrames();\n}\n\n/*[clinic input]\nsys._current_exceptions\n\nReturn a dict mapping each thread's identifier to its current raised exception.\n\nThis function should be used for specialized purposes only.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__current_exceptions_impl(PyObject *module)\n/*[clinic end generated code: output=2ccfd838c746f0ba input=0e91818fbf2edc1f]*/\n{\n    return _PyThread_CurrentExceptions();\n}\n\n/*[clinic input]\nsys.call_tracing\n\n    func: object\n    args as funcargs: object(subclass_of='&PyTuple_Type')\n    /\n\nCall func(*args), while tracing is enabled.\n\nThe tracing state is saved, and restored afterwards.  This is intended\nto be called from a debugger from a checkpoint, to recursively debug\nsome other code.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_call_tracing_impl(PyObject *module, PyObject *func, PyObject *funcargs)\n/*[clinic end generated code: output=7e4999853cd4e5a6 input=5102e8b11049f92f]*/\n{\n    return _PyEval_CallTracing(func, funcargs);\n}\n\n/*[clinic input]\nsys._debugmallocstats\n\nPrint summary info to stderr about the state of pymalloc's structures.\n\nIn Py_DEBUG mode, also perform some expensive internal consistency\nchecks.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__debugmallocstats_impl(PyObject *module)\n/*[clinic end generated code: output=ec3565f8c7cee46a input=33c0c9c416f98424]*/\n{\n#ifdef WITH_PYMALLOC\n    if (_PyObject_DebugMallocStats(stderr)) {\n        fputc('\\n', stderr);\n    }\n#endif\n    _PyObject_DebugTypeStats(stderr);\n\n    Py_RETURN_NONE;\n}\n\n#ifdef Py_TRACE_REFS\n/* Defined in objects.c because it uses static globals in that file */\nextern PyObject *_Py_GetObjects(PyObject *, PyObject *);\n#endif\n\n\n/*[clinic input]\nsys._clear_type_cache\n\nClear the internal type lookup cache.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__clear_type_cache_impl(PyObject *module)\n/*[clinic end generated code: output=20e48ca54a6f6971 input=127f3e04a8d9b555]*/\n{\n    PyType_ClearCache();\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nsys._clear_internal_caches\n\nClear all internal performance-related caches.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__clear_internal_caches_impl(PyObject *module)\n/*[clinic end generated code: output=0ee128670a4966d6 input=253e741ca744f6e8]*/\n{\n#ifdef _Py_TIER2\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    _Py_Executors_InvalidateAll(interp, 0);\n#endif\n    PyType_ClearCache();\n    Py_RETURN_NONE;\n}\n\n/* Note that, for now, we do not have a per-interpreter equivalent\n  for sys.is_finalizing(). */\n\n/*[clinic input]\nsys.is_finalizing\n\nReturn True if Python is exiting.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_is_finalizing_impl(PyObject *module)\n/*[clinic end generated code: output=735b5ff7962ab281 input=f0df747a039948a5]*/\n{\n    return PyBool_FromLong(Py_IsFinalizing());\n}\n\n\n#ifdef Py_STATS\n/*[clinic input]\nsys._stats_on\n\nTurns on stats gathering (stats gathering is off by default).\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__stats_on_impl(PyObject *module)\n/*[clinic end generated code: output=aca53eafcbb4d9fe input=43b5bfe145299e55]*/\n{\n    _Py_StatsOn();\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nsys._stats_off\n\nTurns off stats gathering (stats gathering is off by default).\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__stats_off_impl(PyObject *module)\n/*[clinic end generated code: output=1534c1ee63812214 input=d1a84c60c56cbce2]*/\n{\n    _Py_StatsOff();\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nsys._stats_clear\n\nClears the stats.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__stats_clear_impl(PyObject *module)\n/*[clinic end generated code: output=fb65a2525ee50604 input=3e03f2654f44da96]*/\n{\n    _Py_StatsClear();\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nsys._stats_dump -> bool\n\nDump stats to file, and clears the stats.\n\nReturn False if no statistics were not dumped because stats gathering was off.\n[clinic start generated code]*/\n\nstatic int\nsys__stats_dump_impl(PyObject *module)\n/*[clinic end generated code: output=6e346b4ba0de4489 input=31a489e39418b2a5]*/\n{\n    int res = _Py_PrintSpecializationStats(1);\n    _Py_StatsClear();\n    return res;\n}\n#endif   // Py_STATS\n\n\n#ifdef ANDROID_API_LEVEL\n/*[clinic input]\nsys.getandroidapilevel\n\nReturn the build time API version of Android as an integer.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_getandroidapilevel_impl(PyObject *module)\n/*[clinic end generated code: output=214abf183a1c70c1 input=3e6d6c9fcdd24ac6]*/\n{\n    return PyLong_FromLong(ANDROID_API_LEVEL);\n}\n#endif   /* ANDROID_API_LEVEL */\n\n/*[clinic input]\nsys.activate_stack_trampoline\n\n    backend: str\n    /\n\nActivate stack profiler trampoline *backend*.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_activate_stack_trampoline_impl(PyObject *module, const char *backend)\n/*[clinic end generated code: output=5783cdeb51874b43 input=a12df928758a82b4]*/\n{\n#ifdef PY_HAVE_PERF_TRAMPOLINE\n    if (strcmp(backend, \"perf\") == 0) {\n        _PyPerf_Callbacks cur_cb;\n        _PyPerfTrampoline_GetCallbacks(&cur_cb);\n        if (cur_cb.write_state != _Py_perfmap_callbacks.write_state) {\n            if (_PyPerfTrampoline_SetCallbacks(&_Py_perfmap_callbacks) < 0 ) {\n                PyErr_SetString(PyExc_ValueError, \"can't activate perf trampoline\");\n                return NULL;\n            }\n        }\n        else if (strcmp(backend, \"perf_jit\") == 0) {\n            _PyPerf_Callbacks cur_cb;\n            _PyPerfTrampoline_GetCallbacks(&cur_cb);\n            if (cur_cb.write_state != _Py_perfmap_jit_callbacks.write_state) {\n                if (_PyPerfTrampoline_SetCallbacks(&_Py_perfmap_jit_callbacks) < 0 ) {\n                    PyErr_SetString(PyExc_ValueError, \"can't activate perf jit trampoline\");\n                    return NULL;\n                }\n            }\n        }\n    }\n    else {\n        PyErr_Format(PyExc_ValueError, \"invalid backend: %s\", backend);\n        return NULL;\n    }\n    if (_PyPerfTrampoline_Init(1) < 0) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n#else\n    PyErr_SetString(PyExc_ValueError, \"perf trampoline not available\");\n    return NULL;\n#endif\n}\n\n\n/*[clinic input]\nsys.deactivate_stack_trampoline\n\nDeactivate the current stack profiler trampoline backend.\n\nIf no stack profiler is activated, this function has no effect.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_deactivate_stack_trampoline_impl(PyObject *module)\n/*[clinic end generated code: output=b50da25465df0ef1 input=9f629a6be9fe7fc8]*/\n{\n    if  (_PyPerfTrampoline_Init(0) < 0) {\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nsys.is_stack_trampoline_active\n\nReturn *True* if a stack profiler trampoline is active.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys_is_stack_trampoline_active_impl(PyObject *module)\n/*[clinic end generated code: output=ab2746de0ad9d293 input=29616b7bf6a0b703]*/\n{\n#ifdef PY_HAVE_PERF_TRAMPOLINE\n    if (_PyIsPerfTrampolineActive()) {\n        Py_RETURN_TRUE;\n    }\n#endif\n    Py_RETURN_FALSE;\n}\n\n\n/*[clinic input]\nsys._getframemodulename\n\n    depth: int = 0\n\nReturn the name of the module for a calling frame.\n\nThe default depth returns the module containing the call to this API.\nA more typical use in a library will pass a depth of 1 to get the user's\nmodule rather than the library module.\n\nIf no frame, module, or name can be found, returns None.\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__getframemodulename_impl(PyObject *module, int depth)\n/*[clinic end generated code: output=1d70ef691f09d2db input=d4f1a8ed43b8fb46]*/\n{\n    if (PySys_Audit(\"sys._getframemodulename\", \"i\", depth) < 0) {\n        return NULL;\n    }\n    _PyInterpreterFrame *f = _PyThreadState_GET()->current_frame;\n    while (f && (_PyFrame_IsIncomplete(f) || depth-- > 0)) {\n        f = f->previous;\n    }\n    if (f == NULL || f->f_funcobj == NULL) {\n        Py_RETURN_NONE;\n    }\n    PyObject *r = PyFunction_GetModule(f->f_funcobj);\n    if (!r) {\n        PyErr_Clear();\n        r = Py_None;\n    }\n    return Py_NewRef(r);\n}\n\n/*[clinic input]\nsys._get_cpu_count_config -> int\n\nPrivate function for getting PyConfig.cpu_count\n[clinic start generated code]*/\n\nstatic int\nsys__get_cpu_count_config_impl(PyObject *module)\n/*[clinic end generated code: output=36611bb5efad16dc input=523e1ade2204084e]*/\n{\n    const PyConfig *config = _Py_GetConfig();\n    return config->cpu_count;\n}\n\n/*[clinic input]\nsys._baserepl\n\nPrivate function for getting the base REPL\n[clinic start generated code]*/\n\nstatic PyObject *\nsys__baserepl_impl(PyObject *module)\n/*[clinic end generated code: output=f19a36375ebe0a45 input=ade0ebb9fab56f3c]*/\n{\n    PyCompilerFlags cf = _PyCompilerFlags_INIT;\n    PyRun_AnyFileExFlags(stdin, \"<stdin>\", 0, &cf);\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\nsys._is_gil_enabled -> bool\n\nReturn True if the GIL is currently enabled and False otherwise.\n[clinic start generated code]*/\n\nstatic int\nsys__is_gil_enabled_impl(PyObject *module)\n/*[clinic end generated code: output=57732cf53f5b9120 input=7e9c47f15a00e809]*/\n{\n#ifdef Py_GIL_DISABLED\n    return _PyEval_IsGILEnabled(_PyThreadState_GET());\n#else\n    return 1;\n#endif\n}\n\n\nstatic PerfMapState perf_map_state;\n\nPyAPI_FUNC(int) PyUnstable_PerfMapState_Init(void) {\n#ifndef MS_WINDOWS\n    char filename[100];\n    pid_t pid = getpid();\n    // Use nofollow flag to prevent symlink attacks.\n    int flags = O_WRONLY | O_CREAT | O_APPEND | O_NOFOLLOW;\n#ifdef O_CLOEXEC\n    flags |= O_CLOEXEC;\n#endif\n    snprintf(filename, sizeof(filename) - 1, \"/tmp/perf-%jd.map\",\n                (intmax_t)pid);\n    int fd = open(filename, flags, 0600);\n    if (fd == -1) {\n        return -1;\n    }\n    else{\n        perf_map_state.perf_map = fdopen(fd, \"a\");\n        if (perf_map_state.perf_map == NULL) {\n            close(fd);\n            return -1;\n        }\n    }\n    perf_map_state.map_lock = PyThread_allocate_lock();\n    if (perf_map_state.map_lock == NULL) {\n        fclose(perf_map_state.perf_map);\n        return -2;\n    }\n#endif\n    return 0;\n}\n\nPyAPI_FUNC(int) PyUnstable_WritePerfMapEntry(\n    const void *code_addr,\n    unsigned int code_size,\n    const char *entry_name\n) {\n#ifndef MS_WINDOWS\n    if (perf_map_state.perf_map == NULL) {\n        int ret = PyUnstable_PerfMapState_Init();\n        if (ret != 0){\n            return ret;\n        }\n    }\n    PyThread_acquire_lock(perf_map_state.map_lock, 1);\n    fprintf(perf_map_state.perf_map, \"%\" PRIxPTR \" %x %s\\n\", (uintptr_t) code_addr, code_size, entry_name);\n    fflush(perf_map_state.perf_map);\n    PyThread_release_lock(perf_map_state.map_lock);\n#endif\n    return 0;\n}\n\nPyAPI_FUNC(void) PyUnstable_PerfMapState_Fini(void) {\n#ifndef MS_WINDOWS\n    if (perf_map_state.perf_map != NULL) {\n        // close the file\n        PyThread_acquire_lock(perf_map_state.map_lock, 1);\n        fclose(perf_map_state.perf_map);\n        PyThread_release_lock(perf_map_state.map_lock);\n\n        // clean up the lock and state\n        PyThread_free_lock(perf_map_state.map_lock);\n        perf_map_state.perf_map = NULL;\n    }\n#endif\n}\n\nPyAPI_FUNC(int) PyUnstable_CopyPerfMapFile(const char* parent_filename) {\n#ifndef MS_WINDOWS\n    FILE* from = fopen(parent_filename, \"r\");\n    if (!from) {\n        return -1;\n    }\n    if (perf_map_state.perf_map == NULL) {\n        int ret = PyUnstable_PerfMapState_Init();\n        if (ret != 0) {\n            return ret;\n        }\n    }\n    char buf[4096];\n    PyThread_acquire_lock(perf_map_state.map_lock, 1);\n    int fflush_result = 0, result = 0;\n    while (1) {\n        size_t bytes_read = fread(buf, 1, sizeof(buf), from);\n        size_t bytes_written = fwrite(buf, 1, bytes_read, perf_map_state.perf_map);\n        fflush_result = fflush(perf_map_state.perf_map);\n        if (fflush_result != 0 || bytes_read == 0 || bytes_written < bytes_read) {\n            result = -1;\n            goto close_and_release;\n        }\n        if (bytes_read < sizeof(buf) && feof(from)) {\n            goto close_and_release;\n        }\n    }\nclose_and_release:\n    fclose(from);\n    PyThread_release_lock(perf_map_state.map_lock);\n    return result;\n#endif\n    return 0;\n}\n\n\nstatic PyMethodDef sys_methods[] = {\n    /* Might as well keep this in alphabetic order */\n    SYS_ADDAUDITHOOK_METHODDEF\n    {\"audit\", _PyCFunction_CAST(sys_audit), METH_FASTCALL, audit_doc },\n    {\"breakpointhook\", _PyCFunction_CAST(sys_breakpointhook),\n     METH_FASTCALL | METH_KEYWORDS, breakpointhook_doc},\n    SYS__CLEAR_INTERNAL_CACHES_METHODDEF\n    SYS__CLEAR_TYPE_CACHE_METHODDEF\n    SYS__CURRENT_FRAMES_METHODDEF\n    SYS__CURRENT_EXCEPTIONS_METHODDEF\n    SYS_DISPLAYHOOK_METHODDEF\n    SYS_EXCEPTION_METHODDEF\n    SYS_EXC_INFO_METHODDEF\n    SYS_EXCEPTHOOK_METHODDEF\n    SYS_EXIT_METHODDEF\n    SYS_GETDEFAULTENCODING_METHODDEF\n    SYS_GETDLOPENFLAGS_METHODDEF\n    SYS_GETALLOCATEDBLOCKS_METHODDEF\n    SYS_GETUNICODEINTERNEDSIZE_METHODDEF\n    SYS_GETFILESYSTEMENCODING_METHODDEF\n    SYS_GETFILESYSTEMENCODEERRORS_METHODDEF\n#ifdef Py_TRACE_REFS\n    {\"getobjects\", _Py_GetObjects, METH_VARARGS},\n#endif\n    SYS_GETTOTALREFCOUNT_METHODDEF\n    SYS_GETREFCOUNT_METHODDEF\n    SYS_GETRECURSIONLIMIT_METHODDEF\n    {\"getsizeof\", _PyCFunction_CAST(sys_getsizeof),\n     METH_VARARGS | METH_KEYWORDS, getsizeof_doc},\n    SYS__GETFRAME_METHODDEF\n    SYS__GETFRAMEMODULENAME_METHODDEF\n    SYS_GETWINDOWSVERSION_METHODDEF\n    SYS__ENABLELEGACYWINDOWSFSENCODING_METHODDEF\n    SYS_INTERN_METHODDEF\n    SYS__IS_INTERNED_METHODDEF\n    SYS_IS_FINALIZING_METHODDEF\n    SYS_MDEBUG_METHODDEF\n    SYS_SETSWITCHINTERVAL_METHODDEF\n    SYS_GETSWITCHINTERVAL_METHODDEF\n    SYS_SETDLOPENFLAGS_METHODDEF\n    SYS_SETPROFILE_METHODDEF\n    SYS__SETPROFILEALLTHREADS_METHODDEF\n    SYS_GETPROFILE_METHODDEF\n    SYS_SETRECURSIONLIMIT_METHODDEF\n    SYS_SETTRACE_METHODDEF\n    SYS__SETTRACEALLTHREADS_METHODDEF\n    SYS_GETTRACE_METHODDEF\n    SYS_CALL_TRACING_METHODDEF\n    SYS__DEBUGMALLOCSTATS_METHODDEF\n    SYS_SET_COROUTINE_ORIGIN_TRACKING_DEPTH_METHODDEF\n    SYS_GET_COROUTINE_ORIGIN_TRACKING_DEPTH_METHODDEF\n    {\"set_asyncgen_hooks\", _PyCFunction_CAST(sys_set_asyncgen_hooks),\n     METH_VARARGS | METH_KEYWORDS, set_asyncgen_hooks_doc},\n    SYS_GET_ASYNCGEN_HOOKS_METHODDEF\n    SYS_GETANDROIDAPILEVEL_METHODDEF\n    SYS_ACTIVATE_STACK_TRAMPOLINE_METHODDEF\n    SYS_DEACTIVATE_STACK_TRAMPOLINE_METHODDEF\n    SYS_IS_STACK_TRAMPOLINE_ACTIVE_METHODDEF\n    SYS_UNRAISABLEHOOK_METHODDEF\n    SYS_GET_INT_MAX_STR_DIGITS_METHODDEF\n    SYS_SET_INT_MAX_STR_DIGITS_METHODDEF\n    SYS__BASEREPL_METHODDEF\n#ifdef Py_STATS\n    SYS__STATS_ON_METHODDEF\n    SYS__STATS_OFF_METHODDEF\n    SYS__STATS_CLEAR_METHODDEF\n    SYS__STATS_DUMP_METHODDEF\n#endif\n    SYS__GET_CPU_COUNT_CONFIG_METHODDEF\n    SYS__IS_GIL_ENABLED_METHODDEF\n    {NULL, NULL}  // sentinel\n};\n\n\nstatic PyObject *\nlist_builtin_module_names(void)\n{\n    PyObject *list = _PyImport_GetBuiltinModuleNames();\n    if (list == NULL) {\n        return NULL;\n    }\n    if (PyList_Sort(list) != 0) {\n        goto error;\n    }\n    PyObject *tuple = PyList_AsTuple(list);\n    Py_DECREF(list);\n    return tuple;\n\nerror:\n    Py_DECREF(list);\n    return NULL;\n}\n\n\nstatic PyObject *\nlist_stdlib_module_names(void)\n{\n    Py_ssize_t len = Py_ARRAY_LENGTH(_Py_stdlib_module_names);\n    PyObject *names = PyTuple_New(len);\n    if (names == NULL) {\n        return NULL;\n    }\n\n    for (Py_ssize_t i = 0; i < len; i++) {\n        PyObject *name = PyUnicode_FromString(_Py_stdlib_module_names[i]);\n        if (name == NULL) {\n            Py_DECREF(names);\n            return NULL;\n        }\n        PyTuple_SET_ITEM(names, i, name);\n    }\n\n    PyObject *set = PyObject_CallFunction((PyObject *)&PyFrozenSet_Type,\n                                          \"(O)\", names);\n    Py_DECREF(names);\n    return set;\n}\n\n\n/* Pre-initialization support for sys.warnoptions and sys._xoptions\n *\n * Modern internal code paths:\n *   These APIs get called after _Py_InitializeCore and get to use the\n *   regular CPython list, dict, and unicode APIs.\n *\n * Legacy embedding code paths:\n *   The multi-phase initialization API isn't public yet, so embedding\n *   apps still need to be able configure sys.warnoptions and sys._xoptions\n *   before they call Py_Initialize. To support this, we stash copies of\n *   the supplied wchar * sequences in linked lists, and then migrate the\n *   contents of those lists to the sys module in _PyInitializeCore.\n *\n */\n\nstruct _preinit_entry {\n    wchar_t *value;\n    struct _preinit_entry *next;\n};\n\ntypedef struct _preinit_entry *_Py_PreInitEntry;\n\nstatic _Py_PreInitEntry _preinit_warnoptions = NULL;\nstatic _Py_PreInitEntry _preinit_xoptions = NULL;\n\nstatic _Py_PreInitEntry\n_alloc_preinit_entry(const wchar_t *value)\n{\n    /* To get this to work, we have to initialize the runtime implicitly */\n    _PyRuntime_Initialize();\n\n    /* Force default allocator, so we can ensure that it also gets used to\n     * destroy the linked list in _clear_preinit_entries.\n     */\n    PyMemAllocatorEx old_alloc;\n    _PyMem_SetDefaultAllocator(PYMEM_DOMAIN_RAW, &old_alloc);\n\n    _Py_PreInitEntry node = PyMem_RawCalloc(1, sizeof(*node));\n    if (node != NULL) {\n        node->value = _PyMem_RawWcsdup(value);\n        if (node->value == NULL) {\n            PyMem_RawFree(node);\n            node = NULL;\n        };\n    };\n\n    PyMem_SetAllocator(PYMEM_DOMAIN_RAW, &old_alloc);\n    return node;\n}\n\nstatic int\n_append_preinit_entry(_Py_PreInitEntry *optionlist, const wchar_t *value)\n{\n    _Py_PreInitEntry new_entry = _alloc_preinit_entry(value);\n    if (new_entry == NULL) {\n        return -1;\n    }\n    /* We maintain the linked list in this order so it's easy to play back\n     * the add commands in the same order later on in _Py_InitializeCore\n     */\n    _Py_PreInitEntry last_entry = *optionlist;\n    if (last_entry == NULL) {\n        *optionlist = new_entry;\n    } else {\n        while (last_entry->next != NULL) {\n            last_entry = last_entry->next;\n        }\n        last_entry->next = new_entry;\n    }\n    return 0;\n}\n\nstatic void\n_clear_preinit_entries(_Py_PreInitEntry *optionlist)\n{\n    _Py_PreInitEntry current = *optionlist;\n    *optionlist = NULL;\n    /* Deallocate the nodes and their contents using the default allocator */\n    PyMemAllocatorEx old_alloc;\n    _PyMem_SetDefaultAllocator(PYMEM_DOMAIN_RAW, &old_alloc);\n    while (current != NULL) {\n        _Py_PreInitEntry next = current->next;\n        PyMem_RawFree(current->value);\n        PyMem_RawFree(current);\n        current = next;\n    }\n    PyMem_SetAllocator(PYMEM_DOMAIN_RAW, &old_alloc);\n}\n\n\nPyStatus\n_PySys_ReadPreinitWarnOptions(PyWideStringList *options)\n{\n    PyStatus status;\n    _Py_PreInitEntry entry;\n\n    for (entry = _preinit_warnoptions; entry != NULL; entry = entry->next) {\n        status = PyWideStringList_Append(options, entry->value);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    _clear_preinit_entries(&_preinit_warnoptions);\n    return _PyStatus_OK();\n}\n\n\nPyStatus\n_PySys_ReadPreinitXOptions(PyConfig *config)\n{\n    PyStatus status;\n    _Py_PreInitEntry entry;\n\n    for (entry = _preinit_xoptions; entry != NULL; entry = entry->next) {\n        status = PyWideStringList_Append(&config->xoptions, entry->value);\n        if (_PyStatus_EXCEPTION(status)) {\n            return status;\n        }\n    }\n\n    _clear_preinit_entries(&_preinit_xoptions);\n    return _PyStatus_OK();\n}\n\n\nstatic PyObject *\nget_warnoptions(PyThreadState *tstate)\n{\n    PyObject *warnoptions = _PySys_GetAttr(tstate, &_Py_ID(warnoptions));\n    if (warnoptions == NULL || !PyList_Check(warnoptions)) {\n        /* PEP432 TODO: we can reach this if warnoptions is NULL in the main\n        *  interpreter config. When that happens, we need to properly set\n         * the `warnoptions` reference in the main interpreter config as well.\n         *\n         * For Python 3.7, we shouldn't be able to get here due to the\n         * combination of how _PyMainInterpreter_ReadConfig and _PySys_EndInit\n         * work, but we expect 3.8+ to make the _PyMainInterpreter_ReadConfig\n         * call optional for embedding applications, thus making this\n         * reachable again.\n         */\n        warnoptions = PyList_New(0);\n        if (warnoptions == NULL) {\n            return NULL;\n        }\n        if (sys_set_object(tstate->interp, &_Py_ID(warnoptions), warnoptions)) {\n            Py_DECREF(warnoptions);\n            return NULL;\n        }\n        Py_DECREF(warnoptions);\n    }\n    return warnoptions;\n}\n\nvoid\nPySys_ResetWarnOptions(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (tstate == NULL) {\n        _clear_preinit_entries(&_preinit_warnoptions);\n        return;\n    }\n\n    PyObject *warnoptions = _PySys_GetAttr(tstate, &_Py_ID(warnoptions));\n    if (warnoptions == NULL || !PyList_Check(warnoptions))\n        return;\n    PyList_SetSlice(warnoptions, 0, PyList_GET_SIZE(warnoptions), NULL);\n}\n\nstatic int\n_PySys_AddWarnOptionWithError(PyThreadState *tstate, PyObject *option)\n{\n    PyObject *warnoptions = get_warnoptions(tstate);\n    if (warnoptions == NULL) {\n        return -1;\n    }\n    if (PyList_Append(warnoptions, option)) {\n        return -1;\n    }\n    return 0;\n}\n\n// Removed in Python 3.13 API, but kept for the stable ABI\nPyAPI_FUNC(void)\nPySys_AddWarnOptionUnicode(PyObject *option)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (_PySys_AddWarnOptionWithError(tstate, option) < 0) {\n        /* No return value, therefore clear error state if possible */\n        if (tstate) {\n            _PyErr_Clear(tstate);\n        }\n    }\n}\n\n// Removed in Python 3.13 API, but kept for the stable ABI\nPyAPI_FUNC(void)\nPySys_AddWarnOption(const wchar_t *s)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (tstate == NULL) {\n        _append_preinit_entry(&_preinit_warnoptions, s);\n        return;\n    }\n    PyObject *unicode;\n    unicode = PyUnicode_FromWideChar(s, -1);\n    if (unicode == NULL)\n        return;\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n    PySys_AddWarnOptionUnicode(unicode);\n_Py_COMP_DIAG_POP\n    Py_DECREF(unicode);\n}\n\n// Removed in Python 3.13 API, but kept for the stable ABI\nPyAPI_FUNC(int)\nPySys_HasWarnOptions(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    PyObject *warnoptions = _PySys_GetAttr(tstate, &_Py_ID(warnoptions));\n    return (warnoptions != NULL && PyList_Check(warnoptions)\n            && PyList_GET_SIZE(warnoptions) > 0);\n}\n\nstatic PyObject *\nget_xoptions(PyThreadState *tstate)\n{\n    PyObject *xoptions = _PySys_GetAttr(tstate, &_Py_ID(_xoptions));\n    if (xoptions == NULL || !PyDict_Check(xoptions)) {\n        /* PEP432 TODO: we can reach this if xoptions is NULL in the main\n        *  interpreter config. When that happens, we need to properly set\n         * the `xoptions` reference in the main interpreter config as well.\n         *\n         * For Python 3.7, we shouldn't be able to get here due to the\n         * combination of how _PyMainInterpreter_ReadConfig and _PySys_EndInit\n         * work, but we expect 3.8+ to make the _PyMainInterpreter_ReadConfig\n         * call optional for embedding applications, thus making this\n         * reachable again.\n         */\n        xoptions = PyDict_New();\n        if (xoptions == NULL) {\n            return NULL;\n        }\n        if (sys_set_object(tstate->interp, &_Py_ID(_xoptions), xoptions)) {\n            Py_DECREF(xoptions);\n            return NULL;\n        }\n        Py_DECREF(xoptions);\n    }\n    return xoptions;\n}\n\nstatic int\n_PySys_AddXOptionWithError(const wchar_t *s)\n{\n    PyObject *name = NULL, *value = NULL;\n\n    PyThreadState *tstate = _PyThreadState_GET();\n    PyObject *opts = get_xoptions(tstate);\n    if (opts == NULL) {\n        goto error;\n    }\n\n    const wchar_t *name_end = wcschr(s, L'=');\n    if (!name_end) {\n        name = PyUnicode_FromWideChar(s, -1);\n        if (name == NULL) {\n            goto error;\n        }\n        value = Py_NewRef(Py_True);\n    }\n    else {\n        name = PyUnicode_FromWideChar(s, name_end - s);\n        if (name == NULL) {\n            goto error;\n        }\n        value = PyUnicode_FromWideChar(name_end + 1, -1);\n        if (value == NULL) {\n            goto error;\n        }\n    }\n    if (PyDict_SetItem(opts, name, value) < 0) {\n        goto error;\n    }\n    Py_DECREF(name);\n    Py_DECREF(value);\n    return 0;\n\nerror:\n    Py_XDECREF(name);\n    Py_XDECREF(value);\n    return -1;\n}\n\n// Removed in Python 3.13 API, but kept for the stable ABI\nPyAPI_FUNC(void)\nPySys_AddXOption(const wchar_t *s)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    if (tstate == NULL) {\n        _append_preinit_entry(&_preinit_xoptions, s);\n        return;\n    }\n    if (_PySys_AddXOptionWithError(s) < 0) {\n        /* No return value, therefore clear error state if possible */\n        _PyErr_Clear(tstate);\n    }\n}\n\nPyObject *\nPySys_GetXOptions(void)\n{\n    PyThreadState *tstate = _PyThreadState_GET();\n    return get_xoptions(tstate);\n}\n\n/* XXX This doc string is too long to be a single string literal in VC++ 5.0.\n   Two literals concatenated works just fine.  If you have a K&R compiler\n   or other abomination that however *does* understand longer strings,\n   get rid of the !!! comment in the middle and the quotes that surround it. */\nPyDoc_VAR(sys_doc) =\nPyDoc_STR(\n\"This module provides access to some objects used or maintained by the\\n\\\ninterpreter and to functions that interact strongly with the interpreter.\\n\\\n\\n\\\nDynamic objects:\\n\\\n\\n\\\nargv -- command line arguments; argv[0] is the script pathname if known\\n\\\npath -- module search path; path[0] is the script directory, else ''\\n\\\nmodules -- dictionary of loaded modules\\n\\\n\\n\\\ndisplayhook -- called to show results in an interactive session\\n\\\nexcepthook -- called to handle any uncaught exception other than SystemExit\\n\\\n  To customize printing in an interactive session or to install a custom\\n\\\n  top-level exception handler, assign other functions to replace these.\\n\\\n\\n\\\nstdin -- standard input file object; used by input()\\n\\\nstdout -- standard output file object; used by print()\\n\\\nstderr -- standard error object; used for error messages\\n\\\n  By assigning other file objects (or objects that behave like files)\\n\\\n  to these, it is possible to redirect all of the interpreter's I/O.\\n\\\n\\n\\\nlast_exc - the last uncaught exception\\n\\\n  Only available in an interactive session after a\\n\\\n  traceback has been printed.\\n\\\nlast_type -- type of last uncaught exception\\n\\\nlast_value -- value of last uncaught exception\\n\\\nlast_traceback -- traceback of last uncaught exception\\n\\\n  These three are the (deprecated) legacy representation of last_exc.\\n\\\n\"\n)\n/* concatenating string here */\nPyDoc_STR(\n\"\\n\\\nStatic objects:\\n\\\n\\n\\\nbuiltin_module_names -- tuple of module names built into this interpreter\\n\\\ncopyright -- copyright notice pertaining to this interpreter\\n\\\nexec_prefix -- prefix used to find the machine-specific Python library\\n\\\nexecutable -- absolute path of the executable binary of the Python interpreter\\n\\\nfloat_info -- a named tuple with information about the float implementation.\\n\\\nfloat_repr_style -- string indicating the style of repr() output for floats\\n\\\nhash_info -- a named tuple with information about the hash algorithm.\\n\\\nhexversion -- version information encoded as a single integer\\n\\\nimplementation -- Python implementation information.\\n\\\nint_info -- a named tuple with information about the int implementation.\\n\\\nmaxsize -- the largest supported length of containers.\\n\\\nmaxunicode -- the value of the largest Unicode code point\\n\\\nplatform -- platform identifier\\n\\\nprefix -- prefix used to find the Python library\\n\\\nthread_info -- a named tuple with information about the thread implementation.\\n\\\nversion -- the version of this interpreter as a string\\n\\\nversion_info -- version information as a named tuple\\n\\\n\"\n)\n#ifdef MS_COREDLL\n/* concatenating string here */\nPyDoc_STR(\n\"dllhandle -- [Windows only] integer handle of the Python DLL\\n\\\nwinver -- [Windows only] version number of the Python DLL\\n\\\n\"\n)\n#endif /* MS_COREDLL */\n#ifdef MS_WINDOWS\n/* concatenating string here */\nPyDoc_STR(\n\"_enablelegacywindowsfsencoding -- [Windows only]\\n\\\n\"\n)\n#endif\nPyDoc_STR(\n\"__stdin__ -- the original stdin; don't touch!\\n\\\n__stdout__ -- the original stdout; don't touch!\\n\\\n__stderr__ -- the original stderr; don't touch!\\n\\\n__displayhook__ -- the original displayhook; don't touch!\\n\\\n__excepthook__ -- the original excepthook; don't touch!\\n\\\n\\n\\\nFunctions:\\n\\\n\\n\\\ndisplayhook() -- print an object to the screen, and save it in builtins._\\n\\\nexcepthook() -- print an exception and its traceback to sys.stderr\\n\\\nexception() -- return the current thread's active exception\\n\\\nexc_info() -- return information about the current thread's active exception\\n\\\nexit() -- exit the interpreter by raising SystemExit\\n\\\ngetdlopenflags() -- returns flags to be used for dlopen() calls\\n\\\ngetprofile() -- get the global profiling function\\n\\\ngetrefcount() -- return the reference count for an object (plus one :-)\\n\\\ngetrecursionlimit() -- return the max recursion depth for the interpreter\\n\\\ngetsizeof() -- return the size of an object in bytes\\n\\\ngettrace() -- get the global debug tracing function\\n\\\nsetdlopenflags() -- set the flags to be used for dlopen() calls\\n\\\nsetprofile() -- set the global profiling function\\n\\\nsetrecursionlimit() -- set the max recursion depth for the interpreter\\n\\\nsettrace() -- set the global debug tracing function\\n\\\n\"\n)\n/* end of sys_doc */ ;\n\n\nPyDoc_STRVAR(flags__doc__,\n\"sys.flags\\n\\\n\\n\\\nFlags provided through command line arguments or environment vars.\");\n\nstatic PyTypeObject FlagsType;\n\nstatic PyStructSequence_Field flags_fields[] = {\n    {\"debug\",                   \"-d\"},\n    {\"inspect\",                 \"-i\"},\n    {\"interactive\",             \"-i\"},\n    {\"optimize\",                \"-O or -OO\"},\n    {\"dont_write_bytecode\",     \"-B\"},\n    {\"no_user_site\",            \"-s\"},\n    {\"no_site\",                 \"-S\"},\n    {\"ignore_environment\",      \"-E\"},\n    {\"verbose\",                 \"-v\"},\n    {\"bytes_warning\",           \"-b\"},\n    {\"quiet\",                   \"-q\"},\n    {\"hash_randomization\",      \"-R\"},\n    {\"isolated\",                \"-I\"},\n    {\"dev_mode\",                \"-X dev\"},\n    {\"utf8_mode\",               \"-X utf8\"},\n    {\"warn_default_encoding\",   \"-X warn_default_encoding\"},\n    {\"safe_path\", \"-P\"},\n    {\"int_max_str_digits\",      \"-X int_max_str_digits\"},\n    {\"gil\",                     \"-X gil\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc flags_desc = {\n    \"sys.flags\",        /* name */\n    flags__doc__,       /* doc */\n    flags_fields,       /* fields */\n    18\n};\n\nstatic int\nset_flags_from_config(PyInterpreterState *interp, PyObject *flags)\n{\n    const PyPreConfig *preconfig = &interp->runtime->preconfig;\n    const PyConfig *config = _PyInterpreterState_GetConfig(interp);\n\n    // _PySys_UpdateConfig() modifies sys.flags in-place:\n    // Py_XDECREF() is needed in this case.\n    Py_ssize_t pos = 0;\n#define SetFlagObj(expr) \\\n    do { \\\n        PyObject *value = (expr); \\\n        if (value == NULL) { \\\n            return -1; \\\n        } \\\n        Py_XDECREF(PyStructSequence_GET_ITEM(flags, pos)); \\\n        PyStructSequence_SET_ITEM(flags, pos, value); \\\n        pos++; \\\n    } while (0)\n#define SetFlag(expr) SetFlagObj(PyLong_FromLong(expr))\n\n    SetFlag(config->parser_debug);\n    SetFlag(config->inspect);\n    SetFlag(config->interactive);\n    SetFlag(config->optimization_level);\n    SetFlag(!config->write_bytecode);\n    SetFlag(!config->user_site_directory);\n    SetFlag(!config->site_import);\n    SetFlag(!config->use_environment);\n    SetFlag(config->verbose);\n    SetFlag(config->bytes_warning);\n    SetFlag(config->quiet);\n    SetFlag(config->use_hash_seed == 0 || config->hash_seed != 0);\n    SetFlag(config->isolated);\n    SetFlagObj(PyBool_FromLong(config->dev_mode));\n    SetFlag(preconfig->utf8_mode);\n    SetFlag(config->warn_default_encoding);\n    SetFlagObj(PyBool_FromLong(config->safe_path));\n    SetFlag(config->int_max_str_digits);\n#ifdef Py_GIL_DISABLED\n    if (config->enable_gil == _PyConfig_GIL_DEFAULT) {\n        SetFlagObj(Py_NewRef(Py_None));\n    }\n    else {\n        SetFlag(config->enable_gil);\n    }\n#else\n    SetFlagObj(PyLong_FromLong(1));\n#endif\n#undef SetFlagObj\n#undef SetFlag\n    return 0;\n}\n\n\nstatic PyObject*\nmake_flags(PyInterpreterState *interp)\n{\n    PyObject *flags = PyStructSequence_New(&FlagsType);\n    if (flags == NULL) {\n        return NULL;\n    }\n\n    if (set_flags_from_config(interp, flags) < 0) {\n        Py_DECREF(flags);\n        return NULL;\n    }\n    return flags;\n}\n\n\nPyDoc_STRVAR(version_info__doc__,\n\"sys.version_info\\n\\\n\\n\\\nVersion information as a named tuple.\");\n\nstatic PyTypeObject VersionInfoType;\n\nstatic PyStructSequence_Field version_info_fields[] = {\n    {\"major\", \"Major release number\"},\n    {\"minor\", \"Minor release number\"},\n    {\"micro\", \"Patch release number\"},\n    {\"releaselevel\", \"'alpha', 'beta', 'candidate', or 'final'\"},\n    {\"serial\", \"Serial release number\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc version_info_desc = {\n    \"sys.version_info\",     /* name */\n    version_info__doc__,    /* doc */\n    version_info_fields,    /* fields */\n    5\n};\n\nstatic PyObject *\nmake_version_info(PyThreadState *tstate)\n{\n    PyObject *version_info;\n    char *s;\n    int pos = 0;\n\n    version_info = PyStructSequence_New(&VersionInfoType);\n    if (version_info == NULL) {\n        return NULL;\n    }\n\n    /*\n     * These release level checks are mutually exclusive and cover\n     * the field, so don't get too fancy with the pre-processor!\n     */\n#if PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_ALPHA\n    s = \"alpha\";\n#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_BETA\n    s = \"beta\";\n#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_GAMMA\n    s = \"candidate\";\n#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_FINAL\n    s = \"final\";\n#endif\n\n#define SetIntItem(flag) \\\n    PyStructSequence_SET_ITEM(version_info, pos++, PyLong_FromLong(flag))\n#define SetStrItem(flag) \\\n    PyStructSequence_SET_ITEM(version_info, pos++, PyUnicode_FromString(flag))\n\n    SetIntItem(PY_MAJOR_VERSION);\n    SetIntItem(PY_MINOR_VERSION);\n    SetIntItem(PY_MICRO_VERSION);\n    SetStrItem(s);\n    SetIntItem(PY_RELEASE_SERIAL);\n#undef SetIntItem\n#undef SetStrItem\n\n    if (_PyErr_Occurred(tstate)) {\n        Py_CLEAR(version_info);\n        return NULL;\n    }\n    return version_info;\n}\n\n/* sys.implementation values */\n#define NAME \"cpython\"\nconst char *_PySys_ImplName = NAME;\n#define MAJOR Py_STRINGIFY(PY_MAJOR_VERSION)\n#define MINOR Py_STRINGIFY(PY_MINOR_VERSION)\n#define TAG NAME \"-\" MAJOR MINOR\nconst char *_PySys_ImplCacheTag = TAG;\n#undef NAME\n#undef MAJOR\n#undef MINOR\n#undef TAG\n\nstatic PyObject *\nmake_impl_info(PyObject *version_info)\n{\n    int res;\n    PyObject *impl_info, *value, *ns;\n\n    impl_info = PyDict_New();\n    if (impl_info == NULL)\n        return NULL;\n\n    /* populate the dict */\n\n    value = PyUnicode_FromString(_PySys_ImplName);\n    if (value == NULL)\n        goto error;\n    res = PyDict_SetItemString(impl_info, \"name\", value);\n    Py_DECREF(value);\n    if (res < 0)\n        goto error;\n\n    value = PyUnicode_FromString(_PySys_ImplCacheTag);\n    if (value == NULL)\n        goto error;\n    res = PyDict_SetItemString(impl_info, \"cache_tag\", value);\n    Py_DECREF(value);\n    if (res < 0)\n        goto error;\n\n    res = PyDict_SetItemString(impl_info, \"version\", version_info);\n    if (res < 0)\n        goto error;\n\n    value = PyLong_FromLong(PY_VERSION_HEX);\n    if (value == NULL)\n        goto error;\n    res = PyDict_SetItemString(impl_info, \"hexversion\", value);\n    Py_DECREF(value);\n    if (res < 0)\n        goto error;\n\n#ifdef MULTIARCH\n    value = PyUnicode_FromString(MULTIARCH);\n    if (value == NULL)\n        goto error;\n    res = PyDict_SetItemString(impl_info, \"_multiarch\", value);\n    Py_DECREF(value);\n    if (res < 0)\n        goto error;\n#endif\n\n    /* dict ready */\n\n    ns = _PyNamespace_New(impl_info);\n    Py_DECREF(impl_info);\n    return ns;\n\nerror:\n    Py_CLEAR(impl_info);\n    return NULL;\n}\n\n#ifdef __EMSCRIPTEN__\n\nPyDoc_STRVAR(emscripten_info__doc__,\n\"sys._emscripten_info\\n\\\n\\n\\\nWebAssembly Emscripten platform information.\");\n\nstatic PyTypeObject *EmscriptenInfoType;\n\nstatic PyStructSequence_Field emscripten_info_fields[] = {\n    {\"emscripten_version\", \"Emscripten version (major, minor, micro)\"},\n    {\"runtime\", \"Runtime (Node.JS version, browser user agent)\"},\n    {\"pthreads\", \"pthread support\"},\n    {\"shared_memory\", \"shared memory support\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc emscripten_info_desc = {\n    \"sys._emscripten_info\",     /* name */\n    emscripten_info__doc__ ,    /* doc */\n    emscripten_info_fields,     /* fields */\n    4\n};\n\nEM_JS(char *, _Py_emscripten_runtime, (void), {\n    var info;\n    if (typeof navigator == 'object') {\n        info = navigator.userAgent;\n    } else if (typeof process == 'object') {\n        info = \"Node.js \".concat(process.version);\n    } else {\n        info = \"UNKNOWN\";\n    }\n    var len = lengthBytesUTF8(info) + 1;\n    var res = _malloc(len);\n    if (res) stringToUTF8(info, res, len);\n#if __wasm64__\n    return BigInt(res);\n#else\n    return res;\n#endif\n});\n\nstatic PyObject *\nmake_emscripten_info(void)\n{\n    PyObject *emscripten_info = NULL;\n    PyObject *version = NULL;\n    char *ua;\n    int pos = 0;\n\n    emscripten_info = PyStructSequence_New(EmscriptenInfoType);\n    if (emscripten_info == NULL) {\n        return NULL;\n    }\n\n    version = Py_BuildValue(\"(iii)\",\n        __EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__);\n    if (version == NULL) {\n        goto error;\n    }\n    PyStructSequence_SET_ITEM(emscripten_info, pos++, version);\n\n    ua = _Py_emscripten_runtime();\n    if (ua != NULL) {\n        PyObject *oua = PyUnicode_DecodeUTF8(ua, strlen(ua), \"strict\");\n        free(ua);\n        if (oua == NULL) {\n            goto error;\n        }\n        PyStructSequence_SET_ITEM(emscripten_info, pos++, oua);\n    } else {\n        PyStructSequence_SET_ITEM(emscripten_info, pos++, Py_NewRef(Py_None));\n    }\n\n#define SetBoolItem(flag) \\\n    PyStructSequence_SET_ITEM(emscripten_info, pos++, PyBool_FromLong(flag))\n\n#ifdef __EMSCRIPTEN_PTHREADS__\n    SetBoolItem(1);\n#else\n    SetBoolItem(0);\n#endif\n\n#ifdef __EMSCRIPTEN_SHARED_MEMORY__\n    SetBoolItem(1);\n#else\n    SetBoolItem(0);\n#endif\n\n#undef SetBoolItem\n\n    if (PyErr_Occurred()) {\n        goto error;\n    }\n    return emscripten_info;\n\n  error:\n    Py_CLEAR(emscripten_info);\n    return NULL;\n}\n\n#endif // __EMSCRIPTEN__\n\nstatic struct PyModuleDef sysmodule = {\n    PyModuleDef_HEAD_INIT,\n    \"sys\",\n    sys_doc,\n    -1, /* multiple \"initialization\" just copies the module dict. */\n    sys_methods,\n    NULL,\n    NULL,\n    NULL,\n    NULL\n};\n\n/* Updating the sys namespace, returning NULL pointer on error */\n#define SET_SYS(key, value)                                \\\n    do {                                                   \\\n        PyObject *v = (value);                             \\\n        if (v == NULL) {                                   \\\n            goto err_occurred;                             \\\n        }                                                  \\\n        res = PyDict_SetItemString(sysdict, key, v);       \\\n        Py_DECREF(v);                                      \\\n        if (res < 0) {                                     \\\n            goto err_occurred;                             \\\n        }                                                  \\\n    } while (0)\n\n#define SET_SYS_FROM_STRING(key, value) \\\n        SET_SYS(key, PyUnicode_FromString(value))\n\nstatic PyStatus\n_PySys_InitCore(PyThreadState *tstate, PyObject *sysdict)\n{\n    PyObject *version_info;\n    int res;\n    PyInterpreterState *interp = tstate->interp;\n\n    /* stdin/stdout/stderr are set in pylifecycle.c */\n\n#define COPY_SYS_ATTR(tokey, fromkey) \\\n        SET_SYS(tokey, PyMapping_GetItemString(sysdict, fromkey))\n\n    COPY_SYS_ATTR(\"__displayhook__\", \"displayhook\");\n    COPY_SYS_ATTR(\"__excepthook__\", \"excepthook\");\n    COPY_SYS_ATTR(\"__breakpointhook__\", \"breakpointhook\");\n    COPY_SYS_ATTR(\"__unraisablehook__\", \"unraisablehook\");\n\n#undef COPY_SYS_ATTR\n\n    SET_SYS_FROM_STRING(\"version\", Py_GetVersion());\n    SET_SYS(\"hexversion\", PyLong_FromLong(PY_VERSION_HEX));\n    SET_SYS(\"_git\", Py_BuildValue(\"(szz)\", \"CPython\", _Py_gitidentifier(),\n                                  _Py_gitversion()));\n    SET_SYS_FROM_STRING(\"_framework\", _PYTHONFRAMEWORK);\n    SET_SYS(\"api_version\", PyLong_FromLong(PYTHON_API_VERSION));\n    SET_SYS_FROM_STRING(\"copyright\", Py_GetCopyright());\n    SET_SYS_FROM_STRING(\"platform\", Py_GetPlatform());\n    SET_SYS(\"maxsize\", PyLong_FromSsize_t(PY_SSIZE_T_MAX));\n    SET_SYS(\"float_info\", PyFloat_GetInfo());\n    SET_SYS(\"int_info\", PyLong_GetInfo());\n    /* initialize hash_info */\n    if (_PyStructSequence_InitBuiltin(interp, &Hash_InfoType,\n                                      &hash_info_desc) < 0)\n    {\n        goto type_init_failed;\n    }\n    SET_SYS(\"hash_info\", get_hash_info(tstate));\n    SET_SYS(\"maxunicode\", PyLong_FromLong(0x10FFFF));\n    SET_SYS(\"builtin_module_names\", list_builtin_module_names());\n    SET_SYS(\"stdlib_module_names\", list_stdlib_module_names());\n#if PY_BIG_ENDIAN\n    SET_SYS_FROM_STRING(\"byteorder\", \"big\");\n#else\n    SET_SYS_FROM_STRING(\"byteorder\", \"little\");\n#endif\n\n#ifdef MS_COREDLL\n    SET_SYS(\"dllhandle\", PyLong_FromVoidPtr(PyWin_DLLhModule));\n    SET_SYS_FROM_STRING(\"winver\", PyWin_DLLVersionString);\n#endif\n#ifdef ABIFLAGS\n    SET_SYS_FROM_STRING(\"abiflags\", ABIFLAGS);\n#endif\n\n#define ENSURE_INFO_TYPE(TYPE, DESC) \\\n    do { \\\n        if (_PyStructSequence_InitBuiltinWithFlags( \\\n                interp, &TYPE, &DESC, Py_TPFLAGS_DISALLOW_INSTANTIATION) < 0) { \\\n            goto type_init_failed; \\\n        } \\\n    } while (0)\n\n    /* version_info */\n    ENSURE_INFO_TYPE(VersionInfoType, version_info_desc);\n    version_info = make_version_info(tstate);\n    SET_SYS(\"version_info\", version_info);\n\n    /* implementation */\n    SET_SYS(\"implementation\", make_impl_info(version_info));\n\n    // sys.flags: updated in-place later by _PySys_UpdateConfig()\n    ENSURE_INFO_TYPE(FlagsType, flags_desc);\n    SET_SYS(\"flags\", make_flags(tstate->interp));\n\n#if defined(MS_WINDOWS)\n    /* getwindowsversion */\n    ENSURE_INFO_TYPE(WindowsVersionType, windows_version_desc);\n\n    SET_SYS_FROM_STRING(\"_vpath\", VPATH);\n#endif\n\n#undef ENSURE_INFO_TYPE\n\n    /* float repr style: 0.03 (short) vs 0.029999999999999999 (legacy) */\n#if _PY_SHORT_FLOAT_REPR == 1\n    SET_SYS_FROM_STRING(\"float_repr_style\", \"short\");\n#else\n    SET_SYS_FROM_STRING(\"float_repr_style\", \"legacy\");\n#endif\n\n    SET_SYS(\"thread_info\", PyThread_GetInfo());\n\n    /* initialize asyncgen_hooks */\n    if (_PyStructSequence_InitBuiltin(interp, &AsyncGenHooksType,\n                                      &asyncgen_hooks_desc) < 0)\n    {\n        goto type_init_failed;\n    }\n\n#ifdef __EMSCRIPTEN__\n    if (EmscriptenInfoType == NULL) {\n        EmscriptenInfoType = PyStructSequence_NewType(&emscripten_info_desc);\n        if (EmscriptenInfoType == NULL) {\n            goto type_init_failed;\n        }\n    }\n    SET_SYS(\"_emscripten_info\", make_emscripten_info());\n#endif\n\n    /* adding sys.path_hooks and sys.path_importer_cache */\n    SET_SYS(\"meta_path\", PyList_New(0));\n    SET_SYS(\"path_importer_cache\", PyDict_New());\n    SET_SYS(\"path_hooks\", PyList_New(0));\n\n    if (_PyErr_Occurred(tstate)) {\n        goto err_occurred;\n    }\n    return _PyStatus_OK();\n\ntype_init_failed:\n    return _PyStatus_ERR(\"failed to initialize a type\");\n\nerr_occurred:\n    return _PyStatus_ERR(\"can't initialize sys module\");\n}\n\nstatic int\nsys_add_xoption(PyObject *opts, const wchar_t *s)\n{\n    PyObject *name, *value = NULL;\n\n    const wchar_t *name_end = wcschr(s, L'=');\n    if (!name_end) {\n        name = PyUnicode_FromWideChar(s, -1);\n        if (name == NULL) {\n            goto error;\n        }\n        value = Py_NewRef(Py_True);\n    }\n    else {\n        name = PyUnicode_FromWideChar(s, name_end - s);\n        if (name == NULL) {\n            goto error;\n        }\n        value = PyUnicode_FromWideChar(name_end + 1, -1);\n        if (value == NULL) {\n            goto error;\n        }\n    }\n    if (PyDict_SetItem(opts, name, value) < 0) {\n        goto error;\n    }\n    Py_DECREF(name);\n    Py_DECREF(value);\n    return 0;\n\nerror:\n    Py_XDECREF(name);\n    Py_XDECREF(value);\n    return -1;\n}\n\n\nstatic PyObject*\nsys_create_xoptions_dict(const PyConfig *config)\n{\n    Py_ssize_t nxoption = config->xoptions.length;\n    wchar_t * const * xoptions = config->xoptions.items;\n    PyObject *dict = PyDict_New();\n    if (dict == NULL) {\n        return NULL;\n    }\n\n    for (Py_ssize_t i=0; i < nxoption; i++) {\n        const wchar_t *option = xoptions[i];\n        if (sys_add_xoption(dict, option) < 0) {\n            Py_DECREF(dict);\n            return NULL;\n        }\n    }\n\n    return dict;\n}\n\n\n// Update sys attributes for a new PyConfig configuration.\n// This function also adds attributes that _PySys_InitCore() didn't add.\nint\n_PySys_UpdateConfig(PyThreadState *tstate)\n{\n    PyInterpreterState *interp = tstate->interp;\n    PyObject *sysdict = interp->sysdict;\n    const PyConfig *config = _PyInterpreterState_GetConfig(interp);\n    int res;\n\n#define COPY_LIST(KEY, VALUE) \\\n        SET_SYS(KEY, _PyWideStringList_AsList(&(VALUE)));\n\n#define SET_SYS_FROM_WSTR(KEY, VALUE) \\\n        SET_SYS(KEY, PyUnicode_FromWideChar(VALUE, -1));\n\n#define COPY_WSTR(SYS_ATTR, WSTR) \\\n    if (WSTR != NULL) { \\\n        SET_SYS_FROM_WSTR(SYS_ATTR, WSTR); \\\n    }\n\n    if (config->module_search_paths_set) {\n        COPY_LIST(\"path\", config->module_search_paths);\n    }\n\n    COPY_WSTR(\"executable\", config->executable);\n    COPY_WSTR(\"_base_executable\", config->base_executable);\n    COPY_WSTR(\"prefix\", config->prefix);\n    COPY_WSTR(\"base_prefix\", config->base_prefix);\n    COPY_WSTR(\"exec_prefix\", config->exec_prefix);\n    COPY_WSTR(\"base_exec_prefix\", config->base_exec_prefix);\n    COPY_WSTR(\"platlibdir\", config->platlibdir);\n\n    if (config->pycache_prefix != NULL) {\n        SET_SYS_FROM_WSTR(\"pycache_prefix\", config->pycache_prefix);\n    } else {\n        if (PyDict_SetItemString(sysdict, \"pycache_prefix\", Py_None) < 0) {\n            return -1;\n        }\n    }\n\n    COPY_LIST(\"argv\", config->argv);\n    COPY_LIST(\"orig_argv\", config->orig_argv);\n    COPY_LIST(\"warnoptions\", config->warnoptions);\n\n    SET_SYS(\"_xoptions\", sys_create_xoptions_dict(config));\n\n    const wchar_t *stdlibdir = _Py_GetStdlibDir();\n    if (stdlibdir != NULL) {\n        SET_SYS_FROM_WSTR(\"_stdlib_dir\", stdlibdir);\n    }\n    else {\n        if (PyDict_SetItemString(sysdict, \"_stdlib_dir\", Py_None) < 0) {\n            return -1;\n        }\n    }\n\n#undef SET_SYS_FROM_WSTR\n#undef COPY_LIST\n#undef COPY_WSTR\n\n    // sys.flags\n    PyObject *flags = _PySys_GetObject(interp, \"flags\"); // borrowed ref\n    if (flags == NULL) {\n        if (!_PyErr_Occurred(tstate)) {\n            _PyErr_SetString(tstate, PyExc_RuntimeError, \"lost sys.flags\");\n        }\n        return -1;\n    }\n    if (set_flags_from_config(interp, flags) < 0) {\n        return -1;\n    }\n\n    SET_SYS(\"dont_write_bytecode\", PyBool_FromLong(!config->write_bytecode));\n\n    if (_PyErr_Occurred(tstate)) {\n        goto err_occurred;\n    }\n\n    return 0;\n\nerr_occurred:\n    return -1;\n}\n\n#undef SET_SYS\n#undef SET_SYS_FROM_STRING\n\n\n/* Set up a preliminary stderr printer until we have enough\n   infrastructure for the io module in place.\n\n   Use UTF-8/backslashreplace and ignore EAGAIN errors. */\nstatic PyStatus\n_PySys_SetPreliminaryStderr(PyObject *sysdict)\n{\n    PyObject *pstderr = PyFile_NewStdPrinter(fileno(stderr));\n    if (pstderr == NULL) {\n        goto error;\n    }\n    if (PyDict_SetItem(sysdict, &_Py_ID(stderr), pstderr) < 0) {\n        goto error;\n    }\n    if (PyDict_SetItemString(sysdict, \"__stderr__\", pstderr) < 0) {\n        goto error;\n    }\n    Py_DECREF(pstderr);\n    return _PyStatus_OK();\n\nerror:\n    Py_XDECREF(pstderr);\n    return _PyStatus_ERR(\"can't set preliminary stderr\");\n}\n\nPyObject *_Py_CreateMonitoringObject(void);\n\n/* Create sys module without all attributes.\n   _PySys_UpdateConfig() should be called later to add remaining attributes. */\nPyStatus\n_PySys_Create(PyThreadState *tstate, PyObject **sysmod_p)\n{\n    assert(!_PyErr_Occurred(tstate));\n\n    PyInterpreterState *interp = tstate->interp;\n\n    PyObject *modules = _PyImport_InitModules(interp);\n    if (modules == NULL) {\n        goto error;\n    }\n\n    PyObject *sysmod = _PyModule_CreateInitialized(&sysmodule, PYTHON_API_VERSION);\n    if (sysmod == NULL) {\n        return _PyStatus_ERR(\"failed to create a module object\");\n    }\n#ifdef Py_GIL_DISABLED\n    PyUnstable_Module_SetGIL(sysmod, Py_MOD_GIL_NOT_USED);\n#endif\n\n    PyObject *sysdict = PyModule_GetDict(sysmod);\n    if (sysdict == NULL) {\n        goto error;\n    }\n    interp->sysdict = Py_NewRef(sysdict);\n\n    interp->sysdict_copy = PyDict_Copy(sysdict);\n    if (interp->sysdict_copy == NULL) {\n        goto error;\n    }\n\n    if (PyDict_SetItemString(sysdict, \"modules\", modules) < 0) {\n        goto error;\n    }\n\n    PyStatus status = _PySys_SetPreliminaryStderr(sysdict);\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n\n    status = _PySys_InitCore(tstate, sysdict);\n    if (_PyStatus_EXCEPTION(status)) {\n        return status;\n    }\n\n    if (_PyImport_FixupBuiltin(tstate, sysmod, \"sys\", modules) < 0) {\n        goto error;\n    }\n\n    PyObject *monitoring = _Py_CreateMonitoringObject();\n    if (monitoring == NULL) {\n        goto error;\n    }\n    int err = PyDict_SetItemString(sysdict, \"monitoring\", monitoring);\n    Py_DECREF(monitoring);\n    if (err < 0) {\n        goto error;\n    }\n\n    assert(!_PyErr_Occurred(tstate));\n\n    *sysmod_p = sysmod;\n    return _PyStatus_OK();\n\nerror:\n    return _PyStatus_ERR(\"can't initialize sys module\");\n}\n\n\nvoid\n_PySys_FiniTypes(PyInterpreterState *interp)\n{\n    _PyStructSequence_FiniBuiltin(interp, &VersionInfoType);\n    _PyStructSequence_FiniBuiltin(interp, &FlagsType);\n#if defined(MS_WINDOWS)\n    _PyStructSequence_FiniBuiltin(interp, &WindowsVersionType);\n#endif\n    _PyStructSequence_FiniBuiltin(interp, &Hash_InfoType);\n    _PyStructSequence_FiniBuiltin(interp, &AsyncGenHooksType);\n#ifdef __EMSCRIPTEN__\n    if (_Py_IsMainInterpreter(interp)) {\n        Py_CLEAR(EmscriptenInfoType);\n    }\n#endif\n}\n\n\nstatic PyObject *\nmakepathobject(const wchar_t *path, wchar_t delim)\n{\n    int i, n;\n    const wchar_t *p;\n    PyObject *v, *w;\n\n    n = 1;\n    p = path;\n    while ((p = wcschr(p, delim)) != NULL) {\n        n++;\n        p++;\n    }\n    v = PyList_New(n);\n    if (v == NULL)\n        return NULL;\n    for (i = 0; ; i++) {\n        p = wcschr(path, delim);\n        if (p == NULL)\n            p = path + wcslen(path); /* End of string */\n        w = PyUnicode_FromWideChar(path, (Py_ssize_t)(p - path));\n        if (w == NULL) {\n            Py_DECREF(v);\n            return NULL;\n        }\n        PyList_SET_ITEM(v, i, w);\n        if (*p == '\\0')\n            break;\n        path = p+1;\n    }\n    return v;\n}\n\n// Removed in Python 3.13 API, but kept for the stable ABI\nPyAPI_FUNC(void)\nPySys_SetPath(const wchar_t *path)\n{\n    PyObject *v;\n    if ((v = makepathobject(path, DELIM)) == NULL)\n        Py_FatalError(\"can't create sys.path\");\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    if (sys_set_object(interp, &_Py_ID(path), v) != 0) {\n        Py_FatalError(\"can't assign sys.path\");\n    }\n    Py_DECREF(v);\n}\n\nstatic PyObject *\nmake_sys_argv(int argc, wchar_t * const * argv)\n{\n    PyObject *list = PyList_New(argc);\n    if (list == NULL) {\n        return NULL;\n    }\n\n    for (Py_ssize_t i = 0; i < argc; i++) {\n        PyObject *v = PyUnicode_FromWideChar(argv[i], -1);\n        if (v == NULL) {\n            Py_DECREF(list);\n            return NULL;\n        }\n        PyList_SET_ITEM(list, i, v);\n    }\n    return list;\n}\n\nvoid\nPySys_SetArgvEx(int argc, wchar_t **argv, int updatepath)\n{\n    wchar_t* empty_argv[1] = {L\"\"};\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    if (argc < 1 || argv == NULL) {\n        /* Ensure at least one (empty) argument is seen */\n        argv = empty_argv;\n        argc = 1;\n    }\n\n    PyObject *av = make_sys_argv(argc, argv);\n    if (av == NULL) {\n        Py_FatalError(\"no mem for sys.argv\");\n    }\n    if (sys_set_object_str(tstate->interp, \"argv\", av) != 0) {\n        Py_DECREF(av);\n        Py_FatalError(\"can't assign sys.argv\");\n    }\n    Py_DECREF(av);\n\n    if (updatepath) {\n        /* If argv[0] is not '-c' nor '-m', prepend argv[0] to sys.path.\n           If argv[0] is a symlink, use the real path. */\n        const PyWideStringList argv_list = {.length = argc, .items = argv};\n        PyObject *path0 = NULL;\n        if (_PyPathConfig_ComputeSysPath0(&argv_list, &path0)) {\n            if (path0 == NULL) {\n                Py_FatalError(\"can't compute path0 from argv\");\n            }\n\n            PyObject *sys_path = _PySys_GetAttr(tstate, &_Py_ID(path));\n            if (sys_path != NULL) {\n                if (PyList_Insert(sys_path, 0, path0) < 0) {\n                    Py_DECREF(path0);\n                    Py_FatalError(\"can't prepend path0 to sys.path\");\n                }\n            }\n            Py_DECREF(path0);\n        }\n    }\n}\n\nvoid\nPySys_SetArgv(int argc, wchar_t **argv)\n{\n_Py_COMP_DIAG_PUSH\n_Py_COMP_DIAG_IGNORE_DEPR_DECLS\n    PySys_SetArgvEx(argc, argv, Py_IsolatedFlag == 0);\n_Py_COMP_DIAG_POP\n}\n\n/* Reimplementation of PyFile_WriteString() no calling indirectly\n   PyErr_CheckSignals(): avoid the call to PyObject_Str(). */\n\nstatic int\nsys_pyfile_write_unicode(PyObject *unicode, PyObject *file)\n{\n    if (file == NULL)\n        return -1;\n    assert(unicode != NULL);\n    PyObject *result = PyObject_CallMethodOneArg(file, &_Py_ID(write), unicode);\n    if (result == NULL) {\n        return -1;\n    }\n    Py_DECREF(result);\n    return 0;\n}\n\nstatic int\nsys_pyfile_write(const char *text, PyObject *file)\n{\n    PyObject *unicode = NULL;\n    int err;\n\n    if (file == NULL)\n        return -1;\n\n    unicode = PyUnicode_FromString(text);\n    if (unicode == NULL)\n        return -1;\n\n    err = sys_pyfile_write_unicode(unicode, file);\n    Py_DECREF(unicode);\n    return err;\n}\n\n/* APIs to write to sys.stdout or sys.stderr using a printf-like interface.\n   Adapted from code submitted by Just van Rossum.\n\n   PySys_WriteStdout(format, ...)\n   PySys_WriteStderr(format, ...)\n\n      The first function writes to sys.stdout; the second to sys.stderr.  When\n      there is a problem, they write to the real (C level) stdout or stderr;\n      no exceptions are raised.\n\n      PyErr_CheckSignals() is not called to avoid the execution of the Python\n      signal handlers: they may raise a new exception whereas sys_write()\n      ignores all exceptions.\n\n      Both take a printf-style format string as their first argument followed\n      by a variable length argument list determined by the format string.\n\n      *** WARNING ***\n\n      The format should limit the total size of the formatted output string to\n      1000 bytes.  In particular, this means that no unrestricted \"%s\" formats\n      should occur; these should be limited using \"%.<N>s where <N> is a\n      decimal number calculated so that <N> plus the maximum size of other\n      formatted text does not exceed 1000 bytes.  Also watch out for \"%f\",\n      which can print hundreds of digits for very large numbers.\n\n */\n\nstatic void\nsys_write(PyObject *key, FILE *fp, const char *format, va_list va)\n{\n    PyObject *file;\n    char buffer[1001];\n    int written;\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    PyObject *exc = _PyErr_GetRaisedException(tstate);\n    file = _PySys_GetAttr(tstate, key);\n    written = PyOS_vsnprintf(buffer, sizeof(buffer), format, va);\n    if (sys_pyfile_write(buffer, file) != 0) {\n        _PyErr_Clear(tstate);\n        fputs(buffer, fp);\n    }\n    if (written < 0 || (size_t)written >= sizeof(buffer)) {\n        const char *truncated = \"... truncated\";\n        if (sys_pyfile_write(truncated, file) != 0)\n            fputs(truncated, fp);\n    }\n    _PyErr_SetRaisedException(tstate, exc);\n}\n\nvoid\nPySys_WriteStdout(const char *format, ...)\n{\n    va_list va;\n\n    va_start(va, format);\n    sys_write(&_Py_ID(stdout), stdout, format, va);\n    va_end(va);\n}\n\nvoid\nPySys_WriteStderr(const char *format, ...)\n{\n    va_list va;\n\n    va_start(va, format);\n    sys_write(&_Py_ID(stderr), stderr, format, va);\n    va_end(va);\n}\n\nstatic void\nsys_format(PyObject *key, FILE *fp, const char *format, va_list va)\n{\n    PyObject *file, *message;\n    const char *utf8;\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    PyObject *exc = _PyErr_GetRaisedException(tstate);\n    file = _PySys_GetAttr(tstate, key);\n    message = PyUnicode_FromFormatV(format, va);\n    if (message != NULL) {\n        if (sys_pyfile_write_unicode(message, file) != 0) {\n            _PyErr_Clear(tstate);\n            utf8 = PyUnicode_AsUTF8(message);\n            if (utf8 != NULL)\n                fputs(utf8, fp);\n        }\n        Py_DECREF(message);\n    }\n    _PyErr_SetRaisedException(tstate, exc);\n}\n\nvoid\nPySys_FormatStdout(const char *format, ...)\n{\n    va_list va;\n\n    va_start(va, format);\n    sys_format(&_Py_ID(stdout), stdout, format, va);\n    va_end(va);\n}\n\nvoid\nPySys_FormatStderr(const char *format, ...)\n{\n    va_list va;\n\n    va_start(va, format);\n    sys_format(&_Py_ID(stderr), stderr, format, va);\n    va_end(va);\n}\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wanalyzer-file-leak", "taxa": [{"id": "775", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "leak of FILE 'from'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2526, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 2526, "snippet": {"text": "        if (ret != 0) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2520, "startColumn": 18, "endColumn": 45}, "contextRegion": {"startLine": 2520, "snippet": {"text": "    FILE* from = fopen(parent_filename, \"r\");\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "opened here"}}, "kinds": ["acquire", "resource"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2521, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2521, "snippet": {"text": "    if (!from) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "assuming 'from' is non-NULL"}}, "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2521, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2521, "snippet": {"text": "    if (!from) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "following 'false' branch (when 'from' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2524, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 2524, "snippet": {"text": "    if (perf_map_state.perf_map == NULL) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2524, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2524, "snippet": {"text": "    if (perf_map_state.perf_map == NULL) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2525, "startColumn": 9, "endColumn": 12}, "contextRegion": {"startLine": 2525, "snippet": {"text": "        int ret = PyUnstable_PerfMapState_Init();\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2526, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 2526, "snippet": {"text": "        if (ret != 0) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "following 'true' branch (when 'ret != 0')..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2526, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 2526, "snippet": {"text": "        if (ret != 0) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "'from' leaks here; was opened at (1)"}}, "kinds": ["danger"], "nestingLevel": 1}]}]}]}, {"ruleId": "-Wanalyzer-malloc-leak", "taxa": [{"id": "401", "toolComponent": {"name": "cwe"}}], "level": "warning", "message": {"text": "leak of 'from'"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2526, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 2526, "snippet": {"text": "        if (ret != 0) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}]}], "codeFlows": [{"threadFlows": [{"locations": [{"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2520, "startColumn": 18, "endColumn": 45}, "contextRegion": {"startLine": 2520, "snippet": {"text": "    FILE* from = fopen(parent_filename, \"r\");\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "allocated here"}}, "kinds": ["acquire", "memory"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2521, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2521, "snippet": {"text": "    if (!from) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "assuming 'from' is non-NULL"}}, "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2521, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2521, "snippet": {"text": "    if (!from) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "following 'false' branch (when 'from' is non-NULL)..."}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2524, "startColumn": 5, "endColumn": 7}, "contextRegion": {"startLine": 2524, "snippet": {"text": "    if (perf_map_state.perf_map == NULL) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "false"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2524, "startColumn": 8, "endColumn": 9}, "contextRegion": {"startLine": 2524, "snippet": {"text": "    if (perf_map_state.perf_map == NULL) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "following 'true' branch..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2525, "startColumn": 9, "endColumn": 12}, "contextRegion": {"startLine": 2525, "snippet": {"text": "        int ret = PyUnstable_PerfMapState_Init();\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2526, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 2526, "snippet": {"text": "        if (ret != 0) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "following 'true' branch (when 'ret != 0')..."}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "...to here"}}, "kinds": ["branch", "true"], "nestingLevel": 1}, {"location": {"physicalLocation": {"artifactLocation": {"uri": "./Python/sysmodule.c", "uriBaseId": "PWD"}, "region": {"startLine": 2526, "startColumn": 12, "endColumn": 13}, "contextRegion": {"startLine": 2526, "snippet": {"text": "        if (ret != 0) {\n"}}}, "logicalLocations": [{"name": "PyUnstable_CopyPerfMapFile", "fullyQualifiedName": "PyUnstable_CopyPerfMapFile", "decoratedName": "PyUnstable_CopyPerfMapFile", "kind": "function"}], "message": {"text": "'from' leaks here; was allocated at (1)"}}, "kinds": ["danger"], "nestingLevel": 1}]}]}]}]}]}
